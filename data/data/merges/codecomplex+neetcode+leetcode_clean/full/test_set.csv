code,complexity
"class Solution2(object):
    def copyRandomList(self, head):
        dummy = Node(0)
        current, prev, copies = head, dummy, {}

        while current:
            copied = Node(current.val)
            copies[current] = copied
            prev.next = copied
            prev, current = prev.__next__, current.__next__

        current = head
        while current:
            if current.random:
                copies[current].random = copies[current.random]
            current = current.__next__

        return dummy.__next__",O(n)
"import itertools


class Solution(object):
    def countVowelPermutation(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % MOD \
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[0, 1, 1, 0, 1],
             [1, 0, 1, 0, 0],
             [0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0],
             [0, 0, 1, 1, 0]]
        return sum(map(sum, matrix_expo(T, n-1))) % MOD",O(logn)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n,m = mints()
a = list(mints())
b = list(mints())
l = [None]*(n+m)
r = [None]*(n+m)
c = [0]*(n+m)
x = None
for i in range(len(a)):
	l[i] = x
	if b[i] == 1:
		x = i
x = None
for i in range(len(a)-1,-1,-1):
	r[i] = x
	if b[i] == 1:
		x = i
for i in range(len(a)):
	if b[i] == 0:
		aa = a[i]
		ll = l[i]
		rr = r[i]
		if ll == None:
			if rr != None:
				c[rr] += 1
		elif rr == None:
			c[ll] += 1
		else:
			if aa-a[ll] <= a[rr]-aa:
				c[ll] += 1
			else:
				c[rr] += 1

for i in range(len(a)):
	if b[i] == 1:
		print(c[i], end=' ')
",O(n)
"import collections
from functools import reduce



class Solution2(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).items() if c == 2), 0)",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        first = last = -1
        result = float(""inf"")
        i, prev, head = 0, head.val, head.__next__
        while head.__next__:
            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.__next__
        return [result, last-first] if last != first else [-1, -1]",O(n)
"import math

s = input()
t = input()
p1, p2, m1, m2, q = 0, 0, 0, 0, 0
for i in s:
 if i == '+':
  p1 += 1
 else:
  m1 += 1
for i in t:
 if i == '+':
  p2 += 1
 elif i == '-':
  m2 += 1
 else:
  q += 1
dp, dm = p1 - p2, m1 - m2
if dp < 0 or dm < 0:
 print(0.0)
else:
 ans = (math.factorial(q) / (math.factorial(dp) * math.factorial(dm))) / math.pow(2, q)
 print(ans)",np
"import math

def gaosi(x):
    if (x==1):
        return 1
    else:
        return ((1+x)*x)/2

def calc(mid, total, left):
    return gaosi(mid) - (total - mid) - left

def main():
    x, left = map(int, input().split())
    if (x == 1 and left == 1):
        print(0)
    else:
        l = 1
        r = x
        while (True):
            mid = math.floor((l + r) / 2)
            result = calc(mid, x, left)
            if (result == 0):
                print(x - mid)
                break
            elif (result > 0):
                r = mid
            elif (result  < left):
                l = mid

if __name__ == ""__main__"":
    main()",O(logn)
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",O(n)
"import operator

class Solution(object):
    def evalRPN(self, tokens):
        numerals, operators = [], {""+"": operator.add, ""-"": operator.sub, ""*"": operator.mul, ""/"": operator.div}
        for token in tokens:
            if token not in operators:
                numerals.append(int(token))
            else:
                y, x = numerals.pop(), numerals.pop()
                numerals.append(int(operators[token](x * 1.0, y)))
        return numerals.pop()",O(n)
"from sys import stdin, stdout
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

a, b = mp()
c = 0
x = 0
while not (c>=b and c-b+x==a):
    x += 1
    c += x
print(a-x)",O(logn)
"if __name__ == '__main__':
    n, m, k = map(int, input().split())
    aa = list(map(int,input().split()))
    ans = 0
    for start in range(m):
        ac = aa[:]
        for i in range(start, n, m):
            ac[i] -= k
        cur = 0
        for i in range(start, n):
            if i%m == start:
                cur = max(ac[i] + cur, ac[i])
            else:
                cur += ac[i]
            ans = max(cur, ans)
    print(ans)
",O(n ^ 2)
"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))
extensions = list(map(int, input().split()))
extensions.sort(reverse=True)
devices_left = n_dvics - n_sokts
extnson_used = 0
i = 0
while devices_left > 0 and n_extnson > 0:
    devices_left += 1
    extnson_siez = extensions[i]
    devices_left -= extnson_siez
    extnson_used += 1
    n_extnson -= 1
    i += 1

if devices_left > 0:
    print(-1)
else:
    print(extnson_used)
",O(nlogn)
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2

n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])

cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0

for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2

print((n*(n+1))//2 - cnt1)
",O(n)
"import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",O(n ^ 3)
"debug = 0
BIG = 10 ** 9 + 1

input = raw_input

def prof(f):
    return f

def report(f):
    def new_f(x):
        res = f(x)

        return res

    return new_f if debug else f

def mcheck(a, pairs):
    m = len(a[0])
    allm = 2 ** m - 1

    subs = {i: {i} for i in range(allm + 1)}

    for i in range(allm + 1):
        for j in range(i):
            if i | j == i:
                subs[i].add(j)

    mx = [max(aa) for aa in a]

    @prof
    def check(v):
        masks = {0: -1}
        done = [False] * (allm + 1)
        for i, aa in enumerate(a):
            if mx[i] < v:
                continue
            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)

            if not done[c]:
                for cc in subs[c]:
                    if allm - cc in masks:
                        other = masks[allm - c]
                        pairs[v] = i, other
                        return True
                    masks[cc] = i
                    done[cc] = True

        return False

    return check

@prof
def go():
    n, m = map(int, input().split())

    a = []

    uniq = set()
    for _ in range(n):
        aa = tuple(map(int, input().split()))

        a.append(aa)
        uniq.update(aa)

    uniq = sorted(uniq)
    pairs = {0: (0, 0)}
    check = mcheck(a, pairs)
    l = 0
    r = len(uniq) - 1
    while l != r:
        if debug: print(l, r)
        if l + 1 == r:
            if check(uniq[r]):
                l = r
            else:
                r = l
            continue
        c = (l + r) // 2
        if check(uniq[c]):
            l = c
        else:
            r = c

    l = uniq[l]
    if debug: print(l, pairs[l])
    if l not in pairs:
        check(l)
    a = pairs[l][0]
    b = pairs[l][1]
    if b == -1:
        b = a

    print(""%d %d"" % (a + 1, b + 1))

go()
",np
"class Solution2(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left, right = 0, len(LIS) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if LIS[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target

        for num in nums:
            insert(num)

        return len(LIS)",O(nlogn)
"class Solution(object):
    def losingPlayer(self, x, y):
        return ""Alice"" if min(x, y//4)%2 else ""Bob""",O(1)
"l,r = map(int,input().split())
ans = l ^ r
x = bin(ans)[1:]
if ans == 0:
    print(0)
else:
    ptr = -1
    po = 0
    while True:
        if( x[ptr] == '0') :
            ans += 2**po
        po += 1
        ptr-=1
        if( ptr == -len(x)-1 ):
            break

    print(ans)
",O(logn)
"print(""?"",0,0)
e=int(input())
astr=""000000000000000000000000000000""
bstr=""000000000000000000000000000000""
abig=e
for i in range(30):
    if abig==0:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
        e=int(input())
        if e==1:
            continue
        else:
            if i<29:
                astr=astr[:i]+""1""+astr[i+1:]
                bstr=bstr[:i]+""1""+bstr[i+1:]
            else:
                astr=astr[:i]+""1""
                bstr=bstr[:i]+""1""
    else:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))
        e=int(input())
        if e==-abig:
            if abig==1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                else:
                    astr=astr[:i]+""1""
            else:
                if i<29:
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    bstr=bstr[:i]+""1""
            print(""?"",int(astr,2),int(bstr,2))
            abig=int(input())
        else:
            print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
            e=int(input())
            if e==-1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    astr=astr[:i]+""1""
                    bstr=bstr[:i]+""1""
print(""!"",int(astr,2),int(bstr,2))",O(logn)
"x,y=map(int,input().strip().split())
if(abs(x-y)<2):
    print(-1)
else:
    k=[]
    for i in range(x,y+1):
        if(i%2==0):
            k.append(i)
            if(i+1<y):
                k.append(i+1)
                k.append(i+2)
                break
    if(len(k)==3):
        print("" "".join(str(t) for t in k))
    else:
        print(-1)",O(1)
"from sys import stdin
from collections import defaultdict
import heapq

n = int(stdin.readline())
a = [[] for _ in range(n)]
for _ in range(n-1):
    e = stdin.readline().split(' ')
    u, v = int(e[0]), int(e[1])
    a[u-1].append(v-1)
    a[v-1].append(u-1)

leaves = [i for i in range(n) if len(a[i]) == 1]

def dfs_from(root):
    depth = defaultdict(int)
    child = {}
    parent = defaultdict(lambda: -1)
    stack = [root]
    visited = [False for _ in range(n)]
    while len(stack) > 0:
        crt = stack[-1]
        if visited[crt]:
            stack.pop(-1)
            if len(a[crt]) > 1:
                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]
                                              if c != parent[crt]],
                                             key=lambda x: x[1])
            else:
                child[crt] = -1
                depth[crt] = 0
            continue

        visited[crt] = True
        for next in a[crt]:
            if next != parent[crt]:
                stack.append(next)
                parent[next] = crt

    return depth, child

first_choice = leaves[0]
d1, child1 = dfs_from(first_choice)

root = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],
           key=lambda leaf_depth: leaf_depth[1])[0]
while child1[root] != -1:
    root = child1[root]
depth, child = dfs_from(root)

solution = [1]
pq = []
for k, v in depth.items():
    heapq.heappush(pq, (-v, k))

seen = [False for _ in range(n)]
seen[root] = True

while len(pq) > 0:
    _, best = heapq.heappop(pq)
    if seen[best]:
        continue
    path = []
    c = best
    s = 0
    while c != -1:
        seen[c] = True
        c = child[c]
        s = s+1
    s = s + solution[-1]
    solution.append(s)

for _ in range(n - min(len(solution), n)):
    solution.append(n)

print(' '.join([str(s) for s in solution]))
",O(nlogn)
"def solve(board):
  n=len(board)
  ans=0
  for i in range(n):
    for j in range(n):
      if board[i][j] is 'X':
        ans+=2**(i*n+j)
  return ans

def reverse_array(arr):
  for i in range(len(arr)):
    arr[i].reverse()

def rotate(matrix, degree):
    if degree == 0:
        return matrix
    elif degree > 0:
        return rotate(zip(*matrix[::-1]), degree-90)
    else:
        return rotate(zip(*matrix)[::-1], degree+90)

def make_list(board):
    board=list(board)
    arr=[]
    for i in range(len(list(board))):
        arr.append(list(board[i]))
    return arr

def add_rotations(board,st):
  for i in range(4):
    st.add(solve(board))
    reverse_array(board)
    st.add(solve(board))
    reverse_array(board)
    board=make_list(rotate(board, 90))

n=int(input())
arr1=[]
arr2=[]
for _ in range(n):
    arr1.append(list(input().strip()))
for _ in range(n):
    arr2.append(list(input().strip()))
s=set()
s.add(solve(arr1))
add_rotations(arr1,s)
l1=len(s)

s.add(solve(arr2))
add_rotations(arr2,s)

l2=len(s)
if l1==l2:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"import sys

rd = lambda : sys.stdin.readline().rstrip()

t = int(rd())
for _ in range(t):
    n = int(rd())
    a = list(map(int, rd().split()))
    b = []
    res_a, res_b = 1, 1e18

    a = sorted(a)
    i = 0
    while i < n-1:
        if a[i] == a[i+1]:
            b.append(a[i])
            i += 1

        i += 1

    p2s = lambda x, y : (x+y)**2/(x*y)

    for i in range(len(b)-1):
        if p2s(res_a, res_b) > p2s(b[i], b[i+1]):
            res_a, res_b = b[i], b[i+1]

    print(res_a, res_a, res_b, res_b)
",O(nlogn)
"l,r=map(int,input().split())
r1=len(bin(r))-3
l1=len(bin(l))-3
ans=0
while(l>0):
    if l1==r1:
        r-=(1<<l1)
        l-=(1<<l1)
    else:
        ans=(1<<(r1+1))-1
        break

    z1=min(l,r)
    z2=max(l,r)
    l,r=z1,z2
    r1 = len(bin(r)) - 3
    l1 = len(bin(l)) - 3

if ans==0:
    if l1==r1:
        if r==1:
            print(1)
        else:
            print(0)
    else:
        print((1<<(r1+1))-1)

else:
    print(ans)
",O(logn)
"n = int(input())
s = input()
b = 0
for i in s:
    if i == '+':
        b += 1
    else:
        b -= 1
        b = max(b, 0)
print(b)",O(n)
"class Solution3(object):
    def pancakeSort(self, A):
        def reverse(l, begin, end):
            for i in range((end-begin) // 2):
                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]

        result = []
        for n in reversed(range(1, len(A)+1)):
            i = A.index(n)
            reverse(A, 0, i+1)
            result.append(i+1)
            reverse(A, 0, n)
            result.append(n)
        return result",O(n ^ 2)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
for x in range(1,n):
	if l[x]>l[0]:
		print(l[x])
		break
else:
	print('NO')",O(nlogn)
"import collections


class Solution(object):
    def canReach(self, arr, start):
        q, lookup = collections.deque([start]), set([start])
        while q:
            i = q.popleft()
            if not arr[i]:
                return True
            for j in [i-arr[i], i+arr[i]]:
                if 0 <= j < len(arr) and j not in lookup:
                    lookup.add(j)
                    q.append(j) 
        return False",O(n)
"n, s = input().split()

n = int(n)
s = int(s)

def get_decimal_value_digits(number):
    count = 0
    digits = 0
    number = str(number)
    for digit in number:
        count += int(digit)
        digits += 1
    return count

def is_big_num(number, s):
    if (number - get_decimal_value_digits(number)) >= s:
        return True
    return False

start = s
end = n
count = 0
digits = 0
half = (n + s) // 2

while (end - start) >= 0:
    half = (start + end) // 2

    if is_big_num(half, s):
        end = half - 1
    else:
        start = half + 1

if not is_big_num(start+1, s):
    print(0)
else:
    print(n - start + 1)
",O(logn)
"from collections import defaultdict,deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, itertools, math
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float, input().split()))
def LI_(): return list(map(lambda x: int(x)-1, input().split()))
def II(): return int(input())
def IF(): return float(input())
def S(): return input().rstrip()
def LS(): return S().split()
def IR(n):
    res = [None] * n
    for i in range(n):
        res[i] = II()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI()
    return res
def FR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR_(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI_()
    return res
def SR(n):
    res = [None] * n
    for i in range(n):
        res[i] = S()
    return res
def LSR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LS()
    return res
mod = 1000000007
inf = float('INF')

def solve():
    n = II()
    a = LI()
    dp = [[None for i in range(n + 1)] for i in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = [a[i], a[i], 1]
        dp[i + 1][i] = [a[i], a[i], 1]
    for i in range(2, n + 1):
        for l in range(n - i + 1):
            tmp = [-inf, inf, inf]
            r = l + i
            dpl = dp[l]
            dpr = dp[r]
            for m in range(l + 1, r):
                lm = dpl[m]
                mr = dpr[m]
                lr = lm[2] + mr[2] - (lm[1] == mr[0])
                if lr < tmp[2]:
                    tmp[2] = lr
                    if lm[1] == mr[0]:
                        if lm[2] == 1:
                            tmp[0] = lm[0] + 1
                        else:
                            tmp[0] = lm[0]
                        if mr[2] == 1:
                            tmp[1] = mr[1] + 1
                        else:
                            tmp[1] = mr[1]
                    else:
                        tmp[0] = lm[0]
                        tmp[1] = mr[1]
            dp[l][r] = tmp
            dp[r][l] = tmp
    print(dp[0][n][2])
    return

if __name__ == '__main__':
    solve()
",O(n ^ 3)
"class Solution(object):
    def maxNumber(self, n):
        return (1<<(n.bit_length()-1))-1",O(1)
"class Solution(object):
    def maxScore(self, nums, x):
        dp = [float(""-inf"")]*2
        dp[nums[0]%2] = nums[0]
        for i in range(1, len(nums)):
            dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i]
        return max(dp)",O(n)
"n = int(input())
a = list(map(int,input().split()))
mod = 10**9+7
b = [0 for i in range(1<<20)]
for i in range(n):
  b[a[i]] += 1
for i in range(20):
  for j in range(1<<20):
    if j&1<<i == 0:
      b[j] += b[j|1<<i]
ans = 0
for i in range(1<<20):
  cnt = str(bin(i)).count(""1"")
  if cnt%2 == 0:
    ans += pow(2,b[i],mod)-1
  else:
    ans -= pow(2,b[i],mod)-1
  ans %= mod
print(ans)",np
"t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = sorted(a)
    print(min(a[-2]-1, n-2))
",O(nlogn)
"import collections



class Solution(object):
    def minGroups(self, intervals):
        events = collections.Counter()
        for l, r in intervals:
            events[l] += 1
            events[r+1] -= 1
        result = curr = 0
        for t in sorted(events.keys()):
            curr += events[t]
            result = max(result, curr)
        return result",O(nlogn)
"class Solution(object):
    def isSameAfterReversals(self, num):
        return num == 0 or num%10",O(1)
"class Solution3(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        lookup = SortedDict()
        for right in range(len(nums)):
            lookup[nums[right]] = right
            to_del = []
            for x, i in list(lookup.items()):
                if nums[right]-x <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x)
            for x, i in reversed(list(lookup.items())):
                if x-nums[right] <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x) 
            for x in to_del:
                del lookup[x]
            result += right-left+1
        return result",O(nlogn)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res
p = 1000000007
x = [int(i) for i in raw_input().split()]
y = power(2,x[1],p)

if(x[0]>0):
    ans = 2 * y * x[0]%p - (y - 1)%p
else:
    ans = 0
print(ans%p)",O(logn)
"class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        result = left = prev = 0
        for right in range(len(s)):
            if right-1 >= 0 and s[right-1] == s[right]:
                left, prev = prev, right
            result = max(result, right-left+1)
        return result",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass

n=L()[0]
if n<6:
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(5,n+1):
        print(2,i)
for i in range(1,n):
    print(i,i+1)

endtime = time.time()
",O(n)
"def getsum(n):
    return ((1 << (2*n)) - 1) // 3

def b(n, k):
    l = n - 1
    r = max(0, l - 41)
    while True:
        mid = (l + r) // 2
        count = getsum(n - mid)
        if count <= k:
            l = mid
        else:
            r = mid
        if l - r <= 1:
            break
        del count
    g = getsum(n - r)
    if g < k:
        del g
        return None
    elif g == k:
        del g
        return r
    return l

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    min_side = b(n, k)
    if min_side is None:
        print('NO')
        continue
    k -= getsum(n - min_side)
    if n == 2 and min_side == 1 and k == 2:
        print('NO')
        continue
    num_squares = (1 << (n - min_side)) * 2 - 1
    if k >= num_squares:
        print('YES ' + str(min_side - 1))
    else:
        print('YES ' + str(min_side))",O(logn)
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M= 998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

n,k = value()
a = array()

ans = 0

for i in range(n-k+1):

    num = sum(a[i:i+k])
    den = k
    ans = max(ans , num/den)

    for j in range(i+k,n):

        num += a[j]
        den += 1
        ans = max(ans , num/den)

print(ans)
",O(n ^ 2)
"def findSet(u):
  if parents[u] != u:
    parents[u] = findSet(parents[u])
  return parents[u]

def unionSet(u, v):
  up = findSet(u)
  vp = findSet(v)
  if up == vp:
    return

  if ranks[up] > ranks[vp]:
    parents[vp] = up
  elif ranks[up] < ranks[vp]:
    parents[up] = vp
  else:
    parents[up] = vp
    ranks[vp] += 1

n, a, b = map(int, input().split())
ps = list(map(int, input().split()))

mapping = set(ps)

parents = {x: x for x in ps}
parents['A'] = 'A'
parents['B'] = 'B'
ranks = {x: 0 for x in ps}
ranks['A'] = 0
ranks['B'] = 0

result = True
for x in ps:
  if a - x in mapping:
    unionSet(x, a - x)
  else:
    unionSet(x, 'B')

  if b - x in mapping:
    unionSet(x, b - x)
  else:
    unionSet(x, 'A')

if findSet('A') == findSet('B'):
  print(""NO"")

else:
  print(""YES"")
  for i in ps:
    if findSet(i) == findSet('A'):
      print(""0"", end = ' ')
    else:
      print(""1"", end = ' ')
",O(n)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        for i in range(32):
            if (1 << i) & n:
                res += 1
        return res
",O(1)
"n = int(input())
A = list(map(int, input().split()))
k = 10 ** 10
for i in range(1, n - 1):
    k = min(k, min(A[0], A[i]) // i)
    k = min(k, min(A[-1], A[i]) // (n - i - 1))
k = min(k, min(A[0], A[-1]) // (n - 1))
print(k)",O(n)
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",O(logn)
"class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)",O(n)
"n=input()
if int(n)>0:
	print(n)
elif -9<=int(n)<=0:
	print(0)
else:
	a=(-int(n))//10
	b=((-int(n))//100)*10+int(n[-1])
	print(max(-a,-b))",O(1)
"for _ in range(int(input())):
	def get(n):
		return (4**n-1)//3
	n,k = map(int,input().split())
	if n<32 and 4**n < 1*3*k:
		print(""NO"")
		continue
	now = 1
	p = 2
	ans = n
	sq = 0
	buff = 0
	d = 4
	while k>=now:
		k -= now
		p *= 2
		now = p-1
		ans -= 1

		sq = sq*4 + d-3
		d *= 2
		if n < 60:
			buff += sq * (4**ans-1)//3
		else:
			buff = 10**19

		if ans == 0: break

	if buff < k: print(""NO"")
	else: print(""YES"",max(ans,0))",O(logn)
"def main():
    n, d, k = list(map(int, input().split()))
    if n == 2 and d == 1 and k == 1:
        print(""YES"")
        print(""1 2"")
        return 0
    if n == d + 1 and k - 1:
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        return 0
    if  n < d +1 or k <= 2 or d == 1:
        print(""NO"")
        return 0
    if d % 2 == 0:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 1 + dev + d // 2]

    else:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2) + (k - 2) * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2, 2 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 2 + dev + d // 2]
main()
",O(n ^ 2)
"class Solution2(object):
    def averageOfSubtree(self, root):
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

a=sorted(input())
b=int(input())
a=a[::-1]
p=""""
while a:
	for i, z in enumerate(a):
		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
		if int(n)<=b:
			p+=z
			a.pop(i)
			break
print(p)",O(n ^ 3)
"first = [int(i) for i in input()]
second = [int(i) for i in input()]

pref_dists = [
    [0] + [int(0 != c) for c in second],
    [0] + [int(1 != c) for c in second]
]
for i in range(1, len(second) + 1):
    pref_dists[0][i] += pref_dists[0][i - 1]
    pref_dists[1][i] += pref_dists[1][i - 1]

total = 0
for i, c in enumerate(first):
    end = len(second) - (len(first) - i)
    total += pref_dists[c][end + 1] - pref_dists[c][i]
print(total)
",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def solve():
    n = ii()
    d = defaultdict(lambda:0)
    d1 = defaultdict(lambda:0)
    for i in range(n):
        x,y = li()
        d[x-1]-=1
        d[y]+=1

    x = list(d.keys())
    x.sort()
    r = x[-1]

    c=d[r]
    temp=1
    for i in range(len(x)-2,-1,-1):
        l = x[i]+1
        d1[c]+=r-l+temp

        c+=d[x[i]]
        r=l
        temp=0

    for i in range(1,n+1):
        print(d1[i],end="" "")
    print()

t = 1

for _ in range(t):
    solve()
",O(nlogn)
"class Solution(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            return sum(abs(i-x) for i, x in enumerate(x for x, cnt in enumerate(cnt) for _ in range(cnt)))

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"def max_subarray(A):
    max_ending_here = max_so_far = A[0]
    for x in A[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

ans = 0
n, m, k = map(int, input().split())
a = list(map(int, input().split()))
for i in range(m):
    li = a[0:i] + [-k]
    s = 0
    while True:
        li += a[i+s:min(i+m+s, len(a))]
        li += [-k]
        if i+m+s >= len(a):
            break
        s += m
    ans = max(max_subarray(li) - k,ans)
print(ans)
",O(n ^ 2)
"class Solution5(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        right = [NEG_INF]*len(prices)
        st = SegmentTree(len(price_to_idx))
        for i in reversed(range(len(prices))):
            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)
            st.update(price_to_idx[prices[i]], profits[i])
        result = NEG_INF
        st = SegmentTree(len(price_to_idx))
        for i in range(len(prices)):
            left = st.query(0, price_to_idx[prices[i]]-1)
            if left is not None and right[i] is not None:
                result = max(result, left+profits[i]+right[i])
            st.update(price_to_idx[prices[i]], profits[i])
        return result if result != NEG_INF else -1",O(nlogn)
"import random



class Solution(object):
    def maxSubsequence(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a > b)
        cnt = sum(partition[i] == partition[k-1] for i in range(k))
        result = []
        for x in nums:
            if x > partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt > 0:
                cnt -= 1
                result.append(x)
        return result",O(n)
"from math import log
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    for i in s:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
print(ans)
",O(nlogn)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)
",O(nlogn)
"n,k=map(int,input().split())
low=1
high=n
import sys
while low<=high:
    mid=(low+high)//2
    if mid*(mid+1)//2 -(n-mid)>k:
        high=mid-1
    elif mid*(mid+1)//2-(n-mid)==k:
        print(n-mid)
        sys.exit()
    else :
        low=mid+1",O(logn)
"for _ in range(int(input())):
    i, j = map(int, input().split())
    i -= 1
    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) -
          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2))))",O(1)
"import math
import sys

n=int(input())
s=list(map(int,input().split()))
ce=list(map(int,input().split()))

best=10**9
for j in range(1,n-1):
    a=ce[j];b=10**9;c=10**9
    for i in range(j-1,-1,-1):
        if s[i]<s[j]:
            b=min(b,ce[i])
    for k in range(j+1,n):
        if s[k]>s[j]:
            c=min(c,ce[k])
    best=min(best,a+b+c)

if best>=10**9:
    print(-1)
else:
    print(best)",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=99999999999999999999999999999999

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n=ri()
        s=ria()
        c=ria()
        ans=INF
        for i in range(n):
            mid=s[i]
            mcl=INF
            mrl=INF
            for j in range(i-1,-1,-1):
                if s[j]<mid:
                    mcl=min(mcl,c[j])
            for j in range(i+1,n):
                if s[j]>mid:
                    mrl=min(mrl,c[j])
            ans=min(ans,c[i]+mcl+mrl)
        if ans==INF:
            wi(-1)
        else:
            wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n ^ 2)
"input()
a = sorted(list(map(int, input().split())))
print(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))",O(nlogn)
"movimentos, doces_final = map(int, input().split())
left, right = 0, movimentos + 1

while left < right -1 :
    media = (left + right)//2
    cedidos = (media * (media + 1)) // 2
    comidos = movimentos - media
    if cedidos - comidos > doces_final:
        right = media
    else:
        left = media
print(movimentos - left)",O(logn)
"class Solution(object):
    def stringSequence(self, target):
        return [target[:i]+chr(x) for i in range(len(target)) for x in range(ord('a'), ord(target[i])+1)]",O(n ^ 2)
"class Solution2(object):
    def isReflected(self, points):
        if not points:
            return True
        points.sort()
        points[len(points)/2:] = sorted(points[len(points)/2:], \
                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                                     x[0] - y[0])
        mid = points[0][0] + points[-1][0]
        left, right = 0, len(points) - 1
        while left <= right:
            if (mid != points[left][0] + points[right][0]) or \
               (points[left][0] != points[right][0] and \
                points[left][1] != points[right][1]):
                return False
            left += 1
            right -= 1
        return True",O(nlogn)
"class Solution2(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = (len(nums)+1)*len(nums)//2
        left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result -= right-left+1
        return result",O(n)
"import bisect



class Solution4(object):
    def findMaximumLength(self, nums):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        prev = [-1]*(len(nums)+1)
        left = -1
        for right in range(len(nums)):
            left = max(left, prev[right])
            dp[right+1] = dp[left+1]+1
            next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1
            prev[next_right] = right
        return dp[-1]",O(nlogn)
"class Solution(object):
    def pivotIndex(self, nums):
        total = sum(nums)
        left_sum = 0
        for i, num in enumerate(nums):
            if left_sum == (total-left_sum-num):
                return i
            left_sum += num
        return -1",O(n)
"def A(n):
	return (4**n-1)//3

L = 31

T = int(input())
for _ in range(T):
	n,k = [int(_) for _ in input().split()]

	if n > L:
		print(""YES"",n-1)
		continue

	if k > A(n):
		print(""NO"")
		continue

	E = 1
	M = 0
	R = 0
	while n >= 0:
		M += E

		I = 2*E-1
		E = 2*E+1

		n -= 1
		R += I*A(n)

		if M <= k and k <= M+R: break

	if n >= 0: print(""YES"",n)
	else: print(""NO"")
",O(logn)
"class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0",O(n ^ 2)
"if input()=='1':
 print(input())
else:
 x,*a,y=sorted(map(int,input().split()))
 print(y-x+sum(map(abs,a)))",O(nlogn)
"class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums",O(n)
"from collections import Counter as C
n, m = map(int, input().split())
l = [*map(int, input().split())]
c = sorted(C(l).items())

res = 0
j = 0
for hi, ni in c:

    h = min(hi - j, ni) + j
    res += (hi - 1) * ni
    if h > j:
        j = h
m = max(l)
if j < m:
    res -= m - j
print(res)",O(nlogn)
"from sys import stdout
def main():
    n = int(raw_input())
    k = 2
    a = []
    m = n
    while 1:
        t = n / k
        if t <= 1:
            k /= 2
            a.extend([k] * m)
            a[-1] = n / k * k
            break
        a.extend([k / 2] * (m - t))
        m = t
        k *= 2
    stdout.write(' '.join(map(str, a)))
main()
",O(n)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"class Solution(object):
    def isBalanced(self, num):
        return sum(ord(num[i])-ord('0') for i in range(0, len(num), 2)) == sum(ord(num[i])-ord('0') for i in range(1, len(num), 2))",O(n)
"import sys
import heapq

n, k = list(map(int,sys.stdin.readline().strip().split(' ')))
p = list(map(int,sys.stdin.readline().strip().split(' ')))
c = list(map(int,sys.stdin.readline().strip().split(' ')))

sortedp = sorted([(pi,i) for (i,pi) in enumerate(p)])

ans = [0 for i in range(n)]
acc_coins = 0
acc = []

if k == 0:
	print(' '.join(map(str,c)))
else:
	for i in range(n):
		coins = c[sortedp[i][1]]
		ans[sortedp[i][1]] += acc_coins + coins
		if len(acc) < k:
			acc_coins += coins
			heapq.heappush(acc,coins)
		else:
			smallest_coin = heapq.nsmallest(1,acc)[0]
			if smallest_coin < coins:
				acc_coins -= smallest_coin
				heapq.heappop(acc)
				heapq.heappush(acc,coins)
				acc_coins += coins
	print(' '.join(map(str,ans)))
",O(nlogn)
"import sys
import math
input = sys.stdin.readline

def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s.rstrip()))
def invr():
    return(map(int,input().split()))
n, m, k=inlt()
M=[[[] for i in range(m)] for j in range(n)]
S=[[-1]*m for i in range(n)]
for y in range(n):
	L=inlt()
	for x in range(m-1):
		M[y][x].append(((y, x+1), L[x]))
		M[y][x+1].append(((y, x), L[x]))

for y in range(n-1):
	L=inlt()

	for x in range(m):
		M[y][x].append(((y+1, x), L[x]))
		M[y+1][x].append(((y, x), L[x]))
if k%2==0:
	for l in range(k//2):
		S2=[[0]*m for i in range(n)]
		for y in range(n):
			for x in range(m):
				Mi=10000000000000000000000
				for ((a, b), p) in M[y][x]:
					Mi=min(Mi,max(0,S[a][b])+p)
				S2[y][x]=Mi
		S=S2
	for y in range(n):
		for x in range(m):
			S[y][x]*=2

for y in range(n):
	print(' '.join(list(map(str, S[y]))))",O(n ^ 3)
"class Solution(object):
    def kthCharacter(self, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        return chr(ord('a')+popcount(k-1)%26)",O(1)
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",np
"class Solution(object):
    def collectTheCoins(self, coins, edges):
        DISTANCE = 2

        adj = [set() for _ in range(len(coins))]
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        n = len(coins)
        q = []
        for u in range(len(coins)):
            while len(adj[u]) == 1 and not coins[u]:
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                u = v
        q = [u for u in range(len(coins)) if len(adj[u]) == 1]
        for _ in range(DISTANCE):
            new_q = []
            for u in q:
                if not adj[u]:
                    assert(n == 1)
                    break
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                if len(adj[v]) == 1:
                    new_q.append(v)
            q = new_q
        return (n-1)*2",O(n)
"n,k = map(int,input().split())
a = list(map(int,input().split()))
p = sorted(a)
p = p[-k:]
s = sum(p)
print(s)
idx = 0
i = 0
count = 0
ans = []
while len(ans)<k-1:
    idx+=1
    count+=1
    if a[i] in p:
        p.remove(a[i])
        ans.append(count)
        count = 0
    i+=1
for i in ans:
    print(i,end = "" "")
print(n-idx)
",O(nlogn)
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return r+1

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()
",O(logn)
"class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        USE, REFILL, DIST = 5, 1, 10
        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)
        return (mainTank+cnt*REFILL)*DIST",O(1)
"from math import ceil

n, k = map(int, input().split())

print(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))
",O(1)
"n, m = map(int, input().split())
x1 = -1
x2 = -1
y1 = -1
y2 = -1
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            if x1 == -1:
                x1 = j + 1
            x2 = max(x2, j + 1)
            if y1 == -1:
                y1 = i + 1
            y2 = i + 1
print((y1 + y2) // 2, (x1 + x2) // 2)",O(n ^ 2)
"import sys

input = sys.stdin.readline

a, b= map(int,input().split())

if a == b:
    print(0)

else:
    x = a ^ b
    c = 1

    while x:
        x >>= 1
        c <<= 1

    print(c-1)",O(logn)
"def parse():
    s, i = input().split()
    i = int(i) - 1
    return s, i

def match(p, s):
    for a, b in zip(p, s):
        if a != '_' and a != b:
            return False
    return True

def main():
    from itertools import product

    n, m, k = [int(t) for t in input().split()]
    P = [input() for _ in range(n)]
    S = [parse() for _ in range(m)]

    index_of = dict()
    for i, p in enumerate(P):
        index_of[p] = i

    G = [[] for _ in range(n)]
    for s, i in S:
        if not match(P[i], s):
            print(""NO"")
            return

        for mask in product(range(2), repeat=k):
            sp = ['_' if bit else c for bit, c in zip(mask, s)]
            sp = ''.join(sp)

            try:
                j = index_of[sp]
                if i != j:
                    G[i].append(j)
            except:
                pass

    tp = toposort(G)
    if tp is None:
        print(""NO"")
    else:
        print(""YES"")
        print(*[x+1 for x in tp])

def toposort(graph):
    res, found = [], [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]

import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

main()

os.write(1, stdout.getvalue())
",np
"class Solution(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    ret[:] = [1-is_prime(u+1), is_prime(u+1)]
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [0]*2
                    stk.append((3, (u, p, new_ret, ret, i)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, p, new_ret, ret, i = args
                    result += ret[0]*new_ret[1]+ret[1]*new_ret[0]
                    if is_prime(u+1):
                        ret[1] += new_ret[0]
                    else:
                        ret[0] += new_ret[0]
                        ret[1] += new_ret[1]
            return result

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"n = int(input())
board = list(map(int,input().split("" "")))
index = list(range(0,n))
ascending = [x for _,x in sorted(zip(board,index))]

winners = n * [""""]

for c in reversed(ascending):
	if board[c] == n:
		winners[c] = ""B""

	toCheck = c - board[c]
	while(toCheck >= 0):
		if winners[toCheck] == ""B"":
			winners[c] = ""A""
		toCheck = toCheck - board[c]
	if winners[c] == """":
		toCheck = c + board[c]
		while(toCheck < n):
			if winners[toCheck] == ""B"":
				winners[c] = ""A""
			toCheck = toCheck + board[c]
	if winners[c] == """":
		winners[c] = ""B""

for i in range(n):
	print(winners[i],end="""")
print()
",O(nlogn)
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    cnt[a]=c
for p in P.primes:
    for i in range(m//p,0,-1):
        cnt[i]+=cnt[i*p]
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        return max(self.helper(nums[1:]),
                   self.helper(nums[:-1]))

    def helper(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])

        return dp[-1]
",O(n)
"n,l,r,x = map(int,input().split())
A = list(map(int,input().split()))
count = 0
for i in range(1<<n):
    total = 0
    mn = 1e6
    mx = -1e6
    for k in range(n):
        if (i & (1<<k)):
            total += A[k]
            mn = min(A[k],mn)
            mx = max(A[k],mx)
    if total<=r and total>=l and mx-mn>=x:
        count += 1
print(count)",np
"def onseg(p,q,r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \
           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p,q,r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - \
          (q[0] - p[0]) * (r[1] - q[1])

    if (val == 0): return 0
    return 1 if val > 0 else 2

def doint(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and onseg(p1, p2, q1): return True
    if o2 == 0 and onseg(p1, q2, q1): return True
    if o3 == 0 and onseg(p2, p1, q2): return True
    if o4 == 0 and onseg(p2, q1, q2): return True

    return False

x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())
x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())

A = x0,y0
B = x1,y1
C = x2,y2
D = x3,y3
a = x4,y4
b = x5,y5
c = x6,y6
d = x7,y7

if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \
   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \
   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \
   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \
   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \
   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):
    print('YES')
else:
    print('NO')
",O(1)
"class Solution(object):
    def canThreePartsEqualSum(self, A):
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts >= 3",O(n)
"N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

s=S()
ans = s.replace('1','')+'2'
t =  ans.find('2')

print(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",np
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"n=int(input())
for i in range(n):
	a,b = map( int, input().split() )
	if a>b:
	    a,b=b,a
	ans=0
	while a>0:
		ans+=b//a
		b%=a
		a,b=b,a
	print(ans)",O(1)
"class Solution4(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            q = [src]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup[dst]

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not bfs(len(circles), len(circles)+1)",O(n ^ 2)
"k = int(input())
if (k < 10):
    print(k)
    quit()
c=0
n=k
a = k
while (n > 0):
    c+=1
    sub = 10 ** c - 10 ** (c-1)
    a-=sub*c
    n = a / (c+1) + (10 ** c - 1)
    if (n+1 <= 10 ** (c+1)):
        if (int(n) == n):
            print(int(n%(10)))
            exit()
        else:
            print(str(int(n)+1)[round((n-int(n))*(c+1))-1])
            exit()
",O(logn)
"def ii():
    return int(input())
def mi():
    return map(int,input().split())
def li():
    return list(map(int,input().split()))

mod = 10**9 + 7

x,k = mi()
if(x == 0):
    print(0)
elif(k == 0):
    print((2*x)%mod)
else:
    to = pow(2,k,mod)
    pre = (to * x)%mod
    prev = pow(2,k-1,mod)
    first = (pre - prev + 1)%mod
    sec = (pre - prev)%mod
    ans = (first + sec)%mod
    print((ans+mod)%mod)",O(logn)
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n):
        return(0)
    if(k == 2*n or k==1):
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual = [0]*(k+1)
        auxdiff = [0]*(k+1)

        for j in range(1, k+1):
            auxigual[j] = (iguales[j] + iguales[j-1] + 2*diferentes[j]) % modulo

        for k in range(2, k+1):
            auxdiff[k] = (diferentes[k] + diferentes[k-2] + 2*iguales[k-1]) % modulo

        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())
",np
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"l = input().split()
if l[0]==l[1] and l[1]==l[2]:
    print(0)
    exit(0)
def shuntsu(li):
    li.sort()
    return li[0][1]==li[1][1] and li[1][1]==li[2][1] and int(li[1][0])==int(li[0][0])+1 and int(li[2][0])==int(li[1][0])+1
if shuntsu(l):
    print(0)
    exit(0)
for k in l:
    if len([x for x in l if x==k]) > 1:
        print(1)
        exit(0)
    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+1]) !=0:
        print(1)
        exit(0)
    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+2]) != 0:
        print(1)
        exit(0)
print(2)
",O(nlogn)
"class Solution(object):
    def isUnivalTree(self, root):
        s = [root]
        while s:
            node = s.pop()
            if not node:
                continue
            if node.val != root.val:
                return False
            s.append(node.left)
            s.append(node.right)
        return True
    ",O(n)
"n = int(input())

if n > 0:
    print(n)
else:
    n = n * -1
    x = n % 10
    y = (n // 10) % 10

    if x > y:
        print(-(n // 10))
    else:
        print(-((n // 100)* 10 + x))
",O(1)
"class Solution2(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b

        for i in range(k, len(word), k):
            if all(word[i+j] == word[j] for j in range(len(word)-i)):
                return i//k
        return ceil_divide(len(word), k)",O(n ^ 2)
"import math
s=input()
p=input()
c=1
ss=0
ps=0
k=0
for i in range(len(s)):
	if(p[i]=='?'):
		c*=2
		k+=1
	if(s[i]=='+'):
		ss+=1
	else:
		ss-=1
	if(p[i]=='+'):
		ps+=1
	elif p[i]=='-':
		ps-=1
y=math.fabs(ss-ps)
x=k-y
a=y+x/2
b=k-a
if k<y:
	ans=0.000000000
else:
	ans=math.factorial(a+b)/(math.factorial(a)*math.factorial(b))
	ans/=c
print(""%.12f""%ans)
",np
"n=int(input())
s=(input())
L=s.split("" "")
L=list(set(L))
for i in range(len(L)):
    L[i]=int(L[i])
L=sorted(L)
if len(L)==1:
    print(""NO"")
else:
    print(L[1])
",O(nlogn)
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        seen = set()
        for num in nums:
            if num in seen:
                seen.remove(num)
            else:
                seen.add(num)
        return list(seen)[0]
",O(n)
"class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ""."":
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])

        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ""."":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])

        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ""."":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True
",O(n ^ 2)
"def if_spruce(n,l,s):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if i not in s:
            d[l[i]]+=1
    for i in range(1,n+1):
        if i in s and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,a=[0]*2,0
for _ in range(n-1):
    a=int(input())
    l.append(a)
s=set(l)
print(if_spruce(n,l,s))",O(n)
"import sys
input = sys.stdin.readline
q = int( input() )
rgb = ""RGB""
for _ in range( q ):
    n, k = map( int, input().split() )
    s = input()
    ans = n
    for i in range( 3 ):
        r = [ 0 ]
        l = i
        for c in s:
            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )
            l = ( l + 1 ) % 3
            if len( r ) > k:
                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )
    print( ans )
",O(n)
"n=int(input())
l=[int(c) for c in input().split()]
ll=[]
res=[]
head=0
dia=0
for i in range(1,n):
    if l[i]==1:
        l[i]=0
        ll.append(i)
    else:
        res.append((head+1,i+1))
        l[head]-=1
        dia+=1
        head=i
        l[head]-=1
if l[head]>0 and len(ll)>0:
    res.append((ll[0]+1,head+1))
    l[head]-=1
    del(ll[0])
    dia+=1
if l[0]>0 and len(ll)>0:
    res.append((ll[0]+1,1))
    l[0]-=1
    del(ll[0])
    dia+=1
for i in ll:
    for j in range(n):
        if l[j]>0:
            res.append((j+1,i+1))
            l[j]-=1
            break
if len(res)<n-1:
    print(""NO"")
else:
    print(""YES ""+str(dia))
    print(n-1)
    for p in res:
        print(p[0],end ="" "")
        print(p[1])",O(n ^ 2)
"n=int(input())
ans=0
for i in range(2,n+1):
	for j in range(2*i,n+1,i):
		ans+=(4*(j//i))
print(ans)",O(nlogn)
"def main():
    q = int(input())
    ans = []
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        pr1 = [0]
        pr2 = [0]
        pr3 = [0]
        for i in range(n):
            count1 = 0
            count2 = 0
            count3 = 0
            if i % 3 == 0:
                if s[i] != ""R"":
                    count1 += 1
                if s[i] != ""G"":
                    count2 += 1
                if s[i] != ""B"":
                    count3 += 1
            if i % 3 == 1:
                if s[i] != ""G"":
                    count1 += 1
                if s[i] != ""B"":
                    count2 += 1
                if s[i] != ""R"":
                    count3 += 1
            if i % 3 == 2:
                if s[i] != ""B"":
                    count1 += 1
                if s[i] != ""R"":
                    count2 += 1
                if s[i] != ""G"":
                    count3 += 1
            pr1.append(pr1[-1] + count1)
            pr2.append(pr2[-1] + count2)
            pr3.append(pr3[-1] + count3)
            j = i + 1
            if j >= k:
                count1 = pr1[j] - pr1[j - k]
                count2 = pr2[j] - pr2[j - k]
                count3 = pr3[j] - pr3[j - k]
                min_ans = min(min_ans, count1, count2, count3)
        ans.append(min_ans)
    print(*ans, sep=""\n"")

main()",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)
",O(n ^ 2)
"n = int(input())
left = []
right = []
for i in range(n):
	data = input().split()
	left.append(int(data[0]))
	right.append(int(data[1]))

left.sort()
right.sort()
i = 0
j = 0
count = 1
ans = [0] * (n + 1)
left += [max(right) + 1]
right += [max(right) + 2]
while (i < n) and (j < n):
	while left[i + 1] <= right[j]:
		ans[count] += (left[i + 1] - left[i])
		count += 1
		i += 1
	ans[count] += (right[j] - left[i] + 1)
	i += 1
	count -= 1

	while ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):
		ans[count] += (right[j + 1] - right[j])
		count -= 1
		j += 1
	ans[count] += (left[i] - right[j] - 1)
	j += 1
	count += 1

for i in range(1, n + 1):
	print(ans[i], end = "" "")
print()
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j] = 0

for k1 in range(1, k // 2 + 1):
    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],
                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])

    mem = mem0

[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"import sys
input=sys.stdin.readline
class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
n=int(input())
a=list(map(int,input().split()))
bi=Bit(n+1)
c=0
for i,x in enumerate(a):
    bi.add(x,1)
    c+=i+1-bi.sum(x)
if c%2==n%2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"ints=[int(x) for x in input().split()]

n=ints[0]
k=ints[1]
print(int(n-((8*(n+k)+9)**(1/2)-3)/2))",O(logn)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
        return root
",O(n ^ 2)
"class Solution(object):
    def minCost(self, n, cuts):
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in range(len(sorted_cuts))]
        for l in range(2, len(sorted_cuts)):
            for i in range(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in range(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]",O(n ^ 3)
"n = int(input())+1
print(0 if not (n-1) else n//2 if not n&1 else n)",O(1)
"T = int(input())
for i in range(T):
	n = int(input())
	a = list(map(int, input().split()))
	a.sort()
	print(min(len(a) - 2, max(a[-2] - 1, 0)))
",O(nlogn)
"class Solution(object):
    def totalHammingDistance(self, nums):
        result = 0
        for i in range(32):
            counts = [0] * 2
            for num in nums:
                counts[(num >> i) & 1] += 1
            result += counts[0] * counts[1]
        return result",O(n)
"class Solution(object):
    def minFlipsMonoIncr(self, S):
        flip0, flip1 = 0, 0
        for c in S:
            flip0 += int(c == '1')
            flip1 = min(flip0, flip1 + int(c == '0'))
        return flip1",O(n)
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True

def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""

n = int(input())

print(lucky(n))",O(1)
"class Solution(object):
    def minimumTime(self, nums1, nums2, x):
        dp = [0]*(len(nums1)+1)
        for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):
            for j in reversed(range(1, i+1)):
                dp[j] = max(dp[j], dp[j-1]+(a+j*b))
        total1, total2 = sum(nums1), sum(nums2)
        return next((j for j in range(len(dp)) if (total1+j*total2)-dp[j] <= x), -1)",O(n ^ 2)
"class Solution(object):
    def splitBST(self, root, V):
        if not root:
            return None, None
        elif root.val <= V:
            result = self.splitBST(root.right, V)
            root.right = result[0]
            return root, result[1]
        else:
            result = self.splitBST(root.left, V)
            root.left = result[1]
            return result[0], root",O(n)
"n = int(input())
a = input()
sum = 0
for x in a:
    sum += int(x)
ans = ""NO""
if sum == 0:
    ans = ""YES""
s = 1
while s * s <= sum and ans == ""NO"":
    if sum % s == 0:
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == s:
                flag = 1
            if t > s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == s:
                        flag = 1
        if t == s and t != sum:
            ans = ""YES""
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == sum // s:
                flag = 1
            if t > sum // s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == sum // s:
                        flag = 1
        if t == sum // s and t != sum:
            ans = ""YES""
    s += 1
print(ans)",O(n ^ 2)
"tt=int(input())
for _ in range(tt):
    s=input()
    t=input()
    flag='NO'
    j=0
    ptr=0
    while(j<len(s) and ptr<len(t)):
        if(s[j]==t[ptr]):
            ptr+=1
            j+=1
        else:
            j+=1
    if(ptr==len(t)):
        flag='YES'
    else:
        pos=[0]*26
        for i in range(len(s)):
            pos[ord(s[i])-97]+=1
        for i in range(0,len(t)):
            h=[]
            for j in range(0,len(pos)):
                h.append(pos[j])
            j=0
            ptr=0
            temp1=0
            while(ptr<=i and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==i+1):
                temp1=1

            j=0
            ptr=i+1
            temp2=0
            while(ptr<len(t) and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==len(t)):
                temp2=1

            if(temp1==1 and temp2==1):
                flag='YES'
                break
    if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')):
        flag='NO'
    print(flag)
",O(n ^ 3)
"import sys
def ask(i):
    print('?', i + 1)
    sys.stdout.flush()
    a_i = int(input())
    return a_i
def answer(i):
    print('!', i + 1 if i != -1 else -1)
    sys.exit()

def has_intersection(l1, r1, l2, r2):
    if l1 <= l2 and r2 <= r1:
        return True
    if l2 <= l1 and r1 <= r2:
        return True
    return False

n = int(input())
assert n >= 2 and n % 2 == 0
if (n // 2) % 2 == 1:
    answer(-1)
else:
    assert n % 4 == 0
    l1 = 0
    r1 = n // 2
    a_l1 = ask(l1)
    a_r1 = ask(r1)
    if a_l1 == a_r1:
        answer(0)
    a_l2 = a_r1
    a_r2 = a_l1

    while True:
        m1 = (l1 + r1) // 2
        m2 = (m1 + n // 2) % n
        a_m1 = ask(m1)
        a_m2 = ask(m2)
        if a_m1 == a_m2:
            answer(m1)
        if has_intersection(a_l1, a_m1, a_l2, a_m2):
            r1 = m1
            a_r1 = a_m1
            a_r2 = a_m2
        else:
            assert has_intersection(a_m1, a_r1, a_m2, a_r2)
            l1 = m1
            a_l1 = a_m1
            a_l2 = a_m2

assert False
",O(logn)
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))
",O(n)
"class Solution(object):
    def areNumbersAscending(self, s):
        prev = curr = -1
        for i, c in enumerate(s):
            if c.isdigit():
                curr = max(curr, 0)*10+int(c)
                continue
            if prev != -1 and curr != -1 and prev >= curr:
                return False
            if curr != -1:
                prev = curr
            curr = -1            
        return curr == -1 or prev < curr",O(n)
"n,k =  map(int,input().split())

def tonny(i) :
	return (ord(i)-96)
a= sorted(input())
a=list(map(tonny,a))
a=sorted(list(set(a)))
ans=[a.pop(0)]
k-=1
for j in a :
	if j-ans[-1] >1 and k>0 :
		k-=1
		ans.append(j)
	if k==0 :
		break
if k!=0 :
	print(-1)
else:
	print(sum(ans))
",O(n)
"import sys
from collections import OrderedDict

def sum_from_two(x):

    return x * (x + 1) // 2 - 1

def sum_last(k, x):

    if x == 0:
        return 1

    return sum_from_two(k) - sum_from_two(k - x) - x + 1

def possible(n, k, x):
    return sum_last(k, x) >= n

def main(n, k):
    if n == 1:

        return 0

    if sum_last(k, k - 1) < n:
        return -1

    minimum = 1

    maximum = k - 1
    while minimum <= maximum:
        if minimum == maximum:
            return minimum
        elif minimum == maximum - 1:
            if possible(n, k, minimum):
                return minimum
            else:
                return maximum

        mid = (minimum + maximum) // 2
        if possible(n, k, mid):

            maximum = mid
        else:

            minimum = mid

if __name__ == ""__main__"":
    curr = None
    for e, line in enumerate(sys.stdin.readlines()):
        n, k = list(map(int, line.strip().split()))
    print(main(n, k))
",O(logn)
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)
",O(n)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    tmp = discriminant / 2
    const = Decimal(3/2)
    res1 = math.floor(const + tmp)
    res2 = math.floor(const - tmp)
    res1 = max(res1, res2)
    print(k - res1 + 1);",O(logn)
"n, k = map(int, input().split())
arr = list(map(int, input().split()))

rsum = [0]
maxx = 0.0

for i in range(n): rsum.append(rsum[-1] + arr[i])

for ki in range(k, n+1):
    for i in range(n-ki+1):
        tot = 0

        avg = (rsum[i+ki] - rsum[i])/ki

        maxx = max(maxx, avg)
print(maxx)
",O(n ^ 2)
"x, k = map(int,input().split())
if x==0:
  print(0)
else:
  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)",O(logn)
"import collections


class Solution(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        q = collections.deque()
        left = [0]
        for i in range(len(s)):
            while q and q[0][1] < i:
                q.popleft()
            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))
            q.append((i, i+P[2*i+2]//2))
        q = collections.deque()
        result = right = 0
        for i in reversed(range(len(s))):
            while q and q[0][1] > i:
                q.popleft()
            right = max(right, 1+2*(q[0][0]-i) if q else 1)
            q.append((i, i-P[2*i+2]//2))
            result = max(result, left[i]*right)
        return result",O(n)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
while len(a) > 0:
    k = a.pop(0)
    a = [i for i in a if i % k != 0]
    ans += 1

print(ans)
",O(n ^ 2)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root in (None, p, q):
            return root

        left, right = [self.lowestCommonAncestor(child, p, q) \
                         for child in (root.left, root.right)]
        return root if left and right else left or right

",O(n)
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)

    prev = lst[i][0]
print(ans+prev)",O(n)
"def bs(n, k, lo, hi):
    while lo <= hi:
        mid = (hi + lo)//2
        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)
        if summ == n: return k - mid + 1
        elif summ > n: lo = mid + 1
        elif summ < n: hi = mid - 1
    if summ > n: mid += 1
    return k - mid + 1

def solve():
    n, k = map(int, input().split())
    if n == 1: return 0
    elif (k * (k + 1)//2) - (k-2) <= n: return -1
    elif k >= n: return 1
    else: return bs(n, k, 2, k)

print(solve())",O(logn)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        return [bin(i).count('1') for i in range(n + 1)]
",O(n)
"def main():
    mod=1000000007

    tc=1
    for _ in range(tc):
        a=list(rs())
        b=list(rs())

        if len(a)<len(b):
            ws(''.join(sorted(a)[::-1]))
        else:
            a=sorted(a)
            ans=[]
            sa=SortedList(a)
            for i in range(len(a)-1):
                for j in range(len(sa)-1,-1,-1):
                    temp=ans+[sa[j]]
                    sa.discard(sa[j])
                    for k in sa:
                        temp.append(k)

                    if temp<=b:
                        ans.append(temp[i])
                        break
                    else:
                        sa.add(temp[i])
            ans.append(sa[-1])
            ws("""".join(ans))

def rant():

    return ""AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH""

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def memodict(f):

    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret

    return memodict().__getitem__

def pollard_rho(n):

    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3

    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n

@memodict
def prime_factors(n):

    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)

def distinct_factors(n):

    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors

def all_factors(n):

    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

class DisjointSetUnion:
    def __init__(self, n):
        self.parent = [*range(n+1)]
        self.size = [1]*(n+1)
        self.min, self.max = [*range(n+1)], [*range(n+1)]
        self.count = n

    def get(self, a):

        if self.parent[a] == a:
            return a
        x = a
        while a != self.parent[a]:
            a = self.parent[a]
        while x != self.parent[x]:
            self.parent[x], x = a, self.parent[x]
        return a

    def union(self, a, b):

        a, b = self.get(a), self.get(b)
        if a != b:
            if self.size[a] > self.size[b]:
                a, b = b, a
            self.parent[a] = b
            self.size[b] += self.size[a]
            self.min[b] = min(self.min[a], self.min[b])
            self.max[b] = max(self.max[a], self.max[b])
            self.count -= 1

    def count_sets(self):

        return self.count

class SegmentTree:

    def __init__(self, data, default=0, func=max):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):

        stop+=1
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SparseTable:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, start, stop):

        depth = (stop + 1 - start).bit_length() - 1
        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])

    def __getitem__(self, idx):
        return self._data[0][idx]

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from math import log2
from bisect import bisect_left,bisect_right
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    main()
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")
",O(n ^ 3)
"def res(d,N):
    for i in range(1,N):
        if d[i][1] <= d[i-1][1]:
            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)
    return '-1 -1'

N = int(input())
d = []
for i in range(N):
    a,b = map(int,input().split())
    d.append((a,b,i))
d = sorted(d, key = lambda x:(x[0],-x[1]))
print(res(d,N))
",O(nlogn)
"lr = input()
lr_list = lr.split("" "")
l = int(lr_list[0])
r = int(lr_list[1])
xor = l ^ r

bms = 0
while xor != 0:
    bms = bms + 1
    xor = xor >> 1

maxxor = 0
dois = 1
while bms != 0:
    maxxor = maxxor + dois
    dois = dois << 1
    bms = bms - 1

print(maxxor)
",O(logn)
"class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)",O(n)
"n = int(input())
x, y = map(int, input().split())

if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):
    print('White')
else:
    print('Black')
",O(1)
"n = int(input())-1
c = 0
for i in range(11):
	c += 9*(i+1)* 10**i
	if c > n:
		n -= (c - 9*(i+1)* 10**i)
		v = n // (i+1)
		print(str(10**i + v)[n%(i+1)])
		break
",O(logn)
"class Solution(object):
    def getWinner(self, arr, k):
        result = arr[0]
        count = 0
        for i in range(1, len(arr)):
            if arr[i] > result:
                result = arr[i]
                count = 0
            count += 1
            if (count == k):
                break
        return result",O(n)
"import sys
from array import array

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

n = int(input())
prob = [tuple(map(float, input().split())) for _ in range(n)]
full_bit = (1 << n) - 1
dp = [0.0] * full_bit + [1.0]

for bit in range(full_bit, 0, -1):
    popcount = len([1 for i in range(n) if (1 << i) & bit])
    if popcount == 1 or dp[bit] == 0.0:
        continue
    div = 1 / ((popcount * (popcount - 1)) >> 1)

    for i in range(n):
        if ((1 << i) & bit) == 0:
            continue
        for j in range(i + 1, n):
            if ((1 << j) & bit) == 0:
                continue
            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div
            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div

print(*(dp[1 << i] for i in range(n)))
",np
"n = int(input())
a = []

for i in range(1, n+1):
    l, r = map(int, input().split())
    a.append((l, r, i))

a.sort()

for i in range(n-1):
    if (a[i][0] == a[i+1][0]):
        print(str(a[i][2]) + ' ' + str(a[i+1][2]))
        break

    if (a[i][1] >= a[i+1][1]):
        print(str(a[i+1][2]) + ' ' + str(a[i][2]))
        break
else:
    print('-1 -1')
",O(nlogn)
"n,v=[int(x) for x in input().split()]
if v>=(n-1):
    print(n-1)
else:
    print(int((((n-v)*(n-v+1))/2)-1+v))
",O(1)
"import collections



class Solution(object):
    def minCost(self, nums, k):
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(len(dp)-1):
            cnt = [0]*len(nums)
            d = 0
            for j in range(i+1, len(dp)):
                cnt[nums[j-1]] += 1
                if cnt[nums[j-1]] == 1:
                    d += 1
                elif cnt[nums[j-1]] == 2:
                    d -= 1
                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))
        return dp[-1]",O(n ^ 2)
"class Solution(object):
    def countTexts(self, pressedKeys):
        MOD = 10**9+7
        dp = [1]*5
        for i in range(1, len(pressedKeys)+1):
            dp[i%5] = 0
            for j in reversed(range(max(i-(4 if pressedKeys[i-1] in ""79"" else 3), 0), i)):
                if pressedKeys[j] != pressedKeys[i-1]:
                    break
                dp[i%5] = (dp[i%5]+dp[j%5])%MOD
        return dp[len(pressedKeys)%5]",O(n)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

class Node:
    val = None

    def __init__(self, val):
        self.val = val
        self.left = Node
        self.right = None

def solve(W, H, N, A):
    xs = [0] + [v for t, v in A if t == 0] + [W]
    ys = [0] + [v for t, v in A if t == 1] + [H]
    xs.sort()
    ys.sort()

    xlist = Node(0)
    h = xlist
    xnodes = {0: h}
    maxw = max([xs[i+1] - xs[i] for i in range(len(xs)-1)] or [0])
    maxh = max([ys[i+1] - ys[i] for i in range(len(ys)-1)] or [0])
    for v in xs[1:]:
        n = Node(v)
        xnodes[v] = n
        h.right = n
        n.left = h
        h = n

    ylist =  Node(0)
    h = ylist
    ynodes = {0: h}
    for v in ys[1:]:
        n = Node(v)
        ynodes[v] = n
        h.right = n
        n.left = h
        h = n

    ans = []
    maxarea = maxh * maxw
    for t, v in reversed(A):
        ans.append(maxarea)
        if t == 0:
            node = xnodes[v]
            w = node.right.val - node.left.val
            maxw = max(maxw, w)
        else:
            node = ynodes[v]
            h = node.right.val - node.left.val
            maxh = max(maxh, h)
        node.left.right = node.right
        node.right.left = node.left
        maxarea = maxh * maxw

    return ans[::-1]

def solve2(W, H, N, A):
    ws = [(-W, 0, W)]
    hs = [(-H, 0, H)]
    iw, ih = set(), set()
    ans = []

    xs, ys = [0, W], [0, H]
    for t, v in A:
        if t == 0:
            bisect.insort_left(xs, v)
            i = bisect.bisect_left(xs, v)
            l, m, r = xs[i-1], xs[i], xs[i+1]
            iw.add((l-r, l, r))
            heapq.heappush(ws, (l - m, l, m))
            heapq.heappush(ws, (m - r, m, r))
            while ws[0] in iw:
                heapq.heappop(ws)
        else:
            bisect.insort(ys, v)
            i = bisect.bisect_left(ys, v)
            l, m, r = ys[i-1], ys[i], ys[i+1]
            ih.add((l-r, l, r))
            heapq.heappush(hs, (l - m, l, m))
            heapq.heappush(hs, (m - r, m, r))
            while hs[0] in ih:
                heapq.heappop(hs)
        w, h = ws[0], hs[0]
        ans.append(w[0] * h[0])

    return ans

W, H, N = map(int,input().split())
A = []
for i in range(N):
    a, b = input().split()
    c = 0 if a == 'V' else 1
    A.append((c, int(b)))

print('\n'.join(map(str, solve(W, H, N, A))))",O(nlogn)
"n, c = map(int, input().split())
cnt = [0] * 500005
ans = 0
for v in map(int, input().split()):
    if v == c:
        cnt[c] = cnt[c] + 1
    else:
        if cnt[v] < cnt[c]:
            cnt[v] = cnt[c]
        cnt[v] += 1
    ans = max(ans, cnt[v] - cnt[c])
print(ans + cnt[c])
",O(n)
"class Solution:
    def isValid(self, s: str) -> bool:
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return s == ''
",O(n ^ 2)
"if __name__ == ""__main__"":
    n, s = input().split("" "")
    n = int(n)
    s = int(s)

    sol = 0
    l = 1
    r = n
    while l <= r:
        sum = 0
        i = (l + r)//2
        a = i
        while (a > 0):
            sum += a % 10
            a = a // 10

        if i - sum >= s:
            sol = n - i + 1
            r = i - 1
        else:
            l = i + 1

    print(sol)
",O(logn)
"class Solution(object):
    def maxAdjacentDistance(self, nums):
        return max(abs(nums[i]-nums[i-1]) for i in range(len(nums)))",O(n)
"from collections import defaultdict

n, k = map(int, input().split())

connections = defaultdict(set)

for _ in range(n-1):
	u, v = map(int, input().split())
	connections[u].add(v)
	connections[v].add(u)

leafs = set()
for node in connections:
	if len(connections[node])==1:
		leafs.add(node)

steps = 0
is_correct = True
while is_correct and steps<=k:
	new_leafs = set()
	for x in leafs:
		if len(connections[x])>1:
			is_correct = False

			break
		root = list(connections[x])[0]
		if len(connections[root])<4 and len(leafs)!=3:
			is_correct = False

			break
	if not is_correct:
		break
	for x in leafs:
		root = list(connections[x])[0]
		new_leafs.add(root)
		connections[root].remove(x)
	leafs = new_leafs
	steps += 1
	if len(leafs)==1 and len(connections[list(leafs)[0]])==0:
		break

if is_correct and steps==k:
	print(""Yes"")
else:
	print('No')
",O(nlogn)
"n,m = map(int, input().split())

class Knight:
	def __init__(self, andis, p, c):
		self.p = int(p)
		self.c = int(c)
		self.andis = int(andis)
		self.ans = self.c

p = list(map(int, input().split()))
c = list(map(int, input().split()))
x = []
for i in range(n):
	x.append(Knight(i, p[i], c[i]))

x.sort(key=lambda x: x.p)
coins = []
for i in range(n-1):
	if len(coins) < m:
		coins.append(x[i].c)
		coins.sort()
	elif len(coins) > 0:
		if coins[0] < x[i].c:
			coins[0] = x[i].c
			coins.sort()
	x[i+1].ans += sum(coins)

x.sort(key=lambda x:x.andis)
for k in x:
	print(k.ans, end=' ')
",O(nlogn)
"import collections



class Solution(object):
    def canBeEqual(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"class Solution(object):
    def constructArray(self, n, k):
        result = []
        left, right = 1, n
        while left <= right:
            if k % 2:
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
            if k > 1:
                k -= 1
        return result",O(n)
"class Solution2(object):
    def getHint(self, secret, guess):
        A = sum(map(operator.eq, secret, guess))
        B = sum((Counter(secret) & Counter(guess)).values()) - A
        return ""%dA%dB"" % (A, B)",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

square = set([i**2 for i in range(10**5)])

for _ in range(int(input())):
    n = int(input())
    if n%2:
        print(""NO"")
    else:
        k = n//2
        if k in square:
            print(""YES"")
        elif k%2:
            print(""NO"")
        else:
            k = k//2
            if k in square:
                print(""YES"")
            else:
                print(""NO"")
",O(1)
"n,m = map(int,input().split())
final = []
for i in range(n):
    a,b = map(int,input().split())
    final.append([a,b])
final.sort(key = lambda x: x[0]-x[1])
s1 = 0
s2 = 0
for i in final:
    s2+=i[1]
    s1+=i[0]
if s2>m:
    print(-1)
else:
    if s1<=m:
        print(0)
    else:
        i = n-1
        count = 0
        while s1>m:
            s1 = s1 - (final[i][0]-final[i][1])
            count+=1
            i-=1
        print(count)
",O(nlogn)
"import collections


class Solution(object):
    def canArrange(self, arr, k):
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in range(1, k) if i in count)",O(n)
"import sys

input = sys.stdin.readline

def main():

	a = input().split("" "")
	n = int(a[0])
	d = int(a[1])
	k = int(a[2])

	if d > n - 1:
		sys.stdout.write(""NO\n"")
		return

	par = [-1 for i in range(n)]
	prevlevel = [0]
	bad = [False for i in range(n)]
	clevel = []
	cdep = 1
	callow = k
	cnode = 1
	firstchild = 1

	for i in range(1, n):

		if len(clevel) == callow:
			prevlevel = clevel
			clevel = []
			cdep += 1
			callow *= (k - 1)
			firstchild *= (k - 1)

		cdiv = k
		if cdep > 1:
			cdiv -= 1
		if cdiv == 0:
			sys.stdout.write(""NO\n"")
			return

		par[cnode] = prevlevel[len(clevel) // cdiv]
		clevel.append(cnode)

		cnode += 1

	mdep = d // 2

	if cdep > mdep + 1:
		sys.stdout.write(""NO\n"")
		return

	if cdep == mdep + 1 and ((d % 2 == 0)):
		sys.stdout.write(""NO\n"")
		return

	if cdep == mdep + 1 and len(clevel) > firstchild:
		sys.stdout.write(""NO\n"")
		return

	attach1 = -1
	attach2 = -1

	d1 = cdep
	d2 = cdep

	attach1 = clevel[0]
	if len(clevel) > firstchild:
		attach2 = clevel[-1]
	else:
		attach2 = prevlevel[-1]
		d2 -= 1

	te = attach1
	while te != -1:
		bad[te] = True
		te = par[te]
	te = attach2
	while te != -1:
		bad[te] = True
		te = par[te]

	cptr = n - 1
	while d1 + d2 < d:
		if bad[cptr]:
			cptr -= 1
			continue

		if d2 < d1:
			par[cptr] = attach2
			attach2 = cptr
			d2 += 1
		else:
			par[cptr] = attach1
			attach1 = cptr
			d1 += 1

		cptr -= 1

	sys.stdout.write(""YES\n"")
	for i in range(1, n):
		sys.stdout.write(str(i + 1) + "" "" + str(par[i] + 1) + ""\n"")

main()",O(n ^ 2)
"n = int(input())
if n <= 4:
    print(""YES"")
    exit()

A = [None]*n

for i in range(n):
    A[i] = list(map(int,input().split()))

def is_colinear(a1,a2,a3):
    if a1 == a2 or a2 == a3 or a1 == a3:
        return True

    x1,y1 = a1
    x2,y2 = a2
    x3,y3 = a3

    if x1 == x2 or x1 == x3 or x2 == x3:
        return x1 == x2 == x3
    if y1 == y2 or y1 == y3 or y2 == y3:
        return y1 == y2 == y3
    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)

X,Y,Z = A[0],A[1],A[2]

def good(X,Y):

    bad = []
    for i in range(n):
        if not is_colinear(X,Y,A[i]):
            bad.append(A[i])

    if len(bad) <= 2:
        return True

    U,V = bad[0],bad[1]
    for i in range(len(bad)):
        if not is_colinear(U,V,bad[i]):
            return False
    return True

if good(X,Y) or good(Y,Z) or good(X,Z):
    print(""YES"")
    exit()

print(""NO"")
exit()
",O(nlogn)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x

from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
import heapq
from random import randint as rn
from Queue import Queue as Q
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1
import heapq
k=[(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)]
def gg(i,j):
    if(i<n-2 and j<m-2):
        f=0
        for g in range(8):
            if(w[i+k[g][0]][j+k[g][1]]=="".""):
                f=1
        if(f!=1):
            for g in range(8):
                p[i+k[g][0]][j+k[g][1]]=1

n=input()
w=n
d=1
p=[]
while(n!=1):
    t=(n+1)/2
    for i in range(t):
        p.append(str(d))
    n-=t
    if(n==1):
        break
    d*=2
if(w%d==0):
    p.append(str(w))
else:
    g=w/d
    r=d*g
    p.append(str(r))
stdout.write("" "".join(p))
",O(logn)
"class Solution3(object):
    def minimumPerimeter(self, neededApples):
        def check(neededApples, x):
            return r*(2*r+1)*(2*r+2) >= neededApples

        left, right = 1, int((neededApples/4.0)**(1.0/3))
        while left <= right:
            mid = left + (right-left)//2
            if check(neededApples, mid):
                right = mid-1
            else:
                left = mid+1
        return 8*left",O(logn)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

def solve2(s, t, left, right):
    n = len(s)
    m = len(t)
    nuxt = [-1]*(left+1)
    nuxt[0] = 0

    for i in range(n):
        for j in reversed(range(left+1)):
            k = nuxt[j]
            if k == -1:
                continue
            if j != left:
                if s[i] == t[j]:
                    nuxt[j+1] = max(nuxt[j+1], k)
            if k != right:
                if s[i] == t[left+k]:
                    nuxt[j] = max(nuxt[j], k+1)
    return nuxt[-1]==right

def solve():
    s = input()
    t = input()
    m = len(t)
    for i in range(m+1):
        if solve2(s,t,i,m-i):
            print(""YES"")
            return
    print(""NO"")

t = int(input())
for i in range(t):
    solve()
",O(n ^ 3)
"def f(ch):
    if ch=='0':
        return 0
    else:
        return 1

U=[ [f(i) for i in list(input())],
    [f(i) for i in list(input())]]
i=0
size=len(U[0])
ans=0
while i+1<size:
    if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1:
        i+=1
        continue
    elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        U[1][i+1]=1
        ans+=1
    else:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        ans+=1

    i+=1

print(ans)
",O(1)
"class Solution(object):
    def minimumOneBitOperations(self, n):
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n >>= 1
            return result
        return gray_to_binary(n)",O(logn)
"class Solution(object):
    def validMountainArray(self, A):
        i = 0
        while i+1 < len(A) and A[i] < A[i+1]:
            i += 1
        j = len(A)-1
        while j-1 >= 0 and A[j-1] > A[j]:
            j -= 1
        return 0 < i == j < len(A)-1",O(n)
"import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) >= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return """".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return """".join(result)",O(n)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    a = [int(x) for x in input().split(' ')]
    a_pows = []
    a_pow_dict = [{} for u in range(11)]
    for j in range(n):
        x = a[j] % k
        i = 0
        while i < 11:
            if x in a_pow_dict[i]:
                a_pow_dict[i][x] += 1
            else:
                a_pow_dict[i][x] = 1
            i += 1
            x = (x * 10) % k

    c = 0

    for x in a:
        m = len(str(x))
        if (-x) % k in a_pow_dict[m]:
            c += a_pow_dict[m][(-x) % k]
            c -= int(int(str(x) * 2) % k == 0)

    return c

print(solve())",O(nlogn)
"def max_profit(n,k,l,d):
    a=[]
    p,i=0,-1
    while(len(a)!=k-1):
        p+=1
        i+=1
        if l[i] in d:
            a.append(p)
            p=0
            d.remove(l[i])
    a.append(n-sum(a))
    print(*a)

n,k=map(int,input().split())
l=list(map(int,input().split()))
d=sorted(l,reverse=True)[:k]
print(sum(d))
max_profit(n,k,l,d)",O(nlogn)
"for _ in range(int(input())):
    a,b = map(int, input().split())
    c = 0
    while (a!=0 and b!=0):
        if (a>b) :
            c+= a//b
            a = a%b
        elif (b>a):
            c+= b//a
            b = b%a
        else :
            c+=1
            break
    print(c)",O(1)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):
    hcenter, hlen = [int(item) for item in input().split(' ')]
    cont.append([hcenter - hlen / 2, hcenter + hlen / 2])

cont.sort(key=lambda item: item[0])

for i in range(n - 1):
    gap = cont[i + 1][0] - cont[i][1]
    if gap == t:
        ans += 1
    elif gap > t:
        ans += 2

print(ans)",O(nlogn)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        q1 = deque([p])
        q2 = deque([q])

        while q1 and q2:
            for _ in range(len(q1)):
                nodeP = q1.popleft()
                nodeQ = q2.popleft()

                if nodeP is None and nodeQ is None:
                    continue
                if nodeP is None or nodeQ is None or nodeP.val != nodeQ.val:
                    return False

                q1.append(nodeP.left)
                q1.append(nodeP.right)
                q2.append(nodeQ.left)
                q2.append(nodeQ.right)

        return True
",O(n)
"class Solution2(object):
    def getRow(self, rowIndex):
        result = [1]
        for i in range(1, rowIndex + 1):
            result = [1] + [result[j - 1] + result[j] for j in range(1, i)] + [1]
        return result",O(n ^ 2)
"class Solution(object):
    def largeGroupPositions(self, S):
        result = []
        i = 0
        for j in range(len(S)):
            if j == len(S)-1 or S[j] != S[j+1]:
                if j-i+1 >= 3:
                    result.append([i, j])
                i = j+1
        return result",O(n)
"class Solution(object):
    def checkRecord(self, s):
        count_A = 0
        for i in range(len(s)):
            if s[i] == 'A':
                count_A += 1
                if count_A == 2:
                    return False
            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':
                return False
        return True",O(n)
"from collections import defaultdict
import bisect
from itertools import accumulate, count
import os
import sys
import math
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

s=input()
neg=0
if int(s)<0:
    neg=1
ans1 = """"
s=int(s)
s=abs(s)
s=str(s)
ans2 = """"
for i in range(0, len(s)):
    if i == len(s)-2:
        ans1 += s[i]
    elif i == len(s)-1:
        ans2 += s[i]
    else:
        ans1 += s[i]
        ans2 += s[i]
if neg==0:
    print(s)
else:
    if str(min(int(ans1), int(ans2)))==""0"":
        print(0)
    else:
        print(""-""+str(min(int(ans1), int(ans2))))
",O(1)
"N = int(input())
src = [tuple(map(int,input().split() + [i])) for i in range(N)]
src.sort()

prev_l = max_r = 0
prev_i = outer = -1
for l,r,i in src:
    if prev_l == l:
        print(prev_i+1, i+1)
        exit()
    if r <= max_r:
        print(i+1, outer+1)
        exit()
    else:
        max_r = r
        outer = i
    prev_l = l
    prev_i = i
print(-1,-1)
",O(nlogn)
"n, k = [int(a) for a in input().split()]
power = [int(a) for a in input().split()]
coins = [int(a) for a in input().split()]

dp = [0 for i in range(n)]

def takeSecond(elem):
    return elem[1]

def takeFirst(elem):
    return elem[0]

people = [(power[i], coins[i], i) for i in range(n)]

people.sort(key=takeFirst)

dp[0] = []

for i, p in enumerate(people):
    if i == 0:
        continue
    kills = [i for i in dp[i - 1]]
    kills.append(people[i - 1][1])
    x = []

    if len(kills) > k:
        kills.remove(min(kills))

    dp[i] = kills

x = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]

x.sort(key=takeFirst)

print("" "".join([z[1] for z in x]))
",O(nlogn)
"n,l,r,x = [int(x) for x in input().split()]

a = [int(x) for x in input().split()]

cnt =0

for i in range(0,1<<n):

  sum=0;mn=int(1e18);mx=0;

  for j in range(0,n):

    if((i>>j)&1):
      sum += a[j]
      mn = min(mn,a[j])
      mx = max(mx,a[j])

  if (sum>=l and sum<=r and (mx-mn)>=x):
      cnt +=1

print(cnt)",np
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')
",O(n ^ 2)
"from bisect import bisect_right,bisect_left
n,c_tv,c_es=map(int,input().split())
start=[]
end=[]
add=0
for _ in range(n):
    l,r=map(int,input().split())
    add+=(r-l)
    start.append(l)
    end.append(r)
start.sort()
end.sort()
ans=add*c_es+n*c_tv
M=10**9+7
v=[0]*(n+1)
for i in range(n):
    indx=bisect_left(end,start[i])-1
    k=indx
    while k>=0 and (start[i]-end[k])*c_es<c_tv and v[k]==1:
        k-=1
    if k==-1:
        continue
    if (start[i]-end[k])*c_es<c_tv:
        ans-=c_tv-(start[i]-end[k])*c_es
        v[k]=1
print(ans%M)",O(nlogn)
"import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def possible(x):
    days=n-x
    tot=days*(days+1)//2

    return tot-x<=k

n,k=value()

low=0
high=n

while(low<=high):

    mid=(low+high)//2

    if(possible(mid)):
        high=mid-1
    else:
        low=mid+1

print(low)
",O(logn)
"import pandas as pd



def Solution(products: pd.DataFrame) -> pd.DataFrame:
    products[""quantity""].fillna(0, inplace=True)
    return products",O(n)
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)
        power = lam = 1

        while slow != fast:
            if power == lam:
                slow = fast
                power *= 2
                lam = 0
            fast = self.sumOfSquares(fast)
            lam += 1
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"import sys
import math

t=1
for _ in range(t):

    a=input()
    b=input()
    dp=[0]*(11)
    for i in a:
        dp[int(i)]+=1

    if len(b)>len(a):
        ans=''
        for i in range(len(a)):
            for j in range(9,-1,-1):
                if dp[j]!=0:
                    ans+=str(j)
                    dp[j]-=1
                    break
    elif len(a)==len(b):
        ans=''
        a1=[]
        cmpr=''
        i=0
        while i<len(a):
            cmpr+=b[i]

            if i==0:
                flag=0
                for j in range(9,0,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        dp[j]-=1
                        ans+=str(j)
                        a1.append(j)
                        break
                if flag==0:
                    dp[1]-=1
                    a1.append(1)
                    ans+='1'
            else:
                flag=0
                for j in range(9,-1,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        ans+=str(j)
                        a1.append(j)
                        dp[j]-=1
                        break

                if flag==0:
                    ch=0
                    for i1 in range(i-1,-1,-1):
                        if ch==1:
                            break
                        for j1 in range(int(ans[i1])-1,-1,-1):
                            if i1==0:
                                if j1>0 and dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    index=i1
                                    a1.pop()
                                    a1.append(j1)
                                    ch=1
                                    break
                            else:
                                if  dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    a1.pop()
                                    index=i1

                                    a1.append(j1)
                                    ch=1
                                    break
                            if ch==1:
                                break
                        if ch==1:
                            break
                        val=a1.pop()
                        dp[val]+=1

                    ans=''
                    cmpr=''

                    dp=[0]*11
                    for i1 in range(len(a)):
                        dp[int(a[i1])]+=1

                    for i1 in range(len(a1)):
                        dp[a1[i1]]-=1

                    for i1 in range(len(a1)):
                        ans+=str(a1[i1])
                        cmpr+=b[i1]
                    i=index

            i+=1
    print(ans)",O(n ^ 3)
"class Solution(object):
    def nearestValidPoint(self, x, y, points):
        smallest, idx = float(""inf""), -1
        for i, (r, c) in enumerate(points):
            dx, dy = x-r, y-c
            if dx*dy == 0 and abs(dx)+abs(dy) < smallest:
                smallest = abs(dx)+abs(dy)
                idx = i
        return idx",O(n)
"class Solution(object):
    def mergeTriplets(self, triplets, target):
        result = [0]*3
        for t in triplets:
            if all(t[i] <= target[i] for i in range(3)):
                result = [max(result[i], t[i]) for i in range(3)]
        return result == target",O(n)
"import math
s1=input()
s2=input()
dist=0
pos=0
unrecognized=0
for i in s1:
	if i ==""+"":
		dist+=1
	else:
		dist-=1

for i in s2:
	if i ==""+"":
		pos+=1
	elif i==""-"":
		pos-=1
	elif i==""?"":
		unrecognized+=1
difference=dist-pos

if abs(difference)>abs(unrecognized):
	print(""{0:.9f}"".format(float(0)))
else:
	extra=unrecognized-abs(difference)
	perm_extra=1
	for i in range(1,unrecognized+1):
			perm_extra=perm_extra*i
	perm_extra=perm_extra/(math.factorial(extra/2+(unrecognized-extra))*math.factorial(extra/2))
	if extra%2!=0:
		print(""{0:.9f}"".format(float(0)))
	else:
		print(""{0:.9f}"".format(float(perm_extra*(0.5**unrecognized))))
",np
"

class Solution(object):
    def numberOfEmployeesWhoMetTarget(self, hours, target):
        return sum(x >= target for x in hours)
",O(n)
"l=list(map(int,input().split()))
s1,s2,s3,s4=0,0,0,0
for i in l:
	if i==1:
		s1+=1
	if i==2:
		s2+=1
	if i==3:
		s3+=1
	if i==4:
		s4+=1

if s3>2 or s2>1 or s1>0 or (s4==2 and s2==1):
	print(""YES"")
else:
	print(""NO"")",O(1)
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",O(n ^ 2)
"n = int(input())
x, y = list(map(int, input().strip().split()))

if n-x + n-y >= x-1 + y-1:
	print(""White"")
else:
	print(""Black"")",O(1)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            n &= n - 1
            res += 1
        return res
",O(1)
"import math
import sys
import collections
import bisect
import time
import random
from itertools import permutations
def get_ints():return map(int, sys.stdin.readline().strip().split())
def get_list():return list(map(int, sys.stdin.readline().strip().split()))
def get_string():return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    unique=set(arr)
    poss=False
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique and i-(2**j) in unique:
                print(3)
                print(i,i+2**j,i-2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique:
                print(2)
                print(i,i+2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    print(1)
    print(arr[0])",O(nlogn)
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",O(n ^ 3)
"a, b = [int(x) for x in input().split(' ')]
idx = 0
if(a == b):
    print(0)
else:
    for i in range(63,-1,-1):
        set1 = (a >> i) & 1
        set2 = (b >> i) & 1
        if(set1!=set2):
            idx = i
            break
    print((1<<(idx+1))-1)",O(logn)
"n , m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
diff = [0] * n
for i in range(n):
	if a[i] < m:
		diff[i] = -1
	if a[i] > m:
		diff[i] = 1

aim = a.index(m)
left = {}
right = {}
suml = 0
for i in reversed(range(aim + 1)):
	suml += diff[i]
	if not suml in left:
		left[suml] = 0
	left[suml] += 1

sumr = 0
for i in range(aim, n):
	sumr += diff[i]
	if not sumr in right:
		right[sumr] = 0
	right[sumr] += 1

ans = 0
for i in left:
	wk1 = -i
	if wk1 in right:
		ans += left[i] * right[wk1]
	wk1 = 1 - i
	if wk1 in right:
		ans += left[i] * right[wk1]

print(ans)
",O(nlogn)
"n,k=map(int,input().split())
print(-(-k//n))",O(1)
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))",O(n ^ 2)
"from sys import stdin, stdout

nxt = []

def find_it(s, left, right):
    global nxt
    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]
    dp[0][0] = 0
    for i in range(len(left)+1):
        for j in range(len(right)+1):
            if dp[i][j] > len(s):
                continue
            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:
                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:
                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1
            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:
                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:
                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1
    if dp[len(left)][len(right)] != 1000:
        return True
    else:
        return False

def main():
    global nxt
    n = int(stdin.readline())
    for _ in range(n):
        s = stdin.readline().rstrip()
        t = stdin.readline().rstrip()
        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)]
        for i,x in enumerate(s):
            nxt[ord(x) - 97][i] = i
        for i in range(26):
            for j in range(len(s)-1 ,-1,-1):
                if nxt[i][j] != j:
                    nxt[i][j] = nxt[i][j+1]

        r = False
        for i in range(len(t)):
            res = find_it(s, t[:i], t[-len(t)+i:])
            if res is True:
                r = True
                break

        if r is True:
            stdout.write(""YES\n"")
        else:
            stdout.write(""NO\n"")

main()",O(n ^ 3)
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
",O(n ^ 2)
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np
"class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0",O(n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = {}

        def dfs(i, buying):
            if i >= len(prices):
                return 0
            if (i, buying) in dp:
                return dp[(i, buying)]

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                dp[(i, buying)] = max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                dp[(i, buying)] = max(sell, cooldown)
            return dp[(i, buying)]

        return dfs(0, True)
",O(n)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    cost = n
    ind = 0
    while ind < len(table):
        cost = min(cost, n - ind - 1 + table[ind])
        ind += 1

    return cost

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"import collections


class Solution(object):
    def leastBricks(self, wall):
        widths = collections.defaultdict(int)
        result = len(wall)
        for row in wall:
            width = 0
            for i in range(len(row)-1):
                width += row[i]
                widths[width] += 1
                result = min(result, len(wall) - widths[width])
        return result",O(n)
"class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack",O(n)
"from collections import defaultdict as di

n = int(input())
a = list(map(int, input().split()))
d = di(int)
res, sum = 0, 0
for i in range(n):
	res += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]
	sum += a[i]
	d[a[i]] += 1
print(res)",O(nlogn)
"class Solution(object):
    def minRemoveToMakeValid(self, s):
        result = list(s)
        count = 0
        for i, v in enumerate(result):
            if v == '(':
                count += 1
            elif v == ')':
                if count:
                    count -= 1
                else:
                    result[i] = """"
        if count:
            for i in reversed(range(len(result))):
                if result[i] == '(':
                    result[i] = """"
                    count -= 1
                    if not count:
                        break
        return """".join(result)",O(n)
"def main():
    n = int(input())

    s = []

    for i in range(n):
        s.append(input())

    for i in s:
        for j in s:
            if (i not in j) and (j not in i):
                print('NO')
                return

    print('YES')
    s = sorted(s, key=lambda x : len(x))
    for pal in s:
        print(pal)

main()
",O(nlogn)
"import sys,os,io,time,copy,math
from functools import lru_cache
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

def main():
    n,k=map(int,input().split())
    arr=[]
    for i in range(n):
        x,y=map(int,input().split())
        arr.append((x,y))
        arr.sort(key=lambda x:(x[0],-x[1]),reverse=True)
    req=arr[k-1]
    count=0
    for a in arr:
        if a==req:
            count+=1
    print(count)

main()
",O(nlogn)
"class Solution(object):
    def removeDuplicates(self, S):
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return """".join(result)",O(n)
"from collections import defaultdict

def read_line():
    return [int(x) for x in input().split()]

def solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):
    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    d = {}
    for i in range(1, m+1):
        for j in range(1, n+1):
            d[(i, j)] = col(i, j)
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            d[(i, j)] = 'W'
    for i in range(x3, x4+1):
        for j in range(y3, y4+1):
            d[(i, j)] = 'B'
    return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B'])

def rnd_test():
    from random import randint
    n = randint(1, 50)
    m = randint(1, 50)
    x1, x2, x3, x4 = [randint(1, m) for _ in range(4)]
    y1, y2, y3, y4 = [randint(1, n) for _ in range(4)]
    x1, x2 = min(x1, x2), max(x1, x2)
    y1, y2 = min(y1, y2), max(y1, y2)
    x3, x4 = min(x3, x4), max(x3, x4)
    y3, y4 = min(y3, y4), max(y3, y4)
    assert solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4)

def solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):

    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    def cols(x1, y1, x2, y2):
        assert inside(x1, y1) and inside(x2, y2)
        assert x1 <= x2 and y1 <= y2
        w, h = x2+1-x1, y2+1-y1
        if w % 2 == 0 or h % 2 == 0:
            return w*h // 2, w*h // 2
        else:
            WH, BL = w*h // 2, w*h // 2
            if col(x1, y1) == 'W':
                WH += 1
            else: BL += 1
            return WH, BL

    def overlap():
        X1 = max(x1, x3)
        X2 = min(x2, x4)
        Y1 = max(y1, y3)
        Y2 = min(y2, y4)
        if X1 > X2 or Y1 > Y2: return None
        return X1, Y1, X2, Y2

    tot_wh, tot_bl = cols(1, 1, m, n)

    A_wh, A_bl = cols(x1, y1, x2, y2)
    ovrlp = overlap()
    if ovrlp is not None:
        O_wh, O_bl = cols(*ovrlp)
        assert A_wh >= O_wh and A_bl >= O_bl
        A_wh -= O_wh
        A_bl -= O_bl

    B_wh, B_bl = cols(x3, y3, x4, y4)

    tot_wh += A_bl
    tot_bl -= A_bl

    tot_wh -= B_wh
    tot_bl += B_wh
    return(tot_wh, tot_bl)

t = int(input())

for _ in range(t):
    n, m = read_line()
    x1, y1, x2, y2 = read_line()
    x3, y3, x4, y4 = read_line()
    print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4))
",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findNeartestRightNode(self, root, u):
        q = [root]
        while q:
            new_q = []
            for i, node in enumerate(q):
                if node == u:
                    return q[i+1] if i+1 < len(q) else None
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            q = new_q
        return None",O(n)
"b = list(map(int, input().split()))
n = 14
ans = 0
for i in range(n):
    a = b.copy()
    if a[i] == 0:
        continue
    x = a[i]
    a[i] = 0
    full = x // n
    xex = x % n
    for j in range(n):
        a[j] += full
    for j in range(xex):
        a[(i + j + 1) % n] += 1
    pot = 0
    for j in a:
        if j % 2 == 0:
            pot += j
    ans = max(ans, pot)
print(ans)
",O(1)
"class Solution(object):
    def resultArray(self, nums):
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            if a[-1] > b[-1]:
                a.append(nums[i])
            else:
                b.append(nums[i])
        return a+b",O(n)
"n, s = map(int, input().split())
print((s + n - 1) // n)",O(1)
"b = [list(input()) for _ in range(2)]

n = len(b[0])
ans = 0
a = []
for i in range(n):
    ai = 0
    if b[0][i] == '0':
        ai += 1
    if b[1][i] == '0':
        ai += 1
    a.append(ai)
prv = 0
for i in range(n):
    if a[i] == 0:
        prv = 0
    elif a[i] == 1:
        if prv == 2:
            ans += 1
            prv = 0
        else:
            prv = 1
    elif a[i] == 2:
        if prv == 2:
            ans += 1
            prv = 1
        elif prv == 1:
            ans += 1
            prv = 0
        else:
            prv = 2
print(ans)",O(1)
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",O(1)
"
class Solution(object):
    def oddEvenList(self, head):
        if head:
            odd_tail, cur = head, head.__next__
            while cur and cur.__next__:
                even_head = odd_tail.__next__
                odd_tail.next = cur.__next__
                odd_tail = odd_tail.__next__
                cur.next = odd_tail.__next__
                odd_tail.next = even_head
                cur = cur.__next__
        return head

",O(n)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

pr = lambda x:    x
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
    n, = aj()
    A = aj()
    if A.count(0) >= 2:
        print('cslnb')
    elif n == 1:
        if A[0]%2:
            print('sjfnb')
        else:
            print('cslnb')
    else:
        g2 = 0;flag = 1
        C = Counter(A)
        for i in C.keys():
            if C[i] >= 3:
                flag = 0
            if C[i] == 2 and C[i-1] >= 1:
                flag = 0
            if C[i] == 2:
                g2 += 1
        if g2 >= 2:
            flag = 0
        if not flag:
            print('cslnb')
        else:
            movescount = 0
            A.sort()
            for ii,i in enumerate(A):
                movescount += i - ii
            if movescount % 2 == 0:
                print('cslnb')
            else:
                print('sjfnb')

try:

    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from aj import *
except:
    pass

solve()",O(nlogn)
"class Solution(object):
    def countGoodRectangles(self, rectangles):
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side > mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result",O(n)
"import collections


class Solution(object):
    def longestPalindrome(self, words):
        cnt = collections.Counter(words)
        result = remain = 0
        for x, c in cnt.items():
            if x == x[::-1]:
                result += c//2
                remain |= c%2
            elif x < x[::-1] and x[::-1] in cnt:
                result += min(c, cnt[x[::-1]])
        return result*4+remain*2",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph()])
        a1.fliph()
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"print(int(input())//2 + 1)
",O(1)
"class Solution2(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        dp = [0]*(num_people//2+1)
        dp[0] = 1
        for k in range(1, num_people//2+1):
            for i in range(k):
                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD
        return dp[num_people//2]",O(n ^ 2)
"class Solution(object):
    def nextPalindrome(self, num):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        nums = list(num)
        if not next_permutation(nums, 0, len(nums)//2):
            return """"
        for i in range(len(nums)//2):
            nums[-1-i] = nums[i]
        return """".join(nums)",O(n)
"import sys

int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",np
"from sys import stdin
from itertools import permutations

rints = lambda: [int(x) for x in stdin.readline().split()]
x1, y1, x2, y2, x3, y3 = rints()

for x in [[x1, y1], [y1, x1]]:
    for y in [[x2, y2], [y2, x2]]:
        for z in [[x3, y3], [y3, x3]]:
            if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]:
                print(x[1])
                print('\n'.join(
                    ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in
                                                                                             range(z[0])]))
                exit()

for per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3):
    for x in per[0][:-1]:
        for y in per[1][:-1]:
            for z in per[2][:-1]:
                if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]:
                    print(x[1])
                    print('\n'.join(
                        [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in
                                                                    range(y[0])]))
                    exit()

print(-1)
",np
"class Solution(object):
    def countAsterisks(self, s):
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result",O(n)
"n, k = list(map(int, input().split()))
a = list(map(int, input().split()))

a = sorted(a)

cur_v = a[0]
cur_count = 1
ans = 0

for i in range(1, len(a)):

    if a[i] > a[i-1] and a[i] > a[i-1]+k:
        ans += cur_count
        cur_count = 1
    elif a[i] == a[i-1]:
        cur_count += 1
    elif a[i] > a[i-1]:
        cur_count = 1

ans += cur_count

print(ans)",O(nlogn)
"class Solution2(object):
    def countWays(self, nums):
        nums.sort()
        return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in range(len(nums)+1))",O(nlogn)
"import heapq



class Solution(object):
    def convertArray(self, nums):
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x < -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))",O(nlogn)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(logn)
"import sys, math, queue

MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]
dp[0][0] = a[0]-k

for i in range(1, n):
	for j in range(m):
		if j == 0:
			dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
		else:
			dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())

    a = list(map(int, input().split()))

    mod =  10**9 + 7
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np
"class Solution(object):
    def minimumLength(self, s):
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                break
            c = s[left]
            while left <= right:
                if s[left] != c:
                    break
                left += 1
            while left <= right:
                if s[right] != c:
                    break
                right -= 1
        return right-left+1",O(n)
"import sys

from bisect import bisect_right as rb
from collections import deque

from queue import PriorityQueue
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

def bit(n) :
    if (n == 0) :return 0
    val = 1

    while (val&n) == 0 :
        val *= 2

    return val

n,q = il()
x = n+1

for i in range(q) :
    t1 = ii()

    for j in ip() :
        val = bit(t1)

        if (j == ""U"") :
            tem = (t1-val)|(val*2)
            if (tem < n) :
                t1 = tem
        elif (j == ""L"" and val>1) :
            t1 -= val//2
        elif (j == ""R"" and val>1) :
            t1 += val//2

    print(t1)
",np
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",O(nlogn)
"def main():
    n,k=map(int,input().split( ))
    a=list(map(int,input().split( )))
    ans=-1*10**9+7
    for i in range(n):
        s=0
        for j in range(i,n):
            s+=a[j]
            if j-i+1>=k:

                ans=max(ans,s/(j-i+1))
    print(ans)

main()",O(n ^ 2)
"import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        min_heap = []
        result = i = 0
        while i < len(apples) or min_heap:
            if i < len(apples) and apples[i] > 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result",O(nlogn)
"import bisect

def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return bisect.bisect_left(p, p[-1] / 2)

print(solve())",O(n)
"import collections


class Solution(object):
    def subarraysDivByK(self, A, K):
        count = collections.defaultdict(int)
        count[0] = 1
        result, prefix = 0, 0
        for a in A:
            prefix = (prefix+a) % K
            result += count[prefix]
            count[prefix] += 1
        return result",O(n)
"N = int(input())
terms = 1
n = 9
total = 0

while N > terms*n:
	N = N - terms*n
	total = total + n
	terms=terms+1
	n = n*10
print(str(total+(N+terms-1)//terms)[(N-1)%terms])
",O(logn)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k = tup()
s , i = S() , 1
while s[i:] != s[:-i] :i+=1
print(s[:i]*k + s[i:])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def increasingBST(self, root):
        def increasingBSTHelper(root, tail):
            if not root:
                return tail
            result = increasingBSTHelper(root.left, root)
            root.left = None
            root.right = increasingBSTHelper(root.right, tail)
            return result
        return increasingBSTHelper(root, None)

",O(n)
"a = int(input())
print((a // 2) * 3)",O(1)
"T = int(input())
for ti in range(T):
    s = input().strip()
    t = input().strip()
    N = len(t)
    for i in range(1, N+1):

        dp = [[0]+[-1]*i for _ in range(len(s)+1)]
        for l, c in enumerate(s):
            for j in range(i+1):
                dp[l+1][j] = dp[l][j]

                if dp[l][j] != -1:
                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:
                        dp[l+1][j] = dp[l][j]+1

                if j != 0 and c == t[j-1]:
                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])

        if dp[-1][i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")
",O(n ^ 3)
"import math
def max_sub(arr,n):
	dp = [0]*n
	dp[0] = arr[0]
	for i in range(1,n):
		dp[i] = max(dp[i-1]+arr[i],arr[i])
	return max(0,max(dp))
n,m,k = map(int,input().split())
arr = list(map(int,input().split()))
q = -math.inf
dp = [0]*(300100)
for i in range(300100):
	dp[i] = [q]*(11)
if (m==1):
	for i in range(n):
		arr[i]= arr[i]-k
	print(max_sub(arr,n))
else:
	for i in range(n):
		dp[i][1] = arr[i]-k
		for j in range(m):
			if (i-1<0 or dp[i-1][j]==q):
				continue
			if ((j+1)%m!=1):
				dp[i][(j+1)%m] = dp[i-1][j]+arr[i]
			else:
				dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)
	ma=0
	for i in range(n):

		for j in range(m):

			ma = max(ma,dp[i][j])

	print(ma)",O(n ^ 2)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2):
        cnt = [0]*2
        for x, y in zip(nums1, nums2):
            if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])):
                return -1
            if not (x <= nums1[-1] and y <= nums2[-1]):
                cnt[0] += 1
            if not (x <= nums2[-1] and y <= nums1[-1]):
                cnt[1] += 1
        return min(cnt)",O(n)
"def factorial(n):
    if n<=1:
        return 1
    return n*factorial(n-1)

original = input()
received = input()

originalNum = original.count('+') - original.count('-')
receivedNum = received.count('+') - received.count('-')

variance = received.count('?')

difference = abs(originalNum - receivedNum)

if variance==0:
    if difference==0:
        print(1.)
    else:
        print(0.)
elif difference > variance or difference%2!=variance%2:
    print(0.)
else:
    difference += variance
    difference//=2

    c = factorial(variance)/(factorial(difference)*factorial(variance-difference))
    print(c/(2**variance))
",np
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
fl = 0
m = n
s = list(range(n))
for i in range(n):
    s[i] = m - (l[i] + r[i])
    if fl != 1 and s[i] == m:
        fl = 1
for i in range(n):
    ll = 0;
    for j in range(i):
        if s[j] > s[i]:
            ll += 1
    rr = 0
    for j in range(i + 1, n):
        if s[j] > s[i]:
            rr += 1
    if l[i] != ll or rr != r[i]:
        fl = 0
        break

if fl == 1 and l[0] == 0 and r[n - 1] == 0:
    print('YES')
    print(*s)
else:
    print('NO')
",O(n ^ 2)
"x= int(input(""""))
print(int((x/2)*3))",O(1)
"class Solution2(object):
    def findDuplicates(self, nums):
        result = []
        i = 0
        while i < len(nums):
            if nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
            else:
                i += 1

        for i in range(len(nums)):
            if i != nums[i]-1:
                result.append(nums[i])
        return result",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(50001)]
pp=[]
def SieveOfEratosthenes(n=50000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    for i in range(50001):
        if prime[i]:
            pp.append(i)

n,m,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
if k>=m:
    print(0)
else:
    curr=k
    count=0
    for i in range (n):
        curr+=a[i]-1
        count+=1
        if curr>=m:
            break
    if curr>=m:
        print(count)
    else:
        print(-1)",O(nlogn)
"import collections


class Solution(object):
    def findClosestLeaf(self, root, k):
        def traverse(node, neighbors, leaves):
            if not node:
                return
            if not node.left and not node.right:
                leaves.add(node.val)
                return
            if node.left:
                neighbors[node.val].append(node.left.val)
                neighbors[node.left.val].append(node.val)
                traverse(node.left, neighbors, leaves)
            if node.right:
                neighbors[node.val].append(node.right.val)
                neighbors[node.right.val].append(node.val)
                traverse(node.right, neighbors, leaves)

        neighbors, leaves = collections.defaultdict(list), set()
        traverse(root, neighbors, leaves)
        q, lookup = [k], set([k])
        while q:
            next_q = []
            for u in q:
                if u in leaves:
                    return u
                for v in neighbors[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    next_q.append(v)
            q = next_q
        return 0",O(n)
"def NOD(a, b):
    while b != 0:
        a %= b
        y = a
        a = b
        b = y
    return(a)

def NOK(a, b):
    i = (a*b) // NOD(a, b)
    return(i)

n = int(input())
maxnok = 0
x = 40
for i in range(max(1, n-x), n+1):
    for j in range(max(1, i-x), i+1):
        for f in range(max(1, j-x), j+1):
            nokk = NOK(NOK(i,j), f)
            if maxnok < nokk:
                maxnok = nokk
                delit = []
                delit.append(i)
                delit.append(j)
                delit.append(f)
print(maxnok)",O(1)
"import os
import sys
from io import BytesIO, IOBase

mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]

    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]

    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]

    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]

    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z

n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))

col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)

    for item in ans:
        print(*item)

def nouse0():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

def nouse3():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

if __name__ == '__main__':
    main()",O(n ^ 3)
"
import collections


class Solution(object):
    def anagramMappings(self, A, B):
        lookup = collections.defaultdict(collections.deque)
        for i, n in enumerate(B):
            lookup[n].append(i)
        result = []
        for n in A:
            result.append(lookup[n].popleft())
        return result

",O(n)
"import collections



class Solution(object):
    def finalString(self, s):
        dq = collections.deque()
        parity = 0
        for x in s:
            if x == 'i':
                parity ^= 1
            else:
                dq.appendleft(x) if parity else dq.append(x)
        if parity:
            dq.reverse()
        return """".join(dq)",O(n)
"n = int(input())
b = list(map(int, input().split()))
ff = []
ss = []
for i in  b[::-1]:
    q = i
    f = q // 2
    if q % 2:
        s = f + 1
    else:
        s = f
    if len(ff) == 0:
        ff = [f]
        ss = [s]
    else:
        if f > ff[-1] or s < ss[-1]:
            d = max(f - ff[-1], ss[-1] - s)
            f -= d
            s += d
        ff.append(f)
        ss.append(s)
print(*(ff[::-1] + ss))",O(n)
"n=int(input())
l=list(map(int,input().split()))
m=l[:]
m.sort()
f=1
c=0
for i in range(n):
    if(l[i]!=m[i]):
        c+=1
    if(c>2):
        f=0
        break
if(f==0):
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"l,r=map(int,input().split())
s=bin(l)[2:]
t=bin(r)[2:]
z=max(len(s),len(t))
s='0'*(z-len(s))+s
t='0'*(z-len(t))+t
i=0
while i<z and s[i]==t[i]:
    i=i+1
print(pow(2,z-i)-1)",O(logn)
"k,n,s,p = map(int,input().split())
print(int((int((n+s-1)/s)*k+p-1)/p))",O(1)
"k = int(input())
x = [0,9]
i = 2
y = 90
while x[-1] < 10**12:
    x.append(x[-1]+y*i)
    y *= 10
    i += 1
if k in x:
    print(9)
else:
    for t in range(len(x)):
        if k < x[t]:
            break
    e = k-x[t-1]
    if t == 1:q=str(e)
    else:q =str(10**(t-1)+e//t-1)
    if e%t == 0:
        print(q[-1])
    else:
        q = str(int(q)+1)
        print(q[e%t-1])
",O(logn)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCompleteTree(self, root):
        end = False
        current = [root]
        while current:
            next_level = []
            for node in current:
                if not node:
                    end = True
                    continue
                if end:
                    return False
                next_level.append(node.left)
                next_level.append(node.right)
            current = next_level
        return  True


",O(n)
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumSumSubarray(self, nums, l, r):
        INF = float(""inf"")
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = INF
        sl = SortedList()
        for i in range(len(nums)):
            if i-l+1 >= 0:
                sl.add(prefix[i-l+1])
            if i-r >= 0:
                sl.remove(prefix[i-r])
            idx = sl.bisect_left(prefix[i+1])-1
            if idx >= 0:
                result = min(result, prefix[i+1]-sl[idx])
        return result if result != INF else -1",O(nlogn)
"import sys
import math
input = sys.stdin.readline
for _ in range(1):
    n,pos,l,r = map(int,input().split())
    if l == 1 and r == n:
        print(0)
        continue

    if l != 1 and r != n:
        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)

    else:
        if l == 1:
            ans = abs(pos-r)+1

        else:
            ans = abs(pos-l)+1

    print(ans)",O(1)
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]

def f(i, j):
	if d[i][j] != -1:
		return d[i][j]
	d[i][j] = 0
	for m in range(i, j):
		l = f(i, m)
		if f(m+1, j) == l and l:
			d[i][j] = l+1
			break
	return d[i][j]

a = [_ for _ in range(1, n+1)]
for e in range(1, n):
	for s in range(e+1):
		if f(s, e):
			a[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))
print(a[-1])",O(n ^ 3)
"import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):
        def dfs(labels, adj, node, parent, result):
            count = [0]*26
            for child in adj[node]:
                if child == parent:
                    continue
                new_count = dfs(labels, adj, child, node, result)
                for k in range(len(new_count)):
                    count[k] += new_count[k]
            count[ord(labels[node]) - ord('a')] += 1
            result[node] = count[ord(labels[node]) - ord('a')]
            return count
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        dfs(labels, adj, 0, -1, result)
        return result",O(n)
"class Solution2(object):
    def longestPrefix(self, s):
        M = 10**9+7
        D = 26
        def check(l, s):
            for i in range(l):
                if s[i] != s[len(s)-l+i]:
                    return False
            return True
    
        result, prefix, suffix, power = 0, 0, 0, 1
        for i in range(len(s)-1):
            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M
            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M
            power = (power*D)%M
            if prefix == suffix:
                result = i+1
        return s[:result]",O(n)
"class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))",O(n)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reverseKGroup(self, head, k):
        dummy = ListNode(-1)
        dummy.next = head

        cur, cur_dummy = head, dummy
        length = 0

        while cur:
            next_cur = cur.__next__
            length = (length + 1) % k

            if length == 0:
                next_dummy = cur_dummy.__next__
                self.reverse(cur_dummy, cur.__next__)
                cur_dummy = next_dummy

            cur = next_cur

        return dummy.__next__

    def reverse(self, begin, end):
            first = begin.__next__
            cur = first.__next__

            while cur != end:
                first.next = cur.__next__
                cur.next = begin.__next__
                begin.next = cur
                cur = first.__next__",O(n)
"x = int(input())
print(0,0,x)",O(1)
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = []

        for i in range(n):
            count = 1
            j = i + 1
            while j < n:
                if temperatures[j] > temperatures[i]:
                    break
                j += 1
                count += 1
            count = 0 if j == n else count
            res.append(count)
        return res
",O(n ^ 2)
"import collections
import itertools



class Solution(object):
    def mostPopularCreator(self, creators, ids, views):
        cnt = collections.Counter()
        lookup = collections.defaultdict(lambda: (float(""inf""), float(""inf"")))
        for c, i, v in zip(creators, ids, views):
            cnt[c] += v
            lookup[c] = min(lookup[c], (-v, i))
        mx = max(cnt.values())
        return [[k, lookup[k][1]] for k, v in cnt.items() if v == mx]",O(n)
"n = int(input())
d={}
for _ in range(n):
    a,b = map(int,input().split())
    d[a] = b

s=0
m = int(input())
for _ in range(m):
    x,y = map(int,input().split())

    if x in d:
        d[x] = max(d[x],y)

    else:
        d[x] = y

for i in d:

    s+=d[i]
print(s)
",O(nlogn)
"n=int(input())
a=list(map(int,input().split()))
grip=[[-1]*(n-i) for i in range(n)]
grip[0]=a.copy()
for level in range(1,n):
    for left in range(n-level):
        for split in range(level):
            pl=grip[level-split-1][left]
            pr=grip[split][left+level-split]
            if pl==pr!=-1:
                grip[level][left]=pl+1
pref=[0]*(n+1)
for p in range(1,n+1):
    x=n
    for j in range(p):
        l=pref[j]
        r=grip[p-j-1][j]
        if r==-1:
            r=p-j
        else:
            r=1
        x=min(x,l+r)
    pref[p]=x
print(pref[-1])
",O(n ^ 3)
"class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])",O(n)
"class Solution(object):
    def isGood(self, nums):
        cnt = [0]*len(nums)
        for x in nums:
            if x < len(cnt):
                cnt[x] += 1
            else:
                return False
        return all(cnt[x] == 1 for x in range(1, len(nums)-1))",O(n)
"import itertools
import string



class Solution2(object):
    def greatestLetter(self, s):
        lookup = set(s)
        return next((C for c, C in zip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), """")",O(n)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        res = []

        def dfs(node):
            if not node:
                res.append(""N"")
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        self.i = 0

        def dfs():
            if vals[self.i] == ""N"":
                self.i += 1
                return None
            node = TreeNode(int(vals[self.i]))
            self.i += 1
            node.left = dfs()
            node.right = dfs()
            return node

        return dfs()
",O(n)
"import math

inp = input().split(' ')
m = int(inp[0])
n = int(inp[1])

result = []

for column in range(1, math.ceil(m/2) + 1):

    rowRange = range(1, n + 1)
    if column == math.ceil(m / 2) and m % 2 == 1:
        rowRange = range(1, math.ceil(n/2) + 1)

    for row in rowRange:
        result.append(str(column) + ' ' + str(row))
        if row == math.ceil(n/2) and n % 2 == 1 and column == math.ceil(m / 2) and m % 2 == 1:
            continue
        result.append(str(m + 1 - column) + ' ' + str(n + 1 - row))

print('\n'.join(result))
",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"class Solution2(object):
    def trap(self, A):
        result = 0
        top = 0
        for i in range(len(A)):
            if A[top] < A[i]:
                top = i

        second_top = 0
        for i in range(top):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        second_top = len(A) - 1
        for i in reversed(range(top, len(A))):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        return result",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head",O(n)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
res = 0
same = 0
p = 1
for h in a:
	if p <= h:
		p += 1
	else:
		same += 1
res = a[-1] + same
print(sum(a) - res)",O(nlogn)
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)]
for l in range(1, n):
	for s in range(n-l):
		e = s + l
		for m in range(s, e):
			if d[s][m] == d[m+1][e] and d[s][m] != -1:
				d[s][e] = d[s][m] + 1
a = [1]
for e in range(1, n):
	t = 4096
	for s in range(e+1):
		if d[s][e] != -1:
			t = min(t, ((a[s-1]+1) if s > 0 else a[s]))
	a.append(t)
print(a[-1])
",O(n ^ 3)
"import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):

    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n ^ 3)
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):

    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
",np
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

k = inpl(); k.sort()
if k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:
    print('YES')
else:
    print('NO')",O(1)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if k == 0:
        if n == 0 and m == 0:
            print(0)
        else:
            print(-1)
    elif k == 1:
        if max(abs(n), abs(m)) != 1:
            print(-1)
        elif abs(n) == abs(m) == 1:
            print(1)
        else:
            print(0)
    else:
        if max(abs(n), abs(m)) > k:
            print(-1)
        elif abs(n) == abs(m):
            if (k - abs(n)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:
            if (k - max(abs(n), abs(m))) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",O(1)
"class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        return 100-(purchaseAmount+5)//10*10",O(1)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = [(p, q)]

        while stack:
            node1, node2 = stack.pop()

            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False

            stack.append((node1.right, node2.right))
            stack.append((node1.left, node2.left))

        return True
",O(n)
"class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val, self.minStack[-1] if self.minStack else val)
        self.minStack.append(val)

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
",O(1)
"n, k = map(int , input().split())
s = k // n
if k % n != 0:
    s += 1
print(s)
",O(1)
"class Solution(object):
    def addBinary(self, a, b):
        result, carry, val = """", 0, 0
        for i in range(max(len(a), len(b))):
            val = carry
            if i < len(a):
                val += int(a[-(i + 1)])
            if i < len(b):
                val += int(b[-(i + 1)])
            carry, val = divmod(val, 2)
            result += str(val)
        if carry:
            result += str(carry)
        return result[::-1]",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, k = map(int, stdin.readline().split())
stdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))",O(1)
"class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > k:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"
import threading
import collections


class Solution(object):
    def __init__(self, capacity):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__cap = capacity

    def enqueue(self, element):
        with self.__cv:
            while len(self.__q) == self.__cap:
                self.__cv.wait()
            self.__q.append(element)
            self.__cv.notifyAll()

    def dequeue(self):
        with self.__cv:
            while not self.__q:
                self.__cv.wait()
            self.__cv.notifyAll()
            return self.__q.popleft()

    def size(self):
        with self.__cv:
            return len(self.__q)
",O(1)
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )

def testcase():
    n = int(input())
    cnt = dict()
    for i in range(n):
        l,r = get_intmap()
        cnt[l] = cnt.get(l,0) + 1
        cnt[r+1] = cnt.get(r+1,0) - 1
    ans = [0] * (n + 1)
    sk = sorted(cnt.keys())

    cnt_i = 0
    for ind, i in enumerate(sk[:-1]):
        cnt_i += cnt[i]
        ans[cnt_i] += sk[ind + 1] - i
    print(' '.join([str(i) for i in ans[1:]]))

testcase();quit()
for t in range(int(input())):
    testcase()
",O(nlogn)
"def readline(): return tuple(map(int, input().split()))
def readlines(count): return (readline() for __ in range(count))

def main():
    n, = readline()
    segments = sorted(readline() + (idx + 1,) for idx in range(n))

    prev = (-1, -1, -1)
    for segment in segments:
        assert prev[0] <= segment[0]
        if prev[0] == segment[0]:
            assert prev[1] <= segment[1]
            print(prev[2], segment[2])
            break
        elif prev[1] >= segment[1]:
            print(segment[2],  prev[2])
            break
        prev = segment
    else:
        print(-1, -1)

main()
",O(nlogn)
"n = int(input())
s = input()
t = input()
p = [-1, -1]
a = [[-1] * 26 for i in range(26)]
k = 0
for i in range(n):
    if t[i] != s[i]:
        k += 1
for i in range(n):
    if t[i] != s[i]:
        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:
            print(k - 2)
            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)
            exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
for i in range(n):
    if t[i] != s[i]:
        for j in range(26):
            if a[j][ord(s[i]) - 97] != -1:
                print(k - 1)
                print(a[j][ord(s[i]) - 97] + 1, i + 1)
                exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
print(k)
print(-1, -1)
",O(n)
"import math

def c(k, n):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))

def main():
    sent = input()
    received = input()
    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))
    unrecognized = received.count('?')
    if difference > unrecognized:
        print(0)
        return

    k = (unrecognized - difference) // 2
    answer = c(k, unrecognized) * 0.5**unrecognized
    print(answer)

if __name__ == '__main__':
    main()
",np
"from collections import defaultdict as dd, deque
n = int(input())
A = [int(x) for x in input().split()]
n = len(A)

C = dd(int)
for a in A:
    C[a] += 1

thedup = None
ndup = 0
screwed = False
for c in C:
    if C[c] > 2:
        screwed = True
    elif C[c] == 2:
        if c == 0:
            screwed = True
        thedup = c
        ndup += 1

import sys
if screwed or ndup > 1:
    print('cslnb')
else:
    if ndup == 1:
        if C[thedup-1] != 0:
            print('cslnb')
            sys.exit()

    target = sum(range(n))
    cur = sum(A)
    togo = cur - target

    if togo%2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])

print(ans)
",O(n ^ 3)
"import collections


class Solution(object):
    def shortestSubarray(self, A, K):
        accumulated_sum = [0]*(len(A)+1)
        for i in range(len(A)):
            accumulated_sum[i+1] = accumulated_sum[i]+A[i]

        result = float(""inf"")
        mono_increasing_q = collections.deque()
        for i, curr in enumerate(accumulated_sum):
            while mono_increasing_q and curr <= \
                    accumulated_sum[mono_increasing_q[-1]]:
                mono_increasing_q.pop()
            while mono_increasing_q and \
                    curr-accumulated_sum[mono_increasing_q[0]] >= K:
                result = min(result, i-mono_increasing_q.popleft())
            mono_increasing_q.append(i)
        return result if result != float(""inf"") else -1",O(n)
"def solve(n,k):
    print(1*k,end = ' ')
    if n==2:
        print(2*k,end = ' ')
    if n == 3:
        print(k,3*k,end = ' ')
    else:
        temp = n//2
        if(n%2 == 0): temp -= 1
        print((str(k)+' ')*temp,end='')
        if(n>3):
            solve(n//2,k*2)

n = int(input())
solve(n,1)",O(n)
"class Solution(object):
    def average(self, salary):
        total, mi, ma = 0, float(""inf""), float(""-inf"")
        for s in salary:
            total += s
            mi, ma = min(mi, s), max(ma, s)
        return 1.0*(total-mi-ma)/(len(salary)-2)",O(n)
"class Solution(object):
    def numberOfCombinations(self, num):
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in range(len(num)+1)] 
            for i in reversed(range(len(lcp)-1)):
                for j in reversed(range(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in range(len(num))] 
        dp[0][0] = int(num[0] != '0')
        for i in range(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in range(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu 
                if i-l < 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)",O(n ^ 2)
"class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result",O(n)
"n,pos,l,r=map(int,input().split())
if l==1 and r==n:
    print(0)
elif l==1:
    print(abs(pos-r)+1)
elif r==n:
    print(abs(pos-l)+1)
else:
    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)",O(1)
"n=int(input())
li=list(map(int,input().split("" "")))
dp1=[]
for i in range(n):
  lis=[-1]*n
  dp1.append(lis)
dp2=[0]*n
for i in range(n):
  dp1[i][i]=li[i]

for i in range(n):
  dp2[i]=i+1
size=2

while size<=n:
  i=0
  while i<n-size+1:
    j=i+size-1
    k=i
    while k<j:
      if dp1[i][k]!=-1:
        if dp1[i][k]==dp1[k+1][j]:
          dp1[i][j]=dp1[i][k]+1
      k+=1
    i+=1
  size+=1

i=0
while i<n:
  k=0
  while k<=i:
    if dp1[k][i]!=-1:
      if k==0:
        dp2[i]=1
      else:
        dp2[i]=min(dp2[i],dp2[k-1]+1)
    k+=1
  i+=1

print(dp2[n-1])
",O(n ^ 3)
"from itertools import combinations

[n,l,r,x] = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
c.sort()
k = 0

from itertools import combinations

for i in range(n) :
	for j in range(i+1,n) :
		if ( c[j] - c[i] ) >= x :
			if sum(c[i:j+1]) < l :
				continue
			elif  (c[i] + c[j]) > r :
				continue
			else :
				if (c[i] + c[j]) >= l and (c[i] + c[j]) <= r :
					k += 1
				for p in range(1,j-i) :
					for m in combinations(c[i+1:j],p) :
						if (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r :
							k+=1

print(k)
",np
"a=int(input())
l=[]
total=0
for i in range(4):
    line=''

    for x in [0]*a:
        line+=input()
    l.append(line)
    input() if i!=3 else 0
l=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1]
for z,v in enumerate(l):
    if z<2:
        for i in range(a**2):
            total += v[i]!='0' if i%2 else v[i]!='1'
    else:
        for i in range(a**2):
            total += v[i]!='1' if i%2 else v[i]!='0'
print(total)",O(n ^ 2)
"import math

n, r = map(int, input().split())

a = math.pi/n
sin = math.sin(a)
R = r*sin/(1-sin)

print(R)",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result",O(n)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(1)
"n = int(input())

if n<6:
	print(-1)
else:
	print(""1 2\n1 3\n1 4"")
	for i in range(5,n+1):
		print('2 '+str(i))
for i in range(2, n+1):
	print('1 '+str(i))",O(n)
"import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        out.write(str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+""\n"")
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")",O(nlogn)
"import sys
import math
from collections import defaultdict
n,m=map(int,sys.stdin.readline().split())

up,down=1,n
count=0
while up<=down:
    left,right=1,m

    while left<=m and count<n*m:

        if count<n*m:
            sys.stdout.write((str(up)+"" ""+str(left)+""\n""))
        count+=1
        left+=1

        if count<n*m:
            sys.stdout.write((str(down)+"" ""+str(right)+""\n""))
        count+=1

        right-=1
    up+=1
    down-=1
",O(n ^ 2)
"import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n
while left < right:
    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]
    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1;L = 0
        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]
    dp = [n + 1] * (1 << k);dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def main():
	n, m = mints()
	res = []
	a = [None]*n
	l = [None]*n
	r = [None]*n
	s = [0]*n
	for i in range(n):
		a[i] = list(minp())
		l[i] = [i for i in range(m)]
		r[i] = [i for i in range(m)]
		s[i] = [0]*m
	for i in range(n):
		j = 0
		b = a[i]
		ll = l[i]
		rr = r[i]
		while j < m:
			if b[j] == '*':
				jj = j+1
				while jj < m and b[jj] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					ll[k] = j
					rr[k] = jj
				j = jj + 1
			else:
				j += 1
	for i in range(m):
		j = 0
		while j < n:
			if a[j][i] == '*':
				jj = j+1
				while jj < n and a[jj][i] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					x = min(i-l[k][i],r[k][i]-i,k-j,jj-k)
					s[k][i] = x
					if x > 0:
						res.append((k+1,i+1,x))
				j = jj + 1
			else:
				j += 1
	for i in range(n):
		j = 0
		ss = s[i]
		rr = r[i]
		c = -1
		while j < m:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			else:
				rr[j] = '.'
			j += 1
			c -= 1
		j = m-1
		c = -1
		while j >=0:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			c -= 1
			j -= 1
	for i in range(m):
		j = 0
		c = -1
		while j < n:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			j += 1
			c -= 1
		j = n-1
		c = -1
		while j >=0:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			if r[j][i] != a[j][i]:
				print(-1)
				exit(0)
			c -= 1
			j -= 1
	print(len(res))
	for i in res:
		print(*i)
main()",O(n ^ 2)
"class Solution(object):
    def generate(self, numRows):
        result = []
        for i in range(numRows):
            result.append([])
            for j in range(i + 1):
                if j in (0, i):
                    result[i].append(1)
                else:
                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])
        return result

    def generate2(self, numRows):
        if not numRows: return []
        res = [[1]]
        for i in range(1, numRows):
            res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
        return res[:numRows]

    def generate3(self, numRows):
        if numRows == 0: return []
        if numRows == 1: return [[1]]
        res = [[1], [1, 1]]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while len(res) < numRows:
            res.extend([add(res[-1])])
        return res",O(n ^ 2)
"import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:[*map(int,Z().split())]
n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]
if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit()
d=[0]*n*m
for _ in range(k//2):
    nd=[0]*n*m
    for x in range(n):
        for y in range(m):
            v=x*m+y;w=[]
            if x:w.append(d[v-m]+V[x-1][y])
            if y:w.append(d[v-1]+H[x][y-1])
            if x<n-1:w.append(d[v+m]+V[x][y])
            if y<m-1:w.append(d[v+1]+H[x][y])
            nd[v]=min(w)
    d=nd
print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",O(n ^ 3)
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",O(nlogn)
"n=int(input())
a=[]
for i in range(n+1):
    a.append(((n+1)-i)*i)
print(max(a))",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import sys, math
import io, os

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.buffer.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')

mod = int(1e9)+7

def cal(x):
    l1=set()
    d=dd(int)
    a=[]
    for i in range(n):
        k=0
        for j in range(m):
            if A[i][j]>=x:
                k+=1<<j
        l1.add(k)
        d[k]=i+1
    l1=list(l1)
    s=(1<<m)-1
    for i in l1:
        for j in l1:
            if i|j == s:
                a=[d[i],d[j]]
    return a

n,m=mdata()
A=[mdata() for i in range(n)]
l,r=0,10**9
while l<=r:
    mid=(l+r)//2
    if cal(mid):
        l=mid+1
    else:
        r=mid-1
a=cal(mid)
if a:
    outl(a)
else:
    outl(cal(mid-1))
",np
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n*m):
    dp.set((i, 0), 0)
  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))
      dp.set((i, t), ans)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp.get((node, k/2)) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n = int(input())
if n == 1:
    print(1)
else:
    adj = [[] for i in range(n+10)]
    s = input().split()
    for i in range(2,n+1):
        pi = int(s[i-2])
        adj[i].append(pi)
        adj[pi].append(i)

    num = 1
    curr = [1]
    nextcurr = []
    disco = [1]
    visited = {1:True}
    while num < n:
        for v in curr:
            for w in adj[v]:
                if w not in visited:
                    nextcurr.append(w)
                    visited[w] = True
                    disco.append(w)
                    num += 1
        curr = nextcurr
        nextcurr = []

    nl = {}
    nlvals = {}
    for v in disco[::-1]:
        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)
        nlvals[nl[v]] = nlvals.get(nl[v],0)+1
    colors = {}
    leaves = nlvals[1]
    colors[1] = leaves
    for c in range(2, leaves+1):
        colors[c] = colors[c-1] + nlvals.get(c,0)

    ans = """"
    j = 1
    for i in range(1, n+1):
        while colors[j] < i:
            j += 1
        ans += str(j) + ' '
    print(ans.strip())
",O(n)
"class Solution(object):
    def plusOne(self, digits):
        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        digits[0] = 1
        digits.append(0)
        return digits",O(n)
"s, l= list(map(int,input().split()))
sig = []
utp = []
if s == 0 or l ==0:
    print('NO')
    quit()
for i in range(s):
    sig.append(list(map(int,input())))
for i in range(0,l):
    out = 0
    for x in range(0,s):
        out+=sig[x][i]
    utp.append(out)
sig = sorted(sig,key = sum)
for i in range(0,s):
    res1=0
    for x in range(0,l):
        if utp[x]-sig[i][x] <=0:
            break
        else:
            res1+=1
    if res1 == l:
        print('YES')
        quit()

print('NO')
",O(n ^ 2)
"import collections


class Solution(object):
    def countPoints(self, rings):
        bits = {'R':0b001, 'G':0b010, 'B':0b100}
        rods = collections.defaultdict(int)
        for i in range(0, len(rings), 2):
            rods[int(rings[i+1])] |= bits[rings[i]]
        return sum(x == 0b111 for x in rods.values())",O(n)
"n=int(input())
ar=list(map(int,input().split()))
d={};ans=0
for i in ar:d[i]=d.get(i,0)+1
for i in ar:
  flag=False
  for j in range(31):
    k=2**j;
    if k>=i:
     k1=k-i
     if i!=k1 and d.get(k1,0)>0:flag=True;break
     if i==k1 and d.get(i,0)>1:flag=True;break
  if not flag:ans+=1

print(ans)
",O(nlogn)
"import collections
import string


class Solution(object):
    def longestWord(self, words):
        def iter_dfs(words, node):
            result = -1
            stk = [node]
            while stk:
                node = stk.pop()
                if result == -1 or len(words[node[""_end""]]) > len(words[result]):
                    result = node[""_end""]
                for c in reversed(string.ascii_lowercase):
                    if c not in node or ""_end"" not in node[c]:
                        continue
                    stk.append(node[c])
            return result       
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = iter_dfs(words, trie)
        return words[result] if result != -1 else """"",O(n)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
s = []
for q in range(n-1):
    s.append([a[q+1]-a[q], q])
s.sort(reverse=True)
d = {q[1] for q in s[:k-1]}
ans = 0
q1 = a[0]
for q in range(n-1):
    if q in d:
        ans += a[q]-q1
        q1 = a[q+1]
print(ans+a[-1]-q1)
",O(nlogn)
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",O(n)
"try:
    odd, even, oddIndex, evenIndex = 0, 0, 0, 0
    n = int(input())
    s = list(map(int, input().split()))
    counter = 0
    for i in s:
        if i % 2 == 0:
            even += 1
            evenIndex = counter
        else:
            odd += 1
            oddIndex = counter
        counter += 1
    ans = evenIndex + 1 if even == 1 else oddIndex + 1
    print(ans)
except EOFError as e:
    pass",O(n)
"def getIntList():
    return list(map(int, input().split()));
nbColumn, h=getIntList();
if (nbColumn-2)*2<h:
    print('NO')
else:
    print('YES')
    if h%2==0:
        print('.'*nbColumn);
        print('.'+'
        print('.'+'
        print('.'*nbColumn);
    else:
        print('.'*nbColumn);
        hFirst=min(h, nbColumn-2);
        countPoint=(nbColumn-hFirst)//2;
        print('.'*countPoint+'
        hSecond=(h-hFirst)//2;
        countPoint=nbColumn-2*hSecond-2;
        print('.'+'
        print('.'*nbColumn);",O(n)
"

class Solution(object):
    def buyChoco(self, prices, money):
        i = min(range(len(prices)), key=lambda x: prices[x])
        j = min((j for j in range(len(prices)) if j != i), key=lambda x: prices[x])
        return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money
",O(n)
"import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split())
def listinput(): return list(map(int, input().split()))
n,k=minput()
for i in range(1,n+1):
	if (i*(i+1))/2 -n+i==k:
		print(n-i)
		break",O(logn)
"from sys import stdin,stdout
for _ in range(1):

    moves,left=list(map(int,stdin.readline().split()))

    l=1;r=10**9+1
    while l<=r:
        mid=(l+r)>>1
        fx=(mid*(mid+1))//2-left+mid

        if fx<=moves:l=mid+1
        else:r=mid-1
    print(moves-r)",O(logn)
"from sys import stdin, exit
from typing import List, Tuple, Dict
from itertools import product

def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):
    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])

def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):
    shorthest_path = float('inf')
    for outbreak in outbreaks:
        if shorthest_path < min_dst:
            break
        shorthest_path = min(shorthest_path, distance(tree, outbreak))
    return shorthest_path

input_f = open('input.txt', 'r')
output_f = open('output.txt', 'w')

N, M = [int(v) for v in input_f.readline().rstrip().split()]
input_f.readline()
outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]
outbreaks = []
input_f.close()

for i in range(0, len(outbreaks_line) - 1, 2):
    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))

last_tree = (1, 1)
best_dst = 0
for x, y in product(range(1, N + 1), range(1, M + 1)):
    path_len = shorthest_path((x, y), outbreaks, best_dst)
    if path_len > best_dst:
        last_tree = (x, y)
        best_dst = path_len

output_f.write(' '.join(map(str, last_tree)))

output_f.close()
",O(n ^ 3)
"class Solution2(object):
    def countHighestScoreNodes(self, parents):
        def dfs(adj, i, result):
            cnts = [dfs(adj, child, result) for child in adj[i]]
            total = sum(cnts)+1
            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)
            if score > result[0]:
                result[:] = [score, 1]
            elif score == result[0]:
                result[1] += 1
            return total

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        result = [0]*2
        dfs(adj, 0, result)
        return result[1]",O(n)
"def binary(n,k,low,high):
    if low<=high:
        mid=(low+high)//2
        if (mid*(mid+1))//2-(n-mid)==k:
            return n-mid
        elif mid*(mid+1)//2-(n-mid)>k:
            return binary(n,k,low,mid-1)
        else:
            return binary(n,k,mid+1,high)

n,k=[int(x) for x in input().split()]
print(binary(n,k,1,n))",O(logn)
"class Solution:
    def reverseBits(self, n: int) -> int:
        res = n
        res = (res >> 16) | (res << 16) & 0xFFFFFFFF
        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)
        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)
        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)
        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)
        return res & 0xFFFFFFFF
",O(1)
"class Solution(object):
    def minimumSwap(self, s1, s2):
        x1, y1 = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2: 
            return -1
        return (x1//2 + y1//2) + (x1%2 + y1%2)",O(n)
"n, k = map(int, input().split())
l, r = -1, k+1
while l+1 < r:
	mid = l + r >> 1
	val = (k - mid + 1 + k) * mid // 2 - (mid - 1)
	if val < n:
		l = mid
	else:
		r = mid
print(-1 if r == k+1 else r)
",O(logn)
"t = input()

n = len(t)

maxi = 0

for i in range(n):
    s = t[i]
    if t.count(s) > 1:
        maxi = max(maxi, 1)
    nr = 1
    for j in range(i + 1, n):
        s += t[j]
        nr += 1
        g = 0
        for h in range(n - nr + 1):
            if s == t[h:h + nr]:
                g += 1
        if g > 1:
            maxi = max(nr,maxi)

print(maxi)",O(n ^ 3)
"class Solution:
    def countSubstrings(self, s: str) -> int:
        n, res = len(s), 0
        dp = [[False] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):
                    dp[i][j] = True
                    res += 1

        return res
",O(n ^ 2)
"def size_of_group(i):
    return long(9 * 10**(i - 1)) * i

def find_group(k, i = 1):
    diff = long(k - (size_of_group(i)))
    if diff <= 0:
        return k, i
    return find_group(diff, i + 1)

def get_number(k, g):
    return str(long(10**(g - 1)) + k / g)[k % g]

def get_sequence_number(num):

    k_prim, g_prim = find_group(num)
    return get_number(k_prim - 1, g_prim)

if __name__ == ""__main__"":
    print(get_sequence_number(long(input())))",O(logn)
"class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)",O(n)
"n,m=[int(x) for x in input().split()]
v=[]
h=[]
for i in range(n):
    x=int(input())
    v.append(x)
for i in range(m):
    x,y,z=[int(x) for x in input().split()]
    if x==1:
        h.append(y)
h.sort()
v.sort()
m=len(h)
n=len(v)
if n==0 or v[n-1]!=1000000000:
    v.append(1000000000)
    n+=1
mina=9999999999999
j=0
for i in range(n):
    while(j<m and h[j]<v[i]):
        j+=1

    mina=min(mina,i+m-j)
print(mina)",O(nlogn)
"class Solution2(object):
    def largestMultipleOfThree(self, digits):
        def candidates_gen(r):
            if r == 0:
                return
            for i in range(10):
                yield [i]
            for i in range(10):
                for j in range(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"import collections



class Solution(object):
    def maxSum(self, nums, m, k):
        lookup = collections.Counter()
        result = curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            lookup[nums[right]] += 1
            if right-left+1 == k+1:
                lookup[nums[left]] -= 1
                if lookup[nums[left]] == 0:
                    del lookup[nums[left]]
                curr -= nums[left]
                left += 1
            if right-left+1 == k and len(lookup) >= m:
                result = max(result, curr)
        return result",O(n)
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",O(n)
"class Solution2(object):
    def maxLevelSum(self, root):
        result, level, max_total = 0, 1, float(""-inf"")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total > max_total:
                result, max_total = level, total
            level += 1
        return result",O(n)
"class Solution3(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums): 
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums: 
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True) 
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"def if_Spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1, n + 1):
        if m[i] == 0:
            d[l[i]] += 1
    for i in range(1, n + 1):
        if m[i] > 0 and d[i] < 3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_Spruce(n,l,m))
",O(n)
"n,k=map(int,input().split())
ans=0
ans+=(2*n)//k + bool((2*n)%k!=0)
ans+=(5*n)//k + bool((5*n)%k!=0)
ans+=(8*n)//k + bool((8*n)%k!=0)
print(ans)",O(1)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]
        return []
",O(n ^ 2)
"a=int(input())
arr=list(map(int,input().split()))
d=dict()
summ=[0]
brr=arr
nd=dict()
mimpp=dict()
mimpn=dict()
for i in arr:
    summ.append(i+summ[len(summ)-1])
    if(i in d):
        d[i]=d[i]+1
    else:
        d[i]=1
for i in range(0,len(brr)):
    if(brr[i] in nd):
        nd[brr[i]]=nd[brr[i]]+1
    else:
        nd[brr[i]]=1
    mimpn[i]=0
    mimpp[i]=0
    if(brr[i]-1 in d):
        mimpn[i]=mimpn[i]+d[brr[i]-1]
    if(brr[i]+1 in d):
        mimpp[i]=mimpp[i]+d[brr[i]+1]
    if(brr[i]-1 in nd):
        mimpn[i]=mimpn[i]-nd[brr[i]-1]
    if(brr[i]+1 in nd):
        mimpp[i]=mimpp[i]-nd[brr[i]+1]

ans=0
ind=0
su=sum(arr)
for i in range(0,len(arr)):
    ans=ans+su-summ[ind]-(a-ind)*arr[i]
    ans=ans+mimpn[i]
    ans=ans-mimpp[i]
    ind=ind+1
print(ans)
",O(nlogn)
"d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
for _ in[0]*int(input()):d.pop(input())
print(len(d),*d.values(),sep='\n')",O(1)
"M = 998244353
n = int(input())
l = sorted(map(int, input().split()))[::-1]
out = [0] * n
big = 0
if l[0] >= 2 * l[1]:
    out[1] = 1
    big = 1
for i in range(2, n):
    new = [0] * n
    bigN = 0
    for j in range(i):
        if l[j] >= 2 * l[i]:
            big += out[j]
        else:
            new[j] += out[j] * (i - 1)
            new[j] %= M

    new[i] = big
    bigN = (i * big) % M

    out = new
    big = bigN
print((big + sum(out))%M)",O(n ^ 3)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}

i = int(input())
l = []
for x in range(i):
    d.pop(input())

print(len(d))
for i in d.values() : print(i)",O(1)
"class Solution(object):
    def flipAndInvertImage(self, A):
        for row in A:
            for i in range((len(row)+1) // 2):
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A",O(n ^ 2)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",O(n ^ 2)
"def solve(n, arr):
	s = sum(arr)
	if s == 0:
		return ""cslnb""

	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		return 'cslnb'

	for key in n_num.keys():
		if n_num[key] >= 3:
			return ""cslnb""

	ind_pairs = []
	for key in n_num.keys():
		if n_num[key] == 2:
			ind_pairs.append(key)

	if len(ind_pairs) >= 2:
		return ""cslnb""
	elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
		return ""cslnb""
	else:

		sum_targ = n*(n-1) // 2

		dif_sum = s - sum_targ

		if dif_sum % 2 == 0:
			return ""cslnb""
		else:
			return ""sjfnb""

n = int(input())

arr = list(map(int, input().split()))
print(solve(n, arr))
",O(n)
"d = {
    ""purple"": ""Power"",
    ""green"": ""Time"",
    ""blue"": ""Space"",
    ""orange"": ""Soul"",
    ""red"": ""Reality"",
    ""yellow"": ""Mind"",
}

all_colors = list(d.keys())

n = int(input())
colors = [input() for i in range(n)]

print(len(d) - len(colors))
for color in all_colors:
    if color not in colors:
        print(d[color])
",O(1)
"import collections



class Solution(object):
    def maximumTotalDamage(self, power):
        DIST = 2
        power.sort()
        dp = collections.deque()
        mx = 0
        for x in power:
            if dp and dp[-1][0] == x:
                dp[-1][1] += x
                continue
            while dp and dp[0][0]+DIST < x:
                mx = max(mx, dp.popleft()[1])
            dp.append([x, mx+x])
        return max(x for _, x in dp)",O(nlogn)
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1

ans=[]
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:

    print(ans[-1])
",O(n ^ 3)
"import sys
from operator import itemgetter
readline = sys.stdin.readline

def topological_sort(E, D):
    D = D[:]
    n = len(E)
    Q = [i for i in range(n) if D[i] == 0]
    L = []
    while Q:
        p = Q.pop()
        L.append(p)
        for vf in E[p]:
            D[vf] -= 1
            if not D[vf]:
                Q.append(vf)

    if len(L) != n:
        return False
    return L

N, M = map(int, readline().split())

Edge = [None]*M
for m in range(M):
    a, b, c = map(int, readline().split())
    a -= 1
    b -= 1
    Edge[m] = (c, m+1, a, b)

Edge.sort(key = itemgetter(0), reverse = True)

ok = 0
ng = M+1
while abs(ok-ng) > 1:
    med = (ok+ng)//2
    Edge2 = [[] for _ in range(N)]
    Dim2 = [0]*N
    for i in range(med):
        _, _, a, b = Edge[i]
        Edge2[a].append(b)
        Dim2[b] += 1
    if topological_sort(Edge2, Dim2):
        ok = med
    else:
        ng = med

Edge2 = [[] for _ in range(N)]
Dim = [0]*N
for i in range(ok):
    _, _, a, b = Edge[i]
    Edge2[a].append(b)
    Dim[b] += 1

L = topological_sort(Edge2, Dim)
Linv = [None]*N
for i in range(N):
    Linv[L[i]] = i

Ans = []
ans = 0
if ok < M:
    ans = Edge[ok][0]
    for i in range(ok, M):
        c, m, a, b = Edge[i]
        if Linv[a] > Linv[b]:
            Ans.append(m)
print(ans, len(Ans))
print(*Ans)",O(nlogn)
"def comp(a,b):
    x=len(a)
    s1=''
    s2=''
    for i in range(x):
        s1+=str(a[i])
        s2+=str(b[i])
    if s1>s2:
        return 1
    else:
        return 0

a=list(input(''))
b=list(input(''))
cnt=[0]*10
n=len(a)
m=len(b)
sol=''
for i in range(n):
    a[i]=int(a[i])
    cnt[a[i]]+=1

if n!=m:
    a.sort(reverse=True)
    for i in a:
        sol+=str(i)
    print(sol)
else:
    a.sort()

    for i in range(n):
        b[i]=int(b[i])
    for i in range(n-1):
        for j in range(i,n):
            if a[i]<a[j]:
                temp=a[i]
                a[i]=a[j]
                a[j]=temp
                if comp(a,b):
                    temp=a[i]
                    a[i]=a[j]
                    a[j]=temp

    for i in a:
        sol+=str(i)
    print(sol)",O(n ^ 3)
"import collections


class Solution(object):
    def checkEqualTree(self, root):
        def getSumHelper(node, lookup):
            if not node:
                return 0
            total = node.val + \
                    getSumHelper(node.left, lookup) + \
                    getSumHelper(node.right, lookup)
            lookup[total] += 1
            return total

        lookup = collections.defaultdict(int)
        total = getSumHelper(root, lookup)
        if total == 0:
            return lookup[total] > 1
        return total%2 == 0 and (total/2) in lookup",O(n)
"import sys
n,m=map(int,input().split())
for i in range(n//2):
    for j in range(m):
        sys.stdout.write('{} {}\n'.format(*[i+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n-i,m-j]))
if n%2:
    for j in range(m//2):
        sys.stdout.write('{} {}\n'.format(*[n//2+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m-j]))
    if m%2:
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m//2+1]))",O(n ^ 2)
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
mask = (1 << m) - 1

l = []
for i in range(n):
    l.append(list(map(int,input().split())))

lo = -1
hi = 10 ** 9 + 1
while hi - lo > 1:
    test = (hi + lo) // 2

    things = dict()
    for i in range(n):
        curr = 0
        for v in l[i]:
            curr *= 2
            if v >= test:
                curr += 1
        things[curr] = i

    works = False
    for v1 in things:
        for v2 in things:
            if v1 | v2 == mask:
                outi = things[v1]
                outj = things[v2]
                works = True
                break
        if works:
            break

    if works:
        lo = test
    else:
        hi = test

print(outi + 1, outj + 1)
",np
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input()

idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",O(nlogn)
"import collections


class Solution(object):
    def pathSum(self, nums):
        class Node(object):
            def __init__(self, num):
                self.level = num/100 - 1
                self.i = (num%100)/10 - 1
                self.val = num%10
                self.leaf = True

            def isParent(self, other):
                return self.level == other.level-1 and \
                       self.i == other.i/2

        if not nums:
            return 0
        result = 0
        q = collections.deque()
        dummy = Node(10)
        parent = dummy
        for num in nums:
            child = Node(num)
            while not parent.isParent(child):
                result += parent.val if parent.leaf else 0
                parent = q.popleft()
            parent.leaf = False
            child.val += parent.val
            q.append(child)
        while q:
            result += q.pop().val
        return result",O(n)
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"class Solution2(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            curr = 0
            for j in reversed(range(i+1)):
                curr += int(s[j])<<(i-j)
                if s[j] == '1' and max_pow_5%curr == 0:
                    dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1",O(n ^ 2)
"class Solution2(object):
    def minCost(self, costs):
        if not costs:
            return 0

        n = len(costs)
        for i in range(1, n):
            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

        return min(costs[n - 1])",O(n)
"def main():
    c,r,o,e=0,0,[0]*300000,[0]*300000
    for _ in range(int(input())):
        s=input()
        l,n=0,0
        for i in s:
            if i=='(':
                l+=1
            else:
                if l!=0:
                    l-=1
                else:
                    n+=1
        if l==0 and n==0:
            c+=1
        elif l!=0 and n!=0:
            pass
        elif l!=0:
            o[l]+=1
        else:
            e[n]+=1
    for i in range(300000):
        if e[i] and o[i]:
            r+=e[i]*o[i]
    print(pow(c,2)+r)
if __name__=='__main__':
    main()",O(n)
"class Solution(object):
    def findPairs(self, nums, k):
        if k < 0: return 0
        result, lookup = set(), set()
        for num in nums:
            if num-k in lookup:
                result.add(num-k)
            if num+k in lookup:
                result.add(num)
            lookup.add(num)
        return len(result)",O(n)
"class Solution(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            lookup = [False]*len(nums)
            result = len(nums)
            for i in range(len(nums)):
                if lookup[nums[i]]:
                    continue
                l = 0
                while not lookup[nums[i]]:
                    lookup[nums[i]] = True
                    l += 1
                    i = index(nums[i])
                result -= 1
                if l >= 2:
                    result += 2
            return result-2*int(nums[d*(len(nums)-1)] != 0)

        return min(min_moves(0), min_moves(1))",O(n)
"numeros = [int(i) for i in input().split(' ')]

l = bin(numeros[0])
r = bin(numeros[1])

p = -1

if (len(r) == len(l)):
    for i in range (len(l)):
        if (l[i] != r[i]):
            p = i
            break
    if(numeros[0] != numeros[1]):

        saida = 2**(len(r) - p) - 1
        print(saida)
    else:
        print(0)

else:
    if(numeros[0] != numeros[1]):
        saida = 2**(len(r) - 2) - 1

        print(saida)
    else:
        print(0)
",O(logn)
"import math

a=input()
b=input()
x1=a.count('+')
y1=a.count('-')
x2=b.count('+')
y2=b.count('-')
l=b.count('?')
if l==0 and(x1==x2 and y1==y2):
	print(float(1))
elif x1>(x2+l) or y1>(y2+l):
	print(float(0))
else:
	w=math.factorial(l)
	m=math.factorial(x1-x2)
	n=math.factorial(l-(x1-x2))
	print((w/(m*n)) /2**(x1+y1-x2-y2))
",np
"from sys import stdin
import time

r,g,b = map(int,stdin.readline().split())

red = list(map(int,stdin.readline().split()))
green = list(map(int,stdin.readline().split()))
blue = list(map(int,stdin.readline().split()))
red.sort()
green.sort()
blue.sort()

dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and j>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])

print(dp[-1][-1][-1])
",O(n ^ 3)
"import sys

n, m, k = map(int, input().split())

hor = [list(map(int, input().split())) for _ in range(n)]

ver = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2:
    for i in range(n):
        print(*([-1]*m))
    sys.exit()

k = k // 2
dp = [[[0]*m for _ in range(n)] for _ in range(k+1)]

for x in range(1, k+1):
    for y in range(n):
        for z in range(m):
            hold = float('inf')
            if y != 0:
                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )
            if y != n-1:
                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )
            if z != 0:
                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )
            if z != m-1:
                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )
            dp[x][y][z] = hold

for row in dp[k]:
    print(*map(lambda i: i*2, row))
",O(n ^ 3)
"def some_random_function():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    powe = [1]
    for _ in range(10**6):
        powe.append((powe[-1]*2)%mod)
    n = int(input())
    a = list(map(int,input().split()))
    ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0
    for i in range(1,n):
        if i == 1:
            dp = (dp+a[i])%mod
        else:
            dp = (dp*2+a[i]-dp1)%mod
        ans = (ans+powe[n-i-1]*dp)%mod
        dp1 = a[i]
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",O(n)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)
",O(1)
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",O(n ^ 2)
"class Solution(object):
    def removeDuplicates(self, s, k):
        stk = [['^', 0]]
        for c in s:
            if stk[-1][0] == c:
                stk[-1][1] += 1
                if stk[-1][1] == k:
                    stk.pop()
            else:
                stk.append([c, 1])
        return """".join(c*k for c, k in stk)",O(n)
"class Solution(object):
    def maxDistinctElements(self, nums, k):
        result = 0
        nums.sort()
        curr = float(""-inf"")
        for x in nums:
            if curr > x+k:
                continue
            curr = max(curr, x-k)+1
            result += 1
        return result",O(nlogn)
"import math

n_r = list(map(int, input().split()))

n = n_r[0]
radii = n_r[1]

x_list = list(map(int, input().split()))

temp_arr = []
for i in range(n):
    temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j]
                    for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii])
                    )

for i in temp_arr:
    print(i, end= "" "")
",O(n ^ 2)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",O(n ^ 2)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"def go():
    n = int(input())
    x, y = [int(i) for i in input().split(' ')]
    a = 1 + 1
    b = n + n
    c = x + y
    distance_w = c - a
    distance_b = b - c
    if distance_w == distance_b:
        return 'White'
    if distance_w < distance_b:
        return 'White'
    return 'Black'

print(go())
",O(1)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zb = getIntList()

za1 = [0]
za2 = [zb[0]]

for i in range(1, N//2):
    t1 = zb[i] - za1[-1]
    if t1 <= za2[-1]:
        za1.append(za1[-1])
        za2.append(t1)
        continue
    t2 = zb[i] - za2[-1]
    if t2 >= za1[-1]:
        za1.append(t2)
        za2.append(za2[-1])
        continue
    assert False

zr = za1 + za2[ : :-1]
zs = []
for x in zr:
    zs .append(str(x))

r = ' '.join(zs)

print(r)
",O(n)
"import sys,math
a,b=map(int,input().split())
l=list(map(int,input().split()))
t=[[-1,0] for i in range(100001)]
for i in range(a):
    if t[l[i]][0]!=-1:print(0);sys.exit()
    t[l[i]][0]=3
s=math.inf
for i in range(a):
    if t[l[i]&b][0]!=-1:

        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:
            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]

    else:t[l[i]&b]=[2,1]

for i in range(a):
    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])
if s==math.inf:
    print(-1)
else:
    print(s)
",O(n)
"n, s = map(int, input().split())
if s % n == 0:
    print(s // n)
else:
    print(s // n + 1)
",O(1)
"n=int(input())
c=0
for j in range(2,1+n//2):
	e=0
	i=n//j
	e+=(i*(i+1))//2
	e-=1
	if e>0:
		c+=e
print(c*4)",O(n)
"N = int(input())
s1 = [list(input()) for i in range(N)]
s2 = [list(input()) for i in range(N)]

def rotate(s):
    ret = [[None for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            ret[i][j] = s[j][N-1-i]
    return ret

def v_mirror(s):
    return list(reversed(s))

def h_mirror(s):
    return [list(reversed(row)) for row in s]

def solve():
    global s1
    for i in range(4):
        if s1 == s2: return True
        if v_mirror(s1) == s2: return True
        if h_mirror(s1) == s2: return True
        if v_mirror(h_mirror(s1)) == s2: return True
        s1 = rotate(s1)
    return False

print('Yes' if solve() else 'No')
",O(n ^ 2)
"class Solution(object):
    def findMinimumTime(self, strength, K):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:

            m = l + ((r - l) // 2)

            if nums[m] > target:
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                return m
        return -1
",O(logn)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        queue = deque([root])
        while queue:
            node = queue.popleft()
            node.left, node.right = node.right, node.left
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return root
",O(n)
"import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=2):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

s = input()
lens = len(s)
max_ = 0
for i in range(1, lens):
    d = {}
    for j in range(lens - i + 1):
        if s[j: j + i] in d:
            d[s[j: j + i]] += 1
        else:
            d[s[j: j + i]] = 1
    maxd = max(d.values())
    if max(d.values()) > 1:
        max_ = i
print(max_)
",O(n ^ 3)
"def really_big(x):
    sum_digit = 0
    digits = x
    while digits > 0:
        sum_digit += digits % 10
        digits = digits // 10

    if x - sum_digit >= s:
        return True
    return False

def solve():
    left = 1
    right = n
    ans = 0
    while left <= right:
        mid = (left + right) // 2
        if really_big(mid):
            right = mid - 1
            ans = n - mid + 1
        else:
            left = mid + 1
    return ans

n, s = map(int, input().split())
print(solve())
",O(logn)
"def reach_max(n, k):
    return n * k + 1 - n * (n + 1) // 2

n, k = map(int, input().split())

if n == 1:
    print(0)
    exit()

lo, hi = 1, k - 1

if n > reach_max(hi, k):
    print(-1)
    exit()

while lo < hi:
    mid = (lo + hi) // 2
    if reach_max(mid, k) < n:
        lo = mid + 1
    else:
        hi = mid

print(lo)
",O(logn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"def read():
    return int(input())

def readlist():
    return list(map(int, input().split()))

def readmap():
    return map(int, input().split())

N, A, B = readmap()

if N == 1:
    print(""YES"")
    print(0)

elif N == 2:
    if A == 1 and B == 2:
        print(""YES"")
        print(""01"")
        print(""10"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""00"")
        print(""00"")
    else:
        print(""NO"")

elif N == 3:
    if A == 1 and B == 2:
        print(""YES"")
        print(""011"")
        print(""100"")
        print(""100"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""001"")
        print(""000"")
        print(""100"")
    elif A == 1 and B == 3:
        print(""YES"")
        print(""011"")
        print(""101"")
        print(""110"")
    elif A == 3 and B == 1:
        print(""YES"")
        print(""000"")
        print(""000"")
        print(""000"")
    else:
        print(""NO"")

else:
    if A != 1 and B != 1:
        print(""NO"")
    else:
        print(""YES"")
        if B == 1 and A != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= A:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= A:
                        vec[0] = 1
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        elif A == 1 and B != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= B:
                            vec.append(0)
                        else:
                            vec.append(1)
                    vec[i] = 0
                    mat.append(vec)
                else:
                    vec = [1] * N
                    if i >= B:
                        vec[0] = 0
                    vec[i] = 0
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        else:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= 2:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= 2:
                        vec[0] = 1
                    mat.append(vec)

            mat[1][2] = 1
            mat[2][1] = 1
            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
",O(n ^ 2)
"class Solution(object):
    def countSteppingNumbers(self, low, high):
        MOD = 10**9+7
        def f(s):
            dp = [[0]*10 for _ in range(2)]
            for j in range(1, ord(s[0])-ord('0')+1):
                dp[0][j] = 1
            prefix = True
            for i in range(1, len(s)):
                for j in range(10):
                    dp[i%2][j] = int(j != 0)
                    if j-1 >= 0:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD
                    if j+1 < 10:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD
                if abs(ord(s[i])-ord(s[i-1])) != 1:
                    prefix = False
            return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2])

        return (f(high)-f(str(int(low)-1)))%MOD",O(n)
"n,r=list(map(int,input().split()))
x=list(map(int,input().split()))
y=[r]*n
for i in range(1,n):
    for j in range(i):
        d=abs(x[i]-x[j])
        if d<=2*r:
            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))
print(*y)",O(n ^ 2)
"l, r = map(int, input().split())
if r - l + 1 < 3:
    print(-1)
    exit()
if l % 2 == 0:
    print(l, l+1, l+2)
    exit()
if r - l + 1 > 3:
    print(l+1, l+2, l+3)
    exit()
print(-1)
",O(1)
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        second = slow.next
        prev = slow.next = None
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp

        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1
            first, second = tmp1, tmp2
",O(n)
"n = int(input())
x, y = 1, 9
n -= 1
while n > x * y:
    n -= x * y
    x += 1
    y *= 10
a = 10 ** (x - 1) + n // x
print(str(a)[n % x])",O(logn)
"class Solution(object):
    def minimumMoves(self, grid):
        level, q, lookup = 0, [(0, 0, False)], set()
        while q:
            next_q = []
            for r, c, is_vertical in q:
                if (r, c, is_vertical) in lookup:
                    continue
                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):
                    return level
                lookup.add((r, c, is_vertical))
                if not is_vertical:
                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:
                        next_q.append((r, c+1, is_vertical))
                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r+1, c, is_vertical))
                        next_q.append((r, c, not is_vertical))
                else:
                    if r+2 != len(grid) and grid[r+2][c] == 0:
                        next_q.append((r+1, c, is_vertical))
                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r, c+1, is_vertical))
                        next_q.append((r, c, not is_vertical))
            q = next_q
            level += 1
        return -1",O(n ^ 2)
"class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        q = deque([root])

        while q:
            rightSide = None
            qLen = len(q)

            for i in range(qLen):
                node = q.popleft()
                if node:
                    rightSide = node
                    q.append(node.left)
                    q.append(node.right)
            if rightSide:
                res.append(rightSide.val)
        return res
",O(n)
"n, k = map(int, input().split())
if n == k:
    print('1' * n)
elif k == 1:
    print('0' + '1' * (n - 1))
else:
    x = (n - k) // 2
    a = '0' * x + '1'
    print(a * (n // (x + 1)) + '0' * (n % (x + 1)))",O(1)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",O(n ^ 3)
"import sys

R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse = True)
g = sorted([int(x) for x in input().split()], reverse = True)
b = sorted([int(x) for x in input().split()], reverse = True)

ans = 0

dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if  j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])
            ans = max(ans, dp[i][j][k])
print(ans)",O(n ^ 3)
"import collections


class Solution2(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atMostK(word, k):
            cnt = collections.Counter()
            result = left = 0
            for right, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right+1
                    continue
                cnt[c] += 1
                while len(cnt) > k:
                    cnt[word[left]] -=1
                    if not cnt[word[left]]:
                        del cnt[word[left]]
                    left += 1
                result += right-left+1
            return result

        return atMostK(word, k) - atMostK(word, k-1)",O(n)
"from collections import namedtuple

Point = namedtuple(""Point"", ""x y"")
Square = namedtuple(""Square"", ""left right top bottom"")
Triangle = namedtuple(""Triangle"", ""left top"")

a = [int(v) for v in input().split()]
b = [int(v) for v in input().split()]

a = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)]
b = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)]

bc = Point(sum(p.x for p in b) // 4, sum(p.y for p in b) // 4)
bb = [None] * 4
for p in b:
    if p.x < bc.x:
        bb[0] = p
    elif p.y > bc.y:
        bb[1] = p
    elif p.x > bc.x:
        bb[2] = p
    elif p.y < bc.y:
        bb[3] = p
    else:
        assert False

def in_sqr(sqr, pt):
    return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top

def in_tri(tri, pt):
    return (
        tri.left.x <= pt.x <= tri.top.x and
        tri.left.y <= pt.y <= tri.top.y and
        pt.y - tri.left.y <= pt.x - tri.left.x
    )

def solve_sqr_tri(sqr, tri):
    return (
        in_sqr(sqr, tri.left) or
        in_sqr(sqr, tri.top) or
        in_sqr(sqr, Point(tri.top.x, tri.left.y)) or
        in_tri(tri, Point(sqr.left, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.bottom)) or
        in_tri(tri, Point(sqr.left, sqr.bottom))
    )

def rotate90(pt):
    return Point(-pt.y, pt.x)

def iterate_rot(pt, times):
    for _ in range(times):
        pt = rotate90(pt)
    return pt

def solve_sqr_sqr45(sqr_pts, sqr45):
    for i in range(4):
        tri_pts = sqr45[i], sqr45[(i + 1) % 4]
        left, top = [iterate_rot(pt, i) for pt in tri_pts]

        assert left.x < top.x
        assert left.y < top.y

        tri = Triangle(left=left, top=top)

        sqr = Square(
            left=min(p.x for p in sqr_pts),
            right=max(p.x for p in sqr_pts),
            top=max(p.y for p in sqr_pts),
            bottom=min(p.y for p in sqr_pts),
        )

        if solve_sqr_tri(sqr, tri):
            return True

        sqr_pts = [rotate90(pt) for pt in sqr_pts]

    return False

print([""NO"", ""YES""][solve_sqr_sqr45(a, bb)])
",O(1)
"
import pandas as pd



def Solution(players: pd.DataFrame) -> List[int]:
    return list(players.shape)
",O(1)
"cnt = [0]*2
class Solution2(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]  
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def popcount(x):
            return bin(x).count('1')
      
        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            for c in range((len(s)-(i+1))+1):
                if cnt[curr+c] < k:
                    result = (result+nCr(len(s)-(i+1), c))%MOD
            curr += 1
        return (result-1)%MOD",O(n ^ 2)
"class Solution(object):
    def missingElement(self, nums, k):
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k > missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))",O(logn)
"import sys
input = sys.stdin.readline
n = int(input())
if n < 6:
    print(-1)

else:
    l = []
    o = []
    x = (3+n)//2
    for i in range(3,x+1):
        l.append((1,i))

    for i in range(x+1,n+1):
        o.append((2,i))

    sys.stdout.write(""1""+"" ""+""2""+""\n"")
    for x in l:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

    for x in o:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

sys.stdout.write(""1""+"" ""+""2""+""\n"")
p = 2
for i in range(3,n+1):
    sys.stdout.write(str(p) + "" "" + str(i) + ""\n"")
    p = i
",O(n)
"class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False",O(n ^ 2)
"from sys import *
n = int(stdin.readline())
ans = 0
for i in range(2,n+1):
    for j in range(i*2,n+1,i):
        ans += 4 * (j // i)
print(ans)
",O(nlogn)
"class Solution(object):
    def isIdealPermutation(self, A):
        return all(abs(v-i) <= 1 for i,v in enumerate(A))",O(n)
"class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))",O(n)
"x=int(input())
d=x//2
print(d+1)
",O(1)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1

input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def fun(A):
    for i in range(len(A)):
        if A[i] == 0:
            return i
    return 1

dp = [0]*10
A = aj();A.sort()
k1,k2,k3 = A
for i in range(0,10,k1):
    dp[i] = 1
for i in range(fun(dp),10,k2):
    dp[i] = 1
for i in range(fun(dp),10,k3):
    dp[i] = 1
Y(0 not in dp)
",O(1)
"mod = 1000000007
x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod
    print(ans)",O(logn)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N):
    ans = []

    end = N
    fac = 1

    while end >= 1:
        if end == 1:
            ans.append(fac)
            end = 0
            break

        if end == 2:
            ans.append(fac)
            ans.append(fac * 2)
            end = 0
            break

        if end == 3:
            ans.append(fac)
            ans.append(fac)
            ans.append(fac * 3)
            end = 0
            break

        ans.extend([fac] * ((end + 1) // 2))
        end //= 2
        fac *= 2

    return ans

def main():
    N = int(inp())
    print(*solve(N))

if __name__ == '__main__':
    main()
",O(nlogn)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(1)
"n = int(input())
m = input().split()
t = []
for i in range(n):
    m[i] = int(m[i])
    if i == 0:
        t.append(m[i]+1)
    else:
        t.append(max(t[i-1], m[i]+1))
s = t[n-1] - m[n-1] - 1
for i in range(n-2, -1, -1):
    if t[i] < t[i+1]-1:
        t[i] = t[i+1]-1
    s += t[i] - m[i] - 1
print(s)",O(n)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",O(logn)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",O(n ^ 2)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head",O(n)
"import sys
input=sys.stdin.readline

t=1
for i in range(t):

    n,m,k = map(int,input().split())
    b=[]
    horizontal_edges=[]
    vertical_edges=[]
    for i in range(n):
        temp=[int(x) for x in input().split()]
        horizontal_edges.append(temp)
    for i in range(n-1):
        temp=[int(x) for x in input().split()]
        vertical_edges.append(temp)

    if k%2==1:
        for i in range(n):
            for j in range(m):
                print(-1,end=' ')
            print()
        continue

    dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0

    for z in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                    if i>0:
                        if i<n-1:
                            dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j])
                        else:
                            dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j]
                    else:
                        dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j]
                    if j>0:
                        if j<m-1:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j])
                        else:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j])

    for i in range(n):
            for j in range(m):
                print(dp[i][j][k],end=' ')
            print()",O(n ^ 3)
"class Solution(object):
    def maxCoins(self, nums):
        coins = [1] + [i for i in nums if i > 0] + [1]
        n = len(coins)
        max_coins = [[0 for _ in range(n)] for _ in range(n)]

        for k in range(2, n):
            for left in range(n - k):
                right = left + k
                for i in range(left + 1, right):
                    max_coins[left][right] = \
                        max(max_coins[left][right],
                            coins[left] * coins[i] * coins[right] +
                            max_coins[left][i] +
                            max_coins[i][right])

        return max_coins[0][-1]",O(n ^ 3)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)",O(logn)
"import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def treeQueries(self, root, queries):
        def iter_dfs(root):
            top = collections.defaultdict(lambda: [0]*2)
            depth, height = {}, {}
            stk = [(1, (root, 0))]
            while stk:
                step, (curr, d) = stk.pop()
                if step == 1:
                    if not curr:
                        continue
                    stk.append((2, (curr, d)))
                    stk.append((1, (curr.right, d+1)))
                    stk.append((1, (curr.left, d+1)))
                elif step == 2:
                    h = 1+max((height[curr.left.val] if curr.left else 0), 
                              (height[curr.right.val] if curr.right else 0))
                    if h > top[d][0]:
                        top[d][0], top[d][1] = h, top[d][0]
                    elif h > top[d][1]:
                        top[d][1] = h
                    depth[curr.val], height[curr.val] = d, h
            return top, depth, height

        top, depth, height = iter_dfs(root)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"import sys
if __name__=='__main__':

    numCases = int(sys.stdin.readline())
    for i in range(numCases):
        a, b = sys.stdin.readline().split()
        a = int(a)
        b = int(b)
        total = 0
        largerNum = max(a,b)
        smallerNum = min(a,b)
        while True:
            div = int(largerNum/smallerNum)
            total += div
            rem = int(largerNum%(smallerNum*div))
            if rem == 0:
                break
            else:
                largerNum = smallerNum
                smallerNum = rem

        print(total)
",O(1)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
path = 2*k

for i,level in enumerate(d):
    if level == path:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"MAX=10**9
def main():

    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())

    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1:
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1:
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i

            return (ansi,ansj)
        else:
            return None

    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b

    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None:
            b//=2
        else:
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(*args):

    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

for _abc in range(1):
    main()",np
"t = int(input())
for i in range(t):
    n = int(input())
    arr = [int(x) for x in input().split()]
    arr.sort(reverse=True)
    print(min(arr[1] - 1, len(arr) - 2))",O(nlogn)
"n = int(input())
b = [int(w) for w in input().split()]
a = [0]*n

l = n//2 - 1
r = n//2

a[l] = b[l] // 2
a[r] = b[l] - a[l]

while l > 0:
    if b[l-1] >= b[l]:
        a[l-1] = a[l]
        a[r+1] = b[l-1] - a[l]
    else:
        a[r+1] = a[r]
        a[l-1] = b[l-1] - a[r]
    l -= 1
    r += 1

print(*a)
",O(n)
"n=2*int(input())
a=list(map(int,input().split()))
z=0
for i in range(0,n-1,2):
    if a[i]!=a[i+1]:
        for j in range(i+1,n):
            if a[j]==a[i]:
                z+=j-i-1
                a.pop(j)
                a.insert(i+1,a[i])
print(z)",O(n ^ 2)
"n, k = map(int, input().split())
li = [int(num) for num in input().split("" "", n - 1)]
ans = []
for i in range(0, n):
    su = 0
    for j in range(i, n):
        su += li[j]
        if (j - i + 1 >= k):
            ans.append(su / (j - i + 1))
print(max(ans))",O(n ^ 2)
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]

DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0

			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])

			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])

			DP[idx(r, g, b)] = best

print(max(DP))",O(n ^ 3)
"n = int(input())
curpow, t, mx2pow = 1, 1, 0
while t < n:
    t <<= 1
    mx2pow += 1

if t > n:
    mx2pow -= 1

last = 1 << (mx2pow-1) if mx2pow else 1
add = last

while last < n:
    last += add

if last > n:
    last -= add

while n:
    if n == 1:
        print(last)
        break
    print((str(curpow)+' ') * ((n+1)//2), end='')
    curpow *= 2
    n //= 2
",O(nlogn)
"import heapq



class Solution(object):
    def minimumDifference(self, nums):
        max_heap = []
        for i in range(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in range(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(range(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(range(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result",O(nlogn)
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())

N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1

def zeta_transform(F,n):

    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res

G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)

def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c

ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)
",np
"import sys
readline = sys.stdin.buffer.readline

N = int(readline())
A = list(map(int, readline().split()))

dp = [[0]*N for _ in range(N)]
for j in range(N):
    dp[j][0] = A[j]

for l in range(1, N):
    for j in range(l, N):
        for k in range(j-l, j):
            if dp[k][k-j+l] == dp[j][j-k-1] > 0:
                dp[j][l] = 1+dp[j][j-k-1]
                break

dp = [None] + dp
Dp = [0]*(N+1)
for j in range(1, N+1):
    res = N
    for l in range(j):
        if dp[j][l]:
            res = min(res, 1+Dp[j-l-1])
    Dp[j] = res
print(Dp[N])
",O(n ^ 3)
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",O(1)
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)

	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break
",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def heightOfTree(self, root):
        result = -1
        stk = [(root, 0)]
        while stk:
            u, d = stk.pop()
            result = max(result, d)
            if u.right and u.right.left != u:
                stk.append((u.right, d+1))
            if u.left and u.left.right != u:
                stk.append((u.left, d+1))
        return result",O(n)
"def subsets(S):
    sets = []
    len_S = len(S)
    for i in range(1 << len_S):
        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]
        sets.append(subset)
    return sets

n, l, r, x = list(map(int, input().split()))
problems = list(map(int, input().split()))
res = 0
for m in subsets(problems):
    if l <= sum(m) <= r and (max(m) - min(m)) >= x:
        res += 1
print(res)",np
"class Solution(object):
    def maximumProcessableQueries(self, nums, queries):
        dp = [[float(""-inf"")]*len(nums) for _ in range(len(nums))]
        dp[0][-1] = 0
        for l in reversed(range(1, len(nums))):
            for i in range(len(nums)-(l-1)):
                j = i+(l-1)
                if i-1 >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0))
                if j+1 < len(nums):
                    dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0))
                if dp[i][j] == len(queries):
                    return len(queries)
        return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in range(len(nums)))",O(n ^ 2)
"n, m = map(int, input().split(' '))

distances = list(map(int, input().split(' ')))
taxiDriver = list(map(int, input().split(' ')))

people = []
drivers = []
result = [0] * m

for i in range(len(distances)):
  if(taxiDriver[i]):
    drivers.append(distances[i])
  else:
    people.append(distances[i])

j = 0

for person in people:
  if (j + 1) < len(drivers):
    while (j + 1) < len(drivers) and (drivers[j] - person) < (person - drivers[j + 1]) :
      j += 1

    result[j] += 1
  else:
    result[j] += 1

print(' '.join(map(str, result)))
",O(nlogn)
"a = int(input())
b = list(map(int, input().split()))
c = [int(i % 2 == 0) for i in b]
if(c.count(1) == 1):
	print(c.index(1) + 1)
else:
	print(c.index(0) + 1)
",O(n)
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        resIdx = 0
        resLen = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

        return s[resIdx : resIdx + resLen]
",O(n ^ 2)
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
",O(1)
"n = int(input())
A = map(int, input().split())
a = []
for x in A:
	a.append(x)
tot = 0
for i in range(n):
	l = i
	r = n - i - 1
	tot += a[i] * l + -a[i] * r

from collections import defaultdict

for_cnt = defaultdict(int)

for i in range(n):
	fault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]
	tot -= a[i] * fault
	for_cnt[a[i]] += 1

back_cnt = defaultdict(int)

i = n - 1
while i >= 0:
	fault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]
	tot -= -a[i] * fault
	back_cnt[a[i]] += 1
	i -= 1

print(tot)
",O(nlogn)
"x,k = map(int, input().split())
mod = 10 ** 9 + 7
print(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)
",O(logn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",np
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import itertools


class Solution(object):
    def widestPairOfIndices(self, nums1, nums2):
        lookup = {0:-1}
        result = total = 0
        for i, (n1, n2) in enumerate(zip(nums1, nums2)):
            total += n1-n2
            if total not in lookup:
                lookup[total] = i
            result = max(result, i-lookup[total])
        return result",O(n)
"x, k = map(int, input().split())
mod = 1000 * 1000 * 1000 + 7
if x == 0:
    print(0)
else:
    mul = pow(2, k + 1, mod)
    cnt = pow(2, k, mod)
    s1 = mul * cnt * x
    s2 = cnt * (cnt - 1)
    ans  = (s1 - s2) % mod
    rev = pow(cnt, mod - 2, mod)
    assert rev * cnt % mod == 1
    ans *= rev
    print(ans % mod)
",O(logn)
"n=int(input())
li=list(map(int,input().split()))
lis=[x%2 for x in li]
if lis.count(0)>lis.count(1):
    print(lis.index(1)+1)
else:
    print(lis.index(0)+1)",O(n)
"import random



class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        for i in range(len(reward1)):
            reward1[i] -= reward2[i]
        nth_element(reward1, k-1, compare=lambda a, b: a > b)
        return sum(reward2)+sum(reward1[i] for i in range(k))",O(n)
"n, m = map(int, input().split())
c = []
for j in range(n):
    d = []
    s = input()
    for i in s:
        d.append(i)
    c.append(d)
a = []
b = []
e=[]
g=[]

for j in range(n):
    k=[0]*(m)
    e.append(k)
for j in range(n):
    k=[0]*(m)
    g.append(k)

dpu = []
for j in range(n):
    k=[0]*(m)
    dpu.append(k)
dpd = []
for j in range(n):
    k=[0]*(m)
    dpd.append(k)
dpl = []
for j in range(n):
    k=[0]*(m)
    dpl.append(k)
dpr = []
for j in range(n):
    k=[0]*(m)
    dpr.append(k)
for i in range(n):
    for j in range(m):
        if c[i][j] == ""*"":
            if i>0:
                dpu[i][j]+=dpu[i-1][j]+1
            else:
                dpu[i][j]=1
            if j>0:
                dpl[i][j]=dpl[i][j-1]+1
            else:
                dpl[i][j]=1
i=n-1
while(i>=0):
    j=m-1
    while(j>=0):
        if c[i][j] == ""*"":
            if i<(n-1):
                dpd[i][j] += dpd[i + 1][j] + 1
            else:
                dpd[i][j] = 1
            if j<(m-1):
                dpr[i][j] = dpr[i][j + 1] + 1
            else:
                dpr[i][j] = 1
        j+=-1
    i+=-1
for i in range(1,n-1):
    for j in range(1,m-1):
        if c[i][j] == ""*"":
            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)
            if k==0:
                pass
            elif k>0:
                a.append([i+1,j+1,k])
                e[i-k][j]+=1
                if (i+k)<(n-1):
                    e[i+k+1][j]+=-1
                g[i][j-k] += 1
                if (j + k) < (m - 1):
                    g[i][j+k+1] += -1
for i in range(m):
    for j in range(1,n):
        if c[j-1][i]==""*"":
            e[j][i]+=e[j-1][i]
for i in range(n):
    for j in range(1,m):
        if c[i][j-1]==""*"":
            g[i][j]+=g[i][j-1]
f=0
for i in range(n):
    for j in range(m):
        if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0:
            f=1
            break
if f==1:
    print(-1)
else:
    print(len(a))
    for j in a:
        print(*j)
",O(n ^ 2)
"x, k = [int(v) for v in input().split()]
mod = 10**9 + 7

if x == 0:
    print(0)
else:
    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)
",O(logn)
"class Solution(object):
    def wateringPlants(self, plants, capacity):
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can < x:
                result += 2*i
                can = capacity
            can -= x
        return result",O(n)
"from math import ceil
N = int(input())
S = (N * (N + 1)) / 2
F = int(ceil(N /2.0))
ans = int((S + F) / 2)
print(ans)",O(n)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
p = list(map(int, input().split()))
x = [0] * (n + 1)
for i in range(n):
    if p[i] < m:
        x[i + 1] = -1
    elif p[i] > m:
        x[i + 1] = 1
    else:
        l = i
for i in range(1, n + 1):
    x[i] += x[i - 1]
cnt = [defaultdict(lambda : 0) for _ in range(2)]
for i in range(l + 1):
    cnt[i % 2][x[i]] += 1
ans = 0
for i in range(l + 1, n + 1):
    xi = x[i]
    ans += cnt[i % 2][xi - 1]
    ans += cnt[i % 2 ^ 1][xi]
print(ans)",O(nlogn)
"I=lambda:map(int,input().split())
n,s=I()
l=[0]
for i in range(n):
    q,w=I()
    q=q*60+w
    l+=[q]
if l[1]-l[0]>s:exit(print(0, 0))
for i in range(n):
    if l[i+1]-l[i]>2*s+1:
        l[i]+=s+1
        exit(print(l[i]//60,l[i]%60))
l[-1]+=s+1
print(l[-1]//60,l[-1]%60)",O(n)
"from math import gcd
n, x, y = map(int, input().split())

def solve(n, x, y):
    g = gcd(x, y)
    if gcd(x, y) != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    ans = 0
    for s in [0, 1]:
        dp = [-n, -n]
        dp[s] = 0
        for i in range(x + y):
            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]
        ans = max(ans, dp[s])
    return ans

print(solve(n, x, y))",np
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*n for _ in range(1 << n)]
dp[1][0] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[mask][i] = max(
                    dp[mask][i],
                    dp[mask - (1 << j)][i] * prob[i][j]
                    + dp[mask - (1 << i)][j] * prob[j][i]
                )

print(max(dp[-1]))
",np
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",O(n)
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1

    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:

                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE

check=[0]*(N+1)
check[1]=1

LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

print(ANS)
",O(n)
"n = int(input())
li1 = []
s=""""
li2 = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}
for i in range(n):
    s = input()
    li1.append(s)
print(6-n)
for key in li2:
    if key in li1:
        continue
    else:
        li1.append(key)
        print(li2[key])",O(1)
"import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1",O(n ^ 2)
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",O(n ^ 2)
"import sys
input = lambda: sys.stdin.readline().strip()

nxt = {'R':'G', 'G':'B', 'B':'R'}

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    s = input()
    res = []
    for start in ['R', 'G', 'B']:
        mis = []
        cur = start
        for j in range(k):
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
        res.append(sum(mis))
        for j in range(k, n):
            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
    print(min(res))
",O(n)
"class Solution(object):
    def findTheWinner(self, n, k):
        return reduce(lambda idx, n:(idx+k)%(n+1), range(1, n), 0)+1",O(n)
"class Solution2(object):
    def isFascinating(self, n):
        s = str(n)+str(2*n)+str(3*n)
        return '0' not in s and len(s) == 9 and len(set(s)) == 9",O(logn)
"class Solution2(object):
    def continuousSubarrays(self, nums):
        mn, mx = collections.deque(), collections.deque()
        result = left = 0
        for right in range(len(nums)):
            while mn and nums[mn[-1]] > nums[right]:
                mn.pop()
            mn.append(right)
            while mx and nums[mx[-1]] < nums[right]:
                mx.pop()
            mx.append(right)
            while not nums[right]-nums[mn[0]] <= 2:
                left = max(left, mn.popleft()+1)
            while not nums[mx[0]]-nums[right] <= 2:
                left = max(left, mx.popleft()+1)
            result += right-left+1
        return result",O(n)
"n, k = map(int, input().split())
q = 2 * n + 1
p = k // n
if k % n:
    print(p + 1)
else:
    print(p)",O(1)
"n,m=map(int,input().split())
arr=[ int(x) for x in input().split()]

arr=sorted(arr,reverse=True)
arr.append(0)

isum=sum(arr)
ans=[]
top=arr[0]
for i in range(n):
	if(arr[i]==1):
		ans.append(1)
		arr[i+1]=1
		continue
	if(arr[i+1] >arr[i]):
		arr[i+1]=arr[i]
	if arr[i]-arr[i+1]==0:
		ans.append(1)
		h=1
	else:
		ans.append(arr[i]-arr[i+1])
		h=arr[i]-arr[i+1]

	top=arr[i]-h
	arr[i+1]=top

print(isum-sum(ans))",O(nlogn)
"n = int(input())
arr = list(map(int, input().split()))
res = float('inf')
for i in range(1, n):
    res = min(res, min(arr[i], arr[0]) // i)
for i in range(n - 1):
    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))
print(res)
",O(n)
"class Solution(object):
    def isWinner(self, player1, player2):
        k = 2
        def f(arr):
            result = cnt = 0
            for i in range(len(arr)):
                result += 2*arr[i] if cnt else arr[i]
                cnt += (arr[i] == 10)
                if i-k >= 0:
                    cnt -= (arr[i-k] == 10)
            return result

        a, b = f(player1), f(player2)
        return 1 if a > b else 2 if a < b else 0",O(n)
"mod = 10**9 + 7
x, k = list(map(int, input().split()))
if x == 0:
    print(0)
    exit()
ans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod
print(ans)
",O(logn)
"from math import factorial,pow
send = input()
received = input()

pos = 0
for p in send:
	pos = pos +1 if p=='+' else pos-1
qcount = 0
curr_pos = 0
for p in received:
	if p=='+':
		curr_pos = curr_pos +1
	elif(p=='-'):
		curr_pos = curr_pos-1
	if p=='?':
		qcount +=1

if qcount == 0:
	print(""{:.12f}"".format(1.0 if pos==curr_pos else 0.0))
else:
	exp_val_q = abs(pos -curr_pos)
	if exp_val_q%2!=qcount%2 or qcount<exp_val_q:
		print(""{:.12f}"".format(0.0))
	else:
		neg = (qcount - exp_val_q)/2
		posi = qcount - neg
		val = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))
		print(""{:.12f}"".format(val))
",np
"class Solution(object):
    def maxScore(self, s):
        result, zeros, ones = 0, 0, 0
        for i in range(1, len(s)-1):
            if s[i] == '0':
                zeros += 1
            else:
                ones += 1
            result = max(result, zeros-ones)
        return result + ones + (s[0] == '0') + (s[-1] == '1')",O(n)
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
maxx=0
arr=[0]*(n+1)
for i in range(n):
    summ=0
    for j in range(i,n):
        summ+=lst[j]
        arr[j-i]=max(arr[j-i], summ/(j-i+1))
print(max(arr[m-1:]))",O(n ^ 2)
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    ax, ay = map(int, next(cin).split())
    bx, by = map(int, next(cin).split())
    cx, cy = map(int, next(cin).split())

    if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
        print('YES')
    else:
        print('NO')
",O(1)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if max([n, m]) > k:
        print(-1)
    else:
        if (n + m) % 2 == 0:
            if max([n, m]) % 2 != k % 2:
                print(k - 2)
            else:
                print(k)
        else:
            print(k - 1);
",O(1)
"import sys
input=lambda:sys.stdin.readline().rstrip()

h,w=map(int,input().split())
s=[list("".""*(w+2))]+[list("".""+input()+""."") for _ in range(h)]+[list("".""*(w+2))]
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i in range(1,h+2):
  for j in range(1,w+2):
    if s[i][j]==""*"":
      b[i][j]=b[i-1][j]+1
      c[i][j]=c[i][j-1]+1
for i in range(h,-1,-1):
  for j in range(w,-1,-1):
    if s[i][j]==""*"":
      b[i][j]=min(b[i][j],b[i+1][j]+1)
      c[i][j]=min(c[i][j],c[i][j+1]+1)
ans=[]
for i in range(1,h+1):
  for j in range(1,w+1):
    t=min(b[i][j],c[i][j])-1
    if t>0:
      ans.append((i,j,t))
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i,j,t in ans:
  b[i-t][j]+=1
  b[i+t+1][j]-=1
  c[i][j-t]+=1
  c[i][j+t+1]-=1
for i in range(h+1):
  for j in range(w+1):
    b[i+1][j]+=b[i][j]
    c[i][j+1]+=c[i][j]
    if i!=0 and j!=0:
      if (b[i][j]+c[i][j]>0)!=(s[i][j]==""*""):
        print(-1)
        exit()

print(len(ans))
for i in ans:print(*i)",O(n ^ 2)
"from math import sqrt, floor, ceil
n = int(input())

ran = list(range(2, 1+n//2))
xx = [ d*(n//d-1)     for d in ran]
print(sum(xx)*4)
",O(n)
"class DoublyLinkedList:
    def __init__(self, val, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        head = DoublyLinkedList(tokens[0])
        curr = head

        for i in range(1, len(tokens)):
            curr.next = DoublyLinkedList(tokens[i], prev=curr)
            curr = curr.next

        while head is not None:
            if head.val in ""+-*/"":
                l = int(head.prev.prev.val)
                r = int(head.prev.val)
                if head.val == '+':
                    res = l + r
                elif head.val == '-':
                    res = l - r
                elif head.val == '*':
                    res = l * r
                else:
                    res = int(l / r)

                head.val = str(res)
                head.prev = head.prev.prev.prev
                if head.prev is not None:
                    head.prev.next = head

            ans = int(head.val)
            head = head.next

        return ans
",O(n)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8",O(n)
"class Solution(object):
    def minNumberOperations(self, target):
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))",O(n)
"def fn(n):
	return (n * (n + 1)) / 2

def search(x, n):
	left, right = 0, n
	while left <= right:
		middle = left + (right - left) // 2
		if fn(middle) - (n - middle) == x: return (n - middle)
		elif fn(middle) - (n - middle) > x: right = middle - 1
		else: left = middle + 1
	return -1

if __name__ == '__main__':
	n, k = [int(i) for i in input().split()]
	print(search(k, n))",O(logn)
"l,r=map(int,input().split())
p=bin(l)
p=p[2:]
q=bin(r)
q=q[2:]

t=len(q)
u=len(p)
p=(t-u)*'0'+p
ans=[]

for i in range(len(q)):
    if(q[i]=='1' and p[i]=='0'):
        ans.append(1)
        break;
    elif(q[i]=='1' and p[i]=='1'):
        ans.append(0)
        continue;
    elif(q[i]=='0' and p[i]=='1'):
        ans.append(1)
        continue;
    else:
        ans.append(0)
for j in range(i+1,len(p)):
        ans.append(1)
total=0

ans.reverse()

for i in range(len(ans)):
    total+=pow(2,i)*ans[i]

print(total)
",O(logn)
"n=int(input())
d={}
for _ in range(n):
    a,x=map(int, input().split())
    d[a]=x
m=int(input())
for _ in range(m):
    b,y=map(int, input().split())
    d[b]=max(y, d.get(b,0))
print(sum(d.values()))
",O(nlogn)
"class Solution(object):
    def canMeasureWater(self, x, y, z):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))",O(logn)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
	G = defaultdict(list)

	def addEdge(a,b):
		G[a].append(b)

	def Kahn(N):
	    in_degree = [0]*(N+1)
	    for i in G.keys():
	        for j in G[i]:
	            in_degree[j] += 1
	    queue = deque()
	    for i in range(1,N+1):
	        if in_degree[i] == 0:
	            queue.append(i)
	    cnt =0
	    top_order = []
	    while queue:
	        u = queue.popleft()
	        top_order.append(u)
	        for i in G.get(u,[]):
	            in_degree[i] -= 1
	            if in_degree[i] == 0:
	                queue.append(i)
	        cnt += 1
	    if cnt != N:
	        Y(0);exit(0)
	    else:
	        Y(1);print(*top_order)

	n,m,k = aj()
	mark= {}
	for i in range(n):
		s = input()
		mark[s] = i+1

	B = []
	for i in range(2**k):
		f = bin(i)[2:]
		f = '0'*(k - len(f)) + f
		B.append(f)

	for i in range(m):
		s,mt = input().split("" "")
		mt = int(mt)
		st = set()
		for j in B:
			ss = ['']*k
			for l in range(k):
				if j[l] == '1':
					ss[l] = s[l]
				else:
					ss[l] = '_'
			ss = """".join(ss)
			if ss in mark:
				st.add(mark[ss])

		if mt not in st:
			Y(0);exit(0)
		st.discard(mt)
		for j in st:
			addEdge(mt,j)

	Kahn(n)

try:

	sys.stdin = open('input.txt', 'r')
	sys.stdout = open('output.txt', 'w')
except:
	pass

solve()",np
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    def __init__(self):
        n, m = map(int, input().strip().split())
        segs = list()
        for i in range(m):
            segs.append(list(map(int, input().strip().split())))

        def calc(s, segs):
            res = 0
            for x in segs:
                ones = sum(s[x[0]:x[1] + 1])
                res += ones * (x[1] - x[0] + 1 - ones)
            return res

        s1 = [0 for i in range(n)]
        s2 = [1 for i in range(n)]
        for i in range(n):
            if i % 2 == 0:
                s1[i] = 1
                s2[i] = 0

        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2
        print(''.join(map(str, ans)))

solver()",O(n)
"
class Solution(object):
    def checkString(self, s):
        return ""ba"" not in s
",O(n)
"class Solution(object):
    def tree2str(self, t):
        if not t: return """"
        s = str(t.val)
        if t.left or t.right:
            s += ""("" + self.tree2str(t.left) + "")""
        if t.right:
            s += ""("" + self.tree2str(t.right) + "")""
        return s",O(n)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        start = sorted([i.start for i in intervals])
        end = sorted([i.end for i in intervals])

        res = count = 0
        s = e = 0
        while s < len(intervals):
            if start[s] < end[e]:
                s += 1
                count += 1
            else:
                e += 1
                count -= 1
            res = max(res, count)
        return res
",O(nlogn)
"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        def iter_dfs():
            lookup = [[] for _ in range(26)]
            result = [1]*len(parent)
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    lookup[ord(s[u])-ord('a')].append(u)
                    stk.append((2, u))
                    for v in reversed(adj[u]):
                        stk.append((1, v))
                elif step == 2:
                    for v in adj[u]:
                        result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
                    lookup[ord(s[u])-ord('a')].pop()
            return result
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        return iter_dfs()",O(n)
"R = lambda: map(int, input().split())

n, r = R()
xs = list(R())
ys = []
for i in range(n):
    ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r))
print(*ys)",O(n ^ 2)
"from sys import stdin,stdout
def main():
	n=int(stdin.readline())
	s=stdin.readline()
	sum=0
	a=[]
	for v in s:
		if v!='0' and v!='\n':
			a.append(v)
	if not a and n>1:
		return 'YES'
	n=len(a)
	s=a
	for i in range(n-1):
		sum+=int(s[i])
		j=i+1
		check=1
		while j<n:
			temp=int(s[j])
			j+=1
			while j<n:
				if temp>=sum:
					break
				temp+=int(s[j])
				j+=1
			if sum!=temp:
				check=1
				break
		if sum!=temp:
			check=0
		if check:
			return 'YES'
	return 'NO'
print(main())
",O(n ^ 2)
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
ma = a[0][1]
nma = a[0][2]
for i in range(1, n):
    if a[i][1] >= ma:
        print(a[i][2], nma)
        exit()
    else:
        ma = a[i][1]
        nma = a[i][2]
print(-1, -1)
",O(nlogn)
"class Solution(object):
    def sortVowels(self, s):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        VOWELS = ""AEIOUaeiou""
        LOOKUP = {x:i for i, x in enumerate(VOWELS)}
        vowels = [LOOKUP[x] for x in s if x in LOOKUP]
        inplace_counting_sort(vowels, reverse=True)
        return """".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s)",O(n)
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",O(1)
"import collections
import itertools



class Solution2(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = (len(s)+k-1)//k
        if not (max(cnts.values()) <= bucket_cnt and list(cnts.values()).count(bucket_cnt) <= (len(s)-1)%k+1):
            return """"
        result = [0]*len(s)
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = i%k+1
        return """".join(result)",O(n)
"from collections import Counter

def solve():
    n, k = tuple( map( lambda x: int(x), input().split()) )

    low, high = 0, n

    while low <= high:
        eaten = (low+high)//2
        added = (n-eaten)* (n-eaten+1)/2

        if added - eaten >= k:
            low = eaten + 1
        else:
            high = eaten - 1

    print(high)

if __name__ == ""__main__"":
    solve()",O(logn)
"class Solution2(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=None,
                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,
                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.lazy = [None]*self.base
                self.query_fn = query_fn
                self.update_fn = update_fn
                if build_fn is not None:
                    for i in range(self.base, self.base+N):
                        self.tree[i] = build_fn(i-self.base)
                    for i in reversed(range(1, self.base)):
                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])
                self.count = [1]*len(self.tree) 
                for i in reversed(range(1, self.base)): 
                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) 
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def __push(self, x):
                for h in reversed(range(1, x.bit_length())):
                    y = x>>h
                    if self.lazy[y] is not None:
                        self.__apply(y<<1, self.lazy[y])
                        self.__apply((y<<1)+1, self.lazy[y])
                        self.lazy[y] = None

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) 

                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                self.__push(L)
                self.__push(R)
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        result = accu = 0
        sl = {}
        st = SegmentTree(len(nums))
        for i in range(len(nums)):
            j = sl[nums[i]] if nums[i] in sl else -1
            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD
            result = (result+accu)%MOD
            st.update(j+1, i, 1) 
            sl[nums[i]] = i
        return result",O(nlogn)
"class Solution2(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N

fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break

            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",O(n ^ 3)
"class Solution(object):
    def PredictTheWinner(self, nums):
        if len(nums) % 2 == 0 or len(nums) == 1:
            return True

        dp = [0] * len(nums)
        for i in reversed(range(len(nums))):
            dp[i] = nums[i]
            for j in range(i+1, len(nums)):
                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])

        return dp[-1] >= 0",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
sys.setrecursionlimit(111111)
INF=999999999999999999999999
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))
def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,k=ria()
        a=ria()
        a=sorted(a)
        d=Counter(a)
        ans=0
        for i in a:
            if d[i]:
                ans+=1
                d[i*k]=0
        wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(nlogn)
"n, m = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
if min(G) < max(B):
    print(-1)
    exit(0)
cnt = 0
z = max(B)
y = 0
f = 1
f2 = 0
for i in B:
    if i != z or f2:
        y = max(y, i)
    else:
        f2 = 1
for i in G:
    if i == z:
        f = 0
    cnt += i - z
if f:
    cnt += z - y
print(cnt + sum(B) * m)",O(n)
"class Solution3(object):
    def numberOfSubstrings(self, s):
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right < len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result",O(n)
"x, k = map(int, input().split())
mod = 1000000007
if x == 0:
    print(0)
else:
    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))
",O(logn)
"import sys
sys.setrecursionlimit(50000)
for _ in range(1):
    n,m,k = map(int,input().split())
    s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        d = [int(x) for x in input().split()]
        for j in range(m-1):
            s[i][j][1] = d[j]
            s[i][j+1][3] = d[j]
    for i in range(n-1):
        d = [int(x) for x in input().split()]
        for j in range(m):
            s[i][j][2] = d[j]
            s[i+1][j][0] = d[j]
    if k%2==1:
        for i in range(n):
            print(*[-1 for _ in range(m)])
        continue
    dp = [[[9999999 for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for q in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                cands = []
                if i > 0:
                    cands.append(dp[i-1][j][q-1] + s[i-1][j][2])
                if j > 0:
                    cands.append(dp[i][j-1][q-1] + s[i][j-1][1])
                if i < n - 1:
                    cands.append(dp[i+1][j][q-1] + s[i+1][j][0])
                if j < m - 1:
                    cands.append(dp[i][j+1][q-1] + s[i][j+1][3])
                dp[i][j][q] = min(cands)
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][k//2],end=' ')
        print()",O(n ^ 3)
"class Solution2(object):

    def __init__(self):
        self._cache = {}
        self.url = 'http://tinyurl.com/'

    def encode(self, long_url):
        key = sha256(long_url.encode()).hexdigest()[:6]
        self._cache[key] = long_url
        return self.url + key

    def decode(self, short_url):
        key = short_url.replace(self.url, '')
        return self._cache[key]",O(1)
"import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result",O(n)
"n = int(input())
for q in range(n):
    x, y, k = map(int, input().split())
    if max(x, y) > k:
        print(-1)
    else:
        if 0 == (x + y) % 2:
            if k % 2 == max(x, y) % 2:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",O(1)
"class Solution(object):
    def partitionArray(self, nums, k):
        nums.sort()
        result, prev = 1, 0
        for i in range(len(nums)):
            if nums[i]-nums[prev] <= k:
                continue
            prev = i
            result += 1
        return result",O(nlogn)
"n,m=map(int,input().split())
o=0
c=0
diff=[]
while n:
    n-=1
    a,b=map(int,input().split())
    diff.append(a-b)
    o+=a
    c+=b

if m >=o:
    print(0)
elif m <c:
    print(-1)
else:
    diff.sort(reverse=True)
    nd=o-m

    for i in range(len(diff)):

        nd-=diff[i]
        if nd<=0:
            print(i+1)
            break
",O(nlogn)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0

for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1

print(p)",O(n ^ 2)
"
import bisect


class Solution(object):
    def increasingTriplet(self, nums):
        min_num, a, b = float(""inf""), float(""inf""), float(""inf"")
        for c in nums:
            if min_num >= c:
                min_num = c
            elif b >= c:
                a, b = min_num, c
            else: 
                return True
        return False

",O(n)
"class Solution2(object):
    def isPowerOfThree(self, n):
        return n > 0 and (math.log10(n)/math.log10(3)).is_integer()",O(1)
"class Solution(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        def inv(x, m): 
            return pow(x, m-2, m) 

        def nCr(n, k, m):
            if n-k < k:
                return nCr(n, n-k, m)
            result = 1
            for i in range(1, k+1):
                result = result*(n-k+i)*inv(i, m)%m
            return result

        n = num_people//2
        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD",O(n)
"class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]",O(n)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",O(n ^ 2)
"n,a=list(map(int,raw_input().split()))
deb=1
fin=n+1
while fin-deb>1:
    m=(fin+deb)//2
    if (m*(m+1))//2-(n-m)>a:
        fin=m
    else:
        deb=m
print(n-deb)
",O(logn)
"import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):
                return x
        return -1",O(logn)
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])

    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0

    print(""YES"")
    print(*res[::-1])

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i

matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True
                else:
                    matches[mt].append(pos[tmp])

if(not chk):
    print(""NO"")
else:
    toposort(matches)
",np
"M = 10**9+7
x,k=[int(i) for i in input().split()]
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%M)
else:
    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1
    print(top_sum%M)
",O(logn)
"n, a, b, c, T = map(int, input().split())
ts = list(map(int, input().split()))
ts.sort()
ans = 0
for t in ts:
    temp = -10**18
    for u in range(t, T+1):
        temp = max(temp, c*(u-t)+a-b*(u-t))

    ans += temp
print(ans)
",O(n)
"ans = []
import math
disks_rad = [int(x) for x in input().split("" "")]
nums = [int(x) for x in input().split("" "")]
r = disks_rad[1]
ans.append(r)
for i in range(1, disks_rad[0]):
  y_cord = r
  for j in range(i):
      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):
          y_cord = max(y_cord,
                        ans[j] +
                        math.sqrt(4 *
                                  (r ** 2) -
                                  (nums[j] - nums[i]) ** 2
                                )
                      )
  ans.append(y_cord)
print("" "".join([str(x) for x in ans]))
",O(n ^ 2)
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
",O(n ^ 2)
"import time

(n, k) = (int(i) for i in input().split())

start = time.time()

print((2*n+3-int((9+8*(n+k))**0.5))//2)
finish = time.time()
",O(1)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
candies=[]
for i in range(n):
    candies.append(n-l[i]-r[i])
left=[]
for i in range(n):
    guys=0
    for j in range(i):
        if candies[j]>candies[i]:
            guys+=1
    left.append(guys)
right=[]
for i in range(n):
    guys=0
    for j in range(i,n):
        if candies[j]>candies[i]:
            guys+=1
    right.append(guys)
if left==l and right==r:
    print(""YES"")
    candiesstr=""""
    for i in range(n):
        candiesstr+=str(candies[i])+"" ""
    print(candiesstr[:len(candiesstr)-1])
else:
    print(""NO"")",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y
        }
        
        def iter_dfs(root):
            ret = [0]
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if node.left == node.right:
                        ret[0] = node.val
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = OP[node.val](ret1[0], ret2[0])
            return ret[0]

        return iter_dfs(root)",O(n)
"
class Solution(object):
    def toLowerCase(self, str):
        return """".join([chr(ord('a')+ord(c)-ord('A')) 
                        if 'A' <= c <= 'Z' else c for c in str])

",O(n)
"from fractions import Fraction


class Solution(object):
    def isRationalEqual(self, S, T):
        def frac(S):
            if '.' not in S:
                return Fraction(int(S), 1)

            i = S.index('.')
            result = Fraction(int(S[:i]), 1)
            non_int_part = S[i+1:]
            if '(' not in non_int_part:
                if non_int_part:
                    result += Fraction(int(non_int_part), 10**len(non_int_part))
                return result

            i = non_int_part.index('(')
            if i:
                result += Fraction(int(non_int_part[:i]), 10**i)
            repeat_part = non_int_part[i+1:-1]
            result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1))
            return result

        return frac(S) == frac(T)",O(1)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
class Solution(object):
    def reverseBetween(self, head, m, n):
        diff, dummy, cur = n - m + 1, ListNode(-1), head
        dummy.next = head

        last_unswapped = dummy
        while cur and m > 1:
            cur, last_unswapped, m = cur.__next__, cur, m - 1

        prev, first_swapped = last_unswapped,  cur
        while cur and diff > 0:
            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

        last_unswapped.next, first_swapped.next = prev, cur

        return dummy.__next__",O(n)
"import bisect
from itertools import accumulate, count
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:

        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    primes[1]=False
    primes[0]=False
    return primes
def primefactors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
def factors(n):
    fac=set()
    fac.add(1)
    fac.add(n)
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            fac.add(i)
            fac.add(n//i)
    return list(fac)
def NcR(n, r):

    p = 1
    k = 1
    if (n - r < r):
        r = n - r

    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m

            n -= 1
            r -= 1
    else:
        p = 1
    return p
def Log2(x):
    if x == 0:
        return False;

    return (math.log10(x) /
            math.log10(2));
def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) ==
            math.floor(Log2(n)));

n, r = map(int, input().split())
x = [int(i) for i in input().split()]
c = []

for i in range(n):
    k = r
    for x1, j in c:
        d = abs(x[i] - x1)
        if d <= 2 * r:
            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)
    c.append([x[i], k])
    print(k)
",O(n ^ 2)
"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False

        s1Count, s2Count = [0] * 26, [0] * 26
        for i in range(len(s1)):
            s1Count[ord(s1[i]) - ord('a')] += 1
            s2Count[ord(s2[i]) - ord('a')] += 1

        matches = 0
        for i in range(26):
            matches += (1 if s1Count[i] == s2Count[i] else 0)

        l = 0
        for r in range(len(s1), len(s2)):
            if matches == 26:
                return True

            index = ord(s2[r]) - ord('a')
            s2Count[index] += 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] + 1 == s2Count[index]:
                matches -= 1

            index = ord(s2[l]) - ord('a')
            s2Count[index] -= 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] - 1 == s2Count[index]:
                matches -= 1
            l += 1
        return matches == 26
",O(n)
"import sys
from enum import Enum

class flag(Enum):
    UNVISITED = -1
    EXPLORED = -2
    VISITED = -3

def match(p, s):
    for i in range(len(p)):
        if p[i] != ""_"" and p[i] != s[i]:
            return False
    return True

def cycleCheck(u):
    global AL
    global dfs_num
    global dfs_parent
    global sol

    dfs_num[u] = flag.EXPLORED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            dfs_parent[v] = u
            cycleCheck(v)
        elif dfs_num[v] == flag.EXPLORED.value:
            sol = False
    dfs_num[u] = flag.VISITED.value

def toposort(u):
    global AL
    global dfs_num
    global ts

    dfs_num[u] = flag.VISITED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            toposort(v)
    ts.append(u)

sol = True
n, m, k = map(int, sys.stdin.readline().strip().split())
pd = {}
ps = set()
pa = []
for i in range(n):
    p = sys.stdin.readline().strip()
    pd[p] = i + 1
    ps.add(p)
    pa.append(p)

AL = [[] for _ in range(n)]

for _ in range(m):
    s, fn = sys.stdin.readline().strip().split()
    fn = int(fn)
    if not match(pa[fn-1], s):
        sol = False

    mm = [""""]
    for i in s:
        mm = list(map(lambda x: x + ""_"", mm)) + list(map(lambda x: x + i, mm))
    for i in mm:
        if i in ps:
            if pd[i] != fn:
                AL[fn-1].append(pd[i]-1)

try:
    if not sol:
        print(""NO"")
    else:
        dfs_num = [flag.UNVISITED.value] * n
        dfs_parent = [-1] * n
        for u in range(n):
            if dfs_num[u] == flag.UNVISITED.value:
                cycleCheck(u)
        if not sol:
            print(""NO"")
        else:
            dfs_num = [flag.UNVISITED.value] * n
            ts = []
            for u in range(n):
                if dfs_num[u] == flag.UNVISITED.value:
                    toposort(u)
            ts = ts[::-1]
            print(""YES"")
            print(' '.join(map(lambda x: str(x+1), ts)))
except:
    print(""NO"")",np
"from sys import stdin

def quadratic(a, b, c):
    num = (b * b) - (4 * a * c)
    if num >= 0:
        return [(-b + (num ** .5)) / (2.0 * a), (-b - (num ** .5)) / (2.0 * a)]
    else:
        return [.5, .5]

n, k = map(int, stdin.readline().split())
for root in quadratic(1, 3, -2 * n - 2 * k):
    ans = n - root
    if ans > -1:
        print(int(ans))
        exit()
",O(logn)
"import sys

MOD = 10**9 + 7

x,k = list(map(int,sys.stdin.readline().strip().split(' ')))

a = x*pow(2,k+1,MOD) % MOD
b = (a - pow(2,k,MOD) + 1) % MOD
print(b if x != 0 else 0)",O(logn)
"rd = lambda: map(int, input())
def f(n, t):
    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))
    if t < 3:
        rd()
    return a
n = int(input())
m = sorted([f(n, i) for i in range(4)])
print(2 * n * n + m[0] + m[1] - m[2] - m[3])
",O(n ^ 2)
"s = input()
one = s.count('1')
zero = 0
ind = -1
for i in range(len(s)):
    if s[i]=='2':
        ind=i
        break
    if s[i]=='0':
        zero+=1
d = """"
if ind==-1:
    print(""0""*zero+""1""*one)
    exit()
d =  d + ""0""*zero+""1""*one
for i in s[ind:]:
    if i!='1':
        d+=i
print(d)
",O(n)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def canMerge(self, trees):
        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):
            for root in trees:
                val_to_root[root.val] = root
                q = [root]
                while q:
                    new_q = []
                    for node in q:
                        if node.left is None and node.right is None:
                            if node is not root:
                                leaf_vals_set.add(node.val)
                            continue
                        if node.left:
                            new_q.append(node.left)
                        if node.right:
                            new_q.append(node.right)
                    q = new_q

        def find_root(trees, left_vals_set, val_to_root):
            root = None
            for node in trees:
                if node.val in leaf_vals_set:
                    continue
                if root: 
                    return None
                root = node
            return root

        def merge_bsts(root, left_vals_set, val_to_root):
            if not root:
                return None
            del val_to_root[root.val]
            q = [(root, float(""-inf""), float(""inf""))]
            while q:
                new_q = []
                for node, left, right in q:
                    if not (left < node.val < right):
                        return None
                    if node.left:
                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:
                            node.left = val_to_root[node.left.val]
                            del val_to_root[node.left.val]
                        new_q.append((node.left, left, node.val))
                    if node.right:
                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:
                            node.right = val_to_root[node.right.val]
                            del val_to_root[node.right.val]
                        new_q.append((node.right, node.val, right))
                q = new_q
            return root if not val_to_root else None

        leaf_vals_set, val_to_root = set(), {}
        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    
        root = find_root(trees, leaf_vals_set, val_to_root)
        return merge_bsts(root, leaf_vals_set, val_to_root)",O(n)
"class Solution2(object):
    def minimalKSum(self, nums, k):
        result = prev = 0
        nums.append(float(""inf""))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result",O(nlogn)
"n,m = map(int,input().split())

if m<=n:
    print((m-1)//2)
elif m>n:
    if (m-n) in range(1,n+1):
        if(n-(m-n))%2==0:
            print((n-(m-n))//2)
        else:
            print((n-(m-n))//2+1)
    else:
        print(0)",O(1)
"n = int(input())
print(n if n < 3 else ((n - 1) * (n * (n - 2) if n & 1 else (n - 3) * (n if n % 3 else n - 2))))",O(1)
"class Solution(object):
    def findDerangement(self, n):
        M = 1000000007
        mul, total = 1, 0
        for i in reversed(range(n+1)):
            total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M
            mul = (mul * i) % M
        return total",O(n)
"n, m, k = map(int, input().split())
DATA = [input() for i in range(n)]

INF = 1 << 60
dp = [[INF]*(k + 10) for i in range(n + 10)]
dp[0][0] = 0

COST = [[INF]*(k + 10) for i in range(n + 10)]
for i, string in enumerate(DATA):

    stack = []
    for j in range(m):
        if string[j] == ""1"":
            stack.append(j)
    L = len(stack)
    for j in range(k + 10):
        if j >= L:
            COST[i + 1][j] = 0
            continue
        else:
            for pos in range(j + 1):
                l = pos
                r = pos + L - 1 - j
                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)
for day in range(1, n + 1):
    for used_cost in range(k + 1):
        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]
                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))

ans = min(dp[n][used_cost] for used_cost in range(k + 1))
print(ans)
",O(n ^ 3)
"class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))",O(nlogn)
"from collections import deque

n, m, k = map(int, input().split())
a = deque([int(i) for i in input().split()])

oper = 0
rem = 0
while a:
    x = a.popleft()
    pg = (x - 1 - rem) // k
    lrem = 1
    while a and (a[0] - 1 - rem) // k == pg:
        a.popleft()
        lrem += 1
    rem += lrem
    oper += 1
print(oper)
",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__",O(n)
"class Solution(object):
    def canSplitArray(self, nums, m):
        return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in range(len(nums)-1))",O(n)
"l,r=map(int,input().split())
if(l%2==0 and r-l>1):
    print(l,l+1,l+2,end="" "")
elif(l%2!=0 and r-l>2):
    print(l+1,l+2,l+3,end="" "")
else:
    print(""-1"")",O(1)
"import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result",O(nlogn)
"import math

def valid(n, k, c1, c2):
    if c1 > n:
        return c2
    elif c2 > n:
        return c1
    ans_one = ((n - c1) * (n - c1 + 1) // 2) - c1
    if ans_one == k:
        return c1
    return c2

def f(n, k):
    b2 = (2 * n + 3)
    delta = int(math.sqrt(8 * n + 8 * k + 9))
    return valid(n, k, (b2 + delta) // 2, (b2 - delta) // 2)

n, k = map(int, input().strip().split(' '))
print(f(n, k))
",O(logn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def goodNodes(self, root):
        result = 0
        stk = [(root, root.val)]
        while stk:
            node, curr_max = stk.pop()
            if not node:
                continue
            curr_max = max(curr_max, node.val)
            result += int(curr_max <= node.val)
            stk.append((node.right, curr_max))
            stk.append((node.left, curr_max))
        return result",O(n)
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult

        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)

            md = min(md, d)

        if md > maxd:

            last_tree = (i, j)
            maxd = md

with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")
",O(n ^ 3)
"def main():
	k = int(input())
	digit = 1; low=1; high=9; totalDigit=9; lastTotalDigit=0
	while (totalDigit < k) :
		low *= 10
		high = 10*low-1
		digit += 1
		lastTotalDigit = totalDigit
		totalDigit += (high+1-low)*digit
	k -= lastTotalDigit
	cur = str(low+(k-1) // digit)
	print(cur[(k-1)%digit])

main()
",O(logn)
"import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in zip(sorted_x, sorted_x[1:])] + [0])",O(nlogn)
"class Solution(object):
    def beautifulArray(self, N):
        result = [1]
        while len(result) < N:
            result = [i*2 - 1 for i in result] + [i*2 for i in result]
        return [i for i in result if i <= N]",O(n)
"from sys import stdin

n, m = map(int, stdin.readline().split())
be, en, ans = 1, n, n + 1
while be <= en:
    md = (be + en) >> 1
    if md - sum(int(x) for x in str(md)) >= m:
        en = md - 1
        ans = md
    else:
        be = md + 1

print(n - ans + 1)
",O(logn)
"class Solution(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        mn = min((cnt[i], i) for i in range(value))[1]
        return value*cnt[mn]+mn
import collections",O(n)
"class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import ceil

def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):

    n, m = map(int, input().split())

    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]

    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        is_subset = list(index)
        for i in range(m):
            for mask in range(1 << m):
                if mask & (1 << i):
                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])
        pos = False
        for mask in range(1 << m):
            if index[mask] == -1: continue
            mask2 = ((1 << m) - 1) ^ mask
            if is_subset[mask2] != -1:
                pos = (index[mask], is_subset[mask2])
                break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np
"def maxXORInRange(L, R):

	LXR = L ^ R
	msbPos = 0
	while(LXR):

		msbPos += 1
		LXR >>= 1
	maxXOR, two = 0, 1

	while (msbPos):

		maxXOR += two
		two <<= 1
		msbPos -= 1

	return maxXOR

L, R = [int(i) for i in input().split()]
print(maxXORInRange(L, R))
",O(logn)
"class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)",O(n)
"import math

q = int(input())

for i in range(q):
    x, y, k = map(int, input().split())
    if x > k or y > k:
        print(-1)
    else:
        if (x+y)%2 == 0:
            if (k-max(x,y)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            if (k-max(x,y)) % 2 == 0:
                print(k-1)
            else:
                print(k-1)",O(1)
"n, l, r, x = map(int, input().split())
d = list(map(int, input().split()))
ans = 0
for i in range(pow(2, n)-1, -1, -1):
	s = bin(i)[2:]
	while(len(s) < n):
		s = ""0""+s
	diff = 0
	t = []
	for j in range(n):
		if(s[j]=='1'):
			diff += d[j]
			t.append(d[j])
	t.sort()

	if(l <= diff <= r and t[-1]-t[0] >= x):
		ans += 1
print(ans)",np
"k, n, s, p = map(int, input().split())

sheets = (n + s - 1) // s

print((sheets * k + p - 1) // p)
",O(1)
"n, m = map(int, input().split())
print(m // n + (1 if m % n else 0))
",O(1)
"class Solution2(object):
    def countQuadruplets(self, nums):
        lookup = collections.defaultdict(list)
        for d in range(3, len(nums)):
            for c in range(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in range(1, len(nums)-2) for a in range(b))",O(n ^ 3)
"class Solution(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        result = 0
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(i+1):
                    new_dp[0][i] = max(new_dp[0][i], (prefix[i]-prefix[k])+dp[0][k])
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                for k in range(i+1, len(grid)+1):
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+(new_prefix[k]-new_prefix[i]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"import os,sys
from io import BytesIO, IOBase

def main():
    n,m = map(int,input().split())
    x = ((n-5)//4+((n-5)%4!=0))
    if n <= 5:
        a,b = '5','5'
    else:
        a = '5'*(x+1)
        b = '4'*x+'5'
    print(a,b)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(1)
"n = int(input())
L = []
for i in range(n):
    L.append(list(map(int, input().split()))+[i+1])

L.sort(key=lambda X:(X[0],-X[1],X[2]))

X = 0
for i in range(1,n):
    if L[i][1]<=L[i-1][1]:
        print(L[i][2],L[i-1][2])
        X = 1
        break
if X == 0:
    print(-1,-1)",O(nlogn)
"import math
a, b = map(int, input().split())
if a % b == 0:
    print(int(a/b))
else:
    c = 0
    while b:
        c += a//b
        temp = a
        a = b
        b = temp % b
    print(c)
",O(1)
"class Solution2(object):
    def findGameWinner(self, n):
        grundy = [0, 1] 
        for i in range(2, n):
            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1) 
        return grundy[(n-1)%2] > 0",O(n)
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&po[j]:
                dp[i]=dp[i-po[j]]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)
",np
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
X = [0 for i in range(n)]
Y = [0 for i in range(n)]
for _ in range(n):
    X[_],Y[_] = mi()

def solve(n,X,Y):
    if n<=3:
        return True

    def check(i,j,k):
        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])

    a,b = -1,-1
    for i in range(n):
        if not check(0,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(2,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(0,2,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    return False

print(""YES"" if solve(n,X,Y) else ""NO"")
",O(nlogn)
"import itertools

n, l, r, x = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]

counter = 0
for i, val in enumerate(["""".join(seq) for seq in itertools.product(""01"", repeat=n)]):
    if val.count('1') < 2:
        continue
    dif = 0; mx = float(""-inf""); mn = float(""inf"")
    for i, bit in enumerate(val):
        if bit == '1':
            dif += c[i]
            mx = max(c[i], mx)
            mn = min(c[i], mn)
    if l <= dif <= r and  mx - mn >= x:
        counter += 1

print(counter)
",np
"a,b=input().split()
if(a==b):
    print(""0"")
else:
    xor=bin(int(a)^int(b))[2:]
    a=bin(int(a))[2:]
    b=bin(int(b))[2:]
    ans=""""
    if a[0]==b[0]:
        ans+=""0""
    else:
        ans+=""1""
    for i in range(len(xor)):
        ans+=""1""
    print(int(ans,2))
",O(logn)
"class Solution2(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        dp = [0]*2
        for x in nums:
            dp = [(dp[i]+dp[i^(x%2)]+int(x%2 == i))%MOD for i in range(2)]
        return dp[1]",O(n)
"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
s = input()[:-1]
left, right = 0, n
while left < right:
    mid = right - (right - left) // 2
    A = [[0] * (n + 2) for _ in range(k)]

    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1
        L = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1
            else: L = 0
            A[c][i] = i + mid if L >= mid else A[c][i + 1]

    dp = [n + 1] * (1 << k)
    dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i
            dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np
"n,m = map(int,input().split())
a = [int(x) for x in input().split()]

def gC(m,a):
    s = [0 for x in range(2*n + 1)]
    sum = n
    res = 0
    s[sum] = 1
    ad = 0
    for i in range(n):
        if a[i] < m:
            sum -=1
            ad -=s[sum]
        else:
            ad +=s[sum]
            sum +=1
        res +=ad
        s[sum] +=1
    return res

print(gC(m,a) - gC(m + 1,a))",O(nlogn)
"import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    n,k = map(int,input().split())
    dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)]
    dp[0][1] = [0,1,1,0]
    dp[0][0] = [1,0,0,1]
    for i in range(1,n):
        for r in range(k):
            dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod
            dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod
            dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod
            dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod
            dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod
            dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod
    print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np
"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",O(n ^ 3)
"n = int(input())
a = sorted(set(map(int, input().split())))

if len(a) > 1:
    x = iter(a)
    next(x)
    print(next(x))
else:
    print(""NO"")
",O(nlogn)
"class Solution2(object):
    def preorder(self, root):
        def dfs(root, result):
            result.append(root.val)
            for child in root.children:
                if child:
                    dfs(child, result)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

mod = int(1e9) + 7

def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod

def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count

def main():
    n = int(input())
    a = list(map(int, input().split()))
    d = {}
    for i in range(n):
        d[a[i]] = i
    found=[-1, -1, -1]
    found2=[-1, -1]
    for i in range(n):
        c=1
        while c<(1<<31):
            if a[i]- c in d.keys() and a[i]+c in d.keys():
                found[0]=a[i]-c
                found[1]=a[i]
                found[2]=a[i]+c
            if a[i]- c in d.keys() :
                found2=[a[i], a[i]-c]
            if a[i]+ c in d.keys() :
                found2=[a[i], a[i]+c]
            c*=2
    if found[0]==found[1]:
        if found2[0]==found2[1]:
            print(1)
            print(a[0])
        else:
            print(2)
            print(*found2)
    else:
        print(3)
        print(*found)

    return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"n,m,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort(reverse = True)
s = 0
count = 0

i = 0
while k<m and i<n:
    k+=a[i]-1
    i+=1
print(i if k>=m else -1)
",O(nlogn)
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	(n, k, count) = total_count(n, k)
	if n:
		print(count+2)
	else:
		print(count+1)",O(logn)
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)
",O(1)
"q = int(input())
a,s = map(int,input().split())
if ((a+s-2)<=(q+q-a-s)):
    print(""White"")
else:
    print('Black')
",O(1)
"from sys import exit
n = int(input())
arr = [int(x) for x in input().split()]
tmp = 0
for i in range(len(arr)):
    tmp += (arr[i] - i)
arr.sort()
c = 0
for i in range(1, n):
    if arr[i] == arr[i - 1]:
        c += 1
    if i != 1 and arr[i] == arr[i - 1] and arr[i - 1] == arr[i - 2] + 1:
        print(""cslnb"")
        exit()
if c > 1 or (len(arr) >= 2 and arr[0] == arr[1] == 0):
    print(""cslnb"")
    exit()
print(""cslnb"" if tmp % 2 == 0 else ""sjfnb"")",O(nlogn)
"def forninho(miolo, s):
    premiolo = miolo
    temp = 0
    while (miolo > 0):
        temp += miolo % 10;
        miolo = miolo // 10;
    if (premiolo - temp >= s):
        return 1
    else:
        return 0

entrada = input().split()
n = int(entrada[0])
s = int(entrada[1])

result = -1
l = 1
r = n
while (r-l >= 0):
    miolo = (l + r) // 2
    if(forninho(miolo,s) == 1):
        r = miolo - 1
        result = miolo
    else:
        l = miolo + 1

if (result == -1):
    print(""0"")
else:
    print(n - result + 1)
",O(logn)
"class Solution(object):
    def minimumAverage(self, nums):
        nums.sort()
        return min((nums[i]+nums[~i])/2.0 for i in range(len(nums)//2))",O(nlogn)
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n

        for i in range(n - 2, -1, -1):
            j = i + 1
            while j < n and temperatures[j] <= temperatures[i]:
                if res[j] == 0:
                    j = n
                    break
                j += res[j]

            if j < n:
                res[i] = j - i
        return res
",O(n)
"class Solution2(object):
    def balanceBST(self, root):
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i >= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))",O(n)
"R = lambda: map(int, input().split())
n, k = R()
if n == 1:
    print(0)
    exit(0)
if 1 + k * (k - 1) // 2 < n:
    print(-1)
    exit(0)
l, r = 0, k - 1
while l < r:
    m = (l + r + 1) // 2
    if 1 + (m + k - 1) * (k - 1 - m + 1) // 2 >= n:
        l = m
    else:
        r = m - 1
if 1 + (l + k - 1) * ((k - 1) - l + 1) // 2 < n:
    print(k - 1 - l + 2)
else:
    print(k - 1 - l + 1)",O(logn)
"import collections


class Solution(object):
    def findLHS(self, nums):
        lookup = collections.defaultdict(int)
        result = 0
        for num in nums:
            lookup[num] += 1
            for diff in [-1, 1]:
                if (num + diff) in lookup:
                    result = max(result, lookup[num] + lookup[num + diff])
        return result",O(n)
"n, m = map(int, input().split())
s = input()
t = input()
if ""*"" in s:
    front, back = s.split(""*"")
    if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back):
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""YES"" if s == t else ""NO"")
",O(n)
"class Solution2(object):
    def flipEquiv(self, root1, root2):
        stk1, stk2 = [root1], [root2]
        while stk1 and stk2:
            node1, node2 = stk1.pop(), stk2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                stk1.extend([node1.right, node1.left])
            else:
                stk1.extend([node1.left, node1.right])
            stk2.extend([node2.left, node2.right])
        return not stk1 and not stk2",O(n)
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    ans=10**9
    for i in range(n-k+1):
        x=s[i:i+k]
        m=0
        curr=['R','G','B']
        for l in range(3):
            m=0
            z=l
            for j in x:
                if j!=curr[z]:
                    m+=1
                z+=1
                z%=3
            ans=min(ans,m)
    print(ans)
",O(n ^ 2)
"

class Solution(object):
    def constructTransformedArray(self, nums):
        return [nums[(i+nums[i])%len(nums)] for i in range(len(nums))]
",O(n)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [tuple(inp(dtype)) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i + 1] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

n, T = inp(int)
a = sorted(inp_enus(int, n), key=lambda x: x[-1])
be, en, ans = 0, n, []

while be < en:
    md, time, c = (be + en + 1) >> 1, 0, 0

    for _, i, j in a:
        if time + j <= T and i >= md:
            time += j
            c += 1

    if c >= md:
        be = md
    else:
        en = md - 1

l = be
for _, i, j in a:
    if be and i >= l:
        ans.append(_)
        be -= 1

print(f""{l}\n{l}"")
print(*ans)
",O(nlogn)
"class Solution(object):
    def waysToSplitArray(self, nums):
        total = sum(nums)
        result = curr = 0
        for i in range(len(nums)-1):
            curr += nums[i]
            result += int(curr >= total-curr)
        return result",O(n)
"import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, lookup):
            if not node:
                return
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            dfs(node.left, lookup)
            dfs(node.right, lookup)
    
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        dfs(root, lookup)
        return lookup[root]",O(n)
"def mul(a, b, md) :
    if(b == 1) :
        return a
    if(b % 2 == 0) :
        t = mul(a, b // 2, md)
        return (2 * t) % md
    return (mul(a, b - 1, md) + a) % md;

def pows(a, b, md) :
    if(b == 0) :
        return 1
    if(b % 2 == 0) :
        t = pows(a, b // 2, md)
        return mul(t, t, md) % md
    return (mul(pows(a, b - 1, md) , a, md)) % md;

x, k = map(int, input().split())
ch = pows(2, k, 1000000007)
ans = pows(2, k + 1, 1000000007) * x - ch + 1
ans = ans % (1000000007)
if(x == 0) :
    ans = 0
print(ans)",O(logn)
"import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            stk.append(node.right)
            stk.append(node.left)
        return lookup[root]",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import Counter, defaultdict
import bisect
import math

for _ in range(1):
    n = int(input())

    arr = list(map(int, input().split()))
    t=[0]*n
    cur=0
    for i in range(n-1,-1,-1):
        cur=max(cur-1,0,arr[i]+1)
        t[i]=cur
    ans=0
    for i in range(n):
        cur=max(cur,t[i])
        ans+=cur
    for i in range(n):
        ans-=(arr[i]+1)
    print(ans)
",O(n)
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))",O(nlogn)
"import sys
input = sys.stdin.readline

from collections import deque
N, Q = map(int, input().split())
que = deque([int(a) for a in input().split()])
ma = max(que)

X = []
k = -1
c = 0
while c <= k+N+5:
    a = deque.popleft(que)
    b = deque.popleft(que)

    X.append((a, b))
    c += 1
    if a > b:
        a, b = b, a
    if k < 0 and b == ma:
        k = c
    deque.appendleft(que, b)
    deque.append(que, a)

for _ in range(Q):
    i = int(input()) - 1
    if i <= k:
        print(*X[i])
    else:
        i = (i-k)%(N-1)+k
        print(*X[i])
",O(n)
"class Solution(object):
    def validTicTacToe(self, board):
        def win(board, player):
            for i in range(3):
                if all(board[i][j] == player for j in range(3)):
                    return True
                if all(board[j][i] == player for j in range(3)):
                    return True

            return (player == board[1][1] == board[0][0] == board[2][2] or \
                    player == board[1][1] == board[0][2] == board[2][0])

        FIRST, SECOND = ('X', 'O')
        x_count = sum(row.count(FIRST) for row in board)
        o_count = sum(row.count(SECOND) for row in board)
        if o_count not in {x_count-1, x_count}: return False
        if win(board, FIRST) and x_count-1 != o_count: return False
        if win(board, SECOND) and x_count != o_count: return False

        return True",O(1)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        num_set = set(nums)
        n = len(nums)
        for i in range(n + 1):
            if i not in num_set:
                return i
",O(n)
"import sys
input = sys.stdin.readline

t=int(input())
for testcases in range(t):
    n,m=map(int,input().split())
    A=[list(map(int,input().split())) for i in range(n)]

    B=[]
    for j in range(m):
        B.append([A[i][j] for i in range(n)])

    B.sort(key=lambda x:max(x),reverse=True)

    B=B[:n]

    LEN=len(B)

    if LEN==1:
        print(sum(B[0]))

    elif LEN==2:
        ANS=0
        for i in range(n):
            A=0
            for k in range(n):
                A+=max(B[0][k],B[1][(i+k)%n])

            ANS=max(ANS,A)

        print(ANS)

    elif LEN==3:

        ANS=0
        for i in range(n):
            for j in range(n):

                A=0
                for k in range(n):
                    A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n])

                ANS=max(ANS,A)

        print(ANS)

    elif LEN==4:

        ANS=0
        for i in range(n):
            for j in range(n):
                for l in range(n):

                    A=0
                    for k in range(n):
                        A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n])

                    ANS=max(ANS,A)

        print(ANS)
",np
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",O(1)
"
import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):
        A_B_sum = collections.Counter(a+b for a in A for b in B)
        return sum(A_B_sum[-c-d] for c in C for d in D)

",O(n ^ 2)
"import sys

n, k = map(int, next(sys.stdin).rstrip().split())

xs = list(map(int, next(sys.stdin).rstrip().split()))

mapka = {}
lengths = {}

result = []

for x in xs:

    if x in mapka:
        result.append(mapka[x])
    else:
        left = max(0, x - k + 1)
        range_potential = x - left
        for i in range(range_potential, -1, -1):
            potential_left = x - i
            if potential_left not in mapka:
                result.append(potential_left)
                for y in range(potential_left, x + 1):
                    mapka[y] = potential_left

                lengths[potential_left] = x - potential_left + 1

                break
            else:

                if lengths[mapka[potential_left]] + (x - potential_left) <= k:
                    result.append(mapka[potential_left])
                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):
                        mapka[y] = mapka[potential_left]
                        lengths[mapka[potential_left]] += 1

                    break

print(' '.join(map(str, result)))
",O(n ^ 2)
"a, b= list(map(int, input().split()))
c = 1
result = a^b
while c <= result:
    c *= 2
c -= 1

print(c)
",O(logn)
"import collections
import string

class Solution(object):
    def minDeletions(self, s):
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(range(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result",O(n)
"class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result",O(n)
"class Solution2(object):
    def maxSumBST(self, root):
        def dfs(node, result):
            if not node:
                return True, 0, float(""inf""), float(""-inf"")
            lvalid, lsum, lmin, lmax = dfs(node.left, result)
            rvalid, rsum, rmin, rmax = dfs(node.right, result)
            if lvalid and rvalid and lmax < node.val < rmin:
                total = lsum + node.val + rsum
                result[0] = max(result[0], total)
                return True, total, min(lmin, node.val), max(node.val, rmax)
            return False, 0, 0, 0

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"n,k = map(int,input().split())
s = input()
a = (n-k)//2
s1 = s.replace('(','',a)
s2 = s1.replace(')','',a)
print(s2)",O(n)
"n = int(input())
if n <= 5:
    print(-1)
    for i in range(2, n+1):
        print(1, i)
    exit()

print(1, 2)
print(2, 3)
print(2, 4)
for i in range(5, n+1):
    print(3, i)

for i in range(2, n+1):
    print(1, i)
",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val",O(1)
"class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        order = list(range(len(growTime)))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result",O(nlogn)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(nums)%k
",O(n)
"fact=[1]
temp=1
MOD=10**9+7
for i in range(1,10**5+5):
    temp*=i
    temp%=MOD
    fact+=[temp]
def bino(a,b):
    up=fact[a]
    down=pow(fact[b]*fact[a-b],MOD-2,MOD)
    return (up*down)%MOD

def find(A):
    MOD=10**9+7

    dp=[0]*(10**5+2)
    for x in A:
        dp[x]+=1
    for i in range(2,len(dp)):
        for j in range(2,len(dp)):
            if i*j>len(dp)-1:
                break
            dp[i]+=dp[i*j]
    for i in range(2,len(dp)):
        dp[i]=(pow(2,dp[i],MOD)-1)%MOD

    for i in range(len(dp)-1,1,-1):
        for j in range(2,len(dp)):
            if i*j>=len(dp):
                break
            dp[i]-=dp[i*j]
            dp[i]%=MOD

    ans=0
    for i in range(2,len(dp)):
        ans+=dp[i]
        ans%=MOD

    return (pow(2,len(A),MOD)-ans-1)%MOD
input()
print(find(list(map(int,input().strip().split(' ')))))
",np
"n, k = map(int, input().split())
v = list(map(int, input().split()))

d = {}
ans = 0

for x in v:
  num_d, mod_k = len(str(x)), x % k
  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)

for x in v:
  num_d, mod_k = len(str(x)), x % k
  for add, mods in d.items():
    val_mod = (mod_k * 10 ** add) % k
    need_mod = (k - val_mod) % k
    ans += len(mods.get(need_mod, []))
    if need_mod == mod_k and add == num_d:
      ans -= 1

print(ans)
",O(nlogn)
"class Solution(object):
    def percentageLetter(self, s, letter):
        return 100*s.count(letter)//len(s)",O(n)
"n = int(input())
s = input()
t = input()
dic, diff = {}, []
res, res1, res2 = 0, -1, -1
for i in range(n) :
    if s[i] != t[i] :
        res += 1
        diff.append(i)
        dic[t[i]] = i
swap1, swap2 = False, False
for i in diff :
    if s[i] in dic:
        swap1 = True
        res1 = i+1
        j = dic[s[i]]
        res2 = j+1
        if s[j] == t[i] :
            swap2 = True
            break
print(res - (2 if swap2 else 1 if swap1 else 0))
print(res1, res2)
",O(n)
"class Solution(object):
    def minimumMoves(self, arr):
        dp = [[0 for _ in range(len(arr)+1)] for _ in range(len(arr)+1)]
        for l in range(1, len(arr)+1):
            for i in range(len(arr)-l+1):
                j = i+l-1
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1+dp[i+1][j]
                    if arr[i] == arr[i+1]:
                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])
                    for k in range(i+2, j+1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])
        return dp[0][len(arr)-1]",O(n ^ 3)
"n,tar=[int(i) for i in input().split()]
a=[int(i) for i in input().split()]

from collections import defaultdict
d=defaultdict(lambda:[])
count=0
for i in range(n):
    d[a[i]].append(i)
    if a[i]==tar:
        count+=1

presum=[1 if a[0]==tar else 0]
for e in a[1:]:
    if e==tar:
        presum.append(presum[-1]+1)
    else:
        presum.append(presum[-1])

final = 0
for k,v in d.items():
    if k==tar:
        continue

    t=1
    tt=1
    for i in range(1,len(v)):
        ind=v[i]
        preind=v[i-1]

        t -= presum[ind] - presum[preind]
        t=max(t,0)
        t+=1
        tt=max(tt,t)

    final=max(final,tt)

print(final + count)",O(n)
"r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])

print(ans)
",O(n ^ 3)
"class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        asteroids.sort()
        for x in asteroids:
            if x > mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True",O(nlogn)
"from sys import stdin, stdout

def solve(s1, s2, next):

    dp = [[INF for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    dp[0][0] = 0
    for i in range(len(s1)+1):
        for j in range(len(s2)+1):
            if dp[i][j] == INF:
                continue

            if i < len(s1) and dp[i][j] < len(next) and next[dp[i][j]][ord(s1[i]) - ord('a')] < INF:
                dp[i+1][j] = min(dp[i+1][j], next[dp[i][j]][ord(s1[i]) - ord('a')] + 1)
            if j < len(s2) and dp[i][j] < len(next) and next[dp[i][j]][ord(s2[j]) - ord('a')] < INF:
                dp[i][j+1] = min(dp[i][j+1], next[dp[i][j]][ord(s2[j]) - ord('a')] + 1)

    return dp[len(s1)][len(s2)]

INF = 1e20
T = int(stdin.readline())
for _ in range(T):
    s = stdin.readline().strip()
    rs = stdin.readline().strip()
    next = [[INF for _ in range(26)] for _ in range(len(s))]

    for i in range(len(s)-1, -1, -1):
        if i < len(s)-1:
            for j in range(26):
                next[i][j] = next[i+1][j]
        next[i][ord(s[i]) - ord('a')] = i

    found = False

    if len(rs) == 1:
        if rs in s:
            found = True
    else:
        for p in range(1, len(rs)):
            s1 = rs[:p]
            s2 = rs[p:]

            if solve(s1, s2, next) < INF:
                found = True
                break

    if found:
        stdout.write('YES\n')
    else:
        stdout.write('NO\n')
",O(n ^ 3)
"class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result",O(n)
"n = int(input())
a = list(map(int, input().split()))

dp = [[False] * (n + 1) for i in range(n + 1)]

def solve(l, r):
    if dp[l][r]:
        return dp[l][r]
    if r - l == 1:
        dp[l][r] = (a[l], 1)
        return dp[l][r]
    tmp = 10 ** 9
    for i in range(l + 1, r):
        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:
            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])
        elif solve(l, i) == solve(i, r):
            tmp = solve(l, i)[0] + 1
            dp[l][r] = (tmp, 1)
            return dp[l][r]
        else:
            tmp = min(tmp, 2)
    dp[l][r] = (-1, tmp)
    return dp[l][r]

solve(0, n)
print(dp[0][n][1])",O(n ^ 3)
"n, m = map(int, input().split())
k = list(map(int, input().split()))
p = list(map(int, input().split()))
a = 0
b = 0
ans = 0
while a != n and b != m:
    if p[b] >= k[a]:
        ans += 1
        a += 1
        b += 1
    else:
        a += 1
print(ans)
",O(n)
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
ans = 0

for mask in range(1 << n):
    a = []
    for bit in range(n):
        if mask & (1 << bit):
           a.append(c[bit])
    if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r:
        ans += 1
print(ans)
",np
"n, M = map(int,input().split())

combdic = {}

def fastfrac(a,b,M):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M

def comb(p,q):
    if p==1: return q
    if (p,q) in combdic: return combdic[(p,q)]
    output = (comb(p-1,q-1)*q)%M
    output = fastfrac(output,p,M)
    combdic[(p,q)] = output
    return output

def getnext(i,j,dic):
    if 2*j+1>i: return 0
    if (i,j) in dic: return dic[(i,j)]

    if j==0:
        dic[(i,j)] = (1<<(i-1))%M
        return dic[(i,j)]

    output = 0
    for k in range(2,i):
        if 2*j-1>i-k: break

        output += (getnext(i-k,j-1,dic)*getnext(k-1,0,dic))%M*comb(k-1,i-j)
        output = output%M

    dic[(i,j)] = output

    return output

dic = {}
ans = 0

dp = [[0 for j in range(n//2+3)] for i in range(n+1)]

for i in range(1,n+1):
    dp[i][0] = (1<<(i-1))%M
    for j in range(1,n+1):
        if 2*j+1>i: break

        for k in range(2,i):
            if 2*j-1>i-k: break
            dp[i][j] +=  ((dp[i-k][j-1] * dp[k-1][0])%M * comb(k-1,i-j))%M
            dp[i][j] = dp[i][j]%M

ans = 0
for j in range(n):
    if 2*j+1>i: break

    ans += dp[n][j]
    ans = ans%M

print(ans)
",O(n ^ 3)
"class Solution2(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[0]-x[1]) 
        result = curr = 0
        for a, m in tasks: 
            result += max(m-curr, 0)
            curr = max(curr, m)-a
        return result",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue",O(n)
"n,l,r,x = [int(x) for x in input().split("" "")]
arr = [int(x) for x in input().split("" "")]
ans = 0
for i in range(2**n):
	subset = []
	for j in range(n):
		if (i & (1 << j)) != 0:
			subset.append(arr[j])
	if len(subset)>1:
	    mx = max(subset)
	    mn = min(subset)
	    sm = sum(subset)
	    if l<=sm<=r and mx-mn>=x:
	        ans+=1
print(ans)",np
"import os
import sys
from io import BytesIO, IOBase

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
",np
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        result = 0
        while head: 
            result = result*2 + head.val 
            head = head.__next__ 
        return result",O(n)
"import sys

def sol(a,b):
	for square in [a,b]:
		for i1 in range(4):
			i2 = (i1 + 1)%4
			p1,p2 = square[i1],square[i2]

			norm = (p2[1]-p1[1],p1[0]-p2[0])

			minA = maxA = minB = maxB = None
			for p in a:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minA == None or proj < minA:
					minA = proj
				if maxA == None or proj > maxA:
					maxA = proj
			for p in b:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minB == None or proj < minB:
					minB = proj
				if maxB == None or proj > maxB:
					maxB = proj

			if maxA < minB or maxB < minA:
				return False
	return True

x11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))
x21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))

a = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]
b = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]

print([""NO"",""YES""][sol(a,b)])",O(1)
"def check():
	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][j]:
				f = False
				break
	if f:
		return True

	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[n - 1 - i][j]:
				f = False
				break
	if f:
		return True

	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][n - 1 - j]:
				f = False
				break
	if f:
		return True

def rotate():
	wk1=[]
	for i in range(n):
		wk1.append([])
		for j in range(n):
			wk1[i].append(map1[i][j])

	for i in range(n):
		for j in range(n):
			map1[i][j] = wk1[j][n - 1 - i]

n = int(input())
map1 = []
for i in range(n):
	st = input()
	map1.append([])
	for j in st:
		map1[i].append(j)

map2 = []
for i in range(n):
	st = input()
	map2.append([])
	for j in st:
		map2[i].append(j)

f = False
for k in range(4):
	if check():
		f = True
		break
	rotate()

if f:
	print(""Yes"")
else:
	print(""No"")
",O(n ^ 2)
"def nod(a, b):
    while ((a != 0) and (b != 0)):
        if (a > b):
            a = a % b
        else:
            b = b % a
    return a + b
def point3(x1, y1, x2, y2, x3, y3):
    dy12 = x2 - x1
    dx12 = -(y2 - y1)
    dx13 = x3 - x1
    dy13 = y3 - y1
    if ((dx12 * dx13 + dy12 * dy13) == 0):
        return True
    else:
        return False

lstline = []
mas = list(map(int, input().split()))
n = mas[0]
if (n <= 4):
    for j in range(n):
        mas = list(map(int, input().split()))
    print('YES')
else:
    lst5 = []
    for j in range(5):
        mas = list(map(int, input().split()))
        lst5 = lst5 + [[mas[0], mas[1]]]
    ok = True
    for i in range(3):
        for j in range(i + 1, 4, 1):
            for k in range(j + 1, 5, 1):
                if (ok):
                    if (point3(lst5[i][0], lst5[i][1], lst5[j][0], lst5[j][1], lst5[k][0], lst5[k][1])):
                        l1x1 = lst5[i][0]
                        l1y1 = lst5[i][1]
                        l1x2 = lst5[j][0]
                        l1y2 = lst5[j][1]

                        ok = False
    if (ok == False):
        lstline = []
        for j in range(5):
            if not(point3(l1x1, l1y1, l1x2, l1y2, lst5[j][0], lst5[j][1])):
                lstline = lstline + [[lst5[j][0], lst5[j][1]]]

    if (ok):
        for j in range(n - 5):
            mas = list(map(int, input().split()))
        print('NO')
    else:
        res = 'YES'
        ok1 = True
        for j in range(n - 5):
            mas = list(map(int, input().split()))
            okey1 = point3(l1x1, l1y1, l1x2, l1y2, mas[0], mas[1])

            if (ok1):
                if (len(lstline) == 2):
                    l2x1 = lstline[0][0]
                    l2y1 = lstline[0][1]
                    l2x2 = lstline[1][0]
                    l2y2 = lstline[1][1]
                    ok1 = False
                    okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])
                    if (not(okey1) and not(okey2)):
                        res = 'NO'
                elif(not(okey1)):
                    lstline = lstline + [[mas[0], mas[1]]]
            elif(not(okey1)):
                okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])

                if (not(okey2)):
                    res = 'NO'
        print(res)",O(nlogn)
"import collections


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def serialize(self, root):
        def serializeHelper(node, vals):
            if node:
                vals.append(node.val)
                serializeHelper(node.left, vals)
                serializeHelper(node.right, vals)

        vals = []
        serializeHelper(root, vals)

        return ' '.join(map(str, vals))


    def deserialize(self, data):
        def deserializeHelper(minVal, maxVal, vals):
            if not vals:
                return None

            if minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = deserializeHelper(minVal, val, vals)
                node.right = deserializeHelper(val, maxVal, vals)
                return node
            else:
                return None

        vals = collections.deque([int(val) for val in data.split()])

        return deserializeHelper(float('-inf'), float('inf'), vals)",O(n)
"class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        def iter_dfs():
            lookup = [[float(""-inf""), float(""inf"")] for _ in range(len(adj))]
            stk = [(1, (0, -1, 0))]
            while stk:
                step, (u, p, ah) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p, ah)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u, ah+1)))
                elif step == 2:
                    if len(adj[u])+(u == 0) == 1:
                        lookup[u][0] = 0
                    if u == bob:
                        lookup[u][1] = 0
                    for v in adj[u]:
                        if v == p:
                            continue
                        lookup[u][0] = max(lookup[u][0], lookup[v][0])
                        lookup[u][1] = min(lookup[u][1], lookup[v][1])
                    if ah == lookup[u][1]:
                        lookup[u][0] += amount[u]//2
                    elif ah < lookup[u][1]:
                        lookup[u][0] += amount[u]
                    lookup[u][1] += 1
            return lookup[0][0]

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n = int(input())
        minv = n + 1
        mini = n
        for l in range(1, n + 1):
            v = l + (n + l - 1) // l
            if v < minv:
                minv = v
                mini = l

        ref = [i + 1 for i in range(n)]
        l = mini
        res = list()
        p = n - 1
        while p >= 0:
            pp = max(0, p - l + 1)
            res.extend(ref[pp:p + 1])
            p = pp - 1
        print(' '.join(map(str, res)))

solver()()",O(n)
"n, m = [int(_) for _ in input().split()]
a = [0] * (n + 1)
l, r = 1, n

for i in range(1, n + 1):
    if m <= 1 << max((n - i - 1), 0):
        a[l] = i
        l += 1
    else:
        a[r] = i
        r -= 1
        m -= 1 << max((n - i - 1), 0)

a.pop(0)
print("" "".join(map(str, a)))",np
"import heapq

n, k = list(map(int, input().strip().split()))

p = list(map(int, input().strip().split()))
c = list(map(int, input().strip().split()))

p = sorted([(x, i) for i, x in enumerate(p)], key=lambda x: x[0])

ans = []
top_k = []

cur_gold = 0
for i, t in enumerate(p):
    if k == 0:
        ans.append((c[t[1]], t[1]))
    else:
        if i < k:
            cur_gold += c[t[1]]
            ans.append((cur_gold, t[1]))
            heapq.heappush(top_k, c[t[1]])
        else:
            smallest = heapq.nsmallest(1, top_k)[0]
            if smallest < c[t[1]]:
                cur_gold += c[t[1]]
                ans.append((cur_gold, t[1]))
                heapq.heappop(top_k)
                heapq.heappush(top_k, c[t[1]])
                cur_gold -= smallest
            else:
                ans.append((cur_gold + c[t[1]], t[1]))

ans = sorted(ans, key=lambda x: x[1])
print("" "".join(map(lambda x: str(x[0]), ans)))",O(nlogn)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(e,g)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",O(n ^ 2)
"class Solution(object):
    def divideArray(self, nums, k):
        nums.sort()
        return [nums[i:i+3] for i in range(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in range(0, len(nums), 3)) else []",O(nlogn)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",O(n ^ 3)
"n = int(input())
w = list(map(int, input().split()))
intro = [[v, i] for i, v in enumerate(w, 1)]
intro.sort(key=lambda x: x[0])
s = input()
i = -1
li = []
ans = []
for j in s:
    if j == ""0"":
        i += 1
        ans.append(intro[i][1])
        li.append(intro[i][1])
    else:
        ans.append(li.pop(-1))
print("" "".join(map(str, ans)))
",O(nlogn)
print('4'*1131+'\n'+'5'*1130+'6'),O(1)
"s = input()
sLen, ans = len(s), 0

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)",O(n ^ 3)
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",O(n ^ 2)
"from math import sin, pi
n, r = map(int, input().split())

def p(n, r):
    return 2 * n * r * sin(pi / n)

le = 0; ri = r * 1000
while ri - le > 1e-9:
    m = (ri + le) / 2
    if p(n, r + m) < n * m * 2:
        ri = m
    else:
        le = m
print(m)",O(1)
"from collections import Counter

n, k = map(int, input().split())

for p in range(n+1):
    if p*(p+1)//2 - (n-p) == k:
        print(n-p)
        break
",O(n)
"for x in range(int(input())):
	a,b = map(int,input().split())
	if a > b or a == b:c,d = a,b
	else:c,d = b,a
	e = [0]
	def fun(c,d):
		e[0] += c // d
		f = d
		d = c % d
		c = f
		if f > 0 and d > 0:
			fun(c,d)
	fun(c,d)
	print(e[0])",O(1)
"class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return 0
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            curr = int(node == p or node == q)
            if curr+left+right == 2 and not result[0]:
                result[0] = node
            return curr+left+right

        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"import sys

def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans

def main():
    n,q=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    brr=list(map(int,sys.stdin.readline().strip().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()
",O(nlogn)
"class Solution(object):
    def maximumEnergy(self, energy, k):
        result = float(""-inf"")
        for i in range(k):
            curr = 0
            for j in reversed(range(((len(energy)-i)-1)%k, len(energy)-i, k)): 
                curr += energy[j]
                result = max(result, curr)
        return result",O(n)
"import heapq

def doxor(a, b):
    cnt = 0
    for i in range(len(a)):
        for j in range(len(a[0])):
            cnt += a[i][j] ^ b[i][j]
    return cnt

n = int(input())

a, b = [], []
for i in range(n):
    ai, bi = [], []
    for j in range(n):
        if i % 2 == 0:
            ai.append(j % 2)
            bi.append((j % 2) ^ 1)
        else:
            ai.append((j % 2) ^ 1)
            bi.append(j % 2)
    a.append(ai)
    b.append(bi)

board = []
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])

a_cnts = []
b_cnts = []
for b0 in board:
    heapq.heappush(a_cnts, doxor(b0, a))
    heapq.heappush(b_cnts, doxor(b0, b))

print(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) +
      heapq.heappop(b_cnts) + heapq.heappop(b_cnts))
",O(n ^ 2)
"class Solution(object):
    def orArray(self, nums):
        return [nums[i]|nums[i+1] for i in range(len(nums)-1)]",O(n)
"class Solution(object):
    def checkStraightLine(self, coordinates):
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)",O(n)
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,-1,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
        else:
            ind=m-1
            for j in range(ind,-1,-1):
                while len(rem[j])>req:
                    pop,_=rem[j].pop()
                    rem[i].append([pop+(i-j)%m,_])
                    if len(rem[i])==req:
                        ok=True
                        break
                if ok:
                    break
                ind-=1

out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
",O(n)
"import collections



class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in range(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1",O(n)
"import sys
import bisect
import heapq

from collections import defaultdict as dd
from collections import deque
from collections import Counter as c
from itertools import combinations as comb
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353
def data(): return sys.stdin.readline().strip()

def out(var): sys.stdout.write(var)

def l(): return list(map(int, data().split()))

def sl(): return list(map(str, data().split()))

def sp(): return map(int, data().split())

def ssp(): return map(str, data().split())

def l1d(n, val=0): return [val for i in range(n)]

def l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]

n = int(data())
arr = l()
dp = [[0 for j in range(500)] for i in range(500)]
dp2 = [0 for i in range(501)]
for i in range(n):
    dp[i][i] = arr[i]
i = n-2
while ~i:
    j = i+1
    while j < n:
        dp[i][j] = -1
        for k in range(i, j):
            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:
                dp[i][j] = dp[i][k]+1
        j += 1
    i -= 1
for i in range(1, n+1):
    dp2[i] = pow(10, 9)
    for j in range(i):
        if ~dp[j][i-1]:
            dp2[i] = min(dp2[i], dp2[j]+1)
out(str(dp2[n]))
",O(n ^ 3)
"from operator import itemgetter

class CodeforcesTask528BSolution:
    def __init__(self):
        self.result = ''
        self.n = 0
        self.points = []

    def read_input(self):
        self.n = int(input())
        for _ in range(self.n):
            self.points.append([int(x) for x in input().split("" "")])
            self.points[-1].append(sum(self.points[-1]))

    def process_task(self):
        self.points.sort(key=itemgetter(2))
        last = 0
        ans = 1
        for i in range(1, self.n):
            if self.points[i][0] - self.points[i][1] >= self.points[last][0] + self.points[last][1]:
                last = i
                ans += 1
        self.result = str(ans)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask528BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(nlogn)
"class Solution(object):
    def calPoints(self, ops):
        history = []
        for op in ops:
            if op == '+':
                history.append(history[-1] + history[-2])
            elif op == 'D':
                history.append(history[-1] * 2)
            elif op == 'C':
                history.pop()
            else:
                history.append(int(op))
        return sum(history)",O(n)
"class Solution(object):
    def convertTemperature(self, celsius):
        return [celsius+273.15, celsius*1.80+32.00]",O(1)
"if __name__ == ""__main__"":
    s = input().rstrip().split()
    N = int(s[0])
    K = int(s[1])
    a = list(map(int, list(input().rstrip().split())))

    diff = []
    for i in range(1, N):
        diff.append([i, a[i] - a[i - 1]])
    diff = sorted(diff, key = lambda x: -x[1])
    res = max(a) - min(a)

    k = 0
    while (k < K - 1 and k < len(diff)):
        res -= diff[k][1]

        k += 1
    print(res)",O(nlogn)
"L1=list(map(int, input().split()))
numList=list(map(int, input().split()))
length=L1[0]
targetnumber=L1[1]
pos=numList.index(targetnumber)
pos_r=pos+1
rem=0
right={0:1}
left={0:1}
while pos_r<=length-1:
    if numList[pos_r]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in right:
        right[rem]=1
    else:
        right[rem]+=1
    pos_r+=1
pos_l=pos-1
rem=0
while pos_l>=0:
    if numList[pos_l]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in left:
        left[rem]=1
    else:
        left[rem]+=1
    pos_l-=1
sum=0
for number_l in left:
    if number_l*(-1) in right:
        sum += (left[number_l] * right[(-1) * number_l])
    if 1-number_l in right:
        sum += (left[number_l] * right[1-number_l])
print(sum)",O(nlogn)
"import collections



class Solution(object):
    def countSubarrays(self, nums, k):
        idx = nums.index(k)
        lookup = collections.Counter()
        curr = 0
        for i in reversed(range(idx+1)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            lookup[curr] += 1
        result = curr = 0
        for i in range(idx, len(nums)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            result += lookup[-curr]+lookup[-(curr-1)]
        return result",O(n)
"def main():
	n, d, k = map(int, input().split())
	if n < d+1 or d > 1 and k == 1:
		print('NO')
		return

	edges = [(1, 2)]
	stack = []
	d2 = d/2
	d21 = d2+1
	for node in range(2, d+1):
		edges.append((node, node+1))
		stack.append([node, d2-abs(d21 - node), k-2])
	next_i = d+2
	while next_i <= n:
		if not stack:
			print('NO')
			return

		node = stack[-1]
		i, remaining_depth, remaining_degree = node
		if remaining_depth == 0 or remaining_degree == 0:
			stack.pop()
			continue

		node[2] -= 1
		edges.append((i, next_i))
		stack.append([next_i, remaining_depth-1, k-1])
		next_i += 1

	print('YES')
	print('\n'.join('{} {}'.format(a, b) for a, b in edges))

main()",O(n ^ 2)
"class Solution(object):
    def minMeetingRooms(self, intervals):
        result, curr = 0, 0
        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]
        line.sort()
        for _, num in line:
            curr += num
            result = max(result, curr)
        return result",O(nlogn)
"class Solution4(object):
    def singleNumber(self, nums):
        return (sum(set(nums)) * 3 - sum(nums)) / 2",O(n)
"games,bills = map(int,input().split())
g = list(map(int,input().split()))
b=list(map(int,input().split()))
total = 0
i=0
j=0

while(i < games and j < bills):
    if g[i] <= b[j]:
        total+=1
        i+=1
        j+=1
    elif g[i] > b[j]:
        i+=1
print(total)",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:
        cache = [-1] * n
        def dfs(i):
            if i >= n:
                return i == n
            if cache[i] != -1:
                return cache[i]
            cache[i] = dfs(i + 1) + dfs(i + 2)
            return cache[i]

        return dfs(0)
",O(n)
"import sys
import math as mt
import bisect
input=sys.stdin.readline

t=1
def ncr_util():
    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p
def solve():
    a=1
    b=2*n+3
    c=n+n**2-2*k
    x1=b+int(mt.sqrt(b**2-4*a*c))
    x2=b-int(mt.sqrt(b**2-4*a*c))
    if x1%2==0 and x1//2<=n:
        return x1//2
    return x2//2

for _ in range(t):

    n,k=(map(int,input().split()))

    print(solve())
",O(logn)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:n -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
import heapq
from random import randint as rn
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1

q=[]
for _ in range(input()):
    a=int(stdin.readline())
    b=map(int,stdin.readline().split())
    w={}
    for i in range(a):
        if(w.has_key(b[i])):
            w[b[i]]+=1
        else:
            w[b[i]]=1
    s=-1
    l=0
    mi=2325234324324234
    d=[]
    for i in w:
        if(w[i]>=4):
            t=[str(i),str(i),str(i),str(i)]
            q.append("" "".join(t))
            l=1
            break
        if(w[i]>=2):
            d.append(i)
    if(l==1):
        continue
    d.sort()
    for i in range(len(d)):
        if(s==-1):
            s=d[i]
        else:
            r=float(s)/float(d[i])
            r+=float(d[i])/float(s)
            if(r<mi):
                p=[str(d[i]),str(s)]
                mi=r
            s=d[i]
    p=p*2
    q.append("" "".join(p))
stdout.write(""\n"".join(q))
",O(nlogn)
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(-1, 10**9+1, m))",np
"class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        n = len(grid)
        a_xor_b = 0
        for i in range(n**2):
            r, c = divmod(i, n)
            a_xor_b ^= grid[r][c]^(i+1)
        base = a_xor_b&-a_xor_b
        result = [0]*2
        for i in range(n**2):
            r, c = divmod(i, len(grid[0]))
            result[1 if (i+1)&base != 0 else 0] ^= i+1
            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]
        if any(x == result[1] for row in grid for x in row):
            result[0], result[1] = result[1], result[0]
        return result",O(n ^ 2)
"n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

ans = 0
i = 0
for bill in a:
    try:
        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1
        ans += 1
    except StopIteration:
        break

print(ans)
",O(n)
"n,k = map(int,input().split())
M = 1000000007
if(n == 0):
    print(0)
else:
    ans = 2*n - 1
    x  =  pow(2,k,M)
    print((((ans * x) % M) + 1) % M)",O(logn)
"def main():

    a = input()
    b = input()
    if len(a) < len(b):
        a = list(a)
        a.sort(reverse=True)
        print(''.join(a))
        return

    def solve(i, a: list):
        if i == len(b):
            return ''
        if a.__contains__(b[i]):
            a.remove(b[i])
            suf = solve(i+1, a)
            if suf is not None:
                return b[i] + suf
            a.append(b[i])
        best = ''
        for c in a:
            if c < b[i] and c > best:
                best = c
        if best == '':
            return None
        a.remove(best)
        a.sort(reverse=True)
        return best + ''.join(a)

    a = list(a)
    print(solve(0, a))

main()",O(n ^ 3)
"class Solution(object):
    def maxFrequency(self, nums, k):
        left = 0
        nums.sort()
        for right in range(len(nums)):
            k += nums[right]
            if k < nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1",O(nlogn)
"name = input()
for i in range(len(name), 0, -1):
	for j in range(len(name) - i + 1):
		if name[j: j + i] in name[j + 1:]:
			print(i)
			exit()
print(0)
",O(n ^ 3)
"(x, y, z, t1, t2, t3) = map(int, input().split())

if 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution2(object):
    def findComplement(self, num):
        i = 1
        while i <= num:
            i <<= 1
        return (i - 1) ^ num",O(1)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",O(n)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        left = []
        star = []
        for i, ch in enumerate(s):
            if ch == '(':
                left.append(i)
            elif ch == '*':
                star.append(i)
            else:
                if not left and not star:
                    return False
                if left:
                    left.pop()
                else:
                    star.pop()

        while left and star:
            if left.pop() > star.pop():
                return False
        return not left
",O(n)
"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
a.sort()
if a[-1] == 1: ans = a[:-1] + [2]
else: ans = [1] + a[:-1]
print(*ans)
",O(nlogn)
"def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))

x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

print(f'{x+1} {y+1}')
",O(n ^ 3)
"class Solution(object):
    def canBeValid(self, s, locked):
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(range(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal < 0:
                        return False
        return True",O(n)
"s = input()

def check_x(mid):
    ans = 'no'
    d = {}
    for i in range(len(s)-mid+1):

        if s[i:i+mid] in d.keys():
            ans = 'yes'
            break
        d[s[i:i+mid]] = 1

    return ans

l = 0
r = len(s) - 1
while r-l > 1:
    mid = (r+l) // 2

    ans = check_x(mid)
    if ans == 'yes':
        l = mid
    else:
        r = mid

if check_x(r) == 'yes':
    print(r)
else:
    print(l)
",O(n ^ 3)
