code,complexity
"class Solution:
    def rob(self, nums: List[int]) -> int:

        def dfs(i):
            if i >= len(nums):
                return 0
            return max(dfs(i + 1),
                       nums[i] + dfs(i + 2))

        return dfs(0)
",O(2 ^ n)
"n,s = map(int,input().split())
l = n+1
for i in range(s,min(s+1000000, n)+1,1):
    cur = sum([int(j) for j in str(i)])
    if(i-cur>=s):
        l = i; break
print(n-l+1)",O(logn)
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
f=[1]
iv=[1]
for i in range(1, 5555):
    f.append((f[i-1]*i)%base)
    iv.append(inverse(f[i]))
def C(n, k):
    return (f[n]*iv[k]*iv[n-k])%base
def candy(n, k):

    return C(n+k-1, k-1)
def count_game(k, n, x):
    if(k==0):
        if(n==0):
            return 1
        else:
            return 0
    ans=0
    for i in range(0, k+1):
        t=n-x*i

        if(t<0):
            break
        if(i%2):
            ans=(ans-C(k, i)*candy(t, k))%base
        else:
            ans=(ans+C(k, i)*candy(t, k))%base
    return ans
p, s, r= list(map(int, input().split()))
gamesize=count_game(p, s-r, int(1e18))
gamesize=inverse(gamesize)
ans=0;
for q in range(r, s+1):
    for i in range(0, p):
        t=s-(i+1)*q
        if(t<0):
            break

        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base
print(ans)
",O(n ^ 3)
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]
dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstToGst(self, root):
        def bstToGstHelper(root, prev):
            if not root:
                return root
            bstToGstHelper(root.right, prev)
            root.val += prev[0]
            prev[0] = root.val
            bstToGstHelper(root.left, prev)
            return root
        
        prev = [0]
        return bstToGstHelper(root, prev)",O(n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"import os
import sys
from io import BytesIO, IOBase
import math
from collections import defaultdict, deque
import random

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n, k = map(int, input().split("" ""))
ans = []
for i in range(1, n*k + 1):
    if i%2:
        x,y = divmod(i//2, k)
        ans.append([x+1, y+1])
    else:
        x,y = divmod(n*k-i//2, k)
        ans.append([x + 1, y + 1])
for i in ans:
    sys.stdout.write('{} {}\n'.format(*i))",O(n ^ 2)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:
        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()
    i += 1",O(nlogn)
"n, s = int(input()), input() * 2

h = s.count('H') // 2

print(h - max(s[i:i + h].count('H') for i in range(n)))
",O(n)
"st=input()
m=0
n=len(st)
for i in range(n):
    for j in range(i,n+1) :
        if st[i:j] in st[i+1:n] and len(st[i:j])>m:
            m=len(st[i:j])
print(m)",O(n ^ 3)
"from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd

def read(): return list(map(int, input().strip().split()))

ans_ = []

t_p = [2**i for i in range(31)]
n = int(input());
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [[list(arr.keys())[0], 1]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = arr[a] + arr[b] + arr[c]
        if s > m:
            m = s
            ans_lis = [[x, arr[x]] for x in [a, b, c]]

ans_.append(m)
t = """"
for i in ans_lis:t += (str(i[0])+"" "")*i[1]
ans_.append(t)

for i in ans_:
    print(i)
",O(nlogn)
"import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):
        result, lookup = 'a', collections.Counter()
        for i, c in enumerate(keysPressed):
            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))
            if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:
                result = c
        return result",O(n)
"n = int(input())

if (n == 3):
    print('1 1 3')
else:
    done = 0
    arr = []
    for i in range(30, -1, -1):
        arr.extend([2**i]*(n//(2**i) - done))
        done += n//(2**i) - done
        if (done == 1):
            k = i

    arr[0] = max(arr[0], (n//2**(k-1)) * 2**(k-1))

    arr.reverse()
    print(' '.join(map(str, arr)))
",O(logn)
"import collections

n = int(input())
a = [0, 0] + list(map(int, input().split()))

G = collections.defaultdict(list)
for i in range(2, len(a)):
    G[a[i]].append(i)

nodes = []
q = collections.deque([1])
while q:
    node = q.popleft()
    nodes.append(node)
    for v in G[node]:
        q.append(v)

nodes.reverse()

dp = {}
for u in nodes:
    count = 0
    if len(G[u]) == 0: count += 1
    for v in G[u]:
        count += dp[v]
    dp[u] = count

res = sorted(dp.values())
print(' '.join(map(str, res)))
",O(nlogn)
"n, m = map(int, input().split())
a = []
b = []
while n >= 0:
    a.append(4)
    n -= 4
    b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            while not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
            result = max(result, right-left+1)
        return result",O(nlogn)
"def check_combination(v):
    sm = sum(v)
    if l <= sm <= r:
        if max(v) - min(v) >= x:
            global ans
            ans += 1

def go(offset, k):

    if k == 0:
        check_combination(combination)
        return
    for i in range(offset, len(problems) - k + 1):
        combination.append(problems[i])
        go(i+1, k-1)
        combination.pop()

n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

problems = list()
combination = list()

ans = 0

for i in range(2, len(c) + 1):
    problems = c.copy()
    go(0, i)

print(ans)
",np
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        cnt = k
        res = root.val

        def dfs(node):
            nonlocal cnt, res
            if not node:
                return

            dfs(node.left)
            cnt -= 1
            if cnt == 0:
                res = node.val
                return
            dfs(node.right)

        dfs(root)
        return res
",O(n)
"import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
n,m,k=map(int,input().split())
dist1=[]
for i in range(n):
  dist1.append(list(map(int,input().split())))
dist2=[]
for i in range(n-1):
  dist2.append(list(map(int,input().split())))
if k%2:
  print(' '.join(map(str,[-1]*(n*m))))
  exit()
k//=2
dp=[10**9]*((k+1)*n*m)
for i in range(n):
  for j in range(m):
    dp[i*m+j]=0
for t in range(k):
  r=(t+1)*n*m
  q=t*n*m
  for i in range(n):
    for j in range(m):
      if i<n-1:
        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])
      if i>0:
        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])
      if j<m-1:
        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])
      if j>0:
        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])
ans=[]
for i in range(n):
  for j in range(m):
    ans.append(dp[k*n*m+i*m+j])
print(' '.join(map(str,ans)))",O(n ^ 3)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None

        l1 = head
        while l1 is not None:
            l2 = Node(l1.val)
            l2.next = l1.next
            l1.next = l2
            l1 = l2.next

        newHead = head.next

        l1 = head
        while l1 is not None:
            if l1.random is not None:
                l1.next.random = l1.random.next
            l1 = l1.next.next

        l1 = head
        while l1 is not None:
            l2 = l1.next
            l1.next = l2.next
            if l2.next is not None:
                l2.next = l2.next.next
            l1 = l1.next

        return newHead
",O(n)
"class Solution(object):
    def fourSum(self, nums, target):
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                total = target - nums[i] - nums[j]
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[left] + nums[right] == total:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        right -= 1
                        left += 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif nums[left] + nums[right] > total:
                        right -= 1
                    else:
                        left += 1
        return result",O(n ^ 3)
"class Solution(object):
    def uniqueXorTriplets(self, nums):
        def fst(a, inverse):
            n = len(a)
            step = 1
            while step < n:
                for i in range(0, n, step<<1):
                    for j in range(i, i+step):
                        u, v = a[j], a[j+step]
                        a[j], a[j+step] = u+v, u-v
                step <<= 1
            if inverse:
                for i in range(n):
                    a[i] //= n
        
        a = [0]*(1<<max(nums).bit_length())
        for x in nums:
            a[x] += 1
        fst(a, False)
        for i in range(len(a)):
            a[i] = a[i]**3
        fst(a, True)
        return sum(x != 0 for x in a)",O(nlogn)
"from operator import itemgetter

n = int(input())
if n == 1:
    print(1)
else:
    pi = list(map(int,input().split()))
    ai = [1] * (n+1)
    ai[0] = 10**9
    for i in pi:
        ai[i] = 0
    for i in range(n-2,-1,-1):
        ai[pi[i]] += ai[i+2]
    ai.sort()
    for i in range(n):
        print(ai[i],end="" "")
",O(n)
"class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        intervals.sort(key=lambda i: i.start)

        for i in range(1, len(intervals)):
            i1 = intervals[i - 1]
            i2 = intervals[i]

            if i1.end > i2.start:
                return False
        return True
",O(nlogn)
"n, k = [int(x) for x in input().split()]
ps = [int(x) for x in input().split()]
mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j
    res.append(mapping[p])
print("" "".join(map(str, res)))",O(n ^ 2)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",np
"class Solution(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in reversed(range(2, len(nums))):
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] > nums[i]:
                    result += right-left
                    right -= 1
                else:
                    left += 1
        return result",O(n ^ 2)
"n, m = list(map(int, input().split()))
temp = 0
a = [list(input()) for i in range(n)]
for i in range(n):
    ok = False
    for j in range(m):
        if (a[i][j] == ""B""):
            pos1 = i
            pos2 = j
            temp += 1
            temp2 = j
            if (j != m-1):
                ok = True
                while True:
                    ok2 = False
                    if (temp2 == m-1):
                        ok2 = True
                        break
                    if (a[i][temp2 + 1] != ""B""):
                        ok2 = True
                        break
                    temp += 1
                    temp2 += 1
            elif (j == m - 1):
                temp = 1
                ok = True
                break
            if (ok2):
                break
    if (ok):
        break
print(temp//2 + pos1 + 1, temp//2 + pos2 + 1)",O(n ^ 2)
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input()

idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",O(nlogn)
"import os,sys
from io import BytesIO,IOBase
from math import inf,isinf

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)

        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"MOD = int(1e9 + 7)
x, k = map(int, input().split())
if x == 0: print(0)
else: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)",O(logn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [tuple(inp(dtype)) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i + 1] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

n, T = inp(int)
a = sorted(inp_enus(int, n), key=lambda x: x[-1])
be, en, ans = 0, n, []

while be < en:
    md, time, c = (be + en + 1) >> 1, 0, 0

    for _, i, j in a:
        if time + j <= T and i >= md:
            time += j
            c += 1

    if c >= md:
        be = md
    else:
        en = md - 1

l = be
for _, i, j in a:
    if be and i >= l:
        ans.append(_)
        be -= 1

print(f""{l}\n{l}"")
print(*ans)
",O(nlogn)
"class Solution(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3))",O(1)
"import sys, os
from io import BytesIO, IOBase
import collections, itertools, bisect, heapq, math, string
from decimal import *
from collections import deque

BUFSIZE = 8192

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n = int(input())
    a = list(map(int, input().split()))
    s = set(a)
    a.sort()
    ans = []
    for i in range(n):
        for j in range(31):
            tmp = [a[i]]
            x = a[i] + 2 ** j
            y = a[i] + 2 ** (j + 1)
            if x in s:
                tmp.append(x)
            if y in s:
                tmp.append(y)
            if len(tmp) > 1:
                if len(ans) == 0:
                    ans.append(tmp)
                else:
                    if len(tmp) > len(ans[0]):
                        ans[0] = tmp
    if len(ans) == 0:
        print(1)
        print(a[0])
        return
    if len(ans[0]) == 2:
        print(2)
        print(ans[0][0], ans[0][1])
        return
    if len(ans[0]) == 3:
        print(3)
        print(ans[0][0], ans[0][1], ans[0][2])
        return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(g, e)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"n, q = map(int, input().split(' '))
a = list(map(int, input().split(' ')))

def p(c_k, r):
    l = 0
    while r - l > 1:
        z = (r + l) // 2
        if pr_a[z] > c_k:
            r = z
        else:
            l = z
    return l

pr_a = []
for i in range(n):
    pr_a.append(a[i])
    if i > 0:
        pr_a[i] += pr_a[i - 1]
k = list(map(int, input().split(' ')))
c_k = 0
ans = []
for qq in range(q):
    c_k += k[qq]
    l = p(c_k, n - 1)
    if pr_a[l] <= c_k:
        l += 1
    if c_k >= pr_a[n - 1]:
        c_k = 0
        l = 0
    ans.append(str(n - l))
print('\n'.join(ans))
",O(nlogn)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"class Solution(object):
    def minimumSum(self, n, k):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(k//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)",O(1)
"if __name__ == '__main__':

    x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')]

    lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3

    stairs_time = abs(y-x)*t1

    if lift_time <= stairs_time:
        print('YES')
    else:
        print('NO')",O(1)
"n=int(input())
print(int(n/2)+1)",O(1)
"n = int(input())
u = list(map(int, input().split()))
u.sort()
ans = 0
k = 1
ok = False
for i in range(1, n):
    if u[i] == u[i - 1]:
        k += 1
        if k == 3:
            print('cslnb')
            exit()
        if k == 2:
            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:
                print('cslnb')
                exit()
            ok = True
    else:
        k = 1
for i in range(n):
    ans += u[i] - i
if ans % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')
",O(nlogn)
"n, m, K = map(int, input().split())
wh = [[0]*m for i in range(n)]
wv = [[0]*m for i in range(n)]

for i in range(n):
    t = list(map(int, input().split()))
    for j in range(m-1):
        wh[i][j] = t[j]

for i in range(n-1):
    t = list(map(int, input().split()))
    for j in range(m):
        wv[i][j] = t[j]

f = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)]

for i in range(n):
    for j in range(m):
        f[i][j][0] = 0

for k in range(1, K//2+1):
    for i in range(n):
        for j in range(m):
            if i > 0:
                f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j])
            if j < m-1:
                f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j])
            if i < n-1:
                f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j])
            if j > 0:
                f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1])

for i in range(n):
    for j in range(m):
        if K%2 == 1:
            print(-1)
        else:
            dp = [int(1e8)]*(K//2+1)
            dp[0] = 0
            for k in range(1, K//2+1):
                for l in range(0, k):
                    dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2)

            print(dp[K//2])
",O(n ^ 3)
"import itertools



class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        result = []
        dp = [0, expressCost] 
        for r, e in zip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result",O(n)
"n,m = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
res = list(dict.fromkeys(lst))
c=[]
for i in range(len(res)):
    c.append(lst.count(res[i]))

if m<n:
    print(0)
elif m==n:
    print(1)
else:
    m1=1
    c1=0
    j=2
    f=0
    while(True):
        c1=0
        for i in range(len(c)):
            c1+=c[i]//j
        if c1>=n:
            m1=j
            j+=1
        else:
            f=1
        if f==1:
            print(m1)
            break
",O(nlogn)
"def main():
    n = int(input())
    arr = list(map(int, input().split()))
    ans = 10 ** 10
    for i in range(n):
        x = i if i > n - i - 1 else n - i - 1
        ans = min(ans, arr[i] // x)
    print(ans)
main()",O(n)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(logn)
"class Solution5(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if n%i:
                    continue
                yield i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)

ans = [[0] * 55 for _ in range(55)]

def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')

for i in s:
    buc[find(i)] += 1

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] += dp[j - buc[i]]
        if dp[j] >= MOD:
            dp[j] -= MOD
for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] -= temp_dp[k - buc[i]]
        if temp_dp[k] < 0:
            temp_dp[k] += MOD

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] -= temp_dp[k - buc[j]]
            if temp_dp[k] < 0:
                temp_dp[k] += MOD
        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] += temp_dp[k - buc[j]]
            if temp_dp[k] >= MOD:
                temp_dp[k] -= MOD

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",O(n ^ 3)
"def solve(a, b):
    m = max(a, b)
    n = min(a, b)
    if n == 0:
        return 0
    if m == n:
        return 1
    elif m % n == 0:
        return m // n
    k = m // n
    return k + solve(n, m - n * k)

for _ in range(int(input())):
    a, b = map(int, input().split())
    print(solve(a, b))",O(1)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result",O(nlogn)
"class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        S = ""croak""
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1",O(n)
"from collections import Counter
from collections import defaultdict
import math
import random
import heapq as hq
from math import sqrt
import sys
from functools import reduce

def input():
    return sys.stdin.readline().strip()

def iinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rlinput():
    return list(rinput())

mod = int(1e9)+7

def factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

if __name__ == ""__main__"":
    n = iinput()
    a = rlinput()
    dp = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        dp[i][i] = a[i]

    for l in range(n-2, -1, -1):
        for r in range(l+1, n):
            for k in range(l, r):
                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:

                    dp[l][r] = dp[l][k]+1

    squeeze = [float('inf')]*(n+1)
    squeeze[0] = 0
    for i in range(1, n+1):
        for j in range(i):
            if dp[j][i-1] != 0:
                squeeze[i] = min(squeeze[i], squeeze[j]+1)

    print(squeeze[n])
",O(n ^ 3)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import sys

M = mod = 10 ** 9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]

n = val()
l = li()
c = li()

element = l[0]
for i in range(1, n):element = math.gcd(element, l[i])

if element != 1:
    print(-1)
    exit()

myset = {}

for ind, i in enumerate(l):
    for j in list(myset):
        temp = math.gcd(j, i)
        if(temp not in myset):myset[temp] = myset[j] + c[ind]
        else:myset[temp] = min(myset[temp], c[ind] + myset[j])

    if i not in myset:myset[i] = c[ind]
    else:myset[i] = min(myset[i], c[ind])

print(myset[1])",np
"from math import factorial as fact
s1 = input()
s2 = input()
plus1 = s1.count(""+"")
minus1 = s1.count(""-"")

plus2 = s2.count(""+"")
minus2 = s2.count(""-"")
qCount = s2.count(""?"")

if(plus1==plus2 and minus1==minus2):
	print(1)
else:
	plusReq = plus1 - plus2
	minusReq = minus1 - minus2
	if(plusReq >= 0 and minusReq >= 0):
		ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))
		print(ans)

	else:
		print(0)
",np
"def lvl(val):
    tot=1
    curr=-1
    while(val%tot==0):
        curr+=1
        tot*=2
    return [curr,val*2//(tot),tot//2]

n,q=map(int,input().split())
for _ in range(q):
    curr=int(input())
    l,v,pw=lvl(curr)
    s=input()
    for j in s:

        if j==""U"":
            if v%4==3:
                curr=curr-pw
            else:
                if curr+pw<=n:
                    curr=curr+pw

        elif j==""R"":
            if l>0:
                curr=curr+pw//2

        elif j == ""L"":
            if l > 0:
                curr = curr - pw // 2

        l, v, pw = lvl(curr)

    print(curr)
",np
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])

    print(max(max(v) for v in dp))",O(n)
"n=int(input())
b=[]
for i in range(n):
    b.append(list(map(float,input().split())))

ma=1<<n
dp=[0 for j in range(ma)]
dp[0]=1
for mask in range(1,ma):
    l=n-bin(mask).count(""1"")+1
    res=l*(l-1)//2
    for i in range(n):
        if mask&(1<<i):
            for j in range(n):
                if not mask&(1<<j):

                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)

ans=[]
for i in range(n):
    ans.append(dp[ma-1-(1<<i)])
print(*ans)
",np
"def getIntList():
    return list(map(int, input().split()));
nbColumn, h=getIntList();
if (nbColumn-2)*2<h:
    print('NO')
else:
    print('YES')
    if h%2==0:
        print('.'*nbColumn);
        print('.'+'
        print('.'+'
        print('.'*nbColumn);
    else:
        print('.'*nbColumn);
        hFirst=min(h, nbColumn-2);
        countPoint=(nbColumn-hFirst)//2;
        print('.'*countPoint+'
        hSecond=(h-hFirst)//2;
        countPoint=nbColumn-2*hSecond-2;
        print('.'+'
        print('.'*nbColumn);",O(n)
"class Solution3(object):
    def findErrorNums(self, nums):
        N = len(nums)
        x_minus_y = sum(nums) - N*(N+1)//2
        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y
        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2",O(n)
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]",O(n)
"import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"class Solution(object):
    def findDifferentBinaryString(self, nums):
        return """".join(""01""[nums[i][i] == '0'] for i in range(len(nums)))",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)
",O(1)
"n = int(input())
s = input()
maxn = 0
now = 0
for i in s:
    if i == '+':
        now += 1
    else:
        now -= 1
    maxn = max(maxn, -now)
print(now + maxn)",O(n)
"class Solution(object):
    def maxNonOverlapping(self, nums, target):
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] >= right:
                right = i
                result += 1 
            lookup[accu] = i
        return result",O(n)
"import math
a=input()
b=input()
x=a.count('+')-b.count('+')
y=a.count('-')-b.count('-')
c=a.count('+')-a.count('-')
d=b.count('+')-b.count('-')
e=c-d
f=b.count('?')
if x==0 and y==0:
    print(1)
elif f==0 and (x!=0 or y!=0):
    print(0)
elif x!=0 and y==0:
    print(1/2**f)
elif y!=0 and x==0:
    print(1/2**f)
elif abs(e)>f:
    print(0)
else:
    print(math.factorial(f)/(math.factorial(y)*math.factorial(x)*2**f))",np
"import math
def C(a, b):
	return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))

a = list(input())
b = list(input())
x, y, d, ans, power = 0, 0, 0, 0, 0
for i in range(len(a)):
	if a[i] == '+':
		x += 1
	if a[i] == '-':
		x -= 1
	if b[i] == '?':
		d += 1
	if b[i] == '+':
		y += 1
	if b[i] == '-':
		y -= 1
plus, minus = d, 0
for i in range(0, d+1):
	k = C(d, plus)
	if y+(plus-minus) == x:
		ans += k
	power += k
	plus -= 1
	minus += 1
print(""{0:.12f}"".format(ans/power))",np
"class Solution(object):
    def divisorSubstrings(self, num, k):
        result = curr = 0
        s = list(map(int, str(num)))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k >= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 >= k:
                result += int(curr and num%curr == 0)
        return result",O(logn)
"n,m,k=map(int,input().split())
list1=list(map(int,input().split()))
list1.sort(reverse=True)
c=0
i=0

while(k<m and i<n):
    k+=list1[i]-1
    i+=1
    c+=1
if(k>=m):
    print(c)
else:
    print(-1)",O(nlogn)
"class Solution(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def BellmanFord(dist, pairs, rates):
            for _ in range(len(pairs)):
                for i in range(len(pairs)):
                    dist[pairs[i][1]] = max(dist[pairs[i][1]], dist[pairs[i][0]]*rates[i])
                    dist[pairs[i][0]] = max(dist[pairs[i][0]], dist[pairs[i][1]]*(1/rates[i]))
        
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        BellmanFord(dist, pairs1, rates1)
        BellmanFord(dist, pairs2, rates2)
        return dist[initialCurrency]
import collections",O(n ^ 2)
"import math

n, k = input().split()
n = int(n)
k = int(k)

solfound = 0
m = 0
x0 = 0

if (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2 < n:
    m1 = (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2
else:
    m1 = (3+2*n-math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2

print(int(m1))
",O(logn)
"n = int(input())
print(2*(n**2)-2*n+1)",O(1)
"n = int(input())
for i in range(n):
    k = int(input())
    s = list(map(int, input().split()))
    s.sort()
    print(min(k-2,s[k-2]-1))
",O(nlogn)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = {len(s): 1}
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp[i] += dp[i + 2]
        return dp[0]
",O(n)
"from collections import Counter

n, k = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
f = [int(x) for x in input().split()]
h = [0] + [int(x) for x in input().split()]

cnt_all = Counter(c)
cnt_fav = Counter(f)

ans = 0
for fi in cnt_fav:
    if fi not in cnt_all:
        continue
    m = cnt_fav[fi]
    t = min(cnt_all[fi], m * k)
    dp = [[0] * (t + 1) for _ in range(m + 1)]
    for x in range(1, m + 1):
        for s in range(0, t + 1):
            for ki in range(0, k + 1):
                if ki + s > t:
                    break
                dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki])
    ans += dp[m][t]
print(ans)",O(n ^ 3)
"def f(n):
    if n==1:return[1]
    if n==2:return[1,2]
    if n==3:return[1,1,3]
    if n>3:
        L=f(n//2)
        for i in range(len(L)):L[i]*=2
        return [1]*(n-n//2)+L
L=f(int(input()))
s=''
for i in L:s+=(str(i)+' ')
print(s)",O(nlogn)
"class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
X = [0 for i in range(n)]
Y = [0 for i in range(n)]
for _ in range(n):
    X[_],Y[_] = mi()

def solve(n,X,Y):
    if n<=3:
        return True

    def check(i,j,k):
        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])

    a,b = -1,-1
    for i in range(n):
        if not check(0,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(2,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(0,2,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    return False

print(""YES"" if solve(n,X,Y) else ""NO"")
",O(nlogn)
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)

    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",O(logn)
"n, s = input().split()

n = int(n)
s = int(s)

def get_decimal_value_digits(number):
    count = 0
    digits = 0
    number = str(number)
    for digit in number:
        count += int(digit)
        digits += 1
    return count

def is_big_num(number, s):
    if (number - get_decimal_value_digits(number)) >= s:
        return True
    return False

start = s
end = n
count = 0
digits = 0
half = (n + s) // 2

while (end - start) >= 0:
    half = (start + end) // 2

    if is_big_num(half, s):
        end = half - 1
    else:
        start = half + 1

if not is_big_num(start+1, s):
    print(0)
else:
    print(n - start + 1)
",O(logn)
"class Solution(object):
    def validWordAbbreviation(self, word, abbr):
        i , digit = 0, 0
        for c in abbr:
            if c.isdigit():
                if digit == 0 and c == '0':
                    return False
                digit *= 10
                digit += int(c)
            else:
                if digit:
                    i += digit
                    digit = 0
                if i >= len(word) or word[i] != c:
                    return False
                i += 1
        if digit:
            i += digit

        return i == len(word)",O(n)
"n = int(input())
rang = list(range(2,n//2+1))
a = [i*(n//i-1) for i in rang]
print(sum(a)*4)
",O(n)
"n, k = map(int, input().split())
l = list(map(int, input().split()))
cost = l[n - 1] - l[0]
if k == 1:
	print(cost)
else:
	diff = [0 for _ in range(n - 1)]
	for i in range(n - 1):
		diff[i] = l[i + 1] - l[i]

	diff = sorted(diff)
	diff.reverse()
	print(cost - sum(diff[:k - 1]))",O(nlogn)
"import sys
from collections import defaultdict

input = sys.stdin.readline

n, m = map(int, input().split())

vals = set()
locs = defaultdict(list)
for i in range(n):
    inp = map(int, input().split())
    for pos, v in enumerate(inp):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"class Solution(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = mx = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            if mx > min(nums[i] for i in range(left, right+1)):
                return False
            mx = max(nums[i] for i in range(left, right+1))
            left = right+1
        return True",O(n)
"class Combi():

    def __init__(self, N, mod=10**9 + 7):
        self.power = [1 for _ in range(N+1)]
        self.rev = [1 for _ in range(N+1)]
        self.mod = mod
        for i in range(2, N+1):
            self.power[i] = (self.power[i-1]*i) % self.mod
        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)
        for j in range(N, 0, -1):
            self.rev[j-1] = (self.rev[j]*j) % self.mod

    def com(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod

    def perm(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return (self.power[K])*(self.rev[K-R]) % self.mod

def bitcnt(X):
    res = 0
    v = X
    while v:
        res += v & 1
        v >>= 1
    return res

c = Combi(10000)
NL = list(map(int, list(input())))[::-1]
N = len(NL)
K = int(input())
MOD = 10**9 + 7

dp = [[0]*(1020) for i in range(1020)]

dp[0][0] = 1
for pos, bit in enumerate(NL):
    if bit == 1:
        for bit in range(1010):
            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD
        continue
    else:
        for bit in range(1010):
            dp[pos + 1][bit] = dp[pos][bit]
        continue

INF = 1 << 60
cnt = [INF]*(1010)

cnt[1] = 0
MOD = 10**9 + 7

for i in range(2, 1010):
    cnt[i] = 1 + cnt[bitcnt(i)]

if K == 0:
    print(dp[N][0])
    exit()
else:
    ans = 0
    for bitcnt in range(1010):
        if cnt[bitcnt] == K - 1:
            ans += dp[N][bitcnt]
    if K == 1:
        ans -= 1
    print(ans % MOD)
    exit()
",O(n)
"from math import factorial as fc
def per(a,b):
    return fc(a+b)/(fc(a)*fc(b))
import sys
s=input()
s1=input()
x=s.count(""+"")
y=s.count(""-"")
x1=s1.count(""+"")
y1=s1.count(""-"")
p=x-y
p1=x1-y1
q=s1.count(""?"")
dif=p-p1
if q<abs(p1-p) or dif>q:
    print(0.0)
    sys.exit()
m=abs(y-y1)
pl=abs(x-x1)
print(per(m,pl)/(2**(m+pl)))
",np
"class Solution(object):
    def canCross(self, stones):
        if stones[1] != 1:
            return False

        last_jump_units = {s: set() for s in stones}
        last_jump_units[1].add(1)
        for s in stones[:-1]:
            for j in last_jump_units[s]:
                for k in (j-1, j, j+1):
                    if k > 0 and s+k in last_jump_units:
                        last_jump_units[s+k].add(k)
        return bool(last_jump_units[stones[-1]])",O(n ^ 2)
"
import math


class Solution(object):
    def bulbSwitch(self, n):
        return int(math.sqrt(n))

",O(1)
"class Solution2(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp = [price[u], 0] 
            for v in adj[u]:
                if v == p:
                    continue
                new_dp = dfs(v, u)
                result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0])
                dp[0] = max(dp[0], new_dp[0]+price[u])
                dp[1] = max(dp[1], new_dp[1]+price[u])
            return dp
        
        result = [0]
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        return result[0]",O(n)
"class Solution2(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b

        for i in range(k, len(word), k):
            if all(word[i+j] == word[j] for j in range(len(word)-i)):
                return i//k
        return ceil_divide(len(word), k)",O(n ^ 2)
"n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans

    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()
",O(n ^ 3)
"[l,r]=list(map(int,input().split()))

if l==r:
    print(0)
else:
    a=bin(l)
    b=bin(r)
    a=list(a[2:])
    b=list(b[2:])
    d=0
    if len(a)!=len(b):
        d=len(b)-len(a)
        acta=['0']*d
        for j in a:
            acta.append(j)
        a=acta
    flag=0
    sol=len(b)
    pos=-1
    for i in range(len(b)-1,-1,-1):
        if a[i]!=b[i]:
            pos=sol-i
    if pos!=-1:
        sol=pos

    print((2**sol)-1)",O(logn)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, A, B, C, T = rints()
a, ans = rints(), 0
for i in range(n):
    su, cur = A, A
    for j in range(a[i], T):
        cur -= B
        su = max(su, (j - a[i] + 1) * C + cur)

    ans += su
print(ans)
",O(n)
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",O(n)
"from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.lookup = defaultdict(int)



    def add(self, number):
        self.lookup[number] += 1


    def find(self, value):
        for key in self.lookup:
            num = value - key
            if num in self.lookup and (num != key or self.lookup[key] > 1):
                return True
        return False",O(n)
"import collections
import random
import heapq
import bisect
import math
import time

class Solution2:

    def solve(self, s):
        pass

class Solution:

    def solve(self, n, k):

        grow = 1
        tot = 0

        while n != tot - k:
            tot += grow
            grow += 1
            n -= 1
        return tot - k

sol = Solution()
sol2 = Solution2()

for test_case in range(1):
    N, K = input().split()

    out = sol.solve(int(N),int(K))
    print(str(out))
",O(logn)
"class Solution(object):
    def prefixesDivBy5(self, A):
        for i in range(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]",O(n)
"n = int(input())

a = [input() for _ in range(n)]
b = [input() for _ in range(n)]

cost = 0
for s in [""M"", ""S"", ""XS"", ""XXS"", ""XXXS"", ""L"", ""XL"", ""XXL"", ""XXXL""]:
    ca = a.count(s)
    cb = b.count(s)
    cost += ca - min(ca, cb)

print(cost)",O(n)
"num = input()
num_list = []
for i in range(len(num)):
  num_list.append(int(num[i]))
myMod = (10 ** 9) + 7
length = len(num_list)
f = [0] * (length + 1)
t = [1] * (length + 1)
for i in range(length):
    f[i+1] = (f[i] * 10 + 1) % myMod
    t[i+1] = (t[i] * 10) % myMod
ans = 0
for i in range(1, 10):
    dp = [0] * (length + 1)
    for j in range(length):
        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod
    c = 0
    ctr = 0
    for k in num_list:
        z = min(i, k)
        o = k - z
        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod
        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod
        ans %= myMod
        c += k >= i
        ctr += 1
    ans += f[c]
    if ans >= myMod:
        ans -= myMod
print(ans)
",O(n ^ 2)
"n = int(input())

lst = list(map(int, input().split()))

evens = []
odds = []

for e, x in enumerate(lst):
    if x % 2 == 0:
        evens.append(e + 1)
    else:
        odds.append(e + 1)

if len(evens) < len(odds):
    print(evens[0])
else:
    print(odds[0])
",O(n)
"q = int(input())
for rquer in range(q):
	c, r = map(int, input().split())
	matt = [list(map(int,input().split())) for i in range(c)]
	mat = [[matt[i][j] for i in range(c)] for j in range(r)]
	for i in range(r):
		mat[i].append(max(mat[i]))
		mat[i].reverse()
	mat.sort()
	mat.reverse()
	work = mat[:min(4, r)]
	for t in work:
		t.pop(0)
	r = min(4, r)
	wyn = 0
	for num in range(c**r):
		shif = [(num//(c**i))%c for i in range(r)]
		new = 0
		for i in range(c):
			kol = [work[j][(i + shif[j])%c] for j in range(r)]
			new += max(kol)
		wyn = max(wyn, new)
	print(wyn)
",np
"def readline(): return tuple(map(int, input().split()))
def readlines(count): return (readline() for __ in range(count))

def main():
    n, = readline()
    segments = sorted(readline() + (idx + 1,) for idx in range(n))

    prev = (-1, -1, -1)
    for segment in segments:
        assert prev[0] <= segment[0]
        if prev[0] == segment[0]:
            assert prev[1] <= segment[1]
            print(prev[2], segment[2])
            break
        elif prev[1] >= segment[1]:
            print(segment[2],  prev[2])
            break
        prev = segment
    else:
        print(-1, -1)

main()
",O(nlogn)
"k1,k2,k3 = map(int, input().strip().split(' '))
l=[k1,k2,k3]
if min(k1,k2,k3)==1:
    print('yes')
elif l.count(2)>=2:
    print('yes')
elif l.count(3)==3:
    print('yes')
elif l.count(4)==2 and l.count(2)==1:
    print('yes')
else:
    print('no')",O(1)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"from sys import stdin, stdout

def pair_of_lines(n, xy_a):
    if len(xy_a) <= 3:
        return 'YES'

    p1, p2, p3 = xy_a[0], xy_a[1], xy_a[2]
    if judge(p1, kstr(p1, p2),xy_a):
        return 'YES'
    if judge(p1, kstr(p1, p3),xy_a):
        return 'YES'
    if judge(p2, kstr(p2, p3), xy_a):
        return 'YES'
    return 'NO'

def kstr(xy1, xy2):
    cx, cy = xy1[0], xy1[1]
    x, y = xy2[0], xy2[1]
    dx = x - cx
    dy = y - cy
    k = ''
    if dx == 0:
        k = str(x) + '/y'
    elif dy == 0:
        k = 'x/' + str(y)
    else:
        g = gcd(dx, dy)
        dx //= g
        dy //= g
        k = str(dx) + '/' + str(dy)
    return k

def judge(p, k, xy_a):

    rl = []
    for xy in xy_a:
        if p[0] == xy[0] and p[1] == xy[1]:
            continue
        if kstr(p, xy) != k:
            rl.append(xy)

    if len(rl) > 2:
        ck = kstr(rl[0], rl[1])
        for i in range(2, len(rl)):
            if ck != kstr(rl[0], rl[i]):
                return False

    return True

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

try:
    n = int(stdin.readline())
    xy_a = []
    for _ in range(n):
        xy_a.append(list(map(int, stdin.readline().split())))
    res = pair_of_lines(n, xy_a)
    stdout.write(res)
except Exception as e:
  print(e)
",O(nlogn)
"class Solution(object):
    def reverseString(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1",O(n)
"def problem(s, p):
    n = len(s)
    F = [[n] * 26 for _ in range(n + 2)]
    for i in range(n - 1, -1, -1):
        F[i][:] = F[i + 1]
        F[i][ord(s[i]) - 97] = i

    def interleaving(l, r):
        dp = [-1] + [n] * len(r)

        for j in range(1, len(r) + 1):
            dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]

        for i in range(1, len(l) + 1):
            dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97]

            for j in range(1, len(r) + 1):
                a = F[dp[j] + 1][ord(l[i - 1]) - 97]
                b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]
                dp[j] = min(a, b)

        return dp[-1] < n

    for i in range(len(p)):
        if interleaving(p[:i], p[i:]):
            return 'YES'
    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"n = int(input())
game = list(map(int, input().split()))
game.append(-1)
game.sort()
bitSum = game[1] % 2
rep = False
for i in range(1, n):
    bitSum += game[i + 1] % 2
    if game[i] == game[i + 1]:
        if rep:
            print('cslnb')
            exit(0)
        else:
            if game[i - 1] == game[i] - 1:
                print('cslnb')
                exit(0)
            rep = True
Goal = ((n * (n - 1)) / 2) % 2
if (bitSum + Goal) % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')",O(nlogn)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                simple[mask] = True
                masks[mask] = path
    for i in range(1 << k):
        if not simple[i]:
            continue
        mask = i
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask:
                break
            if (mask & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_child = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask:
                    break
                if (mask & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_child = mask_child | (1 << u)
                    c += 1
            if masks[mask_child] and not masks[mask_child | mask]:
                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}
                if (mask_child | mask) == ((1 << k) - 1):
                    c = [-1] * k
                    p = [-1] * k
                    d = masks[(1 << k) - 1]
                    for key, val in d.items():
                        c[key] = val[0]
                        p[key] = val[1]
                    return True, c, p
    if masks[(1 << k) - 1]:
        c = [-1] * k
        p = [-1] * k
        d = masks[(1 << k) - 1]
        for key, val in d.items():
            c[key] = val[0]
            p[key] = val[1]
        return True, c, p
    return False, None, None

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"class Solution2(object):
    def isValidSequence(self, root, arr):
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False",O(n)
"from bisect import bisect_left
class SegmentTree:
    def __init__(self, N):
        self.n = N
        while (self.n & (self.n - 1)) != 0:
            self.n += 1
        self.tree = [0] * (2 * self.n)

    def update(self, i, val):
        self.tree[self.n + i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            self.tree[j] = max(self.tree[j << 1], self.tree[j << 1 | 1])
            j >>= 1

    def query(self, l, r):
        if l > r:
            return 0
        res = float('-inf')
        l += self.n
        r += self.n + 1
        while l < r:
            if l & 1:
                res = max(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def compress(arr):
            sortedArr = sorted(set(arr))
            order = []
            for num in arr:
                order.append(bisect_left(sortedArr, num))
            return order

        nums = compress(nums)
        n = len(nums)
        segTree = SegmentTree(n)

        LIS = 0
        for num in nums:
            curLIS = segTree.query(0, num - 1) + 1
            segTree.update(num, curLIS)
            LIS = max(LIS, curLIS)
        return LIS
",O(nlogn)
"class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import ceil

def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):

    n, m = map(int, input().split())

    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]

    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        is_subset = list(index)
        for i in range(m):
            for mask in range(1 << m):
                if mask & (1 << i):
                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])
        pos = False
        for mask in range(1 << m):
            if index[mask] == -1: continue
            mask2 = ((1 << m) - 1) ^ mask
            if is_subset[mask2] != -1:
                pos = (index[mask], is_subset[mask2])
                break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np
"class Solution(object):
    def maskPII(self, S):
        if '@' in S:
            first, after = S.split('@')
            return ""{}*****{}@{}"".format(first[0], first[-1], after).lower()

        digits = [x for x in S if x.isdigit()]
        local = ""***-***-{}"".format(digits[-4:])
        if len(digits) == 10:
            return local
        return ""+{}-{}"".format('*' * (len(digits) - 10), local)",O(n)
"a,b,c,d,e,f,g,h,i,j,k,l= [9*1, 90*2, 900*3, 9000*4, 90000*5, 900000*6, 9000000*7, 90000000*8, 900000000*9, 9000000000*10, 90000000000*11, 900000000000*12]
a=a; b= a+b; c= b+c; d=c+d; e=d+e; f= e+f; g= f+g; h=g+h; i=h+i; j= i+j
k= j+k; l= k+l
li1=[0,a,b,c,d,e,f,g,h,i,j,k,l]
n= int(input()); nn=0
for ii in range(1,12):
    if li1[ii-1]<n and li1[ii+1]>n:
        nn= ii

n= n-li1[nn-1]
r1= 10**(nn-1)
n1= n//nn
r1+= n1-1
n2= n-(n1*nn)
if n2==0:
    print(str(r1)[-1])
else:

    print(str(r1+1)[n2-1])",O(logn)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    a = [int(x) for x in input().split(' ')]
    a_pows = []
    a_pow_dict = [{} for u in range(11)]
    for j in range(n):
        x = a[j] % k
        i = 0
        while i < 11:
            if x in a_pow_dict[i]:
                a_pow_dict[i][x] += 1
            else:
                a_pow_dict[i][x] = 1
            i += 1
            x = (x * 10) % k

    c = 0

    for x in a:
        m = len(str(x))
        if (-x) % k in a_pow_dict[m]:
            c += a_pow_dict[m][(-x) % k]
            c -= int(int(str(x) * 2) % k == 0)

    return c

print(solve())",O(nlogn)
"class Solution(object):
    def removeKdigits(self, num, k):
        result = []
        for d in num:
            while k and result and result[-1] > d:
                result.pop()
                k -= 1
            result.append(d)
        return ''.join(result).lstrip('0')[:-k or None] or '0'",O(n)
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])
",O(logn)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 2)
"import itertools


class Solution(object):
    def numTilings(self, N):
        M = int(1e9+7)

        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]

        T = [[1, 0, 0, 1], 
             [1, 0, 1, 0], 
             [1, 1, 0, 0], 
             [1, 1, 1, 0]] 

        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0]",O(logn)
"from io import BytesIO, IOBase
import sys
import math
import os
from collections import defaultdict
from math import ceil
from bisect import bisect_left, bisect_left

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())

def solve():
    n, m, k = mint()
    horizontal = [list(mint()) for i in range(n)]
    vertical = [list(mint()) for i in range(n-1)]
    if k%2 or max(n, m)==1:
        for i in range(n):
            print(*[-1]*m)
        return

    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
    for length in range(1, k//2+1):
        for i in range(n):
            for j in range(m):

                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k//2]*2, end=' ')
        print()

def main():

    t = 1
    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        q = deque()
        if root:
            q.append(root)

        level = 0
        while q:
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            level += 1
        return level
",O(n)
"import os
import sys
import time
from io import BytesIO, IOBase

def main():
    max_int = 10 ** 9
    d = ((1, 0), (-1, 0), (0, 1), (0, -1))
    n, m, k = li_input()
    H = []
    for i in range(n):
        H.append(li_input() + [max_int])

    V = []
    for i in range(n - 1):
        V.append(li_input())

    V.append([max_int] * m)

    if k % 2:
        for i in range(n):
            print(' '.join(['-1'] * m))
        return

    k //= 2

    DP0 = [[0] * (m + 1) for _ in range(n + 1)]
    DP1 = [[0] * (m + 1) for _ in range(n + 1)]

    for kk in range(k):
        for i in range(n):
            for j in range(m):
                l = DP0[i][j - 1] + H[i][j - 1]
                r = DP0[i][j + 1] + H[i][j]
                u = DP0[i - 1][j] + V[i - 1][j]
                d = DP0[i + 1][j] + V[i][j]
                DP1[i][j] = min(l, r, u, d)

        DP0, DP1 = DP1, DP0

    O = []
    for row in DP0[:-1]:
        O.append(' '.join((str(n * 2) for n in row[:-1])))

    print('\n'.join(O))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input():
    return sys.stdin.readline().rstrip(""\r\n"")

def i_input():
    return int(input())

def l_input():
    return input().split()

def li_input():
    return list(map(int, l_input()))

def il_input():
    return list(map(int, l_input()))

if __name__ == ""__main__"":
    TT = time.time()
    main()
",O(n ^ 3)
"class Window(object):
    def __init__(self):
        self.__count = collections.defaultdict(int)

    def add(self, x):
        self.__count[x] += 1

    def remove(self, x):
        self.__count[x] -= 1
        if self.__count[x] == 0:
            self.__count.pop(x)
            
    def size(self):
        return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):
        window1, window2 = Window(), Window()
        result, left1, left2 = 0, 0, 0
        for i in A:
            window1.add(i)
            while window1.size() > K:
                window1.remove(A[left1])
                left1 += 1
            window2.add(i)
            while window2.size() >= K:
                window2.remove(A[left2])
                left2 += 1
            result += left2-left1
        return result",O(n)
"from operator import itemgetter

class CodeforcesTask528BSolution:
    def __init__(self):
        self.result = ''
        self.n = 0
        self.points = []

    def read_input(self):
        self.n = int(input())
        for _ in range(self.n):
            self.points.append([int(x) for x in input().split("" "")])
            self.points[-1].append(sum(self.points[-1]))

    def process_task(self):
        self.points.sort(key=itemgetter(2))
        last = 0
        ans = 1
        for i in range(1, self.n):
            if self.points[i][0] - self.points[i][1] >= self.points[last][0] + self.points[last][1]:
                last = i
                ans += 1
        self.result = str(ans)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask528BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(nlogn)
"n = int(input())
print(n//2+1)",O(1)
"class Solution2(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = int(expression[0:pos]), int(expression[pos+1:]) 
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"class Solution2(object):
    def minimumOneBitOperations(self, n):
        result = 0
        while n:
            result = -result - (n^(n-1)) 
            n &= n-1
        return abs(result)",O(logn)
"from math import *
import sys

input = sys.stdin.readline

def bin_search(arr, n):

	pos = -1

	for i in range(35, -1, -1):
		jump = (1 << i)

		if (pos + jump) >= len(arr):
			continue

		if arr[pos + jump] <= n-1:
			pos += jump

	return len(arr) - pos - 1

def main():
	n, m = [int(x) for x in input().split(' ')]

	vert = []
	for i in range(n):
		vert.append(int(input()))

	hor = []
	for i in range(m):
		col1, col2, row = [int(x) for x in input().split(' ')]

		if col1 != 1:
			continue

		hor.append((col2))

	vert.append(1000000000)

	vert = sorted(vert)
	hor = sorted(hor)

	best = int(1e10)

	for i in range(len(vert)):
		cur_ans = bin_search(hor, vert[i]) + i
		best = min(best, cur_ans)

	print(best)

if __name__ == ""__main__"":
	main()",O(nlogn)
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        def intersect(p_left, p_right, q_left, q_right):
            return max(p_left, q_left) < min(p_right, q_right)

        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and
                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))",O(1)
"import collections



class Solution(object):
    def countPalindromePaths(self, parent, s):
        def iter_dfs():
            result = 0
            cnt = collections.defaultdict(int)
            cnt[0] = 1
            stk = [(0, 0)]
            while stk:
                u, mask = stk.pop()
                if u:
                    mask ^= 1<<(ord(s[u])-ord('a'))
                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                    cnt[mask] += 1
                for v in reversed(adj[u]):
                    stk.append((v, mask))
            return result

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        return iter_dfs()",O(n)
"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        lastIndex = {}
        for i, c in enumerate(s):
            lastIndex[c] = i

        res = []
        size = end = 0
        for i, c in enumerate(s):
            size += 1
            end = max(end, lastIndex[c])

            if i == end:
                res.append(size)
                size = 0
        return res
",O(n)
"def binary(n,k):
    lower=1
    upper=n
    while(lower<upper):
        mid=(lower+upper)//2
        total=(mid*(mid+1))//2
        if n-mid==total-k:
            print(n-mid)
            break
        else:
            if n-mid>total-k:
                lower=mid+1
            else:
                upper=mid

n,k=map(int,input().split())
if n==1 and k==1:
    print(0)
else:
    binary(n,k)
",O(logn)
"n = int(input())
ar = []
for i in range(n):
    ar.append(input())
sortedAr = sorted(ar,key=len)
flag = False
for i in range(n-1):
    if sortedAr[i+1].find(sortedAr[i]) == -1:
        print('NO')
        flag = True
        break
if not flag:
    print('YES')
    for i in sortedAr:
        print(i)
",O(nlogn)
"from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    n = ii()
    d = defaultdict(int)
    ll = defaultdict(list)
    rr = defaultdict(list)
    llst = []
    rlst = []
    lst = []
    for i in range(n):
        l, r = mii()
        lst.append([l,r])
        llst.append(l)
        rlst.append(r)
        ll[l].append(r)
        rr[r].append(l)
    left = max(llst)
    right = min(rlst)
    lleft = min(ll[left])
    lright = max(rr[right])
    lst.remove([left,lleft])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    mx = max(0,pr-pl)
    lst.append([left,lleft])
    lst.remove([lright,right])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    print(max(mx, max(0,pr-pl)))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n)
"class Solution(object):
    def interpret(self, command):
        result, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                result += [""G""]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += [""o""]
                i += 2
            else:
                result += [""al""]
                i += 4
        return """".join(result)",O(n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        l, r = 0, 1
        maxP = 0

        while r < len(prices):
            if prices[l] < prices[r]:
                profit = prices[r] - prices[l]
                maxP = max(maxP, profit)
            else:
                l = r
            r += 1
        return maxP
",O(n)
"n, m = map(int, input().split())
y = []
for i in range(n):
    y.append(int(input()))
y.append(10 ** 9)
x = []
for i in range(m):
    a, b, c = map(int, input().split())
    if a == 1:
        x.append(b)
y.sort(); x.sort()
m = len(x)
ans = m
k = 0
for i in range(n + 1):
    ok = True
    for j in range(k, m):
        if y[i] <= x[j]:
            k = j
            ok = False
            break
    if ok:
        k = m
        ans = min(ans, m - k + i)
        break
    ans = min(ans, m - k + i)
print(ans)
",O(nlogn)
"s = input()
pb = 0
lenght = len(s)-1
w = []
while(lenght!=0):
    ss = s[pb:pb+lenght]
    w.append(ss)
    if pb+lenght==len(s):
        pb = 0
        lenght -= 1
    else:
        pb+=1
for i in range(0,len(w)-1):
    for j in range(i+1,len(w)):
        if (w[i]==w[j]):
            print(len(w[i]))
            exit(0)
print(0)
",O(n ^ 3)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            l, r = i + 1, len(numbers) - 1
            tmp = target - numbers[i]
            while l <= r:
                mid = l + (r - l)//2
                if numbers[mid] == tmp:
                    return [i + 1, mid + 1]
                elif numbers[mid] < tmp:
                    l = mid + 1
                else:
                    r = mid - 1
        return []
",O(nlogn)
"def main():
    n, k = map(int, input().split())
    n -= 1
    k -= 1
    if n == 0:
        minSplitters = 0
    elif n <= k:
        minSplitters = 1
    elif n > sum_consecutive(k):
        minSplitters = -1
    else:
        minSplitters = min_splitters(n, k)

    print(minSplitters)

def min_splitters(n, k):
    low, high = 1, k
    while low < high:
        mid = (low + high) // 2
        summation = sum_consecutive2(mid, k)
        if summation == n:
            return k - mid + 1
        elif summation > n:
            low = mid + 1
        else:
            high = mid

    return k - low + 2

def sum_consecutive(num):
    return int(0.5 * num * (num + 1))

def sum_consecutive2(num1, num2):
    return sum_consecutive(num2) - sum_consecutive(num1 - 1)

if __name__ == '__main__':
    main()
",O(logn)
"class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        return [words[i] for i in range(n) if i == 0 or groups[i-1] != groups[i]]",O(n)
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

import random
from collections import OrderedDict
from fractions import Fraction

n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))
",O(n)
"class Solution(object):
    def buildArray(self, target, n):
        result, curr = [], 1
        for t in target:
            result.extend([""Push"", ""Pop""]*(t-curr))
            result.append(""Push"")
            curr = t+1
        return result",O(n)
"class Solution(object):
    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):
        def cost(m, s):
            if not (0 <= m <= 99 and s <= 99):
                return float(""inf"")
            result = 0
            curr = startAt
            for x in map(int, list(str(m*100 + s))):
                result += (moveCost if x != curr else 0)+pushCost
                curr = x
            return result

        m, s = divmod(targetSeconds, 60)
        return min(cost(m, s), cost(m-1, s+60))",O(1)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def isSameTree(self, p, q):
        if p is None and q is None:
            return True

        if p is not None and q is not None:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

        return False

",O(n)
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    ans=10**9
    for i in range(n-k+1):
        x=s[i:i+k]
        m=0
        curr=['R','G','B']
        for l in range(3):
            m=0
            z=l
            for j in x:
                if j!=curr[z]:
                    m+=1
                z+=1
                z%=3
            ans=min(ans,m)
    print(ans)
",O(n ^ 2)
"import sys
input = sys.stdin.readline
q = int( input() )
rgb = ""RGB""
for _ in range( q ):
    n, k = map( int, input().split() )
    s = input()
    ans = n
    for i in range( 3 ):
        r = [ 0 ]
        l = i
        for c in s:
            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )
            l = ( l + 1 ) % 3
            if len( r ) > k:
                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )
    print( ans )
",O(n)
"import collections



class Solution(object):
    def isPossibleToRearrange(self, s, t, k):
        cnt = collections.defaultdict(int)
        l = len(s)//k
        for i in range(0, len(s), l):
            cnt[s[i:i+l]] += 1
            cnt[t[i:i+l]] -= 1
        return all(v == 0 for v in cnt.values())",O(n)
"from sys import stdin,stdout
from collections import Counter
def ai(): return list(map(int, stdin.readline().split()))
def ei(): return map(int, stdin.readline().split())
def ip(): return  int(stdin.readline().strip())
def op(ans): return stdout.write(str(ans) + '\n')

n = ip()
s = input()
t = input()
value = {}
li = []
res1 = 0
res2 =res3 = -1
for i in range(n):
	if s[i] != t[i]:
		value[t[i]] = i
		res1 += 1
		li.append(i)
p = sq = False
for i in li:
	if s[i] in value:
		p = True
		res2 = i+1
		f = value[s[i]]
		res3 = f+1
		if s[f] == t[i]:
			sq = True
			break
print(res1-(2 if sq else 1 if p else 0))
print(res2,res3)",O(n)
"class Solution(object):
    def numberOfLines(self, widths, S):
        result = [1, 0]
        for c in S:
            w = widths[ord(c)-ord('a')]
            result[1] += w
            if result[1] > 100:
                result[0] += 1
                result[1] = w
        return result",O(n)
"class Solution(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        buckets = [[] for _ in range(len(nums)+1)]
        for i, count in counts.items():
            buckets[count].append(i)

        result = []
        for i in reversed(range(len(buckets))):
            for j in range(len(buckets[i])):
                result.append(buckets[i][j])
                if len(result) == k:
                    return result
        return result",O(n)
"n = int(input())
a = tuple(map(int, input().split()))
if n * 2 > sum(a) + 2:
	print(""NO"")
else:
	n1 = []
	on = []
	for i in range(n):
		if a[i] != 1:
			n1.append(i)
		else:
			on.append(i)
	print(""YES"", len(n1) + min(2, len(on)) - 1)
	print(n - 1)
	n1it = iter(n1)
	next(n1it)
	for v, u in zip(n1, n1it):
		print(v + 1, u + 1)
	if on:
		print(on.pop() + 1, n1[-1] + 1)
	if on:
		print(on.pop() + 1, n1[0] + 1)
	on = iter(on)
	for n11 in n1:
		for i in range(a[n11] - 2):
			try:
				print(n11 + 1, next(on) + 1)
			except StopIteration:
				break
		else:
			continue
		break
",O(n)
"import sys
import math
from itertools import product

n,m,k = [int(i) for i in sys.stdin.readline().split()]

horiz_costs = [[]]*n
vert_costs = [[]]*(n-1)

for i in range(n):
    horiz_costs[i] = [int(i) for i in sys.stdin.readline().split()]
for i in range(n-1):
    vert_costs[i] = [int(i) for i in sys.stdin.readline().split()]

if k%2 == 1:
    for _ in range(n):
        print("" "".join([""-1""]*m))
    quit()

ans = [[[0]*m for _ in range(n)] for _ in range(k//2+1)]

def costs(i,j,ans,time):
    r = []
    if j<m-1:
        r += [2*horiz_costs[i][j] + ans[time-1][i][j+1]]
    if j>0:
        r += [2*horiz_costs[i][j-1] + ans[time-1][i][j-1]]
    if i<n-1:
        r += [2*vert_costs[i][j] + ans[time-1][i+1][j]]
    if i>0:
        r += [2*vert_costs[i-1][j] + ans[time-1][i-1][j]]
    return r

for time in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            cost = costs(i,j,ans, time)
            for c in cost:
                if ans[time][i][j] == 0 or c < ans[time][i][j]:
                    ans[time][i][j] = c

for i in range(n):
    print("" "".join([str(s) for s in ans[-1][i]]))
",O(n ^ 3)
"import itertools



class Solution(object):
    def isAcronym(self, words, s):
        return len(words) == len(s) and all(w[0] == c for w, c in zip(words, s))",O(n)
"import os
import sys
from io import BytesIO, IOBase

mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]

    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]

    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]

    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]

    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z

n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))

col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)

    for item in ans:
        print(*item)

def nouse0():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

def nouse3():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

if __name__ == '__main__':
    main()",O(n ^ 3)
"import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')

INF = 10 ** 18
MOD = 10 ** 9 + 7

def check(x):
    T1 = T[:x] + '*'
    T2 = T[x:] + '*'
    m1 = len(T1)
    m2 = len(T2)

    dp = list2d(N+1, m1, -1)
    dp[0][0] = 0
    for i in range(N):
        s = S[i]
        for j in range(m1):
            k = dp[i][j]
            if k != -1:
                dp[i+1][j] = max(dp[i+1][j], k)
                if T1[j] == s:
                    dp[i+1][j+1] = max(dp[i+1][j+1], k)
                if T2[k] == s:
                    dp[i+1][j] = max(dp[i+1][j], k+1)
    return dp[N][m1-1] == m2-1

for _ in range(INT()):
    S = input()
    T = input()

    N = len(S)
    M = len(T)
    for x in range(M):
        if check(x):
            YES()
            break
    else:
        NO()
",O(n ^ 3)
"import collections


class Solution(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, curr, sum, lookup):
            if root is None:
                return 0
            curr += root.val
            result = lookup[curr-sum] if curr-sum in lookup else 0
            lookup[curr] += 1
            result += pathSumHelper(root.left, curr, sum, lookup) + \
                      pathSumHelper(root.right, curr, sum, lookup)
            lookup[curr] -= 1
            if lookup[curr] == 0:
                del lookup[curr]
            return result

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        return pathSumHelper(root, 0, sum, lookup)",O(n)
"a = input().split()
st = set([])
cnt = [[0 for i in range(9)] for i in range(3)]
for e in a:
    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1
    st.add(e)
answ = len(st) - 1
for i in range(3):
    for j in range(7):
        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))
print(answ)",O(n)
"import sys
input=sys.stdin.readline

from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])

    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0

    print(""YES"")
    print(*res[::-1])

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i

matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True
                else:
                    matches[mt].append(pos[tmp])

if(not chk):
    print(""NO"")
else:
    toposort(matches)
",np
"import math
import sys

n = int(input())
r = 0
t = 1
for i in range(n-1):
    r += t*2
    t += 2
print(r + t)
",O(n)
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

def zeta_super(val, n):

    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",np
"n = int(input())
res = []
multiplier = 1
while n > 1:
	new_n = n // 2
	res.extend((multiplier,)*(n-new_n))
	if n == 3:
		multiplier *= 3
	else:
		multiplier *= 2
	n = new_n
res.extend((multiplier,)*n)
print(*res)
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

p, u = ""Petr"", ""Um_nik""

def main():
    n = N()
    arr = RLL()
    vis = [0]*(n+1)
    dic = {v: i+1 for i, v in enumerate(arr)}

    sm = 0
    for i in range(1, n+1):
        if vis[i]==0:
            now = i
            vis[now] = 1

            while dic[now]!=i:
                sm+=1
                now = dic[now]
                vis[now] = 1
    if (3*n-sm)%2==0:
        print(p)
    else:
        print(u)

if __name__ == ""__main__"":
    main()
",O(nlogn)
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",O(1)
"class Solution(object):
    def numTimesAllBlue(self, light):
        result, right = 0, 0
        for i, num in enumerate(light, 1):
            right = max(right, num)
            result += (right == i)
        return result",O(n)
"import time

(n, k) = (int(i) for i in input().split())

start = time.time()

print((2*n+3-int((9+8*(n+k))**0.5))//2)
finish = time.time()
",O(1)
"
class Solution(object):
    def __init__(self, iterator):
        self.iterator = iterator
        self.val_ = None
        self.has_next_ = iterator.hasNext()
        self.has_peeked_ = False


    def peek(self):
        if not self.has_peeked_:
            self.has_peeked_ = True
            self.val_ = next(self.iterator)
        return self.val_

    def __next__(self):
        self.val_ = self.peek()
        self.has_peeked_ = False
        self.has_next_ = self.iterator.hasNext()
        return self.val_

    def hasNext(self):
        return self.has_next_



",O(1)
"n = int(input())
s = list(input())
t = list(input())

if sorted(t) == sorted(s):
    ans = []
    for i in range(n-1, -1, -1):
        if t[i] != s[i]:
            j = s.index(t[i])
            for k in range(j, i):
                s[k], s[k+1] = s[k+1], s[k]
                ans.append(str(k+1))
    print(len(ans))
    print(' '.join(ans))
else:
    print(-1)
",O(n ^ 2)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):

    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev

    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end

while cur > 0:
    prev = pp[cur]

    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"val=10**9
n,m=map(int,input().split())
arr1=[]
for i in range(n):
    x=int(input())
    arr1.append(x)
arr1.append(val)
arr2=[]
ans=val
finalval=0
arr1.sort()
for i in range(m):
    x1,x2,y=map(int,input().split())
    if(x1==1):
        if(x2==val):
            finalval+=1
        else:
            if(len(arr1)>0 and x2>=arr1[0]):
                arr2.append(x2)
arr2.sort()
i=0
j=0
while(i<len(arr1) and j<len(arr2)):
    if(arr1[i]>arr2[j]):
        j+=1
    elif(arr1[i]==arr2[j]):
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1
    else:
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1

ans=min(i,ans)
print(ans+finalval)
",O(nlogn)
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",O(1)
"def solve(a, b):
    m = len(a)
    n = len(b)
    p_b = [0]
    for x in b[:]:
        p_b.append(p_b[-1] + int(x))
    s = 0
    for i in range(m):
        if a[i] == '0':
            s += p_b[n - m + 1 + i] - p_b[i]
        else:
            s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i])
    return s

a = input()
b = input()
print(solve(a, b))
",O(n)
"n,m = map(int,input().split())
d = {x:0 for x in range(m)}
l = []
for _ in range(n):
    s = input()
    for x in range(m):
        if s[x]== '1': d[x]+=1
    l.append(s)
for x in l:
    t=0
    for y in range(m):
        if x[y] =='1':
            if d[y] ==1:t = 1;break
    if t==0: print('YES');exit()
print('NO')",O(n ^ 2)
"x, y, z, t1, t2, t3 = map(int, input().split())
a=abs(x-y)*t1
b=abs(x-z)*t2+abs(x-y)*t2+3*t3
if b<=a:print(""YES"")
else:print(""NO"")",O(1)
"from sys import stdin
input = stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

l=[]
for i in range(n):
    l.append((arr[i],i))

l.sort(reverse=True)

dp=[]
x=0
for i in range(k):
    dp.append(l[i][1])
    x=x+l[i][0]

print(x)
dp.sort()
dp=[-1]+dp

l=len(dp)
for i in range(1,l-1):
    print(dp[i]-dp[i-1],end="" "")
print(n-1-dp[l-2])",O(nlogn)
"class Solution(object):
    def findAnagrams(self, s, p):
        result = []

        cnts = [0] * 26
        for c in p:
            cnts[ord(c) - ord('a')] += 1

        left, right = 0, 0
        while right < len(s):
            cnts[ord(s[right]) - ord('a')] -= 1
            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:
                cnts[ord(s[left]) - ord('a')] += 1
                left += 1
            if right - left + 1 == len(p):
                result.append(left)
            right += 1

        return result",O(n)
"class Solution2(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return Solution2.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution2(c))
            else:
                node = Solution2(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()",O(n)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        memo = [-1] * len(cost)

        def dfs(i):
            if i >= len(cost):
                return 0
            if memo[i] != -1:
                return memo[i]
            memo[i] = cost[i] + min(dfs(i + 1), dfs(i + 2))
            return memo[i]

        return min(dfs(0), dfs(1))
",O(n)
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf

ri = lambda : map(int, input().split())

def solve():
    n,m = ri()
    A = [[0 for _ in range(m)] for __ in range(n)]
    left = [[0 for _ in range(m)] for __ in range(n)]
    right = [[0 for _ in range(m)] for __ in range(n)]
    up = [[0 for _ in range(m)] for __ in range(n)]
    down = [[0 for _ in range(m)] for __ in range(n)]
    for r in range(n):
        lst = input()
        for c in range(m):
            if lst[c] == '*':
                A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1

    for r in range(n):
        for c in range(1, m):
            if A[r][c]:
                left[r][c] += left[r][c-1]
        for c in range(m-2, -1, -1):
            if A[r][c]:
                right[r][c] += right[r][c+1]

    for c in range(m):
        for r in range(1, n):
            if A[r][c]:
                up[r][c] += up[r-1][c]

        for r in range(n-2, -1, -1):
            if A[r][c]:
                down[r][c] += down[r+1][c]
    res = []
    stars = 0

    ROWS = [[0 for _ in range(m)] for __ in range(n)]
    COLS = [[0 for _ in range(m)] for __ in range(n)]

    for r in range(n):
        for c in range(m):
            if A[r][c]:
                can = min(left[r][c], right[r][c], up[r][c], down[r][c])
                can -= 1
                if can > 0:
                    stars += 1
                    res.append((r+1, c+1, can))
                ROWS[r-can][c] += can
                if r+can+1 < n:
                    ROWS[r+can+1][c] -= can
                COLS[r][c-can] += can
                if c+can+1 < m:
                    COLS[r][c+can+1] -= can

    valid = [[False for _ in range(m)] for __ in range(n)]
    for r in range(n):
        curr = 0
        for c in range(m):
            curr += COLS[r][c]
            if curr > 0:
                valid[r][c] = True

    for c in range(m):
        curr = 0
        for r in range(n):
            curr += ROWS[r][c]
            if curr > 0:
                valid[r][c] = True

    for r in range(n):
        for c in range(m):
            if A[r][c] and not valid[r][c]:
                print(-1)
                return
    print(stars)
    for x,y,z in res:
        print(x,y,z)
t = 1

while t:
    t -= 1
    solve()
",O(n ^ 2)
"n = int(input())
lis = list(map(int, input(). split()))
sor = sorted(lis)
cnt = 0
for i in range(n):
    if lis[i] != sor[i]:
        cnt += 1
if cnt > 2:
    print(""NO"")
else:
    print(""YES"")",O(nlogn)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(x < k for x in nums)
",O(n)
"def solve():
    k = [int(x) for x in input().split(' ')]
    k.sort()
    if min(k) == 1:
        return ""YES""
    elif k.count(2) >= 2:
        return ""YES""
    elif k.count(3) == 3:
        return ""YES""
    elif k == [2, 4, 4]:
        return ""YES""
    return ""NO""

print(solve())",O(1)
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])",O(n ^ 2)
"n = int(input())
m = int(input())

print(m % pow(2, n))
",O(1)
"n, k = map(int, input().split())

if n == 1:
    print(0)
elif k + (k - 1) * (k - 2) // 2 < n:
    print(-1)
else:
    l = 0
    r = k - 1
    while r - l > 1:
        m = (l + r) // 2
        if  (2*k - m + 1) * m // 2 - (m - 1) >= n:
            r = m
        else:
            l = m
    print(r)
",O(logn)
"a,b= map(int, input().split())

c=2*(a-1)-b*(b-1)
if c > 0:
    print(-1)
else:
    d = int((1 + (1 - 4 * c) ** 0.5) / 2)
    if d * (d - 1) + c > 0:
        d -= 1

    print(b -d)",O(logn)
"import pandas as pd



def Solution(animals: pd.DataFrame) -> pd.DataFrame:
     return animals[animals['weight'] > 100].sort_values(by=""weight"", ascending=False)[['name']]",O(nlogn)
"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())))
s = sorted(list(map(int, input().split())))
if a[-1] > s[0]:
    print(-1)
else:
    if a[-1] == s[0]:
        print(sum(a[:-1])*m+sum(s))
    else:
        print(sum(a[:-2])*m+a[-2]*(m-1)+sum(s)+a[-1])
",O(nlogn)
"class Solution2(object):
    def flipEquiv(self, root1, root2):
        stk1, stk2 = [root1], [root2]
        while stk1 and stk2:
            node1, node2 = stk1.pop(), stk2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                stk1.extend([node1.right, node1.left])
            else:
                stk1.extend([node1.left, node1.right])
            stk2.extend([node2.left, node2.right])
        return not stk1 and not stk2",O(n)
"class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result",O(n)
"def x(a,b):
    if(a>b):
        return(1)
    else:
        return(0)
n=int(input())
a1,a2=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
if((a1-a2)==(b1-b2)):
    print(""NO"")
elif((a1+a2)==(b1+b2)):
    print(""NO"")
elif(a1==b1):
    print(""NO"")
elif(a2==b2):
    print(""NO"")
elif((a1-a2)==(c1-c2)):
    print(""NO"")
elif((a1+a2)==(c1+c2)):
    print(""NO"")
elif(a1==c1):
    print(""NO"")
elif(a2==c2):
    print(""NO"")
else:
    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):
        print(""YES"")
    else:
        print(""NO"")",O(1)
"n,k = map(int,input().split())
a = list(map(int,input().split()))

count = 0
b = {}
for i in range(n):
    if a[i] in b:
        b[a[i]] += 1
    else:
        b[a[i]] =1
    if b[a[i]] == 1:
        count += 1
    if count == k:
        break

for j in range(n):
  if a[j] in b:
    b[a[j]] -= 1

  if b[a[j]] == 0:
    break

if count != k:
    print(""-1 -1"")
else:
  if n == 1:
    print(1,1)
  elif n == 2 and count == 2:
    print(1,2)
  else:
    print(j+1,i+1)",O(n)
"class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",O(n)
"rr = lambda: input().rstrip()
rri = lambda: int(rr())
rrm = lambda: list(map(int, rr().split()))

from functools import lru_cache;memo=lru_cache(None)
from sys import setrecursionlimit as srl;srl(10**5)

def solve(N, A):
    @memo
    def dp(i, j, left=0):
        if i == j:
            if left == 0:
                return 1
            if A[i] == left:
                return 1
            return 2
        if i > j:
            return 0 if left == 0 else 1

        ans = 1 + dp(i+1, j, A[i])
        if left >= 1:
            stack = []
            for k in range(i, j+1):
                stack.append(A[k])

                while len(stack) >= 2 and stack[-1] == stack[-2]:
                    stack.pop()
                    stack[-1] += 1
                if len(stack) == 1 and left == stack[-1]:
                    cand = dp(k+1, j, left+1)
                    if cand < ans:
                        ans = cand
        return ans

    return dp(1, N-1, A[0])

print(solve(rri(), rrm()))
",O(n ^ 3)
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",O(logn)
"class Solution(object):
    def longestSquareStreak(self, nums):
        sorted_nums = sorted(set(nums))
        squares = {x for x in sorted_nums if x%2 < 2} 
        result = 0
        for x in sorted_nums:
            square, cnt = x**2, 1
            while square in squares:
                squares.remove(square)
                cnt += 1
                square *= square
            result = max(result, cnt)
        return result if result != 1 else -1",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
for t in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    l1=dd(int)
    a=0
    for j in l:
        l1[j]+=1
        if l1[j]==4:
            a=j
    if a:
        print(a,a,a,a)
    else:
        c=0
        x=0
        l2=[]
        for j in l1:
            if l1[j]>=2:
                l2.append(j)
        l2.sort()
        for j in l2:
                c+=1
                if c==1:
                    a=j
                elif c==2:
                    b=j
                else:
                    if x/j+j/x<a/b+b/a:
                        a,b=x,j
                x=j
        print(a,a,b,b)
",O(nlogn)
"import collections



class Solution(object):
    def findHighAccessEmployees(self, access_times):
        LIMIT_COUNT = 2
        LIMIT_MINUTE = 60
        def to_minute(x):
            return int(x[:2])*60+int(x[2:])
    
        lookup = collections.defaultdict(list)
        for x, t in access_times:
            lookup[x].append(to_minute(t))
        result = []
        for x, ts in lookup.items():
            ts.sort()
            if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in range(len(ts)-LIMIT_COUNT)):
                result.append(x)
        return result",O(nlogn)
"t=int(input())
k=set()
for i in range(1,10**5):
  k.add(4*i*i)
  k.add(2*i*i)
for _ in range(t):
  n=int(input())
  if n in k:
    print('YES')
  else:
    print('NO')",O(1)
"k1, k2, k3  = sorted(map(int, input().split()))

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",O(1)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

def get_ans(x):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo)
    print(""{} {}"".format(i+1,j+1))
",np
"import heapq
n,k = map(int,input().split())
P = list(map(int,input().split()))
C = list(map(int,input().split()))
X = []
for i in range(n):
    X.append([P[i],C[i],i])
X.sort(key = lambda x : x[0])
coins = []
heapq.heapify(coins)
curr = 0
res = [0 for i in range(n)]
for i in range(k):
    heapq.heappush(coins,X[i][1])
    curr += X[i][1]
    res[X[i][2]] = curr
for j in range(k,n):

    res[X[j][2]] = X[j][1] + sum(coins)
    if len(coins)>0:
        x = heapq.heappop(coins)
        if x < X[j][1]:
            heapq.heappush(coins,X[j][1])
        else:
            heapq.heappush(coins,x)

print(*res)",O(nlogn)
"import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result",O(n)
"class Solution2(object):
    def isNumber(self, s):
        import re
        return bool(re.match(""^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$"", s))",O(n)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    if v in powers:
        continue

    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np
"from math import factorial,pow
s1=list(input())
s2=list(input())
S1={""+"":0, ""-"":0}
S2={""+"":0, ""-"":0, ""?"":0}
for i in s1:
    S1[i]+=1
for i in s2:
    S2[i]+=1
if S1[""+""]-S2[""+""]>=0 and S1[""-""]-S2[""-""]>=0:
    pos=S1[""+""]-S2[""+""]
    neg=S1[""-""]-S2[""-""]
    ques=S2[""?""]
    res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques)
    print(""%.12f""%res)
else:
    print(""%.12f"" % 0)",np
"k = int(input())
s = k
i = 1
number_digits = 1
while s - (i * (9 * 10 ** (i - 1))) > 0:
    number_digits = number_digits + 1
    s = s - (i * (9 * 10 ** (i - 1)))
    i += 1
v = (s - 1) // number_digits
s = s - v * number_digits
ans = 10 ** (number_digits - 1) + v
ans = str(ans)
fans = ans[s - 1]
print(fans)
",O(logn)
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other):
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)

		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)

for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]

	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",O(n ^ 3)
"n = int(input())-1
x = 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = 10 ** (x - 1)
a += n // x
print(str(a)[n % x])",O(logn)
"t = int(input())

def sol(n, k):
    p = 1
    q = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += q*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
        q = 2*q+3
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",O(logn)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())

        y = 0
        for _ in range(m):
            x, d = map(int, input().strip().split())
            if d >= 0:
                y += d * (n - 1) * n // 2
            else:
                if n % 2 != 0:
                    l = (n - 1) // 2
                    y += d * l * (l + 1)
                else:
                    l = n // 2
                    y += d * (l * (l + 1) - l)
            y += x * n
        y /= n
        print(f'{y:.9f}')

solver()()",O(n)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

MOD = 998244353

N,K = ilele()
if K == 1 or K == 2*N:
    print(2)
    exit(0)
dp = list3d(N+1,4,K+1,0)
dp[1][0][1] = 1
dp[1][3][1] = 1
dp[1][1][2] = 1
dp[1][2][2] = 1

for n in range(2,N+1):
    for k in range(1,K+1):
        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD
        if k > 1:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        else:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD

print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)
",np
"import sys

def main():
    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u - v) ** 2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x & val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i + 1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0] + [1e8] * (1 << N)
    pres = [None] * (1 << N)
    allb = (1 << N) - 1
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                             + alld[p[0]][0] \
                             + alld[p[1]][0]

    for stt in range(1 << N):
        if stt not in vis:
            continue

        bits = getBits(~stt & allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit] + 1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

main()
",np
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",O(n ^ 2)
"class Solution(object):
    def threeConsecutiveOdds(self, arr):
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False",O(n)
"n = int(input())
a = list(map(int, input().split()))

mex = -1
for i in range(n):
    if a[i] <= mex:
        continue
    elif a[i] == mex + 1:
        mex += 1
    else:
        print(i+1)
        exit()
print(-1)",O(n)
"class Solution(object):
    def maxMatrixSum(self, matrix):
        abs_total = sum(abs(x) for row in matrix for x in row)
        min_abs_val = min(abs(x) for row in matrix for x in row)
        neg_cnt = sum(x < 0 for row in matrix for x in row)
        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val",O(n ^ 2)
"def search(arr,power):
    lo=0
    hi=len(arr)-1
    ans=-1
    while lo<=hi:
        mid=(lo+hi)//2
        if arr[mid]<=power:
            ans=mid
            lo=mid+1
        else:
            hi=mid-1
    return ans

n,q = list(map(int, input().split()))
a = list(map(int, input().split()))
k = list(map(int, input().split()))
for i in range(1,n):
    a[i]+=a[i-1]
power = 0
for i in range(q):
    power+=k[i]
    pos = search(a,power)
    if pos==n-1:
        print(n)
        power=0
    elif pos==-1:
        print(n)
    else:
        print(n-pos-1)",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def swapNodes(self, head, k):
        left, right, curr = None, None, head
        while curr:
            k -= 1
            if right:
                right = right.__next__
            if k == 0:
                left = curr
                right = head
            curr = curr.__next__
        left.val, right.val = right.val, left.val
        return head",O(n)
"from collections import deque
from copy import deepcopy

m,n,k  = map(int,input().split())

horizon = []
for i in range(m):
    horizon.append( list(map(int,input().split()))  )

vertical = []
for i in range(m-1):
    vertical.append( list(map(int,input().split()))  )

if k%2==1:
    ans = [-1]*n
    for i in range(m):
        print("" "".join(map(str,ans)))
    exit()

direc = [[0,-1],[0,1],[1,0],[-1,0]]

ans = [[0 for j in range(n)] for i in range(m)]

for t in range(k//2):
    tempans = deepcopy(ans)

    for i in range(m):
        for j in range(n):
            ans[i][j] = 2147483647
            for d in range(4):
                neighi = i + direc[d][0]
                neighj = j + direc[d][1]
                if neighi<0 or neighi>=m or neighj<0 or neighj>=n: continue
                base = tempans[neighi][neighj]
                if d==0: base += 2 * horizon[neighi][neighj]
                if d==1: base += 2 * horizon[neighi][neighj-1]
                if d==2: base += 2 * vertical[neighi-1][neighj]
                if d==3: base += 2 * vertical[neighi][neighj]
                ans[i][j] = min(ans[i][j],base)

for ele in ans:
    print("" "".join(map(str,ele)))
",O(n ^ 3)
"def solution(n, k):
    ret = [['.' for _ in range(n)] for _ in range(4)]
    if 1 == k & 1:
        ret[1][n >> 1] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[1][n - 1 - i] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[2][i] = '
            ret[2][n - 1 - i] = '
    else:
        for i in range(1, n - 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[2][i] = '

    print('YES')
    for i in range(4):
        print(''.join(ret[i]))

solution(*map(int, input().split()))
",O(n)
"n=int(input())
l1=list(map(int,input().split()))
if len(list(set(l1)))==1 and l1[0]>0:
    print(1)
else:
    l2=list(set(l1))
    x=l1.count(0)
    if x==0:
        print(len(l2))
    else:
        print(len(l2)-1)
",O(n)
"class Solution2(object):
    def largestSquareArea(self, bottomLeft, topRight):
        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in range(len(bottomLeft)) for j in range(i+1, len(bottomLeft))), 0)**2",O(n ^ 2)
"import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):
        parse = re.findall(r""([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)"", formula)
        stk = [collections.Counter()]
        for name, m1, left_open, right_open, m2 in parse:
            if name:
              stk[-1][name] += int(m1 or 1)
            if left_open:
              stk.append(collections.Counter())
            if right_open:
                top = stk.pop()
                for k, v in top.items():
                  stk[-1][k] += v * int(m2 or 1)

        return """".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \
                       for name in sorted(stk[-1]))",O(n)
"import collections
from functools import reduce



class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        MOD = 10**9+7
        dp = collections.defaultdict(int)
        cnt = collections.defaultdict(int)
        for x in nums:
            c = cnt[x-1]+cnt[x+1]+1
            cnt[x] = (cnt[x]+c)%MOD
            dp[x] = (dp[x]+(dp[x-1]+dp[x+1]+x*c))%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, iter(dp.values()))",O(n)
"n = int(input())
a = list(map(int, input()))
b = list(map(int, input()))

ans = sum(q != w for q, w in zip(a, b))
i = 1
while i < n:
    aii = a[i - 1]
    ai = a[i]
    bii = b[i - 1]
    bi = b[i]
    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:
        ans -= 1
        i += 1
    i += 1

print(ans)
",O(n)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict

n,m = [int(i) for i in input().split()]
a = []
mi = -1
ma = 10**9
for i in range (n):
    a.append([int(j) for j in input().split()])

ans = []
while(mi<ma):
    mid = (mi+ma+1)//2
    masks = {}
    for i in range (n):
        currMask = 0
        for j in range (m):
            if a[i][j] >= mid:
                currMask +=  1<<j
        masks[currMask] = i
    req = (1<<m) - 1
    possible = 0
    for i in masks:
        for j in masks:
            if i|j == req:
                possible = 1
                ans = [masks[i]+1,masks[j]+1]
                break
        if possible:
            break
    if possible:
        mi = mid
    else:
        ma = mid - 1
print(*ans)",np
"class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]",O(n)
"import itertools



class Solution(object):
    def minimumTime(self, jobs, workers):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        jobs.sort()
        workers.sort()
        return max(ceil_divide(j, w) for j, w in zip(jobs, workers))",O(nlogn)
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",np
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            m = (l + r) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m

        pivot = l
        l, r = 0, len(nums) - 1

        if target >= nums[pivot] and target <= nums[r]:
            l = pivot
        else:
            r = pivot - 1

        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return m
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1

        return -1
",O(logn)
"import math
n=int(input())
if n==1:
	print(1)
	exit()
a=[]
for i in range(1,n+1,2):
	a.append(1)
b=[]
for i in range(2,n+1,2):
	b.append(i)
p=len(b)
k=2

while p>0:
	c=[]

	for i in range(p):
		if b[i]%k==0 and b[i]%(k*2)!=0:

			a.append(k)
			p-=1

		else:
			c.append(b[i])
	b=c[:]
	k=k*2

p=a[-1]//2
a.pop()
q=p
for i in range(p,n+1):
	if i%p==0 and i>q:
		q=i
a.append(q)

for i in a:
	print(i,end="" "")
",O(nlogn)
"class Solution(object):
    def largestSubarray(self, nums, k):
        left, right, l = 0, 1, 0
        while right+k-1 < len(nums) and right+l < len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] > nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]",O(n)
"class Solution2(object):
    def fib(self, N):
        prev, current = 0, 1
        for i in range(N):
            prev, current = current, prev + current,
        return prev",O(n)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else:
    print(0)",O(1)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n = mint()
a = [0]*n
dp = [0]*n
for i in range(n):
	a[i] = tuple(mints())
a.sort()
for i in range(n):
	x, p = a[i]
	l = -1
	r = n
	v = x-p
	while r-l > 1:
		c = (l + r)//2
		if a[c][0] >= v:
			r = c
		else:
			l = c
		if l == -1:
			dp[i] = i-l-1
		else:
			dp[i] = i-l-1+dp[l]

z = 1e9
for i in range(n):
	z = min(z,dp[i]+n-i-1)
print(z)",O(n)
"class Solution(object):
    def isTransformable(self, s, t):
        idxs = [[] for _ in range(10)]
        for i in reversed(range(len(s))):
            idxs[int(s[i])].append(i)
        for c in t:
            d = int(c)
            if not idxs[d]:
                return False
            for k in range(d): 
                if idxs[k] and idxs[k][-1] < idxs[d][-1]:
                    return False
            idxs[d].pop()
        return True",O(n)
"def naiveSolve():

    return

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class OrderedList(SortedList):
    def __init__(self, arg):
        super().__init__(arg)
    def rangeCountByValue(self, leftVal, rightVal):
        leftCummulative = self.bisect_left(leftVal)
        rightCummulative = self.bisect_left(rightVal + 1)
        return rightCummulative - leftCummulative

from collections import Counter

def main():

    n=int(input())
    a=readIntArr()

    cnts=Counter(a)
    ol=OrderedList([v for v in cnts.values()])
    ol.add(0)
    canMakeFirstMove=False
    for x in a:
        if x>0:
            c=cnts[x]
            ol.remove(c)
            ol.add(c-1)
            d=cnts[x-1]
            ol.remove(d)
            ol.add(d+1)

            if ol[-1]==1:
                canMakeFirstMove=True
                break
            ol.add(c)
            ol.remove(c-1)
            ol.add(d)
            ol.remove(d+1)
    if canMakeFirstMove==False:
        print('cslnb')
    else:

        target=(n*(n-1))//2
        if (sum(a)-target)%2==0:
            print('cslnb')
        else:
            print('sjfnb')

    return

import sys

input=lambda: sys.stdin.readline().rstrip(""\r\n"")

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(l,r):
    print('? {} {}'.format(l,r))
    sys.stdout.flush()
    return int(input())

def answerInteractive(x):
    print('! {}'.format(x))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()
",O(nlogn)
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()

		if s1[-1] - s1[0] >= d:

			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):

			if suma_o_resta(x, i) > 0:

				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))
",np
"from math import sin, pi
n, r = map(int, input().split())

def p(n, r):
    return 2 * n * r * sin(pi / n)

le = 0; ri = r * 1000
while ri - le > 1e-9:
    m = (ri + le) / 2
    if p(n, r + m) < n * m * 2:
        ri = m
    else:
        le = m
print(m)",O(1)
"a = [0 for i in range(0, 256)]
n,k = input().split(' ')
k = int(k)
for c in input().split(' '):
        c = int(c)
        if a[c] != 0:
            print(a[c]-1, end=' ')
        else:
            for x in range(c, c-k, -1):
                if a[x] == 0:
                    i = x
                else:
                    if c-a[x]+1<k:
                        i = a[x]-1
                    break
                if x == 0:
                    break
            for x in range(int(i), c+1):
                a[x] = i + 1
            print(i, end=' ')
",O(n ^ 2)
"import os, sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x - 1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k == 0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10 ** 9 + 7
    dp = [0] * (x + 1)
    dp[1] = 1
    for i in range(2, x + 1):
        dp[i] = dp[bit_count(i)] + 1
    dp1 = [[0] * (x + 1) for _ in range(x + 1)]

    for i in range(x + 1):
        dp1[i][0] = 1
    for i in range(1, x + 1):
        for j in range(1, i + 1):
            dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod
    ans = 0
    cou = n.count('1')
    for i in range(1, x + 1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans + 1) % mod
    print(ans)
main()",O(n)
"import sys
input=sys.stdin.readline
def getsum(BITTree,i):
    i=i+1
    s = 0
    while i > 0:
        s += BITTree[i]
        i -= i & (-i)
    return(s)
def updatebit(BITTree , n , i ,v):
    i=i+1
    while i <= n:
        BITTree[i] += v
        i += i & (-i)

n=int(input())
lista=[int(i) for i in input().split()]
invercount=0
bitTree=[0]*(n+2)
for k in reversed(lista):
        updatebit(bitTree,n+1,k,1)
        counter=getsum(bitTree,k-1)
        invercount+=counter
m=int(input())
for i in range(m):
    l,r=map(int,input().split())
    summa=((r-l+1)*(r-l))/2
    if (invercount+summa)%2:
        print('odd')
        invercount=1
    else:
        print('even')
        invercount=0
",O(n ^ 2)
"class Solution(object):
    def maximumPoints(self, enemyEnergies, currentEnergy):
        mn = min(enemyEnergies)
        return ((currentEnergy-mn)+sum(enemyEnergies))//mn if currentEnergy >= mn else 0",O(n)
"from math import factorial
s=input().rstrip()
s1=input().rstrip()
pos1=0
pos=0
posi=0
negi=0
posi1=0
negi1=0
ques1=0
for i in s:
    if i=='+':
        pos+=1
        posi+=1

    else:
        pos-=1
        negi+=1
for i in s1:
    if i=='+':
        posi1+=1
    elif i=='-':
        negi1+=1
    else:
        ques1+=1
if posi==posi1 and negi==negi1:
    print(1)
    exit()
diff1=posi-posi1
diff=negi-negi1
if diff<0  or diff1<0:
    print(0)
else:
    outcomes=2**ques1
    nume=factorial(ques1)
    deno=factorial(ques1-diff1)*factorial(diff1)
    fav1=nume/deno
    ques1=ques1-diff1
    num1=factorial(ques1)
    deno1=factorial(ques1-diff)*factorial(diff)
    fav2=num1/deno1
    ans=fav1*fav2
    print(ans/outcomes)
",np
"import sys
from itertools import accumulate

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10 ** 9 + 7

def build_grid(H, W, intv, _type, space=True, padding=False):
    if space:
        _input = lambda: input().split()
    else:
        _input = lambda: input()
    _list = lambda: list(map(_type, _input()))
    if padding:
        offset = 1
    else:
        offset = 0
    grid = list2d(H+offset*2, W+offset*2, intv)
    for i in range(offset, H+offset):
        row = _list()
        for j in range(offset, W+offset):
            grid[i][j] = row[j-offset]
    return grid

H, W = MAP()
grid = build_grid(H, W, '

ans = []
imosw = list2d(H+2, W+2, 0)
imosh = list2d(H+2, W+2, 0)
def check(i, j):
    sz = min(L[i][j], R[i][j], U[i][j], D[i][j])
    if sz > 1:
        imosw[i][j-sz+1] += 1
        imosw[i][j+sz] -= 1
        imosh[i-sz+1][j] += 1
        imosh[i+sz][j] -= 1
        ans.append((i, j, sz-1))

def check2():
    for i in range(1, H+1):
        for j in range(1, W+1):
            if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]:
                return False
    return True

L = list2d(H+2, W+2, 0)
R = list2d(H+2, W+2, 0)
U = list2d(H+2, W+2, 0)
D = list2d(H+2, W+2, 0)
for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '.':
            L[i][j] = 0
        else:
            L[i][j] = L[i][j-1] + 1
for i in range(1, H+1):
    for j in range(W, 0, -1):
        if grid[i][j] == '.':
            R[i][j] = 0
        else:
            R[i][j] = R[i][j+1] + 1
for j in range(1, W+1):
    for i in range(1, H+1):
        if grid[i][j] == '.':
            U[i][j] = 0
        else:
            U[i][j] = U[i-1][j] + 1
for j in range(1, W+1):
    for i in range(H, 0, -1):
        if grid[i][j] == '.':
            D[i][j] = 0
        else:
            D[i][j] = D[i+1][j] + 1

for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '*':
            check(i, j)
for i in range(1, H+1):
    for j in range(W+1):
        imosw[i][j+1] += imosw[i][j]
for j in range(1, W+1):
    for i in range(H+1):
        imosh[i+1][j] += imosh[i][j]

if check2():
    print(len(ans))
    [print(h, w, sz) for h, w, sz in ans]
else:
    print(-1)
",O(n ^ 2)
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
n = int(input())
a = []
for i in range(n):
    a.append(input())
print(6-len(a))
for i in dic:
    if i not in a:
        print(dic[i])",O(1)
"def push(d, u, v):
    if u not in d:
        d[u] = []
    if v not in d:
        d[v] = []
    d[u].append(v)
    d[v].append(u)

def push_v(d, u, val):
    if u not in d:
        d[u] = 0
    d[u] += val

n, k = map(int, input().split())
g    = {}

for _ in  range(n-1):
    u, v = map(int, input().split())
    push(g, u, v)

deg1 = []
used = [0] * (n+1)

for u in g:
    if len(g[u]) == 1:
        used[u]  = 1
        deg1.append(u)

flg = True
while k > 0:
    if k >= 1 and len(deg1) < 3:
        flg=False
        break

    cnt = {}
    for u in deg1:
        for v in g[u]:
            if used[v] == 0:
                push_v(cnt, v, 1)

    for v in deg1:
        used[v] = 1

    deg1 = []

    for v, val in cnt.items():
        if val < 3:
            flg=False
            break
        deg1.append(v)

    if flg==False:
        break
    k-=1

if flg==True and len(deg1) > 1:
    flg=False

if flg==False:
    print('NO')
else:
    print('YES')
",O(nlogn)
"n = int(input())
ans = 1
for i in range(1, n):
    ans += i * 4
print(ans)",O(n)
"n=int(input())
s=(input())
L=s.split("" "")
L=list(set(L))
for i in range(len(L)):
    L[i]=int(L[i])
L=sorted(L)
if len(L)==1:
    print(""NO"")
else:
    print(L[1])
",O(nlogn)
"def main():
    q = int(input())
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        for i in range(n - k + 1):
            count1 = 0
            count2 = 0
            count3 = 0
            for j in range(k):
                if (i + j) % 3 == 0:
                    if s[i + j] != ""R"":
                        count1 += 1
                    if s[i + j] != ""G"":
                        count2 += 1
                    if s[i + j] != ""B"":
                        count3 += 1
                if (i + j) % 3 == 1:
                    if s[i + j] != ""G"":
                        count1 += 1
                    if s[i + j] != ""B"":
                        count2 += 1
                    if s[i + j] != ""R"":
                        count3 += 1
                if (i + j) % 3 == 2:
                    if s[i + j] != ""B"":
                        count1 += 1
                    if s[i + j] != ""R"":
                        count2 += 1
                    if s[i + j] != ""G"":
                        count3 += 1
            min_ans = min(min_ans, count1, count2, count3)
        print(min_ans)
main()",O(n ^ 2)
"grid = list(map(int,input().split()))
max_res = 0
for i in range(14):
    g_c = grid.copy()
    Amount = g_c[i]//14
    Amount_r = g_c[i]%14
    if(Amount > 0):
        for j in range(14):
            if i != (i+j+1)%14:
                g_c[(i+j+1)%14]+=Amount
                g_c[i]-=Amount
    if Amount_r > 0:
        for j in range(14):
            if Amount_r > 0:
                if i != (i+j+1)%14:
                    g_c[(i+j+1)%14]+=1
                    Amount_r-=1
                    g_c[i]-=1
            else:
                break

    res = 0
    for i in range(14):
        if g_c[i] % 2 ==0:
            res+=g_c[i]

    max_res = max(max_res,res)

print(max_res)
",O(1)
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(2 * x % mod)
    quit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"n, k = map(int,input().split())
s = input()
p = len(s)-1
while s[:p] != s[-p:]:
    p =  p -1
print(s + s[p:]*(k-1))",O(n ^ 2)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        q1 = deque([p])
        q2 = deque([q])

        while q1 and q2:
            for _ in range(len(q1)):
                nodeP = q1.popleft()
                nodeQ = q2.popleft()

                if nodeP is None and nodeQ is None:
                    continue
                if nodeP is None or nodeQ is None or nodeP.val != nodeQ.val:
                    return False

                q1.append(nodeP.left)
                q1.append(nodeP.right)
                q2.append(nodeQ.left)
                q2.append(nodeQ.right)

        return True
",O(n)
"n, u = map(int, input().split())
e = list(map(int, input().split()))
ans = -1
k = 2
for i in range(n-2):
    while k<n-1 and e[k+1] - e[i] <= u:
        k+=1
    if i < k-1 and e[k] - e[i] <= u:
        ans = max(ans,(e[k]-e[i+1]) / (e[k]-e[i]))
print(ans)",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def equationsPossible(self, equations):
        union_find = UnionFind(26)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '=':
                union_find.union_set(x, y)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if union_find.find_set(x) == union_find.find_set(y):
                    return False
        return True",O(n)
"n, m, k, l = map(int, input().split())
need = k + l
if need % m == 0 and need <= n:
    print(need // m)
else:
    x = need // m + 1
    if x * m > n:
        print(-1)
    else:
        print(x)",O(1)
"class Solution(object):
    def isPrefixString(self, s, words):
        i = j = 0
        for c in s:
            if i == len(words) or words[i][j] != c:
                return False 
            j += 1
            if j == len(words[i]):
                i += 1
                j = 0
        return j == 0",O(n)
"import sys

import random

n = int(input())
if n<=3:
    print('YES')
    sys.exit()
coord = [int(x) for line in sys.stdin for x in line.split()]

X = [coord[2*i] for i in range(n)]
Y = [coord[2*i+1] for i in range(n)]

for i in range(13):
    a = random.randint(0,n-1)
    b = random.randint(0,n-2)

    if a==b:
        b+=1

    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    not_on_line = []
    for c in range(n):
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            not_on_line.append(c)
    if len(not_on_line)<=1:
        print('YES')
        sys.exit()

    a = not_on_line[0]
    b = not_on_line[1]
    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    can = True
    for c in not_on_line:
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            can = False
            break
    if can:
        print('YES')
        sys.exit()
print('NO')",O(nlogn)
"def my_solve(n, m, graph, mask):
	if do_dfs_bool(n,graph,mask.copy()):
		c = get_cyclic(n, graph, mask)
		for u,v in c:
			graph[u].remove(v)
			if not do_dfs_bool(n,graph,mask.copy()):
				return 'YES'
			graph[u].append(v)
		return ""NO""
	return ""YES""

def get_cyclic(n, graph, mask):
	c,v = do_dfs(n,graph,mask)
	path = []
	i = 0
	begin = False
	if c:
		for u in c.keys():
			if c[u] == v:
				begin = True
				path.append((c[u],u))
			elif begin:
				path.append((c[u],u))
		tmp = list(c.keys())
		if len(tmp):
			path.append((tmp[-1],v))
	return path

def do_dfs_bool(n, graph, mask):
	colors = [0]*(n+5)
	for u in graph.keys():
		if not u in mask.keys():
			if dfs_bool(u,graph,mask,colors):
				return True
	return False

def dfs_bool(u, graph, mask,colors):
	colors[u] = 1
	mask[u] = True
	for v in graph[u]:
		if colors[v] == 1:
			return True
		if colors[v] == 0:
			if dfs_bool(v,graph,mask,colors):
				return True
	colors[u] = 2
	return False

def do_dfs(n, graph, mask):
	colors = [0]*(n+5)
	c = {}
	for u in graph.keys():
		if not u in mask.keys():
			c = {}
			p, v = dfs(u,graph,mask,c,colors)
			if p and v:
				return (p,v)

def dfs(u, graph, mask, c, colors):
	colors[u] = 1
	for v in graph[u]:
		if colors[v] == 1:
			return (c, v)
		if colors[v] == 0:
			c[v] = u
			p,w = dfs(v,graph,mask,c,colors)
			if w:
				return (p,w)
	colors[u] = 2
	if len(c) > 0:
		if u in c.keys():
			del c[u]
	return (c, None)

def test(n, m, edges):
	graph = {}
	mask = {}
	for u,v in edges:
		if u not in graph.keys():
			graph[u] = []
		graph[u].append(v)
		if v not in graph.keys():
			graph[v] = []
	return my_solve(n, m, graph, mask)

if __name__ == '__main__':
	n,m = [int(x) for x in input().split()]
	edges = []
	for i in range(0,m):
		u,v = [int(x) for x in input().split()]
		edges.append((u,v))
	print(test(n, m, edges))",O(n ^ 2)
"a=int(input())
l=[]
total=0
for i in range(4):
    line=''

    for x in [0]*a:
        line+=input()
    l.append(line)
    input() if i!=3 else 0
l=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1]
for z,v in enumerate(l):
    if z<2:
        for i in range(a**2):
            total += v[i]!='0' if i%2 else v[i]!='1'
    else:
        for i in range(a**2):
            total += v[i]!='1' if i%2 else v[i]!='0'
print(total)",O(n ^ 2)
"import sys
from collections import defaultdict

readline=sys.stdin.readline

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",O(n ^ 3)
"actual = input()
processed = input()

def factorial(num: int):
    res = 1
    while num >= 1:
        res *= num
        num -= 1
    return res

actualPos = actual.count('+')
actualNeg = actual.count('-')
processedPos = processed.count('+')
processedNeg = processed.count('-')

if processedPos > actualPos or processedNeg > actualNeg:
    print(0)
elif processedPos == actualPos and processedNeg == actualNeg:
    print(1)
else:
    remainPos = actualPos - processedPos
    remainNeg = actualNeg - processedNeg

    print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** (
            remainPos + remainNeg))
",np
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):
        result = [None]
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret[0] = Node(node.val)
                for child in reversed(node.children):
                    ret1 = [None]
                    stk.append((2, (ret1, ret)))
                    stk.append((1, (child, ret1)))
            else:
                ret1, ret = params
                ret[0].children.append(ret1[0])
        return result[0]",O(n)
"import math
a=input()
b=input()
i=a.count('+')
j=a.count('-')
k=b.count('+')
l=b.count('-')
m=b.count('?')
c1=(i-j)
c2=(k-l)
c=abs(c1-c2)
w=m-c
x=w//2
y=w//2+c
if(c==0 and m==0):
    print(1)
elif((c)>m):
    print(0)
else:
    x=math.factorial(m)//(math.factorial(x)*math.factorial(y))
    print(x/pow(2,m))
",np
"n=int(input())
ns=[]
for i in range(n):
    s=input()
    ns.append(s)
ns2=[]
for i in range(n):
    s=input()
    ns2.append(s)

def rotate(i,j):
    return j,n-1-i
def flip(i,j):
    return j,i

def main():
    same=True
    for i in range(n):
        for j in range(n):
            if ns[i][j]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a,b=flip(i,j)
            if ns[a][b]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True
    else:
        return False

if main():
    print('Yes')
else:
    print('No')
",O(n ^ 2)
"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
max_el = -1;
er = -1;
for i in range(len(a)):
    if a[i] - max_el > 1:
        er = i + 1;
        break
    if a[i] > max_el:
        max_el = a[i]

print(er)
",O(n)
"class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)",O(n)
"import collections



class Solution(object):
    def mostFrequentEven(self, nums):
        cnt = collections.Counter(x for x in nums if x%2 == 0)
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], -x)) if cnt else -1",O(n)
"def main():
    n, m = map(int, input().split())
    ll = [c == '*' for _ in range(n) for c in input()]
    nm = n * m
    RLUD = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    cc = [1000] * nm
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if ll[i]:
                    v += 1
                    if cc[i] > v:
                        cc[i] = v
                else:
                    v = cc[i] = 0
        if f:
            ll.reverse()
            cc.reverse()
    cc = [c if c != 1 else 0 for c in cc]
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if v > cc[i]:
                    v -= 1
                else:
                    v = cc[i]
                if v:
                    ll[i] = False
        if f:
            ll.reverse()
            cc.reverse()
    if any(ll):
        print(-1)
    else:
        res = []
        for i, c in enumerate(cc):
            if c:
                res.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(res), '\n'.join(res), sep='\n')

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n = int(input())
x, y = 1, 9
n -= 1
while n > x * y:
    n -= x * y
    x += 1
    y *= 10
a = 10 ** (x - 1) + n // x
print(str(a)[n % x])",O(logn)
"from math import inf

n = int(input())
s_list = list(map(int, input().split()))
c_list = list(map(int, input().split()))

total_min = inf
for j in range(n):
    min_i = inf
    for i in range(0, j):
        if s_list[i] < s_list[j]:
            min_i = min(min_i, c_list[i])

    min_k = inf
    for k in range(j + 1, n):
        if s_list[k] > s_list[j]:
            min_k = min(min_k, c_list[k])

    total_min = min(total_min, min_i + c_list[j] + min_k)
if total_min != inf:
    print(total_min)
else:
    print(-1)",O(n ^ 2)
"MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",O(logn)
"n = int(input())
a = [int(s) for s in input().split()]
os = 0
oss = []
nos = 0
nos_0 = -1
nos_1 = -1
sumnos = 0
for i in range(n):
    if a[i] == 1:
        os += 1
        oss.append(i+1)
    else:
        sumnos += a[i]
        nos += 1
        if nos_0 == -1:
            nos_0 = i+1
        nos_1 = i+1

if os <= sumnos-(2*(nos-1)):
    es = []
    oss_i = 0
    ans = nos-1
    if os >= 1:
        ans += 1
        es.append((nos_0, oss[0]))
        oss_i += 1
    if os >= 2:
        ans += 1
        es.append((nos_1, oss[1]))
        oss_i += 1
    print(""YES"", ans)
    prev_nos = -1
    for i in range(n):
        if a[i] > 1:
            if prev_nos != -1:
                es.append((prev_nos+1, i+1))
            for j in range(a[i]-2):
                if oss_i >= os:
                    break
                es.append((i+1, oss[oss_i]))
                oss_i += 1
            prev_nos = i
    print(len(es))
    for e in es:
        print(*e)
else:
    print(""NO"")
",O(n)
"hell=1000000007
id1=0
id2=0
a = []
def check(n,m,x):
    global id1,id2
    b = [0]*(1<<m)
    idx = [0]*(1<<m)
    for i in range(n):
        mask=0
        for j in range(m):
            if a[i][j]>=x:
                mask=mask^(1<<j)
        b[mask]=1
        idx[mask]=i+1
    for i in range(1<<m):
        if b[i]:
            for j in range(1<<m):
                if b[j]:
                    mask=i|j
                    if mask==((1<<m)-1):
                        id1=idx[i]
                        id2=idx[j]
                        return 1
    return 0
def meowmeow321():
    n,m = map(int,input().split())
    for i in range(n):
        dog = [int(x) for x in input().split()]
        a.append(dog)
    lo=0
    hi=hell
    while hi-lo>0:
        mid=(hi+lo+1)//2
        if check(n,m,mid):
            lo=mid
        else:
            hi=mid-1
    check(n,m,lo)
    print(id1,id2)

t=1

for xxx in range(t):
    meowmeow321()",np
"class Solution(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""""]
        right = float(""inf"")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left > right:
                result.append("""")
            right = new_right
            result[-1] = s[left:right+1]
        return result",O(n)
"class Solution(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return (num-parity(num))//2",O(logn)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(1)
"class Solution(object):
    def maxFrequency(self, nums, k):
        left = 0
        nums.sort()
        for right in range(len(nums)):
            k += nums[right]
            if k < nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1",O(nlogn)
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n,m=map(int,input().split())
l=[]
pm=2**m-1
for i in range(n):
    l.append(list(map(int,input().split())))
def find (x):
    s=set()
    d=defaultdict(int)
    for i in range(n):
        a=""""
        for j in range(m):
            if l[i][j]>=x:
                a+='1'
            else:
                a+='0'
        d[int(a,2)]=i
        s.add(int(a,2))
    s=list(s)

    for i in range(len(s)):
        for j in range(i,len(s)):
            if s[i]|s[j]==pm:
                return [d[s[i]]+1,d[s[j]]+1]
    return [-1,-1]
st=0
end=10**9
ans=(0,0)
while(st<=end):
    mid=(st+end)//2
    s=find(mid)
    if s[0]!=-1:
        ans=s
        st=mid+1
    else:
        end=mid-1
print(*ans)",np
"n,k = map(int,input().split())
s = input()
a = (n-k)//2
s1 = s.replace('(','',a)
s2 = s1.replace(')','',a)
print(s2)",O(n)
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(_y)

print(' '.join(map(str, y)))
",O(n ^ 2)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
c = list(map(int, input().split()))
f = list(map(int, input().split()))
h = [0] + list(map(int, input().split()))
cnt1 = defaultdict(lambda : 0)
for i in c:
    cnt1[i] += 1
cnt2 = defaultdict(lambda : 0)
for i in f:
    cnt2[i] += 1
ans = 0
for i in cnt2:
    c1, c2 = cnt1[i], cnt2[i]
    dp0 = [0]
    l = 1
    for _ in range(c2):
        dp = [0] * (l + k)
        for i in range(l):
            dp0i = dp0[i]
            for j in range(k + 1):
                dp[i + j] = max(dp[i + j], dp0i + h[j])
        l += k
        dp0 = dp
    ans += dp[min(c1, k * c2)]
print(ans)",O(n ^ 3)
"N = 1010

dp = [[[0] * 4 for j in range(N*2)] for i in range(N)]
dp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1
m = 998244353
for i in range(N-1):
    for j in range(1,N*2-5):
        for me in range(4):
            for he in range(4):
                if me <= 1:
                    if he <= 1:
                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m
                else:
                    if he <= 1:
                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m
n,k = map(int,input().split())
print(sum(dp[n-1][k])%m)
",np
"q=input().split()

x=int(q[0])
k=int(q[1])

def po(a,p,m):
 if p==0:
  return 1
 x=po(a,p//2,m)%m
 x=(x%m*x%m)%m
 if p%2==1:
  x=(x%m*a%m)%m

 return int(x)

m=1000000007
if x==0:
 print(0)
else:
 print(((po(2,k+1,m)%m*x%m)%m-(po(2,k,m)%m-1)%m)%m)",O(logn)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
while cur > 0:
    prev = pp[cur]
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"class DFS:
    def __init__(self):
        self.G= []
        self.leave_tree= []

    def take_input(self):
        k = int(input())
        if(k>1):
            graph =[int(node)-1 for (node) in input().split(' ')]
            self.G = [[] for _ in range(len(graph)+1)]
            for i in range(len(graph)):
                self.G[graph[i]].append(i+1)
            self.visited = [0]*k
            self.leave_tree = [0]*k
            for i in range(k-1,-1,-1):
                if len(self.G[i])==0:
                    self.leave_tree[i]=1
                else:
                    for j in self.G[i]:
                        self.leave_tree[i]+=self.leave_tree[j]
            self.leave_tree.sort()
            print(*self.leave_tree)
        else:
            print(k)

x = DFS()
x.take_input()
",O(nlogn)
"import sys
import math
import collections
import heapq
import decimal
input=sys.stdin.readline
n,m,k = map(int,input().split())
a=[]
for i in range(n):
    a.append(list(map(int,input().split())))
b=[]
for i in range(n-1):
    b.append(list(map(int,input().split())))
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end = "" "")
        print()
else:
    k//=2
    pre=[[0 for i in range(m)]for j in range(n)]
    for x in range(k):
        curr = [[float(""inf"") for i in range(m)]for j in range(n)]
        for i in range(n):
            for j in range(m):
                if(j>0):
                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])
                if(i<n-1):
                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])
                if(j<m-1):
                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])
                if(i>0):
                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])
        pre=curr[:]
    for i in range(n):
        for j in range(m):
            print(2*pre[i][j],end = "" "")
        print()",O(n ^ 3)
"from sys import stdin
t = int(stdin.readline())
for _ in range(t):
    n = int(stdin.readline())
    a = round((n / 2) ** 0.5)
    b = round((n / 4) ** 0.5)
    if 2*a**2 == n or 4*b**2 == n:
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"def ch_x(stri, n):
    res = ''
    for i in range(len(stri)):
        if i != n:
            res += stri[i]
        else:
            res += 'x'
    return res

a = input()
b = input()
n = 0
for i in range(0, len(a)):
    if a[i] == '0' and b[i] == '0':
        c = [i-1, i+1]
        for e in c:
            if 0 <= e < len(a):
                if a[e] == '0':
                    n += 1
                    a = ch_x(a, e)
                    break
                if b[e] == '0':
                    n += 1
                    b = ch_x(b, e)
                    break
        a = ch_x(a, i)
        b = ch_x(b, i)
print(n)",O(1)
"n,m=map(int,input().split())
o=0
c=0
diff=[]
while n:
    n-=1
    a,b=map(int,input().split())
    diff.append(a-b)
    o+=a
    c+=b

if m >=o:
    print(0)
elif m <c:
    print(-1)
else:
    diff.sort(reverse=True)
    nd=o-m

    for i in range(len(diff)):

        nd-=diff[i]
        if nd<=0:
            print(i+1)
            break
",O(nlogn)
"n, m, k =map(int, input().split())
horizontal = [list(map(int, input().split())) for i in range(n)]
vertical = [list(map(int, input().split())) for i in range(n-1)]
if k%2 or max(n, m)==1:print(*["" "".join(['-1']*m) for i in range(n)], sep='\n');exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])
",O(n ^ 3)
"class Solution2(object):
    def largestGoodInteger(self, num):
        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in range(len(num)-2))*3",O(n)
"a,b=map(int,input().split())
c=list(map(int,input().split()))
d=list(map(int,input().split()))
e=[]
for i in c:
    if i in d:
        e.append(i)
for j in e:
    print(j,end="" "")",O(n ^ 2)
"n,m=[int(x) for x in input().split()]
v=[]
h=[]
for i in range(n):
    x=int(input())
    v.append(x)
for i in range(m):
    x,y,z=[int(x) for x in input().split()]
    if x==1:
        h.append(y)
h.sort()
v.sort()
m=len(h)
n=len(v)
if n==0 or v[n-1]!=1000000000:
    v.append(1000000000)
    n+=1
mina=9999999999999
j=0
for i in range(n):
    while(j<m and h[j]<v[i]):
        j+=1

    mina=min(mina,i+m-j)
print(mina)",O(nlogn)
"class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False",O(n ^ 2)
"n = int(input())
A = [int(a) for a in input().split()]

prefix = [0] * n
prefix[0] = A[0]
for i in range(1, n):
    prefix[i] = prefix[i - 1] + A[i]

target = (sum(A) + 1) // 2

for i in range(n):
    if prefix[i] < target:
        continue
    else:
        print(i + 1)
        break",O(n)
"from collections import defaultdict

def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import sys
dp=[]
a=[]
def calcdp(l,r):
    global dp,a
    if l+1==r :
        dp[l][r]=a[l]
        return dp[l][r]
    if dp[l][r]!=0:
        return dp[l][r]
    dp[l][r]=-1
    for k in range(l+1,r):
        la=calcdp(l,k)
        ra=calcdp(k,r)
        if la>0 and la==ra:
            dp[l][r]=la+1
    return dp[l][r]
def solve(n):
    dp2=[float('inf')]*(n+1)
    dp2[0]=0
    for i in range(n):
        for j in range(i+1,n+1):
            if calcdp(i,j)>0:
                dp2[j]=min(dp2[j],dp2[i]+1)

    return dp2[n]
def ip():
    global dp,a

    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))
    a.append(0)

    dp=[]
    ll=[0]*(n+1)
    for _ in range(n+1):
        dp.append(list(ll))

    print(solve(n))

ip()
",O(n ^ 3)
"n = int(input())
print(n**2+((n-1)**2))
",O(1)
"n=int(input())
def judge(x):
    if x%2==0:
        return 0
    else:
        return 1
ls=[int(x) for x in input().split()]
if judge(ls[0])==judge(ls[1]):
    for x in ls[2:]:
        if judge(x)!=judge(ls[0]):
            print(ls.index(x)+1)
            break
else:
    if judge(ls[2])==judge(ls[0]):
        print(2)
    elif judge(ls[2])==judge(ls[1]):
        print(1)",O(n)
"n=int(input())
l1=list(map(int,input().split()))
ans=0
l1.sort()
visited=[0]*n
for i in range(n):
    if visited[i]==1:
        continue
    visited[i]=1
    ans+=1
    for j in range(i+1,n):
        if visited[j]==0 and l1[j]%l1[i]==0:
            visited[j]=1
print(ans)",O(n ^ 2)
"class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))",O(n)
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",O(1)
"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}
ch_1={0:[3],3:[0],1:[0,3],2:[0,3]}
ch_2={0:[],3:[],2:[1],1:[2]}
N=998244353
n,k=map(int,input().strip().split("" ""))
dp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]
dp[0][1][3]=1
dp[0][1][0]=1
dp[0][2][1]=1
dp[0][2][2]=1

for i in range(1,n):
    for j in range(1,k+1):
        for mask in range(4):
            for t in ch_0[mask]:
                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N
            if j>1:
                for t in ch_1[mask]:
                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N
                if j>2:
                    for t in ch_2[mask]:
                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N
ans=0
for mask in range(4):
    ans=(ans+dp[n-1][k][mask])%N
print(ans)
",np
"class Solution2(object):
    def goodNodes(self, root):
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max <= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)",O(n)
"import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val

        def inorder_traversal(root, cb):
            def traverseLeft(node, stk):
                while node:
                    stk.append(node)
                    node = node.left 

            stk = []
            traverseLeft(root, stk)
            while stk:
                curr = stk.pop()
                cb(curr.val)
                traverseLeft(curr.right, stk)
                
        counter = collections.defaultdict(int)
        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"n, a, b = map(int, input().split())
if (n == 3 or n == 2) and (a == 1 and b == 1):
    print(""NO"")
    exit(0)
g = [[0 for i in range(n)] for j in range(n)]
if a > 1 and b == 1:
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
elif b > 1 and a == 1:
    a, b = b, a
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
    for i in range(n):
        for j in range(n):
            if g[i][j] == 0:
                g[i][j] = 1
            elif g[i][j] == 1:
                g[i][j] = 0
    for i in range(n):
        g[i][i] = 0
elif a == 1 and b == 1:
    for i in range(n - 1):
        g[i][i + 1] = g[i + 1][i] = 1
elif a > 1 and b > 1:
    print(""NO"")
    exit(0)
print(""YES"")
for i in range(n):
    for j in range(n):
        print(g[i][j], end='')
    print()",O(n ^ 2)
"A, B, C, N = map(int, input().strip().split())
D = N - (A + B - C)
if D <= 0 or C > A or C > B:
    print('-1')
    exit(0)
print(D)
",O(1)
"from __future__ import division
from sys import stdin, stdout

def write(x):
    stdout.write(str(x) + ""\n"")

n = int(stdin.readline())
out = 0
for i in range(2, n + 1):
    out += 4 * (n // i - 1) * i

write(out)
",O(n)
"n, m = map(int, input().split())
a = [0] + list(map(int, input().split()))
a.sort()
ans = 0
h = a[-1]
for i in range(n, 0, -1):
	if a[i - 1] < h - 1:
		ans = ans + a[i] - h + a[i - 1]
		h = a[i - 1]
	else:
		ans = ans + a[i] - 1
		h = h - 1
print(ans)",O(nlogn)
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",O(n ^ 2)
"n,k=list(map(int,input().split()))

if k%2==0:
    s="".""
    s=s+""
    s=s+"".""*(n-len(s))
    print(""YES"")
    print("".""*n)
    print(s)
    print(s)
    print("".""*n)

else:
    if k<=n-2:
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print(s)
        print("".""*n)
        print("".""*n)
    else:
        k=k-n+3
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print("".""+""
        s=list(s)
        s[n//2]="".""
        s="""".join(s)
        print(s)
        print("".""*n)",O(n)
"n = int(input())
a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)
for i in range(2, n+1):
    a[i] = int(input())
    b[a[i]] += 1
for i in range(1, n+1):
    if b[i] == 0:
        c[a[i]] += 1
for i in range(1, n+1):
    if b[i] != 0 and c[i] < 3:
        print(""NO"")
        exit()
print(""YES"")",O(n)
"from collections import defaultdict as dd
import math
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))

n,v=mi()

dist=n-1

if v>=dist:
	print(dist)

else:
	off=dist-v
	prices=[i+2 for i in range(off)]
	print(v+sum(prices))
",O(n)
"import sys
def read():
    return int(input())
def reads():
    return [int(x) for x in input().split()]
N,M=reads()
table=[reads() for i in range(N)]
A=[[0]*N for i in range(N)]
B=[[0]*N for i in range(N)]
for i in range(N):
    for j in range(N):
        res=10**9+7
        for k in range(M):
            res=min(res,abs(table[i][k]-table[j][k]))
        A[i][j]=res
        A[j][i]=res
        res=10**9+7
        for k in range(M-1):
            res=min(res,abs(table[i][k]-table[j][k+1]))
        B[i][j]=res

dp=[[-1]*N for i in range((1<<N) )]
def calc(mask,v):
    if dp[mask][v]!=-1:
        return dp[mask][v]
    res =0
    for u in range(N):
        if (mask & 1<<u) and u!=v:
            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))
    dp[mask][v]=res
    return dp[mask][v]
ans=0
for i in range(N):
    dp = [[-1] * N for i in range((1 << N))]
    for k in range(N):
        if k==i:
            dp[1<<k][k]=10**9+7
        else:
            dp[1<<k][k]=0
    for j in range(N):
        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))

print(ans)",np
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxAncestorDiff(self, root):
        result = 0
        stack = [(root, 0, float(""inf""))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result",O(n)
"n, p=map(int, input().split())
arr=list(map(int, input().split()))
su=0
for i in range(n):
	su+=arr[i]
maxi, f=0, 0
for i in range(n-1):
	f+=arr[i]
	maxi=max(maxi, f%p+(su-f)%p)
print(maxi)",O(n)
"def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret

def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):

        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m

    for i in range(-100, 100):
        t = m + i

        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)

if __name__ == '__main__':
    main()
",O(logn)
"R, G, B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse=True)
g = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())), reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"import math

t = int(input())
res = []
while t:
	t -= 1
	n, k = map(int, input().split())
	limit = -1
	if n <= 60:
		limit = 0
		pow4 = 1
		for _ in range(n):
			limit += pow4
			pow4 *= 4
	if limit < k and limit != -1 or n == 2 and k == 3:
		res.append('NO')
	else:
		div = 1
		k -= 1
		size = 1
		while div < n and k >= 4 * size - 1:
			k -= 4 * size - 1
			size *= 2
			div += 1
		res.append('YES ' + str(n - div))

print('\n'.join(res))",O(logn)
"n,m=list(map(int,input().split()))
for i in range(1,n+1):
    j=i*(i+1)//2

    if j>=m:
        if j==m and i==n:
            print(0)
            break
        else:
            t=n-i
            if j-t==m:
                print(t)
                break
            elif j-t<m:

                continue
",O(logn)
"def if_Spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1, n + 1):
        if m[i] == 0:
            d[l[i]] += 1
    for i in range(1, n + 1):
        if m[i] > 0 and d[i] < 3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_Spruce(n,l,m))
",O(n)
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    for l in cnt:
        if l.count(0)<1:
            continue
        t=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",O(n)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"try:
    n=int(input())
    x=list(map(int,input().split("" "")))
    x=set(x)
    x=list(x)
    x.sort()
    if len(x)!=1:
        print(x[1])
    else:
        print(""NO"")

except:
    pass
",O(nlogn)
"class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans",O(1)
"n = int(input())
a = list(map(int, input().split()))
m = int(input())
parity = 0
for i in range(n):
    for j in range(i + 1, n):
        if a[i] > a[j]:
            parity ^= 1
res = []
for _ in range(m):
    l, r = map(int, input().split())
    s = r - l + 1
    parity ^= (s * (s - 1) // 2) % 2
    res.append(""odd"" if parity else ""even"")
print(""\n"".join(res))",O(n ^ 2)
"NANS = (False, None)

def is_valid(n, k):
    if n > 31:
        return True
    return k*3 <= (2**(2*n) - 1)

def solve_mini(n, k):
    if not is_valid(n, k):
        return NANS

    if n == 1:
        if k == 1:
            return (True, 0)
        else:
            return (False, None)
    if n == 2:
        if k in [1, 2]:
            return (True, 1)
        if k in [4, 5]:
            return (True, 0)
    return (False, None)

def solve(n, k):
    if n < 3:
        ans, log = solve_mini(n, k)
        return (ans, log)

    if not is_valid(n, k):
        return NANS

    w = 1
    while k >= w and n >= 1:
        k -= w
        n -= 1
        w = w + w + 1
    return(True, n)

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    ans, log = solve(n, k)
    if ans:
        print(""YES"", log)
    else:
        print(""NO"")
",O(logn)
"n = int(input())
import math
print(math.ceil(n/2) * (math.floor(n/2)+1))",O(n)
"import sys

def input():
    return sys.stdin.readline().rstrip()

def slv():
    n, m, k = map(int, input().split())
    if k % 2 != 0:
        for i in range(n):
            print(*[-1]*m)
        return

    k //= 2

    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]
    G = [[[] for i in range(m)] for j in range(n)]
    for i in range(n):
        C = list(map(int,input().split()))
        for j in range(m - 1):
            cost = C[j]
            G[i][j].append((cost,i,j + 1))
            G[i][j + 1] .append((cost,i,j))

    for i in range(n - 1):
        C = list(map(int,input().split()))
        for j in range(m):
            cost = C[j]
            G[i][j].append((cost,i + 1,j))
            G[i+1][j].append((cost,i,j))

    for p in range(1,k + 1):
        for u in range(n):
            for v in range(m):
                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])
    for i in range(n):
        ans = [DP[k][i][j]*2 for j in range(m)]
        print(*ans)
    return
def main():
    t = 1
    for i in range(t):
        slv()
    return

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution2(object):
    def findBuildings(self, heights):
        result = []
        for i in reversed(range(len(heights))):
            if not result or heights[result[-1]] < heights[i]:
                result.append(i)
        result.reverse()
        return result",O(n)
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",O(n)
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')

else:
    print('YES')
    print(*ans, sep=' ')",O(n ^ 2)
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",O(n ^ 3)
"class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]",O(n)
"import io
import os

from collections import Counter, defaultdict, deque

def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)

def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)

if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)
",O(n ^ 3)
"n,m=map(int,input().split())
arr=[ int(x) for x in input().split()]

arr=sorted(arr,reverse=True)
arr.append(0)

isum=sum(arr)
ans=[]
top=arr[0]
for i in range(n):
	if(arr[i]==1):
		ans.append(1)
		arr[i+1]=1
		continue
	if(arr[i+1] >arr[i]):
		arr[i+1]=arr[i]
	if arr[i]-arr[i+1]==0:
		ans.append(1)
		h=1
	else:
		ans.append(arr[i]-arr[i+1])
		h=arr[i]-arr[i+1]

	top=arr[i]-h
	arr[i+1]=top

print(isum-sum(ans))",O(nlogn)
"n = int(input())
l = [*map(int, input().split())]

p = [0] * n
for i in range(n): p[l[i] - 1] = i

res = ['?'] * n

for e in range(n, 0, -1):
    i = p[e - 1]
    res[i] = 'B'
    for j in range(i % e, n, e):
        if i != j and l[i] <= l[j] and res[j] == 'B':
            res[i] = 'A'
            break
print(''.join(res))",O(n ^ 2)
"def binary(n,k,low,high):
    if low<=high:
        mid=(low+high)//2
        if (mid*(mid+1))//2-(n-mid)==k:
            return n-mid
        elif mid*(mid+1)//2-(n-mid)>k:
            return binary(n,k,low,mid-1)
        else:
            return binary(n,k,mid+1,high)

n,k=[int(x) for x in input().split()]
print(binary(n,k,1,n))",O(logn)
"class Solution(object):
    def haveConflict(self, event1, event2):
        return max(event1[0], event2[0]) <= min(event1[1], event2[1])",O(1)
"class Solution(object):
    def minimumNumbers(self, num, k):
        return next((i for i in range(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0",O(1)
"from math import ceil

n=int(input())
d={1:[1],2:[1,2],3:[1,1,3]}
if n in d:
    for i in d[n]:
        print(i,end=' ')
    exit()
def f(n):
    if n in d:
        return d[n]
    odds=ceil(n/2)
    lis=[1]*odds
    even=n//2
    lis1=f(even)
    for i in range(len(lis1)):
        lis1[i]*=2
    return lis+lis1
ans=f(n)
for i in ans:
    print(i,end=' ')",O(nlogn)
"class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        dist = float(""inf"")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]",O(n)
"import operator
from functools import reduce



class Solution(object):
    def xorAllNums(self, nums1, nums2):
        return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ \
               (reduce(operator.xor, nums2) if len(nums1)%2 else 0)",O(n)
"class Solution(object):
    def canJump(self, A):
        reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                break
            reachable = max(reachable, i + length)
        return reachable >= len(A) - 1",O(n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"import sys, heapq

n, x = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = dict().fromkeys(set(arr), 0)
for i in arr:
    res[i] += 1
can = False
for i in res:
    if res[i] >= 2:
        can = True
        break
if can:
    print(0)
else:
    res = dict().fromkeys([i for i in range(max(arr) + 1)])
    for i in res:
        res[i] = []
    for i in range(n):
        temp = set()
        now = arr[i]
        cnt = 0
        while True:
            added = False
            before = len(temp)
            temp.add(now)
            after = len(temp)
            if before == after:
                break
            heapq.heappush(res[now], cnt)
            now = now & x
            cnt += 1
    ans = 9876543210
    for i in res:
        if len(res[i]) >= 2:
            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))
    print(ans if ans != 9876543210 else -1)",O(n)
"class Solution2(object):
    def makePalindrome(self, s):
        cnt = 0
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                cnt += 1
                if cnt > 2:
                    return False
            left += 1
            right -= 1
        return True",O(n)
"class Solution(object):
    def depthSum(self, nestedList):
        def depthSumHelper(nestedList, depth):
            res = 0
            for l in nestedList:
                if l.isInteger():
                    res += l.getInteger() * depth
                else:
                    res += depthSumHelper(l.getList(), depth + 1)
            return res
        return depthSumHelper(nestedList, 1)",O(n)
"class Solution(object):
    def doubleIt(self, head):
        if head.val >= 5:
            head = ListNode(0, head)
        curr = head
        while curr:
            curr.val = (curr.val*2)%10
            if curr.__next__ and curr.next.val >= 5:
                curr.val += 1
            curr = curr.__next__
        return head",O(n)
"class Solution(object):
    def numberOfDays(self, Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)",O(1)
"import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)
",O(n ^ 2)
"from sys import stdin, stdout

def binary_exp(x,n,prime):
	if n==0:
		return 1
	elif n==1:
		return x%prime
	else:
		temp=binary_exp(x,n//2,prime)
		temp=(temp*temp)%prime
		if n%2==0:
			return temp
		else:
			return ((x%prime)*temp)%prime

x,k = map(int, stdin.readline().rstrip().split())
if x==0:
	print(0)
else:
	val1=binary_exp(2,k+1,1000000007)
	val2=binary_exp(2,k,1000000007)
	val1=val1%1000000007
	val2=val2%1000000007

	ans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007
	print(ans)",O(logn)
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')
",O(n ^ 2)
"x,k=map(int,input().split())
MOD = pow(10,9)+7
def repow(n):
  global MOD
  if n == 1:
    return 2
  if n%2 == 0:
    return pow(repow(n//2),2)%MOD
  else:
    return (2*pow(repow(n//2),2))%MOD

if 0 < k and 0 < x:
  if MOD <= k:
    while MOD <= k:
      k = (k // MOD) + (k % MOD)
  tmp = (2*x-1)%MOD
  print((tmp*repow(k)+1)%MOD)
else:
  print(2*x%MOD)
",O(logn)
"n, k = map(int,input().split())

start = 0
cnt = n
cur = 1

while start <= k:
    start += cur
    cnt -= 1
    cur += 1

ans = 0

if start != k:
    while cnt > 0:
        if start == k:
            start += cur
            cur += 1
            cnt -= 1
        ans += (start - k)
        cnt -= (start - k)
        start = k

print(ans)
",O(logn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def increasingBST(self, root):
        def increasingBSTHelper(root, tail):
            if not root:
                return tail
            result = increasingBSTHelper(root.left, root)
            root.left = None
            root.right = increasingBSTHelper(root.right, tail)
            return result
        return increasingBSTHelper(root, None)

",O(n)
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]

n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"import sys
input=sys.stdin.readline
a=list(map(int,input().rstrip()))
b=list(map(int,input().rstrip()))
if len(a)<len(b):
    a.sort(reverse=True)
    print(''.join(map(str,a)))
else:
    ans=-1
    ca=[0]*10
    for aa in a:
        ca[aa]+=1
    lim=-1
    for i in range(len(a)):
        if ca[b[i]]:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                ca[b[i]]-=1
                continue
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                ca[b[i]]-=1
        else:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                break
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                break
    flg=True
    ca=[0]*10
    for i in range(len(a)):
        ca[a[i]]+=1
    for i in range(len(a)):
        if ca[b[i]]:
            ca[b[i]]-=1
        else:
            flg=False
    if flg:
        ans=max(ans,int(''.join(map(str,b))))
    print(ans)",O(n ^ 3)
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",O(n)
"from collections import deque

class Solution(object):

    def __init__(self, width,height,food):
        self.__width = width
        self.__height = height
        self.__score = 0
        self.__f = 0
        self.__food = food
        self.__snake = deque([(0, 0)])
        self.__direction = {""U"": (-1, 0), ""L"": (0, -1), ""R"": (0, 1), ""D"": (1, 0)}
        self.__lookup = {(0, 0)}

    def move(self, direction):
        def valid(x, y):
            return 0 <= x < self.__height and \
                   0 <= y < self.__width and \
                   (x, y) not in self.__lookup
        d = self.__direction[direction]
        x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]
        self.__lookup.remove(self.__snake[0])
        tail = self.__snake.popleft()
        if not valid(x, y):
            return -1
        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):
            self.__score += 1
            self.__f += 1
            self.__snake.appendleft(tail)
            self.__lookup.add(tail)
        self.__snake.append((x, y))
        self.__lookup.add((x, y))
        return self.__score",O(1)
"def main():
  n, k = map(int, input().split())
  v = list(map(int, input().split()))

  d = {}
  ans = 0

  for x in v:
    num_d, mod_k = len(str(x)), x % k
    d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)

  for x in v:
    num_d, mod_k = len(str(x)), x % k
    for add, mods in d.items():
      val_mod = (mod_k * 10 ** add) % k
      need_mod = (k - val_mod) % k
      ans += len(mods.get(need_mod, []))
      if need_mod == mod_k and add == num_d:
        ans -= 1

  print(ans)

if __name__ == ""__main__"":
  main()
",O(nlogn)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def enQueue(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deQueue(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def Front(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def Rear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"class Solution(object):
    def checkValidString(self, s):
        lower, upper = 0, 0 
        for c in s:
            lower += 1 if c == '(' else -1
            upper -= 1 if c == ')' else -1
            if upper < 0: break
            lower = max(lower, 0)
        return lower == 0",O(n)
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np
"import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] > limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1 
        return len(nums)-left",O(n)
"import sys,os,io
from math import log, gcd
from collections import defaultdict, deque
from heapq import heappush, heappop

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

t = 1
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    l1.sort()
    pos = []
    for i in range(n):
        if (l1[i]!=l[i]):
            pos.append(i)
    if (len(pos)==0) or (len(pos)==2 and l[pos[0]]==l1[pos[1]] and l[pos[1]]==l1[pos[0]]):
        print(""YES"")
    else:
        print(""NO"")
",O(nlogn)
"class Solution(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [-1]*26
        for right in range(len(s)):
            if lookup[ord(s[right])-ord('a')] >= left:
                left = lookup[ord(s[right])-ord('a')]+1
            lookup[ord(s[right])-ord('a')] = right
            result += (right-left+1)
        return result",O(n)
"n, s = map(int, input().split())
r = 0
v = min(n+1, s+19*9)
for i in range(s, v):
    zz = f'{i}'
    sm = i
    for z in zz:
        sm -= int(z)

    if(sm >= s):
        r += 1

print(r + n-v + 1)
",O(logn)
"class Solution2(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        lookup = {0:-1}
        prefix = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            prefix += nums[right%len(nums)]
            if prefix-target in lookup:
                result = min(result, right-lookup[prefix-target])
            lookup[prefix] = right
        return result+q*len(nums) if result != INF else -1",O(n)
"import sys,math

def read_int():
	return int(sys.stdin.readline().strip())

def read_int_list():
	return list(map(int,sys.stdin.readline().strip().split()))

def read_string():
	return sys.stdin.readline().strip()

def read_string_list(delim="" ""):
	return sys.stdin.readline().strip().split(delim)

k = read_int()

base_digit_number = 1; expo = 0

while k >= base_digit_number:
	base_digit_number += 9*(expo+1)*(10**expo)
	expo += 1

base_digit_number -= 9*(expo)*(10**(expo-1))

ans_number = (k - base_digit_number)//expo + 10**(expo-1)

ans_digit = str(ans_number)[(k - base_digit_number)%expo]

print(ans_digit)
",O(logn)
"class Solution(object):
    def averageHeightOfBuildings(self, buildings):
        points = []
        for x, y, h in buildings:
            points.append((x, 1, h))
            points.append((y, -1, h))
        points.sort()
        result = []
        total = cnt = 0
        prev = -1
        for curr, c, h in points:
            if cnt and curr != prev:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h*c
            cnt += c
            prev = curr
        return result",O(nlogn)
"input()
p = list(map(int, input().split()))
x = max(p)
if p[p.index(x)] == 1:
    p[p.index(x)] = 2
else:
    p[p.index(x)] = 1
p.sort()
print(' '.join(str(i) for i in p))",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

mod = int(1e9) + 7

def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod

def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count

def main():
    n, m=map(int, input().split())
    a=list(map(int, input().split()))
    k=a.index(m)
    t=[0]
    for i in range(k-1, -1, -1):
        z=-1 if a[i]<a[k] else 1
        t.append(t[-1]+z)
    d={0:1}
    now=0
    for i in range(k+1, n):
        now+=-1 if a[i]<a[k] else 1
        if now not in d.keys():
            d[now]=0
        d[now]+=1

    ans=0
    for i in t:
        if -i in d.keys():
            ans+=d[-i]
        if 1-i in d.keys():
            ans+=d[1-i]
    print(ans)

    return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution(object):
    def removeElement(self, A, elem):
        i, last = 0, len(A) - 1
        while i <= last:
            if A[i] == elem:
                A[i], A[last] = A[last], A[i]
                last -= 1
            else:
                i += 1
        return last + 1",O(n)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i

class Solution(object):
    def read(self, buf, n):
        read_bytes = 0
        buffer = [''] * 4
        for i in range((n+4-1)//4):
            size = min(read4(buffer), n-read_bytes)
            buf[read_bytes:read_bytes+size] = buffer[:size]
            read_bytes += size
        return read_bytes",O(n)
"n,l,r,x = map(int,input().split())
A = list(map(int,input().split()))
count = 0
for i in range(1<<n):
    total = 0
    mn = 1e6
    mx = -1e6
    for k in range(n):
        if (i & (1<<k)):
            total += A[k]
            mn = min(A[k],mn)
            mx = max(A[k],mx)
    if total<=r and total>=l and mx-mn>=x:
        count += 1
print(count)",np
"class Solution(object):
    def maxProduct(self, nums):
        m1 = m2 = 0
        for num in nums:
            if num > m1:
                m1, m2 = num, m1
            elif num > m2:
                m2 = num
        return (m1-1)*(m2-1)",O(n)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"s = input()
while s!="""":
	if s==s[::-1]:
		s=s[:(len(s)-1)]
	else:
		break
print(len(s))",O(n)
"z,zz=input,lambda:list(map(int,z().split()))
fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))

num=int(z())

arr=zzz()

new_arr=[(i,j+1) for j,i in enumerate(arr)]
new_arr=sorted(new_arr)

passenger=fast()

que=deque()

ans=[0]*2*num

left=0
right=num-1
le=0

for i in range(2*num):
    if passenger[i]=='0':
        ans[i]=new_arr[left][1]
        que.append(new_arr[left][1])
        left+=1
        le+=1

    else:
        if le>=1:
            ans[i]=que[-1]
            que.pop()
            le-=1
        else:
            ans[i]=new_arr[right][1]
            que.append(new_arr[right][1])
            right-=1
            le+=1
print(*ans)
",O(nlogn)
"import math
def maxor(bawah, atas):
	if bawah == atas:
		return 0
	xor = bawah^atas
	pangkat2 = math.log(xor, 2)
	return 2**int(math.floor(pangkat2)+1) - 1
a=input().split()
print(maxor(int(a[0]),int(a[1])))",O(logn)
"n = int(input())
a = list(map(int, input().split()))
b = []
c = []
e = []
for i in range(n):
	if a[i] == 1:
		b += [i]
for i in range(n):
	if a[i] != 1:
		c += [[a[i], i]]
if not c:
	print(""NO"")
	exit(0)
ans = len(c)
for i in range(len(c) - 1):
	e += [(c[i][1], c[i + 1][1])]
	c[i][0] -= 1
	c[i + 1][0] -= 1
if b:
	e += [(b[-1], c[-1][1])]
	c[-1][0] -= 1
	b.pop()
	ans += 1
if b:
	e += [(b[-1], c[0][1])]
	c[0][0] -= 1
	b.pop()
	ans += 1
i = 0
while b:
	while i < len(c) and c[i][0] == 0:
		i += 1
	if i == len(c):
		print(""NO"")
		exit(0)
	e += [(b[-1], c[i][1])]
	c[i][0] -= 1
	b.pop()

print(""YES"", ans - 1)
print(len(e))
for (x, y) in e:
	print(x + 1, y + 1)
",O(n)
"class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]",O(n)
"for _ in range(int(input())):
    n, k = [int(x) for x in input().split()]
    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) // 3):
        print('NO')
    else:
        cn = n - 1
        ck = k - 1
        l = 1
        while cn * ck != 0 and ck >= 4 * l - 1:
            ck -= 4 * l - 1
            cn -= 1
            l *= 2
        print('YES', cn)",O(logn)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

ans = 0

for mask in range(2**n):
    cnt, csum = 0, 0
    mn, mx = 10**18, -(10**18)
    for i in range(n):
        if (mask & (1 << i) != 0):
            cnt += 1
            csum += c[i]
            mn = min(mn, c[i])
            mx = max(mx, c[i])
    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):
        ans += 1

print(ans)
",np
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect

def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp

    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",O(n ^ 3)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"turns, candies = map(int, input().split())
summ = 0
turn = 0
while candies != summ - (turns - turn):
    turn += 1
    summ += turn
print(turns - turn)",O(n)
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

def main():

    n = getN()
    nums = getList()
    nums.sort()
    margins = [num - i for i, num in enumerate(nums)]
    for m in margins:
        if m < 0:
            print(""cslnb"")
            return
    flag = False
    if len(nums) > 1:
        if nums[0] == nums[1]:
                flag = True
    for a, b, c in zip(nums, nums[1:], nums[2:]):
        if b == c:
            if a == b or b - a == 1:
                print(""cslnb"")
                return
            if flag:
                print(""cslnb"")
                return
            flag = True

    margin = sum(margins)

    if margin % 2 == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"a,b=map(int,input().split())
if b>=a-1:
    print(a-1)
else:
    summ=b
    k=a-b
    for i in range(2,k+1):
        summ+=i
    print(summ)
",O(n)
"n=int(input())
a=[]
for i in range(n+1):
    a.append(((n+1)-i)*i)
print(max(a))",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input())) for i in range(n)]

ignorable = [True] * n

for i in range(m):
    cnt = 0
    for j in range(n):
        cnt += a[j][i]
    if cnt == 1:
        for j in range(n):
            if a[j][i]:
                ignorable[j] = False

if any(ignorable):
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"class node:
    def __init__(self,l,r,u,d):
        self.u = u
        self.d = d
        self.l = l
        self.r = r
        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:
            self.marr = [20000001 for i in range(11)]
        else:
            self.marr = [0 for i in range(11)]
            self.marr[1] = min(l,r,u,d)
    def mo(self,st):
        return self.marr[st-1]

n,m,s = (int(i) for i in input().split())
hor = [[20000001 for i in range(m+3)] for j in range(n+2)]
ver = [[20000001 for i in range(m+2)] for j in range(n+3)]
for i in range(1,n+1):
    hor[i][2:1+m] = [int(i) for i in input().split()]
for i in range(2,1+n):
    ver[i][1:m+1] = [int(i) for i in input().split()]
if s%2 == 0 :
    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]
    for st in range(2,s//2+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                x = nds[i][j].marr[1]
                l = nds[i][j].l
                r = nds[i][j].r
                u = nds[i][j].u
                d = nds[i][j].d
                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))
    ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)]
    for i in range(n):
        print(*tuple(ans[i]))
else :
    a = [[-1 for i in range(m)] for j in range(n)]
    for i in range(n):
        print(*tuple(a[i]))
",O(n ^ 3)
"n, m = map(int, input().split())
a = 1
for i in range(n - 1):
  a *= 10
  a += 1
b = 10 ** n - a
print(a)
print(b)",O(1)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def calculateTax(self, brackets, income):
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result",O(n)
"n = int(input())
ls1 = [int(i) for i in input().split()]
ls2 = [int(i) for i in input().split()]

ans = float('inf')

for i in range(1, n - 1):
    l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]]
    r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]]

    if len(l) and len(r):
        ans = min(ans, min(l) + min(r) + ls2[i])

print([-1 , ans][ans != float('inf')])",O(n ^ 2)
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n,m=read()
a=[]
for i in range(n):
    a.append(read())
sm=0
cur=0
for x, y in a:
    sm+=y
    cur+=x
if sm>m:
    print(-1)
    quit()
cnt=0
a.sort(key=lambda x: -x[0]+x[1])
i = 0
while cur>m and i < n:
    cur -= a[i][0]-a[i][1]
    cnt += 1
    i += 1
print(cnt)",O(nlogn)
"import sys

n, m, k = map(int, input().split())
table = [input() for _ in range(n)]

dp = [0]*(k+1)

for a in table:
    one = []
    for i in range(m):
        if a[i] == '1':
            one.append(i)

    if not one:
        continue

    ni = len(one)
    subdp = [10**9] * (ni+1)
    subdp[-1] = 0

    for i in range(ni):
        for j in range(i, ni):
            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)

    next_dp = [10**9]*(k+1)
    for i in range(k, -1, -1):
        for j in range(ni+1):
            if i+j > k:
                break
            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])
    dp = next_dp

print(min(dp))
",O(n ^ 3)
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

n=Int()
a=array()

series = [1]
fact = 1
for i in range(n+1):
    series.append(((series[-1]*2)%M + fact)%M)
    fact = (fact*2)%M

ind = n-1
ans=0

for i in range(n):
    ans = (ans + (a[i]*series[ind])%M )%M
    ind-=1

print(ans)
",O(n)
"s = input()
ans = 0
for i in range(len(s)):
    for j in range(i + 1, len(s)):
        cur = s[i:j]
        if cur in s[:(j - 1)] or cur in s[(i + 1):]:
            ans = max(ans, j - i)
print(ans)
",O(n ^ 3)
"import sys
LI=lambda:list(map(int, sys.stdin.readline().split()))
MI=lambda:map(int, sys.stdin.readline().split())
SI=lambda:sys.stdin.readline().strip('\n')
II=lambda:int(sys.stdin.readline())

n=II()
s=SI()
c=set(s)
ln=[0]*n
for d in c:
	last=-1

	for i, v in enumerate(s):
		if v==d:
			last=i
		if last==-1:
			ln[i]=int(1e9)
		else:
			ln[i]=max(ln[i], i-last+1)

print(min(ln))",O(n)
"class Solution(object):
    def minCost(self, n, cuts):
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in range(len(sorted_cuts))]
        for l in range(2, len(sorted_cuts)):
            for i in range(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in range(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]",O(n ^ 3)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"from sys import stdin

EPS = 1e-6
n = int(stdin.readline())
m = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))
b.append(b[0])

def check(f):
    fuel_left = f
    total_weight = float(m + fuel_left)
    for i in range(n):
        cost = total_weight / a[i]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost

        cost = total_weight / b[i + 1]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost
        if fuel_left < 0:
            return False
    return True

def binary_search(left, right):
    mid = (left + right) / 2
    if abs(left - right) < EPS:
        return mid
    if check(mid):
        return binary_search(left, mid)
    else:
        return binary_search(mid, right)

res = binary_search(0, 1e9 + 1)
if res - 1e9 > EPS:
    print(-1)
else:
    print(""%.10f"" % res)
",O(n)
"N = int(input())
A = [int(i) for i in input().split()]
A.sort()
duplicates = 0
i=1
temp = 1
ind = -1
while i<N:
    temp = 1
    while i<N and A[i] == A[i-1]:
        ind = i-1
        temp +=1
        i+=1
    i+=1

    if temp != 1: duplicates +=1
    if temp > 2 :
        break

turns =  sum(A) - N*(N-1)//2

if temp>2 or duplicates>1: print('cslnb')

else:
    output = 'cslnb'
    if duplicates == 0:
        if turns%2 == 1: output = 'sjfnb'
    else:
        if ind-1 >= 0:
            if A[ind-1] == A[ind]-1:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
        else:
            if A[ind] == 0:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
    print(output)
",O(nlogn)
"import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students[students[""student_id""] == 101][[""name"", ""age""]]",O(n)
"import bisect



class Solution(object):
    def maximumCount(self, nums):
        return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1))",O(logn)
"class Solution(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, nums, 0)^reduce(lambda x, y: x^y, set(nums), 0)",O(n)
"class Solution(object):
    def canBeValid(self, s, locked):
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(range(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal < 0:
                        return False
        return True",O(n)
"import sys
n,m=map(int,input().split())
s=[list(input()) for i in range(n)]
u=[[-1 for i in range(m)] for j in range(n)]
d=[[-1 for i in range(m)] for j in range(n)]
l=[[-1 for i in range(m)] for j in range(n)]
r=[[-1 for i in range(m)] for j in range(n)]
for i in range(m):
    acum=0
    for j in range(n):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        u[j][i]=acum
for i in range(m):
    acum=0
    for j in range(n-1,-1,-1):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        d[j][i]=acum
for i in range(n):
    acum=0
    for j in range(m):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        l[i][j]=acum
for i in range(n):
    acum=0
    for j in range(m-1,-1,-1):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        r[i][j]=acum
ans=[]
t1=[[0 for i in range(m)] for j in range(n)]
t2=[[0 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1
        if d1>0:
            ans.append([i+1,j+1,d1])
            t1[i+d1][j]+=1
            t1[i-d1][j]-=1
            t2[i][j-d1]+=1
            t2[i][j+d1]-=1
dp=[['.' for i in range(m)] for j in range(n)]
for i in range(n):
    acum=0
    for j in range(m):
        acum+=t2[i][j]
        if acum!=0 or t2[i][j]!=0:
            dp[i][j]='*'
for i in range(m):
    acum=0
    for j in range(n):
        acum+=t1[j][i]
        if acum!=0 or t1[j][i]!=0 :
            dp[j][i]='*'
if dp!=s:
    print(-1)
    sys.exit()
print(len(ans))
for i in ans:
    print(*i)
",O(n ^ 2)
"rgb = 'RGB' * 1000
for q in range(int(input())):
    n, k = [int(s) for s in input().split()]
    s = input()
    ans = 3000
    for w in range(3):
        for e in range(n - k + 1):
            temp = 0
            for i in range(k):
                if s[e + i] != rgb[w + i]:
                    temp += 1
            ans = min(ans, temp)
    print(ans)",O(n ^ 2)
"class Solution3(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            curr = 0
            for i in range(l):
                curr += usageLimits[~i]-(l-i)
                curr = min(curr, 0)
            for i in range(len(usageLimits)-l):
                curr += usageLimits[i]
            return curr >= 0

        usageLimits.sort()
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
t = list(map(int, input().split()))
taxi = list()
for i in range(len(arr)):
    if t[i] == 1:
        taxi.append(arr[i])
taxi2 = list()
kek = 1
for i in range(len(taxi) - 1):
    taxi2.append([kek, taxi[i] + (taxi[i + 1] - taxi[i]) // 2])
    kek = taxi[i] + (taxi[i + 1] - taxi[i]) // 2 + 1
taxi2.append([kek, arr[-1]])
taxi3 = [0] * m
j = 0
for i in range(len(arr)):
    if arr[i] > taxi2[j][1]:
        j += 1
    if t[i] != 1:
        taxi3[j] += 1
print("" "".join(map(str, taxi3)))
",O(n)
"l1,r=map(int,input().split())
if(l1==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l1^r
        p1=1
        while(p1<=x):
            p1*=2
        print(p1-1)
",O(logn)
"n = int(input())

a = list(map(lambda i: int(i), input().split(sep=' ')))
a.sort()
a_count = len(a)

b = list(filter(lambda i: i > 0, a))
b_count = len(b)

def resh():
    idx = 1
    while idx < a_count:
        if a[idx] == a[idx - 1] and (a[idx] - 1) in a:
            return 'cslnb'
        idx += 1

    b_sum = sum(b)
    v_sum = sum(range(1, b_count if a_count == b_count else b_count + 1))
    t = max(b_sum - v_sum, 0)
    return 'cslnb' if t % 2 == 0 else 'sjfnb'

if b_count == 0 or  b_count - len(set(b)) > 1 or a_count - b_count > 1:
    print('cslnb')
else:
    print(resh())
",O(nlogn)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]",O(n)
"def get_fingering(notes):
    fingering = []
    diff = 0
    next_diff = None
    finger = 0
    for i in range(len(notes) - 1):
        next_diff = notes[i+1] - notes[i]
        if diff == 0:
            if next_diff > 0:
                finger = 1 + (finger == 1)
            elif next_diff < 0:
                finger = 5 - (finger == 5)
            else:
                finger = 3 + (finger == 3)
        elif diff > 0:
            if finger == 5:
                return None
            if next_diff < 0:
                finger = 5
            else:
                finger += 1
        else:
            if finger == 1:
                return None
            if next_diff > 0:
                finger = 1
            else:
                finger -= 1
        fingering.append(finger)
        diff = next_diff

    return fingering

_ = input()
notes = [int(x) for x in input().split()]
notes.append(notes[-1])

fingering = get_fingering(notes)

if fingering:
    print(*fingering)
else:
    print(-1)
",O(n)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
a = inpl()
res = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            res = 1-res
for _ in range(inp()):
    l,r = inpl(); m = r-l+1
    swap = m*(m-1)//2
    if swap%2: res = 1-res
    print('odd' if res else 'even')",O(n ^ 2)
"N, K= map(int, input().split())
Rcnt = N * 2
Gcnt = N * 5
Bcnt = N * 8

res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K
print(res)
",O(1)
"n = int(input())

print(0, 0, n)
",O(1)
"class Solution(object):
    def minCost(self, costs):
        if not costs:
            return 0

        min_cost = [costs[0], [0, 0, 0]]

        n = len(costs)
        for i in range(1, n):
            min_cost[i % 2][0] = costs[i][0] + \
                                 min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][1] = costs[i][1] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][2] = costs[i][2] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1])

        return min(min_cost[(n - 1) % 2])",O(n)
"class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0",O(n)
"from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",O(n ^ 2)
"class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize != 0:
            return False
        count = Counter(hand)
        for num in hand:
            start = num
            while count[start - 1]:
                start -= 1
            while start <= num:
                while count[start]:
                    for i in range(start, start + groupSize):
                        if not count[i]:
                            return False
                        count[i] -= 1
                start += 1
        return True
",O(n)
"n=int(raw_input())

ans=[]
p=1
fin=n
while len(ans)<n-1:
	for i in range(fin-(n/(2**p))):
		ans.append(2**(p-1))
		fin-=1
	p+=1

if 2**(p-2) + 2**(p-1) <=n:
	ans.append(2**(p-1) + 2**(p-2))
else:
	ans.append(2**(p-1))

s="" "".join(str(x) for x in ans)

print(s)
",O(nlogn)
"def max_profit(n,k,l,d):
    a=[]
    s,p,i=0,0,-1
    while(len(a)!=k-1):
        p+=1
        i+=1
        if l[i] in d:
            s+=l[i]
            a.append(p)
            p=0
            d.remove(l[i])
    print(s+d[0])
    a.append(n-sum(i for i in a))
    print(*a)

n,k=map(int,input().split())
l=list(map(int,input().split()))
m=[]
m[:]=l[:]
d=[]
m.sort(reverse=True)
for i in range(k):
    d.append(m[i])
max_profit(n,k,l,d)",O(nlogn)
"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
",O(n)
"s = [list(input()), list(input())]
ans = 0
l = len(s[0])
i = 0
while i < l - 1:
    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])
    if a.count(""0"") == 4:
        ans += 1
        s[0][i + 1] = ""X""
        i+=1
    elif a.count(""0"") == 3:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)
",O(1)
"s=input()

while(1):
        if(len(s)==1):
                print(0)
                break

        elif(s==s[::-1]):

            s=s[1:]

        else:
            print(len(s))
            break",O(n)
"from sys import stdin,stdout

mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",O(n)
"class Solution(object):
    def maxOperations(self, nums):
        result = 1
        target = nums[0]+nums[1]
        for i in range(2, len(nums)-1, 2):
            if nums[i]+nums[i+1] != target:
                break
            result += 1
        return result",O(n)
"class Solution(object):
    def differenceOfSums(self, n, m):
        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
    
        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)",O(1)
"import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)
",O(n ^ 3)
"n, a, b, c, t = map(int, input().split())
l = list(map(int, input().split()))
f = [0] * 1001
for i in l: f[i] -= -1
tmp = 0
tmp2 = 0
for i in range(1, t):
    tmp += (t - i) * f[i]
tmp = n * a + tmp * c - tmp * b
print(max(n * a, tmp))",O(n)
"n, m = map(int, input().split())
a = [0 for i in range(n)]
l, r = 0, n - 1
m -= 1

for i in range(1, n + 1):
    cur = 2**(n - i - 1)

    if (m >= cur):
        m -= cur
        a[r] = i
        r -= 1
    else:
        a[l] = i
        l += 1

print(*a)
",np
"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:
    if len(problemSet) >= 2:
        total = sum(problemSet)
        myDelta = max(problemSet) - min(problemSet)
        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:
            return True
    return False

def countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:

    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:
        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):
            validSubsets.append(currentSubset)
        for i in range(nextElementIndex, len(problems)):
            currentSubset.append(problems[i])
            subsetBuilder(problems, currentSubset, i+1)
            currentSubset.pop(-1)

    index = 0
    currentSubset = []
    validSubsets = []

    subsetBuilder(problems, currentSubset, index)
    return len(validSubsets)

n, l, r, x = input().split()
n = int(n)
l = int(l)
r = int(r)
x = int(x)

probs = [int(prob) for prob in input().split()]

print(countValidSubsets(probs, l, r, x))
",np
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    sa=sorted(input(), reverse=True)
    na=len(sa)
    sb=input()
    nb=len(sb)
    if nb>na:
        print(''.join(sa))
        continue
    ans=''
    while sa:
        for i in range(len(sa)):
            new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:]))
            if int(new)<=int(sb):
                ans+=sa[i]
                sa.pop(i)
                break
    print(ans)",O(n ^ 3)
"import os,sys
from io import BytesIO,IOBase

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = [[0] for _ in range(500001)]
    freq,minus = [0]*500001,0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = [i[:] for i in nums]
    for i in range(500001):
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = [0]*500001,tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"import collections


class Solution(object):
    def countStudents(self, students, sandwiches):
        count = collections.Counter(students)
        for i, s in enumerate(sandwiches):
            if not count[s]:
                break
            count[s] -= 1
        else:
            i = len(sandwiches)
        return len(sandwiches)-i",O(n)
"class Solution2(object):
    list_head = None
    def flatten(self, root):
        if root:
            self.flatten(root.right)
            self.flatten(root.left)
            root.right = self.list_head
            root.left = None
            self.list_head = root",O(n)
"def f(l):
    n,m = l
    return ['5'*282,'4'*281+'5']

l = list(map(int,input().split()))
[print(r) for r in f(l)]
",O(1)
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

n, m, k1 = [int(x) for x in input().split()]

arr = [0 for i in range(n)]
for i in range(n):
    arr[i] = [int(x) for x in input().split()]

brr = [0 for i in range(n - 1)]
for i in range(n - 1):
    brr[i] = [int(x) for x in input().split()]

dp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)]

for k in range(1, 21):
    for i in range(n):
        for j in range(m):
                if k % 2:
                    dp[i][j][k] = -1
                else:
                    dp[i][j][k] = 10 ** 9
                    if i > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2)
                    if i < n - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2)
                    if j > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2)
                    if j < m - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2)

for i in range(n):
    for j in range(m):
        print(dp[i][j][k1],end="" "")
    print()
",O(n ^ 3)
"class Solution(object):
    def checkTwoChessboards(self, coordinate1, coordinate2):
        def parity(a):
            return reduce(lambda accu, x: (accu+x)%2, (ord(x) for x in a), 0)
        
        return parity(coordinate1) == parity(coordinate2)",O(1)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

n,k=kk()
pre,post = [],[]
k-=1
v = 1
for i in range(n-2,-1,-1):
	if k&(2**i):
		post.append(v)
	else:
		pre.append(v)
	v+=1
print(*pre,n,*reversed(post))",np
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from bisect import bisect_left as bsl
def main():
    cur=9;count=1;tot=0
    num=[];cc=[]
    for s in range(11):
        num.append(cur*count)
        tot+=cur
        cc.append(tot)
        cur*=10;count+=1
    ans=[num[0]]
    for s in range(1,11):
        ans.append(ans[-1]+num[s])
    k=int(input())
    ind=min(bsl(ans,k),10)
    left=k
    if ind>0:
        left-=ans[ind-1]

    nums=left//(ind+1);rem=left%(ind+1)
    if left%(ind+1)!=0:
        nums+=1
    if ind>0:
        nums+=cc[ind-1]
    answer=[int(k) for k in str(nums)]
    print(answer[rem-1])
main()",O(logn)
"from math import ceil
n, k = map(int, input().split())
cou = 0
cou += ceil(n*2/k)
cou += ceil(n*5/k)
cou += ceil(n*8/k)
print(cou)",O(1)
"n,m=[int(i) for i in input().split("" "")]
arrmv=[]
for i in range(n):
    arrmv.append([int(i) for i in input().split("" "")])
x=0
y=int(1e9+1)
sucls=[0,0]

tols=[]
mstr=""""

powls=[int(pow(2,i)) for i in range(10)]
twodarray=[0  for i in range(257)]
while x+1<y:
    mid = x+(y-x)//2

    for idx,ele in enumerate(twodarray):twodarray[idx]=0
    tols.clear()
    for topidx, eletop in enumerate(arrmv):
        tmp=0
        for idx,ele in enumerate(eletop):
            if ele>=mid:tmp+=powls[idx]

        if not twodarray[tmp]:

            twodarray[tmp]=1
            tols.append((tmp,topidx))
    sz=len(tols)
    suc=0
    no=int(pow(2,m))
    for i in range(sz):
        for j in range(i,sz):
            if tols[i][0] | tols[j][0] == no-1:
                sucls[0],sucls[1]=tols[i][1],tols[j][1]

                suc=1;
                break;
        if suc:break
    if suc:x=mid
    else:y=mid

print(sucls[0]+1,sucls[1]+1)
",np
"class Solution3(object):
    def singleNumber(self, nums):
        return list((collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys())[0]",O(n)
"n = int(input())

a = list(map(int, input().split()))

a.sort(reverse=True)

cnt = 0
while a:
    f = a.pop()
    rm = []
    for x in a:
        if x % f == 0:
            rm.append(x)
    for x in rm:
        a.remove(x)
    cnt += 1

print(cnt)
",O(n ^ 2)
"from itertools import combinations
num,min_dif,max_dif,easy_hard_dif=map(int, input().split("" ""))
arr=[int(m) for m in input().split("" "")]
all_combinations=[]
for x in range(2, num+1):
    combs=combinations(arr, x)
    for abc in combs:
        all_combinations.append(list(abc))
possible_answers=0
for a in all_combinations:
    if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif:
        possible_answers+=1
print(possible_answers)",np
"import heapq
n, k = map(int, input().split())
p = list(map(int, input().split()))
c = list(map(int, input().split()))
indexes = sorted(list(range(n)), key=p.__getitem__)
most_vyg_odn_yye = []
res = [1]*n
cur_res = 0
for ind in indexes:
	this_cost = c[ind]
	heapq.heappush(most_vyg_odn_yye, this_cost)
	cur_res += this_cost
	res[ind] = cur_res
	if len(most_vyg_odn_yye) > k:
		cur_res -= heapq.heappop(most_vyg_odn_yye)
print(*res)
",O(nlogn)
"n,s=map(int,input().split())
x=s//n
if x*n<s:
    x+=1
print(x)",O(1)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",O(n ^ 2)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution3(object):
    def sortEvenOdd(self, nums):
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums",O(nlogn)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"import sys

def second_largest(numbers):
    count = 0
    m1 = m2 = float('-inf')
    for x in numbers:
        count += 1
        if x > m2:
            if x >= m1:
                m1, m2 = x, m1
            else:
                m2 = x
    return m2 if count >= 2 else None

n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
firstMax = max(boys)
secondMax = second_largest(boys)
minGrills = min(girls)
minSum = 0
if firstMax > minGrills:
    print(-1)
    sys.exit()
elif firstMax == minGrills:
    minSum = m * (sum(boys) - firstMax) + sum(girls)
elif n == 1:
    print(-1)
    sys.exit()
else:
    minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax
print(minSum)
",O(n)
"class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        asteroids.sort()
        for x in asteroids:
            if x > mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True",O(nlogn)
"n,m=[int(x) for x in input().split()]
s=[]
for i in range(n):
    s.append(input())
mapp=[[False]*m for i in range(n)]

rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))

def gene(x,y,p):
    cx=x-rnd[p][0]
    cy=y-rnd[p][1]
    ans=[]
    for i in range(8):
        ans.append((cx+rnd[i][0],cy+rnd[i][1]))
    return ans
def judge(ps):
    for x,y in ps:
        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='
            continue
        else:
            return False
    return True
def dye(ps):
    global mapp
    for x,y in ps:
        mapp[x][y]=True
def check(x,y):
    for i in range(8):
        r=gene(x,y,i)
        if judge(r):
            dye(r)
            return True
    return False
for i in range(n):
    for j in range(m):
        if s[i][j]=='
            if check(i,j):
                continue
            else:
                print('NO')
                quit()
print('YES')",O(n ^ 2)
"class Solution2(object):
    def minimumTime(self, s):
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(range(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result",O(n)
"class Solution2(object):
    def diameterOfBinaryTree(self, root):
        def dfs(root):
            if not root: 
                return 0, 0
            left_d, left_h = dfs(root.left)
            right_d, right_h = dfs(root.right)
            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)
 
        return dfs(root)[0]",O(n)
"class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        left = [n]*n
        right = [-1]*n
        up = [-1]*n
        down = [n]*n
        for x, y in buildings:
            x -= 1
            y -= 1
            left[y] = min(left[y], x)
            right[y] = max(right[y], x)
            up[x] = max(up[x], y)
            down[x] = min(down[x], y) 
        return sum(left[y-1] < x-1 < right[y-1] and down[x-1] < y-1 < up[x-1] for x, y in buildings)",O(n)
"import collections


class Solution(object):
    def minWindow(self, s, t):
        count, remain = collections.Counter(t), len(t)
        i, left, right = 0, -1, -1
        for j, c in enumerate(s):
            remain -= count[c] > 0
            count[c] -= 1
            if remain:
                continue
            while count[s[i]] < 0: 
                count[s[i]] += 1
                i += 1
            if right == -1 or j-i+1 < right-left+1:
                left, right = i, j
        return s[left:right+1]",O(n)
"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        output = []
        q = deque()
        l = r = 0

        while r < len(nums):
            while q and nums[q[-1]] < nums[r]:
                q.pop()
            q.append(r)

            if l > q[0]:
                q.popleft()

            if (r + 1) >= k:
                output.append(nums[q[0]])
                l += 1
            r += 1

        return output
",O(n)
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))",O(nlogn)
"from collections import deque
from sys import stdin, stderr
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def signum(n):
    return 1 if n > 0 else 0 if n == 0 else -1

def range_includes(i, j):
    s = signum(j - i)
    return range(i, j + s, s)

def main():

    first = ints()
    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))
    minX = min(aCoord[0] for aCoord in aCoords)
    minY = min(aCoord[1] for aCoord in aCoords)
    maxX = max(aCoord[0] for aCoord in aCoords)
    maxY = max(aCoord[1] for aCoord in aCoords)
    def inFirst(x, y):
        return x >= minX and x <= maxX and y >= minY and y <= maxY

    second = ints()
    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))
    minSum = min(sum(bCoord) for bCoord in bCoords)
    maxSum = max(sum(bCoord) for bCoord in bCoords)
    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)
    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)
    def inSecond(x, y):
        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff

    for aCoord in aCoords:
        if inSecond(*aCoord):
            return True
    for i in range(-1, 3):
        c1 = bCoords[i]
        c2 = bCoords[i + 1]
        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):
            if inFirst(x, y):
                return True
    return False

if __name__ == '__main__':
    print(""YES"" if main() else ""NO"")
",O(1)
"class Solution2(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def dfs(u, p):
            left[u] = cnt[0]
            cnt[0] += 1
            for v in adj[u]:
                if v == p:
                    continue
                dfs(v, u)
                nums[u] ^= nums[v]
            right[u] = cnt[0]
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        cnt = [0]
        left = [0]*len(nums)
        right = [0]*len(nums)
        dfs(0, -1)
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"import math

def main():
    buf = input()
    n = int(buf)
    buf = input()
    buflist = buf.split()
    a = []
    for i, item in enumerate(buflist):
        a.append([i+1, int(item)])
    a = list(reversed(list(sorted(a, key = lambda x:x[1]))))
    one_deg_count = 0
    for i in a:
        if i[1] == 1:
            one_deg_count += 1
    if one_deg_count == len(a):
        if one_deg_count == 2:
            print(""YES"", 1)
            print(1)
            print(1, 2)
        else:
            print(""NO"")
        return
    elif one_deg_count == len(a) - 1:
        if one_deg_count <= a[0][1]:
            print(""YES"", 2)
            print(one_deg_count)
            for i in range(one_deg_count):
                print(a[0][0], a[-i-1][0])
        else:
            print(""NO"")
        return
    else:
        spare_edges = 2
        for i in range(len(a) - one_deg_count):
            spare_edges += a[i][1] - 2
        if spare_edges >= one_deg_count:
            diameter = len(a) - 1 - one_deg_count + min(one_deg_count, 2)
            edge_count = 0
            edge_list = []
            for i in range(len(a) - one_deg_count - 1):
                edge_list.append((a[i][0], a[i+1][0]))
            for i in range(len(a) - one_deg_count):
                a[i][1] -= 2
            if one_deg_count > 0:
                edge_list.append((a[0][0], a[-1][0]))
                one_deg_count -= 1
            if one_deg_count > 0:
                edge_list.append((a[-one_deg_count-2][0], a[-2][0]))
                one_deg_count -= 1
            idx = 0
            for i in range(one_deg_count):
                edge_list.append((a[idx][0], a[-i-3][0]))
                a[idx][1] -= 1
                if a[idx][1] <= 0:
                    idx += 1
            print(""YES"", diameter)
            print(len(edge_list))
            for i in edge_list:
                print(i[0], i[1])
        else:
            print(""NO"")

if __name__ == '__main__':
    main()
",O(nlogn)
"a = int(input())
b = list(map(int, input().split()))
c = [int(i % 2 == 0) for i in b]
if(c.count(1) == 1):
	print(c.index(1) + 1)
else:
	print(c.index(0) + 1)
",O(n)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",O(n ^ 3)
"class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)",O(n)
"import math
def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v
a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))
",O(1)
"import sys, math

def mp():
    return list(map(int, input().split()))

def ss(x):
    return x * (x + 1) // 2

def sol(x):
    if x == 0:
        return 0
    res = ss(x // 2) * 2
    res1 = ss(x) - res
    return res - res1

def main():
    q = int(input())
    for i in range(q):
        l, r = mp()
        print(sol(r) - sol(l - 1))

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()
",O(1)
"n, K = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
s = []
for a in A:
    if not s:
        s.append(a)
        continue
    while s:
        if a-K <= s[-1] < a:
            s.pop()
        else:
            break
    s.append(a)
print(len(s))
",O(nlogn)
"str=input()
n=len(str)
ans=0
amap={}
def fun():
    global ans
    for strLen in range(n,0,-1):
        mark=0
        for t in range(0,n):
            if t+strLen>n:
                break
            s=str[t:t+strLen]
            if s in amap:
                amap[s]+=1
            else:
                amap[s]=1
            if amap[s]>=2:
                mark=1
                ans=len(s)
                print(ans)
                break
        if mark==1:
            break
fun()
if ans==0:
    print(ans)",O(n ^ 3)
"t = int(input())
for i in range(t):
    n = int(input())
    arr = [int(x) for x in input().split()]
    arr.sort(reverse=True)
    print(min(arr[1] - 1, len(arr) - 2))",O(nlogn)
"class Solution(object):
    def checkStraightLine(self, coordinates):
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)",O(n)
"I=lambda:map(int,input().split())
n,s=I()
l=[0]
for i in range(n):
    q,w=I()
    q=q*60+w
    l+=[q]
if l[1]-l[0]>s:exit(print(0, 0))
for i in range(n):
    if l[i+1]-l[i]>2*s+1:
        l[i]+=s+1
        exit(print(l[i]//60,l[i]%60))
l[-1]+=s+1
print(l[-1]//60,l[-1]%60)",O(n)
"class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, min(i * 2 + 1, k + 1)):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np
"R = lambda : map(int, input().split())
n = int(input())
s = input()
hc, tc = s.count('H'), s.count('T')
hr = min([s[i:i + hc].count('T') for i in range(n - hc)])
tr = min([s[i:i + tc].count('H') for i in range(n - tc)])
print(min(hr, tr))",O(n)
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)
",O(n)
"def solve(N, A):
    cnt = [0] * (N + 1)

    evd = {}
    xs = []
    for a, b in A:
        if a not in evd:
            evd[a] = [0, 0]
            xs.append(a)
        if b not in evd:
            evd[b] = [0, 0]
            xs.append(b)

        evd[a][0] += 1
        evd[b][1] += 1

    xs.sort()

    px = xs[0] - 1
    pop = 0
    for x in xs:
        cnt[pop] += x - px - 1
        cnt[pop + evd[x][0]] += 1
        pop -= evd[x][1]
        pop += evd[x][0]
        px = x

    return cnt[1:]

def main():
    N = int(input())
    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]
    print(*solve(N, A))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i < j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)",O(n)
"class Solution(object):
    def countDistinct(self, s):
        count = 0
        trie = {}
        for i in range(len(s)):
            curr = trie
            for j in range(i, len(s)):
                if s[j] not in curr:
                    count += 1
                    curr[s[j]] = {}
                curr = curr[s[j]]
        return count",O(n ^ 2)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",O(n)
"N, M, K, L = map(int, input().split())
if N < M or K + L > N:
    print(-1)
else:
    print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",O(1)
"M=10**9+7
n=int(input())
a=[]
for i in range(n):
    a.append(input())
dp=[[0]*(n+5) for i in range(n+2)]
dp[0][0]=1
for i in range(1,n):
    count=0
    if a[i-1]=='f':
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                dp[i][j+1]=(dp[i][j+1]+dp[i-1][j])%M
    else:
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                count=(count+dp[i-1][j])%M
            dp[i][j]=(dp[i][j]+count)%M
print(sum(dp[n-1])%M)",O(n ^ 2)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)
",O(logn)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)

else:
    print(0)",O(1)
"import sys

maxN = 10**6 + 5
dp = [0] * maxN
b = [0] * maxN

N = int(sys.stdin.readline())
for _ in range(N):
    beacon = [int(x) for x in sys.stdin.readline().split()]
    b[beacon[0]] = beacon[1]

if b[0] > 0:
    dp[0] = 1

for i in range(1, maxN):
    if b[i] == 0:
        dp[i] = dp[i-1]
    else:
        if b[i] >= i:
            dp[i] = 1
        else:
            dp[i] = dp[i-b[i]-1]+1
print(N-max(dp))
",O(n)
"import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root",O(n)
"import sys, math

def mp():
    return list(map(int, input().split()))

def main():
    n, k = mp()
    a = [2, 5, 8]
    s = 0
    for i in a:
        s += (n * i - 1) // k + 1
    print(s)

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",O(1)
"from itertools import chain, combinations
def powerset(iterable):
    xs = list(iterable)

    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))
n,l,r,x=map(int,input().split())
sett=list(map(int,input().split()))
psett=powerset(sett)
count=0
for i in psett:
    k=sorted(i)
    j=sum(k)
    if j>=l and j<=r and k[-1]-k[0]>=x:
        count+=1
print(count)
",np
"class Solution(object):
    def zeroFilledSubarray(self, nums):
        result = 0
        prev = -1
        for i in range(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result",O(n)
"def iscomposite(value):
    for i in range(2,value):
        if(value%i==0):
            return '1'
    else:
        return '0'

n=int(input())
for i in range(4,n):
    a=i
    b=n-i
    if(iscomposite(a)=='1' and iscomposite(b)=='1'):
        print(a,b)
        break
    else:
        continue
",O(1)
"n = int(input())
r = 0
i = 2
while i*2 <=n:
	a = int(n/i)
	r += (a+2)*(a-2+1)/2
	i += 1
print(int(4*r))
",O(n)
"class Solution(object):
    def findWords(self, words):
        rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']),
                set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']),
                set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])]

        result = []
        for word in words:
            k = 0
            for i in range(len(rows)):
                if word[0].lower() in rows[i]:
                    k = i
                    break
            for c in word:
                if c.lower() not in rows[k]:
                    break
            else:
                result.append(word)
        return result",O(n)
"n = int(input())

arr = list(map(int, input().split(' ')))
arr.sort()

stop = 0
equal = -1
tempcounter = 0

for i in range(1, n):
    if arr[i] == arr[i-1]:
        equal = arr[i]
        tempcounter += 1
        if tempcounter == 2:
            break

if tempcounter == 1 and equal != 0:
    for j in range(n):
        if arr[j] == equal-1:
            print(""cslnb"")
            stop = 1

if tempcounter == 1 and equal == 0:
    print(""cslnb"")

elif tempcounter < 2 and stop == 0:
    moves = arr[0]
    counter = 0

    for i in range(1, n):
        moves += arr[i] - i

    if counter == 0:
        if moves%2 == 0:
            print(""cslnb"")

        else:
            print(""sjfnb"")

elif stop == 0:
    print(""cslnb"")
",O(nlogn)
"class Solution2(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[-1] = 0
        for i in reversed(range(len(nums))):
            for j in range(i, len(nums)):
                dp[i] = min(dp[i], prefix1[j+1]*(prefix2[j+1]-prefix2[i])+dp[j+1]+(k*(prefix2[-1]-prefix2[i])))
        return dp[0]",O(n ^ 2)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1

for _ in range(t):
    n,k = li()
    if k<=n:
        print((k-1)//2)
    else:
        print(max((2*n-k+1)//2,0))
",O(1)
"from sys import stdin, stdout

def dfs(l, r, dp, a_a):
    if l == r:
        return a_a[l]
    if l+1 == r:
        if a_a[l] == a_a[r]:
            return a_a[l] + 1
        else:
            return -1

    if dp[l][r] != 10**6:
        return dp[l][r]

    dp[l][r] = -1
    for m in range(l, r):
        r1 = dfs(l, m, dp, a_a)
        r2 = dfs(m+1, r, dp, a_a)
        if r1 > 0 and r1 == r2:
            dp[l][r] = r1 + 1
            return dp[l][r]

    return dp[l][r]

def array_shrinking(n, a_a):
    dp = [[10**6 for _ in range(n)]  for _ in range(n)]
    dp2 = [10**6 for _ in range(n)]
    for i in range(n):
        dp2[i] = min(i + 1, dp2[i])
        for j in range(i, n):
            r = dfs(i, j, dp, a_a)
            if r != -1:
                if i > 0:
                    dp2[j] = min(dp2[i-1] + 1, dp2[j])
                else:
                    dp2[j] = min(1, dp2[j])

    return dp2[n-1]

n = int(stdin.readline())
a_a = list(map(int, stdin.readline().split()))
res = array_shrinking(n, a_a)
stdout.write(str(res))
",O(n ^ 3)
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",O(n ^ 3)
"n = int(input())
l = tuple(map(int,input().split()))
r = tuple(map(int,input().split()))
s = [ (i,sum(v)) for i,(v) in enumerate(zip(l,r)) ]
ss = sorted(s, key= lambda a:a[1] )

candies = [0]*n
for p in ss:
    candies[p[0]] = n-p[1]

ll = [0]
for i in range(1,n):
    ll.append(sum([1 for c in candies[:i] if c > candies[i]]))

rr = [0]
for i in range(n-2,-1,-1):
    rr.append(sum([1 for c in candies[i:] if c > candies[i]]))

for i in range(n):
    if ll[i] != l[i]:
        print(""NO"")
        break
    if rr[n-1-i] != r[i]:
        print(""NO"")
        break
    if i == n-1:
        print(""YES"")
        print(' '.join(map(str,candies)))
",O(nlogn)
"class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \
                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):
                flowerbed[i] = 1
                n -= 1
            if n <= 0:
                return True
        return False",O(n)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n = int(z())
a = zzz()

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])
",O(nlogn)
"from sys import stdin
import collections
import copy
import math

n = int(stdin.readline())
m = int(stdin.readline())
up = list(map(int, stdin.readline().split()))
down = list(map(int, stdin.readline().split()))

def check(x):
    weight = m + x
    fuel = x
    for i in range(n):
        f = weight/up[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
        f = weight/down[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
    return True

l = 0
r = 1e9 + 1e-6

for ii in range(100):
    mid = (r + l)/2

    if(check(mid)):
        r = mid
    else:
        l = mid
    if r-l <= 1e-10:
        break
if l >= 1e9+ 1e-6:
    print(-1)
else:
    print(""%.10f"" %l)
",O(n)
"class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result",O(n)
"class Solution2(object):
    def heightOfTree(self, root):
        result = -1
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left and u.left.right != u:
                    new_q.append(u.left)
                if u.right and u.right.left != u:
                    new_q.append(u.right)
            q = new_q
            result += 1
        return result",O(n)
"class Solution(object):
    def licenseKeyFormatting(self, S, K):
        result = []
        for i in reversed(range(len(S))):
            if S[i] == '-':
                continue
            if len(result) % (K + 1) == K:
                result += '-'
            result += S[i].upper()
        return """".join(reversed(result))",O(n)
"r,g,b = list(map(int,input().split()))
dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]
ra = sorted(list(map(int,input().split())),reverse=True)
ga = sorted(list(map(int,input().split())),reverse=True)
ba = sorted(list(map(int,input().split())),reverse=True)

def solve(i,j,k) :

    if dp[i][j][k] != -1 :
        return dp[i][j][k]

    if i==r :
        if j==g or k==b :
            return 0
        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)

    elif j==g :
        if i==r or k==b:
            return 0
        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)

    elif k==b :
        if j==g or i==r:
            return 0
        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)

    else :
        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))

    return dp[i][j][k]

print(solve(0,0,0))",O(n ^ 3)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=1
    for _ in range(tc):
        n=ri()
        ans=[]
        i=1
        k=1
        t=0
        while True:
            k=i*i
            if k<=n:
                t=i
            else:
                break
            i+=1
        a=[]
        z=[]
        for i in range(n):
            z+=[i+1]
            if len(z)==t:
                a=z+a
                z=[]
        a=z+a
        wia(a)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr+=[0]*m
ans=0
pos=0
while arr[pos]!=0:
  page=(arr[pos]-pos-1)//k
  tmp=1
  for i in range(1,k):
    if pos+i>=2*m-1:
      break
    if (arr[pos+i]-pos-1)//k==page:
      tmp+=1
    else:
      break
  pos+=tmp
  ans+=1
print(ans)",O(n)
"reduced = 1
n, m ,k = map(int,input().split())

p = list(map(int, input().split()))

p.reverse()
cnt = 0
while(len(p)):

    cnt1 = 1
    first = p.pop()
    fack = ((first - reduced)//k) * k
    while(len(p) and p[-1] - fack - reduced < k):
        cnt1 += 1
        p.pop()

    reduced += cnt1
    cnt += 1
print(cnt)",O(n)
"n, s = map(int, input().split())
x, y = divmod(s, 9)
if not s:
	x = 0
elif y:
	x += 1
low = x*9
for i in range(low, low+10000):
	if i - sum([int(c) for c in str(i)]) >= s:
		low = i
		break
print(max(n-low+1, 0))
",O(logn)
"n, k = map(int, input().split())
a, b, c = 2 * n, 5 * n, 8 * n
ceil = lambda x, y: (x + y - 1) // y
print(ceil(a, k) + ceil(b, k) + ceil(c, k))
",O(1)
"class Solution(object):
    def countSegments(self, s):
        result = int(len(s) and s[-1] != ' ')
        for i in range(1, len(s)):
            if s[i] == ' ' and s[i-1] != ' ':
                result += 1
        return result

    def countSegments2(self, s):
        return len([i for i in s.strip().split(' ') if i])",O(n)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    q = I()
    rr = []

    def f(a,b,c,d):
        if a > c or b > d:
            return (0,0)
        sa = c-a + 1
        sb = d-b + 1
        g = h = (sa * sb) // 2
        if (sa*sb) % 2 == 1:
            g += 1

        if (a+b) % 2 == 0:
            return (g,h)
        return (h,g)

    def fa(a):
        return f(a[0],a[1],a[2],a[3])

    for _ in range(q):
        n,m = LI()
        wa = LI()
        ba = LI()
        wc,bc = f(1,1,n,m)
        w1,b1 = fa(wa)
        w2,b2 = fa(ba)
        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))

        wc += b1
        bc -= b1
        wc -= w2
        bc += w2
        wc -= b3
        bc += b3
        rr.append('{} {}'.format(wc,bc))

    return ""\n"".join(map(str,rr))

print(main())
",O(1)
"class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])",O(n)
"n=int(input())
g={}
for i in range(1,n):
    p=int(input())
    if g.get(p):g[p].append(i+1)
    else:g[p]=[i+1]
ams='YES'
for i in g:
    c=0
    for j in g[i]:
        if j not in g:c+=1
    if c<3:ams='NO'
print(ams)",O(n)
"from collections import defaultdict
from sys import stdout,stdin
n,m,K=map(int,input().split())
dp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]
l1=[list(map(int,stdin.readline().split())) for i in range(n)]
l2=[list(map(int,stdin.readline().split())) for i in range(n-1)]
if K%2:
    for i in range(n):
        for j in range(m):
            print('-1',end=' ')
        print()
else:
    for k in range(1,K//2+1):
     for i in range(n):
        for j in range(m):
                res=100000000
                if i-1>=0 and j>=0:
                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])
                if i+1<n and j>=0:
                     res=min(res,l2[i][j]+dp[i+1][j][k-1])
                if 0<=i and j+1<m:
                     res=min(res,l1[i][j]+dp[i][j+1][k-1])
                if 0<=i and j-1>=0:
                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])
                dp[i][j][k]=res
    for i in range(n):
        for j in range(m):
            stdout.write(str(2*dp[i][j][K//2])+' ')
        stdout.write('\n')",O(n ^ 3)
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",O(n ^ 3)
"R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse=True)
g = sorted([int(x) for x in input().split()], reverse=True)
b = sorted([int(x) for x in input().split()], reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"class Solution2(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        color = collections.defaultdict(int)
        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        q1 = collections.deque()
        q2 = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q1.append((HOLE, i, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q2.append((i, i, t))
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        while q2:
            i, j, t = q2.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == MOUSE:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE]",O(n ^ 3)
"import sys, string

n, m = map(int, sys.stdin.readline().split())
print('4' * 2229)
print('5' * 2228 + '6')",O(1)
"class Solution(object):
    def subarraySum(self, nums):
        diff = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            diff[max(i-x, 0)] += 1
            diff[i+1] -= 1
        for i in range(len(nums)):
            diff[i+1] += diff[i]
        return sum(nums[i]*diff[i] for i in range(len(nums)))",O(n)
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        carry = 0
        res = 0
        mask = 0xFFFFFFFF

        for i in range(32):
            a_bit = (a >> i) & 1
            b_bit = (b >> i) & 1
            cur_bit = a_bit ^ b_bit ^ carry
            carry = (a_bit + b_bit + carry) >= 2
            if cur_bit:
                res |= (1 << i)

        if res > 0x7FFFFFFF:
            res = ~(res ^ mask)

        return res
",O(1)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n=int(input())
if n<=5:
    print(-1)
else:
    for i in range(2,5):
        print(1,i)
    for i in range(5,n+1):
        print(2,i)
for i in range(2,n+1):
    print(1,i)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self, root):
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        return target in self.__lookup",O(n)
"n,r = map(int,input().split())
x_coord = list(map(int,input().split()))
d = {}
for i in x_coord:
    final = r

    for j in range(i-r,i+r+1):
        check = d.get(j,[-1,-1])
        if check[0] > 0:
            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5
            final = max(potential,final)
    for j in range(i-r,i+r+1):
        d[j] = (i,final)
    print(final)",O(n ^ 2)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        for i in range(n):
            prod = 1
            for j in range(n):
                if i == j:
                    continue
                prod *= nums[j]

            res[i] = prod
        return res
",O(n ^ 2)
"l = []
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
l.sort()
path = []
path.append(l[0])
x = l[0][0]
while(x<l[1][0]):
	path.append((x, l[0][1]))
	x = x + 1
up = False
if(l[0][1]<l[1][1]):

	up = True
if(up):
	y = l[0][1]
	while(y<=l[1][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[0][1]
	while(y>=l[1][1]):
		path.append((l[1][0], y))
		y = y-1
up = False
if(l[1][1]<l[2][1]):
	up = True
if(up):
	y = l[1][1]
	while(y<=l[2][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[1][1]
	while(y>=l[2][1]):
		path.append((l[1][0], y))
		y = y-1
x = l[1][0]
while(x<l[2][0]):
	path.append((x, l[2][1]))
	x = x + 1
path.append(l[2])
path = list(set(path))
print(len(path))
for i in range(len(path)):
	print(str(path[i][0])+"" ""+str(path[i][1]))
",O(1)
"class Solution2(object):
    def minSideJumps(self, obstacles):
        dp = [1, 0, 1]        
        for i in obstacles:
            if i:
                dp[i-1] = float(""inf"")
            for j in range(3):
                if j+1 != i:
                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))
        return min(dp)",O(n)
"def factorial(n):
    result = 1
    for i in range(2, n+1):
        result *= i
    return result

commands = input().strip()
received = input().strip()
n = len(commands)
positive = 0
negative = 0
count = 0
for i in range(n):
    if commands[i] == ""+"":
        positive += 1
    else:
        negative += 1
    if received[i] == ""+"":
        positive -= 1
    elif received[i] == ""-"":
        negative -= 1
    else:
        count += 1
cases = 2**count
probability = 0.0
if positive >= 0 and negative >= 0:
    probability = (factorial(count)/(factorial(positive)*factorial(negative)))/cases

print(""{0:.9f}"".format(probability))",np
"def main():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())

    l = 1
    r = n + 1

    while r - l != 1:
        m = l + r >> 1
        candies = m * (m + 1) // 2
        eat = n - m

        if candies - eat <= k:
            l = m
        else:
            r = m

    print(n - l)

    return 0

main()",O(logn)
"n = int(input())
l = list(map(int, input().split("" "")))
r = list(map(int, input().split("" "")))

slr = [l[i]+r[i] for i in range(n)]
ans = [n-slr[i] for i in range(n)]

flag = True
if l[0]!=0 or r[n-1]!=0:
	flag= False

for i in range(n):
	great = 0
	for j in range(i+1, n):
		if ans[i]<ans[j]:
			great = great + 1
	if r[i]!=great:
		flag = False
		break
for i in range(n-1, -1, -1):
	great = 0
	for j in range(i-1, -1, -1):
		if ans[i]<ans[j]:
			great = great + 1
	if l[i]!=great:
		flag = False
		break

if flag:
	print(""YES"")
	for i in range(0, n-1):
		print(ans[i], end="" "")
	print(ans[n-1])
else:
	print(""NO"")
",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current",O(n)
"import collections



class Solution(object):
    def maximumTotalDamage(self, power):
        DIST = 2
        power.sort()
        dp = collections.deque()
        mx = 0
        for x in power:
            if dp and dp[-1][0] == x:
                dp[-1][1] += x
                continue
            while dp and dp[0][0]+DIST < x:
                mx = max(mx, dp.popleft()[1])
            dp.append([x, mx+x])
        return max(x for _, x in dp)",O(nlogn)
"class Solution(object):
    def largeGroupPositions(self, S):
        result = []
        i = 0
        for j in range(len(S)):
            if j == len(S)-1 or S[j] != S[j+1]:
                if j-i+1 >= 3:
                    result.append([i, j])
                i = j+1
        return result",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n=int(input())
    s=list(input().strip())
    t=list(input().strip())
    res=True
    ans=[]
    for i in range(n):
        if s[i]==t[i]:
            continue
        else:
            ind=-1
            for j in range(i+1,n):
                if t[i]==s[j]:
                    ind=j
                    break
            if ind==-1:
                res=False
                break
            for j in range(ind-1,i-1,-1):
                ans.append(j+1)
                s[j],s[j+1]=s[j+1],s[j]
    if res:
        print(len(ans))
        print(*ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"def numtostr(a):
    var=[]
    while a>0:

       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)

def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)

        if par==0:
            break
        par -= 1
    return result

def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result

def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))

i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",O(n)
"class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

import collections",O(n)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",O(n ^ 2)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

def isin( x,y, M):
    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:
        return True
    return False

for _ in range(T):
    N, M = getIntList()
    m1 = getIntList()
    m2 = getIntList()
    zx = [0, M]
    zx += [m1[0]-1, m1[2]]
    zx += [m2[0]-1, m2[2]]
    zx.sort()
    zy = [0, N]
    zy += [m1[1]-1, m1[3]]
    zy += [m2[1]-1, m2[3]]
    zy.sort()
    totB = 0
    for i0 in range(5):
        if zx[i0] == zx[i0+1]: continue
        for i1 in range(5):
            if zy[i1] == zy[i1+1]: continue

            x0 = zx[i0]+1
            y0 = zy[i1]+1
            dprint('x0,y0', x0,y0)
            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1])
            if isin(x0,y0, m2):
                dprint('black')
                totB += size
            elif isin(x0,y0, m1):
                dprint('white')
                pass
            else:
                totB+= size//2
                if size%2==1:
                    if (x0+y0)%2==1:
                        dprint('extra black')
                        totB+=1
    print(N*M - totB, totB)
",O(1)
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break
",np
"n,k=map(int,input().split())

ar=[-1 for i in range(256)]
ls=list(map(int,input().split()))

for e in ls:
    if ar[e]==-1:
        tmp=max(0,e-k+1)
        for i in range(tmp,e+1):
            if ar[i]!=-1 and ar[i]!=i:
                tmp+=1
                continue
            else:
                while i<=e:
                    ar[i]=tmp
                    i+=1
    print(ar[e],end="" "")
",O(n ^ 2)
"class Solution2(object):
    def getLonelyNodes(self, root):
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result",O(n)
"import sys
import copy
input = sys.stdin.readline

n,k=map(int,input().split())
C=list(input().strip())

def JUDGE(C):
    ANS_one=0
    ANS_zero=0

    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break

    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break

    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0

if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()

if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()

CAN1=copy.copy(C)
CAN2=copy.copy(C)

if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""

if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""

if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()
",O(n)
"n, MOD = map(int, input().split())

pascal = [[1]]
for _ in range(500):
    nl = [1]
    for i in range(_):
        nl.append((pascal[-1][i] + pascal[-1][i+1]) % MOD)
    nl.append(1)
    pascal.append(nl)

mod_mul = lambda x, y: (x * y) % MOD

import __pypy__

int_add = __pypy__.intop.int_add
int_sub = __pypy__.intop.int_sub
int_mul = __pypy__.intop.int_mul

def make_mod_mul(mod=MOD):
    fmod_inv = 1.0 / mod

    def mod_mul(a, b, c=0):
        res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c)))
        if res >= mod:
            return res - mod
        elif res < 0:
            return res + mod
        else:
            return res

    return mod_mul

mod_mul = make_mod_mul()

def mod_pow(x, y):
    if y == 0:
        return 1
    res = 1
    while y > 1:
        if y & 1 == 1:
            res = mod_mul(res, x)
        x = mod_mul(x, x)
        y >>= 1
    return mod_mul(res, x)

base = [0] * (n + 1)

dp = []
for i in range(n):
    nex = base[:]
    nex[1] = mod_pow(2, i)
    for j in range(i - 1):
        bl = i-j-1
        assert bl > 0
        mul = mod_pow(2, bl - 1)
        for k in range(n):
            ct = 2 + j - k
            if ct < 0:
                assert dp[j][k] == 0
                continue
            mulr = mod_mul(mul, pascal[bl+ct][ct])
            nex[k+1] += mod_mul(mulr, dp[j][k])
            nex[k+1] %= MOD
    dp.append(nex)
print(sum(dp[-1]) % MOD)
",O(n ^ 3)
"from sys import stdin
from collections import deque
c=int(stdin.readline().strip())
for cas in range(c):
    n,m=map(int,stdin.readline().strip().split())
    s=deque(stdin.readline().strip())
    arr=[""R"",""G"",""B""]
    ans=n+3
    for k in range(1):

        for  i in range(3):
            x=i

            dp=[0 for i in range(n+1)]
            for j in range(n):

                if s[j]!=arr[x]:
                    dp[j+1]+=1
                dp[j+1]+=dp[j]
                if j+1>=m:

                    ans=min(ans,dp[j+1]-dp[j+1-m])
                x+=1
                x=x%3

    print(ans)

1
",O(n)
"import sys

n,k = map(int, input().split())
k -= 1
lo,hi = 0,int(1e9)
while lo < hi:
	m = (lo + hi + 1) // 2
	if 1 + k*(k+1)//2 - m*(m+1)//2 >= n:
		lo = m;
	else:
		hi = m - 1
if 1 + k*(k+1)//2 - lo*(lo+1)//2 >= n:
	lo = k - lo
else:
	lo = -1
print(lo)",O(logn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"class Solution(object):
    def maximumImportance(self, n, roads):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        inplace_counting_sort(degree)
        return sum(i*x for i, x in enumerate(degree, 1))",O(n)
"n, M = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

a.insert(0, 0)
n += 1

lit = [0] * (n + 1)
for i in range(1, n):
    if i % 2 == 0:
        lit[i] = lit[i - 1]
    else:
        lit[i] = lit[i - 1] + a[i] - a[i - 1]
if n % 2 == 0:
    lit[n] = lit[n - 1]
else:
    lit[n] = lit[n - 1] + M - a[n - 1]

ans = lit[n]
for i in range(n):
    pre_lit = lit[i]
    post_lit = M - a[i] - (lit[n] - lit[i])

    if i > 0 and a[i - 1] + 1 < a[i]:
        if i % 2 == 0:
            ans = max(ans, pre_lit + 1 + post_lit)
        else:
            ans = max(ans, pre_lit - 1 + post_lit)
    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):
        if i % 2 == 0:
            ans = max(ans, pre_lit + post_lit + 1)
        else:
            ans = max(ans, pre_lit + post_lit - 1)
print(ans)",O(n)
"class Solution(object):
    def longestConsecutive(self, root):
        self.max_len = 0

        def longestConsecutiveHelper(root):
            if not root:
                return 0

            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)

            cur_len = 1
            if root.left and root.left.val == root.val + 1:
                cur_len = max(cur_len, left_len + 1)
            if root.right and root.right.val == root.val + 1:
                cur_len = max(cur_len, right_len + 1)

            self.max_len = max(self.max_len, cur_len)

            return cur_len

        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"vals=list(map(int,input().split()))
l=vals[0]
r=vals[1]

if l==r:
    print(""0"")
else:
    i=0
    j=0
    while l>0 or r>0:
        i+=1
        if (l&1)^(r&1)==1:
            j=i
        l=l>>1
        r=r>>1
    ans=1
    for i in range(0,j):
        ans=ans*2
    ans-=1
    print(ans)",O(logn)
"t = int(input())

def getcol(x1, y1, x2, y2):
    dx = max((x2-x1+1), 0)
    dy = max((y2-y1+1), 0)
    b = w = dx*dy//2
    if dx % 2 and dy % 2:
        if (x1+y1) % 2:
            b = b + 1
        else:
            w = w + 1
    return w, b

for _ in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    w, b = getcol(1,1,n,m)
    w1, b1 = getcol(x1,y1,x2,y2)
    w2, b2 = getcol(x3,y3,x4,y4)
    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))
    woff = w-w1-w2+w3
    boff = b-b1-b2+b3
    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)
",O(1)
"import collections



class Solution2(object):
    def minCost(self, nums, x):
        def cost(k):
            w = k+1
            result = x*k
            dq = collections.deque()
            for i in range(len(nums)+w-1):
                if dq and i-dq[0] == w:
                    dq.popleft()
                while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]:
                    dq.pop()
                dq.append(i)
                if i >= w-1:
                    result += nums[dq[0]%len(nums)]
            return result

        def check(x):
            return cost(x) <= cost(x+1)

        left, right = 0, len(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return cost(left)",O(nlogn)
"n, k = map(int, input().split())
l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if m * (m + 1) // 2 - (n - m) > k:
        r = m
    else:
        l = m
print(n - l)",O(logn)
"class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left, right = 1, x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x / mid:
                right = mid - 1
            else:
                left = mid + 1

        return left - 1",O(logn)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"x2=input()
x=x2.split(' ')
n=int(x[0])
k=int(x[1])
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2
	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)
",O(logn)
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
",O(n ^ 2)
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque

def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)]
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))

main()",O(n ^ 3)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
abc = [inpl() for _ in range(m)]

def sol(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return all(seen)

def sol2(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    tps = [-1]*n; T = 0
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        tps[v] = T; T += 1
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return tps

ok = 10**9+10; ng = -1
while abs(ok-ng)>1:
    mid = (ok+ng)//2
    if sol(mid): ok = mid
    else: ng = mid

res = []
tps = sol2(ok)
for i,(a,b,c) in enumerate(abc):
    if c <= ok:
        if tps[a-1] > tps[b-1]: res.append(i+1)
print(ok,len(res))
print(*res)",O(nlogn)
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        stack = []
        res = 0

        for i in range(len(height)):
            while stack and height[i] >= height[stack[-1]]:
                mid = height[stack.pop()]
                if stack:
                    right = height[i]
                    left = height[stack[-1]]
                    h = min(right, left) - mid
                    w = i - stack[-1] - 1
                    res += h * w
            stack.append(i)
        return res
",O(n)
"import sys
import math

fileoperation=0
if(fileoperation):
    orig_stdout = sys.stdout
    orig_stdin = sys.stdin
    inputfile = open('W:/Competitive Programming/input.txt', 'r')
    outputfile = open('W:/Competitive Programming/output.txt', 'w')
    sys.stdin = inputfile
    sys.stdout = outputfile

mod=1000000007

def nospace(l):
    ans=''.join(str(i) for i in l)
    return ans

t=1
for tt in range(t):
    n=int(input())

    a=list(map(int,sys.stdin.readline().split(' ')))
    a.sort()

    i=0
    ans=0
    while i<len(a):
        if a[i]:
            ans+=1
            j=i+1
            while j<n:
                if(a[j]%a[i]==0):
                    a[j]=0
                j+=1
        i+=1
    print(ans)

if(fileoperation):
    sys.stdout = orig_stdout
    sys.stdin = orig_stdin
    inputfile.close()
    outputfile.close()",O(n ^ 2)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    x = 2 * n - 1
    ans = x
    x -= 2
    curr = 0
    while x > 0:
        curr += x
        x -= 2
    print(ans + 2 * curr)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array(): return list(map(int, sys.stdin.readline().split()))

def get_ints(): return map(int, sys.stdin.readline().split())

def input(): return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)

    def hasNext(self):
        return self.__stk

    def __next__(self):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        return node.val
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",O(1)
"class Solution(object):
    def findContentChildren(self, g, s):
        g.sort()
        s.sort()

        result, i = 0, 0
        for j in range(len(s)):
            if i == len(g):
                break
            if s[j] >= g[i]:
                result += 1
                i += 1
        return result",O(nlogn)
"def nine(p) :

    s=''
    for i in range(p) :
        s+='9'
    return int(s)
def prosh(p) :
    ans=0
    for i in range(1,p+1) :
        ans+=nine(i)*9
    return ans

n,k=map(int,input().split())
l=[0]*29
for i in range(19) :

    e=nine(19-i)

    l[i]=int(k/e)

    k-=l[i]*e

    if k<=0 :

        break
    if i==18  or k%e>prosh(19-i-1) :

        l[i]+=1
        break
otv=0
for i in range(19) :

    otv+=10**(19-i)*l[i]

print(max(n-otv+1,0))
",O(logn)
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
a=a[::-1]
c=[0]*n
bk=[]
for i in range(n):
    co=0
    if c[b[i]-1]==0:
        while a[-1]!=b[i]:
            co+=1
            c[a[-1]-1]=1
            a.pop()
        co+=1
        c[a[-1]-1]=1
        a.pop()
    bk.append(co)
print(*bk)
",O(n)
"n, s = map(int, input().split())

a, b, c = 0, n + 1, 0

while a < b:
    c = (a + b) // 2
    if c - sum([int(x) for x in str(c)]) < s:
        a = c + 1
    else:
        b = c

print(n - b + 1)",O(logn)
"n=int(input())
c=[0]*4
for k in range(4):
 for i in range(n):
  s=input()
  for j in range(n):
   if(i+j)%2!=int(s[j]):c[k]+=1
 if k<3:input()
c.sort()
print(c[0]+c[1]+2*n*n-c[2]-c[3])
",O(n ^ 2)
"n = int(input())
melody = [int(x) for x in input().split()]
ref = [[-1] * 5 for _ in range(n)]
can_finish = [[False] * 5 for _ in range(n)]
can_finish[0] = [True] * 5

for idx, key in enumerate(melody[:-1]):
    if not any(can_finish[idx]):
        break
    for finger in range(5):
        if melody[idx] < melody[idx + 1] and can_finish[idx][finger]:
            for i in range(finger + 1, 5):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
            break
        elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0:
            for i in range(finger):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
        elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]:
            tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger]
            can_finish[idx + 1] = [True] * 5
            ref[idx + 1] = [finger] * 5
            can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref

finger = next((i for i in range(5) if can_finish[n - 1][i]), None)
if finger is None:
    print(-1)
else:
    seq = [finger]
    for i in range(n - 1, 0, -1):
        finger = ref[i][finger]
        seq.append(finger)
    print(' '.join(str(x + 1) for x in seq[::-1]))
",O(n ^ 2)
"class Solution(object):
    def similarRGB(self, color):
        def rounding(color):
            q, r = divmod(int(color, 16), 17)
            if r > 8: q += 1
            return '{:02x}'.format(17*q)

        return 
                rounding(color[1:3]) + \
                rounding(color[3:5]) + \
                rounding(color[5:7])",O(1)
"n,k = list(map(int,input().split()))
start = k-1
end = 1

def bsearch(start,end):
    if start<end:
        return start
    else:
        mid = start-(start-end)//2
        val = ((k-1)*k//2) - ((mid-1)*mid//2) +1
        if val==n:
            return mid
        elif val>n:
            end = mid+1
        else:
            start = mid-1
        return bsearch(start,end)

ans = bsearch(start,end)

if ans == 0:
    print(-1)
elif n==1:
    print(0)
else:
    print(k-ans)
",O(logn)
"import heapq




class Solution3(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        result = 0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        while target:
            x = -heapq.heappop(max_heap)
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                heapq.heappush(max_heap, -x//2)
                heapq.heappush(max_heap, -x//2)
                result += 1
        return result",O(nlogn)
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m

def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)

_main()",O(logn)
"a, b = map(int, input().split())
c = input()
su = 0
cnt = 0
j = -2
i = 0
lis = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and cnt < b:
    if lis[i] in c and i-2 >= j:
        su += i+1
        cnt += 1
        j = i
    i += 1
if cnt < b:
    print(-1)
else:
    print(su)
",O(n)
"(x, y, z, t1, t2, t3) = map(int, input().split())

if 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"n, k = list(map(int, input().strip().split()))
arr = list(map(int, input().strip().split()))
k -= 1
arr_new = sorted([arr[i+1]-arr[i] for i in range(n-1)], reverse=True)
print(arr[-1]-arr[0]-sum(arr_new[:k]))
",O(nlogn)
"import math
import sys
from decimal import Decimal

def main(l,r):

  if l==r:
    return 0

  val=1

  while val*2<=r:
    val*=2

  if val<=l:
    return main(l-val,r-val)
  else:
    return 2*val-1

l,r=list(map(int,input().split()))
print(main(l,r))
",O(logn)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"def cnt(s,t):
    i,c=0,0
    while(s.count(t)):
        s=s[s[i:].index(t)+1:]
        c+=1
    return c
s=(input())
n=len(s)
ln=0
for i in range(n):
    for j in range(i,n):
        if(j-i+1<=ln):
            continue
        if(cnt(s,s[i:j+1])>=2):
            ln=max(ln,j-i+1)
print(ln)
",O(n ^ 3)
"class Solution(object):
    def circularArrayLoop(self, nums):
        def next_index(nums, i):
            return (i + nums[i]) % len(nums)

        for i in range(len(nums)):
            if nums[i] == 0:
                continue

            slow, fast = i, i
            while nums[next_index(nums, slow)] * nums[i] > 0 and \
                  nums[next_index(nums, fast)] * nums[i] > 0 and \
                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:
                slow = next_index(nums, slow)
                fast = next_index(nums, next_index(nums, fast))
                if slow == fast:
                    if slow == next_index(nums, slow):
                        break
                    return True

            slow, val = i, nums[i]
            while nums[slow] * val > 0:
                tmp = next_index(nums, slow)
                nums[slow] = 0
                slow = tmp

        return False",O(n)
"import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1",O(n ^ 2)
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
",O(n ^ 2)
"from math import sin, pi

n, r = map(int, input().split())

print(r * sin(pi / n) / (1 - sin(pi / n)))
",O(1)
"l, r = [int(x) for x in input().split()]

r = bin(r)[2:]
l = bin(l)[2:]

r = r[::-1]
l = l[::-1]

if l == r:
    print(0)
else:

    l += '0' * (len(r) - len(l))
    p = -1
    for i in range(len(r)):
        if r[i] != l[i]:
            p = i

    a = '1' * p + '0'
    b = '0' * p + '1'

    print(int(a, 2) ^ int(b, 2))
",O(logn)
"index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total

r = index % (n)
k = index // n

number = last + k

if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",O(logn)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i] == target:
                return i
        return -1
",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos

n, m, k, l = map(int, stdin.readline().split())

lb, rb = 0, n // m + 1
while rb - lb > 1:
    mid = (lb + rb) >> 1

    if mid * m - k >= l:
        rb = mid
    else:
        lb = mid

if lb != n // m:
    stdout.write(str(rb))
else:
    stdout.write('-1')",O(logn)
"import sys

class ADIYWoodenLadder:
    def solve(self):
        t = int(input())
        for _ in range(t):
            n = int(input())
            a = [int(_) for _ in input().split()]
            a.sort()
            print(min(a[-2] - 1, n - 2))

solver = ADIYWoodenLadder()
input = sys.stdin.readline

solver.solve()
",O(nlogn)
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",O(logn)
"l=list(map(int,input().split()))
l.sort()
x1=l[0]
x2=l[1]
x3=l[2]
if l[0]==1 or (l[0]==2 and l[1]==4 and l[2]==4) or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==2):
    print(""YES"")
else:
    print(""NO"")",O(1)
"a, b, c, n= map(int, input().split())
p = a + b - c
if p <= n-1 and a - c >= 0 and b - c >= 0:
    print(n - p)
else :
    print(-1)
",O(1)
"class Solution(object):
    def confusingNumber(self, N):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        
        S = str(N)
        result = []
        for i in range(len(S)):
            if S[i] not in lookup:
                return False
        for i in range((len(S)+1)//2):
            if S[i] != lookup[S[-(i+1)]]:
                return True
        return False",O(logn)
"n, k = map(int, input().split())

strr = """"
while len(strr) < n:
    strr += ""0"" * ((n-k) // 2) + ""1""
strr = strr[:n]
print(strr)",O(n)
"import io
import os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

endpoints = []

for x in range(n):
    p, w = map(int, input().split())
    endpoints.append([p-w, p+w])

endpoints.sort(key=lambda sublist: sublist[1])

res = 0

bottom = 10**18 * -1

for pt in range(len(endpoints)):
    if endpoints[pt][0] >= bottom:
        res += 1
        bottom = endpoints[pt][1]

print(res)
",O(nlogn)
"n, m, k = map(int, input().split())

a = list(map(int, input().split()))

best = 0
dp = [0] * (n + 1)
for i in range(n):
    b2 = 0
    for j in range(max(-1, i - m), i + 1):
        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))
    dp[i] = max(b2, a[i] - k)
    best = max(best, dp[i])

print(best)
",O(n ^ 2)
"from collections import deque as de
import math
import re
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def dupconscount(nums):
    element = []
    freque = []
    if not nums:
        return element
    running_count = 1
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            running_count += 1
        else:
            freque.append(running_count)
            element.append(nums[i])
            running_count = 1
    freque.append(running_count)
    element.append(nums[i+1])
    return element,freque

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indic():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic

n,p=di()
a=li()
fir=a[0]
sec=sum(a)-fir
ans=(fir%p)+(sec%p)
for i in range(1,n):
    fir+=a[i]
    sec-=a[i]
    temp=(fir%p)+(sec%p)
    if temp >ans:
        ans=temp
print(ans)
",O(n)
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)
    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]
for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx
for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:print(""NO"");exit()

    graph[idx] += [idx_to for idx_to in idxs if idx != idx_to]
flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)
",O(1)
"n, m = map(int, input().split())
dist = [int(x) for x in input().split()]
taxi = [int(x) for x in input().split()]
dists = {}
d = []
for person in range(len(taxi)):
    if taxi[person]:
        dists[dist[person]] = 0
        d.append(dist[person])
start = 0
d.append(10**11)
for person in range(len(taxi)):
    if taxi[person] == 0:
        while dist[person] > d[start + 1]:
            start += 1
        if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]):
            dists[d[start]] += 1
        else:
            dists[d[start + 1]] += 1
for d in dists:
    print(dists[d] if d!=10**11 else '', end=' ')
",O(n)
"import sys
from math import floor

if __name__ == '__main__':

    entrada = input()
    entrada_str = list(entrada.split("" ""))
    entrada_int = list(map(int, entrada_str))

    a = entrada_int[0]
    b = entrada_int[1]

    if a == b:
        print(0)
        sys.exit()

    string_1 = """"
    string_2 = """"
    while a:
        if a%2 == 0:
            string_1 = string_1 + ""0""
        else:
            string_1 = string_1 + ""1""
        a = floor(a/2)

    while b:
        if b%2 == 0:
            string_2 = string_2 + ""0""
        else:
            string_2 = string_2 + ""1""
        b = floor(b/2)

    lista_1 = list(string_1)
    lista_1.reverse()
    contrario_1 = """".join(lista_1)

    lista_2 = list(string_2)
    lista_2.reverse()
    contrario_2 = """".join(lista_2)

    if len(string_1) != len(string_2):
        resposta = pow(2, len(string_2)) - 1
    else:
        potencia = 0
        for i in range(len(string_1)):
            if contrario_1[i] != contrario_2[i]:
                break
            potencia += 1

        potencia = len(string_1) - potencia
        resposta = pow(2, potencia)-1

    print(resposta)
",O(logn)
"import itertools
import re


class Solution(object):
    def summaryRanges(self, nums):
        ranges = []
        if not nums:
            return ranges

        start, end = nums[0], nums[0]
        for i in range(1, len(nums) + 1):
            if i < len(nums) and nums[i] == end + 1:
                end = nums[i]
            else:
                interval = str(start)
                if start != end:
                    interval += ""->"" + str(end)
                ranges.append(interval)
                if i < len(nums):
                    start = end = nums[i]

        return ranges",O(n)
"class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True",O(n)
"class Solution2(object):
    def minimumSteps(self, s):
        result = 0
        left, right = 0, len(s)-1
        while left < right:
            if left < len(s) and s[left] != '1':
                left += 1
                continue
            if right >= 0 and s[right] != '0':
                right -= 1
                continue
            result += right-left
            left += 1
            right -= 1
        return result",O(n)
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase

def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)

def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res

def inar():
    return [int(k) for k in input().split()]

def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp

    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)
",O(nlogn)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"n,k = map(int,input().split(' '))

arr = [n];
k = k+1
z = 1000000007
c = (n*pow(2,k,z)-pow(2,k-1,z)+1)%z
if n==0:
    print(0)
else:
    print(c)
",O(logn)
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1

    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])
",O(1)
"modulo = 10 ** 9 + 7
x, k = [int(s) for s in input().split()]

if x == 0:
    print(0)
    exit(0)

k2 = pow(2, k, modulo)
ans = (x * k2 * 2 - k2 + 1) % modulo
print(ans)
",O(logn)
"def digit(a):
    s=0
    while a:
        s+=a%10
        a//=10
    return s

def big(n,s):

    lo=1
    hi=n
    while lo<=hi:
        mid=(lo+hi)//2
        if mid-digit(mid)<s:

            lo=mid+1
        else:
            hi=mid-1

    return n-lo+1

a,b=map(int,input().strip().split())
print(big(a,b))",O(logn)
"modulo = int(1e9+7)
n = int(input())
arr = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if arr[i] == 'f':
        dp.append(0)
        continue;
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % modulo
print(dp[-1])",O(n ^ 2)
"n=int(input())
s=input()

h=s.count('H')
s=s+s
print(min(s[i:i+h].count('T') for i in range(n)))
",O(n)
"n = int(input())
A = [int(a) for a in input().split()]
B = A.copy()
B.sort()
c = 0
for i in range(n):
    c = c + 1 if A[i] != B[i] else c
print(""YES"" if c <= 2 else ""NO"")",O(nlogn)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False
",O(nlogn)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)
",O(nlogn)
"from sys import exit
N, M = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
B.sort()
mB = B[-1]
m2B = B[-2]
mG = min(G)
if mB > mG:
    print(-1)
    exit()
if mB == mG:
    print(sum(B)*M + sum(G) - mB * M)
    exit()
print(sum(B)*M + sum(G) - mB * M + mB - m2B)",O(nlogn)
"import sys
import threading

def dfs(g, i, p):
    global ans
    count = 0
    for j in g[i]:
        if j == p:
            continue
        count += dfs(g, j, i)
    if count == 0:
        count = 1
    ans.append(count)
    return count

def solve():

    n = int(input())
    l = list(map(int, input().split()))
    g = [[] for i in range(n+1)]

    for i in range(1, n):
        g[i+1].append(l[i-1])
        g[l[i-1]].append(i+1)

    dfs(g, 1, 0)
    ans.sort()
    st = ' '.join(map(str, ans))
    print(st)

ans = []
max_recur_size = 10**5*2 + 1000
max_stack_size = max_recur_size*500

sys.setrecursionlimit(max_recur_size)
threading.stack_size(max_stack_size)
thread = threading.Thread(target=solve)
thread.start()",O(n ^ 2)
"import collections



class Solution(object):
    def countCompleteSubarrays(self, nums):
        nums_set = set(nums)
        result = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while len(cnt) == len(nums_set):
                cnt[nums[left]] -= 1
                if cnt[nums[left]] == 0:
                    del cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"import sys
input = sys.stdin.readline
maxn = int(1510)
ST = [0 for _ in range(4 * maxn)]
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"def read():
    return [c == '1' for c in input()]
n = int(input())
a, b = read(), read()

res = 0

i = 0
while i + 1 < n:
    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:
        a[i] = b[i]
        a[i+1] = b[i+1]
        res += 1
        i += 2
    else:
        i += 1

for i in range(n):
    if a[i] != b[i]:
        res += 1

print(res)",O(n)
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]

    def inputi():
        return stdin.buffer.readline()

def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
rstr = lambda: stdin.readline().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    print('%d\n%s' % (len(out), '\n'.join(out)))
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))

def main():
    a,b = getints()
    print(result(a,b))

def result(a,b):
    if a==0 or b==0:
        return 0
    if a>b:
        return a//b+result(a%b,b)
    else:
        return b//a+result(b%a,a)

if __name__ == ""__main__"":
    main()",O(1)
"k = int(input())
n = 1
up_bnd = 9
while(k > up_bnd):
    n += 1
    up_bnd += (9*n)*(10**(n-1))
low_bnd = 0
lb_val = 0
for i in range(1, n):
    low_bnd += (9*i)*(10**(i-1))
    lb_val = (lb_val*10)+9
num = int((k-low_bnd)/n) + lb_val
rm = (k-low_bnd) % n
if(rm != 0):
    num += 1
ans = 0
if(rm == 0):
    ans = num % 10
else:
    for i in range(n-rm+1):
        j = (num % 10)
        num = int(num/10)
        ans = j
print(int(ans))",O(logn)
"a = input()
lst = []
a_1 = """"
for i in range(len(a)):
    if a[i] != "" "":
        a_1 = a_1 + a[i]
    else:
        lst.append(int(a_1))
        a_1 = """"
lst.append(int(a_1))
if lst[1] > 2 * lst[0] - 1:
    print(0)
else:
    countr = 0
    if lst[1] % 2 == 1:
        countr = (lst[1] - 1) // 2
    else:
        countr = (lst[1] - 2) // 2
    if lst[1] > lst[0] + 1:
        countr = countr - lst[1] + lst[0] + 1
    print(countr)",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val",O(1)
"class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]",O(1)
"class Solution:
    def isNStraightHand(self, hand, groupSize):
        if len(hand) % groupSize:
            return False
        count = Counter(hand)
        hand.sort()
        for num in hand:
            if count[num]:
                for i in range(num, num + groupSize):
                    if not count[i]:
                        return False
                    count[i] -= 1
        return True
",O(nlogn)
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))
",O(1)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(H, W, A):
    visited = [bytearray(W) for _ in range(H)]

    for y in range(H):
        for x in range(W):
            if A[y][x] == '.' or visited[y][x]:
                continue

            dprint(x, y)
            for dx, dy in [(0, 0), (-1, 0), (-2, 0),
                           (0, -1), (-2, -1),
                           (0, -2), (-1, -2), (-2, -2)]:
                tx = x + dx
                ty = y + dy
                dprint('  ', tx, ty)
                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:
                    continue
                bad = False
                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    if A[ny][nx] == '.':
                        bad = True
                        break
                if bad:
                    continue

                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    visited[ny][nx] = 1

                assert visited[ny][nx] == 1
                break

            if visited[y][x] == 0:
                return False

    return True

def main():
    H, W = [int(e) for e in inp().split()]
    A = [inp() for _ in range(H)]

    print('YES' if solve(H, W, A) else 'NO')

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution2(object):
    def hIndex(self, citations):
        citations.sort(reverse=True)
        h = 0
        for x in citations:
            if x >= h + 1:
                h += 1
            else:
                break
        return h",O(nlogn)
"from sys import stdin, stdout
from math import gcd
input = stdin.buffer.readline

x, k = map(int, input().split())
if x == 0:
	print(0)
	exit()
x *= 2
mod = 1000000007
x = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)
print(x % mod)
",O(logn)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution(object):
    def finalValueAfterOperations(self, operations):
        return sum(1 if '+' == op[1] else -1 for op in operations)",O(n)
"class Solution(object):
    def findUnsortedSubarray(self, nums):
        n = len(nums)
        left, right = -1, -2
        min_from_right, max_from_left = nums[-1], nums[0]
        for i in range(1, n):
            max_from_left = max(max_from_left, nums[i])
            min_from_right = min(min_from_right, nums[n-1-i])
            if nums[i] < max_from_left: right = i
            if nums[n-1-i] > min_from_right: left = n-1-i",O(n)
"def somaDigitos(x):
    resp = 0
    while x > 0:
        resp += x%10
        x = x//10
    return resp

def isReallyBigNumber(x):
    return x - somaDigitos(x) >= s

n, s = input().split("" "")
n = int(n)
s = int(s)

count = 0

ini = 1
fim = n
i = 0
ans = False
while ini <= fim:
    meio = (ini + fim)//2
    if isReallyBigNumber(meio):
        ans = meio
        fim = meio - 1
    else:
        ini = meio + 1

if ans:
    print(n - ans + 1)
else:
    print(0)
",O(logn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=0
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid][0] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res

n,m,k=map(int,input().split())
r=[]
for i in range (n):
    a=list(map(int,input().split()))
    r.append(a)
c=[]
for i in range (n-1):
    a=list(map(int,input().split()))
    c.append(a)
if k%2:
    a=[-1]*m
    for i in range (n):
        print(*a)
    sys.exit(0)
dp=[[[0 for i in range ((k//2)+1)]for j in range (m)]for p in range (n)]
for x in range (1,(k//2)+1):
    for i in range (n):
        for j in range (m):
            mn=10**8
            if i>0:
                mn=min(mn,c[i-1][j]+dp[i-1][j][x-1])
            if j>0:
                mn=min(mn,r[i][j-1]+dp[i][j-1][x-1])
            if i<n-1:
                mn=min(mn,c[i][j]+dp[i+1][j][x-1])
            if j<m-1:
                mn=min(mn,r[i][j]+dp[i][j+1][x-1])
            dp[i][j][x]=mn
for i in range (n):
    for j in range (m):
        print(2*dp[i][j][k//2],end=' ')
    print()",O(n ^ 3)
"import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):

		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):

		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]

for i in range(1,x):
	for k in range(1,z):

		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]

			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]

print(ans)
",O(n ^ 3)
"def solve():
    n, k = list(map(lambda x: int(x), input().split()))
    upper_bound = n+1
    lower_bound = -1
    while upper_bound > lower_bound + 1:
        m = (upper_bound + lower_bound) // 2
        if (n - m) * (n - m + 1) // 2 - m > k:
            lower_bound = m
        else:
            upper_bound = m
    print(upper_bound)

solve()
",O(logn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def partition(self, head, x):
        dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)
        smaller, greater = dummySmaller, dummyGreater

        while head:
            if head.val < x:
                smaller.next = head
                smaller = smaller.__next__
            else:
                greater.next = head
                greater = greater.__next__
            head = head.__next__

        smaller.next = dummyGreater.__next__
        greater.next = None

        return dummySmaller.__next__",O(n)
"n,m=map(int,input().strip().split())
v=[0]*51
left=1
right=n
for i in range(1,n+1):
	if(n-i-1<=0):
		pw=1
	else:
		pw=(1<<(n-i-1))

	if(m<=pw):
		v[left]=i
		left+=1
	else:
		v[right]=i
		right-=1
		m-=pw
for i in range(1,n):
	print(v[i], end=' ')
print(v[n])
",np
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K
	return res

c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)
",O(n ^ 3)
"import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=2):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

s = input()
lens = len(s)
max_ = 0
for i in range(1, lens):
    d = {}
    for j in range(lens - i + 1):
        if s[j: j + i] in d:
            d[s[j: j + i]] += 1
        else:
            d[s[j: j + i]] = 1
    maxd = max(d.values())
    if max(d.values()) > 1:
        max_ = i
print(max_)
",O(n ^ 3)
"import sys

n, s = map(int, input().split())

ok, ng = 10**18+100, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    if mid - sum(map(int, str(mid))) >= s:
        ok = mid
    else:
        ng = mid

print(max(0, n - ok + 1))
",O(logn)
"l,r=map(int,input().split())
j=r-l+1

if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",O(1)
"import math

line = input().split()
N = int(line[0])
K = int(line[1])

n = (-3 + math.sqrt(9+4*(2*N+2*K)))/2

print(int(N-n))
",O(logn)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)

if __name__ == '__main__':
    main()",O(n)
"import collections


class Solution2(object):
    def minReorder(self, n, connections):
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)",O(n)
"def main():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    solve(n, k, p)

def solve(n, k, p):
    group = 256 * [None]
    r = p[:]
    for i, pi in enumerate(p):

        if group[pi] is not None:
            r[i] = group[pi][0]
        else:
            lo = pi
            while lo >= 0 and pi - lo < k and group[lo] is None:
                lo -= 1
            if lo < 0 or pi - lo == k:
                lo += 1
                hi = pi + 1
            else:
                if pi - group[lo][0] < k:
                    lo = group[lo][0]
                    hi = pi + 1
                else:
                    lo += 1
                    hi = pi + 1
            lohi = (lo, hi)
            for j in range(lo, hi):
                group[j] = lohi
            r[i] = group[pi][0]
    print("" "".join(map(str, r)))

main()
",O(n ^ 2)
"class Solution(object):
    def productExceptSelf(self, nums):
        if not nums:
            return []

        left_product = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            left_product[i] = left_product[i - 1] * nums[i - 1]

        right_product = 1
        for i in range(len(nums) - 2, -1, -1):
            right_product *= nums[i + 1]
            left_product[i] = left_product[i] * right_product

        return left_product",O(n)
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)

                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",O(n ^ 3)
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",O(n ^ 2)
"from math import *
k,n=map(int,input().split())
print(ceil(n/k))",O(1)
"n = int(input())
m = int(input())
print(m%2**n)",O(1)
"input_arr = [int(i) for i in input().split()]
a,b = input_arr

def dec_to_bin(N):
    res=[0]*64

    pos=0
    while N!=0:
        last_bit = N & 1
        res[pos] = last_bit
        pos+=1
        N=N>>1
    return res

def max_xor(a,b):
    a_bin = dec_to_bin(a)
    b_bin = dec_to_bin(b)

    res = """"
    x = """"
    y = """"
    diff_pt_found = False

    for i in range(len(a_bin)-1,-1,-1):

        if diff_pt_found == False and a_bin[i] == b_bin[i]:
            x+=str(a_bin[i])
            y+=str(b_bin[i])

        if diff_pt_found == False and a_bin[i] != b_bin[i]:
            diff_pt_found = True
            x+=str(a_bin[i])
            y+=str(b_bin[i])

            res+=""1""
            continue

        if diff_pt_found == True:
            if a_bin[i] != b_bin[i]:
                res+=""1""
                x+=str(a_bin[i])
                y+=str(b_bin[i])
            elif b_bin[i]==1:
                res+=""1""

                x+=str(a_bin[i])
                y+=str(0)
            elif a_bin[i]==0:
                res+=""1""

                x+=str(1)
                y+=str(b_bin[i])

    return x,y,res

def bin_to_dec(bin):
    bin = str(bin)
    mul = 1
    res=0
    for i in range(len(bin)-1,-1,-1):
        if bin[i]=='1':
            res+=mul

        mul=mul*2

    return res

x,y,res = max_xor(a,b)

print(bin_to_dec(res))",O(logn)
"n = int(input())
w = list(map(int, input().split()))
intro = [[v, i] for i, v in enumerate(w, 1)]
intro.sort(key=lambda x: x[0])
s = input()
i = -1
li = []
ans = []
for j in s:
    if j == ""0"":
        i += 1
        ans.append(intro[i][1])
        li.append(intro[i][1])
    else:
        ans.append(li.pop(-1))
print("" "".join(map(str, ans)))
",O(nlogn)
"def read_data():
    n = int(input().strip())
    a = []
    for i in range(n):
        line = tuple(map(int, input().strip().split()))
        a.append(line)
    return n, a

def is_on_line(a,b,c):
    return 1 if (a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1])) == 0 else 0

def solve():
    if n <= 4:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[0],a[1],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[0],a[2],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[1],a[2],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    return 0

n, a = read_data()
print(""Yes"" if solve() == 1 else ""No"")",O(nlogn)
"n = int(input().strip())
a = list(map(int,input().strip().split()))
b = list(map(int,input().strip().split()))
pos_of = [-1 for i in range(2*10**5+1)]

for i,ele in enumerate(a):
    pos_of[ele]=i+1

current_pos = 0
ans=[]
for i in b:
    if(pos_of[i]>current_pos):
        ans.append(pos_of[i]-current_pos)
        current_pos=pos_of[i]
    else:
        ans.append(0)

print(' '.join(list(map(str,ans))))
",O(n)
"n = int(input())
a = n * (n + 1) // 2
print(4 * a - 4 * n + 1)",O(1)
"import re


class Solution(object):
    def solveEquation(self, equation):
        a, b, side = 0, 0, 1
        for eq, sign, num, isx in re.findall('(=)|([-+]?)(\d*)(x?)', equation):
            if eq:
                side = -1
            elif isx:
                a += side * int(sign + '1') * int(num or 1)
            elif num:
                b -= side * int(sign + num)
        return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions'",O(n)
"n, l, r, x = list(map(int, input().split("" "")))
c = sorted(list(map(int, input().split("" ""))))
ways = 0

for i in range(0, 2 ** n):
    temp = 0
    m = 10 ** 9 + 1
    M = -1
    for j in range(0, n):
        if i & 1 << j:
            temp += c[j]
            m = min(m, c[j])
            M = max(M, c[j])
    if temp >= l and temp <= r and (M - m) >= x:
        ways += 1

print(ways)
",np
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"")
elif a.count(4)==2 and a.count(2)==1:print(""YES"")
else:print(""NO"")
",O(1)
"import collections


class Solution(object):
    def sortFeatures(self, features, responses):
        features_set = set(features)
        order = {word: i for i, word in enumerate(features)}
        freq = collections.defaultdict(int)
        for r in responses:
            for word in set(r.split(' ')):
                if word in features_set:
                    freq[word] += 1
        features.sort(key=lambda x: (-freq[x], order[x]))
        return features",O(nlogn)
"class Solution(object):
    def permute(self, n, k):
        result = []
        cnt = [1]*n
        for i in range(len(cnt)-1):
            cnt[i+1] = min(cnt[i]*((i+2)//2), k)
        lookup = [False]*n
        for i in range(n):
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt[n-1-i]:
                    break
                k -= cnt[n-1-i]
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"n = int(input())
a = list(map(int, input().split()))
b = []
for i in range(n):
    a[i] %= 2
    if len(b) != 0:
        if b[-1] == a[i]:
            b.pop()
        else:
            b.append(a[i])
    else:
        b.append(a[i])
if len(b) > 1:
    print(""NO"")
else:
    print(""YES"")
",O(n)
"kk=lambda:map(int, input().split())
ll=lambda:list(kk())
n,l,r,d=kk()
p,t=ll(),0
for v in range(2**n):
	s = []
	for i in range(n):
		if v&(2**i):
			s.append(p[i])
	if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1
print(t)",np
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph()])
        a1.fliph()
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"first = [int(i) for i in input()]
second = [int(i) for i in input()]

pref_dists = [
    [0] + [int(0 != c) for c in second],
    [0] + [int(1 != c) for c in second]
]
for i in range(1, len(second) + 1):
    pref_dists[0][i] += pref_dists[0][i - 1]
    pref_dists[1][i] += pref_dists[1][i - 1]

total = 0
for i, c in enumerate(first):
    end = len(second) - (len(first) - i)
    total += pref_dists[c][end + 1] - pref_dists[c][i]
print(total)
",O(n)
"class Solution(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i, h in enumerate(heights):
            while stk and heights[stk[-1]] < h:
                result[stk.pop()] += 1
            if stk:
                result[stk[-1]] += 1
            if stk and heights[stk[-1]] == h:
                stk.pop()
            stk.append(i)
        return result",O(n)
"n=int(input())
lst = list(map(int, input().strip().split(' ')))
c=0
while(len(lst)!=0):
    p=lst[0]
    del lst[0]
    i=lst.index(p)
    c+=i
    del lst[i]
print(c)
",O(n ^ 2)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"MOD = 10**9+7
FACT, INV, INV_FACT = [[1]*2 for _ in range(3)]
def nCr(n, k):
    if n < k:
        return 0
    while len(INV) <= n: 
        FACT.append(FACT[-1]*len(INV) % MOD)
        INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
        INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
    return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD


class Solution(object):
    def minMaxSums(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = 0
        cnt = 1
        for i in range(len(nums)):
            result = (result+(nums[i]+nums[~i])*cnt)%MOD
            cnt = (cnt*2-nCr(i, k-1)) % MOD
        return result",O(nlogn)
"n = int(input())
ax, ay = list(map(int, input().split(' ')))
bx, by = list(map(int, input().split(' ')))
cx, cy = list(map(int, input().split(' ')))

if ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):
    print('YES')
else:
    print('NO')",O(1)
"class Solution2(object):
    def largestSumAfterKNegations(self, A, K):
        A.sort()
        remain = K
        for i in range(K):
            if A[i] >= 0:
                break
            A[i] = -A[i]
            remain -= 1
        return sum(A) - (remain%2)*min(A)*2",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())

    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))

    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",O(n ^ 3)
"s=list(input())
ans=0
far=0
for i in range(len(s)-1):
    if(s[i]!=s[i+1]):
        far+=1
        continue
    if(s[0]!=s[-1]):
        s[:i+1]=s[:i+1][::-1]
        s[i+1:]=s[i+1:][::-1]
        far+=1
    else:
        ans=max(ans,far+1)
        far=0

print(max(far+1,ans))
",O(n)
"class Solution2(object):
    def triangularSum(self, nums):
        result = 0
        nCr = 1
        for i in range(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result",O(n)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"import sys
from array import array
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = [1 << i for i in range(m)]
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)

if __name__ == '__main__':
    main()
",np
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def main():
    n=int(input())
    b=[0]
    cost=b+list(map(int, input().split()))
    arr=b+list(map(int, input().split()))
    nv=[-1]*(n+1)
    colors=[]
    c=0
    for i in range(1,n+1):
        if(nv[i]!=-1):
            continue
        nv[i]=c
        dest=arr[i]
        while(nv[dest]==-1):
            nv[dest]=c
            dest=arr[dest]
        if(nv[dest]==c):
            colors.append(dest)
        c+=1
    s=0
    for i in colors:
        mi=cost[i]
        nxt=arr[i]
        while(nxt!=i):
            mi=min(mi,cost[nxt])
            nxt=arr[nxt]
        s+=mi
    print(s)
main()",O(n)
"class Solution(object):
    def maxAbsoluteSum(self, nums):
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn",O(n)
"a = input().split()
b = [int(i) for i in a]
inputs = []
diff = []
sinComprimir = 0
for i in range(b[0]):
    input1 = input().split()
    input2 = [int(i) for i in input1]
    inputs.append(input2)

comprimido = 0
for k in range(len(inputs)):
    sinComprimir = sinComprimir + inputs[k][0]
    diff.append(inputs[k][0] - inputs[k][1])
    comprimido = comprimido + inputs[k][1]

difference = sorted(diff)
invDifference = difference[::-1]
newTotal = sinComprimir
iteraciones = 0
iterador = 0
if sinComprimir <= b[1]:
    print(""0"")
elif comprimido > b[1]:
    print(""-1"")
else:
    while newTotal > b[1]:
        iterador = iterador + 1
        newTotal = newTotal - invDifference[iterador-1]
        iteraciones += 1
    print(iteraciones)",O(nlogn)
"class Solution(object):
    def canTransform(self, start, end):
        if start.count('X') != end.count('X'):
            return False
        i, j = 0, 0
        while i < len(start) and j < len(end):
            while i < len(start) and start[i] == 'X':
                i += 1
            while j < len(end) and end[j] == 'X':
                j += 1
            if (i < len(start)) != (j < len(end)):
                return False
            elif i < len(start) and j < len(end):
                if start[i] != end[j] or \
                   (start[i] == 'L' and i < j) or \
                   (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True",O(n)
"n , m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l3=[]
for i in range(n):
    for j in range(m):
        if l1[i]==l2[j]:
            if l1[i] is not l3:
                l3.append(l1[i])
print(*l3)
",O(n ^ 2)
"MOD=1000000007
def pow2(n):
    if n==0:
        return 1
    t=pow2(n//2)%MOD
    m=(t*t)%MOD
    if n%2==1:
        m=(m*2)%MOD
    return m
x,k=map(int,input().split())
if x==0:
    print(0)
    exit()
t=pow2(k)*(2*x-1)%MOD
print((t+1)%MOD)
",O(logn)
"import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    p = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [[0]*y for _ in range(n)]

    dp[0][y-1] = 1
    for i in range(y-2,-1,-1):
        mask = 1
        for j in range(n):
            if not mask&i:
                mask <<= 1
                continue
            mask1 = 1
            for k in range(n):
                if i&mask1:
                    mask1 <<= 1
                    continue
                dp[j][i] = max(dp[j][i],
                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])
                mask1 <<= 1
            mask <<= 1
    print(max(dp[i][1<<i] for i in range(n)))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"a = list(input())
b = int(input())
a = sorted(a, reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)
",O(n ^ 3)
"n=int(input())
a=list(map(int,input().split()))
s=sum(a)
new=0
i=0
while 2*(new+a[i])<s:
    new+=a[i]
    i+=1
print(i+1)
",O(n)
"import math;
def getIntList():
    return list(map(int, input().split()));
def getTransIntList(n):
    first=getIntList();
    m=len(first);
    result=[[0]*n for _ in range(m)];
    for i in range(m):
        result[i][0]=first[i];
    for j in range(1, n):
        curr=getIntList();
        for i in range(m):
            result[i][j]=curr[i];
    return result;
n, a, b = getIntList();
if a>1 and b>1:
    print('NO');
elif a==b==1 and (n==2 or n==3):
    print('NO');
else:
    c=max(a, b);
    m=[[0]*n for _ in range(n)];
    for i in range(n-c):
        m[i][i+1]=1;
        m[i+1][i]=1;
    if b>1:
        for i in range(n):
            for j in range(n):
                if i!=j:
                    m[i][j]=1-m[i][j];
    print('YES');
    for i in range(n):
        print(''.join(map(str, m[i])));",O(n ^ 2)
"class Solution(object):
    def maxScoreSightseeingPair(self, A):
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result",O(n)
"class Solution(object):
    def maximumXorProduct(self, a, b, n):
        MOD = 10**9+7
        for i in reversed(range(n)):
            base = 1<<i
            if min(a, b)&base == 0:
                a, b = a^base, b^base
        return (a%MOD)*(b%MOD)%MOD",O(n)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        stack = [root]
        mp = {None: (0, 0)}

        while stack:
            node = stack[-1]

            if node.left and node.left not in mp:
                stack.append(node.left)
            elif node.right and node.right not in mp:
                stack.append(node.right)
            else:
                node = stack.pop()

                leftHeight, leftDiameter = mp[node.left]
                rightHeight, rightDiameter = mp[node.right]

                mp[node] = (1 + max(leftHeight, rightHeight),
                           max(leftHeight + rightHeight, leftDiameter, rightDiameter))

        return mp[root][1]
",O(n)
"def bina(bi):
    binary1 = bi
    decimal, i, n = 0, 0, 0
    while(bi != 0):
        dec = bi % 10
        decimal = decimal + dec * pow(2, i)
        bi = bi//10
        i += 1
    return decimal
def con(n):
   return bin(n).replace(""0b"", """")
l,r=map(int,input().split())
k=con(l)
m=con(r)
k=list(str(k))
m=list(str(m))
j=len(m)-len(k)
k=['0']*j + k

c=0
for i in range(len(m)):
    if k[i]!=m[i]:
        c=1
    if k[i]==m[i] and k[i]=='1' and c==1:
        k[i]='0'
    elif k[i]==m[i] and k[i]=='0' and c==1:
        k[i]='1'
k=int(''.join(k))
m=int(''.join(m))
print(bina(k)^bina(m))",O(logn)
"n=int(raw_input())
arr=list(map(int,raw_input().split()))
dict1={}
arr1=[0]*n
for i in range(n):
	arr1[arr[i]-1]=i
for i in range(n):
	dict1[i+1]=[]
for i in range(n):
	for j in range(i-arr[i],-1,-arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
	for j in range(i+arr[i],n,arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
strarr=['.']*n

for i in range(n-1,-1,-1):
	if(len(dict1[arr[arr1[i]]])==0):
		strarr[arr1[i]]='B'
	else:
		if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):
			strarr[arr1[i]]='A'
		else:
			flag=0
			for j in dict1[arr[arr1[i]]]:

				if(strarr[arr1[j-1]]=='B'):
					flag=1
					break
			if(flag==1):
				strarr[arr1[i]]='A'
			else:
				strarr[arr1[i]]='B'

print("""".join(x for x in strarr))
",O(n ^ 2)
"class Solution(object):
    def verifyPreorder(self, preorder):
        low, i = float(""-inf""), -1
        for p in preorder:
            if p < low:
                return False
            while i >= 0 and p > preorder[i]:
                low = preorder[i]
                i -= 1
            i += 1
            preorder[i] = p
        return True",O(n)
"class Solution(object):
    def findClosest(self, x, y, z):
        return list(range(3))[cmp(abs(y-z), abs(x-z))]",O(1)
"z,x=map(int,input().split())
z-=1;x-=1
if x*(x+1)/2 < z :
  print(-1)
elif z==0:
    print(0)
elif z==x:
    print(1)
else:
    import sys
    start = 1 ; end = x
    while end > start:
        mid = (end +start)//2
        ans =(x*(x+1)//2)-((mid-1)*(mid)//2 )
        if ans == z:
            print(x-mid+1)
            sys.exit(0)
        elif ans > z:
            start = mid+1
        elif ans < z:
            end = mid
    print(x-end+2)
",O(logn)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())",O(n ^ 2)
"n,k = map(int,input().split())
print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)
",O(1)
"n = int(input())
a = list(map(int, input().split()))
s = sorted(a)
q = a.index(max(a))
q1, q = min(len(a)-1, q+1), max(0, q-1)
for q2 in range(len(a)-2, -1, -1):
    if a[q] == s[q2]:
        q = max(0, q-1)
    elif a[q1] == s[q2]:
        q1 = min(len(a)-1, q1+1)
    else:
        print(""NO"")
        break
else:
    print(""YES"")
",O(nlogn)
"from sys import stdin, stdout
from collections import defaultdict

n, m, k = map(int, stdin.readline().split())

dic = defaultdict(lambda : {})
for i in range(n):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m-1):
        dic[i*m+j][i*m+j+1] = line[j]*2
        dic[i*m+j+1][i*m+j] = line[j]*2

for i in range(n-1):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m):
        dic[i*m+j][(i+1)*m+j] = line[j]*2
        dic[(i+1)*m+j][i*m+j] = line[j]*2

if k % 2 != 0:
    for i in range(n):
        stdout.write(' '.join(('-1',)*m))
        stdout.write('\n')
else:
    prev = []
    di = (1, 0, -1, 0)
    dj = (0, 1, 0, -1)
    for _ in range(n):
        prev.append((0,)*m)

    for _ in range(k//2):
        new = []
        for _ in range(n):
            new.append([100_000_000]*m)

        for num in dic:
            i = num // m
            j = num % m
            for idx in range(4):
                ii = i + di[idx]
                jj = j + dj[idx]
                if not ((0 <= ii < n) and (0 <= jj < m)): continue
                new[ii][jj] = min(new[ii][jj], prev[i][j] + dic[i*m+j][ii*m+jj])

        prev = new

    for i in range(n):
        stdout.write(' '.join(map(str, prev[i])))
        stdout.write('\n')
",O(n ^ 3)
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    print(""NO"")

for _ in range(int(input())):
    main()",O(1)
"R,G,B = map(int,input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
area = 0
r.sort(reverse=True)
b.sort(reverse=True)
g.sort(reverse=True)
L = max(len(r),len(g),len(b))
dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]

tr = 0
tg = 0
tb = 0
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
			area = max(area,dp[i][j][k])
print(area)",O(n ^ 3)
"import sys,os,io
from sys import stdin
import math
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

alphabets = list('abcdefghijklmnopqrstuvwxyz')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)

    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret

def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

n,m,k = li()
dp = [0]*(k+1)
l = []
fk = None
for _ in range(n):
    s = list(si())
    d = []
    if list(set(s))==['0']:
        d.append(0)
        continue
    one = []
    for i in range(len(s)):
        if s[i]=='1':
            one.append(i)
    ni = len(one)
    d = [1e9]*(ni+1)
    d[-1]=0
    for i in range(ni):
        for j in range(i, ni):
            d[ni-(j-i+1)] = min(d[ni-(j-i+1)], one[j]-one[i]+1)
    l.append(d)
    fk = [1e9]*(k+1)
    for i in range(k+1):
        for j in range(ni+1):
            if i+j>k:
                break
            fk[i+j] = min(fk[i+j] , dp[i] +d[j])
    dp = fk[:]

print(min(dp))
",O(n ^ 3)
"class Solution(object):
    def maxLevelSum(self, root):
        def dfs(node, i, level_sums):
            if not node:
                return
            if i == len(level_sums):
                level_sums.append(0)
            level_sums[i] += node.val
            dfs(node.left, i+1, level_sums)
            dfs(node.right, i+1, level_sums)

        level_sums = []
        dfs(root, 0, level_sums)
        return level_sums.index(max(level_sums))+1",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

def solve():
    n,k = li()
    l = [['.' for i in range(n)] for j in range(4)]
    print(""YES"")
    if k%2==0:
        for i in range(1,k//2+1):
            l[1][i]='
            l[2][i]='
    else:
        if (k>n-2):

            for i in range(1,n-1):
                l[1][i]='
            k-=(n-2)
        if k>0:
            i = n//2
            if k%2==1:
                l[2][i]='
                k-=1
            i = n//2+1
            for i in range(n//2+1,n//2+1+k//2):
                l[2][i]='
            k = k//2
            for i in range(n//2-1,-1,-1):
                if k==0:
                    break
                k-=1
                l[2][i]='
    for i in l:
        print(''.join(i))

t = 1

for _ in range(t):
    solve()
",O(n)
"from itertools import permutations,combinations
from math import factorial
word1 = list(map(str,input()))
word2 = list(map(str,input()))
expected = 0
for i in word1:
    if i=='+':
        expected+=1
    else:
        expected-=1
blank = 0
for i in word2:
    if i=='+':
        expected-=1
    elif i=='-':
        expected+=1
    else:
        blank+=1
if abs(expected)>blank:
    print(float(0))
elif blank==0:
    if expected==0:
        print(1)
    else:
        print(0)
else:
    total = 2**blank
    if expected==blank-1:
        print(float(0))
    else:
        f = (blank-expected)//2
        if expected>0:
            a,b = expected+f,f
        elif expected<0:
            a,b = expected+f,f
        else:
            a,b = f,f
        ans = factorial(a+b)/(factorial(a))
        ans = ans/factorial(b)
        ans = ans/total
        print(ans)",np
"class Solution(object):
    def countPairs(self, nums1, nums2):
        for i in range(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left < right:
            if nums1[left] > 0 or -nums1[left] < nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result",O(nlogn)
"import itertools



class Solution2(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        result.reverse()
        return result",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,k=ria()
        a=1
        b=-(2*n+3)
        c=n*(n+1)-2*k
        x=(-b-int(math.sqrt(b**2-4*a*c)))//(2*a)
        print(x)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(logn)
"from math import factorial

send = input()
receive = input()

cntP = send.count(""+"")
cntN = send.count(""-"")

cnt1 = receive.count(""+"")
cnt2 = receive.count(""-"")

mark = receive.count(""?"")

total = pow(2, mark)

if cntP < cnt1 or cntN < cnt2:
    valid = 0
else:
    valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1)
print(f""{valid / total:0.12f}"")
",np
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        good = set()

        for t in triplets:
            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:
                continue
            for i, v in enumerate(t):
                if v == target[i]:
                    good.add(i)
        return len(good) == 3
",O(n)
"class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)",O(n)
"class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result",O(n)
"n=input()
L=list(map(int,raw_input().split(' ')))
D=[0]*101000
mod=10**9+7
itt=[0]*101000
p=[0]*100010
D[0]=1
for i in range(100010):
  D[i+1]=(D[i]*2)%mod
for i in range(n):
  itt[L[i]]+=1
for i in range(1,100001):
  for j in range(i*2,100001,i):
    itt[i]+=itt[j]
  p[i]=(D[itt[i]]+mod-1)%mod
i=100000
while i>=1:
  for j in range(i*2,100001,i):
    p[i]-=p[j]
  p[i]=(p[i]%mod+mod)%mod
  i-=1
print(p[1])",np
"from sys import stdin

n, m = map(int, stdin.readline().split())
ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))
num, cur, i = 1, 0, 0

while i < len(p) and m > 0 and num <= n:
    cur += p[i]
    if cur >= m:
        m -= (cur - p[i])
        cur = 0
        ans.append(num)
        all.discard(num)
    num += 1
    i += 1

print(' '.join(map(str, ans + sorted(all)[::-1])))
",np
"n = int(input())

if n == 3:
    print('1 1 3')
    exit()
if n == 1:
    print('1')
    exit()
if n == 2:
    print('1 2')
    exit()
d = 2
ans = []
lfn = n
while d <= n:
    k = n // d
    for j in range(lfn - k):
        ans.append(d//2)
    lfn = n - len(ans)
    d *=2
d //= 2
k = n/d
if k < 1.5:
    ans.append(d)
else:
    ans.append(d + d//2)
print(' '.join([str(i) for i in ans]))",O(nlogn)
"class Solution(object):
    def validSubarrays(self, nums):
        result = 0
        s = []
        for num in nums:
            while s and s[-1] > num:
                s.pop()
            s.append(num)
            result += len(s)
        return result",O(n)
"class Solution(object):
    def mostVisited(self, n, rounds):
        return list(range(rounds[0], rounds[-1]+1)) or \
               list(range(1, rounds[-1]+1)) + list(range(rounds[0], n+1))",O(n)
"R,G,B=list(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])
            if i<R and k<B:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])
            if k<B and j<G:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])
            ans=max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"s=input()
ans=0
m=set()
for i in range(len(s)):
    for j in range(i,-1,-1):
        if(s[j:i+1] in m):
            ans=max(ans,i-j+1)
        else:
            m.add(s[j:i+1])
print(ans)
",O(n ^ 3)
"s1, s2 = input().split()
ans = 'z' * 21
for i in range(1, len(s1) + 1):
    for j in range(1, len(s2) + 1):
        ans = min(ans, s1[:i] + s2[:j])
print(ans)",O(n)
"n,k=map(int,input().split())
mod=int(1e9+7)

if n>0:
    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1
else:
    ans=0
print(ans%mod)",O(logn)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"n = int(input())
l = [input() for _ in range(n)]
l.sort(key=lambda x: len(x))

ok = True
for i in range(n-1):
  if l[i] not in l[i+1]:
    ok = False
    break

if ok:
  print(""YES"")
  print(*l, sep='\n')
else:
  print(""NO"")
",O(nlogn)
"class Solution(object):

    def __init__(self, n):
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i < len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result",O(1)
"k, n, s, p = map(int, input().split())

paper_person = (n + s -1)//s

total_needed = paper_person * k

ans = (total_needed+p-1)//p

print(ans)
",O(1)
"a1, a2, b1, b2, c1, c2 = map(int, input().split())
l = max([a1, a2, b1, b2, c1, c2])

if (a1*a2 + b1*b2 + c1*c2 != l**2):
    print(-1)
else:
    if a1 > a2:
        a1, a2 = a2, a1
    if b1 > b2:
        b1, b2 = b2, b1
    if c1 > c2:
        c1, c2 = c2, c1

    if a2 == b2 and b2 == c2:
        print(l)
        for i in range(a1):
            print('A'*a2)
        for i in range(b1):
            print('B'*b2)
        for i in range(c1):
            print('C'*c2)
    else:
        ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']]

        if b2 == l:
            ls[0], ls[1] = ls[1], ls[0]
        if c2 == l:
            ls[0], ls[2] = ls[2], ls[0]

        valid = True
        if ls[1][0] == ls[2][0]:
            pass
        elif ls[1][1] == ls[2][1]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][0] == ls[2][1]:
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][1] == ls[2][0]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
        else:
            valid = False

        if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l):
            valid = False

        if not valid:
            print(-1)
        else:
            print(l)

            for i in range(ls[0][0]):
                print(ls[0][2] * l)
            for i in range(ls[1][0]):
                print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])
",np
"from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)

ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)

n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
",O(n ^ 2)
"class Solution(object):
    def numSub(self, s):
        MOD = 10**9+7
        result, count = 0, 0
        for c in s:
            count = count+1 if c == '1' else 0
            result = (result+count)%MOD
        return result",O(n)
"class Solution(object):
    def titleToNumber(self, s):
        result = 0
        for i in range(len(s)):
            result *= 26
            result += ord(s[i]) - ord('A') + 1
        return result",O(n)
"class Solution2(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = [[0]*n for _ in range(n)]
        for l in range(1, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = i if l == 1 else mid[i][j-1]
                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:
                    p += 1 
                mid[i][j] = p
        
        rmq = [[0]*n for _ in range(n)]
        for i in range(n):
            rmq[i][i] = stoneValue[i]

        dp = [[0]*n for _ in range(n)]
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = mid[i][j]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(rmq[i][p-1], rmq[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, rmq[i][p-2])
                    if p <= j:
                        max_score = max(max_score, rmq[j][p])
                dp[i][j] = max_score
                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return dp[0][n-1]",O(n ^ 2)
"class Solution(object):
    def convert(self, s, numRows):
        if numRows == 1:
            return s
        step, zigzag = 2 * numRows - 2, """"
        for i in range(numRows):
            for j in range(i, len(s), step):
                zigzag += s[j]
                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):
                    zigzag += s[j + step - 2 * i]
        return zigzag",O(n)
"class Solution(object):
    def countVowelStrings(self, n):
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4)",O(1)
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline

ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())

alphs = ""abcdefghijklmnopqrstuvwxyz""

def solve():
    n,m,k=map(int,input().split())
    dct={}
    global case
    case=0
    iput=[]
    for i in range(n):
        word=input()
        dct[word]=i+1
        iput.append(word)
    d=[[] for i in range(n+1)]
    size=[0]*(n+1)
    for _ in range(m):

        word,idx=input().split()
        idx=int(idx)
        temp=1
        w=iput[idx-1]

        for x in range(k):
            if w[x]!='_' and w[x]!=word[x]:
                temp=0
                print(""NO"")
                exit()
                break

        res=[]
        for i in range(1<<k):
            s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])

            if s in dct:
                j=dct[s]
                if j!=idx:
                    d[idx].append(j)
                    size[j]+=1

    st=[nd  for nd in range(1,n+1) if size[nd]==0]

    for i in st:

        for j in d[i]:
            size[j]-=1
            if size[j]==0:
                st.append(j)

    if len(st)==n:
        print(""YES"")
        print(*st)
    else:
        print(""NO"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    tc=1

    for i in range(tc):
    	solve()",np
"import pandas as pd



def Solution(report: pd.DataFrame) -> pd.DataFrame:
    return report.melt(
        id_vars=[""product""],
        value_vars=[f""quarter_{i}"" for i in range(1, 4+1)],
        var_name=""quarter"",
        value_name=""sales"",
    )",O(n)
"import collections
import operator
from functools import reduce



class Solution(object):
    def countTheNumOfKFreeSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))",O(n)
"from collections import defaultdict
n = int(input())
a = list(map(int, input().split()))

rec = defaultdict(list)
for j in range(n):
    for k in range(j, n):
        rec[sum(a[j:k + 1])].append((j, k))

ans = []
for k in rec.keys():
    tmp = []
    rec[k] = sorted(rec[k], key=lambda x: x[1])
    pre = -1
    for a, b in rec[k]:
        if pre >= a:
            continue
        else:
            tmp.append((a + 1, b + 1))
            pre = b
    if len(tmp) > len(ans):
        ans = tmp

print(len(ans))
for a, b in ans:
    print(a, b)",O(n ^ 3)
"class Solution(object):
    def secondGreaterElement(self, nums):
        result, stk1, stk2 = [-1]*len(nums), [], []
        for i, x in enumerate(nums):
            while stk2 and nums[stk2[-1]] < x:
                result[stk2.pop()] = x
            tmp = []
            while stk1 and nums[stk1[-1]] < x:
                tmp.append(stk1.pop())
            stk1.append(i)
            for x in reversed(tmp):
                stk2.append(x)
        return result",O(n)
"

class Solution(object):
    def makeSmallestPalindrome(self, s):
        return """".join(min(s[i], s[~i]) for i in range(len(s)))
",O(n)
"lis = []
for _ in range(int(input())):
    lis.append(input())
lis = sorted(lis, key=len)

for i in range(len(lis) - 1):
    if(lis[i] not in lis[i + 1]):
        print(""NO"")
        exit(0)

print(""YES"")
for i in lis:
    print(i)
",O(nlogn)
"class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        return 0.5 if n != 1 else 1.0",O(1)
"i=int(input())
d=i%2+8;print(d,i-d)",O(1)
"import sys
m,n=map(int,sys.stdin.readline().split())
res=m^n
s=bin(res)
s=s[2:]
s=int(s)
if(s==0):
    print(0)
else:
    s=str(s)
    res=(2**len(s))-1
    print(res)",O(logn)
"import sys
input = sys.stdin.readline

Q=int(input())
LR=[list(map(int,input().split())) for i in range(Q)]

def SUM(i):
    plus=i//2
    minus=(i+1)//2

    P=(2+2*plus)*plus//2
    M=(1+2*minus-1)*minus//2
    return P-M

for l,r in LR:
    print(SUM(r)-SUM(l-1))
",O(1)
"import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        out.write(str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+""\n"")
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")",O(nlogn)
"from math import factorial
s1=input()
s2=input()
n=0
x1=0
for i in range(len(s1)):
    if s1[i]=='+':
        x1+=1
    else:
        x1-=1
x2=0
for i in range(len(s2)):
    if s2[i]=='+':
        x2+=1
    elif s2[i]=='?':
        n+=1
    else:
        x2-=1
x=abs(x1-x2)
if x>n:
    print(0)
elif x==n:
    print(1/2**n)
else:
    if (n-x)%2==1:
        print(0)
    else:
        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)",np
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if (bx > ax, by > ay) != (cx > ax, cy > ay):
    print(""NO"")
    exit(0)

print(""YES"")
",O(1)
"from collections import deque


class Solution(object):

    def __init__(self, vec2d):
        self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def __next__(self):
        length, iterator = self.stack.popleft()
        if length > 1:
            self.stack.appendleft((length-1, iterator))
        return next(iterator)

    def hasNext(self):
        return bool(self.stack)",O(1)
"n,m=[int(x) for x in input().split()]
ans1=""1""*1500
ans2=""8""*1499+""9""
print(ans1)
print(ans2)
",O(1)
"class Solution(object):
    def longestIdealString(self, s, k):
        dp = [0]*26
        for c in s:
            x = ord(c)-ord('a')
            dp[x] = max(dp[i] for i in range(max(x-k, 0), min(x+k+1, 26)))+1
        return max(dp)",O(n)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)
        stack = []
        for p, s in pair:
            stack.append((target - p) / s)
            if len(stack) >= 2 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)
",O(nlogn)
"import sys

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
m = inp[ii]; ii += 1
k = inp[ii]; ii += 1

if k%2 == 1:
	for _ in range(n):
		toprint = [""-1"" for __ in range(m)]
		print("" "".join(toprint))

	sys.exit()

yw = []

for _ in range(n):
	yw.append(inp[ii:ii+m-1])
	ii += m-1

xw = []

for _ in range(n-1):
	xw.append(inp[ii:ii+m])
	ii += m

inf = 10**10

steps = k//2

dp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)]

for i in range(n):
	for j in range(m):
		dp[0][i][j] = 0

for step in range(1, steps + 1):
	for i in range(n):
		for j in range(m):

			if i > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j])

			if i < n-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j])

			if j > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1])

			if j < m-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j])

for x in dp[-1]:
	print("" "".join(list(map(str, [2*o for o in x]))))",O(n ^ 3)
"class Solution(object):
    def maxDepthAfterSplit(self, seq):
        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):
        result = 0
        s = [root]
        while s:
            node = s.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if L < node.val:
                    s.append(node.left)
                if node.val < R:
                    s.append(node.right)
        return result",O(n)
"import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):
        if n == 1:
            return [0]

        neighbors = collections.defaultdict(set)
        for u, v in edges:
            neighbors[u].add(v)
            neighbors[v].add(u)

        pre_level, unvisited = [], set()
        for i in range(n):
            if len(neighbors[i]) == 1: 
                pre_level.append(i)
            unvisited.add(i)

        while len(unvisited) > 2:
            cur_level = []
            for u in pre_level:
                unvisited.remove(u)
                for v in neighbors[u]:
                    if v in unvisited:
                        neighbors[v].remove(u)
                        if len(neighbors[v]) == 1:
                            cur_level.append(v)
            pre_level = cur_level

        return list(unvisited)",O(n)
"class Solution(object):
    def smallestMissingValueSubtree(self, parents, nums):
        def iter_dfs(adj, nums, i, lookup):
            stk = [i]
            while stk:
                i = stk.pop()
                if nums[i] in lookup:
                    continue
                lookup.add(nums[i])
                for j in adj[i]:
                    stk.append(j)

        result = [1]*len(parents)
        i = next((i for i in range(len(nums)) if nums[i] == 1), -1)
        if i == -1:
            return result
        adj = [[] for _ in range(len(parents))]
        for j in range(1, len(parents)):
            adj[parents[j]].append(j)
        lookup = set()
        miss = 1
        while i >= 0:
            iter_dfs(adj, nums, i, lookup)
            while miss in lookup:
                miss += 1
            result[i] = miss
            i = parents[i]
        return result",O(n)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)
",O(nlogn)
"class Solution(object):
    def strongPasswordChecker(self, s):
        missing_type_cnt = 3
        if any('a' <= c <= 'z' for c in s):
            missing_type_cnt -= 1
        if any('A' <= c <= 'Z' for c in s):
            missing_type_cnt -= 1
        if any(c.isdigit() for c in s):
            missing_type_cnt -= 1

        total_change_cnt = 0
        one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0
        i = 2
        while i < len(s):
            if s[i] == s[i-1] == s[i-2]:
                length = 2
                while i < len(s) and s[i] == s[i-1]:
                    length += 1
                    i += 1

                total_change_cnt += length / 3
                if length % 3 == 0:
                    one_change_cnt += 1
                elif length % 3 == 1:
                    two_change_cnt += 1
                else:
                    three_change_cnt += 1
            else:
                i += 1

        if len(s) < 6:
            return max(missing_type_cnt, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type_cnt, total_change_cnt)
        else:
            delete_cnt = len(s) - 20

            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1
            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2
            total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3

            return delete_cnt + max(missing_type_cnt, total_change_cnt)",O(n)
"class Solution(object):
    def getDescentPeriods(self, prices):
        result = l = 0
        for i in range(len(prices)):
            l += 1
            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:
                result += l*(l+1)//2
                l = 0
        return result",O(n)
"class Solution:
    def isPalindrome(self, s: str) -> bool:
        newStr = ''
        for c in s:
            if c.isalnum():
                newStr += c.lower()
        return newStr == newStr[::-1]
",O(n)
"from sys import stdin,stdout
for _ in range(1):

    moves,left=list(map(int,stdin.readline().split()))

    l=1;r=10**9+1
    while l<=r:
        mid=(l+r)>>1
        fx=(mid*(mid+1))//2-left+mid

        if fx<=moves:l=mid+1
        else:r=mid-1
    print(moves-r)",O(logn)
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",O(logn)
"n=int(input())
a=str(n)
m=len(a)
b=int(a[0:m-1])
c=int(a[0:m-2]+a[-1])
d=max(n,b,c)
print(d)
",O(1)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
ans = [0] * m
p = []
for i in range(n + m):
    if t[i] == 1:
        p.append(i)
ans[0] = p[0]
for i in range(m):
    if i == m - 1:
        ans[i] += n + m - p[i] - 1
    else:
        for j in range(p[i] + 1, p[i + 1]):
            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:
                ans[i] += 1
            else:
                ans[i + 1] += 1
print(' '.join(map(str, ans)))
",O(n ^ 2)
"class Solution(object):
    def halvesAreAlike(self, s):
        vowels = set(""aeiouAEIOU"")
        cnt1 = cnt2 = 0
        left, right = 0, len(s)-1
        while left < right:
            cnt1 += s[left] in vowels
            cnt2 += s[right] in vowels
            left += 1
            right -= 1
        return cnt1 == cnt2",O(n)
"n = int(input())
print(25)
",O(1)
"class Solution3(object):
    def findComplement(self, num):
        bits = '{0:b}'.format(num)
        complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits)
        return int(complement_bits, 2)",O(1)
"import collections


class Solution(object):
    def maxConsecutiveAnswers(self, answerKey, k):
        result = max_count = 0
        count = collections.Counter()
        for i in range(len(answerKey)):
            count[answerKey[i]] += 1
            max_count = max(max_count, count[answerKey[i]])
            if result-max_count >= k:
                count[answerKey[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"class Solution(object):
    def wonderfulSubstrings(self, word):
        ALPHABET_SIZE = 10
        count = [0]*(2**ALPHABET_SIZE)
        count[0] = 1
        result = curr = 0
        for c in word:
            curr ^= 1<<(ord(c)-ord('a'))
            result += count[curr]
            result += sum(count[curr^(1<<i)] for i in range(ALPHABET_SIZE))
            count[curr] += 1
        return result",O(n)
"from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",O(n)
"def MI():
    return map(int,input().split())
def I():
    return int(input())
def LI():
    return [int(i) for i in input().split()]

n,k=MI()

b=-(2*n+3)
c=n*n+n-2*k
x=(-b-((b*b-4*c)**0.5))//2
y=(-b+((b*b-4*c)**0.5))//2
x,y=int(x),int(y)
for i in [x-1,x,x+1,y-1,y,y+1]:
    if i**2+b*i+c==0 and 0<=i<=n-1:
        print(i)
        break",O(1)
"t = int(input())
for i in range(t):
    n = int(input())

    lens = sorted(map(int, input().split()))
    cnt = len(list(filter(lambda x: x> 0, lens[:-2])))

    print(min(cnt, lens[-2]-1))",O(nlogn)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)",O(nlogn)
"n = int(input())
a = str(input())
b = str(input())
k = True
result = 0
for i in range(n):
    if a[i] == b[i]:
        if k == False:
            result += 1
        k = True
    else:
        if k == False and z != a[i]:
            result += 1
            k = True
        elif k == False and z == a[i]:
            result += 1
        else:
            k = False
            z = a[i]
if k == False:
    result += 1
print(result)",O(n)
"cadena = input()
n = len(cadena)

rpta = 0

for i in range(n-1):
    tamanho_cadena = n-i-1
    for j in range(n-tamanho_cadena):
        subcadena = cadena[j:j+tamanho_cadena]
        contador = 1
        for k in range(n-tamanho_cadena-j):
            if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]:
                contador = contador + 1
        if contador >=2  and rpta == 0:
            rpta = tamanho_cadena
    if rpta !=0:
        break

print(rpta)",O(n ^ 3)
"class Solution2(object):
    def minOperationsToMakeMedianK(self, nums, k):
        nums.sort()
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
d = set(a)
if (0 in a):
    print(len(d)-1)
else:
    print(len(d))",O(n)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if k == 0:
        if n == 0 and m == 0:
            print(0)
        else:
            print(-1)
    elif k == 1:
        if max(abs(n), abs(m)) != 1:
            print(-1)
        elif abs(n) == abs(m) == 1:
            print(1)
        else:
            print(0)
    else:
        if max(abs(n), abs(m)) > k:
            print(-1)
        elif abs(n) == abs(m):
            if (k - abs(n)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:
            if (k - max(abs(n), abs(m))) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",O(1)
"class Solution(object):
    def furthestDistanceFromOrigin(self, moves):
        curr = cnt = 0
        for x in moves:
            if x == 'L':
                curr -= 1
            elif x == 'R':
                curr += 1
            else:
                cnt += 1
        return abs(curr)+cnt",O(n)
"n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
newarr=[0]

for num in arr:
  newarr+=[newarr[-1]^num]
dic={}
for num in newarr:
  x=(min(num,2**k-1-num),max(num,2**k-1-num))
  if x in dic:
    dic[x]+=1
  else:
    dic[x]=1
ans=0
for elem in dic:
  m=dic[elem]
  half=m//2
  ans+=half*(half-1)/2
  half=m-half
  ans+=half*(half-1)/2
ans=n*(n+1)/2-ans
print(int(ans))
",O(n)
"import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)",O(n)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))

        print(""."".join(ans))

for _ in range(int(input())):
    main()",O(n ^ 2)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
first_block_index = 0
max_indent = 0
for i in arr:
    if i != 'f':
        break
    first_block_index += 1
    max_indent += 1

dp[max_indent] = 1

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]
def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(first_block_index + 1,n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue

    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"class Solution(object):
    def findDistance(self, root, p, q):
        def iter_dfs(root, p, q):
            result = 0
            dist = [-1]
            stk = [(1, [root, dist])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [-1], [-1]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    if node.val in (p, q):
                        if ret1[0] == ret2[0] == -1:
                            ret[0] = 0
                        else:
                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1
                    elif ret1[0] != -1 and ret2[0] != -1:
                        result = ret1[0]+ret2[0]+2
                    elif ret1[0] != -1:
                        ret[0] = ret1[0]+1
                    elif ret2[0] != -1:
                        ret[0] = ret2[0]+1
            return result
        
        return iter_dfs(root, p, q)",O(n)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    b=sorted(a)
    op=0
    for i in range(n):
        if a[i]==b[i]:continue
        op+=1
    if op==0 or op==2:print('YES')
    else:print('NO')",O(nlogn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)

    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)

print('!', hat1^bb% (2**30), hat2)
",O(logn)
"n, x = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
s = set(a)
mv = 999
if len(s) < n:
    print(0)
else:
    for i in a:
        if i & x != i and i & x in s:
            print(1)
            break
    else:
        k = [i & x for i in a]
        if len(set(k)) < n:
            print(2)
        else:
            print(-1)
",O(n)
"n = int(input())
p = list(map(int, input().split()))
gr = [[] for i in range(n)]
for i in range(n - 1):
    gr[p[i] - 1].append(i + 1)

q = [0]
after = []
i = 0
s = [0 for i in range(n)]
used = set()
used.add(0)
while q:
    cur = q.pop()
    after.append(cur)
    for el in gr[cur]:
        if el not in used:
            used.add(el)
            q.append(el)
            i += 1

q = after
for j in range(i, -1, -1):
    if len(gr[q[j]]) == 0:
        s[q[j]] = 1
    else:
        ans = 0
        for c in gr[q[j]]:
            ans += s[c]
        s[q[j]] = ans
s.sort()
print(' '.join(list(map(str, s))))
",O(nlogn)
"class Solution(object):
    def queensAttacktheKing(self, queens, king):
        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),
                     (-1, 1), (1, 1), (1, -1), (-1, -1)]
        result = []
        lookup = {(i, j) for i, j in queens}
        for dx, dy in dirctions:
            for i in range(1, 8):
                x, y = king[0] + dx*i, king[1] + dy*i
                if (x, y) in lookup:
                    result.append([x, y])
                    break
        return result",O(1)
"from sys import stdin, stdout

idx1 = 0
idx2 = 0
VALD = 0

def getminmax(n, m, a):
    l = 0
    h = 1000000009

    while l < h:
        mid = (l+h+1)//2
        exists = existsequalorbig(mid, m, a)

        if exists:

            l = mid
        else:
            h = mid-1

def existsequalorbig(mid, m, a):
    global idx1
    global idx2
    global VALD

    abw = []
    hs = set()

    for i in range(len(a)):
        v = 0
        for j in range(m):
            if a[i][j] >= mid:
                v |= 1
            v <<= 1
        v >>= 1
        if v not in hs:
            hs.add(v)
            abw.append([i, v])

    for i in range(len(abw)):
        for j in range(i, len(abw)):
            if abw[i][1] | abw[j][1] == VALD:
                idx1 = abw[i][0]
                idx2 = abw[j][0]
                return True

    return False

if __name__ == '__main__':
    nm = list(map(int, stdin.readline().split()))
    n = nm[0]
    m = nm[1]

    VALD = int(pow(2, m) - 1)

    a = []
    for i in range(n):
        a.append(list(map(int, stdin.readline().split())))

    getminmax(n, m, a)

    stdout.write(str(idx1+1) + ' ' + str(idx2+1))",np
"n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)",O(n ^ 2)
"D = False

def hash(r,c):
    return str(r) + ""-"" + str(c)

def sol():
    R, C = [int(x) for x in input().split("" "")]
    m = []
    count = 0
    for _ in range(R):
        line = input()
        m.append(line)
        count += line.count(""

    if D: print(""Count:"", count)

    lookup = {}
    for r in range(1, R-1):
        for c in range(1, C-1):

            if D: print(""  row,col:"", r, c)

            offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
            lst = []
            fail = False

            for o in offset:

                cell = (r + o[0], c + o[1])
                if D: print(""  cell:"", cell, m[cell[0]][cell[1]])
                h = hash(cell[0], cell[1])

                if m[cell[0]][cell[1]] == ""
                    if (not h in lookup):
                        lst.append(h)

                else:
                    fail = True
                    break

            if not fail:
                for item in lst:
                    lookup[item] = True
                count -= len(lst)

    return ""YES"" if count == 0 else ""NO""

ans = sol()
print(ans)
",O(n ^ 2)
"import random
import collections



class Solution(object):
    def minCost(self, basket1, basket2):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        cnt = collections.Counter()
        for x in basket1:
            cnt[x] += 1
        for x in basket2:
            cnt[x] -= 1
        mn = min(cnt.keys())
        swaps = []
        for k, v in cnt.items():
            if v%2:
                return -1
            swaps.extend(k for _ in range(abs(v)//2))
        nth_element(swaps, len(swaps)//2)
        return sum(min(swaps[i], mn*2) for i in range(len(swaps)//2))",O(n)
"import sys
from collections import defaultdict

exist_num,new_width = map(int,sys.stdin.readline().strip().split())
buildings = []
for _ in range(exist_num):
    center, width = map(int,sys.stdin.readline().strip().split())
    buildings.append((center-width/2,center+width/2))
buildings.sort()
possible_loc = 2
for left,right in zip(buildings,buildings[1:]):
    gap=right[0] - left[1]
    if gap == new_width:
        possible_loc += 1
    elif gap > new_width:
        possible_loc += 2

print(possible_loc)
",O(nlogn)
"import math
def main():
    x = input()
    y = input()
    goal = x.count('+') - y.count('+')
    options = y.count('?')
    if options == 0:
        if goal == options:
            print(1)
        else:
            print(0)
    else:
        if (goal > options):
            print(0)
        else:
            if goal < 0:
                print(0)
            else:
                print(math.factorial(options)/math.factorial(goal)/math.factorial(options-goal)/(2**options))
main()
",np
"n,m,k = [int(w) for w in input().split()]
a = [int(w) for w in input().split()]

def f(o):
    r = e = 0
    for i, x in enumerate(a):
        if i < o:
            continue
        if i % m == o:
            e -= k
            if e < -k:
                e = -k
        e += x
        if e > r:
            r = e
    return r

print(max(f(o) for o in range(m)))
",O(n ^ 2)
"class Solution(object):
    def smallestString(self, s):
        result = list(s)
        i = next((i for i in range(len(s)) if s[i] != 'a'), len(s))
        if i == len(s):
            result[-1] = 'z'
        else:
            for i in range(i, len(s)):
                if result[i] == 'a':
                    break
                result[i] = chr(ord(result[i])-1)
        return """".join(result)",O(n)
"class Solution(object):
    def isGood(self, nums):
        cnt = [0]*len(nums)
        for x in nums:
            if x < len(cnt):
                cnt[x] += 1
            else:
                return False
        return all(cnt[x] == 1 for x in range(1, len(nums)-1))",O(n)
"class Solution(object):
    def numFactoredBinaryTrees(self, A):
        M = 10**9 + 7
        A.sort()
        dp = {}
        for i in range(len(A)):
            dp[A[i]] = 1
            for j in range(i):
                if A[i] % A[j] == 0 and A[i] // A[j] in dp:
                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]
                    dp[A[i]] %= M
        return sum(dp.values()) % M",O(n ^ 2)
"from sortedcontainers import SortedList



class Solution(object):
    def resultArray(self, nums):
        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            cnt1 = len(sl1)-sl1.bisect_right(nums[i])
            cnt2 = len(sl2)-sl2.bisect_right(nums[i])
            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):
                sl1.add(nums[i])
                a.append(nums[i])
            else:
                sl2.add(nums[i])
                b.append(nums[i])
        return a+b",O(nlogn)
"n,useless=list(map(int,input().split()))
arr=list(map(int,input().split()))
for x in range(1,n+1):
    if x not in arr:
        print(0)
        break
else:
    print(arr.count(min(arr,key=lambda x:arr.count(x))))",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import math

def main():
    l, r = map(int, input().split())
    for i in range(62, -1, -1):
        if ((1 << i) & l) ^ ((1 << i) & r):
            print((1 << (i+1)) - 1)
            break
    else:
        print(0)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"class Solution(object):
    def sumScores(self, s):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(s)
        z[0] = len(s)
        return sum(z)",O(n)
"debug = 0
BIG = 10 ** 9 + 1

input = raw_input

def prof(f):
    return f

def report(f):
    def new_f(x):
        res = f(x)

        return res

    return new_f if debug else f

def mcheck(a, pairs):
    m = len(a[0])
    allm = 2 ** m - 1

    subs = {i: {i} for i in range(allm + 1)}

    for i in range(allm + 1):
        for j in range(i):
            if i | j == i:
                subs[i].add(j)

    mx = [max(aa) for aa in a]

    @prof
    def check(v):
        masks = {0: -1}
        done = [False] * (allm + 1)
        for i, aa in enumerate(a):
            if mx[i] < v:
                continue
            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)

            if not done[c]:
                for cc in subs[c]:
                    if allm - cc in masks:
                        other = masks[allm - c]
                        pairs[v] = i, other
                        return True
                    masks[cc] = i
                    done[cc] = True

        return False

    return check

@prof
def go():
    n, m = map(int, input().split())

    a = []

    uniq = set()
    for _ in range(n):
        aa = tuple(map(int, input().split()))

        a.append(aa)
        uniq.update(aa)

    uniq = sorted(uniq)
    pairs = {0: (0, 0)}
    check = mcheck(a, pairs)
    l = 0
    r = len(uniq) - 1
    while l != r:
        if debug: print(l, r)
        if l + 1 == r:
            if check(uniq[r]):
                l = r
            else:
                r = l
            continue
        c = (l + r) // 2
        if check(uniq[c]):
            l = c
        else:
            r = c

    l = uniq[l]
    if debug: print(l, pairs[l])
    if l not in pairs:
        check(l)
    a = pairs[l][0]
    b = pairs[l][1]
    if b == -1:
        b = a

    print(""%d %d"" % (a + 1, b + 1))

go()
",np
"print(sum(i for i in range(int(input()),-1,-2)))",O(n)
"n=int(input())
g=n//2
print(g+n)",O(1)
"def main():
    n, k = [int(x) for x in input().split(' ')]
    if k==1:
        print(n)
        return
    a = []
    b = {}
    a = [int(x) for x in input().split(' ')]
    a.sort()

    c=dict(zip(a,range(n)))
    a=c
    count = {}

    for x in a:
        if x % k == 0 and int(x / k) in a:
            b[x] = b[int(x / k)]
            count[b[int(x / k)]] += 1
        else:
            b[x] = x
            count[x] = 1

    for x,y in count.items():
        n -= int(y / 2)

    print(n)

main()
",O(nlogn)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"n,k=map(int,input().split())
l,c=[],0
for _ in range(n):
	l.append(list(map(int,input().split())))
l.sort(reverse=True)
a,x,y=l[k-1][0],k-1,k-1
for i in range(k-2,-1,-1):
	if l[i][0]==a:
		x=i
	else:
		break
for i in range(k,n):
	if l[i][0]==a:
		y=i
	else:
		break
d=k-1-x
d=y-d
for i in range(y,x-1,-1):
	if l[i]==l[d]:
		c+=1
print(c)",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head",O(n)
"class Solution(object):
    def twoEggDrop(self, n):
        return int(math.ceil((-1+(1+8*n)**0.5)/2))",O(1)
"import sys
import math

t=1
for _ in range(t):

    a=input()
    b=input()
    dp=[0]*(11)
    for i in a:
        dp[int(i)]+=1

    if len(b)>len(a):
        ans=''
        for i in range(len(a)):
            for j in range(9,-1,-1):
                if dp[j]!=0:
                    ans+=str(j)
                    dp[j]-=1
                    break
    elif len(a)==len(b):
        ans=''
        a1=[]
        cmpr=''
        i=0
        while i<len(a):
            cmpr+=b[i]

            if i==0:
                flag=0
                for j in range(9,0,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        dp[j]-=1
                        ans+=str(j)
                        a1.append(j)
                        break
                if flag==0:
                    dp[1]-=1
                    a1.append(1)
                    ans+='1'
            else:
                flag=0
                for j in range(9,-1,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        ans+=str(j)
                        a1.append(j)
                        dp[j]-=1
                        break

                if flag==0:
                    ch=0
                    for i1 in range(i-1,-1,-1):
                        if ch==1:
                            break
                        for j1 in range(int(ans[i1])-1,-1,-1):
                            if i1==0:
                                if j1>0 and dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    index=i1
                                    a1.pop()
                                    a1.append(j1)
                                    ch=1
                                    break
                            else:
                                if  dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    a1.pop()
                                    index=i1

                                    a1.append(j1)
                                    ch=1
                                    break
                            if ch==1:
                                break
                        if ch==1:
                            break
                        val=a1.pop()
                        dp[val]+=1

                    ans=''
                    cmpr=''

                    dp=[0]*11
                    for i1 in range(len(a)):
                        dp[int(a[i1])]+=1

                    for i1 in range(len(a1)):
                        dp[a1[i1]]-=1

                    for i1 in range(len(a1)):
                        ans+=str(a1[i1])
                        cmpr+=b[i1]
                    i=index

            i+=1
    print(ans)",O(n ^ 3)
"digit = int(input())

if int(digit) <= 9:
    print(digit)
    exit()

start_range = 1
end_range = 9

power = 1
digit_count = 2
while not (start_range <= digit and digit <= end_range):
    start_range = end_range + 1
    end_range = 9 * 10**power * digit_count + start_range - 1
    power += 1
    digit_count += 1

offset_number = (digit - start_range) // (digit_count - 1)

number = str(10**(power - 1) + offset_number)

offset_digit = (digit - start_range) % (digit_count - 1)

print(f""{number[offset_digit]}"")
",O(logn)
"def sum(num):

    return (num * (num + 1)) // 2

def sum_from_to(fromm, to):
    if fromm <= 1:
        return sum(to)
    return sum(to) - sum(fromm)

def min_splitters():
    start = 1
    end = k
    while start < end:
        mid = (start + end) // 2
        mid_val = sum_from_to(mid, k)
        if mid_val == n:
            return k - mid + 1
        elif mid_val > n:
            start = mid + 1
        else:
            end = mid
    return k - start + 1

n, k = (int(i) for i in input().split())

if n == 1:
    print(0)

elif n <= k:
    print(1)
else:
    k -= 1
    n -= 1

    if sum(k) < n:
        print(-1)
    else:
        print(min_splitters())
",O(logn)
"x=input()
x,k=x.split()
x=int(x)
k=int(k)
mul=pow(2,k+1,1000000007)
y=(x%1000000007*mul)%1000000007
ans=y
if x!=0:
    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007

print(ans)",O(logn)
"import math

def find_nCr(n, r):
	return (math.factorial(n) / (math.factorial(r)*math.factorial(n-r)) )

sent = input()
received = input()

final_pos = 0
current_pos = 0
uncertain = 0

for s in sent:
	if s == ""+"":
		final_pos += 1
	else:
		final_pos -= 1

for s in received:
	if s == ""+"":
		current_pos += 1
	elif s == ""-"":
		current_pos -= 1
	else:
		uncertain += 1

if uncertain == 0:
	if final_pos == current_pos:
		print(1)
	else:
		print(0)
else:

	positions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2))

	try:
		pos_index = positions.index(final_pos)
		a = find_nCr(uncertain, pos_index)
		b = math.pow(2, uncertain)
		print(a/b)
	except:
		pos_index = -1
		print(0)
",np
"import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    s = list(input().rstrip())
    t = input().rstrip()
    ok = False
    for i in range(len(t)):
        t1 = list(t[:i]) + [""
        t2 = list(t[i:]) + [""

        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = 0
        for j, ch in enumerate(s):
            for k in range(len(t1)):
                if dp[j][k] == -1:
                    continue
                dp[j+1][k] = max(dp[j+1][k], dp[j][k])
                if ch == t1[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])
                if ch == t2[dp[j][k]]:
                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)
        for k in range(len(t) + 1):
            if dp[len(s)][k] + k >= len(t):
                ok = True

    if ok:
        print(""YES"")
    else:
        print(""NO"")",O(n ^ 3)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"l, r = [int(x) for x in input().split()]

q = l ^ r
a = 1
while q:
    q //=2
    a <<= 1
print(a-1)
",O(logn)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"class Solution(object):
    def placedCoins(self, edges, cost):
        def iter_dfs():
            result = [0]*len(cost)
            stk = [(1, (0, -1, [cost[0]]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (u, ret)))
                    stk.append((2, (u, p, 0, ret)))
                elif step == 2:
                    u, p, i, ret = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, i+1, ret)))
                    if v == p:
                        continue
                    new_ret = [cost[v]]
                    stk.append((3, (new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret = args
                    ret.extend(new_ret)
                    ret.sort()
                    if len(ret) > 5:
                        ret = ret[:2]+ret[-3:]
                elif step == 4:
                    u, ret = args
                    result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0)
            return result
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution3(object):
    def arrayPairSum(self, nums):
        nums = sorted(nums)
        return sum([nums[i] for i in range(0, len(nums), 2)])",O(nlogn)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
max_indent = 0

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]

def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue
    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"def solve(n, a):
    a = sorted(a)
    if n == 1:
        return a[0] > 0 and a[0] % 2 == 1
    same_count = 0
    for i in range(n - 1):
        if a[i] == a[i + 1] == 0:
            return False
        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:
            return False
        if a[i] == a[i + 1]:
            same_count += 1
    if same_count > 1:
        return False
    return (sum(a) - n * (n - 1) // 2) % 2 == 1

assert not solve(1, [0])
assert not solve(2, [1, 0])
assert solve(2, [2, 2])
assert solve(3, [2, 3, 1])
assert not solve(4, [1, 1, 2, 2])
assert solve(4, [1, 1, 2, 3])
assert not solve(4, [1, 2, 3, 4])
assert solve(4, [0, 1, 2, 4])
assert solve(5, [0, 1, 2, 3, 5])

n = int(input())
a = map(int, input().split())

r = solve(n, a)
if r:

    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left",O(n)
"n,k=map(int,input().split())
for i in range(10**5):
  if (i*(i+1))//2-(n-i)==k:
    print(n-i)",O(1)
"n, k = map(int, input().split())
s = input()

for i in range(1, n):
    if s[:n - i] == s[i:]:
        print(s + s[n - i:] * (k - 1))
        exit()
print(s * k)
",O(n ^ 2)
"import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
swaps = 0
for i in range(0, 2*n, 2):
    if a[i] == a[i+1]:
        continue

    c = a[i]
    j = i + 2
    while c != a[j]:
        j += 1

    MIN = i+1
    while j > MIN:
        a[j], a[j-1] = a[j-1], a[j]
        j -= 1
        swaps += 1

print(swaps)
",O(n ^ 2)
"n, t = map(int, input().split())
l = []
for _ in range(n):
  x, a = map(int, input().split())
  l.append((x-a/2, x+a/2))
l.sort()
res = 2

for i in range(n-1):
  if l[i+1][0] - l[i][1] == t:
    res += 1
  elif l[i+1][0] - l[i][1] > t:
    res += 2

print(res)
",O(nlogn)
"class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in range(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in range(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result",O(n)
"def solve(n,k):
    print(1*k,end = ' ')
    if n==2:
        print(2*k,end = ' ')
    if n == 3:
        print(k,3*k,end = ' ')
    else:
        temp = n//2
        if(n%2 == 0): temp -= 1
        print((str(k)+' ')*temp,end='')
        if(n>3):
            solve(n//2,k*2)

n = int(input())
solve(n,1)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def cord(c):
    return ord(c)-ord('a')

def main():
    n, m = RL()
    s = input()
    ct = [0]*(1<<m)

    for i in range(n-1):
        now, nex = cord(s[i]), cord(s[i+1])
        if now==nex: continue
        ct[1<<now | 1<<nex]+=1

    for i in range(m):
        for j in range(1<<m):
            if (1<<i) & j:
                ct[j]+=ct[(1<<i) ^ j]

    dp = [INF]*(1<<m)
    dp[0] = 0
    for i in range(1<<m):

        for j in range(m):

            if i & 1<<j == 0:
                sm = ct[-1]-ct[i]-ct[~i]
                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)

    print(dp[-1])

if __name__ == ""__main__"":
    main()
",np
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"import math
n = int(input())
A = [i + 1 for i in range(n)]
x = int(math.sqrt(n))
X = [A[i:i + x] for i in range(0, len(A), x)]
X = X[::-1]
f = [item for sublist in X for item in sublist]
print(*f)",O(n)
"from math import sqrt
n,k = map(int, input().split())

ub = k*(k+1)//2 - k+1

if n> ub:
    print(-1)
elif n == ub:
    print(k-1)
elif n == 1:
    print(0)
elif n<=k:
    print(1)
else:
    st = 1
    en = k-1
    target = n-1
    ub = k*(k-1)//2
    p = lambda x: ub - x*(x-1)//2
    ans = -1

    while st <= en:
        md = (st+en)//2
        if p(md) <= target:
            ans = md

            en = md-1
        else:
            st = md +1

    if p(ans) == target:
        print(k-ans)
    else:
        print(k-ans+1)
",O(logn)
"class Solution(object):
    def findSolution(self, customfunction, z):
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) < z:
            y += 1
        while y > 0:
            while y > 0 and customfunction.f(x, y) > z:
                y -= 1
            if y > 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result",O(n)
"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        charSet = set()
        l = 0
        res = 0

        for r in range(len(s)):
            while s[r] in charSet:
                charSet.remove(s[l])
                l += 1
            charSet.add(s[r])
            res = max(res, r - l + 1)
        return res
",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

p0 = getIntList()
p1 = getIntList()
p2 = getIntList()

zp = [p0, p1, p2]

def getpath( p0, p1):
    if p0[0] < p1[0]:
        sp = 1
    elif p0[0] > p1[0]:
        sp = -1
    else:
        sp =0
    zz = [tuple(p0), tuple(p1)]
    if sp!=0:
        for x in range(p0[0], p1[0]+ sp, sp):
            tp = (x, p0[1])
            zz.append(tp)
    if p0[1] < p1[1]:
        sp = 1
    elif p0[1] > p1[1]:
        sp = -1
    else:
        sp = 0
    if sp!=0:
        for y in range(p0[1], p1[1] + sp, sp):
            tp = (p1[0], y)
            zz.append(tp)
    return zz

nr = 1000000;
zr = set()
for i in range(3):
    for j in range(3):
        cx = zp[i][0]
        cy = zp[j][1]
        cp = (cx, cy)
        z1 = getpath(cp, zp[0])
        z2 =getpath(cp, zp[1])
        z3 =getpath(cp, zp[2])

        z0 = z1+z2+z3
        s1 = set(z0)
        dprint(cp,s1)
        if len(s1) < nr:
            nr = len(s1)
            zr = s1

print(len(zr))
for x in zr:
    print(x[0], x[1])
",O(1)
"class Solution(object):
    def rotate(self, matrix):
        n = len(matrix)

        for i in range(n):
            for j in range(n - i):
                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]

        for i in range(n / 2):
            for j in range(n):
                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]

        return matrix",O(n ^ 2)
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        dp = [[[0]*26 for _ in range(len(s))] for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if i == j-1:
                    if s[j] == s[i]:
                        dp[i%2][j][ord(s[i])-ord('a')] = 2
                else:
                    for k in range(26):
                        if s[j] == s[i] and ord(s[j])-ord('a') != k:
                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2)
                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])
        return max(dp[0][-1])",O(n ^ 2)
"base = 1000000007
n , m , k = map(int,input().split())
a = list(map(int,input().split()))
mx = 0
s = 0
dp = []
dd= []
for j in range(m):
    for i in range(n+1):
        dp.append(base)
        dd.append(0)
    for i in range(n):
        dd[i+1]=dd[i]+a[i]-k*(i % m== j)
        dp[i+1] = min(dd[i],dp[i])

        if (i % m == j):
            mx = max ( mx , dd[i+1]-dp[i+1])
print(mx)",O(n ^ 2)
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1

    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)",O(n)
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

n,s=num()
cc=0
for i in range(n,0,-1):
	cc+=s//i
	s=s%i
print(cc)",O(1)
"n, k = map(int, input().split())

a = 1
b = -(2*n+3)
c = (n*n+n-2*k)

d = int((b*b - 4*a*c) ** 0.5)

s1 = (-b + d) // (2 * a)
s2 = (-b - d) // (2 * a)
if s1 >= 0 and s1 <= n:
    print(s1)
else:
    print(s2)
",O(1)
"n,k = map(int,input().split())
s = input()
f = 0
for i in range(1,n):
    if s[:n-i]==s[i:]:
        f=1
        break
if f==0:
    print(s*k)
else:
    j = n-i
    final = s[j:]
    print(s+final*(k-1))",O(n ^ 2)
"class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)",O(n)
"class Solution(object):
    def maxFrequency(self, nums, k, numOperations):
        nums.sort()
        result = 0
        left, right = 0, -1
        cnt = collections.defaultdict(int)
        for i in range(len(nums)):
            while right+1 < len(nums) and nums[right+1]-nums[i] <= k:
                cnt[nums[right+1]] += 1 
                right += 1
            while nums[i]-nums[left] > k:
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, cnt[nums[i]]+min((right-left+1)-cnt[nums[i]], numOperations))
        left = 0
        for right in range(len(nums)):
            while nums[left]+k < nums[right]-k:
                left += 1
            result = max(result, min(right-left+1, numOperations))
        return result
    
import collections",O(nlogn)
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)

    prev = lst[i][0]
print(ans+prev)",O(n)
"n = int(input())
a = [int(i) for i in input().split()]

total = sum(a)
final = n * (n-1) // 2
repeated = []
count = {}

for i in a:
    try:
        count[i] += 1
        repeated.append(i)
    except KeyError:
        count[i] = 1

moves = total - final

if len(repeated) > 1:
    print('cslnb')

elif 0 in repeated:
    print('cslnb')

elif len(repeated) == 1 and repeated[0] - 1 in a:
    print('cslnb')

else:
    if moves % 2 == 0 or moves <= 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"class Solution(object):
    def buildArray(self, nums):
        for i in range(len(nums)):
            prev, curr = i, nums[i]
            while curr >= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in range(len(nums)):
            if nums[i] < 0:
                nums[i] = ~nums[i]
        return nums",O(n)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed

            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"n=int(input())
a=list(map(int,input().split()))
d=set()
t={}
rep=set()
if a.count(0)>=2:
	print(""cslnb"")
	exit()

for i in a:
	if i in d:
		if t[i]+1==3:
			print(""cslnb"")
			exit()
		else:
			t[i]+=1
			rep.add(i)
			if len(rep)>=2:
				print(""cslnb"")
				exit()
	else:
		t[i]=1
		d.add(i)
if rep:
	for c in rep:
		if c-1 in d:
			print(""cslnb"")
			exit()
s=0
a.sort()
for i in range(n):
	s+=a[i]-i
if s%2==1:print(""sjfnb"")
else:print(""cslnb"")",O(nlogn)
"from math import ceil, log
from heapq import heappop, heappush, heapify
t = 1
for test in range(t):
    n,k = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]
    maxcoins = [0 for i in range(k)]
    heapify(maxcoins)
    ans = list(p)
    tmpSum = 0
    tmpSum2 = 0
    prev = arr[0][1]
    for ind, power in arr:
        if power>prev:
            ans[ind] = tmpSum+c[ind]
            tmpSum2 = tmpSum
        else:
            ans[ind] = tmpSum2+c[ind]
        heappush(maxcoins, c[ind])
        tmpSum+=c[ind]
        tmpSum-=heappop(maxcoins)
    print(*ans)
",O(nlogn)
"N, M = map(int, input().split())

grid = []
for _ in range(N):
    grid.append(list(input()))

def check(grid, i, j, sx, sy):
    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:
        i -= sx
        j -= sy
        v = grid[i][j] == '
        return v

    return False

prev = False
for m in range(M):
    for n in range(N):
        if grid[n][m] == '
            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):
                print(""NO"")
                exit(0)

print(""YES"")
",O(n ^ 2)
"class Solution(object):
    def isSumEqual(self, firstWord, secondWord, targetWord):
        def stoi(s):
            result = 0
            for c in s:
                result = result*10 + ord(c)-ord('a')
            return result
        
        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)",O(n)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda pair: pair[1])
        prevEnd = intervals[0][1]
        res = 0

        for i in range(1, len(intervals)):
            if prevEnd > intervals[i][0]:
                res += 1
            else:
                prevEnd = intervals[i][1]

        return res
",O(nlogn)
"n, s = map(int, input().split())
res = 0
for i in range(n, 0, -1):
    res += s//i
    s = s % i
print(res)",O(n)
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)

def solve(N, A):

    valToLeftRight = defaultdict(lambda: defaultdict(set))

    valToRightLeft = defaultdict(lambda: defaultdict(set))

    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:

                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)

                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:

                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):

        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:

            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)

def tup(l, r):

    return l * 16384 + r

def untup(t):

    return divmod(t, 16384)

def solve(N, A):

    cache = {}

    def f(lr):
        if lr not in cache:
            l, r = untup(lr)

            if r - l == 1:
                return tup(1, A[l])
            best = tup(float(""inf""), float(""inf""))
            for i in range(l + 1, r):

                lSplit = f(tup(l, i))
                rSplit = f(tup(i, r))
                lLen, lVal = untup(lSplit)
                rLen, rVal = untup(rSplit)
                if lLen != 1 or rLen != 1:

                    best = min(best, tup(lLen + rLen, 9999))
                else:
                    if lVal == rVal:

                        best = min(best, tup(1, lVal + 1))
                    else:

                        best = min(best, tup(2, 9999))
            cache[lr] = best

        return cache[lr]

    ans = untup(f(tup(0, N)))[0]

    return ans

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)",O(n ^ 3)
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",O(logn)
"from sys import stdin, stdout
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

a, b = mp()
c = 0
x = 0
while not (c>=b and c-b+x==a):
    x += 1
    c += x
print(a-x)",O(logn)
"import sys

n, m, k = map(int, input().split())

hor = [list(map(int, input().split())) for _ in range(n)]

ver = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2:
    for i in range(n):
        print(*([-1]*m))
    sys.exit()

k = k // 2
dp = [[[0]*m for _ in range(n)] for _ in range(k+1)]

for x in range(1, k+1):
    for y in range(n):
        for z in range(m):
            hold = float('inf')
            if y != 0:
                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )
            if y != n-1:
                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )
            if z != 0:
                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )
            if z != m-1:
                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )
            dp[x][y][z] = hold

for row in dp[k]:
    print(*map(lambda i: i*2, row))
",O(n ^ 3)
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []
if num <= bb:
    print(num)
    exit(0)

for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    elif mx < b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)
        break
    elif mx == b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()

for i in rem:
    f.append(i)

print(get(f))
",O(n ^ 3)
"class Solution3(object):
    def getConcatenation(self, nums):
        return nums*2",O(n)
"class Solution(object):
    def validateStackSequences(self, pushed, popped):
        i = 0
        s = []
        for v in pushed:
            s.append(v)
            while s and i < len(popped) and s[-1] == popped[i]:
                s.pop()
                i += 1
        return i == len(popped)",O(n)
"def luckynumber(n):
    a=[]
    for i in range(4,n+1):
        r=i
        c=0
        while(r>0):
            x=r%10
            if x!=4 and x!=7:
                c=1
                break
            r=r//10
        if c==0:
            a.append(i)
    return a
n=int(input())
a=luckynumber(n)
for i in a:
    if n==i or n%i==0:
        print(""YES"")
        break
else:
    print(""NO"")
",O(1)
"N, MOD = map(int, input().split())
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
limit = 1000
frac = [1]*limit
for i in range(2,limit):
    frac[i] = i * frac[i-1]%MOD
fraci = [None]*limit
fraci[-1] = pow(frac[-1], MOD -2, MOD)
for i in range(-2, -limit-1, -1):
    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD
bb = [1, 2]
for i in range(1000):
    bb.append(bb[-1] *2 %MOD)
for ln in range(N+1):
    for cnt in range(ln//2, ln+1):
        for k in range(1, N-ln+1):
            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD
            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD
            dp[ln+k+1][cnt+k] %= MOD
R = 0
for x in dp[N+1][:N+1]:
    R = (R+x)%MOD
print(R)
",O(n ^ 3)
"n,m=map(int, input().split())
cols=[]
for i in range(n):
    cols.append(int(input()))
rows=[]
for i in range(m):
    k=list(map(int, input().split()))
    if k[0]==1:
        rows.append(k[1])
ans=n+m
cols.sort()
rows.sort()
cols.append(int(1e9))
j=0
rem=0

for i in cols:
    while j<len(rows) and rows[j]<i:
        j+=1
    ans=min(ans, len(rows)-j+rem)
    rem+=1
print(ans)
",O(nlogn)
"a = int(input())

print(a**2+(a-1)**2)
",O(1)
"class Solution2(object):
    def plusOne(self, digits):
        result = digits[::-1]
        carry = 1
        for i in range(len(result)):
            result[i] += carry
            carry, result[i] = divmod(result[i], 10)
        if carry:
            result.append(carry)
        return result[::-1]",O(n)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        for num in nums :
            idx = abs(num) - 1
            if nums[idx] < 0 :
                return abs(num)
            nums[idx] *= -1
        return -1
",O(n)
"class Solution(object):
    def lexicographicallySmallestArray(self, nums, limit):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        groups = []
        for i in range(len(nums)):
            if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit:
                groups.append([])
            groups[-1].append(idxs[i])
        result = [-1]*len(nums)
        for g in groups:
            for i, j in enumerate(sorted(g)):
                result[j] = nums[g[i]]
        return result",O(nlogn)
"def check(s,t1,t2):
    s1 = len(t1)
    s2 = len(t2)
    n = len(s)
    dp = [[-1] * (s1+1) for i in range(n + 1)]
    dp[0][0] = 0
    for i in range(n):
        for j in range(s1+1):
            if dp[i][j] >= 0:
                if  j < s1 and t1[j] == s[i]:
                    dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j])
                if dp[i][j] < s2 and t2[dp[i][j]] == s[i]:
                    dp[i+1][j] = max(dp[i+1][j],dp[i][j]+1)
            dp[i+1][j] = max(dp[i+1][j],dp[i][j])

    if dp[n][s1] == s2:
        return True
    else:
        return False

def solve():
    s = input()
    t = input()
    le = len(t)

    for i in range(le):
        t1 = t[:i]
        t2 = t[i:]
        if check(s,t1,t2) == True:
            print(""YES"")
            return
    print(""NO"")

T = int(input())
while T:
    T -= 1
    solve()",O(n ^ 3)
"arr = []
d = {}
for _ in range(int(input())):
    s = input()
    a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split(""."")))
    x = (a+b)/c
    arr.append(x)
    if x not in d:
        d[x] = 0
    d[x] += 1

for i in arr:
    print(d[i], end = "" "")",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",O(nlogn)
"from operator import xor
from functools import reduce


class Solution(object):
    def xorGame(self, nums):
        return reduce(xor, nums) == 0 or \
            len(nums) % 2 == 0",O(n)
"class Solution(object):
    def semiOrderedPermutation(self, nums):
        i, j = nums.index(1), nums.index(len(nums))
        return i+((len(nums)-1)-j)-int(i > j)",O(n)
"n,k=map(int,input().split())
same=[0]*(k+1)
diff=[0]*(k+1)
same[1]=2
if k>1:
    diff[2]=2
for i in range(n-1):
    newsame=[0]*(k+1)
    newdiff=[0]*(k+1)
    for i in range(1,k+1):
        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353
    for i in range(2,k+1):
        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353
    same=newsame
    diff=newdiff
print((same[-1]+diff[-1])%998244353)",np
"x = list(map(int, input().split()))

start = 0
end = x[0] -1

target = x[1]

ans = 0

while start<= end:

    mid = (start+end)//2
    sum = mid*(mid+1) //2

    ans1 = x[0] - mid

    if sum - ans1 == target:
        ans = ans1
        break
    elif sum - ans1 > target:
        end = mid - 1
    else:
        start = mid+1

print(ans)
",O(logn)
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf

def solve():
    n, m = map(int, input().split())
    cnt = defaultdict(int)
    res = []
    for i in range(n):
        A = list(map(int, list(input())))
        res.append(A)
        for j in range(m):
            if A[j]:
                cnt[j] += 1
    valid = False
    for r in res:
        j = [i for i in range(m) if r[i]]
        if all(cnt[i] > 1 for i in j):
            valid = True
            break
    if valid:
        print(""YES"")
    else:
        print(""NO"")

t = 1

while t:
    t -= 1
    solve()
",O(n ^ 2)
"def digit(a):
    s=0
    while a:
        s+=a%10
        a//=10
    return s

def big(n,s):
    lo=1
    hi=n
    while lo<=hi:
        mid=(lo+hi)//2
        if mid-digit(mid)<s:
            lo=mid+1
        else:
            hi=mid-1
    return n-lo+1

a,b=map(int,input().strip().split())
print(big(a,b))",O(logn)
"class Solution2(object):
    def wiggleSort(self, nums):
        nums.sort()
        med = (len(nums) - 1) // 2
        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]",O(nlogn)
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",O(n ^ 2)
"n=int(input())
list1=list(map(int,input().split(' ')))
sum2=0
sum1=0
count=0
list1.sort(reverse=True)
for i in range(len(list1)):
    sum1=sum1+list1[i]

for i in range(len(list1)):
    if(int(sum1/2)>=sum2):
        sum2=sum2+list1[i]
        count=count+1
print(count)",O(nlogn)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(e,g)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"n = int(input())
n+=1
if n==1:
	print(0)
elif n%2==0:
	print(n//2)
elif n%2!=0 and n!=1:
	print(n)",O(1)
"class Solution(object):
    def generateMatrix(self, n):
        matrix = [[0 for _ in range(n)] for _ in range(n)]

        left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1

        while left <= right and top <= bottom:
            for j in range(left, right + 1):
                matrix[top][j] = num
                num += 1
            for i in range(top + 1, bottom):
                matrix[i][right] = num
                num += 1
            for j in reversed(range(left, right + 1)):
                if top < bottom:
                    matrix[bottom][j] = num
                    num += 1
            for i in reversed(range(top + 1, bottom)):
                if left < right:
                    matrix[i][left] = num
                    num += 1
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

        return matrix",O(n ^ 2)
"k = int(input())
k -= 1

pow_10, length = 1, 1

while 9 * pow_10 * length < k:
    k -= 9 * pow_10 * length
    pow_10 *= 10
    length += 1

div = k / length
rem = k % length

num = pow_10 + div

print(str(num)[rem])
",O(logn)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += 1 if n & 1 else 0
            n >>= 1
        return res
",O(1)
"N, K = map(int, input().split())

print((K+N-1)//N)
",O(1)
"n, l, r, x = map(int, input().split())
a = [int(i) for i in input().split()]

count = 0
for i in range(1, 2**n+1):
	temp = []
	for j in range(n):
		if i & (1 << j):
			temp.append(a[j])

	if len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r:
		count += 1

print(count)",np
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",O(n ^ 2)
"n, U = list(map(int, input().strip().split()))
E = list(map(int, input().strip().split()))

mmax = -1
for i in range(0, n-2):
    j = i + 1
    l = j + 1
    r = n - 1
    while l < r:
        mid = (l + r) // 2
        if E[mid] - E[i] <= U:
            l = mid + 1
        else:
            r = mid - 1
    if E[l] - E[i] <= U:
        cur = (E[l] - E[j]) / (E[l] - E[i])
        mmax = max(mmax, cur)
    else:
        if l - 1 > j and E[l-1] - E[i] <= U:
            cur = (E[l-1] - E[j]) / (E[l-1] - E[i])
            mmax = max(mmax, cur)
print(mmax)
",O(nlogn)
"class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = left = gap = 0
        for right in range(len(tiles)):
            if right-1 >= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 >= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"class Solution2(object):
    def maximumSumScore(self, nums):
        total = sum(nums)
        prefix = 0
        result = float(""-inf"")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result",O(n)
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*(1 << n) for _ in range(n)]
dp[0][1] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[i][mask] = max(
                    dp[i][mask],
                    dp[i][mask - (1 << j)] * prob[i][j]
                    + dp[j][mask - (1 << i)] * prob[j][i]
                )

print(max(dp[i][-1] for i in range(n)))
",np
"class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):
        def num_days(date):
            Y, M, D = list(map(int, date.split(""-"")))
            leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap
     
        return abs(num_days(date1) - num_days(date2))",O(1)
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0",O(n)
"r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))

dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] != -1:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]

    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",O(n ^ 3)
"def onseg(p,q,r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \
           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p,q,r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - \
          (q[0] - p[0]) * (r[1] - q[1])

    if (val == 0): return 0
    return 1 if val > 0 else 2

def doint(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and onseg(p1, p2, q1): return True
    if o2 == 0 and onseg(p1, q2, q1): return True
    if o3 == 0 and onseg(p2, p1, q2): return True
    if o4 == 0 and onseg(p2, q1, q2): return True

    return False

x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())
x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())

A = x0,y0
B = x1,y1
C = x2,y2
D = x3,y3
a = x4,y4
b = x5,y5
c = x6,y6
d = x7,y7

if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \
   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \
   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \
   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \
   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \
   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):
    print('YES')
else:
    print('NO')
",O(1)
"class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(nlogn)
"import itertools




class Solution2(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = (8+2)//2
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            def update(arr, i): 
                for j in reversed(range(len(arr))):
                    if points[i][1]-points[arr[j]][1] > result[0]:
                        break
                    result[:] = min(result, dist(i, arr[j]))
                else:
                    j = -1
                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)

            if left == right:
                return
            mid = left+(right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            tmp, tmp_l, tmp_r = [], [], []
            l, r = left, mid+1
            while l <= mid or r <= right:
                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): 
                    update(tmp_r, order[l])
                    if x-points[order[l]][0] <= result[0]: 
                        tmp_l.append(order[l])
                    tmp.append(order[l])
                    l += 1
                else:
                    update(tmp_l, order[r])
                    if points[order[r]][0]-x <= result[0]: 
                        tmp_r.append(order[r])
                    tmp.append(order[r])
                    r += 1
            order[left:right+1] = tmp

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))",O(nlogn)
"class Solution(object):
    def numberOfMatches(self, n):
        return n-1",O(1)
"n=int(input())
print((n+2)//2)",O(1)
"import sys
import math
def rec(i,n,l):

    if i == n:
        return []

    else:
        x = l2[i]
        flag = 0
        o = []
        p = []
        mi = -1
        for j in l:
            if j < x:
                if j > mi:
                    if i == 0 and j == 0:
                        o.append(j)
                        p.append(j)
                        continue

                    mi = j

            if x == j:
                flag = 1

            o.append(j)
            p.append(j)

        if flag:
            o.remove(x)

        if mi == -1 and flag == 0:
            return []

        ans1 = []
        if flag:

            ans1 = [x]+rec(i+1,n,o)

        if mi != -1:
            p.remove(mi)

        p.sort(reverse = True)
        ans2 = [mi]+p
        if len(ans1) == n-i:
            return ans1

        else:
            return ans2

for _ in range(1):
    a = int(input())
    b = int(input())
    e1 = str(a)
    e2 = str(b)
    l1 = []
    l2 = []
    for i in e1:
        l1.append(int(i))

    for i in e2:
        l2.append(int(i))

    if len(l1) < len(l2):
        l1.sort(reverse = True)
        o = []
        for i in l1:
            o.append(str(i))

        print("""".join(o))

    else:
        n = len(l2)
        ans = rec(0,n,l1)
        w = []
        for i in ans:
            w.append(str(i))

        print("""".join(w))",O(n ^ 3)
"import itertools

n , l , r , x = map(int,input().split())

problems = list(map(int,input().split()))

ans = 0

for i in range(2 , n + 1 ):
    for j in itertools.combinations(problems ,i):
        if (l <= sum(j) <= r and max(j) - min(j) >= x):
            ans +=1

print(ans)
",np
"class Solution(object):
    def numberOfSubarrays(self, nums):
        result = 0
        stk = []
        for x in nums:
            while stk and stk[-1][0] < x:
                stk.pop()
            if not stk or stk[-1][0] != x:
                stk.append([x, 0])
            stk[-1][1] += 1
            result += stk[-1][1]
        return result",O(n)
"import collections



class Solution(object):
    def finalString(self, s):
        dq = collections.deque()
        parity = 0
        for x in s:
            if x == 'i':
                parity ^= 1
            else:
                dq.appendleft(x) if parity else dq.append(x)
        if parity:
            dq.reverse()
        return """".join(dq)",O(n)
"n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
boys.sort(reverse=True)
girls.sort(reverse=True)
s = sum(boys)
ma = max(boys)

res = 0
for i in range(0, m):

    if girls[i] < ma:
        print(-1)
        exit(0)
    res += s
    if (girls[i] == ma):
        girls[i] = 0
j = 0
usage = 0
for i in range(0, m):
    if (usage == m - 1):
        j += 1
    if (j >= n):
        print(-1)
        exit(0)

    res += max(0, girls[i] - boys[j])
    usage += 1
print(res)",O(nlogn)
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))

main()
",O(1)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, K = getIntList()

r=  K//N
if K%N!=0: r+=1

print(r)
",O(1)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])
            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"N = int(input())
first = []
second = []
for i in range(N):
    first.append([s for s in input()])
for i in range(N):
    second.append([s for s in input()])

def rotate_90(matrix):
    return list(zip(*matrix[::-1]))

def flip(matrix):
    return matrix[::-1]

def compare_matrices(first, second):
    for i in range(N):
        for j in range(N):
            if first[i][j] != second[i][j]:
                return False
    return True

def wrap(first, second):
    if compare_matrices(first, second) == True:
        return 'Yes'
    hold_first = first[::]
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    first = hold_first
    first = flip(first)
    if compare_matrices(first, second) == True:
        return 'Yes'
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    return 'No'

print(wrap(first, second))",O(n ^ 2)
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N

fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break

            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",O(n ^ 3)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	if n==1:
		return 1
	cnt=2
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			if i!=n//i:
				cnt+=2
			else:
				cnt+=1
	return cnt

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n,k=mi()
	arr=[]
	for _ in range(n):
		x,y=mi()
		arr.append((x,y))

	arr=sorted(arr,key=lambda x: x[0],reverse=True)

	for i in range(n-1):
		for j in range(i+1,n):
			if arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:
				arr[i],arr[j]=arr[j],arr[i]

	cnt=arr.count(arr[k-1])
	print(cnt)

if __name__ == '__main__':
	main()",O(nlogn)
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

for i in range(1,(kk//2)+1) :

	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])

				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",O(n ^ 3)
"class Solution2(object):
    def upsideDownBinaryTree(self, root):
        return self.upsideDownBinaryTreeRecu(root, None)

    def upsideDownBinaryTreeRecu(self, p, parent):
        if p is None:
            return parent

        root = self.upsideDownBinaryTreeRecu(p.left, p)
        if parent:
            p.left = parent.right
        else:
            p.left = None
        p.right = parent

        return root",O(n)
"class Solution(object):
    def addDigits(self, num):
        return (num - 1) % 9 + 1 if num > 0 else 0",O(1)
"def main():
    n, m = list(map(int, input().split()))
    b = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b.sort()
    g.sort()
    if b[-1] > g[0]:
        print(-1)
        return
    if b[-1] == g[0]:
        print(sum(g) + m * (sum(b) - b[-1]))
        return
    if n == 1:
        print(-1)
        return
    print(sum(g) + b[-1] + b[-2] * (m - 1) + m * (sum(b) - b[-1] - b[-2]))
main()",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n)
"def power(x , y):
    res = 1
    while y > 0 :
        if y % 2 != 0 :
            res = res * x
        y //= 2
        x *= x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % power(2 , n))

else:
    print(m)
",O(1)
"n, s = map( int, input().split() )

ans = 0
while s > 0:
    a = s // n
    s -= n * a
    ans += a
    n -= 1

print( ans )
",O(n)
"import collections



class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
            if cnt[nums[i]]:
               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD
            cnt[nums[i]] += 1
            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"from collections import Counter

def main():
    n, m = map(int, input().split())
    l = list(map(int, input().split()))
    p = l.index(m)
    le, ri = Counter(), Counter()
    c = 0
    le[0] = ri[0] = 1
    for i in range(p + 1, n):
        if l[i] < m:
            c += 1
        else:
            c -= 1
        ri[c] += 1
    c = 0
    for i in range(p - 1, -1, -1):
        if l[i] < m:
            c -= 1
        else:
            c += 1
        le[c] += 1
    res = 0
    for c, x in le.items():
        res += x * (ri[c] + ri[c - 1])
    print(res)

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution2(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",O(nlogn)
"from itertools import accumulate
from sys import stdin, stdout

def main():
    k = int(stdin.readline())
    a = [
        tuple(map(int, stdin.readline().split()[1:]))
        for _ in range(k)
    ]
    a2ij = {
        aij: (i, j)
        for i, ai in enumerate(a)
        for j, aij in enumerate(ai)
    }

    plena = [0, ] + list(accumulate(map(len, a)))
    suma = tuple(map(sum, a))
    totala = sum(suma)

    if totala % k != 0:
        stdout.write(""No\n"")
    else:
        needle = totala // k
        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)
        dp = compute_previous_mask(mask2i2cp)
        output(dp, mask2i2cp)

def compute_mask2i2cp(a, a2ij, needle, plena, suma):
    used = [False, ] * plena[-1]
    number_of_masks = 1 << len(a)
    mask2i2cp = [-1, ] * number_of_masks

    for i, ai in enumerate(a):
        for j, aij in enumerate(ai):
            if not used[plena[i] + j]:
                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)

                if i2cp != -1:
                    mask2i2cp[mask] = i2cp

                    for cp in i2cp:
                        if cp != -1:
                            c, p = cp
                            ii, jj = a2ij[c]
                            used[plena[ii] + jj] = True

    return mask2i2cp

def output(dp, mask2i2cp):
    mask = len(mask2i2cp) - 1

    if dp[mask] == -1:
        stdout.write(""No\n"")
    else:
        answer = [-1, ] * len(mask2i2cp[dp[mask]])

        while mask > 0:
            current_mask = dp[mask]

            for i, cp in enumerate(mask2i2cp[current_mask]):
                if 1 == ((current_mask >> i) & 1):
                    c, p = cp
                    answer[i] = (c, p)

            mask ^= current_mask

        stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))

def compute_mask_i2cp(a2ij, aij, i, j, needle, suma):
    i2cp = [-1, ] * len(suma)
    mask = 0
    current_a = aij
    current_i = i

    try:
        while True:
            next_a = needle - (suma[current_i] - current_a)

            next_i, next_j = a2ij[next_a]

            if ((mask >> next_i) & 1) == 1:
                return mask, -1

            mask |= 1 << next_i
            i2cp[next_i] = (next_a, current_i)

            if next_i == i:
                if next_j == j:
                    return mask, i2cp

                return mask, -1

            if next_i == current_i:
                return mask, -1

            current_a = next_a
            current_i = next_i
    except KeyError:
        return mask, -1

def compute_previous_mask(mask2cp):
    number_of_masks = len(mask2cp)
    dp = [-1, ] * number_of_masks
    dp[0] = 0

    for mask, cp in enumerate(mask2cp):
        if cp != -1:
            complement_mask = (number_of_masks - 1) & (~mask)
            previous_mask = complement_mask

            while previous_mask > 0:
                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:
                    dp[previous_mask | mask] = mask

                previous_mask = (previous_mask - 1) & complement_mask

            if dp[mask] == -1:
                dp[mask] = mask
    return dp

if __name__ == '__main__':
    main()
",np
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",O(nlogn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = [False] * n
        posDiag = [False] * (n * 2)
        negDiag = [False] * (n * 2)
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if col[c] or posDiag[r + c] or negDiag[r - c + n]:
                    continue
                col[c] = True
                posDiag[r + c] = True
                negDiag[r - c + n] = True
                board[r][c] = ""Q""

                backtrack(r + 1)

                col[c] = False
                posDiag[r + c] = False
                negDiag[r - c + n] = False
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution(object):
    def minBitFlips(self, start, goal):
        return bin(start^goal).count('1')",O(logn)
"class Solution2(object):
    def kthLuckyNumber(self, k):
        return bin(k+1)[3:].replace('1', '7').replace('0', '4')",O(logn)
"n, s = list(map(int, input().split()))

def sum_of_digits(n):
	ans = 0
	for c in str(n):
		ans += int(c)
	return ans
m = s + 10 - s%10

while m - sum_of_digits(m) < s:
	m += 10
if m <= n:
	print(n - m + 1)
else:
	print(0)
",O(logn)
"import collections


class Solution(object):
    def canConstruct(self, s, k):
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.values())
        return odd <= k <= len(s)",O(n)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            dfs(node.left)
            arr.append(node.val)
            dfs(node.right)

        dfs(root)
        return arr[k - 1]
",O(n)
"n, k = map(int, input().split())
l = list(map(int, input().split()))

o = 2
for i in range(n):
    if i+1 == n:
        break

    d = abs(l[i] - l[i+1]) / k
    if d ==  2:
        o += 1
    elif d > 2:
        o += 2

print(o)",O(n)
"n,k=map(int,input().split())
low=1
high=n
import sys
while low<=high:
    mid=(low+high)//2
    if mid*(mid+1)//2 -(n-mid)>k:
        high=mid-1
    elif mid*(mid+1)//2-(n-mid)==k:
        print(n-mid)
        sys.exit()
    else :
        low=mid+1",O(logn)
"import collections


class Solution(object):

    def __init__(self):
        self.__freq = collections.Counter()
        self.__group = collections.defaultdict(list)
        self.__maxfreq = 0

    def push(self, x):
        self.__freq[x] += 1
        if self.__freq[x] > self.__maxfreq:
            self.__maxfreq = self.__freq[x]
        self.__group[self.__freq[x]].append(x)   

    def pop(self):
        x = self.__group[self.__maxfreq].pop()
        if not self.__group[self.__maxfreq]:
            self.__group.pop(self.__maxfreq)
            self.__maxfreq -= 1
        self.__freq[x] -= 1
        if not self.__freq[x]:
            self.__freq.pop(x)
        return x",O(1)
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
",O(1)
"class Solution(object):
    def findPeaks(self, mountain):
        return [i for i in range(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]",O(n)
"s = input()

count = 0

i = 0

while i < len(s):

    if int(s[i]) % 3 == 0:

        count += 1
        i += 1

    elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ):

        count += 1
        i +=2

    elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') :

        count += 1
        i += 3

    else:

        i +=1

print(count)
",O(n)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        maxArea = 0
        stack = []

        for i in range(n + 1):
            while stack and (i == n  or heights[stack[-1]] >= heights[i]):
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                maxArea = max(maxArea, height * width)
            stack.append(i)
        return maxArea
",O(n)
"class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result",O(n)
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&po[j]:
                dp[i]=dp[i-po[j]]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)
",np
"class Solution3(object):
    def longestPath(self, parent, s):
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l > top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l > top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]",O(n)
"n = int(input())
d={}
for _ in range(n):
    a,b = map(int,input().split())
    d[a] = b

s=0
m = int(input())
for _ in range(m):
    x,y = map(int,input().split())

    if x in d:
        d[x] = max(d[x],y)

    else:
        d[x] = y

for i in d:

    s+=d[i]
print(s)
",O(nlogn)
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    exit()
if k == 0:
    print(2 * x % mod)
    exit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod

print(ans)
",O(logn)
"class Solution(object):
    def atMostNGivenDigitSet(self, D, N):
        str_N = str(N)
        set_D = set(D)
        result = sum(len(D)**i for i in range(1, len(str_N)))
        i = 0
        while i < len(str_N):
            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))
            if str_N[i] not in set_D:
                break
            i += 1
        return result + int(i == len(str_N))",O(logn)
"class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 1: 
                return 0
            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid, end, lower, upper)
            j, k, r = mid, mid, mid
            tmp = []
            for i in range(start, mid):
                while k < end and sums[k] - sums[i] < lower:
                    k += 1
                while j < end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r < end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])
            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums), lower, upper)",O(nlogn)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def dfs():
            token = tokens.pop()
            if token not in ""+-*/"":
                return int(token)

            right = dfs()
            left = dfs()

            if token == '+':
                return left + right
            elif token == '-':
                return left - right
            elif token == '*':
                return left * right
            elif token == '/':
                return int(left / right)

        return dfs()
",O(n)
"l, r = (int(x) for x in input().split())
limit = l ^ r

if limit != 0:
  limit = len(bin(limit)) - 2
  maxXor = '1' * limit
  print(int(maxXor, 2))
else:
  print(0)
",O(logn)
"import collections


class Solution(object):
    def subarraySum(self, nums, k):
        result = 0
        accumulated_sum = 0
        lookup = collections.defaultdict(int)
        lookup[0] += 1
        for num in nums:
            accumulated_sum += num
            result += lookup[accumulated_sum - k]
            lookup[accumulated_sum] += 1
        return result",O(n)
"class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result",O(n)
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",O(1)
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",O(n)
"class Solution2(object):
    def findNonMinOrMax(self, nums):
        mx, mn = max(nums), min(nums)
        return next((x for x in nums if x not in (mx, mn)), -1)",O(n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",O(n)
"n=input()
ans=0
r,c=0,0
for i in range(len(n)):
    r+=int(n[i])
    c+=1
    if int(n[i])%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",O(n)
"import sys
input = sys.stdin.readline
def multi_input():
    return map(int, input().split())

def sum(n,r):
    return n*(2*r - (n-1))//2

def function(total, l, r):
    left = l
    right = r

    while left<=right:
        mid = (right + left) // 2
        result = sum(r-mid+1, r)
        if result==total:
            return r-mid+1
        elif result > total:
            left = mid + 1
        else:
            if sum(r-mid+2,r) > total:
                return r-mid + 2
            else:
                right = mid - 1
    return -1

n, m = multi_input()

n = n-1
m = m-1
if n==0:
    print(0)
elif sum(m,m)<n:
    print(-1)
elif m<n:
    print(function(n, 1, m))
else:
    print(1)
",O(logn)
"a=str(input())
b=str(input())
count=0
al=len(a)
bl=len(b)
s=b[:bl-al+1].count('1')
for i in range(al-1):
    if a[i]=='0':
        count+=s
    else:
        count+=bl-al+1-s
    s+=int(b[bl-al+i+1])-int(b[i])

if a[-1]=='0':
    count+=s
else:
    count+=bl-al+1-s
print(count)",O(n)
"first,last=input().split()
username=first[0]
first=first[1:]
while first!="""" and first[0]<last[0]:
    username=username+first[0]
    first=first[1:]
print(username+last[0])",O(n)
"x,y,z,t1,t2,t3=map(int,input().split())
if abs(x-y)*t1>=abs(x-z)*t2+t3*3+abs(x-y)*t2:
    print('YES')
else:
    print('NO')",O(1)
"n = int(input())
t = [0 for i in range(2000)]
c = [0 for i in range(2000)]
for i in range(n) :
    x = int(input())
    r = 0
    ok = False
    for j in range(2000) :
        if x >> j & 1 :
            if t[j] != 0 :
                x ^= t[j]
                r ^= c[j]
            else :
                t[j] = x
                c[j] = r ^ (1 << i)
                ok = True
                break
    if ok :
        print(0)
        continue
    a = []
    for j in range(2000) :
        if r >> j & 1 :
            a.append(j)
    print(len(a))
    for y in a :
        print(y)
",np
"class Solution(object):
    def countFairPairs(self, nums, lower, upper):
        def count(x):
            cnt = 0
            left, right = 0, len(nums)-1
            while left < right:
                if nums[left]+nums[right] <= x:
                    cnt += right-left
                    left += 1
                else:
                    right -= 1
            return cnt
        
        nums.sort()
        return count(upper)-count(lower-1)",O(nlogn)
"read = lambda: map(int, input().split())
def sq(x):
    return int(x ** 0.5) ** 2 == x
t = int(input())
for _ in range(t):
    n = int(input())
    if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)):
        print('YES')
    else:
        print('NO')",O(1)
"n, capacity = map(int,input().split())
a = [(0, 0)]*n

for i in range(n):
    x, y = map(int,input().split())
    a[i] = (x, y)

a.sort(key=lambda x: max(0, x[0] - x[1]))

current_sum = 0; i = n - 1; ans = 0
for x in a:
    current_sum += x[0]

while i >= 0 and current_sum > capacity:
    ans += 1
    current_sum -= max(0, a[i][0] - a[i][1])
    i -= 1

if current_sum <= capacity:
    print(ans)
else:
    print(-1)",O(nlogn)
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp

x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",O(logn)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

x=L()[0]
if x<=2:
    print(x)
    exit()
if x%2:
    n=x
    lcm=n*(n-1)//gcd(n,n-1)
    lcm=lcm*(n-2)//gcd(lcm,n-2)
    print(lcm)
else:
    ans=1
    for n1 in range(max(1,x-50),x+1):
        for n2 in range(max(1,x-50),x+1):
            for n3 in range(max(1,x-50),x+1):
                lcm=(n1*n2)//(gcd(n1,n2))
                lcm=(lcm*n3)//gcd(lcm,n3)
                ans=max(ans,lcm)
    print(ans)

endtime = time.time()
",O(1)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        intervals.sort(key=lambda x: x.start)
        min_heap = []

        for interval in intervals:
            if min_heap and min_heap[0] <= interval.start:
                heapq.heappop(min_heap)
            heapq.heappush(min_heap, interval.end)

        return len(min_heap)
",O(nlogn)
"class Solution(object):
    def numSteps(self, s):
        result, carry = 0, 0
        for i in reversed(range(1, len(s))):
            if int(s[i]) + carry == 1:
                carry = 1 
                result += 2
            else:
                result += 1
        return result+carry",O(n)
"import collections


class Solution(object):
    def minJumps(self, arr):
        groups = collections.defaultdict(list)
        for i, x in enumerate(arr):
            groups[x].append(i)
        q = collections.deque([(0, 0)])
        lookup = set([0])
        while q:
            pos, step = q.popleft()
            if pos == len(arr)-1:
                break
            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])
            groups[arr[pos]] = []
            for p in neighbors:
                if p in lookup or not 0 <= p < len(arr):
                    continue
                lookup.add(p)
                q.append((p, step+1)) 
        return step",O(n)
"from sys import stdin, stdout
n = int(stdin.readline())
m = int(stdin.readline())
stdout.write(str(m%(1<<n)))",O(1)
"class Solution(object):
    def theMaximumAchievableX(self, num, t):
        return num+2*t",O(1)
"def isPrime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
n=int(input());d=0
if n%2==0:
    print('4 '+str(n-4))
else:
    i=4
    while i<=int(n//2)+1:
        k=n-i
        if isPrime(k)==False:
            print(str(i)+' '+str(k))
            break
        i+=2
",O(1)
"n = int(input())
wyn = 1
x = 4
for i in range(n - 1):
	wyn += x
	x += 4
print(wyn)",O(n)
"n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1

dp = [[0 for i in range(520*12)] for j in range(520)]

for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:

	ss+=dp[d2[i]][d1[i]]
print(ss)",O(n ^ 3)
"import math

n, m, k, l = map(int, input().split())

x = (l + k) // m
if x * m < l + k:
    x += 1
assert x * m >= l + k

if m * x > n:
    print(-1)
else:
    print(x)",O(1)
"class Solution(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [n, 0]
        n -= self.__w-1
        if n < self.__h:
            return [self.__w-1, n]
        n -= self.__h-1
        if n < self.__w:
            return [(self.__w-1)-n, self.__h-1]
        n -= self.__w-1
        return [0, (self.__h-1)-n]

    def getDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return ""South"" if n == 0 and self.__curr else ""East""
        n -= self.__w-1
        if n < self.__h:
            return ""North""
        n -= self.__h-1
        if n < self.__w:
            return ""West""
        n -= self.__w-1
        return ""South""",O(1)
"class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        result = 0
        for x in batteryPercentages:
            if x > result:
                result += 1
        return result",O(n)
"import sys

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())

from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m

	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m

	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])
		dp_table[i][j][k] = m
		return m

	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",O(n ^ 3)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)",O(n)
"n, m = map(int, input().split())
m += 1

def calc(l, r, eq, eq_i):
    if l > r:
        return 1
    key = l, eq, eq_i
    if key in f:
        return f[key]

    t = 0
    for x in (['0', '1'] if s[l] == '?' else [s[l]]):
        if l == r:
            a = [x]
        else:
            a = ['0', '1'] if s[r] == '?' else [s[r]]
        for y in a:
            if not((eq and x > y) or (eq_i and x == y == '1')):
                t += calc(l + 1, r - 1, eq and x == y, eq_i and x != y)
    f[key] = t
    return t

s = ['?'] * n
for i in range(n):
    s[i] = '0'
    f = {}
    p = calc(0, n - 1, True, True)
    if m > p:
        m -= p
        s[i] = '1'

if s[0] == '0':
    print(''.join(s))
else:
    print(-1)
",O(n ^ 3)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
diff = []
if n == 1:
    print(0)
else:
    for i in range(n-1):
        diff.append(a[i+1]-a[i])

    diff.sort(reverse = True)
    ans = a[-1] - a[0]
    for i in range(min(k-1, len(diff))):
        ans -= diff[i]

    print(ans)
",O(nlogn)
"k,n,s,p=map(int,input().split())
a=n//s
if(n%s!=0):
    a+=1
q=k*a
m=q//p
if(q%p!=0):
    m+=1
print(m)
",O(1)
"t = int(input())
for i in range(t):
    n, m = [int(item) for item in input().split()]
    mat = []
    col = [[] for _ in range(m)]
    for j in range(n):
        line = [int(item) for item in input().split()]
        for k, item in enumerate(line):
            col[k].append(item)
        mat.append(line)
    colmax = []
    for line in col:
        colmax.append([max(line), line])
    colmax.sort(reverse=True)
    colmax = colmax[:n]
    ans = 0
    for j in range(n ** (n-1)):
        index = j
        rot = [0]
        for k in range(n-1):
            rot.append(index % n)
            index //= n
        ret = 0
        for l in range(n):
            val = 0
            for k in range(len(colmax)):
                val = max(val, colmax[k][1][(l + rot[k]) % n])
            ret += val
        ans = max(ans, ret)
    print(ans)",np
"n,k = map(int,input().split())
l = [int(x) for x in input().split()]
maps = []
for _ in range(256):
	maps.append(['empty',0])
output = []
for innum in l:
	if maps[innum][0] == 'chosen':
		outnum = maps[innum][1]
	elif maps[innum][0] == 'potential':
		outnum = maps[innum][1]
		i = innum
		while i >= 0 and maps[i][0] == 'potential':
			maps[i] = ['chosen',outnum]
			i -= 1
	else:
		i = innum
		while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':
			i -= 1
		i += 1
		outnum = i
		for j in range(outnum,innum+1):
			maps[j] = ['chosen',outnum]
		if innum < 255:
			for j in range(innum+1,min(256,outnum+k)):
				if maps[j][0] != 'chosen':
					maps[j] = ['potential',outnum]
	output.append(str(outnum))
print(' '.join(output))
",O(n ^ 2)
"def solve():
    n = int(input())
    l = list(map(int,list(input())))
    divisors = []
    total = sum(l)
    for j in range(2,int(sqrt(total))+1):
        if(total%j==0):
            divisors.extend([j,total//j])
    if(total==0):
        print(""YES"")
        return
    if(total!=1):
        divisors.append(1)

    for x in divisors:
        search = x
        index = 0
        summ = 0
        while(index<n):
            summ+=l[index]
            if(summ>search):
                break
            elif(summ==search):
                summ = 0
            index+=1

        if(summ==0 and index==n):
            print(""YES"")
            return
    print(""NO"")
import sys
import math
import bisect
from sys import stdin,stdout
from math import gcd,floor,sqrt,log
from collections import defaultdict as dd
from bisect import bisect_left as bl,bisect_right as br

inp    =lambda: int(input())
strng  =lambda: input().strip()
jn     =lambda x,l: x.join(map(str,l))
strl   =lambda: list(input().strip())
mul    =lambda: map(int,input().strip().split())
mulf   =lambda: map(float,input().strip().split())
seq    =lambda: list(map(int,input().strip().split()))

ceil   =lambda x: int(x) if(x==int(x)) else int(x)+1
ceildiv=lambda x,d: x//d if(x%d==0) else x//d+1

flush  =lambda: stdout.flush()
stdstr =lambda: stdin.readline()
stdint =lambda: int(stdin.readline())
stdpr  =lambda x: stdout.write(str(x))

solve()
",O(n ^ 2)
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums.sort()
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i + 1]:
                i += 2
            else:
                return nums[i]
        return nums[i]
",O(nlogn)
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",O(nlogn)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)",O(1)
"class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Vector:

    def __init__(self, start, end):
        self.x = end.x - start.x
        self.y = end.y - start.y

    def mult(self, a):
        return self.y * a.x - self.x * a.y

n = int(input())
points = []
for i in range(n):
    x, y = map(int, input().split())
    points.append(Point(x, y))

if n <= 3:
    print('YES')
    exit()

def onLine(points):
    n = len(points)
    if n < 3:
        return True
    a = Vector(points[0], points[1])
    for i in range(2, n):
        b = Vector(points[0], points[i])
        if a.mult(b) != 0:
            return False
    return True

tmp = [points[0], points[1]]
oth = []
for i in range(2, n):
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[0], points[2]]
oth = []
for i in range(1, n):
    if i == 2:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[1], points[2]]
oth = []
for i in range(0, n):
    if i == 2 or i == 1:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

print('NO')
",O(nlogn)
"import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result",O(n)
"n, m = [int(i) for i in input().split()]
A = []
ct = []
for i in range(n):
    x = list(input())
    y = [0]*m
    A.append(x)
    ct.append(y)
ok = 1
for i in range(n-2):
    for j in range(m-2):
        if A[i][j]=='
            ct[i][j] = 1
            ct[i][j+1] = 1
            ct[i][j+2] = 1
            ct[i+1][j] = 1
            ct[i+1][j+2] = 1
            ct[i+2][j] = 1
            ct[i+2][j+1] = 1
            ct[i+2][j+2] = 1

xct = 0
xhs = 0

for i in range(len(ct)):
    for j in range(len(ct[i])):
        if ct[i][j] == 1:
            xct+=1
        if A[i][j] == '
            xhs+=1
if xhs==xct:
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
YOKO=[list(map(int,input().split())) for i in range(n)]
TATE=[list(map(int,input().split())) for i in range(n-1)]

if k%2==1:
    for i in range(n):
        print(*[-1]*m)
    exit()

DP=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):

        MIN=1<<30

        if j-1>=0:
            MIN=min(MIN,YOKO[i][j-1]*2)
        if j<m-1:
            MIN=min(MIN,YOKO[i][j]*2)

        if i-1>=0:
            MIN=min(MIN,TATE[i-1][j]*2)
        if i<n-1:
            MIN=min(MIN,TATE[i][j]*2)

        DP[i][j]=MIN

DP0=DP[:]

for tests in range(k//2-1):
    NDP=[[0]*m for i in range(n)]

    for i in range(n):
        for j in range(m):
            MIN=DP[i][j]+DP0[i][j]

            if 0<=i+1<n:
                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])

            if 0<=i-1<n:
                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])

            if 0<=j+1<m:
                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])

            if 0<=j-1<m:
                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])

            NDP[i][j]=MIN
    DP=NDP

for dp in DP:
    print(*dp)
",O(n ^ 3)
"s = input().split()
hand = {'m': [], 'p': [], 's':[]}

for item in s:
	hand[item[1]].append(int(item[0]))

min_steps_needed = 10

for symb in ['m', 'p', 's']:
	hand[symb] = sorted(hand[symb])
	for start in range(1, 10):
		a_needed = 10
		b_needed = 10

		a_needed = 3 - hand[symb].count(start)

		b1, b2, b3 = 0, 0, 0
		if hand[symb].count(start) > 0:
			b1 = 1
		if hand[symb].count(start+1) > 0:
			b2 = 1
		if hand[symb].count(start+2) > 0:
			b3 = 1

		b_needed = 3 - b1 - b2 - b3

		if a_needed < min_steps_needed:
			min_steps_needed = a_needed
		if b_needed < min_steps_needed:
			min_steps_needed = b_needed

print(min_steps_needed)",O(n)
"import collections
import itertools



class Solution(object):
    def equalPairs(self, grid):
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in zip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.keys() if k in cnt2)",O(n ^ 2)
"import sys
from math import floor, ceil

r = lambda: sys.stdin.readline().strip()

a = [[0] * 2 for i in range(3)]

def abs(x):
    if x < 0:
        x = -x
    return x

def calcLen(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2) + 1

def main():
    a[0][0], a[0][1] = map(int, r().split())
    a[1][0], a[1][1] = map(int, r().split())
    a[2][0], a[2][1] = map(int, r().split())
    xMax = max(a[0][0], a[1][0], a[2][0])
    xMin = min(a[0][0], a[1][0], a[2][0])
    yMax = max(a[0][1], a[1][1], a[2][1])
    yMin = min(a[0][1], a[1][1], a[2][1])

    pathLen = xMax - xMin + yMax - yMin + 1
    for i in range(3):
        for j in range(3):
            px = a[i][0]
            py = a[j][1]
            sum = 0
            for k in range(3):
                sum += (calcLen(a[k][0], a[k][1], px, py))
            sum -= 2
            if sum == pathLen:
                break
        if sum == pathLen:
            break
    sq = [[0]*(yMax+1) for i in range(xMax+1)]
    for i in range(3):
        if px == a[i][0]:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py, c):
                sq[px][j]=1
        elif py== a[i][1]:
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
        else:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py + c, c):
                sq[a[i][0]][j] = 1

            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
    sq[px][py] = 1
    ans = []
    for i in range(xMax + 1):
        for j in range(yMax + 1):
            if sq[i][j] == 1:
                ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])

main()
",O(1)
"import collections


class Solution(object):
    def largestUniqueNumber(self, A):
        A.append(-1)
        return max(k for k,v in list(collections.Counter(A).items()) if v == 1)",O(n)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        maxArea = 0

        for i in range(n):
            height = heights[i]

            rightMost = i + 1
            while rightMost < n and heights[rightMost] >= height:
                rightMost += 1

            leftMost = i
            while leftMost >= 0 and heights[leftMost] >= height:
                leftMost -= 1

            rightMost -= 1
            leftMost += 1
            maxArea = max(maxArea, height * (rightMost - leftMost + 1))
        return maxArea
",O(n ^ 2)
"import collections



class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in range(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1",O(n)
"class Solution(object):
    def memLeak(self, memory1, memory2):
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) > x: 
                r -= 1
            return r

        is_swapped = False
        if memory1 < memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]",O(1)
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",O(n ^ 2)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        dp = [0] * n

        for i in range(n):
            dp[i] = 1
            for j in range(i):
                if intervals[j][1] <= intervals[i][0]:
                    dp[i] = max(dp[i], 1 + dp[j])

        max_non_overlapping = max(dp)
        return n - max_non_overlapping
",O(n ^ 2)
"import sys,math,bisect
from random import randint
inf = float('inf')
mod = 998244353
""========================================""
def lcm(a,b):
    return int((a/math.gcd(a,b))*b)
def gcd(a,b):
    return int(math.gcd(a,b))
def tobinary(n):
    return bin(n)[2:]
def binarySearch(a,x):
    i = bisect.bisect_left(a,x)
    if i!=len(a) and a[i]==x:
        return i
    else:
        return -1
def lowerBound(a, x):
    i = bisect.bisect_left(a, x)
    if i:
        return (i-1)
    else:
        return -1
def upperBound(a,x):
    i = bisect.bisect_right(a,x)
    if i!= len(a)+1 and a[i-1]==x:
        return (i-1)
    else:
        return -1
def primesInRange(n):
    ans = []
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    for p in range(2, n+1):
        if prime[p]:
            ans.append(p)
    return ans
def primeFactors(n):
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n = n // 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            factors.append(i)
            n = n // i
    if n > 2:
        factors.append(n)
    return factors
def isPrime(n,k=5):
    if (n <2):
        return True
    for i in range(0,k):
        a = randint(1,n-1)
        if(pow(a,n-1,n)!=1):
            return False
    return True
""=========================================""

from collections import deque,defaultdict,Counter
import heapq,string

n=int(input())
s=input()
s=[int(i) for i in s]
flag=False
for i in range(0,(9*n)+1):
    count=0
    sum = 0
    for j in s:
        sum+=j
        if sum==i:
            count+=1
            sum=0
    if count>1 and sum==0:
        print('YES')
        exit(0)
print('NO')
",O(n ^ 2)
"import collections


class Solution(object):
    def subarraysDivByK(self, A, K):
        count = collections.defaultdict(int)
        count[0] = 1
        result, prefix = 0, 0
        for a in A:
            prefix = (prefix+a) % K
            result += count[prefix]
            count[prefix] += 1
        return result",O(n)
"n = int(input())
nums = [int(x) for x in input().split()]
ans = 10 ** 12
for idx, num in enumerate(nums):
    dist = max(idx, n - idx - 1)
    curr = num // dist
    ans = min(ans, curr)
print(ans)",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))
    color = [0] * n
    arr.sort()

    ans = 0
    for i in range(n):
        if color[i]:
            continue
        ans += 1
        for j in range(i, n):
            if arr[j] % arr[i] == 0:
                color[j] = ans

    print(ans)

    return 0

main()
",O(n ^ 2)
"import io
import os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

arr = [int(z) for z in input().split()]

q = int(input())

inv = 0

for i in range(n):

    for j in range(n):

        if i < j and arr[i] > arr[j]:

            inv += 1

        inv = inv % 2

for query in range(q):

    l, r = map(int, input().split())

    diff = r - l

    s = diff//2

    if diff % 2:
        s += 1

    inv = (inv + (s % 2)) % 2

    if inv:
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"import sys
input = sys.stdin.readline
from collections import deque

n,q=map(int,input().split())
A=deque(map(int,input().split()))
Q=[int(input()) for i in range(q)]

ANS=[0]

for l in range(10**5+1):
    x=A.popleft()
    y=A.popleft()

    ANS.append((x,y))

    if x>y:
        A.appendleft(x)
        A.append(y)
    else:
        A.appendleft(y)
        A.append(x)

ANS0=A[0]
B=list(A)[1:]

for q in Q:
    if q<=10**5+1:
        print(*ANS[q])
    else:
        print(ANS0,B[(q-10**5-2)%(n-1)])
",O(n)
"import bisect
import math
import itertools
import sys

alpha = 'abcdefghijklmnopqrstuvwxyz'
inf = 1e17

def calc1(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j]:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j] == 0:
                cnt += 1
    return cnt

def calc2(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j] == 0:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j]:
                cnt += 1
    return cnt
def solve(n,grids):
    one = []
    zero = []
    for grid in grids:
        one.append(calc1(grid))
        zero.append(calc2(grid))
    take = [3,5,6,9,10,12]
    answer = inf
    for mask in range(16):
        cnt = 0
        if mask not in take:
            continue
        if mask in take:
            if mask & 1:
                cnt += one[3]
                pass
            else:
                cnt += zero[3]
                pass
            if mask & 2:
                cnt += one[2]
                pass
            else:
                cnt += zero[2]
                pass
            if mask & 4:
                cnt += one[1]
                pass
            else:
                cnt += zero[1]
                pass
            if mask & 8:
                cnt += one[0]
                pass
            else:
                cnt += zero[0]
                pass
        answer = min(answer,cnt)
    return answer

t = 1
ans = []
for _ in range(t):
    n = int(input())

    grids = []
    for i in range(4):
        grid = []
        for j in range(n):
            arr = list(map(int,list(input())))
            grid.append(arr)
        if i != 3:
            s = input()
        grids.append(grid)

    ans.append(solve(n,grids))

for test in ans:
    print(test)",O(n ^ 2)
"b = list(map(int, input().split()))
n = 14
ans = 0
for i in range(n):
    a = b.copy()
    if a[i] == 0:
        continue
    x = a[i]
    a[i] = 0
    full = x // n
    xex = x % n
    for j in range(n):
        a[j] += full
    for j in range(xex):
        a[(i + j + 1) % n] += 1
    pot = 0
    for j in a:
        if j % 2 == 0:
            pot += j
    ans = max(ans, pot)
print(ans)
",O(1)
"import sys
input = sys.stdin.readline
def main():
    n,m,k = map(int,input().split())
    if k%2==1:
        for i in range(n):
            for j in  range(m):
                print(-1,end="" "")
            print()
        return 0
    kk=k
    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]

    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]
    for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
    for i in range(n):
        s=list(map(int,input().split()))
        for j in range(m-1):
            maps[i][j][0]=s[j]
            maps[i][j+1][1]=s[j]
    for i in range(n-1):
        s=list(map(int,input().split()))
        for j in range(m):
            maps[i][j][2]=s[j]
            maps[i+1][j][3]=s[j]
    for k in range(1,kk//2+1):
        for i in range(n):
            for j in range(m):
                if j<m-1:
                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])
                if i<n-1:
                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])
                if i>0:
                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])
                if j>0:
                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k]*2,end="" "")
        print()
main()
",O(n ^ 3)
"class Solution(object):
    def isPalindrome(self, x):
        if x < 0:
            return False
        copy, reverse = x, 0

        while copy:
            reverse *= 10
            reverse += copy % 10
            copy //= 10

        return x == reverse",O(logn)
"n = int(input())
ax,ay = [int(s) for s in input().split()]
bx,by = [int(s) for s in input().split()]
cx,cy = [int(s) for s in input().split()]
if ((bx-ax < 0 and cx-ax < 0 or
    bx-ax > 0 and cx-ax > 0) and
    (by-ay < 0 and cy-ay < 0 or
    by-ay > 0 and cy-ay > 0)):
        print(""YES"")
else:
    print(""NO"")",O(1)
"def suma(n):
    return n*(n+1)//2

def sumaij(i, j):
    if i <= 1:
        return suma(j)
    return suma(j) - suma(i-1)

def bin_search_solution(n, k):
    st, end = 1, k
    while st < end:
        mid = (st+end)//2
        s = sumaij(mid, k)
        if s == n:
            return k - mid + 1
        if s > n:
            st = mid + 1
        else:
            end = mid
    return k - st + 2

def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    elif k >= n:
        print(1)
    else:
        n -= 1
        k -= 1

        if suma(k) < n:
            print(-1)
        else:
            res = bin_search_solution(n, k)
            print(res)

if __name__ == '__main__':
    solve()
",O(logn)
"n=int(input())
l=list(map(lambda x:int(x)*2,input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)",O(n)
"def solution():
    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v = list()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                p += 1

            sr = s[:p]
            sc = s[p:]

            c = 0
            for x in sr:
                c = c * 26 + (ord(x) - ord('A') + 1)

            print(""R%sC%d"" % (sc, c))

if __name__ == ""__main__"":
    solution()
",O(n)
"class Solution(object):
    def maxRotateFunction(self, A):
        s = sum(A)
        fi = 0
        for i in range(len(A)):
            fi += i * A[i]

        result = fi
        for i in range(1, len(A)+1):
            fi += s - len(A) * A[-i]
            result = max(result, fi)
        return result",O(n)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write("""".join((str(i),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n"")))

if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n"")))

    if m%2==1:
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))
",O(n ^ 2)
"n,s = input().split()

i = int(s)
d_sum = sum(list(map(int,str(i))))
while i - d_sum < int(s):
    i += 1
    d_sum = sum(list(map(int,str(i))))

print((max(0,int(n)-i+1)))
",O(logn)
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",O(n ^ 3)
"n = int(input())

arr = list(map(int, input().split()))

memo = [-1 for i in range(n+1)]
def can_win(idx):
	if memo[idx] != -1: return memo[idx]
	res = False

	delta = arr[idx]

	nidx = idx + delta
	while nidx < n:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx += delta

	nidx = idx - delta
	while not res and nidx >= 0:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx -= delta

	memo[idx] = res
	return res

ans = ['A' if can_win(i) else 'B' for i in range(n)]
print(''.join(ans))
",O(n ^ 2)
"n, k = [int(x) for x in input().split()]

ps = [int(x) for x in input().split()]

mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j

    res.append(mapping[p])
print("" "".join(map(str, res)))
",O(n ^ 2)
"class Solution(object):
    def maximumScore(self, a, b, c):
        return min((a+b+c)//2, a+b+c - max(a, b, c))",O(1)
"from math import sqrt

def dist(speed, time):

	return speed * time + a * time**2 / 2

def travelTime(distance, speed):

	tAll = (- speed + sqrt(speed**2 + 2 * distance * a)) / a

	tMax = (v - speed) / a

	if tMax >= tAll:
		return tAll
	else:
		return tMax + (distance - dist(speed, tMax)) / v

a, v = map(int, input().split())
l, d, w = map(int, input().split())

if v <= w:
	print(travelTime(l, 0))
else:
	tw = w / a

	dw = dist(0, tw)

	if dw >= d:
		print(travelTime(l, 0))
	else:
		print(tw + 2 * travelTime((d - dw) / 2, w) + travelTime(l - d, w))
",O(1)
"from collections import Counter
import string
import math
import sys

from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split())
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n,k=vary(2)
    num=array_int()
    maxi=0.0
    for i in range(n):
        count=1
        sumt=num[i]

        for j in range(i+1,n):
            sumt+=num[j]
            count+=1
            if count>=k:

                maxi=max(maxi,sumt/count)

    if k==1:
        print(max(maxi,max(num)))
    else:
        print(maxi)
",O(n ^ 2)
"import itertools


class Solution(object):
    def knightDialer(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]
        
        M = 10**9 + 7
        T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
             [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
             [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
             [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],
             [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]]
        return sum(map(sum, matrix_expo(T, N-1))) % M",O(logn)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]
            if i == len(nums) - 1:
                return True
            if nums[i] == 0:
                return False

            end = min(len(nums), i + nums[i] + 1)
            for j in range(i + 1, end):
                if dfs(j):
                    memo[i] = True
                    return True
            memo[i] = False
            return False

        return dfs(0)
",O(n ^ 2)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        mp = defaultdict(int)
        res = 0

        for num in nums:
            if not mp[num]:
                mp[num] = mp[num - 1] + mp[num + 1] + 1
                mp[num - mp[num - 1]] = mp[num]
                mp[num + mp[num + 1]] = mp[num]
                res = max(res, mp[num])
        return res
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])",np
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",O(n ^ 3)
"class Solution(object):
    def elementInNums(self, nums, queries):
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i < len(nums):
                result.append(nums[t+i])
            elif i < t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result",O(n)
"from sys import stdin, stdout
import bisect
input = stdin.readline
t = 1
for _ in range(t):
    n,q=map(int,input().split())
    a=[int(x) for x in input().split()]
    pre=[]
    s=0
    for i in a:
        s+=i
        pre.append(s)
    lost=0
    val_lost=0
    ans=[]
    qu=[int(x) for x in input().split()]
    for i in qu:
        val=i+val_lost
        b=bisect.bisect_left(pre,val,lost,n)
        val_lost=min(val,pre[-1])
        if b==n:
            lost = 0
            val_lost = 0
            ans.append(n)
            continue
        if pre[b]==val:
            lost=b+1
        else:
            lost=b
        if lost==n:
            lost = 0
            val_lost = 0
        ans.append(n-lost)
    for i in ans:
        print(i)",O(nlogn)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        res = 0
        nums.sort()

        curr, streak = nums[0], 0
        i = 0
        while i < len(nums):
            if curr != nums[i]:
                curr = nums[i]
                streak = 0
            while i < len(nums) and nums[i] == curr:
                i += 1
            streak += 1
            curr += 1
            res = max(res, streak)
        return res
",O(nlogn)
"import sys, math, cmath, time, collections
from collections import deque, Counter, OrderedDict, defaultdict
from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace
from math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi
from bisect import bisect_left, bisect_right

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

start_time = time.time()

def solve(s):

    mx = 0
    visited = set()
    for left in range(len(s)):
        for right in range(left, len(s)):
            substring = s[left : right + 1]
            if substring not in visited:
                visited.add(substring)
            elif substring in visited:
                mx = max(mx, len(substring))
    print(mx)

def main():

    s = input()
    solve(s)

if __name__ == ""__main__"":
    LOCAL = False

    if LOCAL:
        sys.stdin = open(""../io/data.in"", ""r"")
        sys.stdout = open(""../io/data.out"", ""w"")

    testcases = 1
    for i in range(testcases):
        main()

    if LOCAL:
        print(f""Time Elapsed: {time.time() - start_time} seconds"")
        sys.stdout.close()
",O(n ^ 3)
"n=int(input())
if n%4==2:
    print('!', '-1')
    exit()
def qry(i):
    print('?', i+1, flush=True)
    a=int(input())
    return a
def qry2(i):
    a=qry(i+n//2)-qry(i)
    if a==0:
        print('!', i+1)
        exit()
    return a
a=qry2(0)
lb,rb=1,n//2-1
while lb<=rb:
    mb=(lb+rb)//2
    b=qry2(mb)
    if (a>0)==(b>0):
        lb=mb+1
    else:
        rb=mb-1",O(logn)
"def digit_sum(n):
	cnt = 0
	while n:
		cnt += n % 10
		n //= 10
	return cnt

def bsearch(low, high, s):
	h = high
	ans = -1
	while low <= high:
		mid = (low + high) // 2
		if mid - digit_sum(mid) >= s:
			ans = mid
			high = mid - 1
		else:
			low = mid + 1
	if ans == -1:
		return 0
	else:
		return h - ans + 1

n, s = map(int, input().split())
st = 1
end = 10
cnt = 0
cnt += (bsearch(1, n, s))
print(cnt)
",O(logn)
"n = int(input())
print(1+2*((n-1)*n))
",O(1)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        res = 0

        def dfs(root):
            nonlocal res

            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            res = max(res, left + right)

            return 1 + max(left, right)

        dfs(root)
        return res
",O(n)
"n = int(input())-1
x, y = 1, 9
while n > x * y: n,x,y = n-x*y,x+1,y*10
a = str(10 ** (x - 1) + n // x)[n%x]
print(a)
",O(logn)
"n, m = [int(_) for _ in input().split()]
a = [0] * (n + 1)
l, r = 1, n

for i in range(1, n + 1):
    if m <= 1 << max((n - i - 1), 0):
        a[l] = i
        l += 1
    else:
        a[r] = i
        r -= 1
        m -= 1 << max((n - i - 1), 0)

a.pop(0)
print("" "".join(map(str, a)))",np
"class Solution2(object):
    def isSubstringPresent(self, s):
        lookup = collections.defaultdict(set)
        for i in range(len(s)-1):
            lookup[s[i]].add(s[i+1])
        return any(s[i] in lookup[s[i+1]] for i in range(len(s)-1))",O(n)
"import itertools


class Solution(object):
    def sortSentence(self, s):
        words = s.split()
        for i in range(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return "" "".join(map(lambda x: x[:-1], words))",O(n)
"class Solution(object):
    def countHomogenous(self, s):
        MOD = 10**9+7
        result = cnt = 0
        for i in range(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result",O(n)
"a,b,c,n = map(int,input().split())
if c > a or c > b or (a+b) - c >=n:
    print(-1)
else:
    print(n -((a+b)-c))",O(1)
"from math import *
import sys
input = lambda: sys.stdin.readline().strip()

d = {'m': [], 's': [], 'p': []}

ls = list(input().split())
for i in ls:
    d[i[1]].append(int(i[0]))
for k, v in d.items():
    v.sort()
    if len(v)==3 and len(set(v))==1: print(0); break
    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break
else:
    for k, v in d.items():
        if len(v)==2 and len(set(v))==1: print(1); break
        if len(v)==2 and v[1]-v[0]<=2: print(1); break
        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break
        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break
    else:
        print(2)
",O(nlogn)
"import sys
input = sys.stdin.readline

from heapq import heapify, heappush, heappop

n, k = map(int, input().split())
plst = list(map(int, input().split()))
clst = list(map(int, input().split()))

if k == 0:
    print(*clst)
    sys.exit()

pc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))
res = [0] * n
pq = []
pq_sum = 0
pq_size = 0

for p, c, i in pc:
    if i > 0 and plst[i] == plst[i-1]:
        res[i] = res[i-1]
    else:
        res[i] = pq_sum + c

    if pq_size < k:
        heappush(pq, c)
        pq_sum += c
        pq_size += 1
    else:
        alt = heappop(pq)
        if alt < c:
            heappush(pq, c)
            pq_sum += c - alt
        else:
            heappush(pq, alt)

print(*res)
",O(nlogn)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",O(1)
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",O(nlogn)
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",O(1)
"class Solution(object):
    def maxSumMinProduct(self, nums):
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        stk, result = [-1], 0
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))
            stk.append(i) 
        return result%MOD",O(n)
"n, m = map(int, input().split())
sun, su, ans = 0, 0, 0
arr, brr, dif = [], [], []
for i in range(n):
    a, b = map(int, input().split())

    sun += a; su += b
    dif.append(a - b)
if(su > m):print(-1)
elif(sun == m):print(0)
else:
    dif.sort()
    j = n - 1
    while(sun > m):
        sun -= dif[j]
        ans += 1
        j -= 1
    print(ans)",O(nlogn)
"import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] < left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result",O(nlogn)
"def mul(x, y, md):
	return x * y % md;

def power(x, y, md) :
	res = 1;
	while (y != 0):
		if (y & 1):
			res = mul(res, x, 1000000007);
		x = mul(x, x, 1000000007);
		y >>= 1;
	return res

def inv(x, md):
	return power(x, md - 2, 1000000007);

t = input().split()
a = int(t[0])
k = int(t[1])
if (a == 0):
	print(0)
else:
	first = power(2, 2 * k, 1000000007);
	second = power(2, k, 1000000007);
	ans = mul(first, 2 * a - 1, 1000000007) + second;
	third = inv(second, 1000000007);
	ans = mul(ans, third, 1000000007);
	print(ans)",O(logn)
"from bisect import bisect,bisect_left

from collections import *
from heapq import *
from math import gcd,ceil,sqrt,floor,inf

from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):
        n=len(arr)
        mx=n.bit_length()
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

class UF:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
        self.size=AI(n,1)
        self.edge=A(n)

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            self.edge[pu]+=1
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            self.edge[pu]+=self.edge[pv]+1
            self.size[pu]+=self.size[pv]
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
            self.edge[pv]+=self.edge[pu]+1
            self.size[pv]+=self.size[pu]

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag

def dij(s,graph):
    d=AI(n,inf)
    d[s]=0
    heap=[(0,s)]
    vis=A(n)
    while heap:
        dis,u=heappop(heap)
        if vis[u]:
            continue
        vis[u]=1
        for v,w in graph[u]:
            if d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

t=1
for i in range(t):
    n,mod=RL()

    ma=(n+1)//2
    ifact(n,mod)
    dp=A2(n+1,ma+1)
    f=A(n+1)
    f[1]=1
    f[2]=2
    f[3]=4
    for i in range(4,n+1):
        f[i]=f[i-1]*2%mod
    dp[1][1]=1
    dp[2][1]=2
    dp[3][1]=4
    dp[3][2]=2
    for i in range(4,n+1):
        dp[i][1]=f[i]
        for k in range(2,(i+1)//2+1):
            for x in range(1,i-2*k+3):

                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod
                dp[i][k]%=mod
    ans=0
    for k in range(1,ma+1):
        ans=(ans+dp[n][k])%mod
    print(ans)
",O(n ^ 3)
"n, s = map(int, input().strip().split())

num = ''
div = 9

if s//10 != 0:

    div = 9
    while (s//div)//10 != 0:
        div = div*10+9
    while div:
        rem = str(s//div)
        if int(rem) > 9:
            num = str(int(num)+1) + '0'*len(str(div))
            div = 0
            s = 0
            break
        else:
            num += rem
        s = s%div
        div //= 10
    num += str(s)
else:
    num = str(s)
mini = int(num)
if mini%10 != 0:
    mini += 10
    mini -= mini%10

print(max(0, n-mini+1))
",O(logn)
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",O(logn)
"class Solution(object):
    def nextGreaterElements(self, nums):
        result, stk = [0] * len(nums), []
        for i in reversed(range(2*len(nums))):
            while stk and stk[-1] <= nums[i % len(nums)]:
                stk.pop()
            result[i % len(nums)] = stk[-1] if stk else -1
            stk.append(nums[i % len(nums)])
        return result",O(n)
"class Solution2(object):
    def numOfWays(self, n):
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in range(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD",O(n)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
from collections import defaultdict as df

import random

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution_TLE(object):
    def houseOfCards(self, n):
        dp = [[0]*(n+1) for _ in range((n+1)//3+1)] 
        dp[0][0] = 1
        for t in range(1, (n+1)//3+1):
            for i in range(3*t-1, n+1):
                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in range(t))
        return sum(dp[t][n] for t in range((n+1)//3+1))",O(n ^ 2)
"class Solution(object):
    def encode(self, num):
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return """".join(reversed(result))",O(logn)
"class Solution(object):
    def flipAndInvertImage(self, A):
        for row in A:
            for i in range((len(row)+1) // 2):
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A",O(n ^ 2)
"class Solution(object):
    def wordPattern(self, pattern, str):
        if len(pattern) != self.wordCount(str):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, self.wordGenerator(str)):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True

    def wordCount(self, str):
        cnt = 1 if str else 0
        for c in str:
            if c == ' ':
                cnt += 1
        return cnt

    def wordGenerator(self, str):
        w = """"
        for c in str:
            if c == ' ':
                yield w
                w = """"
            else:
                w += c
        yield w",O(n)
"import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result",O(n)
"class Solution(object):
    def corpFlightBookings(self, bookings, n):
        result = [0]*(n+1)
        for i, j, k in bookings:
            result[i-1] += k
            result[j] -= k
        for i in range(1, len(result)):
            result[i] += result[i-1]
        result.pop()
        return result",O(n)
"def check(e,value,pre):
    global maxi,count
    e[str(value)]-=1
    pre+=str(value)
    arr=[]
    for i in e:
        for j in range(e[i]):
            arr.append(i)
    arr.sort(reverse=True)
    st=''
    for i in arr:
        st+=str(i)
    alpha=int(pre+st)
    if alpha<=int(b):
        maxi=max(maxi,int(pre+st))

a=input()
b=input()
maxi=0
d={}
for i in a:
    if i not in d:
        d[i]=1
    else:
        d[i]+=1
maxi=0
num=""""
count=0
if len(a)<len(b):
    check(d.copy(),max(d),'')
else:
    for i in b:
        if i in d and d[i]>0:
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            check(d.copy(),i,num)
            num+=i
            d[i]-=1

        else:
            j=0
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            break
print(maxi)",O(n ^ 3)
"n=int(input())
l=[int(x) for x in input().split()]
if l==sorted(l):
	print(""Yes"")
else:
	cnt=0;
	g=sorted(l)
	for i in range(len(l)):
		if l[i]!=g[i]:
			cnt+=1
	if cnt<=2:
		print(""Yes"")
	else:
		print(""No"")",O(nlogn)
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
",O(n)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = collections.defaultdict(lambda: Node(0))
        oldToCopy[None] = None

        cur = head
        while cur:
            oldToCopy[cur].val = cur.val
            oldToCopy[cur].next = oldToCopy[cur.next]
            oldToCopy[cur].random = oldToCopy[cur.random]
            cur = cur.next
        return oldToCopy[head]
",O(n)
"allcolor=['purple','green','blue','orange','red','yellow']
op=['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']
n=int(input())
ipcolor=[]
for i in range(0,n):
    color=input()
    ipcolor.append(color)
diff=list(set(allcolor) - set(ipcolor))
print(len(diff))
for i in range(0,len(diff)):
    print(op[allcolor.index(diff[i])])",O(1)
"import math

def main():
    n,m,k,l = map(int, input().strip().split())

    t = int(k + l + m - 1) // m

    if k + l > n:
        print(-1)
        return

    if m * t > n:
        print(-1)
        return

    print(t)

if __name__ == '__main__':
    main()",O(1)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n, a, b = mi()
c = max(a, b)
if a != 1 and b != 1:
    print('NO')
elif n == 2 and c == 1:
    print('NO')
elif n == 3 and c == 1:
    print('NO')
else:
    if a == 1:
        g = [[1] * n for i in range(n)]
        for i in range(n):
            g[i][i] = 0
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 0
    else:
        g = [[0] * n for i in range(n)]
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 1
    print('YES')
    for r in g:
        print(''.join(str(x) for x in r))",O(n ^ 2)
"import math
k, n, s, p = map(int, input().split())
sheets = math.ceil(n/s) * k
print(math.ceil(sheets/p))
",O(1)
"import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        min_heap = []
        result = i = 0
        while i < len(apples) or min_heap:
            if i < len(apples) and apples[i] > 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result",O(nlogn)
"class Solution2(object):
    def fillCups(self, amount):
        mx, total = max(amount), sum(amount)
        return mx if sum(amount)-mx <= mx else (total+1)//2",O(1)
"n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
count=0
for i in range(2**n):
    maxc=-1
    minc=-1
    c=0
    for j in range(n):
        if i>>j&1==1:
            c+=a[j]
            maxc=max(maxc,a[j])
            if minc==-1:
                minc=a[j]
            else:
                minc=min(a[j],minc)
    if c>=l and c<=r and maxc - minc >=x:
        count+=1
print(count)
",np
"import sys
input=sys.stdin.readline
hashi=dict()
for i in range(1,10**5):
    hashi[i*i]=1
    hashi[(2*i*i)]=1
t=int(input())
for you in range(t):
    n=int(input())
    if(n%2):
        print(""NO"")
        continue
    z=n//2
    if(z in hashi):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"import sys
input = sys.stdin.readline

n = int(input())
li = []

for i in range(n):
    x,w = map(int,input().split())
    li.append((x-w,x+w))

li.sort(key = lambda x: x[1])

a = -10 ** 9
ans = 0

for i in range(n):
     if a <= li[i][0]:
         ans += 1
         a = li[i][1]

print(ans)",O(nlogn)
"import sys

def prepare():
    stack = [i for i in range(n) if deg[i] == 0]
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            deg[dest] -= 1
            if deg[dest] == 0:
                stack.append(dest)
        adj[v].clear()

    return cnt == n

def solve(st):
    stack = [st]
    visited = [0]*n
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            if dest == st:
                continue
            visited[dest] += 1
            if deg[dest] == visited[dest]:
                stack.append(dest)

    return cnt == m

n, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
adj = [[] for _ in range(n)]
rev = [[] for _ in range(n)]
deg = [0]*n
for u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):
    adj[u-1].append(v-1)
    rev[v-1].append(u-1)
    deg[v-1] += 1

ok = prepare()
if ok:
    print('YES')
    exit()

m = len([1 for i in range(n) if deg[i] > 0])
for i in range(n):
    if deg[i] == 1 and solve(i):
        print('YES')
        exit()

print('NO')
",O(n ^ 2)
"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()]
x11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()]

min_x1 = min(x1, x2, x3, x4)
min_y1 = min(y1, y2, y3, y4)
max_x1 = max(x1, x2, x3, x4)
max_y1 = max(y1, y2, y3, y4)

min_x11 = min(x11, x22, x33, x44)
min_y11 = min(y11, y22, y33, y44)
max_x11 = max(x11, x22, x33, x44)
max_y11 = max(y11, y22, y33, y44)

a = (max_x11 + min_x11) / 2
b = (max_y11 + min_y11) / 2
d2 = (max_x11 - min_x11) / 2

for x in range(min_x1, max_x1 + 1):
    for y in range(min_y1, max_y1 + 1):
        if abs(x - a) + abs(y - b) <= d2:
            print(""yes"")
            exit(0)
print(""no"")
",O(1)
"class Solution2(object):
    def minSubArrayLen(self, s, nums):
        min_size = float(""inf"")
        sum_from_start = [n for n in nums]
        for i in range(len(sum_from_start) - 1):
            sum_from_start[i + 1] += sum_from_start[i]
        for i in range(len(sum_from_start)):
            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \
                                    i, len(sum_from_start), \
                                    sum_from_start[i] - nums[i] + s)
            if end < len(sum_from_start):
                min_size = min(min_size, end - i + 1)

        return min_size if min_size != float(""inf"") else 0

    def binarySearch(self, compare, A, start, end, target):
        while start < end:
            mid = start + (end - start) / 2
            if compare(target, A[mid]):
                end = mid
            else:
                start = mid + 1
        return start",O(nlogn)
"import itertools




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])



class Solution(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEFT] = result[RIGHT] = y
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            return result

        def query(x, y):
            return x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.tree[1][MAX_LEN])
        return result",O(nlogn)
"import collections
import heapq


class Solution3(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result",O(nlogn)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
P = permutations([i for i in range(4)])
plus = [(0,0),(0,n),(n,0),(n,n)]

A = []
for i in range(4):
    tmp = [input() for i in range(n)]
    if i!=3:
        _ = input()
    A.append(tmp)

tmp = [[0 for i in range(2*n)] for j in range(2*n)]
res = 10**17
for p in P:
    for k in range(4):
        x,y = plus[p[k]]
        for i in range(n):
            for j in range(n):
                tmp[i+x][j+y] = int(A[k][i][j])

    ans_1 = 0
    ans_2 = 0
    for i in range(2*n):
        for j in range(2*n):
            if tmp[i][j]==(i+j)%2:
                ans_1 += 1
            else:
                ans_2 += 1

    res = min(res,ans_1,ans_2)

print(res)
",O(n ^ 2)
"import collections


class Solution(object):
    def canPermutePalindrome(self, s):
        return sum(v % 2 for v in list(collections.Counter(s).values())) < 2",O(n)
"n = int(input())
print(n, 0, 0)",O(1)
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"import math
n=int(input())
if(n==3):
    print('1 1 3')

else:
    t=1
    while(t<=n):
        ct=math.ceil((n//t)/2)
        for i in range(0,ct):
            print(t,end="" "")

        if(ct==2 and (n//t)%2!=0):
            t=t*3
        else:
            t=t*2
    print("" "")
",O(nlogn)
"class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float(""-inf""), cmp=lambda x, y: x > y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(list(count.keys()), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it) 
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",O(nlogn)
"class Solution(object):
    def maxPower(self, s):
        result, count = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result",O(n)
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())

N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1

def zeta_transform(F,n):

    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res

G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)

def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c

ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)
",np
"t=list(map(int,input().split()))
n=t[0]
c=t[1]
a=list(map(int,input().split()))
f=[]
for i in range(0,500001):
	f.append(0)
l=[]
for i in range(0,500001):
	l.append([0])
m=0
for i in range(n):
	l[a[i]].append(f[a[i]]-m)
	if a[i]==c:
		m+=1
	f[a[i]]+=1
	l[a[i]].append(f[a[i]]-m)
ma=0
for i in l:
	mi=0
	for j in i:
		if(j<mi):
			mi=j
		if(ma<j-mi):
			ma=j-mi
print(m+ma)",O(n)
"n,k=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
mark,b=[],[]
for x in a:
    b.append(x)
    mark.append(False)
b.sort(reverse=True)
idx,profit=0,0
while idx<k:
    profit+=b[idx]
    for i in range(n):
        if not mark[i] and a[i]==b[idx]:
            mark[i]=True
            break
    idx+=1
print(profit)
prev,counter=-1,0
for i in range(n):
    if counter==(k-1):
        break
    if mark[i]:
        print(i-prev,end=' ')
        prev=i
        counter+=1
print(n-prev-1)
",O(nlogn)
"class Solution(object):
    def distinctIntegers(self, n):
        return n-1 if n >= 2 else 1",O(1)
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"n, k = map(int, input().split())

tm = []

for _ in range(n):
    p, t = map(int, input().split())
    tm.append([p, t])

tm.sort(key=lambda x: (x[0] * -1, x[1]))
ans = tm.count(tm[k-1])
print(ans)
",O(nlogn)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])
",np
"from math import sqrt
for _ in ' '*int(input()):
    n = int(input())
    if int(sqrt(n/2)) == sqrt(n/2) or int(sqrt(n/4)) == sqrt(n/4):
        print(""YES"")
    else: print(""NO"")",O(1)
"class Solution(object):
    def isWinner(self, player1, player2):
        k = 2
        def f(arr):
            result = cnt = 0
            for i in range(len(arr)):
                result += 2*arr[i] if cnt else arr[i]
                cnt += (arr[i] == 10)
                if i-k >= 0:
                    cnt -= (arr[i-k] == 10)
            return result

        a, b = f(player1), f(player2)
        return 1 if a > b else 2 if a < b else 0",O(n)
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = list(range(n + 1))
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",O(n ^ 3)
"class Solution2(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        prev, cnt = [0]*2, [0]*2
        for c in s:
            cnt[int(c)] += 1
            if cnt[int(c)^1]:
                prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0
            result = max(result, 2*min(prev[0], cnt[1]))
        return result",O(n)
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",O(nlogn)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        if not root:
            return ""N""
        res = []
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if not node:
                res.append(""N"")
            else:
                res.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        if vals[0] == ""N"":
            return None
        root = TreeNode(int(vals[0]))
        queue = deque([root])
        index = 1
        while queue:
            node = queue.popleft()
            if vals[index] != ""N"":
                node.left = TreeNode(int(vals[index]))
                queue.append(node.left)
            index += 1
            if vals[index] != ""N"":
                node.right = TreeNode(int(vals[index]))
                queue.append(node.right)
            index += 1
        return root
",O(n)
"class Solution2(object):
    def preorder(self, root):
        def dfs(root, result):
            result.append(root.val)
            for child in root.children:
                if child:
                    dfs(child, result)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"class Solution2(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def find_adj(pairs, rates):
            adj = collections.defaultdict(list)
            for i in range(len(pairs)):
                adj[pairs[i][0]].append((pairs[i][1], rates[i]))
                adj[pairs[i][1]].append((pairs[i][0], 1/rates[i]))
            return adj

        def bfs(dist, adj):
            q = list(dist.keys())
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u]:
                        if not w*dist[u] > dist[v]:
                            continue
                        dist[v] = w*dist[u]
                        new_q.append(v)
                q = new_q
            return dist
    
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        adj1 = find_adj(pairs1, rates1)
        bfs(dist, adj1) 
        adj2 = find_adj(pairs2, rates2)
        bfs(dist, adj2) 
        return dist[initialCurrency]",O(n ^ 2)
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution2(object):
    def missingNumber(self, nums):
        return sum(range(len(nums)+1)) - sum(nums)",O(n)
"def process(X, a, b):
    X1 = set(X)
    Other = set([])
    A = set([])
    B = set([])
    Both = set([])
    for x in X:
        if a-x in X1 and b-x  not in X1:
            A.add(x)
            A.add(a-x)
        elif a-x not in X1 and b-x in X1:
            B.add(x)
            B.add(b-x)
        elif a-x not in X1 and b-x not in X1:
            return 'NO'
        else:
            Both.add(x)
    start = A.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                if a-b+x in Both:
                    Both.remove(a-b+x)
                    A.add(a-b+x)
                    next_s.add(a-b+x)
                A.add(b-x)
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                A.add(a-x)
            elif a-x in B or a-x not in A:
                return 'NO'
        start = next_s
    start = B.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                if b-a+x in Both:
                    Both.remove(b-a+x)
                    B.add(b-a+x)
                    next_s.add(b-a+x)
                B.add(a-x)
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                B.add(b-x)
            elif b-x in A or b-x not in B:
                return 'NO'
        start = next_s
    answer = []
    for x in X:
        if x in A:
            answer.append(0)
        else:
            answer.append(1)
    return answer

n, a, b = [int(x) for x in input().split()]
X = [int(x) for x in input().split()]
answer = process(X, a, b)
if answer=='NO':
    print('NO')
else:
    print('YES')
    print(' '.join(map(str, answer)))
",O(n)
"from collections import Counter

n = int(input())
a = Counter()
b = Counter()
for _ in range(n):
    a[input().strip()] += 1
for _ in range(n):
    b[input().strip()] += 1
ans = 0
for key in b:
    ans += max(b[key] - a[key], 0)

print(ans)",O(n)
"from collections import defaultdict
from collections import deque

class graph:
    def __init__(self):
        self.g=defaultdict(list)
    def addedge(self,u,v):
        self.g[u].append(v)
def router(values):
    gr=graph()
    for i in range(len(values)):
        gr.addedge(values[i], i+2)
    return gr.g

def isleaf(node,gr):
    if len(gr[node])==0:
        return True
    return False

def christmas(gr,start,visited):
    q=deque()
    q.append(start)
    visited[start]=True
    count=0
    while q:
        count=0
        value=q.popleft()
        for val in gr[value]:
            if not isleaf(val,gr):
                q.append(val)
                visited[val]=True
            else:
                visited[val]=True
                count=count+1
        if count<3:
            return 'No'
    if count<3:
        return 'No'
    return 'Yes'
n=int(input())
values=[]
for i in range(n-1):
    value=int(input())
    values.append(value)
gr=router(values)
visited=[False]*(n+1)
print(christmas(gr, 1, visited))
",O(n)
"n,m=map(int,raw_input().split())
arr=[]
arr1=[]
for i in range(n):
	arr2=str(raw_input())
	arr.append(arr2)
	x1=[0]*m
	arr1.append(x1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]=='
			if(arr[i][j+1]=='
				arr1[i][j]=1
				arr1[i+1][j]=1
				arr1[i+2][j]=1
				arr1[i+2][j+1]=1
				arr1[i+2][j+2]=1
				arr1[i+1][j+2]=1
				arr1[i][j+1]=1
				arr1[i][j+2]=1
flag=0

for i in range(n):
	for j in range(m):
		if(arr[i][j]==""
			flag=1
			break
	if(flag==1):
		break
if(flag==1):
	print(""NO"")
else:
	print(""YES"")",O(n ^ 2)
"class Solution(object):
    def maxWidthRamp(self, A):
        result = 0
        s = []
        for i in A:
            if not s or A[s[-1]] > A[i]:
                s.append(i)
        for j in reversed(range(len(A))):
            while s and A[s[-1]] <= A[j]:
                result = max(result, j-s.pop())
        return result",O(n)
"from math import *
a,v=list(map(int,input().split()))
l,d,w=list(map(int,input().split()))
if v>w:
    s1=w**2/2/a
    if d<=s1:
        s=min(v**2/2/a,l)
        t=sqrt(2*s/a)+(l-s)/v
    else:
        t=sqrt(2*s1/a)
        s2=min((d-s1)/2,(v**2-w**2)/(2*a))
        if s2==(d-s1)/2:
            t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a))
        else:
            t+=2*(v-w)/a+(d-s1-2*s2)/v
        s3=min((v**2-w**2)/2/a,l-d)
        t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v
else:
    s=min(v**2/2/a,l)
    t=sqrt(2*s/a)+(l-s)/v
print(t)",O(1)
"n = int(input())
dicta = {}
dictb = {}
for i in range(n):
    a, x = map(int, input().split())
    dicta[a] = x
m = int(input())
for i in range(m):
    b, y = map(int, input().split())
    dictb[b] = y
ans = 0
for i in dicta.keys():
    if i in dictb.keys():
        ans += max(dicta[i], dictb[i])
        del dictb[i]
    else :
        ans += dicta[i]
for i in dictb.values():
    ans += i
print(ans)
",O(nlogn)
"class Solution(object):
    def maximumSubarraySum(self, nums, k):
        result = left = total = 0
        lookup = set()
        for right in range(len(nums)):
            while nums[right] in lookup or len(lookup) == k:
                lookup.remove(nums[left])
                total -= nums[left]
                left += 1
            lookup.add(nums[right])
            total += nums[right]
            if len(lookup) == k:
                result = max(result, total)
        return result",O(n)
"class Solution2(object):
    def countExcellentPairs(self, nums, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        sorted_cnts = sorted(popcount(x) for x in set(nums))
        result = 0
        left, right = 0, len(sorted_cnts)-1
        while left <= right:
            if sorted_cnts[left]+sorted_cnts[right] < k:
                left += 1
            else:
                result += 1+2*((right-1)-left+1)
                right -= 1
        return result",O(nlogn)
"class Solution2(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = {0:-1}
        dp = [0]*len(nums)
        result = total = 0
        for i, x in enumerate(nums):
            total += 1 if x == 1 else -1
            if total not in lookup:
                if total > 0:
                    dp[i] = i+1
            else:
                j = lookup[total]
                if j != -1:
                    dp[i] = dp[j]
                if x > 0:
                    dp[i] += (i-1)-j
            lookup[total] = i
            result = (result+dp[i])%MOD
        return result",O(n)
"def examA():
    T = I()
    ans = []
    for _ in range(T):
        N, M = LI()
        if N%M!=0:
            ans.append(""NO"")
        else:
            ans.append(""YES"")
    for v in ans:
        print(v)
    return

def examB():
    T = I()
    ans = []
    for _ in range(T):
        N = I()
        A = LI()
        A.sort()
        ans.append(A[::-1])
    for v in ans:
        print("" "".join(map(str,v)))
    return

def examC():
    T = I()
    ans = []
    for _ in range(T):
        N, K = LI()
        A = LI()
        sumA = sum(A)
        if sumA==0:
            ans.append(""YES"")
            continue
        cur = 0
        L = []
        for i in range(100):
            now = K**i
            L.append(now)
            cur += now
            if cur>=sumA:
                break
        for i in range(N):
            A[i] *= (-1)
        heapify(A)

        for l in L[::-1]:
            if not A:
                break
            a = -heappop(A)
            if a<l:
                heappush(A, -a)
            elif a>l:
                heappush(A,-(a-l))
        if not A or heappop(A)==0:
            ans.append(""YES"")
        else:
            ans.append(""NO"")
    for v in ans:
        print(v)
    return

def examD():
    class combination():

        def __init__(self, n, mod):
            self.n = n
            self.fac = [1] * (n + 1)
            self.inv = [1] * (n + 1)
            for j in range(1, n + 1):
                self.fac[j] = self.fac[j - 1] * j % mod

            self.inv[n] = pow(self.fac[n], mod - 2, mod)
            for j in range(n - 1, -1, -1):
                self.inv[j] = self.inv[j + 1] * (j + 1) % mod

        def comb(self, n, r, mod):
            if r > n or n < 0 or r < 0:
                return 0
            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod
    N, M = LI()
    ans = 0
    if N==2:
        print(ans)
        return
    C = combination(M,mod2)
    for i in range(N-1,M+1):
        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)

        ans += cur
        ans %= mod2
    print(ans)
    return

def examE():
    N = I()
    A = LI()
    dp = [[-1]*(N+1) for _ in range(N+1)]
    for i in range(N):
        dp[i][i+1] = A[i]
    for l in range(2, N + 1):
        for i in range(N - l + 1):
            for k in range(i + 1, i + l):
                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:
                    dp[i][i + l] = dp[i][k] + 1

    L = [inf]*(N+1)
    for i in range(1,N+1):
        if dp[0][i]>=1:
            L[i] = 1
    for i in range(N):
        for k in range(1, N - i + 1):
            if dp[i][i + k] >= 1:
                L[i + k] = min(L[i + k], L[i] + 1)

    ans = L[N]
    print(ans)
    return

def examF():
    ans = 0
    print(ans)
    return

import sys,copy,bisect,itertools,heapq,math,random
from heapq import heappop,heappush,heapify
from collections import Counter,defaultdict,deque
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LSI(): return list(map(str,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def SI(): return sys.stdin.readline().strip()
global mod,mod2,inf,alphabet,_ep
mod = 10**9 + 7
mod2 = 998244353
inf = 10**18
_ep = 10**(-12)
alphabet = [chr(ord('a') + i) for i in range(26)]

if __name__ == '__main__':
    examE()
",O(n ^ 3)
"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        res = 0
        q = deque()

        q.append((root,-float('inf')))

        while q:
            node,maxval = q.popleft()
            if node.val >= maxval:
                res += 1

            if node.left:
                q.append((node.left,max(maxval,node.val)))

            if node.right:
                q.append((node.right,max(maxval,node.val)))

        return res
",O(n)
"import sys
input=sys.stdin.readline
n=int(input())
c=["" ""]+[input().rstrip() for i in range(n)]
mod=10**9+7
dp=[[0]*(n+1) for i in range(n+1)]
dp[1][0]=1
sdp=[0]*(n+1)
sdp[0]=1
for i in range(1,n+1):
    if i>=2 and c[i-1]==""f"":
        for j in range(1,n+1):
            dp[i][j]=dp[i-1][j-1]
            dp[i][j]%=mod
        dp[i][0]=0
    else:
        for j in range(n+1):
            dp[i][j]=sdp[j]
            dp[i][j]%=mod
    sdp=[dp[i][j] for j in range(n+1)]
    for j in range(1,n+1)[::-1]:
        sdp[j-1]+=sdp[j]
        sdp[j-1]%=mod
print(sdp[0]%mod)",O(n ^ 2)
"n, k = [int(a) for a in input().split()]
power = [int(a) for a in input().split()]
coins = [int(a) for a in input().split()]

dp = [0 for i in range(n)]

def takeSecond(elem):
    return elem[1]

def takeFirst(elem):
    return elem[0]

people = [(power[i], coins[i], i) for i in range(n)]

people.sort(key=takeFirst)

dp[0] = []

for i, p in enumerate(people):
    if i == 0:
        continue
    kills = [i for i in dp[i - 1]]
    kills.append(people[i - 1][1])
    x = []

    if len(kills) > k:
        kills.remove(min(kills))

    dp[i] = kills

x = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]

x.sort(key=takeFirst)

print("" "".join([z[1] for z in x]))
",O(nlogn)
"n, k =map(int,input().split())
a = list(map(int, input().split()))
if n == 1:
    print(a[0])
    print(1)
else:
    lst = sorted(a)[-k:]
    ans = sum(lst)
    print(ans)
    c = 0
    ln = len(lst)
    ans = [0]
    cnt = 0
    for i in range(n):
        if cnt == k - 1:
            break
        for j in range(ln):
            if a[i] == lst[j]:
                lst[j] = -1
                ans.append(i + 1)
                cnt += 1
                break
    ln = len(ans)
    for i in range(1,ln):
        print(ans[i] - ans[i - 1], end = "" "")
    print(n - ans[-1])
",O(nlogn)
"left = -1
right = 10e9 - 1
nn = [int(i) for i in input().split()]
n = nn[0]
k = nn[1]
f = True
while right - left > 1:
    mid = (left + right) // 2
    if ((n - mid + 1) * abs((n - mid)) // 2 - mid > k):
        left = mid
    else:
        if((n - mid + 1) * abs((n - mid)) // 2 - mid == k):
            print(round(mid))
            f = False
            break
        else:
            right = mid
if f:
    print(round(left))
",O(logn)
"class Solution(object):
    def minOperationsToFlip(self, expression):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],
               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}
        precedence = {'&':0, '|':0}
        operands, operators = [], []
        for c in expression:
            if c.isdigit():
                operands.append([int(c != '0'), int(c != '1')])
            elif c == '(':
                operators.append(c)
            elif c == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif c in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[c]:
                    compute(operands, operators)
                operators.append(c)
        while operators:
            compute(operands, operators)
        return max(operands[-1])",O(n)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0.0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[1 << i] / su for i in range(n)])
",np
"n = int(input())

string = input()
i = 0
j = 0
total = 0

while j < len(string):
    bool = False
    count = 0
    while j < len(string) and string[i] == 'x' and string[j] == 'x':
        count += 1
        bool = True
        j += 1

    if count >= 3:
        total += (count-3)+1
    if bool:
        i = j
    else:
        i += 1
        j += 1

print(total)
",O(n)
"from sys import stdin
input=stdin.readline
rn=lambda:int(input())
rns=lambda:map(int,input().split())
rl=lambda:list(map(int,input().split()))
rs=lambda:input()
YN=lambda x:print('YES') if x else print('NO')
mod=10**9+7

n,m,k=rns()
rows=[rl() for i in range(n)]
cols=[rl() for i in range(n-1)]
def solve():
    if k%2==1:
        return [m*[-1] for i in range(n)]
    dp=[[[0 for i in range(k//2+1)] for j in range(m)] for l in range(n)]
    for i in range(1,k//2+1):
        for a in range(n):
            for b in range(m):
                mins=[]
                if b>0:
                    mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1])
                if b<m-1:
                    mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b])
                if a>0:
                    mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b])
                if a<n-1:
                    mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b])
                dp[a][b][i]=min(mins)
    ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)]
    return ans

ans = solve()
for i in ans:
    print(*i)",O(n ^ 3)
"def main():
    N, M, K = map(int, input().split())
    HEdge = [list(map(int, input().split())) for _ in range(N)]
    VEdge = [list(map(int, input().split())) for _ in range(N - 1)]
    if K % 2:
        for i in range(N):
            print(*[-1] * M)
        return
    dp = [[[0] * M for _ in range(N)] for _ in range(K // 2 + 1)]
    for i in range(1, K // 2 + 1):
        for j in range(N):
            for k in range(M):
                Val1 = Val2 = Val3 = Val4 = 10 ** 9
                if j > 0:
                    Val1 = dp[i - 1][j - 1][k] + VEdge[j - 1][k]
                if j < N - 1:
                    Val2 = dp[i - 1][j + 1][k] + VEdge[j][k]
                if k > 0:
                    Val3 = dp[i - 1][j][k - 1] + HEdge[j][k - 1]
                if k < M - 1:
                    Val4 = dp[i - 1][j][k + 1] + HEdge[j][k]
                dp[i][j][k] = min(Val1, Val2, Val3, Val4)
    for i in dp[K // 2]:
        print(*list(map(lambda x: x * 2, i)))

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution(object):
    def isCircularSentence(self, sentence):
        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in range(len(sentence)) if sentence[i] == ' ')",O(n)
"n=int(input())
if(n>=0):
    print(n)
else:
    n=abs(n)
    rem=n%10
    n1=n//10
    n2=n1//10
    n2=n2*10+rem
    k=min(n1,n2)
    print(-1*k)
",O(1)
"class Solution(object):
    def encode(self, s):
        def encode_substr(dp, s, i, j):
            temp = s[i:j+1]
            pos = (temp + temp).find(temp, 1) 
            if pos >= len(temp):
                return temp
            return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']'

        dp = [["""" for _ in range(len(s))] for _ in range(len(s))]
        for length in range(1, len(s)+1):
            for i in range(len(s)+1-length):
                j = i+length-1
                dp[i][j] = s[i:i+length]
                for k in range(i, j):
                    if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]):
                        dp[i][j] = dp[i][k] + dp[k+1][j]
                encoded_string = encode_substr(dp, s, i, j)
                if len(encoded_string) < len(dp[i][j]):
                    dp[i][j] = encoded_string
        return dp[0][len(s) - 1]",O(n ^ 3)
"class Solution(object):
    def countDigits(self, num):
        result = 0
        curr = num
        while curr:
            result += int(num%(curr%10) == 0)
            curr //= 10
        return result",O(logn)
"import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:[*map(int,Z().split())]
n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]
if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit()
d=[0]*n*m
for _ in range(k//2):
    nd=[0]*n*m
    for x in range(n):
        for y in range(m):
            v=x*m+y;w=[]
            if x:w.append(d[v-m]+V[x-1][y])
            if y:w.append(d[v-1]+H[x][y-1])
            if x<n-1:w.append(d[v+m]+V[x][y])
            if y<m-1:w.append(d[v+1]+H[x][y])
            nd[v]=min(w)
    d=nd
print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",O(n ^ 3)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",O(n ^ 3)
"import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True",O(n)
"a = list(map(int, input().split()))

ans = 0
for i in range(len(a)):
    x = a[i]
    b = [j for j in a]
    b[i] = 0
    for j in range(len(a)):
        b[j] += x // 14

    for j in range(1, x % 14 + 1):
        b[(i + j) % 14] += 1

    ans_now = 0
    for j in b:
        if j % 2 == 0:
            ans_now += j
    ans = max(ans_now, ans)
print(ans)",O(1)
"x, n = map(int, input().split())
MOD = 10**9 + 7
c = 4*x
if c == 0:
    ans = 0
elif n == 0:
    ans = 2 * x
else:
    ans = (((c - 2) * pow(2, n -1, MOD) + 1) + MOD) % MOD
print(ans % MOD)",O(logn)
"a=input()
n=len(a)
for l in range(n,0,-1):
  for i in range(n-l+1):
    if a[i:i+l] in a[i+1:]:
      print(l)
      exit(0)
print(0)",O(n ^ 3)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
	G = defaultdict(list)

	def addEdge(a,b):
		G[a].append(b)

	def Kahn(N):
	    in_degree = [0]*(N+1)
	    for i in G.keys():
	        for j in G[i]:
	            in_degree[j] += 1
	    queue = deque()
	    for i in range(1,N+1):
	        if in_degree[i] == 0:
	            queue.append(i)
	    cnt =0
	    top_order = []
	    while queue:
	        u = queue.popleft()
	        top_order.append(u)
	        for i in G.get(u,[]):
	            in_degree[i] -= 1
	            if in_degree[i] == 0:
	                queue.append(i)
	        cnt += 1
	    if cnt != N:
	        Y(0);exit(0)
	    else:
	        Y(1);print(*top_order)

	n,m,k = aj()
	mark= {}
	for i in range(n):
		s = input()
		mark[s] = i+1

	B = []
	for i in range(2**k):
		f = bin(i)[2:]
		f = '0'*(k - len(f)) + f
		B.append(f)

	for i in range(m):
		s,mt = input().split("" "")
		mt = int(mt)
		st = set()
		for j in B:
			ss = ['']*k
			for l in range(k):
				if j[l] == '1':
					ss[l] = s[l]
				else:
					ss[l] = '_'
			ss = """".join(ss)
			if ss in mark:
				st.add(mark[ss])

		if mt not in st:
			Y(0);exit(0)
		st.discard(mt)
		for j in st:
			addEdge(mt,j)

	Kahn(n)

try:

	sys.stdin = open('input.txt', 'r')
	sys.stdout = open('output.txt', 'w')
except:
	pass

solve()",np
"class Solution(object):
    def maxBuilding(self, n, restrictions):
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        for i in reversed(range(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))
        result = 0
        for i in range(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))
            left, h1 = restrictions[i-1]
            right, h2 = restrictions[i]
            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)
        return result",O(nlogn)
"class Solution2(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def dfs(u, p):
            cnt = [1-is_prime(u+1), is_prime(u+1)]
            for v in adj[u]:
                if v == p:
                    continue
                new_cnt = dfs(v, u)
                result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0]
                if is_prime(u+1):
                    cnt[1] += new_cnt[0]
                else:
                    cnt[0] += new_cnt[0]
                    cnt[1] += new_cnt[1]
            return cnt

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)",O(nlogn)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    print((solve(r) - solve(l - 1)) % mod)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"from sys import stdin, stdout, exit
import math

n, k = map(int, stdin.readline().split())

ans = round((-3 + math.sqrt(9 + 8*(k+n))) / 2)
stdout.write(str(n-ans) + ""\n"")
",O(1)
"def solve():
    n, l, r, x = map(int, input().split(' '))
    c = list(map(int, input().split(' ')))
    ans = 0
    for bitmask in range(2 ** n):
        if bin(bitmask).count('1') > 1:
            res, _min, _max = 0, float('+inf'), float('-inf')
            for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))):
                if bit_i:
                    res += c_i * bit_i
                    if c_i < _min:
                        _min = c_i
                    if c_i > _max:
                        _max = c_i
            if l <= res <= r and (_max - _min) >= x:
                ans += 1
    print(ans)

if __name__ == '__main__':
    solve()",np
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head",O(n)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",O(n)
"n,k = map(int,input().split())
B = [1]*(n+1)
B[0] = B[1] = 0
for i in range(2,n+1):
    if B[i] == 1:
        m = 2
        while m*i <= n:
            B[m*i] = 0
            m += 1
C = []
D = []
for i in range(len(B)):
    if B[i] != 0:
        D.append(i)
for i in range(1,len(D)):
    c = D[i] + D[i-1] + 1
    if c <= n:
        C.append(c)
x = 0
for i in range(len(C)):
    if B[C[i]] == 1:
        x += 1
if x >= k:
    print('YES')
else:
    print('NO')",O(n)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        queue = deque([root])
        while queue:
            node = queue.popleft()
            node.left, node.right = node.right, node.left
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return root
",O(n)
"a,b = (map(int,input().split()))
print((b+a-1)//a)
",O(1)
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",np
"def main():

    def num(left, right, dp, rev, revI):
        if left > right:
            return 1

        key = left, rev, revI
        if key in dp:
            return dp[key]
        nonlocal ans

        acc = 0

        for x in ('01' if ans[left]=='

            temp = None
            if left == right:
                tmp = x
            elif ans[right]=='
                tmp = '01'
            else:
                tmp = ans[right]

            for y in tmp:
                if not ((rev and x>y) or (revI and x==y=='1')):
                    acc += num(
                        left+1,
                        right-1,
                        dp,
                        rev and x==y,
                        revI and x!=y
                    )
        dp[key] = acc
        return acc

    n, k = map(int, input().split())
    k += 1

    ans = ['

    for i in range(n):
        ans[i] = '0'
        tmp = num(0, n-1, {}, True, True)

        if k > tmp:
            k -= tmp
            ans[i] = '1'

    if ans[0] == '0':
        print(''.join(ans))
    else:
        print(-1)

if __name__ == '__main__':
    import sys, os
    from time import time
    if len(sys.argv)>1 and os.path.exists(sys.argv[1]):
        sys.stdin = open(sys.argv[1], 'rb')
    st = time()
    main()
    print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)
",O(n ^ 3)
"n = int(input())
a = sorted(list(map(int, input().split())))

win = None
first = True

if n == 1:
    win = a[0] % 2 == 1
elif a[1] == 0:
    win = False

if n > 2:
    for i in range(n-1):
        if a[i] == a[i+1]:
            if i > 0:
                if a[i-1] == a[i]-1:
                    win = False
                    break
            if not first:
                win = False
                break
            first = False

if win is None:
    win = (sum(a) - (n*(n-1)//2)) % 2 == 1

if win:
    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"import sys
import string

def ria():
    return [int(i) for i in input().split()]

n, k = ria()
mp = {}
for i in string.ascii_uppercase[:k]:
    mp[i] = 0
for i in input():
    if i in mp:
        mp[i] += 1
print(min(mp.values())*k)",O(n)
"num=int(input())

a=input()

b=input()

dic={}

lis=[]

ham=0

swap1=-1

swap2=-1

p=False

q=False

for i in range(num):

    if a[i]!=b[i]:

        ham+=1

        lis.append(i)

        dic[b[i]]=i

for i in lis:

    if a[i] in dic:

        p=True

        swap1=i+1

        f=dic[a[i]]

        swap2=f+1

        if a[f]==b[i]:

            q=True

            break

print(ham-(2 if q else 1 if p else 0))

print(swap1,swap2)
",O(n)
"import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):
        if len(nums) % 2:
            if nums[len(nums)//2] != target:
                return False
        else:
            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):
                return False

        left = bisect.bisect_left(nums, target)
        right= bisect.bisect_right(nums, target)
        return (right-left)*2 > len(nums)",O(logn)
"n = int(input())
a = list(map(int, input().split()))
s = set(a)
s.discard(0)
print(len(s))
",O(n)
"import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:
        sqrt5 = math.sqrt(5)
        phi = (1 + sqrt5) / 2
        psi = (1 - sqrt5) / 2
        n += 1
        return round((phi**n - psi**n) / sqrt5)
",O(logn)
"class Solution(object):
    def minimumPossibleSum(self, n, target):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(target//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b)",O(1)
"import math
s=input()
p=input()
c=1
ss=0
ps=0
k=0
for i in range(len(s)):
	if(p[i]=='?'):
		c*=2
		k+=1
	if(s[i]=='+'):
		ss+=1
	else:
		ss-=1
	if(p[i]=='+'):
		ps+=1
	elif p[i]=='-':
		ps-=1
y=math.fabs(ss-ps)
x=k-y
a=y+x/2
b=k-a
if k<y:
	ans=0.000000000
else:
	ans=math.factorial(a+b)/(math.factorial(a)*math.factorial(b))
	ans/=c
print(""%.12f""%ans)
",np
"class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = j = 0
        for i in range(len(team)):
            if not team[i]:
                continue
            while j < i-dist:
                j += 1
            while j <= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j <= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result",O(n)
"class Solution(object):
    def breakPalindrome(self, palindrome):
        for i in range(len(palindrome)//2):
            if palindrome[i] != 'a':
                return palindrome[:i] + 'a' + palindrome[i+1:]
        return palindrome[:-1] + 'b' if len(palindrome) >= 2 else """"",O(n)
"import math

v = [int(x) for x in input().split()]
n = len(v)
val = 0
for i in range(n):
    a = v[i] // n
    arr = v.copy()
    arr[i] = 0
    for j in range(n):
        arr[j] += a
    b = v[i] % n
    k = i + 1
    l = 0
    while l < b:
        if k > n - 1:
            k = 0
        arr[k] += 1
        k += 1
        l += 1

    count = 0
    for j in range(n):
        if arr[j] % 2 == 0:
            count += arr[j]
    val = max(val, count)
print(val)
",O(1)
"def comp(a,b):
    x=len(a)
    s1=''
    s2=''
    for i in range(x):
        s1+=str(a[i])
        s2+=str(b[i])
    if s1>s2:
        return 1
    else:
        return 0

a=list(input(''))
b=list(input(''))
cnt=[0]*10
n=len(a)
m=len(b)
sol=''
for i in range(n):
    a[i]=int(a[i])
    cnt[a[i]]+=1

if n!=m:
    a.sort(reverse=True)
    for i in a:
        sol+=str(i)
    print(sol)
else:
    a.sort()

    for i in range(n):
        b[i]=int(b[i])
    for i in range(n-1):
        for j in range(i,n):
            if a[i]<a[j]:
                temp=a[i]
                a[i]=a[j]
                a[j]=temp
                if comp(a,b):
                    temp=a[i]
                    a[i]=a[j]
                    a[j]=temp

    for i in a:
        sol+=str(i)
    print(sol)",O(n ^ 3)
"def main():
    n, k = [int(x) for x in input().split(' ')]
    if k==1:
        print(n)
        return
    a = []
    b = {}
    a = [int(x) for x in input().split(' ')]
    a.sort()

    a=dict(zip(a,range(n)))
    count = {}

    for x in a:
        if x % k == 0 and int(x / k) in a:
            b[x] = b[int(x / k)]
            count[b[int(x / k)]] += 1
        else:
            b[x] = x
            count[x] = 1

    for x,y in count.items():
        n -= int(y / 2)

    print(n)

main()
",O(nlogn)
"def NOD(a, b):
    while b != 0:
        a %= b
        y = a
        a = b
        b = y
    return(a)

def NOK(a, b):
    i = (a*b) // NOD(a, b)
    return(i)

n = int(input())
maxnok = 0
x = 40
for i in range(max(1, n-x), n+1):
    for j in range(max(1, i-x), i+1):
        for f in range(max(1, j-x), j+1):
            nokk = NOK(NOK(i,j), f)
            if maxnok < nokk:
                maxnok = nokk
                delit = []
                delit.append(i)
                delit.append(j)
                delit.append(f)
print(maxnok)",O(1)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
diameter = 2*k

for i,level in enumerate(d):
    if level == diameter:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

if center == -1:
    print(""NO"")
    exit()

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n, q = map(int,input().split())
par = n // 2 + 1
par = len(list(bin(par)[2:]))
for i in range(q):
    ui = int(input())
    si = input()
    temp = bin(ui)[2:]
    now = len(temp)
    num = list((par - now) * ""0"" + temp)
    now = par - now
    for i in range(len(num)):
        if str(num[i]) == '1':
            now = i
    for i in si:
        if i == ""U"":
            if now == 0:
                continue
            num[now] = 0
            now -= 1
            num[now] = 1
        elif i == ""L"":
            if str(num[-1]) == '1':
                continue
            num[now] = 0
            now += 1
            num[now] = 1
        else:
            if str(num[-1]) == '1':
                continue
            now += 1
            num[now] = 1
    for i in range(par):
        num[i] = str(num[i])
    print(int("""".join(num),2))
",np
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)",O(n)
"class Solution2(object):
    def reconstructQueue(self, people):
        people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))
        result = []
        for p in people:
            result.insert(p[1], p)
        return result",O(n ^ 2)
"def prefix_func(s):
    slen, k = len(s), 0
    p = [0]*slen
    p[0] = 0
    for i in range(1, slen):
        while k>0 and s[k] != s[i]:
            k = p[k-1]
        if s[k] == s[i]:
            k += 1
        p[i] = k
    return p
n,k=map(int,input().split())
s=input()
l=prefix_func(s)[-1]
print(s+s[l:]*(k-1))
",O(n ^ 2)
"class Solution(object):
    def countBinarySubstrings(self, s):
        result, prev, curr = 0, 0, 1
        for i in range(1, len(s)):
            if s[i-1] != s[i]:
                result += min(prev, curr)
                prev, curr = curr, 1
            else:
                curr += 1
        result += min(prev, curr)
        return result",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def put(self, key, value):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            node.val = value
        else:
            l.insert(ListNode(key, value))

    def get(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            return node.val
        else:
            return -1

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)",O(1)
"x=int(input())
d=x//2
print(d+1)
",O(1)
"class Solution3(object):
    def deleteString(self, s):
        MOD, P = 10**9+7, (113, 109)
        def hash(i, j):
            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in range(len(P))]

        if all(x == s[0] for x in s):
            return len(s)

        power = [[1] for _ in range(len(P))]
        prefix = [[0] for _ in range(len(P))]
        for x in s:
            for idx, p in enumerate(P):
                power[idx].append((power[idx][-1]*p)%MOD)
                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(1, (len(s)-i)//2+1):
                if hash(i, i+j-1) == hash(i+j, i+2*j-1):
                    dp[i] = max(dp[i], dp[i+j]+1)
        return dp[0]",O(n ^ 2)
"import sys
input_file = sys.stdin
C = (10**9+7)
[n, q] = list(int(i) for i in input_file.readline().split())
temp = input_file.readline()
lst = []
for char in temp[:-1]:
    lst.append(int(char))

new_lst = [(0, 0)]
for i in lst:
    if i == 0:
        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))
    else:
        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))

ls = [1]
for i in range(n):
    ls.append(ls[-1]*2 % C)

for line in input_file:
    [l, r] = list(int(i) for i in line[:-1].split())
    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])
    print((ls[sum(q)] - ls[q[0]]) % C)
",O(n)
"a,b=map(int,input().split())
if a==b:print(0)
else:
    x=a^b
    c=0
    while x:
        x=x//2
        c+=1
    print(2**c-1)
",O(logn)
"n = int(input())
print(n * n + (n - 1) **2)
",O(1)
"import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Solution(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num < num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Solution.P_DENOMINATOR) <= Solution.P_NUMERATOR and \
              level < Solution.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])",O(logn)
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def construct(self, grid):
        def dfs(grid, x, y, l):
            if l == 1:
                return Node(grid[x][y] == 1, True, None, None, None, None)
            half = l // 2
            topLeftNode = dfs(grid, x, y, half)
            topRightNode = dfs(grid, x, y+half, half)
            bottomLeftNode = dfs(grid, x+half, y, half)
            bottomRightNode = dfs(grid, x+half, y+half, half)
            if topLeftNode.isLeaf and topRightNode.isLeaf and \
               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
                return Node(topLeftNode.val, True, None, None, None, None)
            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)
        
        if not grid:
            return None
        return dfs(grid, 0, 0, len(grid))",O(n ^ 2)
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",O(1)
"class Solution(object):
    def scoreOfParentheses(self, S):
        result, depth = 0, 0
        for i in range(len(S)):
            if S[i] == '(':
                depth += 1
            else:
                depth -= 1
                if S[i-1] == '(':
                    result += 2**depth
        return result",O(n)
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)
",O(1)
"class Solution:

    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):
            res += self.countPali(s, i, i)
            res += self.countPali(s, i, i + 1)
        return res

    def countPali(self, s, l, r):
        res = 0
        while l >= 0 and r < len(s) and s[l] == s[r]:
            res += 1
            l -= 1
            r += 1
        return res
",O(n ^ 2)
"class Solution(object):
    def lemonadeChange(self, bills):
        coins = [20, 10, 5]
        counts = collections.defaultdict(int)
        for bill in bills:
            counts[bill] += 1
            change = bill - coins[-1]
            for coin in coins:
                if change == 0:
                    break
                if change >= coin:
                    count = min(counts[coin], change//coin)
                    counts[coin] -= count
                    change -= coin * count
            if change != 0:
                return False
        return True",O(n)
"n = int(input())
print(""0 0 {}"".format(n))
",O(1)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
",O(n)
"n,k=map(int,input().split())

ans=k//n
if(k%n):
    ans+=1
print(ans)",O(1)
"
import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):
        count = collections.Counter(nums)
        for num in sorted(count.keys()):
            c = count[num]
            if not c:
                continue
            for i in range(num, num+k):
                if count[i] < c:
                    return False
                count[i] -= c
        return True
",O(nlogn)
"n,k = map(int,input().split())

def sumTillN (n) :
    return (n*(n+1))//2

minEat = 0
maxEat = n
midEat = 0

while (minEat<=maxEat):
    midEat = (minEat+maxEat)//2
    x = sumTillN(n-midEat)
    if (x==k+midEat):
        break
    elif (x>k+midEat):
        minEat = midEat+1
    else:
        maxEat = midEat-1

print(midEat)
",O(logn)
"class Solution(object):
    def minimumBuckets(self, street):
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 < len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import collections


class Solution(object):

    def __init__(self, v1, v2):
        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def __next__(self):
        len, iter = self.q.popleft()
        if len > 1:
            self.q.append((len-1, iter))
        return next(iter)

    def hasNext(self):
        return bool(self.q)",O(1)
"from functools import lru_cache

P = 10**9+7
N, T = map(int, input().split())
A = [[], [], []]
X = []
for _ in range(N):
    t, g = map(int, input().split())
    X.append((t, g))

@lru_cache(maxsize=None)
def calc(x, pr, t):
    if t < 0:
        return 0
    if t == 0:
        return 1
    if x == 0:
        return 0

    ans = 0
    for i in range(15):
        if x & (1<<i):
            if X[i][1] != pr:
                y = x ^ (1<<i)
                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P
    return ans

print(calc(2**N-1, -1, T))",np
"from random import randint, seed



class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self, end=[float(""inf""), float(""inf""), float(""inf"")], can_duplicated=True):
        seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.add(end)
        self.__end = self.find(end)

    def begin(self):
        return self.__head.nexts[0]
    
    def end(self):
        return self.__end

    def lower_bound(self, target, cmp=lambda x, y: x < y):
        return self.__lower_bound(target, self.__find_prev_nodes(target, cmp))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return self.find(val), False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return node if self.__can_duplicated else (node, True)

    def remove(self, it):
        prevs = it.prevs
        curr = self.__find(it.val, prevs)
        if not curr:
            return self.__end
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return curr.nexts[0]
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val, cmp=lambda x, y: x < y):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and cmp(curr.nexts[i].val, val):
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \
              level < SkipList.MAX_LEVEL:
            level += 1
        return level
    
    def __iter__(self):
        it = self.begin()
        while it != self.end():
            yield it.val
            it = it.nexts[0]

    def __len__(self):
        return self.__len-1 

    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])



class LineContainer(object):
    def __init__(self):
        self.__skiplist = SkipList()

    def add(self, k, m):
        self.__skiplist.add([k, m, 0])
        z = self.__skiplist.find([k, m, 0])
        x = y = z
        z = z.nexts[0]
        while self.__intersect(y, z):
            z = self.__skiplist.remove(z)
        if x != self.__skiplist.begin():
            x = x.prevs[0]
            if self.__intersect(x, y):
                y = self.__skiplist.remove(y)
                self.__intersect(x, y)
        y = x
        while y != self.__skiplist.begin():
            x = x.prevs[0]
            if x.val[2] < y.val[2]:
                break
            y = self.__skiplist.remove(y)
            self.__intersect(x, y)
            y = x
    
    def query(self, x):
        it = self.__skiplist.lower_bound(x, cmp=lambda x, y: x[2] < y)
        return it.val[0]*x + it.val[1]

    def __intersect(self, x, y):
        if y == self.__skiplist.end():
            x.val[2] = float(""inf"")
            return False
        if x.val[0] == y.val[0]:
            x.val[2] = float(""inf"") if x.val[1] > y.val[1] else float(""-inf"")
        else:
            x.val[2] = (y.val[1]-x.val[1])//(x.val[0]-y.val[0])
        return x.val[2] >= y.val[2]

    def __iter__(self):
        return iter(self.__skiplist)

    def __len__(self):
        return len(self.__skiplist)

    def __str__(self):
        return str(self.__skiplist)



class Solution(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = 0
        lc = LineContainer()
        for i in reversed(range(len(nums))):
            lc.add(prefix1[i+1], -(dp+prefix1[i+1]*prefix2[i+1]))
            dp = (-lc.query(prefix2[i]))+(k*(prefix2[-1]-prefix2[i]))
        return dp",O(nlogn)
"

class Solution(object):
    def isStrictlyPalindromic(self, n):
        return False
",O(1)
"n = int(input())
dis = list(map(lambda x: int(x) << 1, input().split()))
ter = input()
st, ans = 0, 0
time = {'G': 5, 'W': 3, 'L': 1}
delta = {'G':1, 'W':1, 'L':-1}
hasWater = False
convert = 0
for i in range(n):
	st += dis[i] * delta[ter[i]]
	ans += dis[i] * time[ter[i]]

	if ter[i] == 'W':
		hasWater = True
	elif ter[i] == 'G':
		convert += dis[i]
	if st < 0:
		if hasWater:
			ans += (-st) * 3
		else:
			ans += (-st) * 5
		st = 0
	convert = min(convert, st // 2)

ans -= 4 * convert
ans -= 2 * (st // 2 - convert)
print(ans // 2)
",O(n)
"class Solution(object):
    def appealSum(self, s):
        result = curr = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)
            lookup[ord(c)-ord('a')] = i
        return result",O(n)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(n - 1, -1, -1):
            new_dp = [False] * (n + 1)
            for open in range(n):
                if s[i] == '*':
                    new_dp[open] = (dp[open + 1] or
                                    (open > 0 and dp[open - 1]) or
                                    dp[open])
                elif s[i] == '(':
                    new_dp[open] = dp[open + 1]
                elif open > 0:
                    new_dp[open] = dp[open - 1]
            dp = new_dp

        return dp[0]
",O(n ^ 2)
"import collections
import itertools



class Solution(object):
    def mostPopularCreator(self, creators, ids, views):
        cnt = collections.Counter()
        lookup = collections.defaultdict(lambda: (float(""inf""), float(""inf"")))
        for c, i, v in zip(creators, ids, views):
            cnt[c] += v
            lookup[c] = min(lookup[c], (-v, i))
        mx = max(cnt.values())
        return [[k, lookup[k][1]] for k, v in cnt.items() if v == mx]",O(n)
"def bs(l, h):
    while l < h:
        m = (l + h) // 2
        if gf(m):
            h = m
        else:
            l = m + 1
    return l

def gf(x):
    d = {}
    for i in range(x):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
    if len(d) == len(u):
        return 1
    for i in range(x, n):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
        d[s[i - x]] -= 1
        if not d[s[i - x]]:
            del d[s[i - x]]
        if len(d) == len(u):
            return 1
    return 0

n = int(input())
s = input()
u = set([*s])
print(bs(1, n))",O(n)
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)==1:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"import sys, heapq

n = int(sys.stdin.readline())
key = []
for i in ['S', 'M', 'L']:
    for j in range(4):
        key.append(j * 'X' + i)
prev = dict().fromkeys(key, 0)
now = dict().fromkeys(key, 0)
for _ in range(n):
    prev[sys.stdin.readline().rstrip()] += 1
for _ in range(n):
    now[sys.stdin.readline().rstrip()] += 1
for i in key:
    temp = min(prev[i], now[i])
    prev[i] -= temp
    now[i] -= temp
ans = 0
for i in key:
    ans += now[i]
print(ans)
",O(n)
"n, m = map(int, input().split())
V = []
for i in range(n):
    V.append(int(input()))
V.sort()
V.append(10 ** 9)
n += 1
X2 = []
for i in range(m):
    x1, x2, y = map(int, input().split())
    if x1 == 1:
        X2.append(x2)
X2.sort()
k = len(X2)
i = 0
j = 0
ans = 10 ** 9 + 7
c = 0

while i < n:
    while j < k:
        if X2[j] < V[i]:
            c += 1
            j += 1
        else:
            break
    ans = min(ans,  k - c + i)
    i += 1
print(ans)",O(nlogn)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isValidBST(self, root):
        prev, cur = None, root
        while cur:
            if cur.left is None:
                if prev and prev.val >= cur.val:
                    return False
                prev = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    if prev and prev.val >= cur.val:
                        return False
                    node.right = None
                    prev = cur
                    cur = cur.right

        return True


",O(n)
"def replace(arr):
    if arr==[1]*len(arr):
        arr[-1]=2
        print(*sorted(arr))
        return """"
    arr[arr.index(max(arr))]=1
    print(*sorted(arr))
    return """"
a=input()
lst=list(map(int,input().strip().split()))
print(replace(lst))",O(nlogn)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:

            m = l + ((r - l) // 2)

            if nums[m] > target:
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                return m
        return -1
",O(logn)
"n = int(input())

print(n//2 + 1)
",O(1)
"class Solution(object):
    def alienOrder(self, words):
        result, in_degree, out_degree = [], {}, {}
        zero_in_degree_queue = collections.deque()
        nodes = set()
        for word in words:
            for c in word:
                nodes.add(c)

        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], in_degree, out_degree)

        for node in nodes:
            if node not in in_degree:
                zero_in_degree_queue.append(node)

        while zero_in_degree_queue:
            precedence = zero_in_degree_queue.popleft()
            result.append(precedence)

            if precedence in out_degree:
                for c in out_degree[precedence]:
                    in_degree[c].discard(precedence)
                    if not in_degree[c]:
                        zero_in_degree_queue.append(c)

                del out_degree[precedence]

        if out_degree:
            return """"

        return """".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
        str_len = min(len(word1), len(word2))
        for i in range(str_len):
            if word1[i] != word2[i]:
                if word2[i] not in in_degree:
                    in_degree[word2[i]] = set()
                if word1[i] not in out_degree:
                    out_degree[word1[i]] = set()
                in_degree[word2[i]].add(word1[i])
                out_degree[word1[i]].add(word2[i])
                break",O(n)
"import itertools

element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np
"import os
import sys
from io import BytesIO, IOBase
import threading
from bisect import bisect_right
from math import gcd,log
from collections import Counter,defaultdict,deque
from pprint import pprint
from itertools import permutations
from bisect import bisect_right
from random import randint as rti

n,m=0,0

def main(tnum):
    global n,m,d
    n,m,k=map(int,input().split())
    if k%2:
        ans=[[-1]*m for i in range(n)]
        for li in ans:
            print(*li)
        return
    cost=dict()
    dp=[[float('inf')]*m for i in range(n)]
    crr=[]
    rrr=[]
    for i in range(n):
        arr=list(map(int,input().split()))
        for j in range(m-1):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i][j+1]=min(dp[i][j+1],arr[j])
        crr.append(arr)

    for i in range(n-1):
        arr=list(map(int,input().split()))
        for j in range(m):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i+1][j]=min(dp[i+1][j],arr[j])

        rrr.append(arr)

    for i in range(1,k//2):
        ndp=[[float('inf')]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                x,y=i,j
                if x>0:
                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])
                if x<n-1:
                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])
                if y>0:
                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])
                if y<m-1:
                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])
        dp=ndp
    for li in dp:
        li=[2*x for x in li]
        print(*li)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":

    for _ in range(1):
        main(_+1)
",O(n ^ 3)
"import collections



class Solution(object):
    def canBeEqual(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

def datainput():
    return map(int, input().split())
def listinput():
    return list(map(int, input().split()))

n=int(input())
ans={}
while n:
    n-=1
    a,x =datainput()
    ans[a]=x
m=int(input())
while m:
    m-=1
    b,y =datainput()
    if b in ans:
        if ans[b] < y:
            ans[b]=y
    else:
        ans[b]=y
print(sum(list(ans.values())))
",O(nlogn)
"from itertools import combinations as cmb
n ,l ,r ,x = map(int , input().split())
*a , = map(int ,input().split())
b = []
a.sort()
for i in range(2 ,n+1):
    b.extend(cmb(a ,i))
ans = 0
for i in b:

    if(sum(i) >= l and sum(i) <= r):
        if(i[-1]-i[0] >= x):

            ans+=1

print(ans)",np
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",O(1)
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = 2*p[n-1] % M

    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1

    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M

    return bc

def solve():

    dp = [[0 for _ in range(N)] for _ in range(N)]
    dp[0][0]=1

    for i in range(1,N):
        for k in range(1,i):
            for j in range(1,i):
                dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][i] = POW[i]

    res=0
    for j in range(0,N):
        res = (res + dp[N-1][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())

    BC = binomials(N)
    POW = powers(N)

    print(solve())

f.close()",O(n ^ 3)
"import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in zip(sorted_x, sorted_x[1:])] + [0])",O(nlogn)
"class Solution2(object):
    def trap(self, A):
        result = 0
        top = 0
        for i in range(len(A)):
            if A[top] < A[i]:
                top = i

        second_top = 0
        for i in range(top):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        second_top = len(A) - 1
        for i in reversed(range(top, len(A))):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        return result",O(n)
"n = int(input())

segments = []

for i, _ in enumerate(range(n)):
    a, b = map(int, input().split())
    segments.append(((a, b), i + 1))

segments.sort(key=lambda x: (x[0][0], -x[0][1]))

last_r = 0
last_index = 0

for segment, index in segments:
    if last_r >= segment[1]:
        print(index, last_index)
        break

    last_r = segment[1]
    last_index = index
else:
    print(-1, -1)",O(nlogn)
"
import collections



class Solution(object):
    def digitCount(self, num):
        cnt = collections.Counter(num)
        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))
",O(n)
"n, m, k, l = map(int, input().split())
if k + l > n:
    print(-1)
else:
    x = (k + l) // m + (1 if (k + l) % m != 0 else 0)
    if x * m > n:
        print(-1)
    else:
        print(x)
",O(1)
"class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class PrefixTree:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.endOfWord

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
",O(n)
"class Solution(object):
    def transformArray(self, arr):
        def is_changable(arr):
            return any(arr[i-1] > arr[i] < arr[i+1] or 
                       arr[i-1] < arr[i] > arr[i+1]
                       for i in range(1, len(arr)-1))
        
        while is_changable(arr):
            new_arr = arr[:]
            for i in range(1, len(arr)-1):
                new_arr[i] += arr[i-1] > arr[i] < arr[i+1]
                new_arr[i] -= arr[i-1] < arr[i] > arr[i+1]
            arr = new_arr
        return arr",O(n ^ 2)
"from collections import Counter
import sys
readline = sys.stdin.readline

def check(A):
    CA = Counter(A)
    if CA[0] >= 2:
        return False
    cnt = 0
    for k, v in CA.items():
        if v > 2:
            return False
        if v == 2 and CA[k-1] >= 1:
            return False
        if v >= 2:
            cnt += 1
    if cnt >= 2:
        return False
    L = len(A)
    if (sum(A) - L*(L-1)//2) % 2 == 0:
        return False
    return True

N = int(readline())
if check(list(map(int, readline().split()))):
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result",O(n)
"a,b=map(int,input().split())
ans=0
while a and b:
  ans+=a//b
  a,b=b,a%b
print(ans)",O(1)
"def make_number(b,chars):
	if len(chars) == 0:
		return """"
	target = chars[0]
	for i in chars:
		if int(b[0]) <= int(i):
			break
		target = i
	chars.remove(target)
	return target + """".join(chars[::-1])

def find_number(b,chars):
	backup_chars = list(chars)
	if len(b) == 1:
		return chars[0]
	elif b[0] in chars:
		chars.remove(b[0])
		num = b[0] + find_number(b[1:],chars)
		if min(num,b) == b and b != num:
			return make_number(b,backup_chars)
		else:
			return num

	else:
		return make_number(b,backup_chars)

a,b = str(input()), str(input())
chars = [i for i in a]
chars.sort()

if len(a) < len(b):
	print("""".join(chars[::-1]))
else:
	print(find_number(b,chars))",O(n ^ 3)
"class Solution(object):
    def copyRandomList(self, head):
        current = head
        while current:
            copied = Node(current.val)
            copied.next = current.__next__
            current.next = copied
            current = copied.__next__

        current = head
        while current:
            if current.random:
                current.next.random = current.random.__next__
            current = current.next.__next__

        dummy = Node(0)
        copied_current, current = dummy, head
        while current:
            copied_current.next = current.__next__
            current.next = current.next.__next__
            copied_current, current = copied_current.__next__, current.__next__
        return dummy.__next__",O(n)
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))
",O(n)
"n = int(input())
T = input().split(' ')
for i in range(n):
    T[i]=int(T[i])
L=[]
M=[]
t=0
ip=0
IP=[]
for i in range(n):
    if T[i]>=2:
        L.append(i+1)
        M.append(T[i])
        t+=T[i]
    else:
        ip+=1
        IP.append(i+1)
if t-(2*len(L)-2)<ip:
    print(""NO"")
else:
    for i in range(1, len(L)-1):
        M[i]-=2
    if len(L)>=2:
        M[0]-=1
        M[-1]-=1
    print(""YES"",end=' ')
    if ip==0:
        print(len(L)-1)
    elif ip==1:
        print(len(L))
    else:
        print(len(L)+1)
    print(len(L)-1+ip)
    if ip>=1:
        print(IP[0], end=' ')
        print(L[0])
        M[0]-=1
    if ip>=2:
        print(IP[-1], end=' ')
        print(L[-1])
        M[-1]-=1
    k=1
    ind=0
    while k < ip-1:
        if M[ind]==0:
            ind+=1
        else:
            print(IP[k], end=' ')
            print(L[ind])
            M[ind]-=1
            k+=1
    for i in range(len(L)-1):
        print(L[i], end=' ')
        print(L[i+1])
",O(n)
"import random



class Solution2(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(curr):
            if not curr:
                result.append(0)
                return
            dfs(curr.left)
            left = result[-1]
            dfs(curr.right)
            right = result[-1]
            result.append(left+right+1 if left == right != -1 else -1)

        result = []
        dfs(root)
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1",O(n)
"n, s = map(int,input().split())

def digs(k):
	r = k
	while k:
		r -= k % 10
		k //= 10
	return r
x = s + 19*9
while digs(x-1) >= s:
	x -= 1
print(max(n - x + 1, 0))",O(logn)
"import collections


class Solution(object):
    def characterReplacement(self, s, k):
        result, max_count = 0, 0
        count = collections.Counter()
        for i in range(len(s)):
            count[s[i]] += 1
            max_count = max(max_count, count[s[i]])
            if result - max_count >= k:
                count[s[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]
        curMin, curMax = 1, 1

        for num in nums:
            tmp = curMax * num
            curMax = max(num * curMax, num * curMin, num)
            curMin = min(tmp, num * curMin, num)
            res = max(res, curMax)
        return res
",O(n)
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def hnbhai(t):
    n=sb()
    p=[]
    for i in range(n):
        p.append(sflo())

    dp=[0]*(1<<n)
    dp[1]=1
    for i in range(2,1<<n):
        for j in range(1,n):
            for k in range(0,j):
                if (i>>j)&1 and (i>>k)&1:
                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])

    print(dp[-1])
for _ in range(1):
    hnbhai(_+1)
",np
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"import sys
import logging
logging.root.setLevel(level=logging.DEBUG)
import re

s = sys.stdin.readline().strip()

from collections import defaultdict
substr = defaultdict(int)
for left in range(len(s)):
    for right in range(left+1,len(s)+1):
        substr[s[left:right]] += 1
max_len = 0
for segment,times in substr.items():
    if times >= 2:
        max_len = max(max_len,len(segment))
print(max_len)
",O(n ^ 3)
"class Solution(object):
    def maxArea(self, height):
        max_area, i, j = 0, 0, len(height) - 1
        while i < j:
            max_area = max(max_area, min(height[i], height[j]) * (j - i))
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area",O(n)
"import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)
        return result

",O(n)
"dp=[]
n,k=map(int,input().split())
for _ in range(n):
    p,t=map(int,input().split())
    dp.append((p,-t))
dp.sort(reverse=True)
print(dp.count(dp[k-1]))",O(nlogn)
"class Solution2(object):
    def findSubtreeSizes(self, parent, s):
        def dfs(u):
            lookup[ord(s[u])-ord('a')].append(u)
            for v in adj[u]:
                dfs(v)
                result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
            lookup[ord(s[u])-ord('a')].pop()
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        lookup = [[] for _ in range(26)]
        result = [1]*len(parent)
        dfs(0)
        return result",O(n)
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)

maxdiff=0

maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])

    maxdiff=max(maxdiff,diff)

print(slsum+maxdiff)",O(n)
"n=input()
i=0
while(True):
    if (n-9*10**i*(i+1))<=0:
        break
    n-=9*10**i*(i+1)
    i+=1

a=n/(i+1)
b=n%(i+1)
if(b!=0):
    print(str(10**i+a)[b-1])
else:
    print(str(10**i+a-1)[-1])
",O(logn)
"mod = 1000000007
eps = 10**-9

def main():
    import sys
    input = sys.stdin.readline

    N, M, K = map(int, input().split())
    P = [""""]
    for i in range(N):
        p = input().rstrip(""\n"")
        P.append(p)
    p2i = {p: i for i, p in enumerate(P)}
    adj = [set() for _ in range(N+1)]
    for i in range(M):
        s, mt = input().split()
        mt = int(mt)
        ok = 0
        for k in range(1 << K):
            s_new = [""_""] * K
            for j in range(K):
                if k >> j & 1:
                    s_new[j] = s[j]
            s_new = """".join(s_new)
            if s_new != P[mt]:
                if s_new in p2i:
                    adj[mt].add(p2i[s_new])
            else:
                ok = 1
        if not ok:
            print(""NO"")
            exit()
    in_num = [0] * (N+1)
    for v in range(1, N+1):
        for u in adj[v]:
            in_num[u] += 1
    st = []
    for v in range(1, N+1):
        if in_num[v] == 0:
            st.append(v)
    ans = []
    while st:
        v = st.pop()
        ans.append(v)
        for u in adj[v]:
            in_num[u] -= 1
            if in_num[u] == 0:
                st.append(u)
    if len(ans) == N:
        print(""YES"")
        print(*ans)
    else:
        print(""NO"")

if __name__ == '__main__':
    main()
",np
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)
",O(n)
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0

        l, r = 0, len(height) - 1
        leftMax, rightMax = height[l], height[r]
        res = 0
        while l < r:
            if leftMax < rightMax:
                l += 1
                leftMax = max(leftMax, height[l])
                res += leftMax - height[l]
            else:
                r -= 1
                rightMax = max(rightMax, height[r])
                res += rightMax - height[r]
        return res
",O(n)
"import sys

T = int(sys.stdin.readline().strip())
for t in range (0, T):
    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().strip().split()))
    a.sort()
    print(min([len(a)-2, a[-2]-1]))",O(nlogn)
"class Solution(object):
    def countDistinct(self, nums, k, p):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for i in range(len(nums)):
            cnt = 0
            curr = trie
            for j in range(i, len(nums)):
                cnt += (nums[j]%p == 0)
                if cnt > k:
                    break
                if nums[j] not in curr:
                    result += 1
                curr = curr[nums[j]]
        return result",O(n ^ 2)
"from sys import stdin,stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    a.sort()
    s = set()
    for v in a:
        if (v % k != 0) or v // k not in s:
            s.add(v)
    print(len(s))",O(nlogn)
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",O(nlogn)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n, res = len(nums), nums[0]
        prefix = suffix = 0

        for i in range(n):
            prefix = nums[i] * (prefix or 1)
            suffix = nums[n - 1 - i] * (suffix or 1)
            res = max(res, max(prefix, suffix))
        return res
",O(n)
"class Solution(object):
    def waysToMakeFair(self, nums):
        prefix = [0]*2
        suffix = [sum(nums[i] for i in range(k, len(nums), 2)) for k in range(2)]
        result = 0
        for i, num in enumerate(nums):
            suffix[i%2] -= num
            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])
            prefix[i%2] += num
        return result",O(n)
"from operator import xor

r = list(map(int, input().split()))

ms = xor(r[0], r[1])

max = 0
sum = 1

while ms > 0:
    ms >>= 1
    max += sum
    sum <<= 1

print(max)
",O(logn)
"def main():
    buf = input()
    buflist = buf.split()
    hand = buflist;
    t = []
    for i in range(3):
        t.append([])
        for j in range(9):
            t[i].append(0)
    for x in hand:
        idx = 0
        if x[1] == 'm':
            idx = 0
        elif x[1] == 'p':
            idx = 1
        elif x[1] == 's':
            idx = 2
        t[idx][int(x[0])-1] += 1
    max_cons = 0
    max_mult = 0
    for i in range(3):
        cons = [0, 0, 0]
        for j in range(9):
            cons[0] = cons[1]
            cons[1] = cons[2]
            if t[i][j] > 0:
                cons[2] = 1
            else:
                cons[2] = 0
            max_cons = max(sum(cons), max_cons)
            max_mult = max(max_mult, t[i][j])
    print(3 - max(max_cons, max_mult))

if __name__ == '__main__':
    main()
",O(n)
"class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))",O(n)
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)
",O(n ^ 2)
"import math
s1 = input()
s2 = input()
x = 0
y = 0
p = 0
for i in range(len(s1)):
    if s1[i] == '+': x+=1
    elif s1[i] == '-': y+=1
    if s2[i] == '+': x-=1
    elif s2[i] == '-': y-=1
    else: p+=1
if x<0 or y<0:
    print(float(0))
else:
    q = math.factorial(x+y)/(math.factorial(x)*math.factorial(y))
    r = q/math.pow(2,p)
    print(r)
",np
"import sys
from array import array

def readline() -> str: return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353
dp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)]
dp[0][0][1] = dp[3][0][1] = 1
dp[1][0][2] = dp[2][0][2] = 1

for i in range(n-1):
    for j in range(k+1):
        for sbit in range(4):
            for tbit in range(4):
                add = (
                    1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else
                    (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0)
                    + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0)
                )
                dp[tbit][i+1][j+add] += dp[sbit][i][j]
                if dp[tbit][i+1][j+add] >= mod:
                    dp[tbit][i+1][j+add] -= mod

ans = sum(dp[bit][-1][k] for bit in range(4)) % mod
print(ans)
",np
"n = int(input())
print((n//2)+1)",O(1)
"a,b = list(map(int, input().split()))

x = a ^ b

ans = 1
while x > 0:

	x //= 2
	ans *= 2

print(ans -1)",O(logn)
"q = int(input())
for _ in range(q):
    n, k = map(int, input().split())
    s = input()
    ans = k
    sample = ""RGB""
    for i in range(n - k + 1):
        cnt = 0
        x = 0
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3

        ans = min(ans, cnt)
        cnt = 0
        x = 1
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)

        cnt = 0
        x = 2
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)

    print(ans)",O(n ^ 2)
"max_ = 10**18
arr  = [0, 1]
arr2 = [0, 3]
while arr[-1] < max_:
    arr.append(arr[-1]*4)
    arr2.append(arr2[-1]*2+1)

for i in range(1, len(arr)):
    arr[i] += arr[i-1]

def solve(n, k):
    if n==2 and k==3:
        return 'NO'
    if n==2 and k==4:
        return 'YES 0'
    if n+1<=len(arr) and k > arr[n]:
         return 'NO'

    i=0
    while k >= arr[i+1]:
        i+=1
    if k-arr[i] > arr2[i]:
        i+=1
    return 'YES ' +str(n-i)

for _ in range(int(input())):
    n, k = map(int, input().split())
    print(solve(n, k))",O(logn)
"n = int(input())
if n == 1:
    print(1)
else:
    adj = [[] for i in range(n+10)]
    s = input().split()
    for i in range(2,n+1):
        pi = int(s[i-2])
        adj[i].append(pi)
        adj[pi].append(i)

    num = 1
    curr = [1]
    nextcurr = []
    disco = [1]
    visited = {1:True}
    while num < n:
        for v in curr:
            for w in adj[v]:
                if w not in visited:
                    nextcurr.append(w)
                    visited[w] = True
                    disco.append(w)
                    num += 1
        curr = nextcurr
        nextcurr = []

    nl = {}
    nlvals = {}
    for v in disco[::-1]:
        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)
        nlvals[nl[v]] = nlvals.get(nl[v],0)+1
    colors = {}
    leaves = nlvals[1]
    colors[1] = leaves
    for c in range(2, leaves+1):
        colors[c] = colors[c-1] + nlvals.get(c,0)

    ans = """"
    j = 1
    for i in range(1, n+1):
        while colors[j] < i:
            j += 1
        ans += str(j) + ' '
    print(ans.strip())
",O(n)
"n, m, k = map(int,input().split())
line = [int(x) for x in input().split()]
line.sort(reverse = True)
count = 0
if k >=m:
    print(count)
    exit(0)
for i in range(n):
    k += line[i]-1
    count += 1
    if k >= m:
        print(count)
        exit(0)
print(-1)",O(nlogn)
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
from collections import defaultdict as dft

n,m,k=map(int,input().split())
dct={}
global case
case=0
iput=[]
for i in range(n):
    word=input()
    dct[word]=i+1
    iput.append(word)
d=[[] for i in range(n+1)]
size=[0]*(n+1)
for _ in range(m):

    word,idx=input().split()
    idx=int(idx)
    temp=1
    w=iput[idx-1]

    for x in range(k):
        if w[x]!='_' and w[x]!=word[x]:
            temp=0
            print(""NO"")
            exit()
            break

    res=[]
    for i in range(1<<k):
        s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])

        if s in dct:
            j=dct[s]
            if j!=idx:
                d[idx].append(j)
                size[j]+=1

st=[nd  for nd in range(1,n+1) if size[nd]==0]

for i in st:

    for j in d[i]:
        size[j]-=1
        if size[j]==0:
            st.append(j)

if len(st)==n:
    print(""YES"")
    print(*st)
else:
    print(""NO"")
",np
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

maxconseq = [[0 for j in range(k)] for i in range(n+1)]
for i in range(n):
    if s[i]==ord('?'):
        for j in range(k):
            maxconseq[i][j] = maxconseq[i-1][j] + 1
    else:
        j = s[i]-97
        maxconseq[i][j] = maxconseq[i-1][j] + 1

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        for i in range(n)[::-1]:
            if maxconseq[i][j]>=needed:
                effect[j][i-needed+1] = i+1
            effect[j][i] = min(effect[j][i], effect[j][i+1])

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"class Solution(object):
    def peakIndexInMountainArray(self, arr):
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1]:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result",O(nlogn)
"def main():
  N, M = map(int, input().split())
  L = [tuple(map(int, input().split())) for _ in range(N)]
  maxi = max(max(t) for t in L)+1
  mini, res = max((min(t), i) for i, t in enumerate(L))
  res = res, res
  BITMASK = (1 << M)
  while True:
    mid = (maxi+mini)//2

    if mid == mini:
      break
    masks = [None]*BITMASK
    for i, t in enumerate(L):
      tmask = 0
      for v in t:
        tmask *= 2
        if v >= mid:
          tmask += 1
      if masks[tmask] is not None:
        continue
      masks[tmask] = i
      for k in range(BITMASK):
        if masks[k] is not None and k | tmask == BITMASK-1:
          res = masks[k], i
          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))
          break
      else:
        continue
      break
    else:
      maxi = mid

  print(res[0]+1, res[1]+1)

main()
",np
"import heapq
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    h = []
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            heapq.heappush(h, (i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not h:
            ans = ""NO""
            break
        j, k0, d0 = heapq.heappop(h)
        e.append((j, i))
        if k0 + 1 < k:
            heapq.heappush(h, (j, k0 + 1, d0))
        if d0 - 1 > 0:
            heapq.heappush(h, (i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",O(n ^ 2)
"class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False",O(n)
"def maxXORInRange(L, R):
    LXR = L ^ R

    msbPos = 0
    while (LXR):
        msbPos += 1
        LXR >>= 1

    maxXOR, two = 0, 1

    while (msbPos):
        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR

L, R = map(int, input().split())
print(maxXORInRange(L, R))
",O(logn)
"class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack",O(n)
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))
",O(n)
"import random


class Solution(object):

    def __init__(self, nums):
        self.__nums = nums


    def reset(self):
        return self.__nums


    def shuffle(self):
        nums = list(self.__nums)
        for i in range(len(nums)):
            j = random.randint(i, len(nums)-1)
            nums[i], nums[j] = nums[j], nums[i]
        return nums",O(n)
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N-1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])
",O(n ^ 3)
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",O(n ^ 2)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"from os import path
from io import BytesIO, IOBase
import sys
from heapq import heappush,heappop
from functools import cmp_to_key as ctk
from collections import deque,Counter,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
mod=1000000007

inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('0')

file = 1
def ceil(a,b):
    return (a+b-1)//b

def solve():

    l,r = mi()
    s1 = bin(l)[2:]
    s2 = bin(r)[2:]
    if len(s1) != len(s2):
      print((1<<len(s2))-1)
      return

    x = 0
    for i in range(62,-1,-1):
      if ((l>>i)&1)^((r>>i)&1):
        x +=(1<<(i+1))
        x -=1
        break
    print(x)

if __name__ ==""__main__"":

    if(file):

       if path.exists('input.txt'):
           sys.stdin=open('input.txt', 'r')
           sys.stdout=open('output.txt','w')
       else:
           input=sys.stdin.readline
    solve()
",O(logn)
"class Solution(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result += left
        return result",O(n)
"n, k = [int(i) for i in input().split()]
p = [int(i) for i in input().split()]
ans = [-1] * (max(p) + 1)
ans[0] = 0
for i in range(n):
	if ans[p[i]] < 0:
		position = p[i] - k + 1
		for j in range(max(0,p[i] - k + 1), p[i] + 1):
			if ans[j] < 0:
				position = j
				break
		j = max(0, position - 1)
		key = ans[j]
		count = 0
		while j >= 0:
			if ans[j] != key:
				position1 = j + 1
				break
			j -= 1
			count += 1
		if count + p[i] + 1 - position > k:
			key = position
		for j in range(position, p[i] + 1):
			ans[j] = key

for i in range(n):
	if i != len(p) - 1:
		wk1 = "" ""
	else:
		wk1 = ""\n""
	print(ans[p[i]], end = wk1)
",O(n ^ 2)
"n=int(input())
arr=[int(x) for x in input().split()]
pos=dict()
if(n==1):print(""B"")
else:
    for i in range(n):
        pos[arr[i]]=i
    ans=[""Q""]*n

    ans[pos[1]]=""A""
    ans[pos[n]]=""B""
    for i in range(n-1,0,-1):
        flag=0
        p=pos[i]
        j=1
        while(p+j*i<n):
            if(ans[p+j*i]==""B""):
                flag=1
                ans[pos[i]]=""A""
                break
            j+=1
        if(flag==0):
            j=1
            while(p-j*i>=0):
                if(ans[p-j*i]=='B'):
                    flag=1
                    ans[pos[i]]=""A""
                    break
                j+=1
        if(flag==0):ans[pos[i]]=""B""
    print("""".join(ans))
",O(nlogn)
"n,k = map(int, input().split())

l = 0
r = n
while True:
    m = int((l+r)/2)
    S = int(((n-m)**2 + n - 3 * m)/2)
    if S == k:
        print(m)
        break
    elif S < k:
        r = m
    else:
        l = m",O(logn)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",O(n ^ 2)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(logn)
"s = input().split(' ')
s1 = s[0]
s2 = s[1]
res = s1[0]
flag = 0
for i in range(1, len(s1)):
    if(s1[i]>=s2[0]):
        res+=s2[0]
        flag = 1
        break
    else:
        res+=s1[i]
if(flag == 0):
    res+=s2[0]
print(res)
",O(n)
"class Solution(object):
    def longestMountain(self, A):
        result, up_len, down_len = 0, 0, 0
        for i in range(1, len(A)):
            if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]:
                up_len, down_len = 0, 0
            up_len += A[i-1] < A[i]
            down_len += A[i-1] > A[i]
            if up_len and down_len:
                result = max(result, up_len+down_len+1)
        return result",O(n)
"import sys
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    print(2*(n*(n-1))+1)
    return

while 1:
    try: main()
    except EOFError: break",O(1)
"class Solution(object):
    def findMaxK(self, nums):
        lookup = set(nums)
        return max([x for x in lookup if x > 0 and -x in lookup] or [-1])",O(n)
"class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result",O(n)
"class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result",O(n)
"class Solution(object):
    def missingElement(self, nums, k):
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k > missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))",O(logn)
"class Solution(object):
    def smallestNumber(self, pattern):
        result = []
        for i in range(len(pattern)+1):
            if not (i == len(pattern) or pattern[i] == 'I'):
                continue
            for x in reversed(list(range(len(result)+1, (i+1)+1))):
                result.append(x)
        return """".join(map(str, result))",O(n)
"class Solution(object):
    def countValidWords(self, sentence):
        result = token = hyphen = 0
        for i in range(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in ""!.,"" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result",O(n)
"n,k=map(int,input().split())
p=list(map(int,input().split()))

arr=[[] for i in range(256)]
ans=[]
for i in p:
    j=i
    if len(arr[i])==0:
        c=0
        while c<k and j>=0:
            if len(arr[j])+c>k:
                break

            if len(arr[j])!=0:
                arr[i].extend(arr[j])
                break
            arr[j]=arr[i]
            arr[j].append(j)
            j-=1
            c+=1
        arr[i].sort()
    ans.append(arr[i][0])
print(*ans)
",O(n ^ 2)
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"class Solution(object):
    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):
        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefix = [0]*(len(NUMS)+1)
        for i in range(len(NUMS)):
            prefix[i+1] += prefix[i]+NUMS[i]
    
        def day(date):
            return prefix[int(date[:2])-1]+int(date[3:])

        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)",O(1)
"x,k = map(int,input().split())
if(x==0):
    print(0)
    exit(0)
m = 10**9+7
p = pow(2,k+1,m)
q = pow(2,k,m)
a = (x*p-q+1)%m
print(a)
",O(logn)
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = bin(r)[2:], bin(l)[2:]
binl = '0' * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        binl = '1' * len(binl[i:])
        break

print(int(binl, 2))
",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        def dfs(root, voyage, i, result):
            if not root:
                return True
            if root.val != voyage[i[0]]:
                return False
            i[0] += 1
            if root.left and root.left.val != voyage[i[0]]:
                result.append(root.val)
                return dfs(root.right, voyage, i, result) and \
                       dfs(root.left, voyage, i, result)
            return dfs(root.left, voyage, i, result) and \
                   dfs(root.right, voyage, i, result)
        
        result = []
        return result if dfs(root, voyage, [0], result) else [-1]",O(n)
"def ints():
 return list(map(int,input().split()))
n,k=ints()
a,t=ints(),ints()
ans=sum(a[ii] for ii in range(n) if t[ii])
bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]
ll=0
rr=k
tmp=sws=sum(bb[:k])
while rr<n:
 sws-=bb[ll]
 sws+=bb[rr]
 ll+=1
 rr+=1
 tmp=max(tmp,sws)
ans+=tmp
print(ans)
",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",O(n ^ 3)
"n,k=map(int, input().split())
a = list(map(int, input().split()))

c = a[-1] - a[0]

d = [a[i]-a[i-1] for i in range(1, n)]
d = sorted(d)[::-1]
c -= sum(d[:k-1])
print(c)
",O(nlogn)
"from math import sqrt
n, k = map(int, input().split())
a = 1
b = -1 * (2*n + 3)
c = n * (n + 1) - 2 * k

res = (-1 * b) - sqrt((b * b) - 4 * a * c)
res = res / 2
res = int(res)
print(res)
",O(logn)
"def getBW(x1, y1, x2, y2):
    if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1:
        return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]
    else:
        if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1):
            return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2]
        else:
            return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]

cs = int(input())

for c in range(cs):
    m, n = map(int, input().split())
    BW = getBW(1, 1, n, m)
    x1, y1, x2, y2 = map(int, input().split())

    x3, y3, x4, y4 = map(int, input().split())

    BW1 = getBW(x1, y1, x2, y2)
    BW2 = getBW(x3, y3, x4, y4)
    BWO =[0, 0]

    xo1 = max(x1, x3)
    xo2 = min(x2, x4)
    yo1 = max(y1, y3)
    yo2 = min(y2, y4)
    if (xo2 >= xo1 and yo2 >= yo1):
        BWO = getBW(xo1, yo1, xo2, yo2)

    B = BW[0] - BW1[0] + BW2[1] + BWO[0]
    W = BW[1] + BW1[0] - BW2[1] - BWO[0]

    print(W, end = "" "")
    print(B)",O(1)
"from itertools import *
n, s = map(int, input().split())
times = []
for i in range(n):
    h, m = map(int, input().split())
    times.append((h * 60 + m))

times.sort()
for t in count():
    if all(abs(u - t) > s for u in times):
        print(*divmod(t, 60))
        break
",O(n)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
if l[0]!=0 or r[n-1]!=0:
    print(""NO"")
    exit(0)
s=[(l[i]+r[i]) for i in range(n)]
m=max(s)+1
k=[]
for i in s:
    k.append(m-i)
l1=[]
r1=[]

for i in range(n):
    c=0
    d=0
    for j in range(0,i):
        if k[j]>k[i]:
            c+=1
    l1.append(c)
    for j in range(i+1,n):
        if k[j]>k[i]:
            d+=1
    r1.append(d)
if l1!=l or r1!=r:
    print(""NO"")
else:
    print(""YES"")
    print(*k)
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n, k = map(int, input().split())
b = []
d=dict()
e=dict()
for i in range(n):
    a, t = map(int, input().split())
    b.append([a,t,i+1])
b.sort(key= lambda x:x[1])
ans = 0
j = 0
curr = 1
currsum = 0
l=0
while(curr<=n):
    if curr-1 in d.keys():
        currsum-=d[curr-1]
        l-=e[curr-1]

    p=0
    while (j < n):
        if b[j][0] >= curr:
            currsum += b[j][1]
            if b[j][0] in d.keys():
                d[b[j][0]]+=b[j][1]
                e[b[j][0]]+=1
            else:
                d[b[j][0]] = b[j][1]
                e[b[j][0]] = 1

            l+=1
        if l==curr:
            j+=1
            break
        j+=1

    if j<=n and l==curr and currsum<=k:
        ans+=1
    else:
        break
    curr+=1
c=[]
j=0
l=0
while(j<n):
    if l==ans:
        break
    if b[j][0] >= ans:
        c.append(b[j][2])
        l+=1
    j+=1

print(ans)
print(ans)
print(*c)
",O(nlogn)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = {None: None}

        cur = head
        while cur:
            copy = Node(cur.val)
            oldToCopy[cur] = copy
            cur = cur.next
        cur = head
        while cur:
            copy = oldToCopy[cur]
            copy.next = oldToCopy[cur.next]
            copy.random = oldToCopy[cur.random]
            cur = cur.next
        return oldToCopy[head]
",O(n)
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        second = slow.next
        prev = slow.next = None
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp

        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1
            first, second = tmp1, tmp2
",O(n)
"from string import digits
from collections import Counter
a = input()
b = input()
ca = Counter(a)
l = list()
if len(b) > len(a):
    for i in digits[::-1]:
        if i in ca:
            l.extend(i * ca[i])
else:
    def asd(i, s):
        if i == len(b):
            return True
        if s:
            for j in digits[::-1]:
                if j in ca and ca[j] > 0:
                    l.extend(j * ca[j])
            return True
        else:
            for j in digits[:int(b[i])+1][::-1]:
                if j in ca and ca[j] > 0:
                    ca[j] -= 1
                    l.append(j)
                    if asd(i + 1, j != b[i]):
                        return True
                    ca[j] += 1
                    l.pop()
            return False
    asd(0, False)
print("""".join(l))
",O(n ^ 3)
"class Solution2(object):
    def mostProfitablePath(self, edges, bob, amount):
        def dfs(u, ah):
            lookup[u] = True
            result = 0 if len(adj[u])+(u == 0) == 1 else float(""-inf"")
            bh = 0 if u == bob else float(""inf"")
            for v in adj[u]:
                if lookup[v]:
                    continue
                r, h = dfs(v, ah+1)
                result = max(result, r)
                bh = min(bh, h)
            if ah == bh:
                result += amount[u]//2
            elif ah < bh:
                result += amount[u]
            return result, bh+1

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(0, 0)[0]",O(n)
"MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")
",O(n)
"class Solution(object):
    def canChoose(self, groups, nums):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(start, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True",O(n)
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",O(n)
"import random

n = int(input())
v = []
a = []
for i in range(n):
    a.append(i)

for _ in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, x*x+y*y])

while 1>0:
    x = 0
    y = 0
    ans = [0]*n
    random.shuffle(a)
    for i in range(n):
        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:
            x += v[a[i]][0]
            y += v[a[i]][1]
            ans[a[i]] = 1
        else:
            x -= v[a[i]][0]
            y -= v[a[i]][1]
            ans[a[i]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break
",O(nlogn)
"class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))",O(n)
"import sys

class APaintTheNumbers:
    def solve(self):
        n = int(input())
        a = [int(_) for _ in input().split()]
        a.sort()
        ans = 0
        done = [0] * n
        for i in range(n):
            if done[i]: continue
            ans += 1
            for j in range(i, n):
                if done[j]: continue
                if a[j] % a[i] == 0:
                    done[j] = 1

        print(ans)

solver = APaintTheNumbers()
input = sys.stdin.readline

solver.solve()
",O(n ^ 2)
"R,G,B = map(int,input().split())
r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))
r.sort()
g.sort()
b.sort()
dp = []
for i in range(R+1):
	d = []
	for j in range(G+1):
		d.append([0]*(B+1))
	dp.append(d)
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i+j+k<2:
				continue
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",O(n ^ 3)
"n=int(input())
s=input()
if ""0"" in s:
    if ""1"" in s:
        print(""1""+""0""*s.count(""0""))
    else:
        print(""0"")
else:
    print(""1"")",O(n)
"class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):
        return (D - B) * (C - A) + \
               (G - E) * (H - F) - \
               max(0, (min(C, G) - max(A, E))) * \
               max(0, (min(D, H) - max(B, F)))",O(1)
"class Solution(object):
    def maxSumDivThree(self, nums):
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]",O(n)
"class Solution2(object):
    def isPowerOfFour(self, num):
        while num and not (num & 0b11):
            num >>= 2
        return (num == 1)",O(1)
"n, S = map(int, input().split())
print((S + n - 1) // n);
",O(1)
"n = int(input())
p = list(map(lambda x: int(x) - 1, input().split()))

vis = [False] * n
odd = 0
for x in range(n):
    if vis[x]:
        continue
    odd ^= 1
    while not vis[x]:
        odd ^= 1
        vis[x] = True
        x = p[x]

print('Petr' if (n + odd) % 2 == 0 else 'Um_nik')
",O(nlogn)
"n,k=map(int,input().split())
print(max(min(n,k-1)-k//2,0))",O(1)
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
res = 0
for i in range(1 << n):
	Bit = []
	for j in range(n):
		if i & (1 << j):
			Bit.append(c[j])
	if (len(Bit) >= 2) and (l<= sum(Bit) <= r) and (max(Bit) - min(Bit) >= x):
		res+= 1
print(res)",np
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = effect[j][i+4-4]

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"class Solution(object):
    def hasSameDigits(self, s):
        def check(mod):
            def decompose(x, mod): 
                cnt = 0
                while x > 1 and x%mod == 0:
                    x //= mod
                    cnt += 1
                return x, cnt

            result = cnt = 0
            curr = 1
            for i in range(len(s)-1):
                if cnt == 0:
                    result = (result+curr*(ord(s[i])-ord(s[i+1])))%mod
                x, c = decompose(len(s)-2-i, mod)
                curr = (curr*x)%mod
                cnt += c
                x, c = decompose(i+1, mod)
                curr = (curr*pow(x, mod-2, mod))%mod
                cnt -= c
            return result == 0

        return check(2) and check(5)",O(nlogn)
"import threading


class Solution(object):
    
    def __init__(self):
        self.__l = threading.Lock()
        self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
        with self.__l:
            if self.__light != roadId:
                self.__light = roadId
                turnGreen()
            crossCar()",O(1)
"s = input()
res = 0
solve = 0
for pos in range(1,len(s)):
    for i in range(len(s) - pos):
        if s[i:i+pos] in s[i+1:]:
            if solve < pos:
                solve = pos
print(solve)",O(n ^ 3)
"class Solution(object):
    def minimizeSum(self, nums):
        nums.sort()
        return min(nums[-3+i]-nums[i] for i in range(3))",O(nlogn)
"n, k = map(int, input().split())
lst = []
for i in range(n):
    a, b = map(int, input().split())
    lst.append([-a, b])
lst.sort()
print(lst.count(lst[k-1]))",O(nlogn)
"n=int(input())
m=int(input())

if n>(m+1)/2:
	print(m)
else:
	print(int(m%(2**n)))
",O(1)
"class Solution(object):
    def minSideJumps(self, obstacles):
        result, lanes = 0, set([2])
        for i in range(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in range(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result",O(n)
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",O(1)
"import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
import math

def deep(node):
    visited[node-1]=1
    if(len(d[node])==1):
        return node
    for c in d[node]:
        if(visited[c-1]!=1):
            return(deep(c))

n=int(input())
d={}
for i in range(n-1):
    u,v=map(int,input().split())
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")
",O(n)
"N, K = list(map(int, input().split()))
S = input().strip()
S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]

def check(x):
    p = [[N for i in range(N+1)] for k in range(K)]

    for k in range(K):
        keep = 0
        for i in range(N-1, -1, -1):
            keep += 1
            if S[i] != -1 and S[i] != k:
                keep = 0
            p[k][i] = p[k][i+1]
            if keep >= x:
                p[k][i] = i + x - 1

    d = [N for s in range(1<<K)]
    d [0] = -1
    for s in range(1, 1<<K):
        for k in range(K):
            if (s&(1<<k)) and (d[s^(1<<k)]<N):
                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])

    return d[(1<<K)-1] < N

l, r = 0, N//K

while l < r:
    mid = (l + r + 1) // 2
    if check(mid):
        l = mid
    else:
        r = mid - 1
print(l)
",np
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <= key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n=int(input())
l=list(map(int,input().split()))
dp=[[0 for i in range(n)]for i in range(n)]
for i in range(n):
    dp[i][i]=l[i]
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1]^dp[i+1][j])
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1],dp[i+1][j])
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",O(n ^ 2)
"import sys
input=sys.stdin.readline
n,m,k=map(int,input().strip().split("" ""))

lr=[]
for i in range(n):
	lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001])
ud=[[100000001]*m]
for i in range(n-1):
	ud.append(list(map(int,input().strip().split("" ""))))
ud.append([100000001]*m)
o=[[1000000001]*(m+2)]
from copy import deepcopy
if k%2:
	for i in range(n):
		sys.stdout.write("" "".join([""-1""]*m)+""\n"")
	sys.exit()
for _ in range(n):
	oo=[100000001]
	for _ in range(m):
		oo.append(0)
	oo.append(100000001)
	o.append(oo)
o.append([100000001]*(m+2))
for _ in range(k//2):
	oo=deepcopy(o)
	for i in range(1,n+1):
		for j in range(1,m+1):
			oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])
	o=deepcopy(oo)
for i in o[1:n+1]:
	sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")
",O(n ^ 3)
"from itertools import combinations

n, l, r, x = map(int, input().split())
a = list(map(int, input().split()))

arr = []

for i in range(2, n+1):
    ar = combinations(a, i)
    for j in ar:
        arr += [(list(j))]

count = 0
for i in arr:
    dif = max(i) - min(i)
    total = sum(i)
    if dif >= x and (total >= l and total <= r):
        count +=1

print(count)
",np
"n=int(input())
l=sorted(list(map(int,raw_input().split())))
def f():
    global n
    dou=False
    for k in range(1,n):
        if l[k]==l[k-1]:
            if dou or l[k]==0 or (l[k]==l[k-2] and n!=2) or l[k]==l[k-2]+1:
                return False
            else:
                dou=True
    return (sum(l)-(n*(n-1))//2)%2
if f():
    print(""sjfnb"")
else:
    print(""cslnb"")
",O(nlogn)
"print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)
",O(logn)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp, n, m):
  if remain == 0:
    return 0

  key = (node + remain * n * m)
  mem = dp[key]
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1,
            adj, dp, n, m) + x[1], adj[node]))
  dp[key] = ans
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp, n, m) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n,m,a,b = map(int,input().split())
if n%m!=0:
    mn = n//m * m
    mx = n//m * m + m
    print(min(((n - mn) * b),((mx - n) * a)))
else:print(0)",O(n)
"from sys import stdin, stdout

s = input()

s = s.split(' ')

M = [0]*9
P = [0]*9
S = [0]*9

for pile in s:
    pile = list(pile)

    num = int(pile[0])
    tile = pile[1]

    if tile=='s':
        S[num-1] += 1
    elif tile=='p':
        P[num-1] += 1
    elif tile=='m':
        M[num-1] += 1

for i in range(9):
    if M[i]==3:
        print(0)
        quit()
    if P[i]==3:
        print(0)
        quit()
    if S[i]==3:
        print(0)
        quit()

for i in range(7):
    if M[i]==1 and M[i+1]==1 and M[i+2]==1:
        print(0)
        quit()
    if P[i]==1 and P[i+1]==1 and P[i+2]==1:
        print(0)
        quit()
    if S[i]==1 and S[i+1]==1 and S[i+2]==1:
        print(0)
        quit()

for i in range(9):
    if M[i]==2:
        print(1)
        quit()
    if P[i]==2:
        print(1)
        quit()
    if S[i]==2:
        print(1)
        quit()

for i in range(8):
    if M[i]==1 and M[i+1]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+1]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+1]==1:
        print(1)
        quit()

for i in range(7):
    if M[i]==1 and M[i+2]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+2]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+2]==1:
        print(1)
        quit()

print(2)
",O(n)
"import math

def read_ints():
    return map(int, input().split())

def read_matrix(n):
    return [list(read_ints()) for _ in range(n)]

def around(x, y, hor, ver, mtx):
    a, b, c, d = [math.inf]*4

    if x > 0:
        a = hor[y][x - 1] * 2 + mtx[y][x - 1]

    if x < m - 1:
        b = hor[y][x] * 2 + mtx[y][x + 1]

    if y > 0:
        c = ver[y - 1][x] * 2 + mtx[y - 1][x]

    if y < n - 1:
        d = ver[y][x] * 2 + mtx[y + 1][x]

    return min(a, b, c, d)

if __name__ == ""__main__"":
    n, m, k = read_ints()
    hor = read_matrix(n)
    ver = read_matrix(n - 1)

    if k % 2:
        for i in range(n):
            print('-1 ' * m)
        exit()

    _old = [[0] * m for _ in range(n)]
    for i in range(k // 2):
        _new = [[0] * m for _ in ' ' * n]

        for x in range(m):
            for y in range(n):
                _new[y][x] = around(x, y, hor, ver, _old)

        _old = _new

    for row in _old:
        print(*row)",O(n ^ 3)
"import sys
from math import gcd, sqrt
from typing import Deque

sys.setrecursionlimit(10 ** 5)

inf = float(""inf"")
en = lambda x: list(enumerate(x))

ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())

n = ii()
arr = rr()
arr = en(arr)

arr.sort(key=lambda x: x[1])

i = 0
brr = []

for j in input():
    if j == ""0"":
        brr.append(arr[i])
        print(arr[i][0] + 1, end="" "")
        i += 1
    else:
        x = brr.pop()
        print(x[0] + 1, end="" "")
",O(nlogn)
"class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)",O(n)
"
class Solution(object):
    def defangIPaddr(self, address):
        result = []
        for c in address:
            if c == '.':
                result.append(""[.]"")
            else:
                result.append(c)
        return """".join(result)
",O(n)
"import sys as _sys

_sys.setrecursionlimit(2**14)

_cache = dict()

class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)

def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)

def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []

    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]

    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]

    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area

def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])

def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def maximumScoreAfterOperations(self, edges, values):
        def iter_dfs():
            dp = [0]*len(values)
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop() 
                if step == 1:
                    if len(adj[u]) == (1 if u else 0):
                        dp[u] = values[u]
                        continue
                    stk.append((2, u, p))
                    for v in reversed(adj[u]):
                        if v != p:
                            stk.append((1, v, u))
                elif step == 2:
                    dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u]) 
            return dp[0]

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-iter_dfs()",O(n)
"class Solution2(object):
    def minimumPerimeter(self, neededApples):
        x = int((2*neededApples)**(1.0/3))
        x -= x%2
        assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3)
        x += 2
        if (x-2)*(x-1)*x < 2*neededApples:
            x += 2
        return 8*(x-2)//2",O(1)
"n,a,b=list(map(int,input().split()))
d=[]
for i in range(n):
    d.append([""1""]*n)
    d[i][i]=""0""
if [n,a,b]==[2,1,1]:
    print(""NO"")
elif [n,a,b]==[3,1,1]:
    print(""NO"")
elif a==1:
    c=n-b
    for i in range(c):
        d[i][i+1]=""0""
        d[i+1][i]=""0""
    print(""YES"")
    for i in range(n):
        print("""".join(d[i]))
elif a!=1 and b!=1:
    print(""NO"")
else:
    print(""YES"")
    for i in range(a-1):
        for j in range(n):
            d[i][j]=""0""
        for j in range(n):
            d[j][i]=""0""
    for i in range(n):
        print("""".join(d[i]))",O(n ^ 2)
"class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]",O(n)
"import collections



class Solution(object):
    def minimumOperations(self, nums):
        even_top = collections.Counter(nums[i] for i in range(0, len(nums), 2)).most_common(2) 
        odd_top = collections.Counter(nums[i] for i in range(1, len(nums), 2)).most_common(2) 
        if not odd_top or even_top[0][0] != odd_top[0][0]:
            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)
        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),
                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))",O(n)
"n = int(input())
a = list(map(int, input().split()))

dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]

for i in range(n):
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",O(n ^ 3)
"n,m = map(int,input().split())
print(n*""8"")
print((n-1)*""1""+""2"")",O(1)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
lf = [(a[i], i) for i in range(n) if a[i] == 1]
it = [(a[i], i) for i in range(n) if a[i] > 1]
it.sort(reverse=True)
while len(lf) < 2:
    lf.append(it.pop())

ed = []
_, last = lf.pop()

for i in range(len(it)):
    cap, u = it[i]
    if i != 0:
        ed.append((it[i - 1][1], u))
        cap -= 1
    while lf and cap > 1:
        _, l = lf.pop()
        ed.append((u, l))
        cap -= 1

if lf:
    ans = 'NO'
else:
    ans = 'YES %d' % (len(it) + 1,)
    ed.append((it[-1][1], last))
    ans1 = str(len(ed))
    ans2 = '\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)
    ans = '\n'.join([ans, ans1, ans2])
print(ans)
",O(nlogn)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)
",O(1)
"n,d=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
pos=2
for i in range(n-1):
    l=a[i]+d
    r=a[i+1]-d
    if l==r:
        pos+=1
    elif l<r:
        pos+=2
print(pos)
",O(n)
"n = int(input())
a = list(map(int, input().split()))
q = (10 ** 6) * [-1]
pnt = -1
ans = ""YES""
for i in range(n):
    if pnt == -1:
        pnt += 1
        q[pnt] = a[i]
    else :
        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:
            q[pnt] = -1
            pnt -= 1
        else:
            pnt += 1
            q[pnt] = a[i]
if pnt > 0 :
    ans = ""NO""
print(ans)
",O(n)
"n,m=map(int,input().split())
a=0
while m:a+=n//m;n,m=m,n%m
print(a)",O(1)
"from math import factorial
s=input()
s1=input()
plus=s.count('+')-s1.count('+')
minus=s.count('-')-s1.count('-')
n=s1.count('?')
if plus<0 or minus<0:
    print(0)
else:
    print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n))",np
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
x, y = ria()
d1 = abs(1 - x) + abs(1 - y)
d2 = abs(n - x) + abs(n - y)
if d1<=d2:
    print('White')
else:
    print('Black')",O(1)
"class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        max_run = -1
        i = max_prof = prof = waiting = 0
        run = 1
        while i < len(customers) or waiting > 0:
            if i < len(customers):
                waiting += customers[i] 
                i += 1
            boarding = min(waiting, 4) 
            waiting -= boarding
            prof += boarding * boardingCost - runningCost 
            if prof > max_prof:
                max_prof = prof
                max_run = run
            run += 1
        return max_run",O(n)
"n,s=map(int,input().split())
arr=[]
for i in range(n):
    arr.append([])
    arr[i]=[int(i) for i in input().split()]
arr=sorted(arr,reverse=True,key=lambda x:x[0])
ans,c=0,0
for i in range(n):
    if i!=0:
       c=arr[i-1][0]
    if i==0:
       ans=ans+s-arr[i][0]
    else:
       ans=ans+c-arr[i][0]
    if arr[i][1]>=ans:
        ans=ans+(arr[i][1]-ans)
ans=ans+arr[n-1][0]
print(ans)
",O(n)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):
    hcenter, hlen = [float(item) for item in input().split(' ')]

    cont.append([hcenter - hlen / 2, hcenter + hlen / 2])

cont.sort(key=lambda it: it[0])

for i in range(n - 1):
    gap = cont[i + 1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1
print(ans)",O(nlogn)
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)
",O(n ^ 3)
"import sys

def inn(a,b):
	return (a[0] <= b[0] and b[1] <= a[1])

n = int(input())

seg = []

a,b = map(int,input().split())
seg.append((a,b,1))

for i in range(2,n+1):
	a,b = map(int,input().split())
	seg.append((a,b,i))

seg.sort(key=lambda x : (x[0],-x[1]))

main = seg.pop(0)

for i in seg:
	if inn(main,i):
		print(i[2],main[2])
		sys.exit(0)
	if main[1] < i[1]:
		main = i

print(-1,-1)",O(nlogn)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

from math import log
l,r=kk()
i=msb = int(max(log(l,2),log(r,2)))
while ((2**i)&l) == ((2**i)&r):
	i-=1
	if i == -1:
		break
i+=1
print(2**i-1)",O(logn)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

pr = lambda x:    x
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
    n, = aj()
    A = aj()
    if A.count(0) >= 2:
        print('cslnb')
    elif n == 1:
        if A[0]%2:
            print('sjfnb')
        else:
            print('cslnb')
    else:
        g2 = 0;flag = 1
        C = Counter(A)
        for i in C.keys():
            if C[i] >= 3:
                flag = 0
            if C[i] == 2 and C[i-1] >= 1:
                flag = 0
            if C[i] == 2:
                g2 += 1
        if g2 >= 2:
            flag = 0
        if not flag:
            print('cslnb')
        else:
            movescount = 0
            A.sort()
            for ii,i in enumerate(A):
                movescount += i - ii
            if movescount % 2 == 0:
                print('cslnb')
            else:
                print('sjfnb')

try:

    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from aj import *
except:
    pass

solve()",O(nlogn)
"import sys
n=int(input())

l=list(map(int,input().split()))
c=list(map(int,input().split()))
a=[]
for i in range(1,n-1):
    lr=sys.maxsize
    lc=sys.maxsize
    for j in range(0,i):

        if l[i]>l[j]:
            lc=min(lc,c[j])

    for j in range(i+1,n):

        if l[j]>l[i]:
            lr=min(lr,c[j])

    if lr<sys.maxsize and lc<sys.maxsize:
        a.append(lr+lc+c[i])

if not a:
    print(-1)
else:
    print(min(a))
",O(n ^ 2)
"nab=input().split()
l=input().split()
nab=[int(i) for i in nab]
l=[int(i) for i in l]
l.sort()
if(l[nab[2]-1]==l[nab[2]]):
    print(0)
else:
    print(l[nab[2]]-l[nab[2]-1])
",O(nlogn)
"n,p,v = input().split()
x= list(map(int,input().split()))

x.sort()
print(x[int(v)]-x[int(v)-1])",O(nlogn)
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1",O(n ^ 2)
"N=int(input())
L=list(map(int,input().split()))

DP=[[-1]*N for i in range(N)]
for d in range(N):
    for s in range(N-d):
        e=s+d
        if s==e:
            DP[s][e]=L[s]
            continue
        for m in range(s,e):
            l=DP[s][m]
            r=DP[m+1][e]
            if l==r and l!=-1:
                DP[s][e]=max(DP[s][e],l+1)
DP2=[i+1 for i in range(N)]
for i in range(N):
    if DP[0][i]!=-1:
        DP2[i]=1
        continue
    for j in range(i):
        if DP[j+1][i]!=-1:
            DP2[i]=min(DP2[i],DP2[j]+1)
print(DP2[N-1])",O(n ^ 3)
"class Solution2(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, prev, sum):
            if root is None:
                return 0

            curr = prev + root.val
            return int(curr == sum) + \
                   pathSumHelper(root.left, curr, sum) + \
                   pathSumHelper(root.right, curr, sum)

        if root is None:
            return 0

        return pathSumHelper(root, 0, sum) + \
               self.pathSum(root.left, sum) + \
               self.pathSum(root.right, sum)",O(n ^ 2)
"import math

n, r = map(int, input().split())

a = math.pi/n
sin = math.sin(a)
R = r*sin/(1-sin)

print(R)",O(1)
"n,k = list(map(int,input().split()))

limit = 998244353

if k > 2*n:
    print(0)
elif k == 1 or k == 2*n:
    print(2)
else:
    same = [0] * (k+1)
    same[1] = 2

    diff = [0] * (k+1)
    diff[2] = 2

    for i in range(2, n+1):
        for j in range(min(k, 2*i), 1, -1):

            same[j] = same[j] + 2*diff[j] + same[j-1]
            same[j] %= limit

            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]
            diff[j] %= limit

    print((same[k] + diff[k]) % limit)",np
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",O(nlogn)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

s = STR()

if len(set(s)) == len(s):
    print('0')
    exit(0)

d = []

for i in range(len(s)):
    for j in range(i+1 , len(s)):
        x = ''
        for k in range(i , j+1):
            x += s[k]

        d.append(x)

v = {}
for i in range(len(s)):
    if s[i] not in v :
        v[s[i]] = 1
    else:
        v[s[i]] +=1

for i in d :
    if i not in v :
        v[i] = 1
    else:
        v[i]+=1

mx = -1
ans = ''

for i in v :
    if v[i] >= 2 :
        if len(i) > mx :
            mx = max(mx , len(i))

print(mx)
",O(n ^ 3)
"from sys import stdin
x, k = map(int, stdin.readline().split())
if x == 0:
	print(0)
else:
	mod = 1000000007
	a = pow(2,k,mod)%mod
	b = (2*a)%mod
	print((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)",O(logn)
"class Solution(object):
    def maximizeWin(self, prizePositions, k):
        dp = [0]*(len(prizePositions)+1)
        result = left = 0
        for right in range(len(prizePositions)):
            while prizePositions[right]-prizePositions[left] > k:
                left += 1
            dp[right+1] = max(dp[right], right-left+1)
            result = max(result, dp[left]+(right-left+1))
        return result",O(n)
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",O(logn)
"
import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):
        row_maxes = [max(row) for row in grid]
        col_maxes = [max(col) for col in zip(*grid)]

        return sum(min(row_maxes[r], col_maxes[c])-val \
                   for r, row in enumerate(grid) \
                   for c, val in enumerate(row))

",O(n ^ 2)
"n,m = map(int,input().split())
arr1 = [int(i) for i in input().split()]
arr2 = [int(i) for i in input().split()]

for first in arr1:
    for second in arr2:
        if first == second:

            print(first,end="" "")",O(n ^ 2)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers) - 1

        while l < r:
            curSum = numbers[l] + numbers[r]

            if curSum > target:
                r -= 1
            elif curSum < target:
                l += 1
            else:
                return [l + 1, r + 1]
        return []
",O(n)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"t=int(input())
for i in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    if(n<=2):
        print(0)
        continue
    ar=sorted(ar)[::-1]
    ans=0
    for i in range(1,n-1):
        if(ar[0]>i and ar[1]>i):
            ans=i
    print(ans)
",O(nlogn)
"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

ans = float('inf')
for i in range(1, n-1):
    bef = aft = float('inf')
    for j in range(i):
        if a[j] < a[i]:
            bef = min(bef, b[j])
    for j in range(i, n):
        if a[i] < a[j]:
            aft = min(aft, b[j])
    ans = min(ans, b[i]+bef+aft)
print(-1 if ans > 10**9 else ans)
",O(n ^ 2)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])

    print(max(dp[n]))",O(n)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    counter=collections.Counter(arr)
    ans=set()
    for i in counter:
        for j in range(1,32):
            no=2**j
            diff=no-i
            if diff<0:
                continue
            if diff==i:
                if counter[i]>1:
                    ans.add(i)

                    break
            else:
                if diff not in  counter:
                    continue
                else:
                    ans.add(i)

                    break

    val=0
    ans=list(ans)
    for i in ans:
        val+=counter[i]
    print(n-val)",O(nlogn)
"from sys import stdin
readline = stdin.readline
def readInt():
    return int(readline())
def readInts():
    return list(map(int,readline().split()))

U, D, L, R = 0, 1, 2, 3
DIR = [(-1,0), (1,0), (0,-1), (0,1)]

n, m, k = readInts()

moves = [[[-1 for _ in range(4)] for _ in range(m)] for _ in range(n)]

right = []
down = []

for i in range(n):
    row = readInts()
    right.append(row)

for i in range(n-1):
    row = readInts()
    down.append(row)

if k % 2 == 1:
    for _ in range(n):
        for _ in range(m):
            print(-1, end="" "")
        print()
    exit()

k //= 2

dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]

for l in range(k):
    for i in range(n):
        for j in range(m):
            dp[i][j][l+1] = float(""inf"")
            if i > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])
            if j > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])
            if i < n - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])
            if j < m - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])

for i in range(n):
    for j in range(m):
        print(2*dp[i][j][k], end="" "")
    print()
",O(n ^ 3)
"import itertools

kol1 = {'+': 0, '-': 0, '?': 0}
kol2 = {'+': 0, '-': 0, '?': 0}

s1 = input()
s2 = input()

for s in s1:
    kol1[s] += 1

for s in s2:
    kol2[s] += 1

if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):
    print('1.0')
    exit()

mod1 = kol1['+'] - kol1['-']
mod2 = kol2['+'] - kol2['-']
mod3 = abs(mod2-mod1)
if (mod3>kol2['?']):
    print(0.0)
    exit()

list_comb = [1, -1]
sum_pos = 0
col = 0

for comb in itertools.product(list_comb, repeat=kol2['?']):
    if sum(comb)==mod3:
        sum_pos += 1
    col+=1

print(sum_pos/col)",np
"import math


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1)))",O(1)
"class Solution(object):
    def findMaximums(self, nums):
        def find_bound(nums, direction, init):
            result = [0]*len(nums)
            stk = [init]
            for i in direction(range(len(nums))):
                while stk[-1] != init and nums[stk[-1]] >= nums[i]:
                    stk.pop()
                result[i] = stk[-1]
                stk.append(i)
            return result

        left = find_bound(nums, lambda x: x, -1)
        right = find_bound(nums, reversed, len(nums))
        result = [-1]*len(nums)
        for i, v in enumerate(nums):
            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)
        for i in reversed(range(len(nums)-1)):
            result[i] = max(result[i], result[i+1])
        return result",O(n)
"from itertools import chain
from time import time

def main():

    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x&val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i+1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0]+[1e8]*(1<<N)
    pres = [None]*(1<<N)
    allb = (1 << N)-1
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                                + alld[p[0]][0] \
                                + alld[p[1]][0]

    for stt in range(1<<N):
        if stt not in vis:
            continue

        bits = getBits(~stt&allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit]+1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

import sys
st = time()
main()
print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np
"def dig(d):
    return ord(d) - ord('0')

def biggest_left(counts):
    res = ''
    for i in range(9, -1, -1):
        res += str(i) * counts[i]
    return res

def ok(d, _counts, rest):
    if rest == '':
        return True

    counts = _counts.copy()
    counts[d] -= 1

    r = ''
    for i in range(10):
        r += str(i) * counts[i]

    return int(r) <= int(rest)

def main():
    a, b = input(), input()

    counts = [0] * 10
    for d in a:
        counts[dig(d)] += 1

    ans = ''
    if len(a) < len(b):
        print(biggest_left(counts))
        return

    n = len(a)
    for i in range(n):
        d = dig(b[i])

        if counts[d] and ok(d, counts, b[i+1:]):
            ans += b[i]
            counts[d] -= 1
        else:
            for s in range(d-1, -1, -1):
                if counts[s] > 0:
                    ans += str(s)
                    counts[s] -= 1
                    ans += biggest_left(counts)
                    print(ans)
                    return
    print(ans)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def averageWaitingTime(self, customers):
        avai = wait = 0.0
        for a, t in customers:
            avai = max(avai, a)+t
            wait += avai-a
        return wait/len(customers)",O(n)
"class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        order = list(range(len(growTime)))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result",O(nlogn)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    max_val = max(table)
    ind = 0
    while ind < len(table):
        if table[ind] == max_val:
            break
        ind += 1
    cost = (len(table) - ind) + table[ind - 1]

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    return min(table[n - 1], min_cost)

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"class Solution(object):
    def bitwiseComplement(self, N):
        mask = 1
        while N > mask:
            mask = mask*2+1
        return mask-N",O(logn)
"n,m = map(int, input().split())
a= input()
b = input()
if '*' in a:
    c = a.replace('*','')
    i = a.index('*')
    if c==b:
        print(""YES"")
    elif a[:i]==b[:i]:
        t = a[i+1:]

        tt = b[m - n+1+i:]

        if t ==tt and n-1<=m:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
elif n>m:
    print(""NO"")
else:
    if a==b:
        print(""YES"")
    else:
        print(""NO"")
",O(n)
"get = lambda : list(map(int, input().split(' ')))
n, m, k = get()
rlist, clist = [], []
for _ in range(n):
    rlist.append(get())
for _ in range(n-1):
    clist.append(get())

dway = [[0,1],[0,-1],[1,0],[-1,0]]
if k%2:
    res = [[-1]*m for _ in range(n)]
else:
    flist = [[0]*m for _ in range(n)]
    for _ in range(k//2):
        glist = [[10**9]*m for _ in range(n)]
        for dx, dy in dway:
            klist = rlist if dx == 0 else clist
            for x in range(n):
                for y in range(m):
                    xx, yy = x+dx, y+dy
                    if not (0<=xx<n) or not (0<=yy<m):
                        continue
                    tx = xx if dx==-1 else x
                    ty = yy if dy==-1 else y
                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)
        flist = glist
    res = flist
for row in res:
    print(' '.join(map(str, row)))",O(n ^ 3)
"from collections import defaultdict
from collections import Counter
from collections import deque
import heapq

inf = float('inf')
ninf = float('-inf')

M1 = 10**9 + 7
M2 = 998244353

def li():
    return list(map(int,input().split()))

def pre():
    ""Start""

def solve():
    a = input()
    b = input()
    n = len(a)
    if(len(a)<len(b)):
        a = sorted(list(a),reverse = True)
        print("""".join(a))
        return
    b = int(b)
    ans = 0
    cnt = [0]*10
    for i in range(n):
        cnt[ord(a[i])-ord('0')] += 1

    def getrem(k):
        cnt[k] -= 1
        ans = """"
        for i in range(10):
            for j in range(cnt[i]):
                ans += str(i)
        cnt[k] += 1
        return ans

    prev = """"
    for i in range(n):
        for j in range(9,-1,-1):
            if(cnt[j]>0):
                newval = prev + str(j)+ getrem(j)
                if(int(newval)<=b):
                    ans = max(ans,int(newval))
                    prev += str(j)
                    cnt[j] -= 1
                    break
    print(ans)

pre()

__ = 1

for _ in range(__):
    solve()",O(n ^ 3)
"n, k = map(int, input().split())
arr = list(map(int, input().split()))

rsum = [0]
maxx = 0.0

for i in range(n): rsum.append(rsum[-1] + arr[i])

for ki in range(k, n+1):
    for i in range(n-ki+1):
        tot = 0

        avg = (rsum[i+ki] - rsum[i])/ki

        maxx = max(maxx, avg)
print(maxx)
",O(n ^ 2)
"class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        return 100-(purchaseAmount+5)//10*10",O(1)
"import collections



class Solution(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        self.__key_to_freq = {}

    def get(self, key):
        if key not in self.__key_to_freq:
            return -1
        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_freq and self.__size == self.__capa:
            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]
            if not self.__freq_to_nodes[self.__min_freq]:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_freq:
            freq = self.__key_to_freq[key]
            del self.__freq_to_nodes[freq][key]
            if not self.__freq_to_nodes[freq]:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_freq[key] = freq
        self.__freq_to_nodes[freq][key] = value
        self.__size += 1",O(1)
print(int(input()) // 2 + 1),O(1)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
j = 0
a.sort()
n1 = n
for i in range(n):
    while a[j] < a[i]:
        if a[i] <= a[j] + k:
            n1 -= 1
        j += 1
print(n1)
",O(nlogn)
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
MAP=[list(input().strip()) for i in range(n)]

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        if MAP[i][j]==""*"":
            T0[i][j]=T0[i-1][j]+1
            Y0[i][j]=Y0[i][j-1]+1

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        if MAP[i][j]==""*"":
            T1[i][j]=T1[i+1][j]+1
            Y1[i][j]=Y1[i][j+1]+1

ANS=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):
        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])
        if score>=2:
            ANS[i][j]=score

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)
        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)
        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)

SUF=[["".""]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:
            SUF[i][j]=""*""

if SUF!=MAP:
    print(-1)
else:
    ANSLIST=[]
    for i in range(n):
        for j in range(m):
            if ANS[i][j]!=0:
                ANSLIST.append((i+1,j+1,ANS[i][j]-1))

    print(len(ANSLIST))
    for ans in ANSLIST:
        print(*ans)
",O(n ^ 2)
"n = int(input())
A = [int(i) for i in input().split()]
A = list(set(A))
A.sort()
if len(A)>1:
    print(A[1])
else:
    print(""NO"")
",O(nlogn)
"class Solution(object):
    def __init__(self):
        self.__max_log3 = int(math.log(0x7fffffff) / math.log(3))
        self.__max_pow3 = 3 ** self.__max_log3

    def isPowerOfThree(self, n):
        return n > 0 and self.__max_pow3 % n == 0",O(1)
"class Solution(object):
    def stringSequence(self, target):
        return [target[:i]+chr(x) for i in range(len(target)) for x in range(ord('a'), ord(target[i])+1)]",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrderBottom(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)

        return result[::-1]",O(n)
"import math

def get_line(x1, y1, x2, y2):
    a = x2 - x1
    b = y1 - y2
    c = x1 * (y2 - y1) - y1 * (x2 - x1)

    g = math.gcd(math.gcd(a, b), c)
    a //= g
    b //= g
    c //= g
    return a, b, c

n = int(input())
xy = []

for i in range(n):
    x, y = [int(x) for x in input().split()]
    xy.append((x, y))

if n <= 3:
    print(""YES"")
    exit()

def check(x1, y1, x2, y2, xy):
    a1, b1, c1 = get_line(x1, y1, x2, y2)
    other_point = None
    cnt_other = 0
    a2, b2, c2 = 0, 0, 0
    for i in range(len(xy)):
        x, y = xy[i]

        if a1 * y + b1 * x + c1 != 0:
            if other_point is None:
                other_point = x, y
                cnt_other = 1
            elif cnt_other == 1:
                cnt_other = 2
                a2, b2, c2 = get_line(*other_point, x, y)
            else:
                if a2 * y + b2 * x + c2 != 0:
                    return False
    return True

if check(*xy[0], *xy[1], xy[2:]):
    print(""YES"")
elif check(*xy[1], *xy[2], [xy[0]] + xy[3:]):
    print(""YES"")
elif check(*xy[0], *xy[2], [xy[1]] + xy[3:]):
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n = int(input())
x,y = map(int,input().split())
num = x - 1 + y - 1
num2 = n - x + n - y
ans = num <= num2
if ans:
    print(""White"")
else:
    print(""Black"")
",O(1)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
A.sort()

from collections import Counter
C=Counter(A)
dou=0

for c in C:
    dou+=C[c]-1

    if C[c]>=2 and C[c-1]!=0:
        print(""cslnb"")
        sys.exit()

if dou>=2:
    print(""cslnb"")
    sys.exit()

ANS=0
for i in range(n):
    if A[i]<i:
        print(""cslnb"")
        sys.exit()
    ANS+=(A[i]-i)%2

if ANS%2==0:
    print(""cslnb"")
    sys.exit()
else:
    print(""sjfnb"")
    sys.exit()
",O(nlogn)
"class Solution2(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        result = 0
        for x in fruits:
            i = next((i for i in range(len(baskets)) if baskets[i] >= x), -1)
            if i ==-1:
                result += 1
            else:
                baskets[i] = 0
        return result",O(n ^ 2)
"a=list(input())
b=int(input())
a.sort()
a=a[::-1]
prefix=""""
while(len(a)>0):
    for i in range(len(a)):
        num=prefix+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if(int(num)<=b):
            prefix+=a[i]
            a=a[:i]+a[i+1:]
            break
print(prefix)",O(n ^ 3)
"import collections



class Solution(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
        return right-left+1",O(n)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    x,k = LI()
    if x == 0:
        return 0
    t = pow(2,k+1,mod) * x % mod
    d = pow(2,k,mod) - 1

    return (t + mod - d) % mod

print(main())
",O(logn)
"a,b=map(int,input().split())
x,y,z=map(int,input().split())

yell=2*x+y
blue=y+3*z
res=max(0,yell-a)+max(0,blue-b)

print(res)",O(1)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution(object):
    def myPow(self, x, n):
        result = 1
        abs_n = abs(n)
        while abs_n:
            if abs_n & 1:
                result *= x
            abs_n >>= 1
            x *= x

        return 1 / result if n < 0 else result",O(logn)
"n=int(input())
a=list(map(int,input().split()))
b=[]
maxi=0
for i in range(n):
    maxi=max(maxi,a[i]+1)
    b.append(maxi)
c=[]
count=b[-1]
for i in range(n-1,-1,-1):
    if count-1>=b[i]:
        count-=1
        c.append(count)
    else:
        c.append(count)
c=c[::-1]
ans=0
for i in range(n):
    ans+=(c[i]-a[i]-1)
print(ans)",O(n)
"def candy_eaten(n, k):

    choco = 1
    last = 1
    eat = 0

    i = n - 1
    while i > 0:
        if choco > k:
            temp = choco - k
            choco -= temp
            eat += temp
            i -= temp
        else:
            last += 1
            choco += last
            i -= 1
    return eat

if __name__ == '__main__':
    n, k = map(int, input().strip().split())
    print(candy_eaten(n, k))
",O(logn)
"n = int(input())
A = list(map(int, input().split()))
A.sort()
ans = 1
for i in range(1, n):
  ok = False
  for j in range(i):
    if A[i] % A[j] == 0:
      ok = True
  if not ok:
    ans += 1
print(ans)
",O(n ^ 2)
"import sys,math
class Node:
    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):
        self.up=u
        self.dn=d
        self.lt=l
        self.rt=r
    def __str__(self):
        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)

n,m,k=list(map(int,sys.stdin.readline().strip().split()))
graph=[[Node() for j in range(m)]for i in range(n)]
for i in range(n):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m-1):
        graph[i][j].rt=wts[j]
        graph[i][j+1].lt=wts[j]

for i in range(n-1):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m):
        graph[i][j].dn=wts[j]
        graph[i+1][j].up=wts[j]

ans=[[math.inf for j in range(m)]for i in range(n)]

if k%2:
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]

else:
    def bfs(prsnt,stps):

        if stps==0:
            return 0
        else:
            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:
                min_cost=math.inf
                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:
                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:
                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)
                dp[prsnt[0]][prsnt[1]][stps]=min_cost
                return min_cost
            else:
                return dp[prsnt[0]][prsnt[1]][stps]

    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]
    for i in range(n):
        for j in range(m):
            ans[i][j]=bfs((i,j),k//2)*2
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",O(n ^ 3)
"class Solution(object):
    def countArrays(self, original, bounds):
        left, right = bounds[0]
        result = right-left+1
        for i in range(1, len(original)):
            diff = original[i]-original[i-1]
            left = max(left+diff, bounds[i][0])
            right = min(right+diff, bounds[i][1])
            result = min(result, max(right-left+1, 0))
        return result",O(n)
"class Solution_TLE(object):
    def find132pattern(self, nums):
        for k in range(len(nums)):
            valid = False
            for j in range(k):
                if nums[j] < nums[k]:
                    valid = True
                elif nums[j] > nums[k]:
                    if valid:
                        return True
        return False",O(n ^ 2)
"import sys

def is_winning_state(nims, n):
    keys = set(nims)
    counts = dict.fromkeys(keys, 0)
    for nim in nims:
        counts[nim] += 1
    if 0 in keys and counts[0] > 1:
        return True
    lose_count = 0
    for k in keys:
        if counts[k] > 2:
            return True
        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:
            return True
        if counts[k] > 1:
            lose_count += 1
    if lose_count > 1:
        return True
    return False

def main():
    n = int(input())
    nims = list(map(int, input().split()))
    if is_winning_state(nims, n):
        print('cslnb')
    else:
        x = sum(nims) - (n * (n - 1)) // 2
        if x % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')

main()
",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod=10**9+7
n=int(input())
a=list(map(int,input().split()))
c=0
for i in range (1,n):
    for j in range (i):
        if a[j]>a[i]:
            c+=1
c=c%2
m=int(input())
for i in range (m):
    l,r=map(int,input().split())
    s=(r-l+1)//2
    if s%2==1:
        c=(c+1)%2
    if c==0:
        print(""even"")
    else:
        print(""odd"")",O(n ^ 2)
"import sys

input = sys.stdin.buffer.readline

def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True

    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans

def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i

    print(str(idx_i + 1) + "" "" + str(idx_j + 1))

def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)

main()
",np
"class Solution2(object):
    def numMovesStones(self, a, b, c):
        stones = [a, b, c]
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]",O(1)
"class Solution(object):
    def maxRectangleArea(self, xCoord, yCoord):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points = sorted((xCoord[i], yCoord[i]) for i in range(len(xCoord)))
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(yCoord)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"class Solution(object):
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        return left",O(logn)
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):
        union_find = UnionFind(len(s))
        for x,y in pairs: 
            union_find.union_set(x, y)
        components = collections.defaultdict(list)
        for i in range(len(s)): 
            components[union_find.find_set(i)].append(s[i])
        for i in components.keys(): 
            components[i].sort(reverse=True)
        result = []
        for i in range(len(s)): 
            result.append(components[union_find.find_set(i)].pop())
        return """".join(result)


",O(nlogn)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(1)
"def bin(n):
    if n == 0:
        return 1
    else:
        if n % 2 == 1:
            return bin(n - 1) * 2
        else:
            b = (bin(n // 2)) % 1000000007
            return b * b;
x, k = map(int,input().split())
if x == 0:
    print(0)
else:
    z = bin(k + 1) % 1000000007
    z = z * (x - 1)
    z = z % 1000000007
    z += bin(k)
    z += 1
    while(z < 0):
        z += 1000000007
    print(z % 1000000007)",O(logn)
"import sys, math
import io, os

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.buffer.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')

mod = int(1e9)+7

def cal(x):
    l1=set()
    d=dd(int)
    a=[]
    for i in range(n):
        k=0
        for j in range(m):
            if A[i][j]>=x:
                k+=1<<j
        l1.add(k)
        d[k]=i+1
    l1=list(l1)
    s=(1<<m)-1
    for i in l1:
        for j in l1:
            if i|j == s:
                a=[d[i],d[j]]
    return a

n,m=mdata()
A=[mdata() for i in range(n)]
l,r=0,10**9
while l<=r:
    mid=(l+r)//2
    if cal(mid):
        l=mid+1
    else:
        r=mid-1
a=cal(mid)
if a:
    outl(a)
else:
    outl(cal(mid-1))
",np
"class Solution(object):
    def reverseStr(self, s, k):
        s = list(s)
        for i in range(0, len(s), 2*k):
            s[i:i+k] = reversed(s[i:i+k])
        return """".join(s)",O(n)
"n,k=list(map(int,input().split()))

arr1=list(map(int,input().split()))
arr2=list(map(int,input().split()))
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1

print(mx+ans)
",O(n)
"n,k=map(int,input().split())
mod=998244353

NEXT={(0,1):2,(1,2):2}

for i in range(1,n):
    NOW=NEXT
    NEXT=dict()
    for key in NOW:

        if key[0]==0:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
            if k-(n-i)*2<key[1]+1<=k:
                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]
                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod

        else:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod

            if k-(n-i)*2<key[1]+2<=k:
                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]

ANS=0
for key in NEXT:
    if key[1]==k:
        ANS=(ANS+NEXT[key])%mod

print(ANS)
",np
"class Solution(object):
    def checkRecord(self, s):
        count_A = 0
        for i in range(len(s)):
            if s[i] == 'A':
                count_A += 1
                if count_A == 2:
                    return False
            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':
                return False
        return True",O(n)
"from itertools import combinations_with_replacement
import sys
from sys import stdin
import math
import bisect

def BinarySearch(a, x):
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    else:
        return -1
def iinput():
    return int(input())
def minput():
    return map(int,input().split())
def linput():
    return list(map(int,input().split()))

def fiinput():
    return int(stdin.readline())
def fminput():
    return map(int,stdin.readline().strip().split())
def flinput():
    return list(map(int,stdin.readline().strip().split()))

x,k=minput()

if(x==0):
    print(0)
else:
    mod=(10**9)+7
    a=pow(2,k,mod)
    b=((2*x)%mod-1)%mod
    ans=((a*b)%mod+1)%mod
    print(ans)",O(logn)
"n,k=map(int,input().split())
l=input()
l=sorted(l)
ans=l[0]
sum=ord(l[0])
index=0
for j in range(1,n):
    if len(ans)<k:
        if ord(l[j])-ord(l[index])>1:
            ans=ans+l[j]
            sum=sum+ord(l[j])
            index=j
    else:
        break
if len(ans)==k:
    sum=sum-96*k
    print(sum)
else:
    print(-1)
",O(n)
"def main():
    def solve():
        n = int(input())
        arr = sorted(map(int, input().split()))
        a = arr[-2]
        print(min(n - 2, a - 1))

    import sys
    input = sys.stdin.readline

    for _ in range(int(input())):
        solve()

    return 0

main()",O(nlogn)
"class Solution(object):
    def canAliceWin(self, n):
        c = 10
        l = int(((2*c+1)-((2*c+1)**2-8*n)**0.5)/2)
        return l%2 == 1",O(1)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))
",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

def check(a,mid,n,m,z):
    b=Counter()
    for i in range(n):
        c=[""0""]*m
        for j in range(m):
            if a[i][j]>=mid:
                c[j]=""1""
        zz=int("""".join(c),2)
        b[zz]=i
    c=list(b.keys())
    lc=len(c)
    for i in range(lc):
        for j in range(i,lc):
            if c[i]|c[j]==z:
                mi,x,y=10000000000,b[c[i]],b[c[j]]
                for k in range(m):
                    mi=min(mi,max(a[x][k],a[y][k]))
                if mi>=mid:
                    return (x,y)
def main():
    n,m= map(int, input().split())
    a=[list(map(int,input().split())) for _ in range(n)]
    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1
    while lo<=hi:
        mid=(lo+hi)//2
        z=check(a,mid,n,m,y)
        if z:
            lo=mid+1
            ans=[z[0]+1,z[1]+1]
        else:
            hi=mid-1
    print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np
"n,s=map(int,input().split())
if s>=n:
	print(0)
else:
	ans=0
	def sod(n):
		s=str(n)
		ret=0
		for i in s:
			ret+=int(i)
		return ret
	for nd in range(s,s+1000):
		if nd-sod(nd) >=s:
			ans+=1
		if nd==n:
			break
		if nd==(s+369):
			ans+=(n-nd)
			break
	print(ans)",O(logn)
"import collections


class Solution(object):
    def minReorder(self, n, connections):
        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        result = 0
        stk = [(-1, 0)]
        while stk:
            parent, u = stk.pop()
            result += (parent*n+u in lookup)
            for v in reversed(graph[u]):
                if v == parent:
                    continue
                stk.append((u, v))
        return result",O(n)
"import bisect


class Solution(object):
    def minAbsoluteSumDiff(self, nums1, nums2):
        MOD = 10**9+7

        sorted_nums1 = sorted(nums1)
        result = max_change = 0
        for i in range(len(nums2)):
            diff = abs(nums1[i]-nums2[i])
            result = (result+diff)%MOD
            if diff < max_change:
                continue
            j = bisect.bisect_left(sorted_nums1, nums2[i])
            if j != len(sorted_nums1):
                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))
            if j != 0:
                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))
        return (result-max_change)%MOD",O(nlogn)
"class BIT:

    __all__ = ['add', 'sumrange', 'lower_left']

    def __init__(self, maxsize=10**7):
        assert (maxsize > 0)

        self._n = maxsize+1
        self._bitdata = [0]*(maxsize+1)

    def add(self, i, x):

        assert(0 <= i < self._n)

        pos = i+1
        while pos < self._n:
            self._bitdata[pos] += x
            pos += pos&(-pos)

    def running_total(self, i):

        assert (-1<= i < self._n)

        if i == -1:
            return 0
        returnval = 0
        pos = i+1
        while pos:
            returnval += self._bitdata[pos]
            pos -= pos & (-pos)
        return returnval

    def sumrange(self, lo=0, hi=None):

        if lo < 0:
            raise ValueError('lo must be non-negative')
        if hi is None:
            hi = self._n

        return self.running_total(hi) - self.running_total(lo-1)

    def lower_left(self, total):

        if total < 0:
            return -1
        pos = 0
        k = 1<<(self._n.bit_length()-1)
        while k > 0:
            if pos+k < self._n and self._bitdata[pos+k] < total:
                total -= self._bitdata[pos+k]
                pos += k
            k //= 2
        return pos
def tentousu(lis):
  bit = BIT()
  ans = 0
  for i in range(len(lis)):
      bit.add(lis[i], 1)
      ans += i + 1 - bit.running_total(lis[i])
  return ans
N=int(input())
L=list(map(int,input().split()))
a=tentousu(L)
a%=2
if N%2==0 and a%2==0:
  print(""Petr"")
if N%2==0 and a%2==1:
  print(""Um_nik"")
if N%2==1 and a%2==0:
  print(""Um_nik"")
if N%2==1 and a%2==1:
  print(""Petr"")
",O(nlogn)
"n = int(input())
board = list(map(int,input().split("" "")))
index = list(range(0,n))
ascending = [x for _,x in sorted(zip(board,index))]

winners = n * [""""]

for c in reversed(ascending):
	if board[c] == n:
		winners[c] = ""B""

	toCheck = c - board[c]
	while(toCheck >= 0):
		if winners[toCheck] == ""B"":
			winners[c] = ""A""
		toCheck = toCheck - board[c]
	if winners[c] == """":
		toCheck = c + board[c]
		while(toCheck < n):
			if winners[toCheck] == ""B"":
				winners[c] = ""A""
			toCheck = toCheck + board[c]
	if winners[c] == """":
		winners[c] = ""B""

for i in range(n):
	print(winners[i],end="""")
print()
",O(nlogn)
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__",O(n)
"import sys
input = lambda: sys.stdin.readline().strip()

nxt = {'R':'G', 'G':'B', 'B':'R'}

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    s = input()
    res = []
    for start in ['R', 'G', 'B']:
        mis = []
        cur = start
        for j in range(k):
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
        res.append(sum(mis))
        for j in range(k, n):
            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
    print(min(res))
",O(n)
"class Solution(object):
    def sumGame(self, num):
        cnt = total = 0
        for i in range(len(num)):
            if num[i] == '?':
                cnt += (-1 if i < len(num)//2 else 1)
            else:
                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9",O(n)
"class Solution(object):
    def maxDistToClosest(self, seats):
        prev, result = -1, 1
        for i in range(len(seats)):
            if seats[i]:
                if prev < 0:
                    result = i
                else:
                    result = max(result, (i-prev)//2)
                prev = i
        return max(result, len(seats)-1-prev)",O(n)
"x, k = list(map(int,input().split()))
m = 1000000000 +7
if x!=0:
    p1 = x*2 - 1
    p2 = x*2
    p = (p1 + p2)//2
    print((p*pow(2,k,m) + 1)%m)
else:
    print(x*2)
",O(logn)
"class Solution(object):
    def minOperations(self, s1, s2, x):
        parity = curr = prev = 0
        j = -1
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(""inf"")), curr
            j = i
            parity ^= 1
        return curr//2 if parity == 0 else -1",O(n)
"n=int(input())
a=list(map(int,input().split()))
l=list(set(a))
l.sort()
if len(l) >=2:
    print(l[1])
else:
    print(""NO"")",O(nlogn)
"class Solution2(object):
    def countQuadruplets(self, nums):
        lookup = collections.defaultdict(list)
        for d in range(3, len(nums)):
            for c in range(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in range(1, len(nums)-2) for a in range(b))",O(n ^ 3)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def delNodes(self, root, to_delete):
        def delNodesHelper(to_delete_set, root, is_root, result):
            if not root:
                return None
            is_deleted = root.val in to_delete_set
            if is_root and not is_deleted:
                result.append(root)
            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)
            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)
            return None if is_deleted else root
        
        result = []
        to_delete_set = set(to_delete)
        delNodesHelper(to_delete_set, root, True, result)
        return result
",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zb = getIntList()

za1 = [0]
za2 = [zb[0]]

for i in range(1, N//2):
    t1 = zb[i] - za1[-1]
    if t1 <= za2[-1]:
        za1.append(za1[-1])
        za2.append(t1)
        continue
    t2 = zb[i] - za2[-1]
    if t2 >= za1[-1]:
        za1.append(t2)
        za2.append(za2[-1])
        continue
    assert False

zr = za1 + za2[ : :-1]
zs = []
for x in zr:
    zs .append(str(x))

r = ' '.join(zs)

print(r)
",O(n)
"n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break
                else:ind = -1
            if(ind == -1):print(-1);exit()
            cnt = abs(ind - i)
            s.pop(ind)
            s.insert(i,d[i])

            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)
                ind -= 1
    print(len(ans))
    print(*ans)",O(n ^ 2)
"def mypw2(deg):
    if (deg >= 1500) : return 2 ** 150

    return 2 ** deg

def sol():
    n, k = map(int, input().split())
    if (k == 0):
        print(""YES"", n)
        return
    for side in range(1, n + 1):
        MIN = mypw2(side + 1) - side - 2
        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;
        MAX //= 3

        if (MIN <= k <= MAX):
            print(""YES"", n - side)
            return
    print(""NO"")

def main():
    t = int(input())
    for i in range(t):
        sol()

main()",O(logn)
"MOD = 1000000007
def modpow(x, p):

    result = 1
    while p > 0:

        if p % 2 == 1:
            result = (result * x) % MOD

        p = p // 2

        x = (x * x) % MOD

    return result

n, k = map(int, input().split())
k+=1
if n == 0:
	print(0)
else:

	ans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD
	print(ans)",O(logn)
"a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)

        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",O(1)
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
def fn(p):
    turns=b[p]//14
    a=b.copy();sm=0
    a[p]=0
    for i in range(1,15):
        a[(p+i)%14]+=turns
    rem=b[p]%14
    for i in range(p+1,p+rem+1,1):
        a[(i%14)]+=1
    for i in range(14):
        if a[i]&1==0:
            sm+=a[i]

    return sm
for _ in range(1):
    b=lst()
    ans=0
    for i in range(14):
        if b[i]!=0:ans=max(ans,fn(i))
    print(ans)
",O(1)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def maximumValueSum(self, nums, k, edges):
        result = parity = 0
        diff = float(""inf"")
        for x in nums:
            y = x^k
            result += max(x, y)
            parity ^= int(x < y)
            diff = min(diff, abs(x-y))
        return result-parity*diff",O(n)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])
        return res
",O(n)
"class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD 
            else:
                ends0 = (ends0+ends1)%MOD 
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD",O(n)
"class Solution(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))",O(nlogn)
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):

    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
",np
