code,complexity
"def solve_tsp(n, distances):
    visited = [False] * n
    def dfs(city, count, cost):
        if count == n:
            return cost + distances[city][0]
        min_cost = float('inf')
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                min_cost = min(min_cost, dfs(next_city, count+1, cost + distances[city][next_city]))
                visited[next_city] = False
        return min_cost
    visited[0] = True
    return dfs(0, 1, 0)",O(n!)
"class Solution2(object):
    def minimumTime(self, s):
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(range(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result",O(n)
"def main():
    n, m, k, l = map(int, input().split())
    d = (l + k) // m
    if (l + k) % m:
        d += 1
    if m * d > n or n - k < l:
        print(-1)
    else:
        print(d)

main()",O(1)
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x
print(""!"",a,b)
",O(1)
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K
	return res

c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)
",O(n ^ 3)
"import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    n,k = map(int,input().split())
    dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)]
    dp[0][1] = [0,1,1,0]
    dp[0][0] = [1,0,0,1]
    for i in range(1,n):
        for r in range(k):
            dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod
            dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod
            dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod
            dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod
            dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod
            dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod
    print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np
"n=int(input())
b=[]
for i in range(n):
    b.append(list(map(float,input().split())))

ma=1<<n
dp=[0 for j in range(ma)]
dp[0]=1
for mask in range(1,ma):
    l=n-bin(mask).count(""1"")+1
    res=l*(l-1)//2
    for i in range(n):
        if mask&(1<<i):
            for j in range(n):
                if not mask&(1<<j):

                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)

ans=[]
for i in range(n):
    ans.append(dp[ma-1-(1<<i)])
print(*ans)
",np
"a,b = map(int,input().split())
ans = 0
if(a > b):
    ans += int(a//b)
    a = a%b
while(b!=0):
    ans += int(a//b)
    a,b = b,a%b
print(ans)",O(1)
"def factorial_complexity(n, current=[]):
    if len(current) == n:
        return [current[:]]
    results = []
    for i in range(1, n+1):
        if i not in current:
            current.append(i)
            results.extend(factorial_complexity(n, current))
            current.pop()
    return results",O(n!)
"def permute_unique(elements):
    if len(elements) == 0:
        yield []
    for idx, el in enumerate(elements):
        remaining = elements[:idx] + elements[idx+1:]
        for perm in permute_unique(remaining):
            yield [el] + perm",O(n!)
"import itertools

element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np
"money=input()
initi=money

if int(money)<0:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]
    else:money=money[:-2]+money[-1]
    print(int(money))
else:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]
    else:money=money[:-2]+money[-2]
    if int(initi)>=int(money):
        print(initi)
    else:
        print(money)
",O(1)
"n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]

s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",O(n ^ 2)
"from collections import deque

class Solution(object):

    def __init__(self):
        self.__k = 300
        self.__dq = deque()
        self.__count = 0

    def hit(self, timestamp):
        self.getHits(timestamp)
        if self.__dq and self.__dq[-1][0] == timestamp:
            self.__dq[-1][1] += 1
        else:
            self.__dq.append([timestamp, 1])
        self.__count += 1

    def getHits(self, timestamp):
        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
            self.__count -= self.__dq.popleft()[1]
        return self.__count",O(1)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)",O(nlogn)
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = list(bin(r)[2:]), list(bin(l)[2:])
binl = ['0'] * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        binl = '1' * (len(binl[i:]))
        break

print(int(binl, 2))",O(logn)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:
            m = l + ((r - l) // 2)
            if nums[m] > target:
                r = m
            elif nums[m] <= target:
                l = m + 1
        return l - 1 if (l and nums[l - 1] == target) else -1
",O(logn)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution5(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        uf = UnionFind(len(circles)+2)
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                uf.union_set(u, len(circles))
            if x1+r1 >= X or y1-r1 <= 0:
                uf.union_set(u, len(circles)+1)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                uf.union_set(u, v)
        return uf.find_set(len(circles)) != uf.find_set(len(circles)+1)",O(n ^ 2)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
t=list(map(int,input().split()))
ans=0
m=0
for i in range(n):
    if t[i]:
        ans+=a[i]
        a[i]=0
cf=[0]*(n+1)
for i in range(1,n+1):
    cf[i]=cf[i-1]+a[i-1]
for i in range(n-k+1):
    m=max(m,cf[i+k]-cf[i])
print(ans+m)",O(n)
"movimentos, doces_final = map(int, input().split())
left, right = 0, movimentos + 1

while left < right -1 :
    media = (left + right)//2
    cedidos = (media * (media + 1)) // 2
    comidos = movimentos - media
    if cedidos - comidos > doces_final:
        right = media
    else:
        left = media
print(movimentos - left)",O(logn)
"class Solution2(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            curr += 1
            if i+1 < len(s) and s[i+1] == '0':
                result += curr
        return result",O(n)
"import sys
import argparse
import json

def main():
    n = int(sys.stdin.readline())
    ticket = sys.stdin.readline().rstrip()
    integers = [int(x) for x in ticket]

    zeros = 0
    while zeros < len(integers) and integers[-1*(zeros+1)] == 0:
        zeros += 1

    if zeros > 0 and zeros >= len(integers):
        integers = []
    elif zeros > 0:
        integers = integers[:-1*zeros]

    if not integers:
        print(""YES"")
        return
    if len(integers) == 1:
        print(""NO"")
        return

    total = 0
    for i, val in enumerate(integers[:-1]):
        total += val
        splice = integers[i+1:]
        if is_golden(total, splice):
            print(""YES"")
            return
    print(""NO"")

def is_golden(total, integers):
    current_total = 0

    for i, val in enumerate(integers):
        current_total += val
        if current_total < total:
            continue
        elif current_total == total:

            splice = integers[i+1:]
            return (not splice) or is_golden(total, splice)
        elif current_total > total:
            return False
    return False

def get_tests():
    tests = [(""5\n73452"", ""YES""),
             (""4\n1248"", ""NO""),
             (""4\n7435"", ""NO""),
             (""8\n0020200"", ""YES""),
             (""99\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887"", ""YES""),
             (""84\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090"", ""YES""),
             (""2\n00"", ""YES""),
             (""8\n00020200"", ""YES""),
             (""5\n11980"", ""NO""),
             (""3\n100"", ""NO"")]

    for test in tests:
        print(json.dumps({""input"": test[0], ""output"": test[1]}))

if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--get-tests"", action=""store_true"")
    args = parser.parse_args()

    if args.get_tests:
        get_tests()
    else:
        main()
",O(n ^ 2)
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))

for i in range(n - 1):
    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",O(n ^ 2)
"import math

n_r = list(map(int, input().split()))

n = n_r[0]
radii = n_r[1]

x_list = list(map(int, input().split()))

temp_arr = []
for i in range(n):
    temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j]
                    for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii])
                    )

for i in temp_arr:
    print(i, end= "" "")
",O(n ^ 2)
"class Solution2(object):
    def mostProfitablePath(self, edges, bob, amount):
        def dfs(u, ah):
            lookup[u] = True
            result = 0 if len(adj[u])+(u == 0) == 1 else float(""-inf"")
            bh = 0 if u == bob else float(""inf"")
            for v in adj[u]:
                if lookup[v]:
                    continue
                r, h = dfs(v, ah+1)
                result = max(result, r)
                bh = min(bh, h)
            if ah == bh:
                result += amount[u]//2
            elif ah < bh:
                result += amount[u]
            return result, bh+1

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(0, 0)[0]",O(n)
"class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)",O(n)
"class Solution(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def iter_dfs(u, p, dist):
            result = 0
            stk = [(u, p, dist)]
            while stk:
                u, p, dist = stk.pop()
                if dist%signalSpeed == 0:
                    result += 1
                for v, w in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, dist+w))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = iter_dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"n, k = map(int, input().split())
print((n*2)//k + bool((n*2)%k) + (n*5)//k + bool((n*5)%k) + (n*8)//k + bool((n*8)%k))",O(1)
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1):
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",O(n ^ 2)
"class Solution(object):
    def countVowelStrings(self, n):
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4)",O(1)
"import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:

        if isOn(mask, bit):
            summ.append(dif[bit])

        bit += 1

    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1

    mask += 1

print(count)
",np
"import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True",O(n)
"import sys
def contain(a, b):
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2
def ask(x1, y1, x2, y2, known=(), memo={}):
    if x2 < x1+1 or y2 < y1+1:
        return 0
    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))
    key = (x1+1, y1+1, x2, y2)
    if key in memo:
        return memo[key] - ofs
    print('?', *key)
    sys.stdout.flush()
    memo[key] = int(input())
    return memo[key] - ofs
def binsearch(l, r, p):
    assert l < r
    while l+1 != r:
        m = (l + r) // 2
        if p(m):
            r = m
        else:
            l = m
    return r
def shrink(x1, y1, x2, y2, cnt, known=()):
    assert ask(x1, y1, x2, y2, known=known) == cnt
    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1
    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1
    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)
    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)
    assert ask(x1, y1, x2, y2, known=known) == cnt
    assert ask(x1, y1, x2, y2, known=known) == cnt
    return x1, y1, x2, y2
def go(x1, y1, x2, y2):
    assert ask(x1, y1, x2, y2) == 2
    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)
    a = None
    if not a and x1 < x2:
        if ask(x1+1, y1, x2, y2) == 1:
            a = shrink(x1+1, y1, x2, y2, 1)
        elif ask(x1, y1, x2-1, y2) == 1:
            a = shrink(x1, y1, x2-1, y2, 1)
    if not a and y1 < y2:
        if ask(x1, y1+1, x2, y2) == 1:
            a = shrink(x1, y1+1, x2, y2, 1)
        elif ask(x1, y1, x2, y2-1) == 1:
            a = shrink(x1, y1, x2, y2-1, 1)
    if not a:
        a = x1, y1, x2, y2
        return a, a
    else:
        b = shrink(x1, y1, x2, y2, 1, known=[ a ])
        return a, b
n = int(input())
a, b = go(0, 0, n, n)
ax1, ay1, ax2, ay2 = a
bx1, by1, bx2, by2 = b
print('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)
",O(logn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"from collections import deque


class Solution(object):

    def __init__(self, vec2d):
        self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def __next__(self):
        length, iterator = self.stack.popleft()
        if length > 1:
            self.stack.appendleft((length-1, iterator))
        return next(iterator)

    def hasNext(self):
        return bool(self.stack)",O(1)
"import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)",O(nlogn)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        xorr = n
        for i in range(n):
            xorr ^= i ^ nums[i]
        return xorr
",O(n)
"from collections import deque
with open(""input.txt"",""r"") as input_file:
    with open(""output.txt"",""a"") as output_file:
        N,M = map(int,input_file.readline().split())
        K = int(input_file.readline())
        T = list(map(int,input_file.readline().split()))
        graph = [[0] * (M + 1) for _ in range(N + 1)]
        queue = deque()
        for i in range(0, 2 * K - 1, 2):
            graph[T[i]][T[i + 1]] = 1
            queue.append((T[i], T[i + 1]))
        x, y = 0, 0
        while queue:
            x, y = queue.popleft()
            x_moves = [x - 1, x + 1, x, x]
            y_moves = [y, y, y - 1, y + 1]
            for i in range(len(x_moves)):
                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:
                    if graph[x_moves[i]][y_moves[i]] == 0:
                        x = x_moves[i]
                        y = y_moves[i]
                        graph[x_moves[i]][y_moves[i]] = 1
                        queue.append((x_moves[i], y_moves[i]))
        output_file.write(f""{x} {y}"")",O(n ^ 3)
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):

    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
",np
"n, m = map(int, input().split())
a = [0 for i in range(n)]
l, r = 0, n - 1
m -= 1

for i in range(1, n + 1):
    cur = 2**(n - i - 1)

    if (m >= cur):
        m -= cur
        a[r] = i
        r -= 1
    else:
        a[l] = i
        l += 1

print(*a)
",np
"a = [int(i) for i in input().split()]
n = a[0]
k = a[1]
i = 1
count = 0
cursum = 0
while(count<n):
	if(cursum < k):
		cursum += i
	else:
		break
	count+=1
	i+=1
count += cursum-k
if(n == count):
	print(cursum - k)
else:
	ans = cursum-k
	extra = 0
	while(count<n):
		extra += i
		count+=(i+1)

		i+=1
	print(ans+extra)",O(logn)
"class SegTree:
    def __init__(self, init_val, ide_ele, segfunc):
        self.n = len(init_val)
        self.num = 2**(self.n-1).bit_length()
        self.ide_ele = ide_ele
        self.segfunc = segfunc
        self.seg = [ide_ele]*2*self.num

        for i in range(self.n):
            self.seg[i+self.num] = init_val[i]

        for i in range(self.num-1, 0, -1):
            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])

    def update(self, k, x):
        k += self.num
        self.seg[k] = x
        while k:
            k = k >> 1
            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])

    def query(self, l, r):
        if r <= l:
            return self.ide_ele
        l += self.num
        r += self.num
        lres = self.ide_ele
        rres = self.ide_ele
        while l < r:
            if r & 1:
                r -= 1
                rres = self.segfunc(self.seg[r], rres)
            if l & 1:
                lres = self.segfunc(lres, self.seg[l])
                l += 1
            l = l >> 1
            r = r >> 1
        res = self.segfunc(lres, rres)
        return res

    def __str__(self):
        arr = [self.query(i,i+1) for i in range(self.n)]
        return str(arr)

n = int(input())
S = list(map(int, input().split()))
C = list(map(int, input().split()))
SA = list(set(S))
SA = sorted(SA)
d = {}
for i, s in enumerate(SA):
    d[s] = i
S = [d[s] for s in S]
L = [0]*n
R = [0]*n
INF = 10**18
N = len(d)
seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[0], C[0])
for i in range(1, n-1):
    s = S[i]
    L[i] = seg.query(0, s)
    seg.update(s, C[i])

seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[-1], C[-1])
for i in reversed(range(1, n-1)):
    s = S[i]
    R[i] = seg.query(s+1, seg.n)
    seg.update(s, C[i])

ans = INF
for i in range(1, n-1):
    ans = min(ans, L[i]+C[i]+R[i])
if ans >= INF:
    print(-1)
else:
    print(ans)
",O(n ^ 2)
"import collections


class Solution(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        for nums in nums1, nums2, nums3:
            cnt.update(set(nums))
        return [x for x, c in cnt.items() if c >= K]",O(n)
"n = int(input())
values = list(map(int, input().split()))
queries = int(input())

dp = [[0] * 5009 for i in range(5009)]

for i in range(n):
    dp[0][i] = values[i]

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = top ^ right

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = max(right, max(dp[i][j], top))

for i in range(queries):
    left, right = map(int, input().split())
    last_row = (right - 1) - (left - 1)
    last_column = (left - 1)
    print(dp[last_row][last_column])
",O(n ^ 2)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))
",O(n)
"class Solution(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            return sum(abs(i-x) for i, x in enumerate(x for x, cnt in enumerate(cnt) for _ in range(cnt)))

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])
",O(n ^ 3)
"def count_solutions(n):
    total=0
    def dfs(i, assign):
        nonlocal total
        if i==n:
            a=assign
            ok=(a[0] or (not a[-1])) if n>0 else True
            if ok:
                total+=1
            return
        assign.append(False)
        dfs(i+1, assign)
        assign.pop()
        assign.append(True)
        dfs(i+1, assign)
        assign.pop()
    dfs(0, [])
    return total

print(count_solutions(10))
",O(2 ^ n)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
mx = a[-1]
t = 0
ans = 0;
for i in a:
    if i > 0:
        if i > t:
            t += 1
        ans += i - 1
ans -= mx - t
print(ans)
",O(nlogn)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(1)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,m=inar()
    tup=[]
    sm=0
    for i in range(n):
        a,b=inar()
        sm+=a
        diff=a-b
        tup.append([diff,a,b])
    tup.sort(reverse=True)
    ans=0
    i=0
    while sm>m and i<n:
        sm-=tup[i][1]
        sm+=tup[i][2]
        i+=1
        ans+=1
    if sm<=m:
        print(ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution(object):
    def addRungs(self, rungs, dist):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        result = prev = 0
        for curr in rungs:
            result += ceil_divide(curr-prev, dist)-1
            prev = curr
        return result",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])
",O(n)
"import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        result = 0
        q = collections.deque(initialBoxes)
        while q:
            changed = False
            for _ in range(len(q)):
                box = q.popleft()
                if not status[box]:
                    q.append(box)
                    continue
                changed = True
                result += candies[box]
                for contained_key in keys[box]:
                    status[contained_key] = 1
                for contained_box in containedBoxes[box]:
                    q.append(contained_box)
            if not changed:
                break
        return result",O(n ^ 2)
"def power_set(arr):
    res = []
    path = []
    n = len(arr)
    def backtrack(i):
        if i == n:
            res.append(path.copy())
            return
        backtrack(i+1)
        path.append(arr[i])
        backtrack(i+1)
        path.pop()
    backtrack(0)
    return res

print(power_set([1,2,3]))
",O(2 ^ n)
"import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split())
def listinput(): return list(map(int, input().split()))
n,k=minput()
for i in range(1,n+1):
	if (i*(i+1))/2 -n+i==k:
		print(n-i)
		break",O(logn)
"x,k=map(int,input().split())
if x==0:print(""0"")
else:
    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)
    print(ans)
",O(logn)
"class Solution2(object):
    def numTrees(self, n):
        counts = [1, 1]
        for i in range(2, n + 1):
            count = 0
            for j in range(i):
                count += counts[j] * counts[i - j - 1]
            counts.append(count)
        return counts[-1]",O(n ^ 2)
"class PermutationGenerator:
    def generate(self, elements):
        if len(elements) == 0:
            return [[]]
        results = []
        for i in range(len(elements)):
            current = elements[i]
            remaining = elements[:i] + elements[i+1:]
            subperms = self.generate(remaining)
            for sub in subperms:
                results.append([current] + sub)
        return results",O(n!)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())",O(n ^ 2)
"class Solution(object):
    def minIncrements(self, n, cost):
        result = 0
        for i in reversed(range(n//2)):
            result += abs(cost[2*i+1]-cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return result",O(n)
"vals=list(map(int,input().split()))
l=vals[0]
r=vals[1]

if l==r:
    print(""0"")
else:
    i=0
    j=0
    while l>0 or r>0:
        i+=1
        if (l&1)^(r&1)==1:
            j=i
        l=l>>1
        r=r>>1
    ans=1
    for i in range(0,j):
        ans=ans*2
    ans-=1
    print(ans)",O(logn)
"def is_good(x, n, k):
    y = k - x + 1
    return (y + k * (k - 1) // 2 - y * (y - 1) // 2) >= n

if __name__ == '__main__':
    n, k = [int(x) for x in input().split()]
    if n == 1:
        print(0)
    elif (k + (k - 2) * (k - 1) // 2) < n:
        print(-1)
    elif k >= n:
        print(1)
    else:
        l = 0
        r = k
        while r > l + 1:
            m = (l + r) // 2

            if is_good(m, n, k):
                r = m
            else:
                l = m
        print(r)
",O(logn)
"import itertools



class Solution(object):
    def paintWalls(self, cost, time):
        dp = [float(""inf"")]*(len(cost)+1)
        dp[0] = 0
        for c, t in zip(cost, time):
            for j in reversed(range(1, len(cost)+1)):
                dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c)
        return dp[-1]",O(n ^ 2)
"turns = int(input())
s0 = input()
s1 = input()
s2 = input()

d0 = dict()
d1 = dict()
d2 = dict()

alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
for char in alphabet:
	d0[char] = 0
	d1[char] = 0
	d2[char] = 0

for char in s0:
	d0[char] += 1
for char in s1:
	d1[char] += 1
for char in s2:
	d2[char] += 1

m0 = max([d0[char] for char in alphabet])
m1 = max([d1[char] for char in alphabet])
m2 = max([d2[char] for char in alphabet])

l0 = len(s0)
l1 = len(s1)
l2 = len(s2)

if turns == 1 and m0 == l0:
	score0 = m0 - 1
else:
	score0 = min(l0,m0+turns)

if turns == 1 and m1 == l1:
	score1 = m1 - 1
else:
	score1 = min(l1,m1+turns)

if turns == 1 and m2 == l2:
	score2 = m2 - 1
else:
	score2 = min(l2,m2+turns)

scores = [score0,score1,score2]
bestscore = max(scores)

winnerlist = [i for i in range(3) if scores[i] == bestscore]
if len(winnerlist) > 1:
	print('Draw')
else:
	print(['Kuro','Shiro','Katie'][winnerlist[0]])",O(n)
"s = input()
t = s.count('1')
s = s.replace('1', '')
i = s.find('2')
if i == -1:
    print(s + '1'*t)
else:
    print(s[:i] + '1'*t + s[i:])",O(n)
"class Solution2(object):
    def isFascinating(self, n):
        s = str(n)+str(2*n)+str(3*n)
        return '0' not in s and len(s) == 9 and len(set(s)) == 9",O(logn)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=99999999999999999999999999999999
def outIn(x):
    print(x, flush=True)
    return input()
def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        s=rs()
        d=Counter(s)
        if '1' in d:
            news=""""
            for i in s:
                if i!='1':
                    news+=i
            ans=""""
            ind=len(news)
            for i in range(len(news)):
                if news[i]=='2':
                    ind=i
                    break

            ans=news[0:ind]+'1'*d['1']+news[ind:]
            ws(ans)
        else:
            ws(s)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"def out_edge(x,y):
    a[x] -= 1
    a[y] -= 1
    print(x,y)

n = int(input())
a =list(map(int, input().split()))
sa = sum(a)
ma = min(a)
if (sa <2*(n-1)) or (ma<1):
    print('NO')
    exit()

verts = sorted(enumerate(a,1), key = lambda x: x[1], reverse= True)
verts = [list(j) for j in verts]
outres = []
for kk in range(1,n):
    if  verts[kk-1][1] >= 1:
        outres.append((verts[kk] [0], verts[kk-1][0]))
        verts[kk][1] -= 1
        verts[kk-1][1] -= 1
    else:
        break
else:
    kk+=1

path_len = kk

print('YES', min(n-1, path_len))

reserve_start = 0
while kk < n:
    if verts[reserve_start][1] >0:
        outres.append((verts[reserve_start][0], verts[kk][0]))
        verts[reserve_start][1] -= 1
        verts[kk][1] -= 1
        kk +=1
    else:
        reserve_start += 1

print(len(outres))
for oo in outres:
    print(*oo)
",O(nlogn)
"def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

print(fib(25))
",O(2 ^ n)
"def letter_case_permutations(s):
    res=[]
    chars=list(s)
    n=len(chars)
    def dfs(i, cur):
        if i==n:
            res.append(''.join(cur))
            return
        ch=chars[i]
        if ch.isalpha():
            cur.append(ch.lower())
            dfs(i+1, cur)
            cur.pop()
            cur.append(ch.upper())
            dfs(i+1, cur)
            cur.pop()
        else:
            cur.append(ch)
            dfs(i+1, cur)
            cur.pop()
    dfs(0, [])
    return res

print(len(letter_case_permutations('a1b2c3d')))
",O(2 ^ n)
"class Solution(object):
    def checkArray(self, nums, k):
        curr = 0
        for i, x in enumerate(nums):
            if x-curr < 0:
                return False
            nums[i] -= curr
            curr += nums[i]
            if i-(k-1) >= 0:
                curr -= nums[i-(k-1)]
        return curr == 0",O(n)
"def heap_permutation(n, A):
    if n == 1:
        yield A[:]
    else:
        for i in range(n):
            yield from heap_permutation(n - 1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"n,k = map(int,input().split())
if k>n+n-1:
    print(0)
    exit(0)
if k-1<=n:
    ml = 1
    mr = k-1
    print((mr-ml+1)//2)
else:
    mr = n
    ml = k-n
    print((mr-ml+1)//2)",O(1)
"def power(x , y):
    res = 1
    while y > 0 :
        if y % 2 != 0 :
            res = res * x
        y //= 2
        x *= x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % power(2 , n))

else:
    print(m)
",O(1)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    anagrams = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_anagrams(remaining):
            anagrams.append(char + perm)
    return anagrams",O(n!)
"n,m,k = map(int,input().split())
wh=[]

for j in range(n):
    l=list(map(int,input().split()))
    wh.append(l)

wv=[]

for j in range(n-1):
    l=list(map(int,input().split()))
    wv.append(l)

if(k%2!=0):
    ans = [[-1 for _ in range(m)]for j in range(n)]
    for res in ans:
        print(*res)
else:
    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]
    for x in range(1,21):
        for i in range(1,n+1):
            for j in range(1,m+1):
                dp[i][j][x]=1234567890
                if(i!=n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])
                if(i!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])
                if(j!=m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])
                if(j!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans = 1234567890
            for x in range(1,k+1):
                if(k%x==0 and (k//x)%2==0 ):
                    ans = min(ans,dp[i][j][x]*(k//x))
            print(ans,end="" "")
        print()",O(n ^ 3)
"class Solution2(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return Solution2.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution2(c))
            else:
                node = Solution2(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()",O(n)
"def count_arrangements(n, used=None):
    if used is None:
        used = [False] * n
    if all(used):
        return 1
    count = 0
    for i in range(n):
        if not used[i]:
            used[i] = True
            count += count_arrangements(n, used)
            used[i] = False
    return count",O(n!)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

def isin( x,y, M):
    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:
        return True
    return False

for _ in range(T):
    N, M = getIntList()
    m1 = getIntList()
    m2 = getIntList()
    zx = [0, M]
    zx += [m1[0]-1, m1[2]]
    zx += [m2[0]-1, m2[2]]
    zx.sort()
    zy = [0, N]
    zy += [m1[1]-1, m1[3]]
    zy += [m2[1]-1, m2[3]]
    zy.sort()
    totB = 0
    for i0 in range(5):
        if zx[i0] == zx[i0+1]: continue
        for i1 in range(5):
            if zy[i1] == zy[i1+1]: continue

            x0 = zx[i0]+1
            y0 = zy[i1]+1
            dprint('x0,y0', x0,y0)
            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1])
            if isin(x0,y0, m2):
                dprint('black')
                totB += size
            elif isin(x0,y0, m1):
                dprint('white')
                pass
            else:
                totB+= size//2
                if size%2==1:
                    if (x0+y0)%2==1:
                        dprint('extra black')
                        totB+=1
    print(N*M - totB, totB)
",O(1)
"n = int(input())
if n == 1:
    print(1)
else:
    adj = [[] for i in range(n+10)]
    s = input().split()
    for i in range(2,n+1):
        pi = int(s[i-2])
        adj[i].append(pi)
        adj[pi].append(i)

    num = 1
    curr = [1]
    nextcurr = []
    disco = [1]
    visited = {1:True}
    while num < n:
        for v in curr:
            for w in adj[v]:
                if w not in visited:
                    nextcurr.append(w)
                    visited[w] = True
                    disco.append(w)
                    num += 1
        curr = nextcurr
        nextcurr = []

    nl = {}
    nlvals = {}
    for v in disco[::-1]:
        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)
        nlvals[nl[v]] = nlvals.get(nl[v],0)+1
    colors = {}
    leaves = nlvals[1]
    colors[1] = leaves
    for c in range(2, leaves+1):
        colors[c] = colors[c-1] + nlvals.get(c,0)

    ans = """"
    j = 1
    for i in range(1, n+1):
        while colors[j] < i:
            j += 1
        ans += str(j) + ' '
    print(ans.strip())
",O(n)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(x < k for x in nums)
",O(n)
"
import itertools


class Solution(object):
    def printVertically(self, s):
        return ["""".join(c).rstrip() for c in itertools.zip_longest(*s.split(), fillvalue=' ')]
",O(n)
"from sys import exit
x, k = map(int, input().split())
if x == 0:
    print(0)
    exit(0)
x = 2 * x - 1
mod = 10**9 + 7

def pot(r, k):
    if k == 0: return 1
    if k % 2 == 1:
        return r * pot(r, k - 1) % mod
    y = pot(r, k // 2)
    return y * y % mod

print((pot(2, k) * x + 1) % mod)
",O(logn)
"class Solution:
    def climbStairs(self, n: int) -> int:
        one, two = 1, 1

        for i in range(n - 1):
            temp = one
            one = one + two
            two = temp

        return one
",O(n)
"a=int(input())
if a>0:
    print(a)
else:
    a=a-2*a
    k=a//10
    b=a%10
    c=(a//100)*10+b
    if k<c:
        if k!=0:
            print('-%d' %k)
        else:
            print(k)
    else:
        if c!=0:
            print('-%d' %c)
        else:
            print(c)",O(1)
"
class Solution(object):
    def isPalindrome(self, head):
        reverse, fast = None, head
        while fast and fast.__next__:
            fast = fast.next.__next__
            head.next, reverse, head = reverse, head, head.next

        tail = head.__next__ if fast else head

        is_palindrome = True
        while reverse:
            is_palindrome = is_palindrome and reverse.val == tail.val
            reverse.next, head, reverse = head, reverse, reverse.next
            tail = tail.__next__

        return is_palindrome

",O(n)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            dfs(node.left)
            arr.append(node.val)
            dfs(node.right)

        dfs(root)
        return arr[k - 1]
",O(n)
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()

x = 1
while x <= r:
    x = x << 1
x = x >> 1

k = x
while x <= l or x > r:
    if x <= l:
        x += k
    else:
        x -= k
    k = k >> 1

print(x ^ (x - 1))
",O(logn)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        q = deque()
        if root:
            q.append(root)

        level = 0
        while q:
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            level += 1
        return level
",O(n)
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other):
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)

		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)

for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]

	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",O(n ^ 3)
"
import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):
        TARGET = ""balloon""
        source_count = collections.Counter(text)
        target_count = collections.Counter(TARGET)
        return min(source_count[c]//target_count[c] for c in target_count.keys())
",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

k = li()
k.sort()
k = tuple(k)

ans = [(2,4,4),(3,3,3)]
if k.count(1)>=1:
    print(""YES"")
elif k.count(2)>=2:
    print(""YES"")
elif k.count(3)>=3:
    print(""YES"")
elif k in ans:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)",O(n)
"class Solution(object):
    def findMode(self, root):
        def inorder(root, prev, cnt, max_cnt, result):
            if not root:
                return prev, cnt, max_cnt

            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
            if prev:
                if root.val == prev.val:
                    cnt += 1
                else:
                    cnt = 1
            if cnt > max_cnt:
                max_cnt = cnt
                del result[:]
                result.append(root.val)
            elif cnt == max_cnt:
                result.append(root.val)
            return inorder(root.right, root, cnt, max_cnt, result)

        if not root:
            return []
        result = []
        inorder(root, None, 1, 0, result)
        return result",O(n)
"class Solution(object):
    def minimizeArrayValue(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = curr = 0
        for i, x in enumerate(nums):
            curr += x
            result = max(result, ceil_divide(curr, i+1))
        return result",O(n)
"n=int(input())
print(""0"",""0"",n)",O(1)
"def min_diff(nums):
    best=[float('inf')]
    def dfs(i,s):
        if i==len(nums):
            if abs(s)<best[0]:
                best[0]=abs(s)
            return
        dfs(i+1,s+nums[i])
        dfs(i+1,s-nums[i])
    dfs(0,0)
    return best[0]

print(min_diff([1,6,11,5]))
",O(2 ^ n)
"n=int(input())
l=[-1 for i in range(n+1)]
s=input().split()
ll=[int(i) for i in s]
for i in range(n):
    j=ll[i]
    l[j]=i
res=[""."" for i in range(n+1)]
res[n]=""B""
for i in range(n-1,0,-1):
    toadd=""B""
    pos=l[i]%i
    while pos<n:
        j=ll[pos]
        if j<=i:
            pos+=i
            continue
        if abs(l[i]-l[j])%i==0 and res[j]==""B"":
            toadd=""A""
            break
        pos+=i
    res[i]=toadd
for i in ll:
    print(res[i],end="""")
print("""")
",O(nlogn)
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)",O(1)
"from bisect import bisect_left

if __name__ == ""__main__"":
    n, m = map(int, raw_input().split())
    verticals = [int(raw_input()) for _ in range(n)]
    h = [map(int, raw_input().split()) for _ in range(m)]
    horizontals = [t[1] for t in h if t[0] == 1]

    verticals.sort()
    horizontals.sort()
    verticals.append(10**9)
    min_blockers = n + m
    for i, v in enumerate(verticals):
        cur_blockers = len(horizontals) - bisect_left(horizontals, v) + i
        min_blockers = min(min_blockers, cur_blockers)

    print(min_blockers)
",O(nlogn)
"class Solution4(object):
    def specialArray(self, nums):
        nums.sort(reverse=True) 
        for i in range(len(nums)): 
            if nums[i] <= i:
                break
        else:
            i += 1
        return -1 if i < len(nums) and nums[i] == i else i",O(nlogn)
"n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]

items = [(-l[i]-r[i],i) for i in range(n)]
items.sort()
vals = [1] * n
m = 1
for i in range(1, n):
    if items[i-1][0] != items[i][0]:
        m += 1
    vals[items[i][1]] = m

for i in range(n):
    ln = sum(map(lambda x: x-vals[i] > 0, vals[:i]))
    lr = sum(map(lambda x: x-vals[i] > 0, vals[i:]))
    if ln != l[i] or lr != r[i]:
        print('NO')
        break
else:
    print('YES')
    print(' '.join(str(i) for i in vals))
",O(n ^ 2)
"import sys

n, l, r, x = map(int, input().split())
temp = []
temp = list(map(int, input().split()))

temp.sort()
ans = 0

for i in range(1 << n):
    score = 0
    _min = sys.maxsize
    _max = -sys.maxsize
    for j in range(n):
        if i & (1 << j) > 0:
            _min = min(_min, temp[j])
            _max = max(_max, temp[j])
            score += temp[j]
    if score >= l and score <= r and _max-_min >= x:
        ans += 1

print(ans)
",np
"import math
def solve(n, x, y):
    g = math.gcd(x, y)
    if g != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    p = x + y
    weights = [n // p] * p
    for i in range(p):
        if (i * x) % p < n % p:
            weights[i] += 1
    ans = -n
    for i in range(2):
        dp = [-n, -n]
        dp[i] = 0
        for w in weights:
            dp = [max(dp[0], dp[1]), dp[0] + w]
        ans = max(ans, dp[i])
    return ans

def main():
    n, x, y = [int(x) for x in input().split()]
    print(solve(n, x, y))

main()",np
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0

for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1

print(p)",O(n ^ 2)
"class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Vector:

    def __init__(self, start, end):
        self.x = end.x - start.x
        self.y = end.y - start.y

    def mult(self, a):
        return self.y * a.x - self.x * a.y

n = int(input())
points = []
for i in range(n):
    x, y = map(int, input().split())
    points.append(Point(x, y))

if n <= 3:
    print('YES')
    exit()

def onLine(points):
    n = len(points)
    if n < 3:
        return True
    a = Vector(points[0], points[1])
    for i in range(2, n):
        b = Vector(points[0], points[i])
        if a.mult(b) != 0:
            return False
    return True

tmp = [points[0], points[1]]
oth = []
for i in range(2, n):
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[0], points[2]]
oth = []
for i in range(1, n):
    if i == 2:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[1], points[2]]
oth = []
for i in range(0, n):
    if i == 2 or i == 1:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

print('NO')
",O(nlogn)
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        count = [0] * (n + 1)
        for x in citations:
            if x >= n:
                count[n] += 1
            else:
                count[x] += 1

        h = 0
        for i in reversed(range(0, n + 1)):
            h += count[i]
            if h >= i:
                return i
        return h",O(n)
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return r+1

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()
",O(logn)
"NANS = (False, None)

def is_valid(n, k):
    if n > 31:
        return True
    return k*3 <= (2**(2*n) - 1)

def solve_mini(n, k):
    if not is_valid(n, k):
        return NANS

    if n == 1:
        if k == 1:
            return (True, 0)
        else:
            return (False, None)
    if n == 2:
        if k in [1, 2]:
            return (True, 1)
        if k in [4, 5]:
            return (True, 0)
    return (False, None)

def solve(n, k):
    if n < 3:
        ans, log = solve_mini(n, k)
        return (ans, log)

    if not is_valid(n, k):
        return NANS

    w = 1
    while k >= w and n >= 1:
        k -= w
        n -= 1
        w = w + w + 1
    return(True, n)

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    ans, log = solve(n, k)
    if ans:
        print(""YES"", log)
    else:
        print(""NO"")
",O(logn)
"from collections import namedtuple
import sys

HS = namedtuple('HS', 'x1 x2 y')

n, m = [int(w) for w in input().split()]
vs = [int(input()) for _ in range(n)]
hs = [HS(*[int(w) for w in input().split()]) for _ in range(m)]

vs.sort()

hr = len([s for s in hs if s.x1 == 1 and s.x2 == 10**9])
hs = [s.x2 for s in hs if s.x1 == 1 and s.x2 < 10**9]
hs.sort()

r = hc = len(hs)
hi = vi = 0
for hi in range(hc):
    while vi < n and hs[hi] >= vs[vi]:
        vi += 1
    c = (hc - hi - 1) + vi
    if c < r:
        r = c

print(r + hr)
",O(nlogn)
"import bisect



class Solution2(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = min(left, right)
            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total):
                left -= 1
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"f=input
D,E={},[eval(f())for _ in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",O(n)
"class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        intervals.sort(key=lambda i: i.start)

        for i in range(1, len(intervals)):
            i1 = intervals[i - 1]
            i2 = intervals[i]

            if i1.end > i2.start:
                return False
        return True
",O(nlogn)
"class Solution(object):
    def maxSubarraySumCircular(self, A):
        total, max_sum, cur_max, min_sum, cur_min = 0, -float(""inf""), 0, float(""inf""), 0
        for a in A:
            cur_max = max(cur_max+a, a)
            max_sum = max(max_sum, cur_max)
            cur_min = min(cur_min+a, a)
            min_sum = min(min_sum, cur_min)
            total += a
        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum",O(n)
"class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        mp = defaultdict(int)
        for start, end in intervals:
            mp[start] += 1
            mp[end] -= 1

        res = []
        interval = []
        have = 0
        for i in sorted(mp):
            if not interval:
                interval.append(i)
            have += mp[i]
            if have == 0:
                interval.append(i)
                res.append(interval)
                interval = []
        return res
",O(nlogn)
"def factorial_complexity(n):
    def backtrack(path, choices):
        if len(choices) == 0:
            yield path
            return
        for i in range(len(choices)):
            yield from backtrack(path + [choices[i]], choices[:i] + choices[i+1:])
    return list(backtrack([], list(range(n))))",O(n!)
"n=18

def c(i,p):
    if i==n:
        return 1 if p==0 else 0
    return c(i+1,p) + c(i+1,1-p)

print(c(0,0))
",O(2 ^ n)
"class Solution3(object):
    def sortEvenOdd(self, nums):
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums",O(nlogn)
"class Solution(object):
    def outerTrees(self, points):
        points = sorted(set(tuple(x) for x in points))

        if len(points) <= 1:
            return points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower = []
        for p in points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: 
                lower.pop()
            lower.append(p)

        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: 
                upper.pop()
            upper.append(p)

        result = lower[:-1] + upper[:-1]
        return result if result[1] != result[-1] else result[:len(result)//2+1]",O(nlogn)
"s = input()
ans = 2
s1 = s[0:2]
s2 = s[3:5]
s3 = s[6:8]
def func(inp):
    ans = 2
    num = int(inp[0])
    c = inp[1]
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))
    ans = min( ans, 3 - s.count(inp))
    return ans
ans = min(ans,func(s1))
ans = min(ans,func(s2))
ans = min(ans,func(s3))
print(ans)
",O(n)
"n,m,k = map(int,input().split())
pi = list(map(int,input().split()))
num = 1
ans = 0
i = 0
while i < m:
    temp = (pi[i] - num) // k
    temp2 = i
    i += 1
    while i < m :
        if temp != (pi[i] - num) // k:
            break
        i += 1
    num += (i - temp2)
    ans += 1
print(ans)
",O(n)
"import math

def gaosi(x):
    if (x==1):
        return 1
    else:
        return ((1+x)*x)/2

def calc(mid, total, left):
    return gaosi(mid) - (total - mid) - left

def main():
    x, left = map(int, input().split())
    if (x == 1 and left == 1):
        print(0)
    else:
        l = 1
        r = x
        while (True):
            mid = math.floor((l + r) / 2)
            result = calc(mid, x, left)
            if (result == 0):
                print(x - mid)
                break
            elif (result > 0):
                r = mid
            elif (result  < left):
                l = mid

if __name__ == ""__main__"":
    main()",O(logn)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"def heap_permute(n):
    A = list(range(n))
    def generate(k):
        if k == 1:
            yield A[:]
        else:
            for i in range(k):
                yield from generate(k - 1)
                if k % 2 == 0:
                    A[i], A[k-1] = A[k-1], A[i]
                else:
                    A[0], A[k-1] = A[k-1], A[0]
    return list(generate(n))",O(n!)
"import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())

n = ri(1)
a= ri()

b= sorted(a)
c= dd(int)

ans = 0
val=0
for i in range(n):
	if c[b[i]]==0:
		val+=1
		for j in range(n):
			if b[j]%b[i]==0:
				c[b[j]]=val

for i in c:
	ans = max(ans , c[i])

print(ans)
",O(n ^ 2)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"inp = list(map(int, input().strip().split()))
moves = inp[0]
candiesAtTheEnd = inp[1]

def find(moves, candiesAtTheEnd):
  result = -1
  start = 0
  end = moves-1
  while result!=candiesAtTheEnd:

    mid=((end-start+1)//2)+start

    pluses=moves-mid
    minuses=mid

    result=((pluses+1)/2)*pluses
    result=result-minuses

    if result==candiesAtTheEnd:
      return minuses
    elif result>candiesAtTheEnd:
      start=mid
    else:
      end=mid

result_final=find(moves,candiesAtTheEnd)
print(result_final)
",O(logn)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",O(n ^ 2)
"from sys import stdin, stdout, exit

n, m, k = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))

def bf(a):
    best = 0
    best_arg = (-1, -1)
    for i in range(n):
        for j in range(i, n):
            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)
            if cur > best:
                best = max(best, cur)
                best_arg = (i,j)
    return best, best_arg

def max_sum(a):
    if len(a) == 0:
        return 0
    elif len(a) == 1:
        return max(0, a[0] - k)
    mid = len(a) // 2
    l_rec = max_sum(a[:mid])
    r_rec = max_sum(a[mid:])
    l_bests = [0]*m
    r_bests = [0]*m
    l_sum = 0
    for idx in range(1,mid+1):
        l_sum += a[mid-idx]
        if idx % m == 0:
            l_sum -= k
        l_bests[idx%m] = max(l_bests[idx%m], l_sum)
    r_sum = 0
    for idx in range(0, len(a)-mid):
        r_sum += a[idx+mid]
        if (idx+1) % m == 0:
            r_sum -= k
        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)

    best_acr = 0
    for i in range(m):
        for j in range(m):
            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))
    ans = max(l_rec,r_rec, best_acr)

    return ans

ans = max_sum(a)
stdout.write(str(ans) + ""\n"")
",O(n ^ 2)
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np
"class Solution(object):
    def removeDuplicates(self, S):
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return """".join(result)",O(n)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k = tup()
s , i = S() , 1
while s[i:] != s[:-i] :i+=1
print(s[:i]*k + s[i:])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"n, m = map(int, input().split())
a = []
b = []
while n >= 0:
    a.append(4)
    n -= 4
    b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):

    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import collections


class Solution(object):
    def stoneGameIX(self, stones):
        count = collections.Counter(x%3 for x in stones)
        if count[0]%2 == 0:
            return count[1] and count[2]
        return abs(count[1]-count[2]) >= 3",O(n)
"import collections


class Solution(object):
    def minWindow(self, s, t):
        count, remain = collections.Counter(t), len(t)
        i, left, right = 0, -1, -1
        for j, c in enumerate(s):
            remain -= count[c] > 0
            count[c] -= 1
            if remain:
                continue
            while count[s[i]] < 0: 
                count[s[i]] += 1
                i += 1
            if right == -1 or j-i+1 < right-left+1:
                left, right = i, j
        return s[left:right+1]",O(n)
"def sat(vars, expr):
    from itertools import product
    res=[]
    for vals in product([False, True], repeat=len(vars)):
        env=dict(zip(vars, vals))
        if eval(expr, {}, env):
            res.append(env)
    return res
print(len(sat(['x','y','z','w','u'], '(x or y) and (not w or z)')))
",O(2 ^ n)
"a,b,c,d,e,f=map(int,input().split())
if a<b:a,b=b,a
if c<d:c,d=d,c
if e<f:e,f=f,e
sides=[[a,b,'A'],[c,d,'B'],[e,f,'C']]
sides.sort(reverse=True)
c1,c2,c3=sides[0][2],sides[1][2],sides[2][2]
area=a*b+c*d+e*f
if int(area**0.5)**2!=area:
	print(-1)
else:
	l=int(area**0.5)
	if l not in sides[0]:
		print(-1)
	elif l in sides[1] and l in sides[2]:
		print(l)
		for i in range(3):sides[i].remove(l)
		for i in range(3):
			for _ in range(sides[i][0]):
				print([c1,c2,c3][i]*l)
	else:
		r=l-sides[0][1]
		if r in sides[1] and r in sides[2]:
			print(l)
			for i in range(1,3):sides[i].remove(r)
			for _ in range(sides[0][1]):
				print(c1*l)
			for _ in range(r):
				print(c2*sides[1][0]+c3*sides[2][0])
		else:
			print(-1)",np
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",O(n)
"from bisect import bisect_right as br
from bisect import bisect_left as bl
from math import *

def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)

n = int(input())
a,b = map(int,input().split())
if(mhd(a,b,1,1)<=mhd(a,b,n,n)):
    print('White')
else:
    print('Black')",O(1)
"from collections import Counter
import sys
readline = sys.stdin.readline

def check(A):
    CA = Counter(A)
    if CA[0] >= 2:
        return False
    cnt = 0
    for k, v in CA.items():
        if v > 2:
            return False
        if v == 2 and CA[k-1] >= 1:
            return False
        if v >= 2:
            cnt += 1
    if cnt >= 2:
        return False
    L = len(A)
    if (sum(A) - L*(L-1)//2) % 2 == 0:
        return False
    return True

N = int(readline())
if check(list(map(int, readline().split()))):
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"from math import factorial as fact
s1 = input()
s2 = input()
plus1 = s1.count(""+"")
minus1 = s1.count(""-"")

plus2 = s2.count(""+"")
minus2 = s2.count(""-"")
qCount = s2.count(""?"")

if(plus1==plus2 and minus1==minus2):
	print(1)
else:
	plusReq = plus1 - plus2
	minusReq = minus1 - minus2
	if(plusReq >= 0 and minusReq >= 0):
		ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))
		print(ans)

	else:
		print(0)
",np
"str=input()
n=len(str)
ans=0
amap={}
def fun():
    global ans
    for strLen in range(n,0,-1):
        mark=0
        for t in range(0,n):
            if t+strLen>n:
                break
            s=str[t:t+strLen]
            if s in amap:
                amap[s]+=1
            else:
                amap[s]=1
            if amap[s]>=2:
                mark=1
                ans=len(s)
                print(ans)
                break
        if mark==1:
            break
fun()
if ans==0:
    print(ans)",O(n ^ 3)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",O(n ^ 2)
"n,k=map(int,input().split())
ans=0
ans+=(2*n)//k + bool((2*n)%k!=0)
ans+=(5*n)//k + bool((5*n)%k!=0)
ans+=(8*n)//k + bool((8*n)%k!=0)
print(ans)",O(1)
"s = input()
sLen, ans = len(s), 0

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)",O(n ^ 3)
"import collections
import heapq


class Solution(object):
    def highFive(self, items):
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) > 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]",O(nlogn)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time

starttime = time.time()

mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)

endtime = time.time()
",O(n ^ 3)
"n = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())
if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def numberOfSubarrays(self, nums, k):
        def atMost(nums, k):
            result, left, count = 0, 0, 0
            for right, x in enumerate(nums):
                count += x%2
                while count > k:
                    count -= nums[left]%2
                    left += 1
                result += right-left+1
            return result

        return atMost(nums, k) - atMost(nums, k-1)",O(n)
"N, M, K = map(int, raw_input().split())
A = [int(a) for a in raw_input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)
",O(n ^ 2)
"def factorial_time_sequence(n):
    def backtrack(start, path):
        if len(path) == n:
            yield path[:]
        for num in range(1, n+1):
            if num not in path:
                path.append(num)
                yield from backtrack(start, path)
                path.pop()
    return list(backtrack(1, []))",O(n!)
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque

def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)]
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))

main()",O(n ^ 3)
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	(n, k, count) = total_count(n, k)
	if n:
		print(count+2)
	else:
		print(count+1)",O(logn)
"def max_subset_xor(a):
    best = 0
    n = len(a)
    def dfs(i, x):
        nonlocal best
        if i == n:
            if x > best:
                best = x
            return
        dfs(i + 1, x)
        dfs(i + 1, x ^ a[i])
    dfs(0, 0)
    return best

print(max_subset_xor([5,1,7]))
",O(2 ^ n)
"def gen(n, b):
	a = [(x + b) % 3 for x in range(n)]
	s = """"
	for i in range(n):
		if a[i] == 0:
			s += ""R""
		if a[i] == 1:
			s += ""G""
		if a[i] == 2:
			s += ""B""
	return s

q = int(input())
for _ in range(q):
	n, k = map(int, input().split())
	s = input()
	ans = n
	for xi in range(3):
		t = gen(n, xi)
		diff = 0
		for i in range(k):
			if s[i] != t[i]:
				diff += 1
		ans = min(ans, diff)
		for j in range(k, n):
			if s[j - k] != t[j - k]:
				diff -= 1
			if s[j] != t[j]:
				diff += 1
			ans = min(ans, diff)
	print(ans)",O(n ^ 2)
"n,k = map(int,input().split())
print(-(-k//n))
",O(1)
"def solve(n, v):
    fuel = min(n - 1, v)
    cost = fuel
    for i in range(2, n):
        if fuel >= n - 1:
            break
        fuel += 1
        cost += i
    return cost

n, v = map(int, input().split())
print(solve(n, v))
",O(n)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase
from array import array

def main():
    n,m,k=map(int,input().split())
    left=[array(""i"",map(int,input().split())) for _ in range(n)]
    down=[array(""i"",map(int,input().split())) for _ in range(n-1)]
    dp=[array(""i"",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[array(""i"",[10**8 for _ in range(m)]) for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

j = 0
for i in range(n):
    if j<m and arr2[j]>=arr1[i]:
        j+=1
print(j)
",O(n)
"n, a, b = map(int, input().split())
if (n == 3 or n == 2) and (a == 1 and b == 1):
    print(""NO"")
    exit(0)
g = [[0 for i in range(n)] for j in range(n)]
if a > 1 and b == 1:
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
elif b > 1 and a == 1:
    a, b = b, a
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
    for i in range(n):
        for j in range(n):
            if g[i][j] == 0:
                g[i][j] = 1
            elif g[i][j] == 1:
                g[i][j] = 0
    for i in range(n):
        g[i][i] = 0
elif a == 1 and b == 1:
    for i in range(n - 1):
        g[i][i + 1] = g[i + 1][i] = 1
elif a > 1 and b > 1:
    print(""NO"")
    exit(0)
print(""YES"")
for i in range(n):
    for j in range(n):
        print(g[i][j], end='')
    print()",O(n ^ 2)
"import itertools

def all_binary_vectors(n):
    return list(itertools.product([0, 1], repeat=n))

print(len(all_binary_vectors(12)))
",O(2 ^ n)
"class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True",O(n)
"import itertools


class Solution(object):
    def climbStairs(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]",O(logn)
"from collections import deque

n, m = map(int, input().split())

arr = [int(z) for z in input().split()]

mods = [0 for i in range(m)]
placement = [[] for i in range(m)]

for i in range(n):
    mods[arr[i] % m] += 1
    placement[arr[i] % m].append(i)

cnt = 0
queue = deque()
target = n//m
for i in range(2*m):
    mod = i % m
    if mods[mod] > n//m:

        for c in range(mods[mod] - target):
            queue.append([i, placement[mod][c]])
        mods[mod] = target

    elif mods[mod] < target:
        while len(queue) > 0 and mods[mod] < target:
            elem, indice = queue.popleft()
            mods[mod] += 1
            cnt += (mod - elem) % m
            arr[indice] += (mod - elem) % m

print(cnt)
print(' '.join([str(i) for i in arr]))
",O(n)
"class Solution2(object):
    def numOfWays(self, n):
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in range(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD",O(n)
"def powerset(a):
    res=[]
    n=len(a)
    def dfs(i, cur):
        if i==n:
            res.append(cur[:])
            return
        cur.append(a[i]); dfs(i+1, cur); cur.pop()
        dfs(i+1, cur)
    dfs(0,[])
    return res

print(len(powerset([1,2,3,4,5])))
",O(2 ^ n)
"class Solution2(object):
    def sumImbalanceNumbers(self, nums):
        result = 0
        for right in range(len(nums)):
            lookup = {nums[right]}
            curr = 0
            for left in reversed(range(right)):
                if nums[left] not in lookup:
                    lookup.add(nums[left])
                    curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup)
                result += curr
        return result",O(n ^ 2)
"from math import sqrt, floor, ceil
n = int(input())

ran = list(range(2, 1+n//2))
xx = [ d*(n//d-1)     for d in ran]
print(sum(xx)*4)
",O(n)
"n, U = list(map(int, input().strip().split()))
E = list(map(int, input().strip().split()))

mmax = -1
for i in range(0, n-2):
    j = i + 1
    l = j + 1
    r = n - 1
    while l < r:
        mid = (l + r) // 2
        if E[mid] - E[i] <= U:
            l = mid + 1
        else:
            r = mid - 1
    if E[l] - E[i] <= U:
        cur = (E[l] - E[j]) / (E[l] - E[i])
        mmax = max(mmax, cur)
    else:
        if l - 1 > j and E[l-1] - E[i] <= U:
            cur = (E[l-1] - E[j]) / (E[l-1] - E[i])
            mmax = max(mmax, cur)
print(mmax)
",O(nlogn)
"s = input().split()
s.sort()
if s[0] == s[1] == s[2]:
	print(0)
	exit()
if s[0][1] == s[1][1] == s[2][1]:
	if ord(s[0][0]) + 1 == ord(s[1][0]) == ord(s[2][0]) - 1:
		print(0)
		exit()
if s[0][1] == s[1][1] and ord(s[0][0]) + 2 >= ord(s[1][0]) or s[1][1] == s[2][1] and ord(s[1][0]) + 2 >= ord(s[2][0]) or s[0][1] == s[2][1] and ord(s[0][0]) + 2 >= ord(s[2][0]):
	print(1)
	exit()
if s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:
	print(1)
	exit()
print(2)
",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):
        w = [[c, 0, i] for i, c in enumerate(wells, 1)]
        p = [[c, i, j] for i, j, c in pipes]
        result = 0
        union_find = UnionFind(n+1)
        for c, x, y in sorted(w+p):
            if not union_find.union_set(x, y):
                continue
            result += c
            if union_find.count == 1:
                break
        return result",O(nlogn)
"import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))",O(n)
"def if_spruce(n,l,s):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if i not in s:
            d[l[i]]+=1
    for i in range(1,n+1):
        if i in s and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,a=[0]*2,0
for _ in range(n-1):
    a=int(input())
    l.append(a)
s=set(l)
print(if_spruce(n,l,s))",O(n)
"class Solution3(object):
    def maxFrequencyScore(self, nums, k):
        def check(l):
            return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in range(len(nums)-l+1))

        nums.sort()
        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        left, right = 1, len(nums)
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"def fib(n):
    return n if n<2 else fib(n-1)+fib(n-2)

print(fib(30))
",O(2 ^ n)
"class DoublyLinkedList:
    def __init__(self, val, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        head = DoublyLinkedList(tokens[0])
        curr = head

        for i in range(1, len(tokens)):
            curr.next = DoublyLinkedList(tokens[i], prev=curr)
            curr = curr.next

        while head is not None:
            if head.val in ""+-*/"":
                l = int(head.prev.prev.val)
                r = int(head.prev.val)
                if head.val == '+':
                    res = l + r
                elif head.val == '-':
                    res = l - r
                elif head.val == '*':
                    res = l * r
                else:
                    res = int(l / r)

                head.val = str(res)
                head.prev = head.prev.prev.prev
                if head.prev is not None:
                    head.prev.next = head

            ans = int(head.val)
            head = head.next

        return ans
",O(n)
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",O(n ^ 2)
"k,n,s,p=map(int,input().split())
c=(n//s) if n%s==0 else (n//s)+1
print((c*k)//p if (c*k)%p==0 else ((c*k)//p)+1)
",O(1)
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",O(1)
"class Solution(object):
    def kthLuckyNumber(self, k):
        result = []
        k += 1
        while k != 1:
            result.append('7' if k&1 else '4')
            k >>= 1
        result.reverse()
        return """".join(result)",O(logn)
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,k=nninp()
nos=math.floor(math.sqrt(2*k))
for i in range(nos,12309123):
    if((i*(i+1))//2-k+i==n):
        print((i*(i+1))//2-k)
        exit()
",O(logn)
"n = int(input())
print(n + n // 2)",O(1)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}

i = int(input())
l = []
for x in range(i):
    d.pop(input())

print(len(d))
for i in d.values() : print(i)",O(1)
"import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result",O(n)
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)

def get(x):
    return 1 << (ord(x) - ord('a'))

for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",np
"n,m=map(int,input().split())
l=[]
for i in range(n):
    s=input()
    l.append(s)
minX,minY,maxX,maxY=n,m,0,0
for i in range(n):
    for j in range(m):
        if l[i][j]=='B':
            minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j)
print((minX+maxX)//2+1,(minY+maxY)//2+1)",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums, x):
        target = sum(nums)-x
        result = -1
        curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            while left < len(nums) and curr > target:
                curr -= nums[left]
                left += 1
            if curr == target:
                result = max(result, right-left+1)
        return len(nums)-result if result != -1 else -1",O(n)
"class Solution(object):
    def firstPalindrome(self, words):
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return """"",O(n)
"t=list(map(int,input().split()))
n=t[0]
c=t[1]
a=list(map(int,input().split()))
f=[]
for i in range(0,500001):
	f.append(0)
l=[]
for i in range(0,500001):
	l.append([0])
m=0
for i in range(n):
	l[a[i]].append(f[a[i]]-m)
	if a[i]==c:
		m+=1
	f[a[i]]+=1
	l[a[i]].append(f[a[i]]-m)
ma=0
for i in l:
	mi=0
	for j in i:
		if(j<mi):
			mi=j
		if(ma<j-mi):
			ma=j-mi
print(m+ma)",O(n)
"n=int(input())
if n<3:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    else:
        if n==6:
            print(60)
        elif n%3==0:
            print((n-1)*(n-2)*(n-3))
        else:
            print(n*(n-1)*(n-3))
",O(1)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = collections.defaultdict(lambda: Node(0))
        oldToCopy[None] = None

        cur = head
        while cur:
            oldToCopy[cur].val = cur.val
            oldToCopy[cur].next = oldToCopy[cur.next]
            oldToCopy[cur].random = oldToCopy[cur.random]
            cur = cur.next
        return oldToCopy[head]
",O(n)
"import sys
from collections import Counter

input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))

LIST=[0]*(n+1)

LEAF=[1]*(n+1)
for p in P:
    LEAF[p]=0

for i in range(1,n+1):
    if LEAF[i]==1:
        LIST[i]=1

for i in range(n,1,-1):
    LIST[P[i-2]]+=LIST[i]

counter=Counter(LIST[1:])

SUM=[0]
SC=sorted(counter.keys())

for j in SC:
    SUM.append(SUM[-1]+counter[j])

i=1
j=0
while j<len(SUM):
    if i<=SUM[j]:
        print(SC[j-1],end="" "")
    else:
        j+=1
        continue

    i+=1
",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rightSideView(self, root):
        result = []
        self.rightSideViewDFS(root, 1, result)
        return result

    def rightSideViewDFS(self, node, depth, result):
        if not node:
            return

        if depth > len(result):
            result.append(node.val)

        self.rightSideViewDFS(node.right, depth+1, result)
        self.rightSideViewDFS(node.left, depth+1, result)",O(n)
"class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,x=ria()
        a=ria()
        d=Counter(a)
        sa=set(a)
        if len(sa)<n:
            print(0)
        else:
            c=0
            for i in a:
                k=i&x
                if k!=i and k in d:
                    c=1
                    print(1)
                    break
            if c==0:
                z=[]
                for i in a:
                    z.append(i&x)
                if len(set(z))<n:
                    print(2)
                else:
                    print(""-1"")

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"class Solution2(object):
    def singleNumber(self, A):
        one, two, carry = 0, 0, 0
        for x in A:
            two |= one & x
            one ^= x
            carry = one & two
            one &= ~carry
            two &= ~carry
        return one",O(n)
"class Solution(object):
    def largest1BorderedSquare(self, grid):
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-l+1):
                for j in range(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) >= l:
                        return l*l
        return 0",O(n ^ 3)
"n=int(input())

a=list(map(int,input().split()))
b=list(map(int,input().split()))

s=[0]*n

ans=True

for i in range(n):
    ans=ans and a[i]<=i and b[i]<=(n-i-1)
    s[i]=n-a[i]-b[i]

def qwe(s,j):
    l,r=0,0
    for i in range(len(s)):
        if i<j and s[i]>s[j]: l+=1
        elif i>j and s[i]>s[j]: r+=1
    return l,r

if ans:
    for i in range(n):
        l,r=qwe(s,i)
        ans=ans and a[i]==l and b[i]==r

if ans:
    print('YES')
    for i in range(n):
        print(n-a[i]-b[i],end=' ')
else: print('NO')
",O(n ^ 2)
"class Solution(object):
    def largestAltitude(self, gain):
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result",O(n)
"from queue import Queue
n = int(input())
g = [set() for i in range(n+1)]
for i in range(n-1):
    u, v = map(int, input().split())
    g[u].add(v)
    g[v].add(u)

a = list(map(int, input().split()))
if a[0] != 1:
    print(""No"")
    exit()
ptr = 0
i = 1

while i < n:
    par = a[ptr]
    while len(g[par]) != 0:
        if a[i] not in g[par]:
            print(""No"")
            exit()
        else:
            g[par].remove(a[i])
            g[a[i]].remove(par)
        i += 1
    ptr += 1
print(""Yes"")
",O(n ^ 2)
"n,k=list(map(int,input().split()))
a=list(map(int,input().split()))
b=[]
for i in range(11):
    c={}
    for j in range(n):
        d=(a[j]*(10**i))%k
        if d in c.keys():
            c[d]+=1
        else:
            c[d]=1
    b.append(c)

s=0
for i in range(n):
    c=a[i]%k
    d=(k-c)%k
    if d in b[len(str(a[i]))]:
        s+=b[len(str(a[i]))][d]
    if (a[i]*(10**len(str(a[i]))))%k==d:
        s-=1
print(s)",O(nlogn)
"n, m = map(int, input().split())
A = list(map(int, input().split()))
from collections import Counter
C = Counter(A)

def is_ok(x):
    cnt = 0
    for v in C.values():
        cnt += v//x
    if cnt >= n:
        return True
    else:
        return False

ok = 0
ng = 1000
while ok+1 < ng:
    c = (ok+ng)//2
    if is_ok(c):
        ok = c
    else:
        ng = c
print(ok)
",O(nlogn)
"def binaries(n):
    res=[]
    def rec(i, cur):
        if i==n:
            res.append("""".join(cur))
            return
        cur.append(""0""); rec(i+1, cur); cur.pop()
        cur.append(""1""); rec(i+1, cur); cur.pop()
    rec(0,[])
    return res

print(len(binaries(10)))
",O(2 ^ n)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n + 1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
    e[v][i] = i
    d[i].append(i)
for v in range(1, 2024):
    for i in range(n):
        j = e[v][i]
        h = e[v][j + 1] if j != -1 else -1
        if j != -1 and h != -1:
            e[v + 1][i] = h
            d[i].append(h)

a = [_ for _ in range(1, n + 1)]
for s in range(n):
    for e in d[s]:
        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)
print(a[n - 1])
",O(n ^ 3)
"from sys import stdin
from array import array
def recSolve(dp,r,g,b,rx,gx,bx, R, G, B):
	if rx == R:
		return sum(a * b for a, b in zip(g[gx:], b[bx:]))
	if gx == G:
		return sum(a * b for a, b in zip(r[rx:], b[bx:]))
	if bx == B:
		return sum(a * b for a, b in zip(g[gx:], r[rx:]))
	if dp[rx * G * B + gx * B + bx] != -1:
		return dp[rx * G * B + gx * B + bx]
	rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]
	bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]
	rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]
	ans = max(rg, bg, rb)
	dp[rx * G * B + gx * B + bx] = ans
	return ans
input = stdin.readline
R, G, B = map(int, input().split())
r = sorted([*map(int, input().split())], reverse = True)
g = sorted([*map(int, input().split())], reverse = True)
b = sorted([*map(int, input().split())], reverse = True)
dp = array('q', (-1 for x in range(R * G * B)))
print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,q=map(int,input().split())
x=n+1
l=0
while x>1:
    x//=2
    l+=1
for i in range(q):
    a=int(input())
    s=input()
    for j in s:
        lv=1
        a1=a
        while a1%2==0:
            a1=a1//2
            lv+=1
        x=2**lv
        q=x//2
        p=q//2
        y=(a-q)//x+1
        if j=='U':
            if lv==l:
                pass
            else:
                if y%2:
                    a=(2*a+x)//2
                else:
                    a=(2*a-x)//2
        elif j=='L':
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+z*q
        else:
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+(z+1)*q
    print(a)
",np
"n, k = map(int, input().split())
l = list(map(int, input().split()))
cost = l[n - 1] - l[0]
if k == 1:
	print(cost)
else:
	diff = [0 for _ in range(n - 1)]
	for i in range(n - 1):
		diff[i] = l[i + 1] - l[i]

	diff = sorted(diff)
	diff.reverse()
	print(cost - sum(diff[:k - 1]))",O(nlogn)
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime=[]
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        if (primes[p] == True):
            prime.append(p)
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    return prime
def factors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac

a = input()
b = a.count('1')
a = a.replace('1','')
c = a.find('2')
if c==-1:
    a = (a+ '1'*b)
else:
    a = a[:c]+ '1'*b + a[c:]
print(a)
",O(n)
"class Solution(object):
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1

        for i, integer in enumerate(A):
            if integer != i + 1:
                return i + 1
        return len(A) + 1",O(n)
"import math
n  = int(input())

for i in range(n):
    l,r = [*map(int, input().split())]
    l-=1
    war1 = math.ceil(l/2)
    if(l%2 == 1):
        war1 = -1*war1

    war2 = math.ceil(r/2)
    if(r%2 == 1):
        war2 = -1*war2

    print(war2-war1)",O(1)
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",O(n ^ 3)
"class Solution(object):
    def missingNumber(self, nums):
        return reduce(operator.xor, nums,
                      reduce(operator.xor, range(len(nums) + 1)))",O(n)
"class Solution(object):
    def sortArrayByParity(self, A):
        i = 0
        for j in range(len(A)):
            if A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 1
        return A",O(n)
"x,k=map(int,input().split())
print(((pow(2,k,1000000007)*((2*x-1)%1000000007))%1000000007+1)%1000000007 if x!=0 else 0)
",O(logn)
"import collections



class Solution(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            mn1[x] = min(mn1[x], mn0)+x
            mn0 = min(mn0, curr)
            mn = min(mn, mn1[x], mn0)
        return result",O(n)
"def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count

class CodeforcesTask23ASolution:
    def __init__(self):
        self.result = ''
        self.string = ''

    def read_input(self):
        self.string = input()

    def process_task(self):
        o_max = 0
        for x in range(len(self.string)):
            for y in range(x):
                m = occurrences(self.string, self.string[y:x])
                if m >= 2:
                    o_max = max(x - y, o_max)
        self.result = str(o_max)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask23ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(n ^ 3)
"import collections


class Solution(object):
    def closeStrings(self, word1, word2):
        if len(word1) != len(word2):
            return False 
        
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)  
        return set(cnt1.keys()) == set(cnt2.keys()) and \
               collections.Counter(iter(cnt1.values())) == collections.Counter(iter(cnt2.values()))",O(n)
"import math

line = input().split()
N = int(line[0])
K = int(line[1])

n = (-3 + math.sqrt(9+4*(2*N+2*K)))/2

print(int(N-n))
",O(logn)
"def solve():
    l, r = map(int, input().split())

    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()
",O(logn)
"n, s = list(map(int, input().split()))
num_1 = s // n
if s % n == 0:
    print(num_1)
else:
    print(num_1 + 1)",O(1)
"n=int(input())
if n==1:
    print(1)
else:
    p=list(map(int,input().split()))
    children=[]
    for i in range(n):
        children.append([])
    for i in range(n-1):
        children[p[i]-1].append(i+1)
    layers=[1]+[0]*(n-1)
    layer=[0]
    num=2
    bylayer=[]
    while len(layer)>0:
        bylayer.append(layer)
        newlayer=[]
        for vert in layer:
            for child in children[vert]:
                layers[child]=num
                newlayer.append(child)
        layer=newlayer
        num+=1
    bylayer=bylayer[::-1]
    count=[0]*n
    for layer in bylayer:
        for vert in layer:
            if children[vert]==[]:
                count[vert]=1
            else:
                count[vert]=sum(count[v] for v in children[vert])
    count.sort()
    out=""""
    for guy in count:
        out+=str(guy)+"" ""
    print(out)",O(n ^ 2)
"import math

n,r = [int(x) for x in input().split()]

x = math.sin(math.pi/n)

y = (x*r)/(1-x)

print(y)",O(1)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def minMovesToMakePalindrome(self, s):
        idxs = [[] for _ in range(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in range(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1) 
            bit.add(i, 1)
        return result",O(nlogn)
"def permutation_swap(arr, l, r):
    if l == r:
        print(arr)
    else:
        for i in range(l, r + 1):
            arr[l], arr[i] = arr[i], arr[l]
            permutation_swap(arr, l + 1, r)
            arr[l], arr[i] = arr[i], arr[l]",O(n!)
"import sys
n,d,k=map(int,input().split())
if(n<=d):
    print('NO')
    sys.exit()
if(k==1 and n>2):
    print('NO')
    sys.exit()

edgestot=[]
edges=[[] for i in range(n)]
tovisit=[]
for i in range(d):
    edgestot.append([i,i+1])
    tovisit.append([i+1,min(i+1,d-i-1)])
    edges[i].append(i+1)
    edges[i+1].append(i)
cur=d+1
while(cur<n and len(tovisit)>0):
    x=tovisit.pop()
    if(x[1]==0):
        continue
    while(len(edges[x[0]])<k and cur<n):
        tovisit.append([cur,x[1]-1])
        edgestot.append([cur,x[0]])
        edges[x[0]].append(cur)
        edges[cur].append(x[0])
        cur+=1

if(len(edgestot)==n-1):
    print('YES')
    for i in range(n-1):
        print(edgestot[i][0]+1,edgestot[i][1]+1)

else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):
        curr, max_count = 1, 1
        for i in range(1, len(nums)):
            curr = 1 if nums[i-1] < nums[i] else curr+1
            max_count = max(max_count, curr)
        return K*max_count <= len(nums)",O(n)
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",O(nlogn)
"def letter_case_permutations(s):
    out=[]
    def dfs(i, cur):
        if i==len(s):
            out.append(''.join(cur))
            return
        c=s[i]
        if c.isalpha():
            cur.append(c.lower())
            dfs(i+1, cur)
            cur.pop()
            cur.append(c.upper())
            dfs(i+1, cur)
            cur.pop()
        else:
            cur.append(c)
            dfs(i+1, cur)
            cur.pop()
    dfs(0, [])
    return out
print(letter_case_permutations('a1b2'))
",O(2 ^ n)
"a=sorted(input())

b=int(input())

a=a[::-1]

p=""""

while a:

	for i, z in enumerate(a):

		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))

		if int(n)<=b:

			p+=z

			a.pop(i)

			break

print(p)
",O(n ^ 3)
"import math
s1=input()
s2=input()
s1p=s1.count(""+"")
s1m=s1.count(""-"")
s2p=s2.count(""+"")
s2m=s2.count(""-"")
s2q=0
if '?' in s2:
    s2q=s2.count(""?"")
if s2q==0:
    if s1p==s2p and s1m==s2m:
        print(""%.12f""%1)
    else:
        print(""%.12f""%0)
else:
    if s1p>=s2p and s1m>=s2m:
        s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))
        print(""%.12f""%(s2q/(2**s2.count(""?""))))
    else:
        print(""%.12f""%0)
",np
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",O(logn)
"def gray(n):
    if n==0:
        return ['']
    prev=gray(n-1)
    return ['0'+x for x in prev] + ['1'+x for x in reversed(prev)]
print(gray(3))
",O(2 ^ n)
"_=input()
n=input()
num=int(n)

list_n=list(n)
list_n_int=list(map(int,n))

lower=max(list_n_int)
total=sum(list_n_int)
upper=int(total/2)

flag=False
if lower == 0:
    print(""YES"")
else:
    for i in range(lower,upper+1):
        flag=True
        p=0
        temp=0
        each=i
        seg=total/each
        if seg.is_integer():
            while p < len(n):

                temp+=list_n_int[p]
                if temp < each:
                    p+=1
                elif temp == each:
                    temp=0
                    p+=1
                else:
                    flag=False
                    break
            if flag:
                print(""YES"")
                break
        else:
            flag=False
    if not flag:
        print(""NO"")
",O(n ^ 2)
"a, b, c, n = [int(j) for j in input().split()]
a -= c
b -= c
if n - a - b - c >= 1 and a >= 0 and b >= 0:
    print(n - a - b - c)
else:
    print(-1)
",O(1)
"class Solution3(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        result = 0
        for i in range(len(nums)):
            lookup = set()
            for j in reversed(range(i+1)):
                lookup.add(nums[j])
                result = (result+len(lookup)**2) % MOD
        return result",O(n ^ 2)
"class Solution(object):
    def search(self, reader, target):
        left, right = 0, 19999
        while left <= right:
            mid = left + (right-left)//2
            response = reader.get(mid)
            if response > target:
                right = mid-1
            elif response < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"def powerset(a):
    res=[]
    cur=[]
    def go(i):
        if i==len(a):
            res.append(cur[:])
            return
        go(i+1)
        cur.append(a[i])
        go(i+1)
        cur.pop()
    go(0)
    return res
",O(2 ^ n)
"n, c = map(int, input().split())
cnt = [0] * 500005
ans = 0
for v in map(int, input().split()):
    if v == c:
        cnt[c] = cnt[c] + 1
    else:
        if cnt[v] < cnt[c]:
            cnt[v] = cnt[c]
        cnt[v] += 1
    ans = max(ans, cnt[v] - cnt[c])
print(ans + cnt[c])
",O(n)
"class Solution2(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & ~-n) == 0",O(1)
"class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        while m < n:
            n &= n - 1
        return n",O(1)
"import math

k,n,s,p = input().split()
k = int(k)
n = int(n)
s = int(s)
p = int(p)

sheet_for_each_person = math.ceil(n/s)

total_sheets_required = k*sheet_for_each_person

no_of_packs = math.ceil( total_sheets_required/p )
print(no_of_packs)",O(1)
"class Solution(object):
    def parseBoolExpr(self, expression):
        def parse(expression, i):
            if expression[i[0]] not in ""&|!"":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])",O(n)
"l,r=map(int,input().split())
ls=str(bin(l))[2:]
rs=str(bin(r))[2:]
llog=len(ls)
rlog=len(rs)
ans=0
if llog<rlog:
    z=rlog-1
    while z>-1:
        ans+=2**z
        z-=1
else:
    ct=0
    stringa=""""
    for i in range(len(ls)):
        if ls[i]==rs[i] and ct==0:
            stringa+=ls[i]
        if ls[i]==""0"" and rs[i]==""1"":
            ct+=1
            stringa+=ls[i]
        if ls[i]==""1"" and rs[i]==""0"":
            stringa+=ls[i]
        if ls[i]==rs[i] and ct>0:
            stringa+=str((int(rs[i])+1)%2)
    ans=(int(stringa,2)^r)
print(ans)",O(logn)
"import os
import sys
from io import BytesIO, IOBase
from heapq import *

def main():
    n,x,y=map(int,input().split())
    a,b=[],[]
    for i in range(n):
        u,v=map(int,input().split())
        a.append((u,1))
        a.append((v,-1))
    a.sort(key=lambda x:x[0]*10000000000-x[1])
    mod=10**9+7
    t,z,ans=1,1,x
    for i in range(1,len(a)):
        z+=a[i][1]
        if z<t:
            ans=(ans+t*(a[i][0]-a[i-1][0])*y)%mod
            heappush(b,-a[i][0])
        else:
            if b:
                if x<(a[i][0]+b[0])*y:
                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+x)%mod
                else:
                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+(a[i][0]+b[0])*y)%mod
                    heappop(b)
            else:
                ans = (ans + t * (a[i][0] - a[i - 1][0]) * y + x) % mod
        t=z
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(nlogn)
"max_ = 10**18
arr  = [0, 1]
arr2 = [0, 3]
while arr[-1] < max_:
    arr.append(arr[-1]*4)
    arr2.append(arr2[-1]*2+1)

for i in range(1, len(arr)):
    arr[i] += arr[i-1]

def solve(n, k):
    if n==2 and k==3:
        return 'NO'
    if n==2 and k==4:
        return 'YES 0'
    if n+1<=len(arr) and k > arr[n]:
         return 'NO'

    i=0
    while k >= arr[i+1]:
        i+=1
    if k-arr[i] > arr2[i]:
        i+=1
    return 'YES ' +str(n-i)

for _ in range(int(input())):
    n, k = map(int, input().split())
    print(solve(n, k))",O(logn)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):
        curr = [root]
        while curr:
            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]
        return sum(node.val for node in prev)
",O(n)
"n, A, C = list(map(int, input().split()))

def Ro(x, y):
    return A * x - y + C

huh = []

for i in range(n):
    z, x, y = list(map(int, input().split()))
    huh.append((Ro(x + z, z * A + y), x))
huh = sorted(huh)
anss = 0
c1 = 0
c2 = 0
prev = (-9999999999999, -999999999999999)
g = []

huh.append((-9999999999999, -999999999999999))

for huhh in huh:
    if huhh[0] != prev[0]:
        g.append(c1)

        for j in g:
            anss += (c2 - j) * j
        g = []
        c1 = 1
        c2 = 1
        prev = (huhh[0], huhh[1])
        continue
    c2 += 1
    if huhh[1] != prev[1]:
        g.append(c1)
        c1 = 0
        prev = (huhh[0], huhh[1])
    c1 += 1
print(anss)
",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    kek = [0] * (n - 1)
    for i in range(n - 1):
        kek[i] =  -arr[i + 1] + arr[i]

    kek.sort()

    ans = arr[-1] - arr[0]
    for i in range(k - 1):
        ans += kek[i]

    print(ans)

    return 0

main()",O(nlogn)
"class Solution(object):
    def minOperations(self, nums, k):
        lookup = [False]*k
        for i in reversed(range(len(nums))):
            if nums[i] > len(lookup) or lookup[nums[i]-1]:
                continue
            lookup[nums[i]-1] = True
            k -= 1
            if not k:
                break
        return len(nums)-i",O(n)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = dp2 = 0
        dp1 = 1
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp = 0
            else:
                dp = dp1

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp += dp2
            dp, dp1, dp2 = 0, dp, dp1
        return dp1
",O(n)
"class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",O(n)
"class Solution(object):
    def fixedRatio(self, s, num1, num2):
        lookup = collections.Counter()
        lookup[0] = 1
        result = curr = 0
        for c in s:
            curr += -num2 if c == '0' else +num1
            result += lookup[curr]
            lookup[curr] += 1
        return result",O(n)
"n = int(input())
a = list(map(int, input().split()))

mex = -1
for i in range(n):
    if a[i] <= mex:
        continue
    elif a[i] == mex + 1:
        mex += 1
    else:
        print(i+1)
        exit()
print(-1)",O(n)
"k,n,s,p = map(int,input().split())
print(int((int((n+s-1)/s)*k+p-1)/p))",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def postorderTraversal(self, root):
        dummy = TreeNode(0)
        dummy.left = root
        result, cur = [], dummy
        while cur:
            if cur.left is None:
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    result += self.traceBack(cur.left, node)
                    node.right = None
                    cur = cur.right

        return result

    def traceBack(self, frm, to):
        result, cur = [], frm
        while cur is not to:
            result.append(cur.val)
            cur = cur.right
        result.append(to.val)
        result.reverse()
        return result",O(n)
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",O(nlogn)
"from math import factorial
s = input().strip()
new = input().strip()
questions = 0
plus = s.count('+')
minus = s.count('-')
for i in new:
	if i == '+':
		plus -= 1
	elif i == '-':
		minus -= 1
	else:
		questions += 1
if plus < 0 or minus < 0:
	print(0)
else:
	num = factorial(questions)/(factorial(plus)*factorial(minus))
	den = 2**questions
	print(""{0:.10f}"".format(num/den))",np
"a,b=map(int,input().split(' '))
print((b+a-1)//a)",O(1)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()
k = []
i = 0
while 2 ** i <= 10**18 :
    k.append(2 ** i)
    i+=1

d = {}
s1 = set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in k :
        x = j - i
        y = -1
        try:
            y = d[x]
        except:
            y = -1
        if y != -1:
            if x == i and d[i] == 1:
                continue
            flag = True
            break
    if flag==False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)
",O(nlogn)
"class Solution(object):
    def maxHeightOfTriangle(self, red, blue):
        def f(x, y):
            a, b = int(2*x**0.5)-1, int((4*y+1)**0.5)-1
            return min(a, b)+int(a != b)
        
        return max(f(red, blue), f(blue, red))",O(1)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
lf = [(a[i], i) for i in range(n) if a[i] == 1]
it = [(a[i], i) for i in range(n) if a[i] > 1]
it.sort(reverse=True)
while len(lf) < 2:
    lf.append(it.pop())

ed = []
_, last = lf.pop()

for i in range(len(it)):
    cap, u = it[i]
    if i != 0:
        ed.append((it[i - 1][1], u))
        cap -= 1
    while lf and cap > 1:
        _, l = lf.pop()
        ed.append((u, l))
        cap -= 1

if lf:
    ans = 'NO'
else:
    ans = 'YES %d' % (len(it) + 1,)
    ed.append((it[-1][1], last))
    ans1 = str(len(ed))
    ans2 = '\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)
    ans = '\n'.join([ans, ans1, ans2])
print(ans)
",O(nlogn)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        start = sorted([i.start for i in intervals])
        end = sorted([i.end for i in intervals])

        res = count = 0
        s = e = 0
        while s < len(intervals):
            if start[s] < end[e]:
                s += 1
                count += 1
            else:
                e += 1
                count -= 1
            res = max(res, count)
        return res
",O(nlogn)
"n=int(input())
s=[c=='1' for c in input()]
m=len(s)
z=[[0,0]]
for c in s:
 ind = z[-1][c]
 z[-1][c] = len(z)
 z.append(z[ind][:])
assert(len(z) == m+1)
z[m][0] = z[m][1] = m

dp = [0 for _ in range(m+1)]
dp[0] = 1
for i in range(n):
 ndp = [0 for _ in range(m+1)]
 for i in range(m+1):
  ndp[z[i][0]] += dp[i]
  ndp[z[i][1]] += dp[i]
 dp = ndp
res = dp[m]

for k in range(1, m):
 s0 = 0
 for c in s[-k:]:
  s0 = z[s0][c]
 dp = [0 for _ in range(m+1)]
 dp[s0] = 1
 for i in range(n - k):
  ndp = [0 for _ in range(m+1)]
  for i in range(m+1):
   ndp[z[i][0]] += dp[i]
   ndp[z[i][1]] += dp[i]
  dp = ndp
 for s1 in range(m):
  v = dp[s1]
  for c in s[-k:]:
   if s1 == m: v = 0
   s1 = z[s1][c]
  if s1 == m: res += v
print(res)",np
"n,m = map(int,input().split())
arr1 = [int(i) for i in input().split()]
arr2 = [int(i) for i in input().split()]

for first in arr1:
    for second in arr2:
        if first == second:

            print(first,end="" "")",O(n ^ 2)
"import collections



class Solution(object):
    def minOperations(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        cnt = collections.Counter(nums)
        return sum(ceil_divide(x, 3) for x in cnt.values()) if all(x >= 2 for x in cnt.values()) else -1",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",np
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    p=0
    ans=float('inf')
    for i in range(n):
        turns=ceil((a[i]-i)/n)
        if turns<ans:
            ans=turns
            p=i
    print(p+1)",O(n)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        res = []

        def dfs(node):
            if not node:
                res.append(""N"")
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        self.i = 0

        def dfs():
            if vals[self.i] == ""N"":
                self.i += 1
                return None
            node = TreeNode(int(vals[self.i]))
            self.i += 1
            node.left = dfs()
            node.right = dfs()
            return node

        return dfs()
",O(n)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None

        l1 = head
        while l1 is not None:
            l2 = Node(l1.val)
            l2.next = l1.next
            l1.next = l2
            l1 = l2.next

        newHead = head.next

        l1 = head
        while l1 is not None:
            if l1.random is not None:
                l1.next.random = l1.random.next
            l1 = l1.next.next

        l1 = head
        while l1 is not None:
            l2 = l1.next
            l1.next = l2.next
            if l2.next is not None:
                l2.next = l2.next.next
            l1 = l1.next

        return newHead
",O(n)
"if __name__ == '__main__':
	n = int(input())
	num = n + n//2
	print(num)",O(1)
"n = int(input())
A = list(map(int, input().split()))
if n == 1:
    if A[0] >= 0:
        print(A[0])
    else:
        print(-A[0]-1)
    exit(0)
for i in range(n):
    if A[i] < 0:
        pass
    else:
        A[i] = -A[i]-1
if n % 2 == 0:
    print(*A)
    exit(0)
mim = 0
indmim = 0
for i in range(n):
    if A[i] < mim:
        mim = A[i]
        indmim = i
A[indmim] = -A[indmim]-1
print(*A)
",O(n)
"k,n,s,p=map(int,input().split(' '))
if (1*n)%s==0:
    need=(1*n)//s
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)
else:
    need=((1*n)//s)+1
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)",O(1)
"
class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x < y]
",O(n)
"from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",O(n ^ 2)
"import collections


class Solution2(object):
    def minReorder(self, n, connections):
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)",O(n)
"def really_big(x):
    sum_digit = 0
    digits = x
    while digits > 0:
        sum_digit += digits % 10
        digits = digits // 10

    if x - sum_digit >= s:
        return True
    return False

def solve():
    left = 1
    right = n
    ans = 0
    while left <= right:
        mid = (left + right) // 2
        if really_big(mid):
            right = mid - 1
            ans = n - mid + 1
        else:
            left = mid + 1
    return ans

n, s = map(int, input().split())
print(solve())
",O(logn)
"l1=l2=-1
r1=r2=1<<30
for i in range(int(input())):
 l,r=map(int,input().split())
 if l>l1:il,l1,l2=i,l,l1
 elif l>l2:l2=l
 if r<r1:ir,r1,r2=i,r,r1
 elif r<r2:r2=r
print(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))",O(n)
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",O(1)
"class Solution(object):
    def maxSumAfterOperation(self, nums):
        prev_with_square = prev_without_square = 0
        result = 0
        for num in nums:
            without_square = max(num, num+prev_without_square)
            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)
            result = max(result, with_square)
            prev_with_square, prev_without_square = with_square, without_square
        return result",O(n)
"x, y, z, t1, t2, t3 = map( int, input().split() )
elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3
stairs = t1 * abs( x - y )
if elevator > stairs:
    print( 'NO' )
else:
    print( 'YES' )
",O(1)
"def rotate_90(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[y][x])
        b.append(l)
    return b
def flip(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[x][y])
        b.append(l)
    return b
n=int(input())
l=[]
for i in range(n):
    a=input()
    l2=[]
    for i2 in a:
        l2.append(i2)
    l.append(l2)
l2=[]
for i in range(n):
    a=input()
    l3=[]
    for i2 in a:
        l3.append(i2)
    l2.append(l3)
d='no'
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
l=flip(l)
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
print(d)
",O(n ^ 2)
"class Solution(object):
    def incremovableSubarrayCount(self, nums):
        for j in reversed(range(1, len(nums))):
            if not nums[j-1] < nums[j]:
                break
        else:
            return (len(nums)+1)*len(nums)//2
        result = len(nums)-j+1
        for i in range(len(nums)-1):
            while j < len(nums) and not (nums[i] < nums[j]):
                j += 1
            result += len(nums)-j+1
            if not (nums[i] < nums[i+1]):
                break
        return result",O(n)
"n = int(input())
a = list(map(int,input().split()))
rev = [-1] * (n + 1)
for i, j in enumerate(a):
    rev[j] = i

mx = max(a)

l = a.index(mx)
r = l

for i in range(n - 1, 0, -1):
    idx = rev[i]
    if idx == l - 1:
        l -= 1
    elif idx == r + 1:
        r += 1
    else:
        print('NO')
        exit()
print('YES')",O(n)
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))
",O(n)
"from sys import stdin,stdout,setrecursionlimit
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush,nlargest
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm , accumulate
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
setrecursionlimit(10**9)
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return input()
def num():return int(input())
def L(): return list(sp())
def LF(): return list(spf())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def spf(): return map(int, input.readline().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def pmat2(A):
    for ele in A:
        for j in ele:
            print(j,end='')
        print()
def iseven(n):
    return n%2==0

def seive(r):
    prime=[1 for i in range(r+1)]
    prime[0]=0
    prime[1]=0
    for i in range(r+1):
        if(prime[i]):
            for j in range(2*i,r+1,i):
                prime[j]=0
    return prime

n = int(input())
s = list(input())
t = list(input())
ans = []
for i in range(n):
    for j in range(i,n):
        if s[j] == t[i]:
            for k in range(j, i, -1):
                s[k], s[k-1] = s[k-1], s[k]
                ans.append(k)
            break
if s==t:
    print(len(ans))
    print(' '.join(map(str, ans)))
else:
    print(-1)

endtime = time.time()
",O(n ^ 2)
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t

n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",O(n)
"from math import sin, pi

n, r = map(int, input().split())

print(r * sin(pi / n) / (1 - sin(pi / n)))
",O(1)
"n,m=map(int,input().split())
a=[list('') for x in range(n)]
b=[list('.'*m) for x in range(n)]
start=0

for i in range(n):
    a[i]=list(input())
    if (start==0):
        if ('.' in a[i]):
            start=((i-3)//3) *3
for i in range(start):
    b[i]=list('

for i in range(start,n-2):
    for j in range(m-2):
        ok=True
        if a[i][j]=='
            for y in range(i,i+3):
                if ok==False:
                    break
                for x in range(j,j+3):
                    if not((y==i+1)and(x==j+1)):
                        if a[y][x]!='

                            ok=False
                            break
            if ok:
                for y in range(i,i+3):
                    for x in range(j,j+3):
                        if not((y==i+1)and(x==j+1)):
                            b[y][x]='

if a==b:
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"import math
def max_sub(arr,n):
	dp = [0]*n
	dp[0] = arr[0]
	for i in range(1,n):
		dp[i] = max(dp[i-1]+arr[i],arr[i])
	return max(0,max(dp))
n,m,k = map(int,input().split())
arr = list(map(int,input().split()))
q = -math.inf
dp = [0]*(300100)
for i in range(300100):
	dp[i] = [q]*(11)
if (m==1):
	for i in range(n):
		arr[i]= arr[i]-k
	print(max_sub(arr,n))
else:
	for i in range(n):
		dp[i][1] = arr[i]-k
		for j in range(m):
			if (i-1<0 or dp[i-1][j]==q):
				continue
			if ((j+1)%m!=1):
				dp[i][(j+1)%m] = dp[i-1][j]+arr[i]
			else:
				dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)
	ma=0
	for i in range(n):

		for j in range(m):

			ma = max(ma,dp[i][j])

	print(ma)",O(n ^ 2)
"def solve(n, k, v):
    if(n >= 50):
        print(""YES "" + str(n - 1))
        return
    critical = 1
    excess = 0
    while(n > 0):

        if(excess >= k):
            print(""YES "" + str(n))
            return
        if(critical > k):
            print(""NO"")
            return
        k -= critical
        n -= 1
        excess += (critical * 2 - 1) * v[n]
        critical = (critical * 2 + 1)

    if(excess >= k):
        print(""YES "" + str(n))
        return
    print(""NO"")

v = [0, 1]

for i in range(50):
    a = 1 + 4 * v[-1]
    v.append(a)

t = int(input())

for tcase in range(t):
    inputs = [int(x) for x in input().split()]
    n = inputs[0]
    k = inputs[1]
    solve(n, k, v)
",O(logn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n + 1)]

        for i in range(n - 1, -1, -1):
            for buying in [True, False]:
                if buying:
                    buy = dp[i + 1][False] - prices[i] if i + 1 < n else -prices[i]
                    cooldown = dp[i + 1][True] if i + 1 < n else 0
                    dp[i][1] = max(buy, cooldown)
                else:
                    sell = dp[i + 2][True] + prices[i] if i + 2 < n else prices[i]
                    cooldown = dp[i + 1][False] if i + 1 < n else 0
                    dp[i][0] = max(sell, cooldown)

        return dp[0][1]
",O(n)
"class Solution(object):
    def largestValues(self, root):
        def largestValuesHelper(root, depth, result):
            if not root:
                return
            if depth == len(result):
                result.append(root.val)
            else:
                result[depth] = max(result[depth], root.val)
            largestValuesHelper(root.left, depth+1, result)
            largestValuesHelper(root.right, depth+1, result)

        result = []
        largestValuesHelper(root, 0, result)
        return result",O(n)
"class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False",O(n)
"def traveling_salesman(graph, start):
    from itertools import permutations
    nodes = list(graph.keys())
    nodes.remove(start)
    min_path = float('inf')
    for perm in permutations(nodes):
        current_path = 0
        k = start
        for node in perm:
            current_path += graph[k][node]
            k = node
        current_path += graph[k][start]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
",O(n ^ 3)
"import sys

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10**8
N = 5*10**6

def solve(n):
    arr = []
    while n> 0:
        arr.append(n%2)
        n=n//2
    return arr

l,r = Ri()
arrl = solve(l)
arrr = solve(r)
if len(arrr) > len(arrl):
    ans = (1<<len(arrr))-1
    print(ans)
else:
    ind = -1
    for i in range(len(arrr)-1,-1,-1):
        if arrr[i] != arrl[i]:
            ind = i
            break
    if ind == -1:
        print(0)
    else:
        ans = (1 << (ind+1)) -1
        print(ans)
",O(logn)
"class Solution2(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0} 
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.items():
                for k2, v2 in right.items():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]",O(n)
"def count_xor(nums, k):
    ans = 0
    def dfs(i, x):
        nonlocal ans
        if i == len(nums):
            if x == k:
                ans += 1
            return
        dfs(i + 1, x)
        dfs(i + 1, x ^ nums[i])
    dfs(0, 0)
    return ans

print(count_xor([1, 2, 3, 4], 6))
",O(2 ^ n)
"import sys
from collections import OrderedDict

def sum_from_two(x):

    return x * (x + 1) // 2 - 1

def sum_last(k, x):

    if x == 0:
        return 1

    return sum_from_two(k) - sum_from_two(k - x) - x + 1

def possible(n, k, x):
    return sum_last(k, x) >= n

def main(n, k):
    if n == 1:

        return 0

    if sum_last(k, k - 1) < n:
        return -1

    minimum = 1

    maximum = k - 1
    while minimum <= maximum:
        if minimum == maximum:
            return minimum
        elif minimum == maximum - 1:
            if possible(n, k, minimum):
                return minimum
            else:
                return maximum

        mid = (minimum + maximum) // 2
        if possible(n, k, mid):

            maximum = mid
        else:

            minimum = mid

if __name__ == ""__main__"":
    curr = None
    for e, line in enumerate(sys.stdin.readlines()):
        n, k = list(map(int, line.strip().split()))
    print(main(n, k))
",O(logn)
"n,k = map(int,input().split())
mod = 998244353
dp = [[[0,0]for j in range(2*n+1)] for i in range(n)]
dp[0][0][0] = dp[0][1][1] = 1
for i in range(1,n):
  for j in range(2*n-1):
    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod
    dp[i][j+1][0] += dp[i-1][j][0] % mod
    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod
    dp[i][j][1] += dp[i-1][j][1] %mod
    dp[i][j+2][1] += dp[i-1][j][1] %mod
print(sum(dp[n-1][k-1])*2%mod)",np
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)
",O(n ^ 2)
"class Solution2(object):
    def uniqueXorTriplets(self, nums):
        cnt2, cnt3 = set([0]), set(),  
        max_cnt = 1<<max(nums).bit_length()
        for x in nums:
            for y in cnt2:
                cnt3.add(x^y)
            for y in nums:
                cnt2.add(x^y)
            if len(cnt3) == max_cnt:
                break
        return len(cnt3)",O(n ^ 2)
"import collections



class Solution(object):
    def findWinners(self, matches):
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in range(2)]",O(nlogn)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a*x+b + vy
        dd = a*nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx,vy) not in dc[dd]:
            dc[dd][(vx,vy)] = 0
        dc[dd][(vx,vy)] += 1

    tot = 0
    for v,k in dc.items():
        tt = 0
        pp =0
        for _,cc in k.items():
            tt -= cc * (cc+1) // 2
            pp += cc
        tt += pp * (pp+1) // 2
        tot += tt*2
    print(tot)

if __name__ == '__main__':
    main()
",O(n)
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        left = self.height(root.left)
        right = self.height(root.right)
        if abs(left - right) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)

    def height(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.height(root.left), self.height(root.right))
",O(n ^ 2)
"class Solution(object):
    def strangePrinter(self, s):
        def dp(s, i, j, lookup):
            if i > j:
                return 0
            if (i, j) not in lookup:
                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        lookup[(i, j)] = min(lookup[(i, j)], \
                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))
            return lookup[(i, j)]

        lookup = {}
        return dp(s, 0, len(s)-1, lookup)",O(n ^ 3)
"import collections


class Solution(object):
    def replaceWords(self, dictionary, sentence):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in dictionary:
            reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        def replace(word):
            curr = trie
            for i, c in enumerate(word):
                if c not in curr:
                    break
                curr = curr[c]
                if ""_end"" in curr:
                    return word[:i+1]
            return word

        return "" "".join(map(replace, sentence.split()))",O(n)
"def decimal_to_26(num):
    num = int(num)
    res = ''
    while num:
        mod = num % 26
        if mod == 0:
            res = 'Z' + res
            num = num // 26 - 1
        else:
            num //= 26
            res = chr(mod+64) + res
    return res

def RXCY_to_Excel(c,r):
    new_row = decimal_to_26(r)
    return new_row + str(c)

n = int(input())
li = []
for i in range(n):
    li.append(input())
for i in li:
    di_index = []
    al_index = []
    temp = i
    for j in range(len(i)):
        if i[j].isalpha():
            al_index.append(j)
            i = i.replace(i[j],' ')

        elif i[j].isdigit():
            di_index.append(j)
            i = i.replace(i[j],' ')

    i = temp
    if min(di_index) < max(al_index):

        row = int(i[1:i.index('C')])
        col = int(i[i.index('C')+1:])

        print(RXCY_to_Excel(row,col))
    else:
        row_num = 0
        for k in range(len(i)):
            if i[k].isdigit():
                num_start = k
                break

        length = len(i[0:k])

        for m in range(num_start):
            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)

            length -= 1
        print('R'+i[num_start:]+'C'+str(row_num))
",O(n)
"class Solution(object):
    def countCollisions(self, directions):
        result = cnt = 0
        smooth = 1
        for x in directions:
            if x == 'R':
                cnt += 1
            elif x == 'S' or (cnt or not smooth):
                result += cnt+int(x == 'L')
                cnt = smooth = 0
        return result",O(n)
"l,r=map(int,input().split())
z=l^r
c=0
if(z==0):
    print(0)
    exit()
while(z):
	c+=1;
	z>>=1;
x='1'*c
print(int(x,2))
",O(logn)
"import collections


class Solution(object):
    def tupleSameProduct(self, nums):
        result = 0
        count = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                result += count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return 8*result",O(n ^ 2)
"n,s=map(int,input().split())
degs=[0]*n
for i in range(n-1):
    a,b=map(int,input().split())
    degs[a-1]+=1
    degs[b-1]+=1
print(2*s/degs.count(1))",O(n)
"n,k=map(int,input().split())
s=input();flag=True;lenn=10**10;ans=0
for i in range(n):
  s1=s+s[n-i-1:]*(k-1);cnt=0
  for i in range(len(s1)-len(s)+1):
     if s1[i:i+len(s)]==s:cnt+=1
  if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1)
print(ans)
",O(n ^ 2)
"N, K = list(map(int, input().split()))
S = input().strip()
S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]

def check(x):
    p = [[N for i in range(N+1)] for k in range(K)]

    for k in range(K):
        keep = 0
        for i in range(N-1, -1, -1):
            keep += 1
            if S[i] != -1 and S[i] != k:
                keep = 0
            p[k][i] = p[k][i+1]
            if keep >= x:
                p[k][i] = i + x - 1

    d = [N for s in range(1<<K)]
    d [0] = -1
    for s in range(1, 1<<K):
        for k in range(K):
            if (s&(1<<k)) and (d[s^(1<<k)]<N):
                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])

    return d[(1<<K)-1] < N

l, r = 0, N//K

while l < r:
    mid = (l + r + 1) // 2
    if check(mid):
        l = mid
    else:
        r = mid - 1
print(l)
",np
"import sys
n = int(input())

a = list(map(int,input().split()))

for i in range(n):
    a[i] = [i,a[i]]

a.sort(key=lambda x: x[1],reverse=True)

ans = []

index = 0
cnt = 0
tmp = 1
right_bool = False
left_bool = False

for i in range(1,n):
    if a[index][1] == 0:
        print('NO')
        sys.exit()
    if a[i][1] >= 2:
        ans.append([a[i-1][0],a[i][0]])
        cnt += 1
        a[i-1][1] -= 1
        a[i][1] -= 1
    else:
        if right_bool == False:
            ans.append([a[i-1][0],a[i][0]])
            a[i-1][1] -= 1
            a[i][1] -= 1
            cnt += 1
            right_bool = True
        else:
            ans.append([a[index][0],a[i][0]])
            a[index][1] -= 1
            a[i][1] -= 1
            if left_bool == False:
                cnt += 1
                left_bool = True
            if a[index][1] == 0:
                index += 1

print('YES', cnt)
print(n-1)
for i in range(n-1):
    print(ans[i][0]+1,ans[i][1]+1)",O(nlogn)
"import sys, math
from sys import stdin, stdout

rem = 10 ** 9 + 7
inf=10**18
sys.setrecursionlimit(10 ** 6 + 7)

take = lambda: map(int, stdin.readline().split())
from heapq import heappush, heappop, heapify
from collections import deque
from bisect import *

n,m=take()
arr=take()
check=take()
cnt=[0 for i in range(n+m)]

left=[-1 for i in range(n+m)]
right=[-1 for i in range(n+m)]
prev=-1
for i in range(n+m):
    if check[i]==0:
        left[i]=prev
    else:
        prev=i
prev=-1
for i in range(n+m-1,-1,-1):
    if check[i]==0:
        right[i]=prev
    else:
        prev=i
for i in range(n+m):
    if check[i]==1:
        continue
    a=left[i]
    b=right[i]
    if a==-1 and b==-1:
        continue
    if a==-1 and b!=-1:
        cnt[b]+=1
    if a!=-1 and b==-1:
        cnt[a]+=1
    if a!=-1 and b!=-1:
        if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]):
            cnt[a]+=1
        else:
            cnt[b]+=1
ans=[]
for i in range(n+m):
    if check[i]==1:
        ans.append(str(cnt[i]))
stdout.write(' '.join(ans))
",O(n)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)",O(n ^ 3)
"n = int(input())
print(int(3 * n / 2))",O(1)
"def raschot(d, e, g, h):
    if d > e:
        return 1
    key = d, g, h
    if key in b:
        return b[key]
    f = 0
    for x in (['0', '1'] if a0[d] == '?' else [a0[d]]):
        if d == e:
            a = [x]
        else:
            a = ['0', '1'] if a0[e] == '?' else [a0[e]]
        for y in a:
            if not ((g and x > y) or (h and x == y == '1')):
                f += raschot(d + 1, e - 1, g and x == y, h and x != y)
    b[key] = f
    return f

n, m = map(int, input().split())
m += 1
a0 = ['?'] * n
for i in range(n):
    a0[i] = '0'
    b = {}
    c = raschot(0, n - 1, True, True)
    if m > c:
        m -= c
        a0[i] = '1'
if a0[0] == '0':
    print(''.join(a0))
else:
    print(-1)
",O(n ^ 3)
"s = input()
pb = 0
lenght = len(s)-1
w = []
while(lenght!=0):
    ss = s[pb:pb+lenght]
    w.append(ss)
    if pb+lenght==len(s):
        pb = 0
        lenght -= 1
    else:
        pb+=1
for i in range(0,len(w)-1):
    for j in range(i+1,len(w)):
        if (w[i]==w[j]):
            print(len(w[i]))
            exit(0)
print(0)
",O(n ^ 3)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(1)
"class Solution(object):
    def minimumOperationsToWriteY(self, grid):
        cnt = [[0]*3 for _ in range(2)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1
        return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in range(3) for j in range(3) if i != j)",O(n ^ 2)
"class Solution(object):
    def circularArrayLoop(self, nums):
        def next_index(nums, i):
            return (i + nums[i]) % len(nums)

        for i in range(len(nums)):
            if nums[i] == 0:
                continue

            slow, fast = i, i
            while nums[next_index(nums, slow)] * nums[i] > 0 and \
                  nums[next_index(nums, fast)] * nums[i] > 0 and \
                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:
                slow = next_index(nums, slow)
                fast = next_index(nums, next_index(nums, fast))
                if slow == fast:
                    if slow == next_index(nums, slow):
                        break
                    return True

            slow, val = i, nums[i]
            while nums[slow] * val > 0:
                tmp = next_index(nums, slow)
                nums[slow] = 0
                slow = tmp

        return False",O(n)
"def count_subseq(s, t):
    cnt = 0
    def dfs(i, j):
        nonlocal cnt
        if j == len(t):
            cnt += 1
            return
        if i == len(s):
            return
        dfs(i+1, j)
        if s[i] == t[j]:
            dfs(i+1, j+1)
    dfs(0, 0)
    return cnt

print(count_subseq('abracadabra', 'aba'))
",O(2 ^ n)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                answer[mask] = True
                masks[mask] = path
    for mask_right in range(1 << k):
        if not masks[mask_right]:
            continue
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask_right:
                break
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_left = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask_right:
                    break
                if (mask_right & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_left = mask_left | (1 << u)
                    c += 1
            joint_mask = mask_left | mask_right
            if answer[mask_left] and not answer[joint_mask]:
                answer[joint_mask] = True
                left[joint_mask] = mask_left
                right[joint_mask] = mask_right
                if joint_mask == ((1 << k) - 1):
                    return build_answer(k, masks, left, right)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    return False, None, None

def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for key, val in masks[right[pos]].items():
            c[key] = val[0]
            p[key] = val[1]
        pos = left[pos]
    for key, val in masks[pos].items():
        c[key] = val[0]
        p[key] = val[1]
    return True, c, p

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"n, m = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
ans = [0] * m
p = []
for i in range(n + m):
    if t[i] == 1:
        p.append(i)
ans[0] = p[0]
for i in range(m):
    if i == m - 1:
        ans[i] += n + m - p[i] - 1
    else:
        for j in range(p[i] + 1, p[i + 1]):
            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:
                ans[i] += 1
            else:
                ans[i + 1] += 1
print(' '.join(map(str, ans)))
",O(n ^ 2)
"def main():

    n,m = map(int, input().split())
    S = [list(str(input())) for _ in range(n)]

    L = [[0]*m for _ in range(n)]
    R = [[0]*m for _ in range(n)]
    U = [[0]*m for _ in range(n)]
    D = [[0]*m for _ in range(n)]

    for i in range(n):
        cnt = 0
        for j in range(m):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                L[i][j] = cnt
        cnt = 0
        for j in reversed(range(m)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                R[i][j] = cnt

    for j in range(m):
        cnt = 0
        for i in range(n):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                U[i][j] = cnt
        cnt = 0
        for i in reversed(range(n)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                D[i][j] = cnt

    imosH = [[0]*(m+1) for _ in range(n)]
    imosV = [[0]*m for _ in range(n+1)]
    ans = []
    for i in range(1, n-1):
        for j in range(1, m-1):
            if S[i][j] == '.':
                continue
            l = L[i][j]-1
            r = R[i][j]-1
            u = U[i][j]-1
            d = D[i][j]-1
            s = min([l, r, u, d])
            if s == 0:
                continue
            ans.append((i+1, j+1, s))
            imosV[i-s][j] += 1
            imosV[i+s+1][j] -= 1
            imosH[i][j-s] += 1
            imosH[i][j+s+1] -= 1

    from itertools import accumulate
    for i in range(n):
        imosH[i] = list(accumulate(imosH[i]))
    for j in range(m):
        for i in range(1, n+1):
            imosV[i][j] += imosV[i-1][j]

    for i in range(n):
        for  j in range(m):
            if S[i][j] == '*':
                if imosH[i][j] <= 0 and imosV[i][j] <= 0:
                    print(-1)
                    exit()
    else:
        print(len(ans))
        for i in range(len(ans)):
            print(*ans[i])

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]

    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]

    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]

    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]

    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z

n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))

col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)

    for item in ans:
        print(*item)

def nouse0():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

def nouse3():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

if __name__ == '__main__':
    main()",O(n ^ 3)
"n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=[float('inf')]*(n)
for i in range(1,n):
    mn=float('inf')
    for j in range(i):
        if s[i]>s[j]:
            mn=min(mn,c[i]+c[j])
    dp[i]=mn
res=float('inf')
for i in range(1,n):
    for j in range(i):
        if s[i]>s[j]:
            res=min(res,c[i]+dp[j])
if res==float('inf'):
    res=-1
print(res)
",O(n ^ 2)
"t=int(input())
k=set()
for i in range(1,10**5):
  k.add(4*i*i)
  k.add(2*i*i)
for _ in range(t):
  n=int(input())
  if n in k:
    print('YES')
  else:
    print('NO')",O(1)
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp

x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",O(logn)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"rd = lambda: map(int, input())
def f(n, t):
    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))
    if t < 3:
        rd()
    return a
n = int(input())
m = sorted([f(n, i) for i in range(4)])
print(2 * n * n + m[0] + m[1] - m[2] - m[3])
",O(n ^ 2)
"class Solution(object):
    def largestRectangleArea(self, heights):
        stk, result = [-1], 0
        for i in range(len(heights)+1):
            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
            stk.append(i) 
        return result",O(n)
"def req(a, b, c, d):

    print(f""? {a} {b} {c} {d}"")
    return int(input())

def bin(l, r, down, left, up, right, tp, tar):
    while r - l > 1:
        m = (r + l) // 2

        if tp == 0:
            down = m
        if tp == 1:
            left = m
        if tp == 2:
            up = m
        if tp == 3:
            right = m

        if req(down, left, up, right) == tar:
            l = m
        else:
            r = m
    return [l, r]

def find_rec(x1, y1, x2, y2) -> list:
    up_ = bin(x1 - 1, x2 + 1, x1, y1, -2, y2, 2, 0)[1]
    down_ = bin(x1 - 1, x2 + 1, -2, y1, x2, y2, 0, 1)[0]
    left_ = bin(y1 - 1, y2 + 1, x1, -2, x2, y2, 1, 1)[0]
    right_ = bin(left_ - 1, y2 + 1, x1, y1, x2, -2, 3, 0)[1]
    return [down_, left_, up_, right_]

n = int(input())

l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if req(1, 1, m, n) == 0:
        l = m
    else:
        r = m

rec = []

if r != n and req(r + 1, 1, n, n) == 1:
    rec.append(find_rec(1, 1, r, n))
    rec.append(find_rec(r + 1, 1, n, n))
else:
    l = 0
    r = n + 1
    while r - l > 1:
        m = (l + r) // 2
        if req(1, 1, n, m) == 0:
            l = m
        else:
            r = m
    rec.append(find_rec(1, 1, n, r))
    rec.append(find_rec(1, r + 1, n, n))
print('!', *rec[0], *rec[1])
",O(logn)
"string = input()
totalmax = 0;
for x in range(len(string)):
    curr = """"
    for y in string[x:]:
        curr +=y;
        if string[x:].rfind(curr) != string[x:].find(curr):
            totalmax = max(totalmax, len(curr))
            continue
print(totalmax)",O(n ^ 3)
"

class Solution:
    def toArray(self, node):
        while node.prev:
            node = node.prev
        result = []
        while node:
            result.append(node.val)
            node = node.__next__
        return result
",O(n)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
MAP=[list(input().strip()) for i in range(n)]

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        if MAP[i][j]==""*"":
            T0[i][j]=T0[i-1][j]+1
            Y0[i][j]=Y0[i][j-1]+1

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        if MAP[i][j]==""*"":
            T1[i][j]=T1[i+1][j]+1
            Y1[i][j]=Y1[i][j+1]+1

ANS=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):
        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])
        if score>=2:
            ANS[i][j]=score

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)
        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)
        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)

SUF=[["".""]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:
            SUF[i][j]=""*""

if SUF!=MAP:
    print(-1)
else:
    ANSLIST=[]
    for i in range(n):
        for j in range(m):
            if ANS[i][j]!=0:
                ANSLIST.append((i+1,j+1,ANS[i][j]-1))

    print(len(ANSLIST))
    for ans in ANSLIST:
        print(*ans)
",O(n ^ 2)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    max_val = max(table)
    ind = 0
    while ind < len(table):
        if table[ind] == max_val:
            break
        ind += 1
    cost = (len(table) - ind) + table[ind - 1]

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    return min(table[n - 1], min_cost)

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"n=int(input())
a=list(map(int,input().split()))
ans=0
while len(a)>0:
    c=a.pop(0)
    i=a.index(c)
    ans+=i
    del a[i]
print(ans)",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
s = sorted(a)
q = a.index(max(a))
q1, q = min(len(a)-1, q+1), max(0, q-1)
for q2 in range(len(a)-2, -1, -1):
    if a[q] == s[q2]:
        q = max(0, q-1)
    elif a[q1] == s[q2]:
        q1 = min(len(a)-1, q1+1)
    else:
        print(""NO"")
        break
else:
    print(""YES"")
",O(nlogn)
"class Solution(object):
    def minimumSum(self, n, k):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(k//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)",O(1)
"c = 0
def backtracking(actuales,restantes,l,r,x):
    global c
    if sum(actuales)<=r and sum(actuales) >= l:
        if max(actuales)- min(actuales) >= x:
            c += 1
    if restantes:
        for i in range(len(restantes)):
            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)
    return 0
def main():
    n,l,r,x = input().split("" "")
    n,l,r,x = int(n), int(l), int(r), int(x)
    difficulties = input().split("" "")
    for i in range(len(difficulties)):
        difficulties[i] = int(difficulties[i])
    difficulties.sort()
    backtracking([],difficulties,l,r,x)
    global c
    return c

if __name__ == ""__main__"":
    print(main())",np
"n=int(input())
print(2*(n*(n-1))+1)
",O(1)
"class Solution(object):
    def findComplement(self, num):
        return 2 ** (len(bin(num)) - 2) - 1 - num",O(1)
"def heap_permutation(n, arr):
    if n == 1:
        yield arr[:]
    else:
        for i in range(n):
            yield from heap_permutation(n-1, arr)
            if n % 2 == 0:
                arr[i], arr[n-1] = arr[n-1], arr[i]
            else:
                arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"class Solution(object):
    def minLength(self, s):
        stk = []
        for c in s:
            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):
                stk.pop()
                continue
            stk.append(c)
        return len(stk)",O(n)
"a,b,c,n = map(int,input().split())
if c > a or c > b or (a+b) - c >=n:
    print(-1)
else:
    print(n -((a+b)-c))",O(1)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(logn)
"n=int(input())
if(n<3):
    print(n)
else:

    if(n%2!=0):
        print(n*(n-1)*(n-2))
    elif(n%3==0):
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",O(1)
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -float('inf')
        def dfs(root):
            nonlocal res
            if not root:
                return
            left = self.getMax(root.left)
            right = self.getMax(root.right)
            res =max(res, root.val + left + right)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return res

    def getMax(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        left = self.getMax(root.left)
        right = self.getMax(root.right)
        path = root.val + max(left, right)
        return max(0, path)
",O(n ^ 2)
"from sys import stdin
def get_ints(): return list(map(int, stdin.readline().strip().split()))

n = int(input())
ar = get_ints()

bus = sorted([ (ar[i], i+1) for i in range(n) ])
pa = [int(x) for x in input()]
seq = []

tail = 0
for p in pa:
	if p == 0:
		print(bus[tail][1], end="" "")
		seq.append(tail)
		tail+=1
	else:
		v = seq.pop()
		print(bus[v][1],end="" "")
",O(nlogn)
"def min_partition_diff(a):
    n=len(a)
    total=sum(a)
    best=[abs(total)]
    def dfs(i,acc):
        d=abs(total-2*acc)
        if d<best[0]:
            best[0]=d
        if i==n:
            return
        dfs(i+1,acc+a[i])
        dfs(i+1,acc)
    dfs(0,0)
    return best[0]
print(min_partition_diff([2,7,4,1,8,1]))
",O(2 ^ n)
"n, l, r, x = map(int, input().split())
tasks = [int(i) for i in input().split()]
cnt = 0
for num in range(2 ** n):
    bin_num = bin(num)[2:]
    if len(bin_num) < n:
        bin_num = '0' * (n - len(bin_num)) + bin_num
    m = []
    for i in range(n):
        if bin_num[i] == '1':
            m.append(tasks[i])
    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:
        cnt += 1
print(cnt)",np
"class Solution(object):
    def canMeasureWater(self, x, y, z):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))",O(logn)
"class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])",O(n)
"n, s = map(int, input().split())
print((s + n - 1) // n)",O(1)
"class Solution(object):
    def maxVowels(self, s, k):
        VOWELS = set(""aeiou"")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i >= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def update(i, d):
            if word[i] not in VOWELS:
                curr2[0] += d
                return
            x = ord(word[i])-ord('a')
            if cnt1[x] == 0:
                curr1[0] += 1
            cnt1[x] += d
            if cnt1[x] == 0:
                curr1[0] -= 1

        result = 0
        cnt1, cnt2 = [0]*26, [0]*26
        curr1, curr2 = [0], [0]
        mid = left = 0
        for right in range(len(word)):
            update(right, +1)
            while curr2[0] > k:
                update(left, -1)
                if left < mid:
                    assert(word[left] in VOWELS)
                    cnt2[ord(word[left])-ord('a')] -= 1
                left += 1
                mid = max(mid, left)
            if not (curr1[0] == len(VOWELS) and curr2[0] == k):
                continue
            while word[mid] in VOWELS and cnt1[ord(word[mid])-ord('a')]-(cnt2[ord(word[mid])-ord('a')]+1) >= 1:
                cnt2[ord(word[mid])-ord('a')] += 1
                mid += 1
            result += mid-left+1
        return result",O(n)
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",O(n)
"n = int(input())
a = sorted(map(int , input().split()))
ans = 0
for i in range(n):
    f = 1
    for j in range(i):
        if a[i] % a[j] == 0:
            f = 0
            break
    ans += f
print(ans)",O(n ^ 2)
"class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'",O(nlogn)
"class Solution(object):
    def memLeak(self, memory1, memory2):
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) > x: 
                r -= 1
            return r

        is_swapped = False
        if memory1 < memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]",O(1)
"def binary(n,k,low,high):
    if low<=high:
        mid=(low+high)//2
        if (mid*(mid+1))//2-(n-mid)==k:
            return n-mid
        elif mid*(mid+1)//2-(n-mid)>k:
            return binary(n,k,low,mid-1)
        else:
            return binary(n,k,mid+1,high)

n,k=[int(x) for x in input().split()]
print(binary(n,k,1,n))",O(logn)
"class Solution2(object):
    def goodNodes(self, root):
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max <= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)",O(n)
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N = INT()
xw = [LIST() for _ in range(N)]

rl = []
for x, w in xw:
    rl.append((x-w, x+w))

rl.sort(key = lambda x: (x[1], x[0]))

ans = 0
tmp = -INF

for r, l in rl:
    if r < tmp:
        continue
    ans += 1
    tmp = l

print(ans)
",O(nlogn)
"import heapq


class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):
        max_heap = []
        stations.append((target, float(""inf"")))

        result = prev = 0
        for location, capacity in stations:
            startFuel -= location - prev
            while max_heap and startFuel < 0:
                startFuel += -heapq.heappop(max_heap)
                result += 1
            if startFuel < 0:
                return -1
            heapq.heappush(max_heap, -capacity)
            prev = location

        return result",O(nlogn)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [10**18]*(N+1)
dp2[0] = 0
for i in range(N):
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"l,r = map(int,input().split())
if l%2:
    l+=1
if r-l<2:
    print(-1)
else:
    print(l,l+1,l+2)
",O(1)
"import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):
                return x
        return -1",O(logn)
"import sys
input=sys.stdin.buffer.readline

n=int(input())
a=list(map(int,input().split()))
dp=[[0]*(n) for i in range(n)]
for i in range(n):
    dp[i][i]=a[i]
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]
    count+=1
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])
    count+=1
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",O(n ^ 2)
"class Solution(object):
    def tictactoe(self, moves):
        row, col = [[0]*3 for _ in range(2)], [[0]*3 for _ in range(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return ""AB""[p]
            p ^= 1
        return ""Draw"" if len(moves) == 9 else ""Pending""",O(1)
"MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())

    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))

    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",O(n ^ 3)
"def f(a, b):
    global ans
    maks = max(a, b)
    mins = min(a, b)
    ans += (maks//mins)

    if (mins == 1):
        return ans
    else:
        if (maks % mins == 0):
            return ans
        else:
            return f(maks%mins, mins)
for i in range(int(input())):
    a, b = list(map(int, input().split()))
    ans = 0
    print(f(a, b))",O(1)
"s = [input(), input()]
n = len(s[0])

dp = [[0,0,0] for _ in range(n+1)]

for i in range(n-2,-1,-1):
    dp[i] = [dp[i+1][0]]*3
    vals = [0,0,0,0]
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0':
        vals[0] = dp[i+1][2] + 1
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[1] = dp[i+2][0] + 1
    if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[2] = dp[i+2][0] + 1
    if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0':
        vals[3] = dp[i+1][1] + 1
    dp[i][1] = max(dp[i+1][0], vals[1])
    dp[i][2] = max(dp[i+1][0], vals[2])
    dp[i][0] = max(dp[i][1], dp[i][2], *vals)

result = max(dp[0])
print(result)
",O(1)
"class Solution:
    def climbStairs(self, n: int) -> int:
        cache = [-1] * n
        def dfs(i):
            if i >= n:
                return i == n
            if cache[i] != -1:
                return cache[i]
            cache[i] = dfs(i + 1) + dfs(i + 2)
            return cache[i]

        return dfs(0)
",O(n)
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        head = dummy = ListNode(next=head)
        while head:
            for _ in range(m):
                if not head.__next__:
                    return dummy.__next__
                head = head.__next__
            prev = head
            for _ in range(n):
                if not head.__next__:
                    prev.next = None
                    return dummy.__next__
                head = head.__next__
            prev.next = head.__next__
        return dummy.__next__",O(n)
"n, d, k = map(int, input().split())

if d+1 > n:
    print('NO')
    exit()

ans = []
dist = [0]*n
deg = [0]*n
for i in range(d+1):
    if i == 0 or i == d:
        deg[i] = 1
    else:
        deg[i] = 2
    if i != d:
        ans.append((i+1, i+2))
    dist[i] = max(i, d-i)

for i in range(n):
    if deg[i] > k:
        print('NO')
        exit()

from collections import deque
q = deque(list(range(d+1)))
cur = d+1
while q and cur < n:
    v = q.pop()
    if dist[v] < d and deg[v] < k:
        deg[v] += 1
        dist[cur] = dist[v]+1
        deg[cur] = 1
        ans.append((v+1, cur+1))
        q.append(v)
        q.append(cur)
        cur += 1
    else:
        continue
if cur != n:
    print('NO')
else:
    print('YES')
    for i in range(len(ans)):
        print(*ans[i])
",O(n ^ 2)
"from sys import stdin,stdout
from math import gcd, ceil, sqrt
from itertools import combinations
from collections import Counter
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
mod = 1000000007

n, l, r, x = iia()
arr = iia()
count = 0
for i in range(2, n + 1):
    t = combinations(arr, i)
    for j in t:
        if sum(j) >= l and sum(j) <= r \
            and max(j) - min(j) >= x:
            count += 1
print(count)
",np
"import bisect
n,q=map(int,input().split())
strength=list(map(int,input().split()))
arrows=list(map(int,input().split()))
for i in range(1,n):
    strength[i]+=strength[i-1]
No_arrows=0
n-=1
for i in range(q):
    No_arrows+=arrows[i]
    if(No_arrows>=strength[-1]):
        No_arrows=0
        print(n+1)
    else:
        it=bisect.bisect_left(strength,No_arrows)
        if(strength[it]==No_arrows):
            print(n-it)
        else:
            print(n-it+1)
",O(nlogn)
"class Solution(object):
    def longestSubsequence(self, s, k):
        result, base = 0, 1
        for i in reversed(range(len(s))):
            if s[i] == '0':
                result += 1
            elif base <= k:
                k -= base
                result += 1
            if base <= k:
                base <<= 1
        return result",O(n)
"input = raw_input

def f(n):
    t = (n + 1) // 2
    return t if n % 2 == 0 else -t

for i in range(int(input())):
    le, rg = map(int, input().split())

    print(f(rg) - f(le - 1))
",O(1)
"def check(num):
    l = list(str(num))
    l = list(dict.fromkeys(l))
    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True
    else: return False

lucky = False
n = int(input())
for i in range(3, n+1):
    if n%i==0 and check(i): lucky=True
print(""YES"" if lucky else ""NO"")",O(1)
"class Solver:
    def solve(self):
        self.num_people = int(input())

        if self.num_people % 4 == 2:
            return -1

        return self.find_zero_pair()

    def find_zero_pair(self):
        begin = 1
        end = self.num_people // 2 + 1

        begin_value = self.func(begin)
        if begin_value == 0:
            return begin

        while begin < end:
            mid = (begin + end) // 2
            mid_value = self.func(mid)
            if mid_value == 0:
                return mid
            elif begin_value * mid_value > 0:
                begin = mid + 1
            else:
                end = mid - 1

        return begin

    def func(self, pos):
        opposite = (pos - 1 + self.num_people // 2) % self.num_people + 1
        return self.get_value(pos) - self.get_value(opposite)

    def get_value(self, pos):
        print('? {}'.format(pos))
        value = int(input())
        return value

solver = Solver()
pair = solver.solve()
print('! {}'.format(pair))
",O(logn)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",O(1)
"num=int(input())

a=input()

b=input()

dic={}

lis=[]

ham=0

swap1=-1

swap2=-1

p=False

q=False

for i in range(num):

    if a[i]!=b[i]:

        ham+=1

        lis.append(i)

        dic[b[i]]=i

for i in lis:

    if a[i] in dic:

        p=True

        swap1=i+1

        f=dic[a[i]]

        swap2=f+1

        if a[f]==b[i]:

            q=True

            break

print(ham-(2 if q else 1 if p else 0))

print(swap1,swap2)
",O(n)
"class Solution2(object):
    def maximumSumScore(self, nums):
        total = sum(nums)
        prefix = 0
        result = float(""-inf"")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result",O(n)
"t=1
for _ in range(t):
    n=int(input())
    l=list(map(int,input().split()))
    dp=[[0 for j in range(n)] for i in range(n)]
    for i in range(n):
        dp[0][i]=l[i]
    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=dp[i-1][j]^dp[i-1][j+1]

    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j+1])

    q=int(input())
    for __ in range(q):
        x,y=map(int,input().split())
        x-=1
        y-=1
        print(dp[y-x][x])",O(n ^ 2)
"n=int(input())
i=iter(sorted(zip(map(int,input().split()),range(1,n+1))))
s,o=[],[]
for c in input():
 if c=='0':
  x=next(i)[1];o+=[x];s+=[x]
 else:o.append(s.pop())
print(*o)
",O(nlogn)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",O(n ^ 2)
"
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child


class Solution(object):
    def flatten(self, head):
        curr = head
        while curr:
            if curr.child:
                curr_next = curr.__next__
                curr.child.prev = curr
                curr.next = curr.child
                last_child = curr
                while last_child.__next__:
                    last_child = last_child.__next__
                if curr_next:
                    last_child.next = curr_next
                    curr_next.prev = last_child
                curr.child = None
            curr = curr.__next__
        return head

",O(n)
"class Solution3(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        H, W = 0, 1
        table = [[[0, 0] for j in range(len(matrix[0]))] \
                         for i in range(len(matrix))]
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == '1':
                    h, w = 1, 1
                    if i + 1 < len(matrix):
                        h = table[i + 1][j][H] + 1
                    if j + 1 < len(matrix[i]):
                        w = table[i][j + 1][W] + 1
                    table[i][j] = [h, w]

        s = [[0 for j in range(len(matrix[0]))] \
                for i in range(len(matrix))]
        max_square_area = 0
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                side = min(table[i][j][H], table[i][j][W])
                if matrix[i][j] == '1':
                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                        side = min(s[i + 1][j + 1] + 1, side)
                    s[i][j] = side
                    max_square_area = max(max_square_area, side * side)

        return max_square_area",O(n ^ 2)
"class Solution(object):
    def maxPower(self, s):
        result, count = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result",O(n)
"class Solution2(object):
    def getMaximumGenerated(self, n):
        if n == 0:
            return 0
        nums = [0]*(n+1)
        nums[1] = 1
        result = 1
        for i in range(2, n+1):
            if i%2 == 0:
                nums[i] = nums[i//2]
            else:
                nums[i] = nums[i//2] + nums[i//2+1]
            result = max(result, nums[i])
        return result",O(n)
"from math import sqrt

a, v = map(int, input().split())
l, d, w = map(int, input().split())

def findt(u, v, a, dist):
	front = (v*v-u*u)/(2*a)
	if front > dist:
		return (sqrt(u*u+2*a*dist)-u)/a
	return (v-u)/a + (dist-front)/v

def solve(a, v, l, d, w):
	if v <= w or 2*a*d <= w*w:
		return findt(0, v, a, l)
	after = findt(w, v, a, l-d)
	peak = sqrt(a*d + w*w/2)
	if peak > v:
		travel = (v*v-w*w/2)/a
		before = (2*v-w)/a + (d-travel)/v
	else:
		before = (2*peak-w)/a
	return before + after

print(f'{solve(a, v, l, d, w):.8f}')",O(1)
"import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result",O(n)
"import sys
readline = sys.stdin.readline

N = int(readline())
M = float(readline())
A = list(map(int, readline().split()))
B = list(map(int, readline().split()))
B = B[1:] + [B[0]]
C = []
for a, b in zip(A[::-1], B[::-1]):
    C.append(b)
    C.append(a)

if 1 in C:
    print(-1)
else:
    M0 = M
    for c in C:
        M += M/(c-1)

    print(M-M0)",O(n)
"class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev, curr = None, head

        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        return prev
",O(n)
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n, m = map(int, input().split())

MAX = 0
MIN = 10**18
for i in range(n):
    l = i*(i+1)//2
    r = (n-1-i)*(n-1-i+1)//2
    MAX= max(MAX, l+r)
    MIN = min(MIN, l+r)

ans = 0
for i in range(m):
    x, d = map(int, input().split())
    ans += n*x
    if d  >= 0:
        ans += d*MAX
    else:
        ans += d*MIN
print(ans/n)
",O(n)
"n, m = int(input()), int(input())
print(m % (2 ** n) if n < 30 else m)",O(1)
"a=[int(x) for x in input().split()]
n=a[0]^a[1]
x=bin(n)[2:]

f=0
for i in range(len(x)):
    if x[i]=='1':
        f=1
        break
l=len(x)-i
sum=0
for i in range(l):
   sum+=2**i
if f==0:
    sum=0
print(sum)",O(logn)
"class Solution(object):
    def maxKDivisibleComponents(self, n, edges, values, k):
        def bfs():
            result = 0
            dp = [x%k for x in values]
            cnt = [len(adj[u]) for u in range(len(adj))]
            q = [u for u in range(n) if cnt[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if not dp[u]:
                        result += 1
                    for v in adj[u]:
                        dp[v] = (dp[v]+dp[u])%k
                        cnt[v] -= 1
                        if cnt[v] == 1:
                            new_q.append(v)
                q = new_q
            return max(result, 1)

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs()",O(n)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"class UnionFind(object): 
    def __init__(self, nums):
        self.set = list(range(len(nums)))
        self.rank = [0]*len(nums)
        self.size = nums[:]

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]



class Solution(object):
    def maximumSegmentSum(self, nums, removeQueries):
        result = [0]*len(removeQueries)
        lookup = [0]*len(nums)
        uf = UnionFind(nums)
        for i in reversed(range(1, len(removeQueries))): 
            q = removeQueries[i]
            lookup[q] = 1
            if q-1 >= 0 and lookup[q-1]:
                uf.union_set(q-1, q)
            if q+1 < len(nums) and lookup[q+1]:
                uf.union_set(q, q+1)
            result[i-1] = max(result[i], uf.total(q))   
        return result",O(n)
"import collections



class Solution_TLE(object):
    def maxSubarraySum(self, nums):
        MAX, TOTAL, PREFIX, SUFFIX = list(range(4))
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            return [nums[i]]*4
        
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            return [max(x[MAX], y[MAX], x[SUFFIX]+y[PREFIX]),
                    x[TOTAL]+y[TOTAL],
                    max(x[PREFIX], x[TOTAL]+y[PREFIX]),
                    max(y[SUFFIX], x[SUFFIX]+y[TOTAL])]

        mx = max(nums)
        if mx < 0:
            return mx
        mn = min(nums)
        if mn >= 0:
            return sum(nums)
        groups = collections.defaultdict(list)
        for i, x in enumerate(nums):
            groups[x].append(i)
        st = SegmentTree(len(nums), build_fn=build, query_fn=query)
        result = st.tree[1][0] 
        for k, v in groups.items():
            for i in v:
                st.update(i, None)
            result = max(result, st.tree[1][0]) 
            for i in v:
                st.update(i, [k]*4)
        return result",O(nlogn)
"import itertools

n = int(input())
boards = []
for i in range(4):
    boards.append([])
    for j in range(n):
        boards[-1].append(list(map(int, list(input()))))
    if i < 3: input()

ans = n * n * 4

def check_board(corner, board):
    ans = 0
    for i in range(n):
        for j in range(n):
            if board[i][j] != corner:
                ans += 1
            corner = 1 - corner
    return ans

def solve(corner, p):
    ans = check_board(corner, boards[p[0]])
    ans += check_board(1- corner, boards[p[1]])
    ans += check_board(1 - corner, boards[p[2]])
    ans += check_board(corner, boards[p[3]])

    return ans

for p in itertools.permutations(range(4), 4):
    ans = min(ans, solve(1, p))
    ans = min(ans, solve(0, p))

print(ans)",O(n ^ 2)
"class Solution(object):
    def xorQueries(self, arr, queries):
        for i in range(1, len(arr)):
            arr[i] ^= arr[i-1]
        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]",O(n)
"def all_permutations(data):
    if len(data) <= 1:
        return [data]
    perms = []
    for i, elem in enumerate(data):
        remaining = data[:i] + data[i+1:]
        for perm in all_permutations(remaining):
            perms.append([elem] + perm)
    return perms",O(n!)
"import sys
def ask(i):
    print('?', i + 1)
    sys.stdout.flush()
    a_i = int(input())
    return a_i
def answer(i):
    print('!', i + 1 if i != -1 else -1)
    sys.exit()

def has_intersection(l1, r1, l2, r2):
    if l1 <= l2 and r2 <= r1:
        return True
    if l2 <= l1 and r1 <= r2:
        return True
    return False

n = int(input())
assert n >= 2 and n % 2 == 0
if (n // 2) % 2 == 1:
    answer(-1)
else:
    assert n % 4 == 0
    l1 = 0
    r1 = n // 2
    a_l1 = ask(l1)
    a_r1 = ask(r1)
    if a_l1 == a_r1:
        answer(0)
    a_l2 = a_r1
    a_r2 = a_l1

    while True:
        m1 = (l1 + r1) // 2
        m2 = (m1 + n // 2) % n
        a_m1 = ask(m1)
        a_m2 = ask(m2)
        if a_m1 == a_m2:
            answer(m1)
        if has_intersection(a_l1, a_m1, a_l2, a_m2):
            r1 = m1
            a_r1 = a_m1
            a_r2 = a_m2
        else:
            assert has_intersection(a_m1, a_r1, a_m2, a_r2)
            l1 = m1
            a_l1 = a_m1
            a_l2 = a_m2

assert False
",O(logn)
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])
",O(logn)
"import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0
        for i in range(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.values():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in range(len(coeff)):
                for k in range(i+1):
                    if k+j >= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in range(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result",O(n ^ 2)
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",O(n ^ 2)
"class Solution2(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        r1, r2 = n//2-d1, n//2-d2
        return d1+d2+min(r1+r2, c)",O(n)
"import sys
from itertools import chain, combinations

def powerset(iterable):
	s = list(iterable)
	return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def diff(s, x):
	return True if (max(s)-min(s))>=x else False

def solve(problemset, l, r, x):
	multiset = powerset(problemset)
	cnt = 0
	for s in multiset:
		if sum(s)>=l and sum(s)<=r and diff(s, x):
			cnt += 1
	return cnt

sys.setrecursionlimit(10**7)

def I(): return int(sys.stdin.readline().rstrip())
def MI():return map(int, sys.stdin.readline().rstrip().split())
def LI():return list(map(int, sys.stdin.readline().rstrip().split()))
def LI2():return list(map(int, sys.stdin.readline().rstrip()))
def S():return sys.stdin.readline().rstrip()
def LS():return list(sys.stdin.readline().rstrip().split())
def LS2():return list(sys.stdin.readline().rstrip())

n, l, r, x = MI()

problemset = LI()

print(solve(problemset, l, r, x))",np
"class Solution(object):
    def longestPrefix(self, s):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        return s[:getPrefix(s)[-1]+1]",O(n)
"class Solution_TLE(object):
    def countPrimes(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes
    
        return len(linear_sieve_of_eratosthenes(n-1))",O(n)
"import sys
input=sys.stdin.readline
al=list(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"")
n=int(input())
s=[input().rstrip() for i in range(3)]
l=len(s[0])
ans=[0]*3
for c in al:
    for i in range(3):
        cnt_c=s[i].count(c)
        if cnt_c+n<=l:
            ans[i]=max(ans[i],cnt_c+n)
        else:
            if n==1 and l==cnt_c:
                ans[i]=max(ans[i],l-1)
            else:
                ans[i]=l
if (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):
    print(""Draw"")
elif max(ans)==ans[0]:
    print(""Kuro"")
elif max(ans)==ans[1]:
    print(""Shiro"")
else:
    print(""Katie"")",O(n)
"n = int(input())
ax,ay = list(map(int,input().split()))
bx,by = list(map(int,input().split()))
cx,cy = list(map(int,input().split()))

if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeElements(self, head, val):
        dummy = ListNode(float(""-inf""))
        dummy.next = head
        prev, curr = dummy, dummy.__next__

        while curr:
            if curr.val == val:
                prev.next = curr.__next__
            else:
                prev = curr

            curr = curr.__next__

        return dummy.__next__



",O(n)
"from operator import itemgetter

class CodeforcesTask528BSolution:
    def __init__(self):
        self.result = ''
        self.n = 0
        self.points = []

    def read_input(self):
        self.n = int(input())
        for _ in range(self.n):
            self.points.append([int(x) for x in input().split("" "")])
            self.points[-1].append(sum(self.points[-1]))

    def process_task(self):
        self.points.sort(key=itemgetter(2))
        last = 0
        ans = 1
        for i in range(1, self.n):
            if self.points[i][0] - self.points[i][1] >= self.points[last][0] + self.points[last][1]:
                last = i
                ans += 1
        self.result = str(ans)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask528BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(nlogn)
"class Solution(object):
    def numDupDigitsAtMostN(self, N):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(N+1)))
        result = 0

        for i in range(1, len(digits)):
            result += P(9, 1)*P(9, i-1)
        prefix_set = set()
        for i, x in enumerate(digits):
            for y in range(1 if i == 0 else 0, x):
                if y in prefix_set:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in prefix_set:
                break
            prefix_set.add(x)
        return N-result",O(logn)
"class Solution(object):
    def isCircularSentence(self, sentence):
        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in range(len(sentence)) if sentence[i] == ' ')",O(n)
"def prime(n):
    j = 3
    while j * j <= n:
        if n % j == 0:
            return False
        j += 2
    return True
ref = [2]
for j in range(3, 1000, 2):
    if prime(j) == True:
        ref.append(j)
def check(n):
    for j in range(1, len(ref) - 1):
        v = n - ref[j] - 1
        if ref[j - 1] == v or ref[j + 1] == v:
            return True
        if j > n:
            break
    return False
arr = []
for j in range(3, 1001, 2):
    if prime(j) == True and check(j) == True:
        arr.append(j)
n, k = [int(j) for j in input().split()]
count = 0
for j in range(2, n + 1):
    if j in arr:
        count += 1
if count >= k:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"def min_diff(arr):
    best=[float('inf')]
    def dfs(i, a, b):
        if i==len(arr):
            d=abs(a-b)
            if d<best[0]:
                best[0]=d
            return
        dfs(i+1, a+arr[i], b)
        dfs(i+1, a, b+arr[i])
    dfs(0,0,0)
    return best[0]
print(min_diff([5,6,7,8,9]))
",O(2 ^ n)
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
a=a[::-1]
c=[0]*n
bk=[]
for i in range(n):
    co=0
    if c[b[i]-1]==0:
        while a[-1]!=b[i]:
            co+=1
            c[a[-1]-1]=1
            a.pop()
        co+=1
        c[a[-1]-1]=1
        a.pop()
    bk.append(co)
print(*bk)
",O(n)
"import random
import collections



class Solution(object):
    def minCost(self, basket1, basket2):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        cnt = collections.Counter()
        for x in basket1:
            cnt[x] += 1
        for x in basket2:
            cnt[x] -= 1
        mn = min(cnt.keys())
        swaps = []
        for k, v in cnt.items():
            if v%2:
                return -1
            swaps.extend(k for _ in range(abs(v)//2))
        nth_element(swaps, len(swaps)//2)
        return sum(min(swaps[i], mn*2) for i in range(len(swaps)//2))",O(n)
"class Solution(object):
    def findMaxLength(self, nums):
        result, count = 0, 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += 1 if num == 1 else -1
            if count in lookup:
                result = max(result, i - lookup[count])
            else:
                lookup[count] = i

        return result",O(n)
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",O(n ^ 2)
"
import math


class Solution(object):
    def bulbSwitch(self, n):
        return int(math.sqrt(n))

",O(1)
"class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(nlogn)
"l,r=map(int,input().split())
al=[]
ar=[]
while(r):
    p=r%2
    ar.append(p)
    r=r//2
while(l):
    p=l%2
    al.append(p)
    l=l//2
if len(ar)!=len(al):
    ans=(2**len(ar))-1
else:
    n=len(ar)
    s=0
    k=0
    for i in range(n-1,-1,-1):
        if ar[i]!=al[i]:
            k=i+1
            break
    ans=(2**k)-1
    if k==0:
        ans=0
print(ans)",O(logn)
"class Solution3(object):
    def countEven(self, num):
        return sum(sum(map(int, str(x)))%2 == 0 for x in range(1, num+1))",O(nlogn)
"n=int(input())
a,b=map(int,input().split())
white=abs(a-1)+abs(b-1)
black=abs(n-a)+abs(n-b)
if white<=black:
    print(""White"")
else:
    print(""Black"")",O(1)
"n, k = map(int, input().split())
count = [0] * k
for c in input():
    count[ord(c) - ord(""A"")] += 1
print(k * min(count))
",O(n)
"import collections
import operator
from functools import reduce



class Solution(object):
    def beautifulSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))-1",O(n)
"def brute_force_assignment(cost_matrix):
    n = len(cost_matrix)
    min_cost = float('inf')
    from itertools import permutations
    for assignment in permutations(range(n)):
        total = 0
        for i in range(n):
            total += cost_matrix[i][assignment[i]]
        min_cost = min(min_cost, total)
    return min_cost",O(n!)
"mod=1000000007
import math
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m
def modInverse(b,m):
    g = math.gcd(b, m)
    if (g != 1):

        return -1
    else:

        return pow(b, m - 2, m)

def modDivide(a,b,m):
    a = a % m
    inv = modInverse(b,m)
    a=(a*inv)%m
    return a
n,k=map(int,input().split())
ans=(powm(4,k,mod)*n)%mod
r=powm(2,k,mod)
r=(powm(r,2,mod)-r)%mod
w=modDivide(r,2,mod)
ans=(ans-w)
er=powm(2,k,mod)
ans=modDivide(ans,er,mod)
ans=(ans*2)%mod
if n==0:
    ans=0
print(ans)",O(logn)
"class Solution(object):
    def hasAlternatingBits(self, n):
        n, curr = divmod(n, 2)
        while n > 0:
            if curr == n % 2:
                return False
            n, curr = divmod(n, 2)
        return True",O(1)
"N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"import sys

lines = sys.stdin.readlines()

def read_a_num(line):
    n = int(line.strip())
    return n

def read_a_str(line):
    line = line.strip()
    return line

def check_ticket(digits):
    for target in range(900):
        seg_i = 0
        seg_sum = 0
        next_flag = False
        for d in digits:
            int_d = int(d)
            if int_d > target:
                next_flag = True
                break
            elif seg_sum + int_d > target:
                if next_flag:
                    break
                next_flag = True
                continue
            elif int_d == target or seg_sum + int_d == target:
                seg_i += 1
                seg_sum = 0
            else:
                seg_sum += int_d

        if next_flag:
            continue

        if seg_i >= 2 and seg_sum == 0:
            return True

    return False

digits = read_a_str(lines[1])
if check_ticket(digits):
    print(""yes"")
else:
    print(""no"")
",O(n ^ 2)
"class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result",O(n)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                simple[mask] = True
                masks[mask] = path
    for i in range(1 << k):
        if not simple[i]:
            continue
        mask = i
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask:
                break
            if (mask & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_child = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask:
                    break
                if (mask & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_child = mask_child | (1 << u)
                    c += 1
            if masks[mask_child] and not masks[mask_child | mask]:
                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}
                if (mask_child | mask) == ((1 << k) - 1):
                    c = [-1] * k
                    p = [-1] * k
                    d = masks[(1 << k) - 1]
                    for key, val in d.items():
                        c[key] = val[0]
                        p[key] = val[1]
                    return True, c, p
    if masks[(1 << k) - 1]:
        c = [-1] * k
        p = [-1] * k
        d = masks[(1 << k) - 1]
        for key, val in d.items():
            c[key] = val[0]
            p[key] = val[1]
        return True, c, p
    return False, None, None

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"class Solution(object):
    def alphabetBoardPath(self, target):
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return """".join(result)",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

def get_ans(x):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo)
    print(""{} {}"".format(i+1,j+1))
",np
"l, r=map(int, input().split())
def cntbit(n):
  ans=0
  while(n):
    ans+=1
    n//=2
  return ans
c1=cntbit(l)
c2=cntbit(r)
if(c2>c1):
  print(2**c2-1)
else:
  x=l^r
  c=cntbit(x)
  print(2**c-1)",O(logn)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n, m = ria()
ar = ria()
arc = []
art = []
res = []
for n, i in enumerate(ria()):
    if i == 1:
        art.append(ar[n])
        res.append(0)
    else:
        arc.append(ar[n])
nt = 0
for i in arc:
    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):
        nt += 1
    res[nt] += 1

for i in res:
    print(i,end= ' ')",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",O(nlogn)
"n=int(input())
g={}
for i in range(1,n):
    p=int(input())
    if g.get(p):g[p].append(i+1)
    else:g[p]=[i+1]
ams='YES'
for i in g:
    c=0
    for j in g[i]:
        if j not in g:c+=1
    if c<3:ams='NO'
print(ams)",O(n)
"class Solution2(object):
    def largestValues(self, root):
        result = []
        curr = [root]
        while any(curr):
            result.append(max(node.val for node in curr))
            curr = [child for node in curr for child in (node.left, node.right) if child]
        return result",O(n)
"def knap(values,weights,W):
    n=len(values)
    def rec(i,cap):
        if i==n or cap<=0:
            return 0
        take=0
        if weights[i]<=cap:
            take=values[i]+rec(i+1,cap-weights[i])
        skip=rec(i+1,cap)
        return take if take>skip else skip
    return rec(0,W)
print(knap([6,10,12],[1,2,3],5))
",O(2 ^ n)
"n=int(input())
a=[int(i) for i in input().split()]
a.sort()
tot = 0
d={}
for i in range(len(a)):
    if a[i] not in d:
        tot+=1
        for j in range(i+1,len(a),1):
            if a[j]%a[i] == 0:
                d[a[j]]=1
print(tot)",O(n ^ 2)
"import collections



class Solution(object):
    def minimumSeconds(self, nums):
        lookup = collections.defaultdict(int)
        dist = collections.defaultdict(int)
        for i in range(2*len(nums)):
            x = nums[i%len(nums)]
            dist[x] = max(dist[x], i-lookup[x])
            lookup[x] = i
        return min(dist.values())//2",O(n)
"import sys

n=int(input())
A=list(map(int,input().split()))

if sum(A)<2*n-2:
    print(""NO"")
    sys.exit()

ONES=A.count(1)
print(""YES"",min(n-1,n-ONES+1))

NOONE=[]
for i in range(n):
    if A[i]!=1:
        NOONE.append([A[i],i+1])

ANS=[]
for i in range(1,len(NOONE)):
    ANS.append((NOONE[i-1][1],NOONE[i][1]))
    NOONE[i-1][0]-=1
    NOONE[i][0]-=1

NOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]]

LENNO=len(NOONE)

j=0
for i in range(n):
    while j<LENNO and NOONE[j][0]==0:
        j+=1
    if A[i]!=1:
        continue
    ANS.append((i+1,NOONE[j][1]))
    NOONE[j][0]-=1

print(len(ANS))
for a,b in ANS:
    print(a,b)
",O(n)
"import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

def bisearch_max(mn, mx, func):

    ok = mn
    ng = mx
    while ok+1 < ng:
        mid = (ok+ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok

def check(m):
    ok = [0] * N
    S = set()
    for i in range(N):
        for j in range(M):
            if A[i][j] >= m:
                ok[i] |= 1<<j
        S.add(ok[i])
    full = (1<<M) - 1
    for bit1 in range(1<<M):
        for bit2 in range(bit1, 1<<M):
            if bit1 in S and bit2 in S:
                if bit1 | bit2 == full:
                    return True
    return False

N, M = MAP()
A = [None] * N
for i in range(N):
    A[i] = LIST()

res = bisearch_max(0, 10**9+1, check)
ok = [0] * N
S = set()
D = {}
for i in range(N):
    for j in range(M):
        if A[i][j] >= res:
            ok[i] |= 1<<j
    S.add(ok[i])
    D[ok[i]] = i + 1
full = (1<<M) - 1
for bit1 in range(1<<M):
    for bit2 in range(bit1, 1<<M):
        if bit1 in S and bit2 in S:
            if bit1 | bit2 == full:
                print(D[bit1], D[bit2])
                exit()
",np
"def main():
    q = int(input())
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        for i in range(n - k + 1):
            count1 = 0
            count2 = 0
            count3 = 0
            for j in range(k):
                if (i + j) % 3 == 0:
                    if s[i + j] != ""R"":
                        count1 += 1
                    if s[i + j] != ""G"":
                        count2 += 1
                    if s[i + j] != ""B"":
                        count3 += 1
                if (i + j) % 3 == 1:
                    if s[i + j] != ""G"":
                        count1 += 1
                    if s[i + j] != ""B"":
                        count2 += 1
                    if s[i + j] != ""R"":
                        count3 += 1
                if (i + j) % 3 == 2:
                    if s[i + j] != ""B"":
                        count1 += 1
                    if s[i + j] != ""R"":
                        count2 += 1
                    if s[i + j] != ""G"":
                        count3 += 1
            min_ans = min(min_ans, count1, count2, count3)
        print(min_ans)
main()",O(n ^ 2)
"import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) >= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return """".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return """".join(result)",O(n)
"def has_subset_sum(nums, target):
    n = len(nums)
    for mask in range(1<<n):
        s = 0
        for i in range(n):
            if mask>>i & 1:
                s += nums[i]
        if s == target:
            return True
    return False

print(has_subset_sum([2,4,6,10], 16))
",O(2 ^ n)
"class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current",O(n)
"class Solution(object):
    def numWays(self, s):
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD",O(n)
"import sys
from array import array
from typing import List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n = int(input())
    a = list(map(int, input().split()))

    dp = [array('h', [10000]) * (n + 1) for _ in range(n + 1)]
    num = [array('h', [-1]) * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = 1
        num[i][i + 1] = a[i]

    for sublen in range(2, n + 1):
        for l, r in zip(range(n), range(sublen, n + 1)):
            for mid in range(l + 1, r):
                if num[l][mid] == num[mid][r] != -1:
                    dp[l][r] = 1
                    num[l][r] = num[l][mid] + 1
                    break

                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid][r])

    print(dp[0][-1])

if __name__ == '__main__':
    main()
",O(n ^ 3)
"def mypw2(deg):
    if (deg >= 1500) : return 2 ** 150

    return 2 ** deg

def sol():
    n, k = map(int, input().split())
    if (k == 0):
        print(""YES"", n)
        return
    for side in range(1, n + 1):
        MIN = mypw2(side + 1) - side - 2
        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;
        MAX //= 3

        if (MIN <= k <= MAX):
            print(""YES"", n - side)
            return
    print(""NO"")

def main():
    t = int(input())
    for i in range(t):
        sol()

main()",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())
    a = list(map(int, input().split()))
    dp = [[False]*(n+2) for i in range(n+2)]

    dp2 = [[600]*(n+2) for i in range(n+2)]
    for i in range(n):
        dp[i][i] = a[i]
        dp2[i][i] = 1
    for diff in range(1, n):
        for i in range(n-diff):

            for j in range(i, i+diff):
                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:
                    dp[i][i+diff] = dp[i][j] + 1
                    dp2[i][i+diff] = 1
                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])
            if not dp2[i][i+diff]:
                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)
    print(dp2[0][n-1])",O(n ^ 3)
"def binaries(n):
    out=[]
    def rec(s, i):
        if i==n:
            out.append(s)
            return
        rec(s+'0', i+1)
        rec(s+'1', i+1)
    rec('',0)
    return out

print(len(binaries(12))//1)
",O(2 ^ n)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

n=int(input())
if n==0:
    print(0)
else:
    if (n+1)%2:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"n,m=map(int,input().split())
a=0
while m:a+=n//m;n,m=m,n%m
print(a)",O(1)
"class Solution2(object):
    def treeQueries(self, n, edges, queries):
        def dfs(u, p, d):
            L[u] = cnt[0]
            cnt[0] += 1
            dist[u] = d
            for v, w in adj[u]:
                if v == p:
                    continue
                lookup[v] = w
                dfs(v, u, d+w)
            R[u] = cnt[0]

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
        cnt = [0]
        dfs(0, -1, 0)
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result",O(nlogn)
"import random



class Solution(object):
    def maxStarSum(self, vals, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        adj = [[] for _ in range(len(vals))]
        for u, v in edges:
            if vals[v] > 0:
                adj[u].append(v)
            if vals[u] > 0:
                adj[v].append(u)
        result = float(""-inf"")
        for u in range(len(vals)):
            if 1 <= k <= len(adj[u]):
                nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b])
            result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u])))))
        return result",O(n)
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:

        def rec(root: ListNode, cur: ListNode) -> ListNode:
            if not cur:
                return root
            root = rec(root, cur.next)

            if not root:
                return None
            tmp = None
            if root == cur or root.next == cur:
                cur.next = None
            else:
                tmp = root.next
                root.next = cur
                cur.next = tmp
            return tmp

        head = rec(head, head.next)
",O(n)
"def count_subset_sum(arr, tgt):
    def dfs(i, s):
        if i==len(arr): return 1 if s==tgt else 0
        return dfs(i+1, s) + dfs(i+1, s+arr[i])
    return dfs(0,0)
print(count_subset_sum([2,3,5,6,8,10],10))
",O(2 ^ n)
"n, = map(int,input().split())

s = input()
if s=='0':
    print(0)
else:
    print(""1""+""0""*s.count('0'))",O(n)
"arr = [2,3,5,7,11]
prods = []

def dfs(i, p):
    if i == len(arr):
        prods.append(p)
        return
    dfs(i + 1, p)
    dfs(i + 1, p * arr[i])

dfs(0, 1)
print(len(prods))
",O(2 ^ n)
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",O(logn)
"def unique_subset_ors(a):
    seen = set()
    def dfs(i, cur):
        if i == len(a):
            seen.add(cur)
            return
        dfs(i+1, cur | a[i])
        dfs(i+1, cur)
    dfs(0, 0)
    return seen

print(len(unique_subset_ors([1,2,4,8,16,3])))
",O(2 ^ n)
"def generate_permutations(arr):
    if len(arr) == 0:
        return [[]]
    perms = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            perms.append([arr[i]] + p)
    return perms",O(n!)
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 998244353;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    B();

dp = [];
def D():
    [n,k] = ti();
    a = ti();
    a = sorted(a);
    cnt = [0 for i in range(n)];
    for i in range(n):
        c = 0;
        for j in range(i,n):
            if a[j]-a[i] <= 5: c+=1;
            else:break;
        cnt[i] = c;

    global dp;
    dp = [[0 for j in range(k+1)] for i in range(n+1)];
    ans = 0;
    for i in range(n):
        for j in range(k+1):
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            if j+1 <= k:
                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);
    print(dp[n][k]);

def B():
    n = pi();
    a = ti();
    q = pi();

    mat = [[0 for j in range(n)] for i in range(n)];
    dp = [[0 for i in range(n)] for j in range(n)];
    for i in range(n):
        for j in range(n):
            if i == j:
                mat[i][j] = a[i];
                dp[i][j] = a[i];
    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];
            j += 1;
            i += 1;
        x += 1;

    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);
            j += 1;
            i += 1;
        x += 1;

    for i in range(q):
        [l,r] = ti();
        print(dp[l-1][r-1]);

main();",O(n ^ 2)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"class Solution2(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, prev, sum):
            if root is None:
                return 0

            curr = prev + root.val
            return int(curr == sum) + \
                   pathSumHelper(root.left, curr, sum) + \
                   pathSumHelper(root.right, curr, sum)

        if root is None:
            return 0

        return pathSumHelper(root, 0, sum) + \
               self.pathSum(root.left, sum) + \
               self.pathSum(root.right, sum)",O(n ^ 2)
"class Solution2(object):
    def longestSquareStreak(self, nums):
        dp = collections.defaultdict(int)
        nums.sort()
        result = -1
        for x in nums:
            sqrt_x = int(x**0.5)
            if sqrt_x**2 == x:
                dp[x] = dp[sqrt_x]+1
            else:
                dp[x] = 1
            result = max(result, dp[x])
        return result if result != 1 else -1",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
",np
"from math import factorial

s1 = input()
s2 = input()

finPos=0
for c in s1:
	if c=='+': finPos+=1
	else: finPos-=1

stPos=0
for c in s2:
	if c=='+': stPos+=1
	elif c=='-': stPos-=1

n=s2.count('?')
diff=abs(finPos-stPos)
if diff > n:
	print(0)
elif n&1 != diff&1:
	print(0)
else:
	i=0
	for i in range(n//2,n):
		if i*2-n == diff: break
	if i*2-n != diff: i+=1

	print((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))",np
"if __name__ == ""__main__"":
    s = input().rstrip().split()
    N = int(s[0])
    K = int(s[1])
    a = list(map(int, list(input().rstrip().split())))

    diff = []
    for i in range(1, N):
        diff.append([i, a[i] - a[i - 1]])
    diff = sorted(diff, key = lambda x: -x[1])
    res = max(a) - min(a)

    k = 0
    while (k < K - 1 and k < len(diff)):
        res -= diff[k][1]

        k += 1
    print(res)",O(nlogn)
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)
        power = lam = 1

        while slow != fast:
            if power == lam:
                slow = fast
                power *= 2
                lam = 0
            fast = self.sumOfSquares(fast)
            lam += 1
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"class Solution(object):
    def checkIfExist(self, arr):
        lookup = set()
        for x in arr:
            if 2*x in lookup or \
               (x%2 == 0 and x//2 in lookup):
                return True
            lookup.add(x)
        return False",O(n)
"class Solution(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) < k:
            if m-arr[left] > arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result",O(nlogn)
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

n, k = getList()
nums = getList()

diff = []

for i, j in zip(nums, nums[1:]):
    diff.append(j - i)

diff.sort()
print(sum(diff[:(n-k)]))",O(nlogn)
"def inclusion_exclusion(sets):
    n=len(sets)
    total=0
    for mask in range(1<<n):
        if mask==0:
            continue
        inter=None
        bits=0
        for i in range(n):
            if (mask>>i)&1:
                bits+=1
                inter=sets[i] if inter is None else inter & sets[i]
        total+=((-1)**(bits+1))*len(inter)
    return total

a=set(range(1,51))
b=set(range(1,101,2))
c=set(range(1,101,3))
print(inclusion_exclusion([a,b,c]))
",O(2 ^ n)
"n,m,k=map(int,input().split())
p=list(map(int,input().split()))
count=0
delete=0
now=0
while now<m:
    up=((p[now]-delete-1)//k+1)*k+delete
    while now<m and p[now]<=up:
        now+=1
        delete+=1
    count+=1
print(count)",O(n)
"class Solution(object):
    def lastNonEmptyString(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        mx = max(cnt)
        result = []
        for x in reversed(s):
            if cnt[ord(x)-ord('a')] != mx:
                continue
            cnt[ord(x)-ord('a')] -= 1
            result.append(x)
        return """".join(reversed(result))",O(n)
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",O(n)
"def traveling_salesman(n, dist):
    from itertools import permutations
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += dist[path[i-1]][path[i]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def subset_product(nums, target):
    ways=[]
    def dfs(i, prod, path):
        if i==len(nums):
            if prod==target:
                ways.append(path[:])
            return
        dfs(i+1, prod, path)
        path.append(nums[i])
        dfs(i+1, prod*nums[i], path)
        path.pop()
    dfs(0, 1, [])
    return ways
print(subset_product([1,2,3,4,6], 6))
",O(2 ^ n)
"class PermutationGenerator:
    def __init__(self, items):
        self.items = items
        self.n = len(items)
    def generate(self):
        if self.n == 0:
            return [[]]
        perms = []
        for i in range(self.n):
            remaining = self.items[:i] + self.items[i+1:]
            for p in PermutationGenerator(remaining).generate():
                perms.append([self.items[i]] + p)
        return perms",O(n!)
"class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def balanceBST(self, root):
        def inorderTraversal(root):
            result, stk = [], [(root, False)]
            while stk:
                node, is_visited = stk.pop()
                if node is None:
                    continue
                if is_visited:
                    result.append(node.val)
                else:
                    stk.append((node.right, False))
                    stk.append((node, True))
                    stk.append((node.left, False))
            return result
    
        def sortedArrayToBst(arr):
            ROOT, LEFT, RIGHT = list(range(3))
            result = [None]
            stk = [(0, len(arr), ROOT, result)]
            while stk:
                i, j, update, ret = stk.pop()
                if i >= j:
                    continue
                mid = i + (j-i)//2
                node = TreeNode(arr[mid])
                if update == ROOT:
                    ret[0] = node
                elif update == LEFT:
                    ret[0].left = node
                else:
                    ret[0].right = node
                stk.append((mid+1, j, RIGHT, [node]))
                stk.append((i, mid, LEFT, [node]))
            return result[0]
        
        return sortedArrayToBst(inorderTraversal(root))",O(n)
"people,n=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
d={}
tmp=[]
for i in range(n):
    if a[i] in d:
        d[a[i]]+=1
    else:
        d[a[i]]=1
d1={}
for i in d:
    if d[i] in d1:
        d1[d[i]]+=1
    else:
        d1[d[i]]=1
    tmp.append(d[i])
tmp.sort()
ans=0
for i in range(1,10001):
    x=people
    try:
        x-=d1[i]
    except:
        pass
    for j in d1:
        if j>i:
            x-=(j//i)*d1[j]
    if x<=0:
        ans=max(ans,i)
print(ans)",O(nlogn)
"def sum(num):

    return (num * (num + 1)) // 2

def sum_from_to(fromm, to):
    if fromm <= 1:
        return sum(to)
    return sum(to) - sum(fromm)

def min_splitters():
    start = 1
    end = k
    while start < end:
        mid = (start + end) // 2
        mid_val = sum_from_to(mid, k)
        if mid_val == n:
            return k - mid + 1
        elif mid_val > n:
            start = mid + 1
        else:
            end = mid
    return k - start + 1

n, k = (int(i) for i in input().split())

if n == 1:
    print(0)

elif n <= k:
    print(1)
else:
    k -= 1
    n -= 1

    if sum(k) < n:
        print(-1)
    else:
        print(min_splitters())
",O(logn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val",O(1)
"a, v = list(map(int, input().split("" "")))
l, d, w = list(map(int, input().split("" "")))

if(v <= w or w * w > 2 * a * d):
    if(v * v > 2 * a * l):
        print((2 * l / a) ** 0.5)
    else:
        print(l / v + v / 2 / a)
else:
    u = (w * w / 2 + a * d) ** 0.5
    if(u > v):
        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v
    else:
        m = (2 * u - w) / a

    if(v * v > 2 * a * (l - d + w * w / 2 / a)):
        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)
    else:
        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)",O(1)
"n, m = map(int, input().split())
xs = list(map(int, input().split()))
ts = list(map(int, input().split()))

ps = [x for x, t in zip(xs, ts) if t == 0]
ds = [x for x, t in zip(xs, ts) if t == 1]
ans = [0] * m

di = 0
for pi, p in enumerate(ps):
    while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p):
        di += 1

    if di >= m:
        ans[m - 1] += n - pi
        break

    ans[di] += 1

print(' '.join(map(str, ans)))
",O(n)
"from math import *
n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
min1=inf
min2=inf
max1=-inf
max2=-inf
for i in range(n):
    for j in range(m):
        if li[i][j] == ""B"":
            min1 = min(min1,i)
            min2 = min(min2, j)
            max1 = max(max1, i)
            max2 = max(max2, j)
print((min1+max1)//2+1,(min2+max2)//2+1)",O(n ^ 2)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
class Solution(object):
    def reverseBetween(self, head, m, n):
        diff, dummy, cur = n - m + 1, ListNode(-1), head
        dummy.next = head

        last_unswapped = dummy
        while cur and m > 1:
            cur, last_unswapped, m = cur.__next__, cur, m - 1

        prev, first_swapped = last_unswapped,  cur
        while cur and diff > 0:
            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

        last_unswapped.next, first_swapped.next = prev, cur

        return dummy.__next__",O(n)
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect

def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp

    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",O(n ^ 3)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        goal = len(nums) - 1

        for i in range(len(nums) - 2, -1, -1):
            if i + nums[i] >= goal:
                goal = i
        return goal == 0
",O(n)
"def count_states(n):
    stack=[0]
    c=0
    while stack:
        i=stack.pop()
        if i==n:
            c+=1
        else:
            stack.append(i+1)
            stack.append(i+1)
    return c

print(count_states(24))
",O(2 ^ n)
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",O(logn)
"class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def binary_search(self, x):
                if self.tree[1] < x:
                    return -1
                i = 1
                while not i >= self.base:
                    if self.tree[2*i] >= x:
                        i = 2*i
                    else:
                        i = 2*i+1
                return i-self.base

        def build(i):
            return baskets[i]

        st = SegmentTree(len(baskets), build_fn=build)
        result = 0
        for x in fruits:
            i = st.binary_search(x)
            if i == -1:
                result += 1
            else:
                st.update(i, 0)
        return result",O(nlogn)
"n=int(input())
l=[int(i) for i in input().split()]
s=set(l)
if 0 in s:
    print(len(s)-1)
else:
    print(len(s))",O(n)
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",O(1)
"def solve_tsp(distances):
    n = len(distances)
    min_cost = float('inf')
    best_path = []
    
    def dfs(path, visited, cost):
        nonlocal min_cost, best_path
        if len(path) == n:
            total = cost + distances[path[-1]][path[0]]
            if total < min_cost:
                min_cost = total
                best_path = path[:]
            return
        last = path[-1]
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                path.append(next_city)
                dfs(path, visited, cost + distances[last][next_city])
                path.pop()
                visited[next_city] = False
    
    visited = [False] * n
    visited[0] = True
    dfs([0], visited, 0)
    return best_path, min_cost",O(n!)
"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result",O(n)
"from sys import stdin
n,m=map(int,stdin.readline().strip().split())
s=list(map(int,stdin.readline().strip().split()))
s1=list(map(int,stdin.readline().strip().split()))
if min(s1)<max(s):
    print(-1)
    exit(0)
s.sort()
s1.sort()

ans=0
if s1[0]!=s[-1]:
    ans+=s1[0]
    ans+=s[-2]*(m-1)
    ans+=sum(s1[1::])
    ans+=s[-1]
    for i in range(n-2):
        ans+=s[i]*m
else:
    ans+=sum(s1)
    for i in range(n-1):
        ans+=s[i]*m
print(ans)
",O(nlogn)
"n = int(input())
l = tuple(map(int,input().split()))
r = tuple(map(int,input().split()))
s = [ (i,sum(v)) for i,(v) in enumerate(zip(l,r)) ]
ss = sorted(s, key= lambda a:a[1] )

candies = [0]*n
for p in ss:
    candies[p[0]] = n-p[1]

ll = [0]
for i in range(1,n):
    ll.append(sum([1 for c in candies[:i] if c > candies[i]]))

rr = [0]
for i in range(n-2,-1,-1):
    rr.append(sum([1 for c in candies[i:] if c > candies[i]]))

for i in range(n):
    if ll[i] != l[i]:
        print(""NO"")
        break
    if rr[n-1-i] != r[i]:
        print(""NO"")
        break
    if i == n-1:
        print(""YES"")
        print(' '.join(map(str,candies)))
",O(nlogn)
"class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 < len(word1) and arr_idx2 < len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())
from collections import Counter

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

n, k = mi()
s = input().strip()
c = Counter(s)
mn = 10 ** 9
for ch in alpha[:k]:
    mn = min(mn, c[ch])
print(mn * k)
",O(n)
"class MinStack:
    def __init__(self):
        self.min = float('inf')
        self.stack = []

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self) -> None:
        if not self.stack:
            return

        pop = self.stack.pop()

        if pop < 0:
            self.min = self.min - pop

    def top(self) -> int:
        top = self.stack[-1]
        if top > 0:
            return top + self.min
        else:
            return self.min

    def getMin(self) -> int:
        return self.min
",O(1)
"class Solution(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        mn = min((cnt[i], i) for i in range(value))[1]
        return value*cnt[mn]+mn
import collections",O(n)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	tmp=[]
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			cnt=0
			while(n%i==0):
				n=n//i
				cnt+=1
			tmp.append((i,cnt))
	if n>1:
		tmp.append((n,1))
	return tmp

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n=ii()
	print(n,0,0)

if __name__ == '__main__':
	main()",O(1)
"n = int(input())
p = [0,0] + [int(w) for w in input().split()]
d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]
if n == 1:
    d[1] = 1
d = d[1:]
d.sort()
print(*d)",O(n)
"class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(range(cols)):
            for j in reversed(range(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return """".join(result)",O(n)
"class Solution(object):
    def rob(self, nums):
        last, now = 0, 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now",O(n)
"val=10**9
n,m=map(int,input().split())
arr1=[]
for i in range(n):
    x=int(input())
    arr1.append(x)
arr1.append(val)
arr2=[]
ans=val
finalval=0
arr1.sort()
for i in range(m):
    x1,x2,y=map(int,input().split())
    if(x1==1):
        if(x2==val):
            finalval+=1
        else:
            if(len(arr1)>0 and x2>=arr1[0]):
                arr2.append(x2)
arr2.sort()
i=0
j=0
while(i<len(arr1) and j<len(arr2)):
    if(arr1[i]>arr2[j]):
        j+=1
    elif(arr1[i]==arr2[j]):
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1
    else:
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1

ans=min(i,ans)
print(ans+finalval)
",O(nlogn)
"import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):
        parse = re.findall(r""([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)"", formula)
        stk = [collections.Counter()]
        for name, m1, left_open, right_open, m2 in parse:
            if name:
              stk[-1][name] += int(m1 or 1)
            if left_open:
              stk.append(collections.Counter())
            if right_open:
                top = stk.pop()
                for k, v in top.items():
                  stk[-1][k] += v * int(m2 or 1)

        return """".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \
                       for name in sorted(stk[-1]))",O(n)
"import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        K = 3

        result = 0
        count = collections.Counter()
        for i in range(len(s)):
            if i >= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result",O(n)
"class Solution(object):
    def findDelayedArrivalTime(self, arrivalTime, delayedTime):
        return (arrivalTime + delayedTime)%24",O(1)
"import sys

def solve(n, m, grid):
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                continue
            must = cell == 1
            if i >= n - 2 or j >= m - 2:
                if must:
                    return 'NO'
                continue
            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                if grid[i + di][j + dj] == 0:
                    if must:
                        return 'NO'
                    break
            else:
                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                    grid[i + di][j + dj] = 2
                grid[i][j] = 2
    return 'YES'

n, m = list(map(int, input().split()))
grid = [['.
print(solve(n, m, grid))
",O(n ^ 2)
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))
",np
"n, c = map(int, input().split())
res1 = [0] * 500001
res = 0
for ai in map(int, input().split()):
	res1[ai] = max(res1[ai], res1[c])
	res1[ai] += 1
	res = max(res, res1[ai] - res1[c])
print(res + res1[c])
",O(n)
"
import heapq


class Solution(object):
    def smallestChair(self, times, targetFriend):
        events = []
        for i, (s, e) in enumerate(times): 
            events.append((s, True, i))
            events.append((e, False, i))
        events.sort()

        lookup = {}
        min_heap = []
        for _, arrival, i in events: 
            if not arrival: 
                heapq.heappush(min_heap, lookup.pop(i))
                continue
            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)
            if i == targetFriend:
                break
        return lookup[targetFriend]
",O(nlogn)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",O(1)
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])

    print(max(max(v) for v in dp))",O(n)
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)
",O(n)
"def toggle_case(s):
    res=[]
    def dfs(i, path):
        if i==len(s):
            res.append(path)
            return
        c=s[i]
        dfs(i+1, path+c.lower())
        dfs(i+1, path+c.upper())
    dfs(0, '')
    return res

print(toggle_case('ab3'))
",O(2 ^ n)
"
class Solution(object):
    def maximumNumber(self, num, change):
        mutated = False
        result = list(map(int, list(num)))
        for i, d in enumerate(result):
            if change[d] < d:
                if mutated:
                    break
            elif change[d] > d:
                result[i] = str(change[d])
                mutated = True
        return """".join(map(str, result))
",O(n)
"def color(x, y):

	return 'white' if (x + y) % 2 == 0 else 'black'

def white(x1, y1, x2, y2):

	if x1 > x2 or y1 > y2:
		return 0

	if color(x1, y1) != color(x2, y2):
		return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
	else:
		if color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2
		elif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2
		else:
			return (x2 - x1 + 1) * (y2 - y1 + 1) // 2

def black(x1, y1, x2, y2):

	if x1 > x2 or y1 > y2:
		return 0

	return (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)

def intersect_1D(x1, x2, x3, x4):

	return max(x1, x3), min(x2, x4)

def intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):

	xl, xr = intersect_1D(x1, x2, x3, x4)
	yl, yr = intersect_1D(y1, y2, y3, y4)
	return xl, yl, xr, yr

for i in range(int(input())):
	n, m = map(int, input().split())

	x1, y1, x2, y2 = map(int, input().split())

	x3, y3, x4, y4 = map(int, input().split())

	w0, b0 = white(1, 1, m, n), black(1, 1, m, n)

	_b0 = black(x1, y1, x2, y2)

	w1, b1 = w0 + _b0, b0 - _b0

	_w1 = white(x3, y3, x4, y4)

	w2, b2 = w1 - _w1, b1 + _w1

	xl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)

	_b2 = black(xl, yl, xr, yr)

	w3, b3 = w2 - _b2, b2 + _b2

	print(w3, b3)
",O(1)
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort()
    dic={}
    for a in arr:
        if a/k not in dic:
            dic[a]=1

    print(len(dic))

main()",O(nlogn)
"import math


class Solution(object):
    def getPermutation(self, n, k):
        seq, k, fact = """", k - 1, math.factorial(n - 1)
        perm = [i for i in range(1, n + 1)]
        for i in reversed(range(n)):
            curr = perm[k / fact]
            seq += str(curr)
            perm.remove(curr)
            if i > 0:
                k %= fact
                fact /= i
        return seq",O(n ^ 2)
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])

mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",O(n ^ 3)
"class Solution(object):
    def prevPermOpt1(self, A):
        for left in reversed(range(len(A)-1)):
            if A[left] > A[left+1]:
                break
        else:
            return A
        right = len(A)-1
        while A[left] <= A[right]:
            right -= 1
        while A[right-1] == A[right]:
            right -= 1
        A[left], A[right] = A[right], A[left]
        return A",O(n)
"def permute_unique(nums):
    res = []
    def dfs(path, counter):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for num in counter:
            if counter[num] > 0:
                path.append(num)
                counter[num] -= 1
                dfs(path, counter)
                path.pop()
                counter[num] += 1
    from collections import Counter
    dfs([], Counter(nums))
    return res",O(n!)
"import collections
import functools


class Solution(object):
    def minimumLengthEncoding(self, words):
        words = list(set(words))
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()

        nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]

        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)",O(n)
"class Solution(object):
    def numberOfDays(self, Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)",O(1)
"class Solution(object):
    def sumRemoteness(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            total, cnt = grid[i][j], 1
            grid[i][j] = -1
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):
                            continue
                        total += grid[ni][nj]
                        cnt += 1
                        grid[ni][nj] = -1
                        new_q.append((ni, nj))
                q = new_q
            return total, cnt
    
        groups = [bfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] != -1]
        total = sum(t for t, _ in groups)
        return sum((total-t)*c for t, c in groups)",O(n ^ 2)
"class Solution(object):
    def isValid(self, word):
        VOWELS = ""aeiou""

        if len(word) < 3:
            return False
        vowel = consonant = False
        for x in word:
            if x.isalpha():
                if x.lower() in VOWELS:
                    vowel = True
                else:
                    consonant = True
            elif not x.isdigit():
                return False
        return vowel and consonant",O(n)
"class Solution(object):

    def encode(self, strs):
        encoded_str = """"
        for s in strs:
            encoded_str += ""%0*x"" % (8, len(s)) + s
        return encoded_str


    def decode(self, s):
        i = 0
        strs = []
        while i < len(s):
            l = int(s[i:i+8], 16)
            strs.append(s[i+8:i+8+l])
            i += 8+l
        return strs",O(n)
"class Solution(object):
    def removeOuterParentheses(self, S):
        deep = 1
        result, cnt = [], 0
        for c in S:
            if c == '(' and cnt >= deep:
                result.append(c)
            if c == ')' and cnt > deep:
                result.append(c)
            cnt += 1 if c == '(' else -1
        return """".join(result)",O(n)
"n, k = [int(i) for i in input().split()]
for i in range(100*k+100*n):
    if i*(i+1) == (n+k-i)*2:
        print(n-i)
        break",O(n)
"class Solution(object):
    def threeSum(self, nums):
        result = []
        nums.sort()
        for i in reversed(list(range(2, len(nums)))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            target = -nums[i]
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] < target:
                    left += 1
                elif nums[left]+nums[right] > target:
                    right -= 1
                else:
                    result.append([nums[left], nums[right], nums[i]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        return result",O(n ^ 2)
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"class Solution(object):
    def reformatDate(self, date):
        lookup = {""Jan"":1, ""Feb"":2, ""Mar"":3, ""Apr"":4,
                  ""May"":5, ""Jun"":6, ""Jul"":7, ""Aug"":8,
                  ""Sep"":9, ""Oct"":10, ""Nov"":11, ""Dec"":12}
        return ""{:04d}-{:02d}-{:02d}"".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))",O(1)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",O(n ^ 2)
"class Solution3(object):
    def pancakeSort(self, A):
        def reverse(l, begin, end):
            for i in range((end-begin) // 2):
                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]

        result = []
        for n in reversed(range(1, len(A)+1)):
            i = A.index(n)
            reverse(A, 0, i+1)
            result.append(i+1)
            reverse(A, 0, n)
            result.append(n)
        return result",O(n ^ 2)
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True",O(n)
"class Solution(object):
    def countHighestScoreNodes(self, parents):
        def iter_dfs(adj):
            result = [0]*2
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    i, ret = args
                    cnts = [[0] for _ in range(len(adj[i]))]
                    stk.append((2, (cnts, ret)))
                    for j, child in enumerate(adj[i]):
                        stk.append((1, (child, cnts[j])))
                elif step == 2:
                    cnts, ret = args
                    ret[0] = sum(cnt[0] for cnt in cnts)+1
                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)
                    if score > result[0]:
                        result[:] = [score, 1]
                    elif score == result[0]:
                        result[1] += 1
            return result[1]

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        return iter_dfs(adj)",O(n)
"def power_set(arr):
    ps=[[]]
    for x in arr:
        ps=ps+[s+[x] for s in ps]
    return ps

p=power_set([1,2,3,4,5])
",O(2 ^ n)
"k = int(input())

for i in range(20):
    if k > 10**i * 9 * (i+1):
        k -= 10**i * 9 * (i+1)
    else:
        a, b = (k-1) // (i+1) + 10**i, (k-1) % (i+1)
        print(str(a)[b])
        break",O(logn)
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",O(nlogn)
"pri=998244353
dp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)]
n,k=map(int,input().split())

for i in range(1,n+1):
    if(i==1):
        dp[0][i][1]=2
        dp[1][i][2]=2

        continue;
    for j in range(1,(2*i)+1):
        dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j]))

        dp[0][i][j]%=pri
        dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2])
        dp[0][i][j]%=pri
        dp[1][i][j]%=pri
y=dp[0][n][k]+dp[1][n][k]
y%=pri
print(y)
",np
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue",O(n)
"class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)",O(n)
"import bisect as bi
n,q = map(int,input().split())
a = list(map(int,input().split()))
l = list(map(int,input().split()))
som = sum(a)
e = 0
p = []
for i in a:
    e += i
    p.append(e)

e = 0
s = set(p)
for i in l:
    e += i
    if e >= som:
        e = 0

    x = bi.bisect(p,e)
    print(n-x)
",O(nlogn)
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        count = defaultdict(int)
        for num in nums:
            count[num] += 1

        res = []
        for i in range(len(nums)):
            count[nums[i]] -= 1
            if i and nums[i] == nums[i - 1]:
                continue

            for j in range(i + 1, len(nums)):
                count[nums[j]] -= 1
                if j - 1 > i and nums[j] == nums[j - 1]:
                    continue
                target = -(nums[i] + nums[j])
                if count[target] > 0:
                    res.append([nums[i], nums[j], target])

            for j in range(i + 1, len(nums)):
                count[nums[j]] += 1
        return res
",O(n ^ 2)
"def pow(x, p):
    ret = 1
    for i in range(p): ret=ret*x
    return ret

def rate(p):
    ret = 0
    now = 1
    for i in range(p):
        ret = ret + now
        now = now * 4
    return ret

def solve():
    n, k = map(int, input().split())
    if (n>35):
        print(""YES %d"" % (n-1))
        return
    mSplit = 1
    cnt1 = 0
    cnt3 = 1
    for i in range(1, n+1):
        now = pow(4, i) - pow(2, i+1) + 1
        now = now * rate(n-i) + rate(i)

        if (k<=now):
            print(""YES %d"" % (n-i))
            return
        mSplit = mSplit + cnt1 + cnt3 * 3
        cnt1 = cnt1 + cnt3
        cnt3 = cnt3 + cnt3
        if (mSplit>k): break
    print(""NO"")

def main():
    T = int(input())
    for i in range(T):
        solve()

if __name__ == ""__main__"":
    main()
",O(logn)
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",O(1)
"import math
import collections
import bisect
import heapq
import time
import itertools
import sys

N = int(input())
B = [int(x) for x in input().split()]

A = [0] * N

i, j = N//2-1, N//2
A[i] = B[-1] // 2
A[j] = B[-1] // 2 if B[-1] % 2 == 0 else B[-1] // 2 + 1
l, r = A[i], A[j]
for bi in range(len(B)-2, -1, -1):
    b = B[bi]
    i -= 1
    j += 1

    if b-l >= A[j-1]:
        A[i] = l
        A[j] = b-l
        r = b-l
    else:
        A[j] = r
        A[i] = b-r
        l = b-r

print(' '.join(map(str, A)))
",O(n)
"import itertools



class Solution2(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
        
        def pairwise(it):
            a, b = tee(it)
            next(b, None)
            return zip(a, b)

        return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount)))",O(n)
"import math
temp=list(map(int,input().split()))
N,q=temp[0],temp[1]
for j in range(0,q):
    u=int(input())
    S=input()
    k=(N+1)//2
    n=int(math.log((N+1),10)/math.log(2,10))-1
    dup_n=n
    store=[k]
    while u!=k:
        n-=1
        if u>k:
            k+=2**(n)
        else:
            k-=2**(n)
        store.append(k)
    for i in range(0,len(S)):
        if S[i]=='R':
            n-=1
            if n==-1:
                n=0
                continue
            k+=2**(n)
        elif S[i]=='L':
            n-=1
            if n==-1:
                n=0
                continue
            k-=2**(n)
        else:
            if n==dup_n:
                continue
            store.pop()
            k=store[len(store)-1]
            n+=1
            continue
        store.append(k)

    print(k)",np
"import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*n for _ in range(n)]
    dp2=[[inf]*n for _ in range(n)]
    for i in range(n):
        dp1[i][i]=aa[i]
        dp2[i][i]=1
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w-1
            for m in range(l,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m+1][r]:
                    dp1[l][r]=dp1[l][m]+1
                    dp2[l][r]=1
    for m in range(n):
        for l in range(m+1):
            for r in range(m+1,n):
                dp2[l][r]=min(dp2[l][r],dp2[l][m]+dp2[m+1][r])
    print(dp2[0][n-1])

main()",O(n ^ 3)
"from collections import deque as de
import math
from math import sqrt as sq
from math import floor as fl
from math import ceil as ce
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb

from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())

    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True

def primes_method5(n):
    out ={}
    sieve = [True] * (n+1)
    for p in range(2, n+1):
        if (sieve[p]):
            out[p]=1
            for i in range(p, n+1, p):
                sieve[i] = False
    return out

def getSum(n):

    strr = str(n)
    list_of_number = list(map(int, strr.strip()))
    return sum(list_of_number)

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(value)] = int(index)+1
    return dic
def frqdict():

    dic={}
    for index, value in enumerate(input()):
        if value not in dic:
            dic[value] =1
        else:
            dic[value] +=1
    return dic

n=ii()
a=sorted(li())
if a[n-1]==1:
    a[n-1]=2
else:
    a[n-1]=1
a.sort()
print(*a)
",O(nlogn)
"n=int(input())
l1=list(map(int,input().split()))
if n%2==0:
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
else :
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1
print(' '.join(str(x) for x in l1))",O(n)
"from sys import stdin, stdout
import sys
input=sys.stdin.readline

def solve(n, t, tasks):
    lo = 0
    hi = n

    res = []
    curr_res = 0

    tasks.sort(key=lambda x: x[1])

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        valid_tasks = []
        for i in tasks:
            if i[0] >= mid:
                valid_tasks.append(i)

        can_do = False

        curr_sum = 0
        total_used = 0
        r = []
        for i in valid_tasks:
            curr_sum += i[1]
            total_used += 1
            r.append(i[2])
            if curr_sum > t:
                break
            elif total_used >= mid:
                can_do = True
                curr_res = mid
                res = r
                break
        if can_do:
            lo = mid + 1
        else:
            hi = mid - 1
    return curr_res, res

def main():
    n, t = (int(x) for x in input().split("" ""))
    tasks = []
    nums = n
    idx = 1
    while n:
        a_i, t_i = (int(x) for x in input().split("" ""))
        tasks.append((a_i, t_i, idx))
        idx += 1
        n -= 1

    res, res_arry = solve(nums, t, tasks)
    print(res)
    print(res)
    stdout.write("" "".join(map(str, res_arry)))
    stdout.write(""\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"import sys
import bisect

ls2int = lambda ls: int(''.join(map(str,ls)))
def candidates(digs, num):
    if not digs:
        return [[]]

    res = []
    i = bisect.bisect_left(digs, num[0])

    if num[0] in digs:
        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):
            res.append([digs[i]] + suffix)

    if i > 0:
        i -= 1
        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))

    return res

def solution(a, b):
    digits = [int(x) for x in sorted(a)]
    ceiling = [int(x) for x in b]

    assert(len(digits) <= len(ceiling), 'solution does not exist')
    if len(digits) < len(ceiling):
        return ls2int(digits[::-1])
    return max(ls2int(ls) for ls in candidates(digits, ceiling))

a = sys.stdin.readline().strip()
b = sys.stdin.readline().strip()
print(solution(a, b))",O(n ^ 3)
"def has_product(nums, target):
    n = len(nums)
    def dfs(i, p):
        if i == n:
            return p == target
        return dfs(i + 1, p) or dfs(i + 1, p * nums[i])
    return dfs(0, 1)
",O(2 ^ n)
"class Solution(object):
    def getMaximumConsecutive(self, coins):
        coins.sort()
        result = 1
        for c in coins:
            if c > result:
                break
            result += c
        return result",O(nlogn)
"k = int(input())

mul = 1
d = 1

while k>mul*9*d:
    k-=mul*9*d
    d+=1
    mul*=10

x = k%d
y = k//d
y+=mul

if x==0:
    print((y-1)%10)
else:
    y = y//pow(10,d-x)
    print(y%10)
",O(logn)
"class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == """":
            return """"

        countT = {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        res, resLen = [-1, -1], float(""infinity"")
        for i in range(len(s)):
            countS = {}
            for j in range(i, len(s)):
                countS[s[j]] = 1 + countS.get(s[j], 0)

                flag = True
                for c in countT:
                    if countT[c] > countS.get(c, 0):
                        flag = False
                        break

                if flag and (j - i + 1) < resLen:
                    resLen = j - i + 1
                    res = [i, j]

        l, r = res
        return s[l : r + 1] if resLen != float(""infinity"") else """"
",O(n ^ 2)
"n = int(input())
a = list(map(int,input().split()))
fl = False
ans = True
for i in range(n-1):
    if a[i+1]>a[i]:
        if fl:
            ans = False
    else:
        fl = True
if ans:
    print('YES')
else:
    print('NO')",O(n)
"import math
def getdt():
    return map(int, input().split())
def calc(v0, v, a, x):
    t = (v - v0) / a
    x0 = v0 * t + 0.5 * a * t * t
    if x0 >= x:
        return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) / a)
    return (x0, t)
def go(v0, v, a, x):
    x0, t = calc(v0, v, a, x)
    return t + (x - x0) / v
a, v = getdt()
l, d, w = getdt()
if w > v:
    w = v
x, t = calc(0, w, a, d)
if x == d:
    print(go(0, v, a, l))
else:
    print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))
",O(1)
"import collections



class Solution(object):
    def maxSum(self, nums, m, k):
        lookup = collections.Counter()
        result = curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            lookup[nums[right]] += 1
            if right-left+1 == k+1:
                lookup[nums[left]] -= 1
                if lookup[nums[left]] == 0:
                    del lookup[nums[left]]
                curr -= nums[left]
                left += 1
            if right-left+1 == k and len(lookup) >= m:
                result = max(result, curr)
        return result",O(n)
"def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(25))
",O(2 ^ n)
"class Solution(object):
    def mergeArrays(self, nums1, nums2):
        result = []
        i = j = 0
        while i < len(nums1) or j < len(nums2):
            if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]):
                if result and result[-1][0] == nums1[i][0]:
                    result[-1][1] += nums1[i][1]
                else:
                    result.append(nums1[i])
                i += 1
            else:
                if result and result[-1][0] == nums2[j][0]:
                    result[-1][1] += nums2[j][1]
                else:
                    result.append(nums2[j])
                j += 1
        return result",O(n)
"import collections



class Solution(object):
    def minGroups(self, intervals):
        events = collections.Counter()
        for l, r in intervals:
            events[l] += 1
            events[r+1] -= 1
        result = curr = 0
        for t in sorted(events.keys()):
            curr += events[t]
            result = max(result, curr)
        return result",O(nlogn)
"import itertools


class Solution(object):
    def largestTimeFromDigits(self, A):
        result = """"
        for i in range(len(A)):
            A[i] *= -1
        A.sort()
        for h1, h2, m1, m2 in itertools.permutations(A):
            hours = -(10*h1 + h2)
            mins = -(10*m1 + m2)
            if 0 <= hours < 24 and 0 <= mins < 60:
                result = ""{:02}:{:02}"".format(hours, mins)
                break
        return result",O(1)
"k = int(input())
k_=k
ca = 9
di = 1
tem = 9
while k_>0:
    k_-=ca*di
    ca*=10
    di+=1
    tem += ca*di
    if k_==0:
        break
tem -= ca*di
ca=int(ca/10)
di-=1
tem -= ca*di
ca=int(ca/10)
ca_=0
while ca>0:
    ca_+=ca
    ca= int(ca/10)
k -= tem
re = int((k+di-1)//di)+ca_
re_= k%di
if re_==0:
    l=1
else:
    l = 10**(di-re_)
re = int(re//l)
print(re%10)
",O(logn)
"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def main():

    n=int(input())
    print(0,0,n)

main()",O(1)
"n = int(input())
print(25)",O(1)
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

count = [0]*(int(1e5+1))

for i in arr:
    count[i] += 1

s = sum([1 if i>0 else 0 for i in count])
if s < k:
    print('-1 -1')
    exit()

r = n-1
while True:
    if count[arr[r]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[r]] -= 1
    r -= 1

l=0
while True:
    if count[arr[l]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[l]] -= 1
    l += 1

print(l+1, r+1)
",O(n)
"for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    dp = [[0] * (1<<N) for _ in range(M+1)]
    for j in range(M):
        for mask in range(1<<N):
            maskpre = mask
            while maskpre >= 0:
                maskpre &= mask
                ma = 0
                for k in range(N):
                    s = 0
                    for i in range(N):
                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:
                            s += X[i-k][j]
                    ma = max(ma, s)
                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)

                maskpre -= 1
    print(dp[-1][-1])",np
"class Solution(object):
    def sumOfLeftLeaves(self, root):
        def sumOfLeftLeavesHelper(root, is_left):
            if not root:
                return 0
            if not root.left and not root.right:
                return root.val if is_left else 0
            return sumOfLeftLeavesHelper(root.left, True) + \
                   sumOfLeftLeavesHelper(root.right, False)

        return sumOfLeftLeavesHelper(root, False)",O(n)
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
YOKO=[list(map(int,input().split())) for i in range(n)]
TATE=[list(map(int,input().split())) for i in range(n-1)]

if k%2==1:
    for i in range(n):
        print(*[-1]*m)
    exit()

DP=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):

        MIN=1<<30

        if j-1>=0:
            MIN=min(MIN,YOKO[i][j-1]*2)
        if j<m-1:
            MIN=min(MIN,YOKO[i][j]*2)

        if i-1>=0:
            MIN=min(MIN,TATE[i-1][j]*2)
        if i<n-1:
            MIN=min(MIN,TATE[i][j]*2)

        DP[i][j]=MIN

DP0=DP[:]

for tests in range(k//2-1):
    NDP=[[0]*m for i in range(n)]

    for i in range(n):
        for j in range(m):
            MIN=DP[i][j]+DP0[i][j]

            if 0<=i+1<n:
                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])

            if 0<=i-1<n:
                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])

            if 0<=j+1<m:
                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])

            if 0<=j-1<m:
                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])

            NDP[i][j]=MIN
    DP=NDP

for dp in DP:
    print(*dp)
",O(n ^ 3)
"class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root",O(n)
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if (bx > ax, by > ay) != (cx > ax, cy > ay):
    print(""NO"")
    exit(0)

print(""YES"")
",O(1)
"class Solution(object):
    def countDigitOne(self, n):
        DIGIT = 1
        is_zero = int(DIGIT == 0)
        result = is_zero
        base = 1
        while n >= base:
            result += (n//(10*base)-is_zero)*base + \
                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))
            base *= 10
        return result",O(logn)
"class Solution(object):
    def countTime(self, time):
        result = 1
        if time[4] == '?':
            result *= 10
        if time[3] == '?':
            result *= 6
        if time[1] == time[0] == '?':
            result *= 24
        elif time[1] == '?':
            result *= 10 if time[0] != '2' else 4
        elif time[0] == '?':
            result *= 3 if time[1] < '4' else 2
        return result",O(1)
"class Solution(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] == '1':
                curr += 1
            elif i+1 == len(s) or s[i+1] == '1':
                result += curr
        return result",O(n)
"def traveling_salesman_brute(graph):
    from itertools import permutations
    n = len(graph)
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def gen(n):
    if n == 0:
        return [""""]
    prev = gen(n - 1)
    return [p + ""0"" for p in prev] + [p + ""1"" for p in prev]

print(len(gen(15)))
",O(2 ^ n)
"def flipH(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[i][N-j-1]
    return B

def flipV(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[N-i-1][j]
    return B

def rotate90(A):
    ans = zip(*A[::-1])
    ans=list(map(list,ans))
    return ans

def check(A,B,N):
    for i in range(N):
        for j in range(N):
            if A[i][j]!=B[i][j]:
                return False
    return True

N=int(input())
A=[]
X=[]
for i in range(N):
    A.append(list(input()))
for i in range(N):
    X.append(list(input()))
B=flipH(A,N)
C=flipV(A,N)
flag=False
for i in range(4):
    if check(A,X,N) or check(B,X,N) or check(C,X,N):
        flag=True
        break
    else:
        A=rotate90(A)
        B=rotate90(B)
        C=rotate90(C)
if flag:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"def partition_min_diff(nums):
    total=sum(nums)
    best=total
    def dfs(i, s):
        nonlocal best
        if i==len(nums):
            diff=abs(total-2*s)
            if diff<best:
                best=diff
            return
        dfs(i+1, s+nums[i])
        dfs(i+1, s)
    dfs(0,0)
    return best

print(partition_min_diff([5,10,15,20,25]))
",O(2 ^ n)
"from heapq import heappop, heappush

n, m, k = [int(i) for i in input().split()]
if k % 2 == 1:
    for _ in range(n):
        print("" "".join([""-1""] * m))
    exit()

E_right = []
for i in range(n):
    E_right.append([int(j) for j in input().split()])

E_down = []
for i in range(n - 1):
    E_down.append([int(j) for j in input().split()])

P = [[0 for _ in range(m)] for _ in range(n)]
new_P = [[0 for _ in range(m)] for _ in range(n)]

for k in range(k // 2 + 1):
    for i in range(n):
        for j in range(m):
            possible = []
            if i - 1 >= 0:
                e = E_down[i - 1][j]
                possible.append(P[i - 1][j] + e)

            if i + 1 < n:
                e = E_down[i][j]
                possible.append(P[i + 1][j] + e)

            if j - 1 >= 0:
                e = E_right[i][j - 1]
                possible.append(P[i][j - 1] + e)

            if j + 1 < m:
                e = E_right[i][j]
                possible.append(P[i][j + 1] + e)

            new_P[i][j] = min(possible)

    tmp = P
    P = new_P
    new_P = tmp

for i in range(n):
    print("" "".join(str(s * 2) for s in new_P[i]))
",O(n ^ 3)
"import sys
n=int(input())

l=list(map(int,input().split()))
c=list(map(int,input().split()))
a=[]
for i in range(1,n-1):
    lr=sys.maxsize
    lc=sys.maxsize
    for j in range(0,i):

        if l[i]>l[j]:
            lc=min(lc,c[j])

    for j in range(i+1,n):

        if l[j]>l[i]:
            lr=min(lr,c[j])

    if lr<sys.maxsize and lc<sys.maxsize:
        a.append(lr+lc+c[i])

if not a:
    print(-1)
else:
    print(min(a))
",O(n ^ 2)
"class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result",O(nlogn)
"class Solution(object):
    def maximumTime(self, time):
        result = list(time)
        for i, c in enumerate(time): 
            if c != ""?"":
                continue
            if i == 0:
                result[i] = '2' if result[i+1] in ""?0123"" else '1'
            elif i == 1:
                result[i] = '3' if result[0] == '2' else '9'
            elif i == 3:
                result[i] = '5'
            elif i == 4:
                result[i] = '9'
        return """".join(result)",O(1)
"def exhaustive_permutations(items):
    n = len(items)
    if n == 0:
        return [[]]
    result = []
    for i in range(n):
        remaining = items[:i] + items[i+1:]
        perms = exhaustive_permutations(remaining)
        for p in perms:
            result.append([items[i]] + p)
    return result",O(n!)
"class Solution2(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            while result and x < 0 < result[-1]:
                if result[-1] < -x:
                    result.pop()
                    continue
                elif result[-1] == -x:
                    result.pop()
                break
            else:
                result.append(x)
        return result",O(n)
"I=lambda:map(int,input().split())
n,m=I()
q={}
for i in range(1,n+1):q[i]=0
for i in I():q[i]+=1
print(min(q.values()))",O(n ^ 2)
"from math import log2
n = int(input())
if n == 1:
    print(1)
    exit()
elif n == 3:
    print(1, 1, 3)
    exit()
l = [1] * (n // 2)
if n % 2 == 1:
    l.append(1)

xn = int(log2(n))
tmp = n - len(l)
for i in range(2, xn+1):
    fn = tmp // 2
    if tmp % 2 == 1:
        fn += 1
    tmp -= fn
    l += ([pow(2, i-1)] * fn)
l.append((n // pow(2, xn - 1)) * pow(2, xn - 1))
print(' '.join(str(i) for i in l))",O(n)
"n = int(input())
s = list(str(input()))
t = list(str(input()))

from collections import Counter
cs = Counter(s)
ct = Counter(t)
if cs != ct:
    print(-1)
    exit()

xs = [[] for _ in range(26)]
xt = [[] for _ in range(26)]
for i in range(n):
    j = ord(s[i])-ord('a')
    xs[j].append(i)

for i in range(n):
    j = ord(t[i])-ord('a')
    xt[j].append(i)

x = [-1]*n
for i in range(26):
    for j, k in zip(xs[i], xt[i]):
        x[j] = k

ans = []
for i in range(n):
    for j in reversed(range(i+1, n)):
        if x[j-1] > x[j]:
            x[j-1], x[j] = x[j], x[j-1]
            ans.append(j)
print(len(ans))
print(*ans)",O(n ^ 2)
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
a = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")

print()
",O(nlogn)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):
    hcenter, hlen = [float(item) for item in input().split(' ')]

    cont.append([hcenter - hlen / 2, hcenter + hlen / 2])

cont.sort(key=lambda it: it[0])

for i in range(n - 1):
    gap = cont[i + 1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1
print(ans)",O(nlogn)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]

    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():

        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):

                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]]
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)
",O(nlogn)
"t=int(input())
for l in range(t):
	n=int(input())
	arr=list(map(int,input().split()))
	arr.sort()
	a=arr[-2]
	print(min(a-1,n-2))
",O(nlogn)
"n = int(input())

l = []
for i in range(n):
    c = list(map(int, input().split()))
    l.append(sum(c))

m = l[0]
l.sort(reverse=True)
for i in range(len(l)):
    if m == l[i]:
        print(i+1)
        break
",O(n)
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
from sys import stdin
rl = lambda l: tuple(map(int, l.split()))
n, a, b = rl(input())
l = list(map(rl, stdin.readlines()))
c, d = {}, {}
r = 0
for _, x, y in l:
    i, j = a * x - y, (x, y)
    r += c.get(i, 0) - d.get(j, 0)
    c[i] = c.get(i, 0) + 1
    d[j] = d.get(j, 0) + 1
print(2 * r)
",O(n)
"def main():
	n, d, k = map(int, input().split())
	if n < d+1 or d > 1 and k == 1:
		print('NO')
		return

	edges = [(1, 2)]
	stack = []
	d2 = d/2
	d21 = d2+1
	for node in range(2, d+1):
		edges.append((node, node+1))
		stack.append([node, d2-abs(d21 - node), k-2])
	next_i = d+2
	while next_i <= n:
		if not stack:
			print('NO')
			return

		node = stack[-1]
		i, remaining_depth, remaining_degree = node
		if remaining_depth == 0 or remaining_degree == 0:
			stack.pop()
			continue

		node[2] -= 1
		edges.append((i, next_i))
		stack.append([next_i, remaining_depth-1, k-1])
		next_i += 1

	print('YES')
	print('\n'.join('{} {}'.format(a, b) for a, b in edges))

main()",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
s=sum(a)
new=0
i=0
while 2*(new+a[i])<s:
    new+=a[i]
    i+=1
print(i+1)
",O(n)
"x, k = [int(v) for v in input().split()]
mod = 10**9 + 7

if x == 0:
    print(0)
else:
    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)
",O(logn)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        prod, zero_cnt = 1, 0
        for num in nums:
            if num:
                prod *= num
            else:
                zero_cnt +=  1
        if zero_cnt > 1: return [0] * len(nums)

        res = [0] * len(nums)
        for i, c in enumerate(nums):
            if zero_cnt: res[i] = 0 if c else prod
            else: res[i] = prod // c
        return res
",O(n)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
rstr = lambda: stdin.readline().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    print('%d\n%s' % (len(out), '\n'.join(out)))
",O(n ^ 2)
"from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    s = li()
    n = len(s)
    cnt = 0
    sm = 0
    for i in range(n):
        s[i] = int(s[i]) % 3
    i = 0
    while i < n:
        if s[i] == 0:
            cnt += 1
            sm = 0
            i += 1
        else:
            sm += s[i]
            if sm % 3 == 0:
                sm = 0
                cnt += 1
                i += 1
            else:
                if i + 1 < n and s[i] + s[i + 1] == 3:
                    i += 2
                    cnt += 1
                    sm = 0
                else:
                    i += 1
    print(cnt)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n)
"class Solution(object):
    def survivedRobotsHealths(self, positions, healths, directions):
        stk = []
        for i in sorted(range(len(positions)), key=lambda x:positions[x]):
            if directions[i] == 'R':
                stk.append(i)
                continue
            while stk:
                if healths[stk[-1]] == healths[i]:
                    healths[stk.pop()] = healths[i] = 0
                    break
                if healths[stk[-1]] > healths[i]:
                    healths[i] = 0
                    healths[stk[-1]] -= 1
                    break                
                healths[stk.pop()] = 0
                healths[i] -= 1
        return [x for x in healths if x]",O(nlogn)
"class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))",O(n)
"def sat_count(n, expr):
    def dfs(i, assign):
        if i==n:
            return 1 if expr(assign) else 0
        return dfs(i+1, assign+[False])+dfs(i+1, assign+[True])
    return dfs(0, [])

print(sat_count(10, lambda a: sum(a)%3==0))
",O(2 ^ n)
"class Solution2(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
        
        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums",O(nlogn)
print('4'*1131+'\n'+'5'*1130+'6'),O(1)
"class Solution(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result += left
        return result",O(n)
"n = int(input())
ans = 1+n//2
print(ans)
",O(1)
"class Solution(object):
    def minimumAverage(self, nums):
        nums.sort()
        return min((nums[i]+nums[~i])/2.0 for i in range(len(nums)//2))",O(nlogn)
"N = int(input())
m1 = []
m2 = []
ms = []
for n in range(N):
    m1.append(input())
for n in range(N):
    m2.append(input())

ms = [
    m2,
    [x[::-1] for x in m2],
    [x for x in reversed(m2)],
]

a = []
for m in ms:
    a.append(m)
    a.append([x[::-1] for x in reversed(m)])
    a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)])
    a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)])

ms = a
print(['NO', 'YES'][m1 in ms])
",O(n ^ 2)
"f=input
D,E=dict(),[eval(f())for i in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",O(n ^ 3)
"n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",O(n ^ 3)
"n, m, k = map(int, input().split())
ea = [list(map(int, input().split()))for _ in range(n)]
eb = [list(map(int, input().split()))for _ in range(n-1)]
dp = [[[10**20]*m for __ in range(n)]for _ in range(k//2+1)]
dp[0] = [[0]*m for _ in range(n)]

def show_ans():
    for line in dp[-1]:
        print(' '.join(map(str, [d*2 for d in line])))

if k % 2:
    for i in range(n):
        print(' '.join(['-1']*m))
    exit()
for t in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            if i:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i-1][j]+eb[i-1][j])
            if i < n-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i+1][j]+eb[i][j])
            if j:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j-1]+ea[i][j-1])
            if j < m-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j+1]+ea[i][j])
show_ans()
",O(n ^ 3)
"class Solution(object):
    def isDecomposable(self, s):
        if len(s)%3 != 2:
            return False
        for left in range(0, len(s), 3):
            if any(s[i] != s[i-1] for i in range(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(range(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(range(max(right-2, left), right))):
                break
        return right-left == 1",O(n)
"class Solution2(object):
    def missingNumber(self, nums):
        return sum(range(len(nums)+1)) - sum(nums)",O(n)
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N, M, A):
    A.sort(reverse=True)

    lh = A[0]
    cnt = 1
    for a in A[1:]:
        if lh == 1:
            cnt += 1
        elif lh - 1 <= a:
            cnt += 1
            lh -= 1
        else:
            cnt += lh - a
            lh = a

    cnt += lh - 1

    return sum(A) - cnt

def main():
    N, M = [int(e) for e in inp().split()]
    A = [int(e) for e in inp().split()]
    assert len(A) == N
    print(solve(N, M, A))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution2(object):
    def sortVowels(self, s):
        VOWELS = ""AEIOUaeiou""
        LOOKUP = set(VOWELS)
        vowels = [x for x in s if x in LOOKUP]
        vowels.sort(reverse=True)
        return """".join(vowels.pop() if x in LOOKUP else x for x in s)",O(nlogn)
"def permute(nums):
    res = []
    def backtrack(start):
        if start == len(nums):
            res.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start+1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return res",O(n!)
"import math
n=int(input())
print((math.floor(n/2)+1)*math.ceil(n/2))",O(n)
"x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
E = set()
T = set()
F = {('x', x), ('y', y), ('z', z)}
prv = (set(), set(), set())
fam = 2 ** 8
tmpl = '
ans = [tmpl] * fam
def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:
            ans[e[1]] = e[0]
    return set((j, i) for i, j in enumerate(ans) if j != tmpl)
while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add(('!' + f[0], ~f[1] & (fam - 1)))
        T.add(f)
        for t in prv[1]:
            T.add((t[0] + '&' + f[0], t[1] & f[1]))
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add(('(' + e[0] + ')', e[1]))
        for t in prv[1]:
            E.add((e[0] + '|' + t[0], e[1] | t[1]))
    E, T, F = cmpr(E), cmpr(T), cmpr(F)
cmpr(E)
n = int(input())
for i in range(n):
	print(ans[int(input(), 2)])",O(n ^ 2)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, s = map(int, stdin.readline().split())
stdout.write(str((s + n - 1) // n))",O(1)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
johnny=0
",O(n ^ 2)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(logn)
"def heap_permutation(n, A):
    if n == 1:
        yield A[:]
    else:
        for i in range(n):
            yield from heap_permutation(n-1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())
        a = list(map(int, input().strip().split()))
        h = Counter()
        for ai in a:
            h[ai] = h[ai] + 1 if ai in h else 1
        days = 0
        while True:
            tot = 0
            for key, cnt in h.items():
                tot += cnt // (days + 1)
            if tot < n:
                print(days)
                return
            days += 1

solver()()",O(nlogn)
"n = int(input())
A = [int(a) for a in input().split()]
B = A.copy()
B.sort()
c = 0
for i in range(n):
    c = c + 1 if A[i] != B[i] else c
print(""YES"" if c <= 2 else ""NO"")",O(nlogn)
"import math
k = int(input())

def cnt_digit_order(X):
    res = 0
    if X == 0:
        return 0
    for i in range(1, X+1):
        res += i*(9*pow(10, i-1))
    return res

L = -1
leftcnt = 0
for length in range(1, 100):
    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):
        L = length
        leftcnt = k - cnt_digit_order(length - 1)
        break

M = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))
leftcnt -= 1
leftcnt %= L
print(M[leftcnt])
",O(logn)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for j, v in enumerate(b):
	e[v][j] = j
	d[j].append(j)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"import collections


class Solution(object):
    def canConstruct(self, s, k):
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.values())
        return odd <= k <= len(s)",O(n)
"def get(self, index):
       pass

   def length(self):
       pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        def binarySearch(A, left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,
                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))
        left = binarySearch(mountain_arr, 0, peak,
                            lambda x: mountain_arr.get(x) >= target)
        if left <= peak and mountain_arr.get(left) == target:
            return left
        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,
                             lambda x: mountain_arr.get(x) <= target)
        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:
            return right
        return -1",O(logn)
"inp = input().split()
n = int(inp[0])
k = int(inp[1])

a = input().split()
for i in range(n):
    a[i] = int(a[i])

bank  = {}

for i in range(n):
    arg = (len(str(a[i])),a[i]%k)

    bank[arg] = bank.get(arg,0)+1

ans = 0

for i in range(n):
    ten = 1
    for j in range(1,11):
        ten*=10
        frontMod = (a[i]*ten)%k

        req = (k-frontMod)%k

        got = bank.get((j,req),0)
        ans += got

for i in range(n):
    cur = str(a[i])
    cur = cur*2
    tst = int(cur)
    if(tst%k==0):
        ans-=1

print(ans)",O(nlogn)
"n = int(input())
l = list(map(int,input().split()))

l = set(l)
l = list(l)

if len(l)<=1:
    print(""NO"")
    exit()

l.sort()
print(l[1])",O(nlogn)
"class Solution(object):
    def totalNumbers(self, digits):
        cnt = [0]*10
        for x in digits:
            cnt[x] += 1
        even = sum(cnt[i] != 0 for i in range(0, len(cnt), 2))
        odd = sum(cnt[i] != 0 for i in range(1, len(cnt), 2))
        result = 0
        for i in range(2, len(cnt), 2):
            if cnt[i] >= 3:
                result += 1 
        result += even*(odd+even-1)*(odd+even-2) 
        if cnt[0]:
            result -= 1*(even-1)*(odd+even-2) 
        for i in range(len(cnt)):
            if cnt[i] < 2:
                continue
            if i == 0:
                result += (odd+even)-1 
            elif i%2:
                result += even 
            else:
                result += 3*(even-1)-int(cnt[0] != 0) 
                result += 2*odd 
        return result",O(n)
"actions, end_total_candies = [int(i) for i in input().split()]
candies = 1
if(actions == 1):
    print(0)
else:
    for i in range(1, actions):
        candies = candies + i + 1

        if(candies >= end_total_candies + (actions - i - 2)):
            print(candies - end_total_candies)
            exit()
",O(logn)
"def solve(d, n, k):
    mv = sum(d[0:k])
    v = mv
    for i in range(1, n-k+1):
        mv = mv + d[i+k-1] - d[i-1]
        v = min(v, mv)
    return v

for _ in range(int(input())):
    n, k = tuple(map(int, input().split()))
    s = input()
    st = 'RGB' * (n//3 + 3)
    diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]

    for i in range(n):
        if s[i] != st[i]: diff1[i] = 1
        if s[i] != st[i+1]: diff2[i] = 1
        if s[i] != st[i+2]: diff3[i] = 1

    print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))",O(n)
"import sys

n, k = map(int, next(sys.stdin).rstrip().split())

xs = list(map(int, next(sys.stdin).rstrip().split()))

mapka = {}
lengths = {}

result = []

for x in xs:

    if x in mapka:
        result.append(mapka[x])
    else:
        left = max(0, x - k + 1)
        range_potential = x - left
        for i in range(range_potential, -1, -1):
            potential_left = x - i
            if potential_left not in mapka:
                result.append(potential_left)
                for y in range(potential_left, x + 1):
                    mapka[y] = potential_left

                lengths[potential_left] = x - potential_left + 1

                break
            else:

                if lengths[mapka[potential_left]] + (x - potential_left) <= k:
                    result.append(mapka[potential_left])
                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):
                        mapka[y] = mapka[potential_left]
                        lengths[mapka[potential_left]] += 1

                    break

print(' '.join(map(str, result)))
",O(n ^ 2)
"from math import factorial
from decimal import *
A=input()
B=input()
a=0
cnt2=0
cnt1=0
b=0
for i in A:
    if i=='+':
        a+=1
        cnt1+=1
    else:
        a-=1
        cnt2+=1
cnt3=0
cnt=0
cnt4=0
for i in B:
    if i=='+':
        b+=1
        cnt3+=1
    elif i=='-':
        b-=1
        cnt4+=1
    else:
        cnt+=1
if cnt3>cnt1 or cnt4>cnt2:
    print(format(0,'.12f'))
else:
    No_of_plus=cnt1-cnt3
    No_of_minus=cnt2-cnt4
    Total_cases=2**cnt
    Total_No_of_favourable_cases=factorial(cnt)//(factorial(No_of_plus)*factorial(No_of_minus))

    print(format(Decimal(Total_No_of_favourable_cases)/Decimal(Total_cases), '.12f'))
",np
"n = int(input())
l = [-1] * n
r = [-1] * n
a = list(map(int, input().split()))
for i in range(2 * n):
    x = a[i] - 1
    if l[x] == -1: l[x] = i
    r[x] = i
ans = 0
for i in range(n):
    for j in range(n):
        if l[i] < l[j] < r[j] < r[i]: ans += 2
for i in range(n):
    ans += r[i] - l[i] - 1
print(ans // 2)",O(n ^ 2)
"class Solution(object):
    def checkSubarraySum(self, nums, k):
        count = 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += num
            if k:
                count %= k
            if count in lookup:
                if i - lookup[count] > 1:
                    return True
            else:
                lookup[count] = i

        return False",O(n)
"class Solution(object):
    def prefixesDivBy5(self, A):
        for i in range(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]",O(n)
"def check(j):
    if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x:
        return 1
    return 0

from itertools import combinations
n,l,r,x=list(map(int,input().split()))
c=list(map(int,input().rstrip().split()))
count=0
for i in range(2,n+1):
    a=list(combinations(c,i))
    for j in a:

        if check(j):
            count+=1
print(count)
",np
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for i in range(len(nums)-2):
            if nums[i]:
                continue
            nums[i+1] ^= 1
            nums[i+2] ^= 1
            result += 1
        return result if nums[-2] == nums[-1] == 1 else -1",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())

    l = 1
    r = n + 1

    while r - l != 1:
        m = l + r >> 1
        candies = m * (m + 1) // 2
        eat = n - m

        if candies - eat <= k:
            l = m
        else:
            r = m

    print(n - l)

    return 0

main()",O(logn)
"from math import factorial
drazil = input()
dreamoon = input()
net_drazil = 0
net_dreamoon = 0
uncretain_count = 0
for i in drazil:
    if i == '-':
        net_drazil -= 1
    else:
        net_drazil += 1
for i in dreamoon:
    if i == '-':
        net_dreamoon -= 1
    elif i == '+':
        net_dreamoon += 1
    else:
        uncretain_count += 1
x = (uncretain_count + (net_drazil - net_dreamoon)) // 2
y = (uncretain_count - (net_drazil - net_dreamoon)) // 2

if abs(x) + abs(y) != uncretain_count:
    print(0.0)
else:
    out = factorial(uncretain_count)//(factorial(x)*factorial(uncretain_count-x))
    print(out/2**uncretain_count)
",np
"n, p, l, r = map(int, input().split())
if l == 1 and r == n:
    print(0)
elif l == 1:
    print(abs(p-r) + 1)
elif r == n:
    print(abs(p-l) + 1)
else:
    print(min(abs(p-l), abs(p-r)) + r - l + 2)",O(1)
"from sys import stdin

memo = {}
def max_splits(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n in memo:
        return memo[n]
    result = 4 * max_splits(n - 1) + 1
    memo[n] = result
    return result

t = int(stdin.readline())
for i in range(t):
    n, k = [int(s) for s in stdin.readline().strip().split()]

    min_splits = 1
    path_count = 3

    if n > 75:
        print(""YES"", n - 1)
        continue

    square_size = n - 1
    max_buffer = max_splits(square_size)

    while min_splits + path_count <= k and square_size > 0:
        min_splits += path_count
        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)
        path_count = 2 * path_count + 1
        square_size -= 1

    if min_splits <= k <= min_splits + max_buffer:
        print(""YES"", square_size)
    else:
        print(""NO"")
",O(logn)
"mod = 10 ** 9 + 7
x, k = map(int, input().split())
if x != 0:
    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)
else:
    print(0)
",O(logn)
"import bisect
from itertools import accumulate, count
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:

        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    primes[1]=False
    primes[0]=False
    return primes
def primefactors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
def factors(n):
    fac=set()
    fac.add(1)
    fac.add(n)
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            fac.add(i)
            fac.add(n//i)
    return list(fac)
def NcR(n, r):

    p = 1
    k = 1
    if (n - r < r):
        r = n - r

    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m

            n -= 1
            r -= 1
    else:
        p = 1
    return p
def Log2(x):
    if x == 0:
        return False;

    return (math.log10(x) /
            math.log10(2));
def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) ==
            math.floor(Log2(n)));

n, r = map(int, input().split())
x = [int(i) for i in input().split()]
c = []

for i in range(n):
    k = r
    for x1, j in c:
        d = abs(x[i] - x1)
        if d <= 2 * r:
            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)
    c.append([x[i], k])
    print(k)
",O(n ^ 2)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            m = (l + r) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m

        pivot = l
        l, r = 0, len(nums) - 1

        if target >= nums[pivot] and target <= nums[r]:
            l = pivot
        else:
            r = pivot - 1

        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return m
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1

        return -1
",O(logn)
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",O(1)
"n,l,r,x=map(int,input().split())
import math
z=list(map(int,input().split()))
count=0
for i in range(pow(2,len(z))):

    mini=math.inf
    maxa=0
    j=i
    inde=0
    sume=0
    while(j>0):

        if(j&1):
            sume+=z[inde]
            maxa=max(maxa,z[inde])
            mini=min(mini,z[inde])
        j=j>>1
        inde+=1

    if(maxa-mini>=x and l<=sume<=r):
        count+=1

print(count)
",np
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:
    print('NO')
else:
    print('YES')
",O(1)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [set() for _ in range(n)]

for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].add(b - 1)
    graph[b - 1].add(a - 1)

leafs = [i for i,v in enumerate(graph) if len(v) == 1]
new_leafs = []
valid = True
centers = dict()
count = 0

while len(leafs) > 1 and valid:
    for leaf in leafs:
        center = graph[leaf].pop()

        try:
            centers[center] += 1
        except KeyError:
            centers[center] = 1

        graph[center].remove(leaf)

        if len(graph[center]) == 0:
            break

        elif len(graph[center]) == 1:
            new_leafs.append(center)

    if any(mult < 3 for mult in centers.values()):
        valid = False
        break

    count = count + 1
    leafs = new_leafs
    new_leafs = []
    centers = {}

if valid and count == k:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"L1=list(map(int, input().split()))
numList=list(map(int, input().split()))
length=L1[0]
targetnumber=L1[1]
pos=numList.index(targetnumber)
pos_r=pos+1
rem=0
right={0:1}
left={0:1}
while pos_r<=length-1:
    if numList[pos_r]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in right:
        right[rem]=1
    else:
        right[rem]+=1
    pos_r+=1
pos_l=pos-1
rem=0
while pos_l>=0:
    if numList[pos_l]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in left:
        left[rem]=1
    else:
        left[rem]+=1
    pos_l-=1
sum=0
for number_l in left:
    if number_l*(-1) in right:
        sum += (left[number_l] * right[(-1) * number_l])
    if 1-number_l in right:
        sum += (left[number_l] * right[1-number_l])
print(sum)",O(nlogn)
"n = int(input())
for i in range(n):
    a,b = map(int, input().split())
    a1 = a
    if a % 2 == 0:
        a1 += 1
    b1 = b
    if b % 2 == 0:
        b1 -= 1
    n = 0
    if a1 <= b1:
        num = (b1 - a1) // 2 + 1
        n = num * (b1 + a1) // 2
        n *= -1
    b2 = b
    a2 = a
    if a % 2 == 1:
        a2 += 1
    if b % 2 == 1:
        b2 -= 1
    n2 = 0
    if a2 <= b2:
        num = (b2 - a2) // 2 + 1
        n2 = num * (b2 + a2) // 2
    print(n + n2)
",O(1)
"from sys import stdin,stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    a.sort()
    s = set()
    for v in a:
        if (v % k != 0) or v // k not in s:
            s.add(v)
    print(len(s))",O(nlogn)
"class Solution(object):
    def minimumDeletions(self, s):
        result = b_cnt = 0
        for c in s:
            if c == 'b':
                b_cnt += 1
            elif b_cnt:
                b_cnt -= 1
                result += 1
        return result",O(n)
"n = int(input())
s = input()

if n == 1:
    print(s)
else:
    zeros = s.count('0')
    print('1' + zeros * '0')
",O(n)
"n,p,v = input().split()
x= list(map(int,input().split()))

x.sort()
print(x[int(v)]-x[int(v)-1])",O(nlogn)
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",O(n ^ 3)
"class Solution(object):
    def colorRed(self, n):
        result = [[1, 1]]
        for i in range(2, n+1):
            if i%2 == n%2:
                result.extend([i, j] for j in range((1 if i%4 == n%4 else 3), 2*i, 2))
            else:
                result.append([i, (2 if i%4 == (n-1)%4 else 1)])
        return result",O(n ^ 2)
"import collections



class Solution2(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if nums[i]%d in cnt:
                result += cnt[nums[i]%d]
            for j in range(i):
                cnt[-(nums[i]+nums[j])%d] += 1
        return result",O(n ^ 2)
"class Permuter:
    def __init__(self):
        self.result = []
    def generate(self, items, k=None):
        if k is None:
            k = len(items)
        if k == 0:
            self.result.append([])
            return
        self.generate(items, k-1)
        new_result = []
        for perm in self.result:
            for i in range(len(perm)+1):
                new_perm = perm[:i] + [items[k-1]] + perm[i:]
                new_result.append(new_perm)
        self.result = new_result
    def get_all(self):
        return self.result",O(n!)
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out

    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()
",np
"def number(pos):
    ans = 0
    for i in range(pos + 1):
        ans += 2**(i)
    return ans

l, r = input().split()
l = int(l)
r = int(r)

if(l == r):
    print(0)
else:
    b_pos = 0
    i = 0
    while(l > 0 or r > 0):
        if(l%2 != r%2):
            b_pos = i
        l >>= 1
        r >>= 1
        i += 1
    print(number(b_pos))
",O(logn)
"def maxXORInRange(L, R):

    LXR = L ^ R

    msbPos = 0
    while(LXR):

        msbPos += 1
        LXR >>= 1

    maxXOR, two = 0, 1

    while (msbPos):

        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR

L,R = map(int, input().split())
print(maxXORInRange(L, R))",O(logn)
"n , m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
diff = [0] * n
for i in range(n):
	if a[i] < m:
		diff[i] = -1
	if a[i] > m:
		diff[i] = 1

aim = a.index(m)
left = {}
right = {}
suml = 0
for i in reversed(range(aim + 1)):
	suml += diff[i]
	if not suml in left:
		left[suml] = 0
	left[suml] += 1

sumr = 0
for i in range(aim, n):
	sumr += diff[i]
	if not sumr in right:
		right[sumr] = 0
	right[sumr] += 1

ans = 0
for i in left:
	wk1 = -i
	if wk1 in right:
		ans += left[i] * right[wk1]
	wk1 = 1 - i
	if wk1 in right:
		ans += left[i] * right[wk1]

print(ans)
",O(nlogn)
"class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

        return res
",O(n ^ 2)
"class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        if n == 0:
            return 1
        result = cnt = 1
        for i in range(n-1):
            cnt *= 9-i
            result += cnt
        return 1+9*result",O(n)
"a, b = map(int, input().split())
if a == b:
    print(0)
    exit()
aa = """"
bb = """"
while a or b:
    aa += str(a % 2)
    bb += str(b % 2)
    a //= 2
    b //= 2
aa = aa[::-1]
bb = bb[::-1]

idx = 0
while aa[idx] == bb[idx]:
    idx += 1

ln = len(aa)
r = 2 ** (ln - idx) - 1
print(r)
",O(logn)
"arr=[-1,1,2,-2,3]

def cnt(i,s):
    if i==len(arr):
        return 1 if s==0 else 0
    return cnt(i+1,s)+cnt(i+1,s+arr[i])

print(cnt(0,0))
",O(2 ^ n)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import itertools
import bisect
import heapq

def main():
    pass
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum
def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m
def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)
def p2(n):
    c=0
    while(n%2==0):
        n//=2
        c+=1
    return c
def seive(n):
    primes=[True]*(n+1)
    primes[1]=primes[0]=False
    for i in range(2,n+1):
        if(primes[i]):
            for j in range(i+i,n+1,i):
                primes[j]=False
    p=[]
    for i in range(0,n+1):
        if(primes[i]):
            p.append(i)
    return(p)
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
def denofactinverse(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return (pow(fac,m-2,m))
def numofact(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return(fac)
def sod(n):
    s=0
    while(n>0):
        s+=n%10
        n//=10
    return s
def getVal(x,y,sx,sy):

    if (x == -1 or y == -1 or x == n or y == m):
        return inF
    elif(sx==x):
        return hor[sx][min(sy,y)]
    else:
        return ver[min(sx,x)][sy]
def rec(k,x,y):
    if(x==-1 or y==-1 or x>=n or y>=m):
        return inF
    elif (k == 0):

        dp[k][x][y] = 0
        return dp[k][x][y]
    elif(dp[k][x][y]!=-1):
        return dp[k][x][y]
    else:

        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)
        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)
        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)
        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)
        dp[k][x][y]=min(val1,val2,val3,val4)
        return dp[k][x][y]
n,m,k=map(int,input().split())
adj=[[-1]*n for i in range(0,m)]
if(k%2):
    for i in range(0, n):
        for j in range(0, m):
            print(-1, end="" "")
        print("""")
else:
    hor,ver=[],[]
    inF=10**20
    k//=2
    for i in range(0,n):
        hor.append(list(map(int,input().split())))
    for i in range(0,n-1):
        ver.append(list(map(int,input().split())))
    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]
    for i in range(0,n):
        for j in range(0,m):
            print(2*rec(k,i,j),end="" "")
        print("""")
",O(n ^ 3)
"f1, f2 = map(int,input().split("" ""))
if f1==0:
  print(0)
else:
  print((pow(2,f2,1000000007)*(2*f1-1)+1)%1000000007)",O(logn)
"from sys import stdin, stdout

def dfs(l, r, dp, a_a):
    if l == r:
        return a_a[l]
    if l+1 == r:
        if a_a[l] == a_a[r]:
            return a_a[l] + 1
        else:
            return -1

    if dp[l][r] != 10**6:
        return dp[l][r]

    dp[l][r] = -1
    for m in range(l, r):
        r1 = dfs(l, m, dp, a_a)
        r2 = dfs(m+1, r, dp, a_a)
        if r1 > 0 and r1 == r2:
            dp[l][r] = r1 + 1
            return dp[l][r]

    return dp[l][r]

def array_shrinking(n, a_a):
    dp = [[10**6 for _ in range(n)]  for _ in range(n)]
    dp2 = [10**6 for _ in range(n)]
    for i in range(n):
        dp2[i] = min(i + 1, dp2[i])
        for j in range(i, n):
            r = dfs(i, j, dp, a_a)
            if r != -1:
                if i > 0:
                    dp2[j] = min(dp2[i-1] + 1, dp2[j])
                else:
                    dp2[j] = min(1, dp2[j])

    return dp2[n-1]

n = int(stdin.readline())
a_a = list(map(int, stdin.readline().split()))
res = array_shrinking(n, a_a)
stdout.write(str(res))
",O(n ^ 3)
"[n, k]=[int(i) for i in input().split()]
print((k+n-1)//n)",O(1)
"def max_subset_xor(arr):
    n = len(arr)
    best = 0
    for mask in range(1<<n):
        x = 0
        for i in range(n):
            if mask>>i & 1:
                x ^= arr[i]
        if x > best:
            best = x
    return best

print(max_subset_xor([3,5,6,9,10]))
",O(2 ^ n)
"t=int(input())
for _ in range(t):
  n,k=map(int,input().split())
  if n==2 and k==3:
    print('NO')
    continue
  if n<=100:
    curr=0
    for j in range(n):
      curr+=pow(4,j)
    if curr<k:
      print('NO')
      continue
  curr=0
  ans=0
  while curr<k and ans<n:
    ans+=1
    curr+=pow(2,ans)-1
  if curr>k:
    ans-=1
  print('YES',n-ans)",O(logn)
"class Solution2(object):
    def fib(self, N):
        prev, current = 0, 1
        for i in range(N):
            prev, current = current, prev + current,
        return prev",O(n)
"import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        result, left = 0, 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            while nums[max_dq[0]]-nums[min_dq[0]] > limit: 
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"n, l, r, x = list(map(int, input().split()))
s = list(map(int, input().split()))
olmps = []
c = []
v = 0
for i in range(1<<n):
    olmps.append([])
    for j in range(n):
        if i & (1<<j):
            olmps[-1].append(s[j])
for o in olmps:
    if l <= sum(o) <= r:
        c.append(o)
for z in c:
    if max(z) - min(z) >= x:
        v+=1
print(v)
",np
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        A = []
        for i, num in enumerate(nums):
            A.append([num, i])

        A.sort()
        i, j = 0, len(nums) - 1
        while i < j:
            cur = A[i][0] + A[j][0]
            if cur == target:
                return [min(A[i][1], A[j][1]),
                        max(A[i][1], A[j][1])]
            elif cur < target:
                i += 1
            else:
                j -= 1
        return []
",O(nlogn)
"class Solution(object):
    def subArrayRanges(self, nums):
        result = 0
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""inf"")
            while stk and nums[stk[-1]] <= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""-inf"")
            while stk and nums[stk[-1]] >= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result",O(n)
"def hanoi(n, a, b, c):
    if n == 0:
        return
    hanoi(n-1, a, c, b)
    print(a, '->', c)
    hanoi(n-1, b, a, c)

hanoi(4, 'A', 'B', 'C')
",O(2 ^ n)
"def target_sum(nums, T):
    n=len(nums)
    cnt=0
    def dfs(i, s):
        nonlocal cnt
        if i==n:
            if s==T:
                cnt+=1
            return
        dfs(i+1, s+nums[i])
        dfs(i+1, s-nums[i])
    dfs(0,0)
    return cnt

print(target_sum([1,1,1,1,1],3))
",O(2 ^ n)
"def factorial_complexity(n):
    def helper(current, remaining):
        if len(remaining) == 0:
            return [current]
        results = []
        for i in range(len(remaining)):
            results.extend(helper(current + [remaining[i]], remaining[:i] + remaining[i+1:]))
        return results
    return helper([], list(range(n)))",O(n!)
"N = int(input())
src = [tuple(map(int,input().split() + [i])) for i in range(N)]
src.sort()

prev_l = max_r = 0
prev_i = outer = -1
for l,r,i in src:
    if prev_l == l:
        print(prev_i+1, i+1)
        exit()
    if r <= max_r:
        print(i+1, outer+1)
        exit()
    else:
        max_r = r
        outer = i
    prev_l = l
    prev_i = i
print(-1,-1)
",O(nlogn)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N):
    ans = []

    end = N
    fac = 1

    while end >= 1:
        if end == 1:
            ans.append(fac)
            end = 0
            break

        if end == 2:
            ans.append(fac)
            ans.append(fac * 2)
            end = 0
            break

        if end == 3:
            ans.append(fac)
            ans.append(fac)
            ans.append(fac * 3)
            end = 0
            break

        ans.extend([fac] * ((end + 1) // 2))
        end //= 2
        fac *= 2

    return ans

def main():
    N = int(inp())
    print(*solve(N))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution(object):
    def findSubstringInWraproundString(self, p):
        letters = [0] * 26
        result, length = 0, 0
        for i in range(len(p)):
            curr = ord(p[i]) - ord('a')
            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):
                length = 0
            length += 1
            if length > letters[curr]:
                result += length - letters[curr]
                letters[curr] = length
        return result",O(n)
"from sys import stdin

rstr = lambda: stdin.readline().strip()
rints = lambda: [int(x) for x in stdin.readline().split()]

n, m, k = rints()
a = [rstr() for _ in range(n)]
mem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]

for i in range(n):
    ixs = []
    for j in range(m):
        if a[i][j] == '1':
            ixs.append(j)

    for j in range(k + 1):
        tem = 0
        if j < len(ixs):
            tem, c = float('inf'), 0
            for j1 in range(len(ixs) - j - 1, len(ixs)):
                tem = min(tem, ixs[j1] - ixs[c] + 1)
                c += 1

        for j1 in range(k + 1 - j):
            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)

print(mem[n][k])
",O(n ^ 3)
"n,pos,l,r=map(int,input().split())
if l==1 and r==n:
    print(0)
elif l==1:
    print(abs(pos-r)+1)
elif r==n:
    print(abs(pos-l)+1)
else:
    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)",O(1)
"n = int(input())
a = list(map(int, input().split()))
s = list(map(int, input().split()))
d = []
for q in range(n):
    d.append(a[q]+s[q])
d = [n-q for q in d]
for q in range(n):
    f = 0
    for q1 in range(q):
        if d[q1] > d[q]:
            f += 1
    g = 0
    for q1 in range(q+1, n):
        if d[q1] > d[q]:
            g += 1
    if f != a[q] or g != s[q]:
        print('NO')
        break
else:
    print('YES')
    print(*d)
",O(n ^ 2)
"class Solution2(object):
    def minWindow(self, s, t):
        current_count = [0 for i in range(52)]
        expected_count = [0 for i in range(52)]

        for char in t:
            expected_count[ord(char) - ord('a')] += 1

        i, count, start, min_width, min_start = 0, 0, 0, float(""inf""), 0
        while i < len(s):
            current_count[ord(s[i]) - ord('a')] += 1
            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:
                count += 1

            if count == len(t):
                while expected_count[ord(s[start]) - ord('a')] == 0 or \
                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:
                    current_count[ord(s[start]) - ord('a')] -= 1
                    start += 1

                if min_width > i - start + 1:
                    min_width = i - start + 1
                    min_start = start
            i += 1

        if min_width == float(""inf""):
            return """"

        return s[min_start:min_start + min_width]",O(n)
"from math import ceil, sqrt, log

def mod_expo(n, p, m):

	result = 1
	while p != 0:
		if p%2 == 1:
			result = (result * n)%m
		p //= 2
		n = (n * n)%m
	return result

def is_square(n):
	return int(sqrt(n))*int(sqrt(n)) == n

def find_div(n):
	d = []
	for i in range(2, int(sqrt(n))+1):
		if n%i == 0:
			if i*i != n:
				d.append(i)
				d.append(n/i)
			else:
				d.append(i)
	return d

def find_x(n):
	d = find_div(2*n)
	for div in d:
		x2 = div*(div + 2*n)
		if is_square(x2):
			return sqrt(x2)
	return -1

def find_base_side(n):
	squares = [x*x for x in range(ceil(sqrt(n)))]
	for i in range(len(squares)):
		for j in range(len(squares)):
			if squares[i] + squares[j] == n*n:
				return squares[i]
	return -1

def str_add(n):
	n = list(n)
	for i in range(1, len(n)+1):
		if n[-i] == '9':
			n[-i] = '0'
		else:
			n[-i] = int(int(n[-i]) + 1)
			break
	n = str(n)
	return n

def str_sub(n):
	n = list(n)
	for i in range(1, len(n)+1):
		if n[-i] == '0':
			n[-i] = '9'
		else:
			n[-i] = int(int(n[-i]) - 1)
			break
	n = str(n)
	return n

def find_massive_x(n):
	if n%2 == 0:
		n2 = str(int(pow(n/2, 2)))
		x = str_sub(n2)
		y = str_add(n2)
	else:
		n2 = str(int(pow(n, 2)/2))
		x = str_sub(n2)
		y = str_add(n2)
	x = str(x)
	y = str(y)
	print(x, y)
def find_triples(n):
	if n <= 2:
		print(-1)
		return
	else:

		x = find_massive_x(n)

	print(-1)

def find_max_xor(l, r):
	lxr = l^r
	msb_pos = 0
	while lxr > 0:
		msb_pos += 1
		lxr //= 2
	return pow(2, msb_pos)-1

t = 1

while t:
	t = t - 1

	print(find_max_xor(l, r))
",O(logn)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

DP=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
    DP[i][i]=A[i]

for mid in range(1,n):
    for i in range(n):
        j=i+mid
        if j==n:
            break
        for k in range(i,j+1):
            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:
                DP[i][j]=DP[i][k]+1

ANS=[2000]*(n+1)
ANS.append(0)
for i in range(n):
    ANS[i]=min(ANS[i],ANS[i-1]+1)
    for j in range(i,n):
        if DP[i][j]!=-1:
            ANS[j]=min(ANS[j],ANS[i-1]+1)

print(ANS[n-1])
",O(n ^ 3)
"n=int(input())
arr=[int(x) for x in input().split()]
pos=dict()
if(n==1):print(""B"")
else:
    for i in range(n):
        pos[arr[i]]=i
    ans=[""Q""]*n

    ans[pos[1]]=""A""
    ans[pos[n]]=""B""
    for i in range(n-1,0,-1):
        flag=0
        p=pos[i]
        j=1
        while(p+j*i<n):
            if(ans[p+j*i]==""B""):
                flag=1
                ans[pos[i]]=""A""
                break
            j+=1
        if(flag==0):
            j=1
            while(p-j*i>=0):
                if(ans[p-j*i]=='B'):
                    flag=1
                    ans[pos[i]]=""A""
                    break
                j+=1
        if(flag==0):ans[pos[i]]=""B""
    print("""".join(ans))
",O(nlogn)
"class Solution(object):
    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0]+energyDrinkA[i], dp[1]), max(dp[1]+energyDrinkB[i], dp[0])]
        return max(dp)",O(n)
"n = int(input())
ans = 0
if n==1:
    print(1)
    exit()
if n==2:
    print(2)
    exit()
if n==3:
    print(6)
    exit()
if n%2==0:
    if n%3==0:
        ans=(n-1)*(n-2)*(n-3)
    else:
        ans=n*(n-1)*(n-3)
else:
    ans=n*(n-1)*(n-2)

print(ans)",O(1)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",O(n ^ 2)
"n = int(input())
A = [0] + list(map(int,input().split()))

vec = []
for i in range(1, n+1) :
	vec = vec + [[A[i], i]]
list.sort(vec)
list.reverse(vec)

if vec[0][0] == 1 :
	print(""NO"")
	exit(0)

dia = 0
path = [vec[0][1]]
ans = []
bol, col, idx = 1, 1, 0
for i in vec[1:] :

	if i[0] != 1 :
		ans = ans + [[path[-1], i[1]]]
		dia = dia+1
		A[path[-1]] = A[path[-1]]-1
		path += [i[1]];
		A[path[-1]] = A[path[-1]]-1
	else :
		if col == 1:
			dia = dia+1
			col = 0
			A[path[0]] -= 1
			ans = ans+ [[path[0], i[1]]]
		elif bol == 1:
			dia = dia+1
			bol = 0
			A[path[-1]] -= 1
			ans = ans + [[path[-1], i[1]]]
		else :
			while idx < len(path) and A[path[idx]] == 0 :
				idx = idx+1
			if idx == len(path) :
				print(""NO"")
				exit(0)
			A[path[idx]] = A[path[idx]] - 1;
			ans = ans + [[path[idx], i[1]]]

print(""YES"", dia)
print(len(ans))
for i in ans :
	print(i[0], i[1])
",O(nlogn)
"import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        MOD = 10**9 + 7
        result, s_sum = 0, 0
        min_heap = []
        for e, s in sorted(zip(efficiency, speed), reverse=True):
            s_sum += s
            heapq.heappush(min_heap, s)
            if len(min_heap) > k:
                s_sum -= heapq.heappop(min_heap)
            result = max(result, s_sum*e)
        return result % MOD",O(nlogn)
"import sys

def rint():
    return map(int, sys.stdin.readline().split())

def writable(r, c):
    if r+2 >= n or c+2 >= m:
        return False
    t = set()
    t.add(cells[r][c])
    t.add(cells[r][c+1])
    t.add(cells[r][c+2])
    t.add(cells[r+1][c])
    t.add(cells[r+1][c+2])
    t.add(cells[r+2][c])
    t.add(cells[r+2][c+1])
    t.add(cells[r+2][c+2])
    return not '.' in t

def fill_ink(r,c):
    paper[r][c] = ""
    paper[r][c+1] = ""
    paper[r][c+2] = ""
    paper[r+1][c] = ""
    paper[r+1][c+2] = ""
    paper[r+2][c] = ""
    paper[r+2][c+1] = ""
    paper[r+2][c+2] = ""

n, m = rint()

cells = []
for i in range(n):
    cells.append(input())

paper = [[""."" for j in range(m)] for i in range(n)]

for r in range(n):
    for c in range(m):
        if writable(r,c) is True:
            fill_ink(r, c)

for r in range(n):
    for c in range(m):
        if cells[r][c] != paper[r][c]:
            print(""NO"")
            exit()

print(""YES"")
",O(n ^ 2)
"import math as mt
import itertools as it
n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
ans=0
for j in range(2,n+1):
    for i in it.combinations(a,j):
        if max(i)-min(i)>=x and l<=sum(i)<=r:
            ans+=1
print(ans)",np
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        seen = set()
        for num in nums:
            if num in seen:
                return num
            seen.add(num)
        return -1
",O(n)
"def dfs_permute(path, unused):
    if not unused:
        yield path
    for item in list(unused):
        unused.remove(item)
        yield from dfs_permute(path + [item], unused)
        unused.add(item)",O(n!)
"class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]",O(n)
"t = int(input())
for i in range(t):
    n = int(input())
    ai = list(map(int,input().split()))
    ai.sort()
    print(min(n-2,ai[-2]-1))
",O(nlogn)
"nr, ng, nb = map(int, input().split())
r = sorted([int(i) for i in input().split()])
g = sorted([int(i) for i in input().split()])
b = sorted([int(i) for i in input().split()])

dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            val = 0
            if i - 1 >= 0 and j - 1 >= 0:
                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])
            if i - 1 >= 0 and k - 1 >= 0:
                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])
            if j - 1 >= 0 and k - 1 >= 0:
                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])
            dp[i][j][k] = val

print(dp[nr][ng][nb])
",O(n ^ 3)
"n=input()
i=0
while(True):
    if (n-9*10**i*(i+1))<=0:
        break
    n-=9*10**i*(i+1)
    i+=1

a=n/(i+1)
b=n%(i+1)
if(b!=0):
    print(str(10**i+a)[b-1])
else:
    print(str(10**i+a-1)[-1])
",O(1)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
x, y = ria()
bx, by = ria()
cx, cy = ria()

x1, y1 = x - bx, y - by
x2, y2 = x - cx, y - cy

if abs(x2) == abs(y2):
    print('NO')
    exit(0)
if math.copysign(x2, x1) != x2:
    print('NO')
    exit(0)
if math.copysign(y2, y1) != y2:
    print('NO')
    exit(0)
print('YES')",O(1)
"import itertools



class Solution(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))

        def check(x, t):
            return sum(c for y, c in zip(nums, cost) if y <= x) >= t
    
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        total = sum(cost)
        median = (total+1)//2
        while left <= right:
            mid = left+(right-left)//2
            if check(nums[idxs[mid]], median):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",O(n ^ 3)
"from math import gcd

n = int(input())
d = dict()
qs = []
for i in range(n):
    s = input()
    a = int(s[1:s.index('+')])
    b = int(s[s.index('+') + 1: s.index(')')])
    c = int(s[s.index(')') + 2:])
    a = a + b
    gc = gcd(a, c)
    res = (a // gc, c // gc)
    qs.append(res)
    if res in d:
        d[res] += 1
    else:
        d[res] = 1
for q in qs:
    print(d[q], end=' ')
",O(n)
"import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"from math import factorial

def C(k, n):
    return factorial(n) // factorial(k) // factorial(n - k)

s1 = input()
s2 = input()
n1 = s1.count('+')
n2 = s2.count('+')
n3 = s2.count('?')
if n2 > n1:
    print(0)
else:
    try:
        print(C(n1 - n2, n3) / (2 ** n3))
    except:
        print(0)
",np
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

def pre(x, y):
    w = x * (y // 2) + (y % 2) * (x + 1) // 2
    b = x * (y // 2) + (y % 2) * x // 2
    assert w + b == x * y
    return w

def count(x1, y1, x2, y2):
    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)
    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w
    return w, b

for t in range(ii()):
    n, m = mi()
    x1, y1, x2, y2 = mi()
    x3, y3, x4, y4 = mi()
    w = pre(m, n)
    b = m * n - w

    wc, bc = count(x1, y1, x2, y2)
    w -= wc
    b -= bc
    w += (x2 - x1 + 1) * (y2 - y1 + 1)

    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):
        x5 = max(x1, x3)
        y5 = max(y1, y3)
        x6 = min(x2, x4)
        y6 = min(y2, y4)
        w -= (x6 - x5 + 1) * (y6 - y5 + 1)
        wc, bc = count(x5, y5, x6, y6)
        w += wc
        b += bc
    wc, bc = count(x3, y3, x4, y4)
    w -= wc
    b -= bc
    b += (x4 - x3 + 1) * (y4 - y3 + 1)
    print(w, b)",O(1)
"n=int(input())
l=list(str(n))
if n>=0:
	print(n)
else:
	if int(l[-1])>int(l[-2]):
		l.pop(-1)
	else:
		l.pop(-2)
	print(int(''.join(l)))
",O(1)
"n=int(input())
arr=list(map(int,input().split()))
dp=[[-1 for i in range(5+1)] for j in range(n)]
for i in range(1,6):
    dp[0][i] =1
for i in range(1,n):
    if arr[i] > arr[i - 1]:
        for j in range(1,6):
            for k in range(1,j):
                if dp[i-1][k]==1:
                    dp[i][j] =1
                    break
    elif arr[i] <arr[i-1]:
        for j in range(1,6):
            for k in range(j+1,6):
                if dp[i-1][k] ==1:
                    dp[i][j]=1
                    break
    else:
        for j in range(1,6):
            for k in range(1,6):
                if j ==k:
                    continue
                if dp[i-1][k] ==1:
                    dp[i][j] =1
                    break
ans=[]
for i in range(1,6):
    if dp[n-1][i]==1:
        ans.append(i)
        break
if len(ans) ==0:
    print(-1)
    exit()
for i in range(n-2,-1,-1):
    curr=ans[-1]
    if arr[i] >arr[i+1]:
        for j in range(curr+1,6):
            if dp[i][j] ==1:
                ans.append(j)
                break
    elif arr[i] <arr[i+1]:
        for j in range(1,curr):
            if dp[i][j] ==1:
                ans.append(j)
                break
    else:
        for j in range(1,6):
            if j ==curr:
                continue
            if dp[i][j] ==1:
                ans.append(j)
                break
ans=ans[::-1]
print(*ans)
",O(n)
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
elif 3*k <= n:

    print((""0"" * ((n-k)//2)) + ""1"" + (""0""*(k-2)) + ""1"" + ""0"" * ((n-k)//2))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",O(1)
"import math
k = int(input())

flag = True
i = 0
value=0

if(k <= 9):
    print(k)

else:
    while(flag):
        a = 9 * pow(10, i) * (i+1)
        if(k >= a):
            k -= a
            value+=9 * pow(10, i)
            i+=1
        else:
            n=int(math.ceil(k/(i+1)))
            value+=n
            index=k%(i+1)-1
            print(str(value)[index])
            flag=False
",O(logn)
"class Solution(object):
    def addNegabinary(self, arr1, arr2):
        result = []
        carry = 0
        while arr1 or arr2 or carry:
            if arr1:
                carry += arr1.pop()
            if arr2:
                carry += arr2.pop()
            result.append(carry & 1)
            carry = -(carry >> 1)
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        result.reverse()
        return result",O(n)
"class Solution2(object):
    def timeTaken(self, edges):
        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            result[u] = max(dp[u][0][0], curr)
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        dfs1(0, -1)
        result = [0]*(len(edges)+1)
        dfs2(0, -1, 0)
        return result",O(n)
"a,b=map(int,input().split())
ans=0
while a and b:
  ans+=a//b
  a,b=b,a%b
print(ans)",O(1)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        res = 0
        nums.sort()

        curr, streak = nums[0], 0
        i = 0
        while i < len(nums):
            if curr != nums[i]:
                curr = nums[i]
                streak = 0
            while i < len(nums) and nums[i] == curr:
                i += 1
            streak += 1
            curr += 1
            res = max(res, streak)
        return res
",O(nlogn)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"from bisect import bisect_right as br
from bisect import bisect_left as bl
MAX = 10**9
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)

n,m = map(int,input().split())
v = []
h = []
for _ in range(n):
    v.append(int(input()))

for _ in range(m):
    x1,x2,y = map(int,input().split())
    if(x1==1):
        h.append(x2)
lh = len(h)
h.sort()
v.sort()
if not lh:
    print(0)
elif n==0:
    print(lh-bl(h,MAX))
else:
    mn = n+lh-bl(h,MAX)
    for i in range(n):
        mn = min(mn,lh-bl(h,v[i])+i)
    print(mn)
",O(nlogn)
"my_list = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""yellow"":""Mind"", ""red"":""Reality""}

n = int(input())
for i in range(n):
    my_list.pop(input())

print(len(my_list))
for i in my_list:
    print(my_list[i])",O(1)
"class Solution2(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(3)]
            for i in range(start, end):
                for j in range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):
                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])
            return dp[(end-1)%3][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"class Solution(object):
    def minMoves(self, target, maxDoubles):
        result = 0
        while target > 1 and maxDoubles:
            result += 1+target%2
            target //= 2
            maxDoubles -= 1
        return result+(target-1)",O(logn)
"import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n, s = map(int, input().split())
    lo, hi = s, n
    ans = n + 1
    while lo <= hi:
        mid = (lo + hi) // 2
        z = sum(map(int, str(mid)))
        if mid >= s + z:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    print(n - ans + 1)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(logn)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]

def get_permutations(n):
    pg = PermutationGenerator()
    pg.generate(list(range(n)))
    return pg.result",O(n!)
"import bisect
import sys
input=sys.stdin.readline

import collections
import heapq
t=1
p=10**9+7
def ncr_util():

    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p

def solve():
    ans,a,b=0,0,0
    mul=2**60
    for i in range(60,-1,-1):

        ch1,ch2=0,0
        if a+mul<=l:

            a+=mul
            ch1=1
        if  b+mul<=l:

            b+=mul
            ch2=1
        if ch1^ch2==1:
            ans+=mul
        elif ch1==0 and ch2==0:
            if a+mul<=r:
                a+=mul
                ans+=mul
            elif b+mul<=r:
                b+=mul
                ans+=mul

        mul//=2

    return ans

for _ in range(t):

    l,r=map(int,input().split())

    print(solve())
",O(logn)
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = False
        self.__cv = threading.Condition()

    def foo(self, printFoo):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != False:
                    self.__cv.wait()
                self.__curr = not self.__curr
                printFoo()
                self.__cv.notify()

    def bar(self, printBar):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != True:
                        self.__cv.wait()
                self.__curr = not self.__curr
                printBar()
                self.__cv.notify()
",O(n)
"import random



class Solution2(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(u, p):
            result = 0
            diff = []
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                result += cnt[0]
                diff.append(max((cnt[1]+w)-cnt[0], 0))
            if k-1 < len(diff):
                nth_element(diff, k-1, lambda a, b: a > b)
            return (result+sum(diff[i] for i in range(min(k, len(diff)))), result+sum(diff[i] for i in range(min(k-1, len(diff)))))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dfs(0, -1)[0]",O(n)
"class Solution(object):
    def findPeaks(self, mountain):
        return [i for i in range(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]",O(n)
"

class Solution(object):
    def restoreString(self, s, indices):
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return """".join(result)


",O(n)
"class Solution(object):
    def maxProfit(self, prices):
        hold1, hold2 = float(""-inf""), float(""-inf"")
        release1, release2 = 0, 0
        for i in prices:
            hold1 = max(hold1, -i)
            release1 = max(release1, hold1 + i)
            hold2 = max(hold2, release1 - i)
            release2 = max(release2, hold2 + i)
        return release2",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos

x, y, z, t1, t2, t3 = map(int, stdin.readline().split())

if abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1:
    stdout.write('YES')
else:
    stdout.write('NO')",O(1)
"def get_all_permutations(sequence):
    if len(sequence) == 0:
        return []
    if len(sequence) == 1:
        return [sequence]
    perms = []
    for i in range(len(sequence)):
        current = sequence[i]
        remaining = sequence[:i] + sequence[i+1:]
        for p in get_all_permutations(remaining):
            perms.append([current] + p)
    return perms",O(n!)
"x,k=map(int,input().split())
mod=1000000007
print((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)",O(logn)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"def string_permutations(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        for perm in string_permutations(s[:i] + s[i+1:]):
            perms.append(char + perm)
    return perms",O(n!)
"class Solution(object):
    def minSwaps(self, nums):
        result = cnt = w = nums.count(1)
        for i in range(len(nums)+(w-1)):
            if i >= w:
                cnt += nums[(i-w)%len(nums)]
            cnt -= nums[i%len(nums)]
            result = min(result, cnt)
        return result",O(n)
"class Solution2(object):
    def countSubarrays(self, nums):
        result = left = 0
        for right in range(len(nums)):
            if not (right-1 >= 0 and nums[right-1] < nums[right]):
                left = right
            result += right-left+1
        return result",O(n)
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)

	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break",O(n ^ 3)
"n, = map(int,input().split())
arr = set(map(int,input().split()))
print(len(arr)-(0 in arr))
",O(n)
"n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans

    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()
",O(n ^ 3)
"class Solution(object):
    def addSpaces(self, s, spaces):
        prev = len(s)
        s = list(s)
        s.extend([None]*len(spaces))
        for i in reversed(range(len(spaces))):
            for j in reversed(range(spaces[i], prev)):
                s[j+1+i] = s[j]
            s[spaces[i]+i] = ' '
            prev = spaces[i]
        return """".join(s)",O(n)
"class Solution3(object):
    def flipEquiv(self, root1, root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2 or root1.val != root2.val:
            return False

        return (self.flipEquiv(root1.left, root2.left) and
                self.flipEquiv(root1.right, root2.right) or
                self.flipEquiv(root1.left, root2.right) and
                self.flipEquiv(root1.right, root2.left))",O(n)
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        if s == s[::-1]: 
            return len(s)

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return dp[0][-1]",O(n ^ 2)
print((int(input()))//2+1),O(1)
"n=int(input())
c=0
for j in range(2,1+n//2):
	e=0
	i=n//j
	e+=(i*(i+1))//2
	e-=1
	if e>0:
		c+=e
print(c*4)",O(n)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    print((solve(r) - solve(l - 1)) % mod)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"from functools import lru_cache

P = 10**9+7
N, T = map(int, input().split())
A = [[], [], []]
X = []
for _ in range(N):
    t, g = map(int, input().split())
    X.append((t, g))

@lru_cache(maxsize=None)
def calc(x, pr, t):
    if t < 0:
        return 0
    if t == 0:
        return 1
    if x == 0:
        return 0

    ans = 0
    for i in range(15):
        if x & (1<<i):
            if X[i][1] != pr:
                y = x ^ (1<<i)
                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P
    return ans

print(calc(2**N-1, -1, T))",np
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"class Solution2(object):
    def rotateString(self, A, B):
        def strStr(haystack, needle):
            def KMP(text, pattern):
                prefix = getPrefix(pattern)
                j = -1
                for i in range(len(text)):
                    while j > -1 and pattern[j + 1] != text[i]:
                        j = prefix[j]
                    if pattern[j + 1] == text[i]:
                        j += 1
                    if j == len(pattern) - 1:
                        return i - j
                return -1

            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix

            if not needle:
                return 0
            return KMP(haystack, needle)

        if len(A) != len(B):
            return False
        return strStr(A*2, B) != -1",O(n)
"import sys
dp=[]
a=[]
def calcdp(l,r):
    global dp,a
    if l+1==r :
        dp[l][r]=a[l]
        return dp[l][r]
    if dp[l][r]!=0:
        return dp[l][r]
    dp[l][r]=-1
    for k in range(l+1,r):
        la=calcdp(l,k)
        ra=calcdp(k,r)
        if la>0 and la==ra:
            dp[l][r]=la+1
    return dp[l][r]
def solve(n):
    dp2=[float('inf')]*(n+1)
    dp2[0]=0
    for i in range(n):
        for j in range(i+1,n+1):
            if calcdp(i,j)>0:
                dp2[j]=min(dp2[j],dp2[i]+1)

    return dp2[n]
def ip():
    global dp,a

    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))
    a.append(0)

    dp=[]
    ll=[0]*(n+1)
    for _ in range(n+1):
        dp.append(list(ll))

    print(solve(n))

ip()
",O(n ^ 3)
"n = int(input())
print(n, 0, 0)",O(1)
"def comp(a,b):
    x=len(a)
    s1=''
    s2=''
    for i in range(x):
        s1+=str(a[i])
        s2+=str(b[i])
    if s1>s2:
        return 1
    else:
        return 0

a=list(input(''))
b=list(input(''))
cnt=[0]*10
n=len(a)
m=len(b)
sol=''
for i in range(n):
    a[i]=int(a[i])
    cnt[a[i]]+=1

if n!=m:
    a.sort(reverse=True)
    for i in a:
        sol+=str(i)
    print(sol)
else:
    a.sort()

    for i in range(n):
        b[i]=int(b[i])
    for i in range(n-1):
        for j in range(i,n):
            if a[i]<a[j]:
                temp=a[i]
                a[i]=a[j]
                a[j]=temp
                if comp(a,b):
                    temp=a[i]
                    a[i]=a[j]
                    a[j]=temp

    for i in a:
        sol+=str(i)
    print(sol)",O(n ^ 3)
"from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
    return sys.stdout.flush()

def fac(n):
    ans = 1
    for i in range(1,n+1):
        ans*=i
        ans%=MOD
    return ans

n = int(input())
a = arrIN()
a.sort()
f = [1]*n
cnt = 0
for i in range(n):
    if f[i]:
        cnt+=1
        for j in range(i,n):
            if f[j] and a[j]%a[i]==0:
                f[j] = 0
        f[i] = 0
print(cnt)
",O(n ^ 2)
"from math import ceil
n, k = map(int, input().split())
print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))",O(1)
"n=int(input())
a=list(map(int, input().rstrip().split()))
a.sort()
sum1=0
rem=sum(a)
i=len(a)-1
c=0
while(sum1<=rem):
    sum1+=a[i]
    rem=sum(a)-sum1
    i-=1
    c+=1
print(c)",O(nlogn)
"class Solution(object):
    def minSwaps(self, s):
        result = curr = 0
        for c in s:
            if c == ']':
                curr += 1
                result = max(result, curr)
            else:
                curr -= 1
        return (result+1)//2",O(n)
"class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in zip(sorted(s1), sorted(s2))))",O(n)
"n = int(input())
a = sorted(list(map(int, input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"n = int(input())

a = list(map(lambda i: int(i), input().split(sep=' ')))
a.sort()
a_count = len(a)

b = list(filter(lambda i: i > 0, a))
b_count = len(b)

def resh():
    idx = 1
    while idx < a_count:
        if a[idx] == a[idx - 1] and (a[idx] - 1) in a:
            return 'cslnb'
        idx += 1

    b_sum = sum(b)
    v_sum = sum(range(1, b_count if a_count == b_count else b_count + 1))
    t = max(b_sum - v_sum, 0)
    return 'cslnb' if t % 2 == 0 else 'sjfnb'

if b_count == 0 or  b_count - len(set(b)) > 1 or a_count - b_count > 1:
    print('cslnb')
else:
    print(resh())
",O(nlogn)
"class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))",O(n)
"from itertools import *
n, s = map(int, input().split())
times = []
for i in range(n):
    h, m = map(int, input().split())
    times.append((h * 60 + m))

times.sort()
for t in count():
    if all(abs(u - t) > s for u in times):
        print(*divmod(t, 60))
        break
",O(n)
"class Solution(object):
    def depthSumInverse(self, nestedList):
        def depthSumInverseHelper(list, depth, result):
            if len(result) < depth + 1:
                result.append(0)
            if list.isInteger():
                result[depth] += list.getInteger()
            else:
                for l in list.getList():
                    depthSumInverseHelper(l, depth + 1, result)

        result = []
        for list in nestedList:
            depthSumInverseHelper(list, 0, result)

        sum = 0
        for i in reversed(range(len(result))):
            sum += result[i] * (len(result) - i)
        return sum",O(n)
"import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))",O(n)
"import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result",O(n)
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",O(logn)
"n = int(input())
a = list(map(int, input().split()))

if sum(a) < (2 * n) - 2:
    print(""NO"")
else:
    one = []
    rst = []
    for i in range(0, n):
        if a[i] > 1:
            rst.append(i)
        else:
            one.append(i)
    ans = []
    for i in range(1, len(rst)):
        ans.append((rst[i], rst[i - 1]))
        a[rst[i]] -= 1
        a[rst[i - 1]] -= 1
    for i in range(1, len(one)):
        for j in range(0, len(rst)):
            if a[rst[j]] > 0:
                a[rst[j]] -= 1
                ans.append((rst[j], one[i]))
                break
    if len(one):
        for i in range(len(rst) - 1, -1, -1):
            if a[rst[i]] > 0:
                ans.append((rst[i], one[0]))
                break
    siz = min(len(one) + len(rst), 2 + len(rst)) - 1
    print(""YES "", siz)

    print(len(ans))
    for u,v in ans:
        print(u + 1,v + 1)
",O(n ^ 2)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
from collections import defaultdict as df

import random

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node:
                return
            if not node.left and not node.right:
                yield node.val
            for i in dfs(node.left):
                yield i
            for i in dfs(node.right):
                yield i
        return all(a == b for a, b in
                   itertools.zip_longest(dfs(root1), dfs(root2)))",O(n)
"def count_k_subsets(n,k):
    cnt=0
    def dfs(i, chosen):
        nonlocal cnt
        if i==n:
            if chosen==k:
                cnt+=1
            return
        dfs(i+1, chosen)
        dfs(i+1, chosen+1)
    dfs(0,0)
    return cnt
print(count_k_subsets(10,3))
",O(2 ^ n)
"n=5
sol=[]
arr=list(range(n))
choose=[False]*n
def go(i):
    if i==n:
        a=[arr[j] for j in range(n) if choose[j]]
        b=[arr[j] for j in range(n) if not choose[j]]
        sol.append((tuple(a),tuple(b)))
        return
    choose[i]=False
    go(i+1)
    choose[i]=True
    go(i+1)
    choose[i]=False

go(0)
",O(2 ^ n)
"from sys import *
mod=1000000007
n,q=map(int,stdin.readline().split())
s=str(stdin.readline())
arr=[]
count=0
for i in s:
	if(i=='1'):
		count+=1
	arr.append(count)

ansarr=[]
for i in range(q):
	x,y=map(int,input().split())
	if(x==1):
		total1=arr[y-1]
	else:
		total1=arr[y-1]-arr[x-2]
	total0=(y-x+1-total1)
	ans=pow(2,y-x+1,mod)%mod
	ans=((((ans%mod)-(pow(2,total0,mod)%mod))%mod)+mod)%mod
	ansarr.append(ans)
stdout.write('\n'.join(map(str, ansarr)))",O(n)
"n=int(input())
a=[0] + list(map(int,input().split()))
d={}
for i in range(1,n+1):
    d[a[i]]=i
ans=0
for i in range(1,n+1):
    if a[i]!=i:
        ind1=d[a[i]]
        ind2=d[i]
        va1=a[i]
        val2=i
        a[ind1],a[ind2]=a[ind2],a[ind1]
        d[i]=i
        d[va1]=ind2
        ans+=1

if (3*n - ans)%2==0:
    print(""Petr"")
else:
    print(""Um_nik"")
",O(nlogn)
"class Solution(object):
    def maximumLength(self, nums):
        k = 2
        result = 0
        for i in range(k):
            dp = [0]*k
            for x in nums:
                dp[x%k] = dp[(i-x)%k]+1
            result = max(result, max(dp))
        return result",O(n)
"entrada = input().split()

l = int(entrada[0])
r = int(entrada[1])

pop = l ^ r
result = 1

while (result <= pop):
    result = result << 1

print(result - 1)
",O(logn)
"from collections import defaultdict

n = int(raw_input())
t = defaultdict(list)
for _ in range(n - 1):
    u, v = map(int, raw_input().split())
    t[u].append(v)
    t[v].append(u)
a = list(map(int, raw_input().split()))
o = {a_: i for i, a_ in enumerate(a)}

i = 0
q = [1]
lv = {1: 0}
par = {1: 1}
while i < len(q):
    u = q[i]
    i += 1
    for v in t[u]:
        if v not in lv:
            lv[v] = lv[u] + 1
            q.append(v)
            par[v] = u

depths = defaultdict(list)
for x in a:
    depths[lv[x]].append(o[par[x]])

ans = a[0] == 1
if ans:
    for d in depths.values():
        if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)):
            ans = False
            break

if ans:
    l = [lv[x] for x in a]
    ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1))

print(('No', 'Yes')[ans])
",O(n)
"def binaries(n):
    out=[]
    def rec(prefix,k):
        if k==n:
            out.append(prefix)
            return
        rec(prefix+'0',k+1)
        rec(prefix+'1',k+1)
    rec('',0)
    return out
b=binaries(5)
print(b[:3]+b[-3:])
",O(2 ^ n)
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    ax, ay = map(int, next(cin).split())
    bx, by = map(int, next(cin).split())
    cx, cy = map(int, next(cin).split())

    if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
        print('YES')
    else:
        print('NO')
",O(1)
"k = int(input())
prev=0
nextt=0
NumofDigits=0

while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",O(1)
"import sys
input = sys.stdin.readline
def multi_input():
    return map(int, input().split())

def sum(n,r):
    return n*(2*r - (n-1))//2

def function(total, l, r):
    left = l
    right = r

    while left<=right:
        mid = (right + left) // 2
        result = sum(r-mid+1, r)
        if result==total:
            return r-mid+1
        elif result > total:
            left = mid + 1
        else:
            if sum(r-mid+2,r) > total:
                return r-mid + 2
            else:
                right = mid - 1
    return -1

n, m = multi_input()

n = n-1
m = m-1
if n==0:
    print(0)
elif sum(m,m)<n:
    print(-1)
elif m<n:
    print(function(n, 1, m))
else:
    print(1)
",O(logn)
"import sys
input = lambda: sys.stdin.readline().strip()
from math import ceil

def mismatch(s1, s2):
    cnt = 0
    for i in range(len(s1)):
        if s1[i]!=s2[i]: cnt+=1
    return cnt

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    check = ''
    for i in range(ceil((k+2)/3)):
        check+='RGB'
    ls = []
    for i in range(3):
        ls.append(check[i:i+k])
    s = input()
    m = n
    for i in range(n-k+1):
        for j in ls:
            m = min(m, mismatch(s[i:i+k], j))
    print(m)
",O(n ^ 2)
"class DFS:
    def __init__(self):
        self.G= []
        self.leave_tree= []

    def take_input(self):
        k = int(input())
        if(k>1):
            graph =[int(node)-1 for (node) in input().split(' ')]
            self.G = [[] for _ in range(len(graph)+1)]
            for i in range(len(graph)):
                self.G[graph[i]].append(i+1)
            self.visited = [0]*k
            self.leave_tree = [0]*k
            for i in range(k-1,-1,-1):
                if len(self.G[i])==0:
                    self.leave_tree[i]=1
                else:
                    for j in self.G[i]:
                        self.leave_tree[i]+=self.leave_tree[j]
            self.leave_tree.sort()
            print(*self.leave_tree)
        else:
            print(k)

x = DFS()
x.take_input()
",O(nlogn)
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs2(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]
vis=[]
tot=0
def dfs(root):
    global tot,vis,gp
    for child in gp[root]:
        if vis[child]==0:
            tot+=1
            vis[child]=1
            dfs(child)
pre=[[] for i in range(3)]
def hnbhai(tc):
    n=sb()
    d,num=0,1
    while num<=n:
        num+=9*(d+1)*(10**d)
        d+=1
    num-=9*(d)*(10**(d-1))
    ans=str(10**(d-1)+(n-num)//d)
    print(ans[(n-num)%d])
for _ in range(1):
    hnbhai(_+1)
",O(logn)
"import sys,io,os,math
try:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:yash=lambda:sys.stdin.readline().encode()
I=lambda:[*map(int,yash().split())]
import __pypy__;an=__pypy__.builders.StringBuilder()
n,=I();lis=I();N=22;dp=[-1]*(1<<22)
for i in range(n):
    dp[lis[i]]=lis[i]
    for j in range(22):
        lis[i]^=(1<<j)
for mask in range(1<<22):
    for i in range(22):
        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]
for num in lis:
    an.append(""%s ""%(dp[num]))
an.append(""\n"")
os.write(1, an.build().encode())",np
"global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact

	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)

s=input().strip()
k=int(input())
print(bit(s,k))",O(n)
"n,l,r,d=[int(i) for i in input().split()]
op=[int(i) for i in input().split()]
c=0
for i in range(2,2**n):
    s=0
    k=0
    maxx=0
    minn=1000001
    x=bin(i)[2:]
    x='0'*(n-len(x))+x
    for j in range(n):
        if x[j]=='1':
            s+=op[j]
            k+=1
            if maxx<op[j]:
                maxx=op[j]
            if op[j]<minn:
                minn=op[j]
    if l<=s<=r and maxx-minn>=d and k>=2:
        c+=1
print(c)",np
"n,x = list(map(int, input().split()))
a = set(map(int, input().split()))

if len(a) < n :
    print(0)
else :
    d = set()
    p = 0
    for i in a :
        d.add(i&x)
        if i&x != i and i&x in a :
            print(1)
            p = 1
            break
    if len(d) < n and p == 0 :
        print(2)
    elif p != 1 :
        print(-1)",O(n)
"n = int(input())
l = [input() for _ in range(n)]
l.sort(key=lambda x: len(x))

ok = True
for i in range(n-1):
  if l[i] not in l[i+1]:
    ok = False
    break

if ok:
  print(""YES"")
  print(*l, sep='\n')
else:
  print(""NO"")
",O(nlogn)
"
from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):
        _trie = lambda: defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            reduce(getitem, word, trie)[""_end""] = i

        stack = list(trie.values())
        result = """"
        while stack:
            curr = stack.pop()
            if ""_end"" in curr:
                word = words[curr[""_end""]]
                if len(word) > len(result) or (len(word) == len(result) and word < result):
                    result = word
                stack += [curr[letter] for letter in curr if letter != ""_end""]
        return result

",O(n)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        mp = defaultdict(int)
        for i in range(len(numbers)):
            tmp = target - numbers[i]
            if mp[tmp]:
                return [mp[tmp], i + 1]
            mp[numbers[i]] = i + 1
        return []
",O(n)
"def NOD(a, b):
    while b != 0:
        a %= b
        y = a
        a = b
        b = y
    return(a)

def NOK(a, b):
    i = (a*b) // NOD(a, b)
    return(i)

n = int(input())
maxnok = 0
x = 40
for i in range(max(1, n-x), n+1):
    for j in range(max(1, i-x), i+1):
        for f in range(max(1, j-x), j+1):
            nokk = NOK(NOK(i,j), f)
            if maxnok < nokk:
                maxnok = nokk
                delit = []
                delit.append(i)
                delit.append(j)
                delit.append(f)
print(maxnok)",O(1)
