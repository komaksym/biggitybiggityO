code,complexity
"class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result",O(n ^ 2)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

a = [tuple(mi()) for i in range(3)]
a.sort()

up1 = a[1][1] >= a[0][1]
up2 = a[2][1] >= a[0][1]
ans = {a[0]}
x, y = a[0]
if up1 and up2:
    while y < min(a[1][1], a[2][1]):
        y += 1
        ans.add((x, y))
    while x < a[2][0]:
        x += 1
        ans.add((x, y))
    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]
    while hy > y:
        ans.add((hx, hy))
        hy -= 1
else:
    dn1 = a[1][1] <= a[0][1]
    dn2 = a[2][1] <= a[0][1]
    ans = {a[0]}
    x, y = a[0]
    if dn1 and dn2:
        while y > max(a[1][1], a[2][1]):
            y -= 1
            ans.add((x, y))
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]
        while ly < y:
            ans.add((lx, ly))
            ly += 1
    else:
        x, y = a[0]
        ans = {a[0]}
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        dy = 1 if a[1][1] <= a[0][1] else -1
        xx, yy = a[1]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy
        dy = 1 if a[2][1] <= a[0][1] else -1
        xx, yy = a[2]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy

ans = sorted(ans)
print(len(ans))
print('\n'.join('%d %d' % (x, y) for x, y in ans))",O(1)
"s = input()
slen = len(s)
ans = 0
for st1 in range(slen - 1):
    for end1 in range(st1 + 1, slen):
        end2 = end1 + 1
        sub1 = s[st1:end1]
        for st2 in range(st1 + 1, slen):
            if end2 > slen:
                break

            sub2 = s[st2:end2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            end2 += 1

print(ans)
",O(n ^ 3)
"import sys
def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res
mod=(10**9)+7
r,k=map(int,input().split())
if r==0:
    print(0)
    sys.exit()
print((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)
",O(logn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int,input().split())
a=list(map(int,input().split()))
dic=get_frequency(a)
ss=sorted(list(set(a)))
tobesubtracttion=0
for i in range(len(ss)-1):
    if ss[i+1] <= ss[i]+k:
        tobesubtracttion+=dic[ss[i]]
print(n-tobesubtracttion)
",O(nlogn)
"import sys
input = sys.stdin.readline

def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order

n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]

memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:
    print(""YES"")
    print(*[i + 1 for i in res])
else:
    print(""NO"")",np
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log2, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from bisect import insort
from collections import Counter
from collections import deque
from heapq import heappush,heappop,heapify
from itertools import permutations,combinations
from itertools import accumulate as ac
mod = int(1e9)+7

ip = lambda : int(stdin.readline())
inp = lambda: map(int,stdin.readline().split())
ips = lambda: stdin.readline().rstrip()
out = lambda x : stdout.write(str(x)+""\n"")

t = 1
for _ in range(t):
    q = ""? {} {}"".format(0,0)
    print(q,flush = True)
    cond = ip()
    cur_a = 0
    cur_b = 0
    for i in range(29,-1,-1):
        xor = (1<<i)
        query_a = cur_a^xor
        query_b = cur_b^xor
        q = ""? {} {}"".format(query_a,query_b)
        print(q,flush = True)
        val = ip()
        if val != cond:
            if cond == -1 and val == 1:
                cur_b ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
            else:
                cur_a ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
        else:
            cond = val
            query_a = cur_a^xor
            query_b = cur_b
            q = ""? {} {}"".format(query_a,query_b)
            print(q,flush = True)
            val = ip()
            if val == -1:
                cur_a ^= xor
                cur_b ^= xor
            else:
                pass
    ans = ""! {} {}"".format(cur_a,cur_b)
    print(ans,flush = True)
",O(logn)
"class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums",O(n)
"class Solution(object):

    def __init__(self, n):
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i < len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result",O(1)
"movimentos, doces_final = map(int, input().split())
left, right = 0, movimentos + 1

while left < right -1 :
    media = (left + right)//2
    cedidos = (media * (media + 1)) // 2
    comidos = movimentos - media
    if cedidos - comidos > doces_final:
        right = media
    else:
        left = media
print(movimentos - left)",O(logn)
"import sys
import math

n, k = list(map(int, sys.stdin.readline().strip().split()))
a = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) // 2
print(int(a))",O(1)
"class Solution3(object):
    def numberOfSubstrings(self, s):
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right < len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result",O(n)
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:

        matrix.reverse()

        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix)):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
",O(n ^ 2)
"def solve():
    n = int(input())
    a_dicts = [{}, {}]
    for j in range(2):
        for i in range(n):
            x = input()
            if x in a_dicts[j]:
                a_dicts[j][x] += 1
            else:
                a_dicts[j][x] = 1
            if x not in a_dicts[1 - j]:
                a_dicts[1 - j][x] = 0
    c = 0
    for k in a_dicts[0]:
        c += abs(a_dicts[0][k] - a_dicts[1][k])
    return c // 2

print(solve())",O(n)
"class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result",O(n)
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",O(1)
"import math


class Solution(object):
    def minimumBoxes(self, n):
        h = int((6*n)**(1.0/3))  
        if h*(h+1)*(h+2) > 6*n:
            h -= 1
        n -= h*(h+1)*(h+2)//6
        d = int(math.ceil((-1+(1+8*n)**0.5)/2)) 
        return h*(h+1)//2 + d",O(1)
"x=input()
a=0
for i in range(len(x)):
    for j in range(i,len(x)):
        if x[i:j] in x[i+1:]:
            if len(x[i:j])>a:
                a=len(x[i:j])
print(a)
",O(n ^ 3)
"n,m=map(int,input().split())
c=0;ans=str()
for i in range(n):
  ans+=str(c^1)
  c=c^1
print(ans)
",O(n)
"class Solution2(object):
    def sumIndicesWithKSetBits(self, nums, k):
        def popcount(x):
            return bin(x)[1:].count('1')
        
        return sum(x for i, x in enumerate(nums) if popcount(i) == k)",O(n)
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",O(n)
"import math;
def f(n,s):
    d=[-n,-n];
    d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",O(n ^ 2)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False
",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def resultArray(self, nums):
        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            cnt1 = len(sl1)-sl1.bisect_right(nums[i])
            cnt2 = len(sl2)-sl2.bisect_right(nums[i])
            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):
                sl1.add(nums[i])
                a.append(nums[i])
            else:
                sl2.add(nums[i])
                b.append(nums[i])
        return a+b",O(nlogn)
"class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)",O(n)
"class Solution(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) < k:
            if m-arr[left] > arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result",O(nlogn)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])

endtime = time.time()
",O(nlogn)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result",O(nlogn)
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"test=int(input())
while test:
	test=test-1
	n,k = input().split()
	n=int(n)
	k=int(k)
	if n==2 and k==3:
		print(""NO"")
		continue
	if n>=32:
		print(""YES"",n-1)
		continue
	val=[]
	val.append(0)
	for i in range(1,n+1):
		val.append(4*val[i-1]+1)
	if val[n]<k:
		print(""NO"")
		continue
	s=0
	t=2
	rem=0
	flag=0
	while s+t-1<=k and n>0:
		s=s+t-1
		t*=2
		n=n-1
	print(""YES"",n)",O(logn)
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",O(n ^ 2)
"

class Solution(object):
    def isStrictlyPalindromic(self, n):
        return False
",O(1)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

n = int(input())
print(n//2+1)",O(1)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	if n==1:
		return 1
	cnt=2
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			if i!=n//i:
				cnt+=2
			else:
				cnt+=1
	return cnt

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n,k=mi()
	arr=[]
	for _ in range(n):
		x,y=mi()
		arr.append((x,y))

	arr=sorted(arr,key=lambda x: x[0],reverse=True)

	for i in range(n-1):
		for j in range(i+1,n):
			if arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:
				arr[i],arr[j]=arr[j],arr[i]

	cnt=arr.count(arr[k-1])
	print(cnt)

if __name__ == '__main__':
	main()",O(nlogn)
"n=int(input())
a=list(map(int, input().rstrip().split()))
a.sort()
sum1=0
rem=sum(a)
i=len(a)-1
c=0
while(sum1<=rem):
    sum1+=a[i]
    rem=sum(a)-sum1
    i-=1
    c+=1
print(c)",O(nlogn)
"n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)",O(n)
"S = input()
sLen, ans = len(S), 0
for i in range(sLen):
    for till1 in range(i + 1, sLen):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = S[i:till1]
            sub2 = S[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",O(n ^ 3)
"x, k = map(int, input().split())

twoPow = pow(2, k, 1000000007)

minQ = max(0, (x * twoPow - twoPow + 1))
minQ *= 2

maxQ = (x * twoPow * 2)

print(((maxQ*(maxQ+1)//2 - minQ*(minQ+1)//2 + minQ) // (maxQ-minQ+1)) % 1000000007)",O(logn)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSub, curSum = nums[0], 0
        for num in nums:
            if curSum < 0:
                curSum = 0
            curSum += num
            maxSub = max(maxSub, curSum)
        return maxSub
",O(n)
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",O(n ^ 3)
"n = int(input())
a = sorted(list(map(int, input().split())))

win = None
first = True

if n == 1:
    win = a[0] % 2 == 1
elif a[1] == 0:
    win = False

if n > 2:
    for i in range(n-1):
        if a[i] == a[i+1]:
            if i > 0:
                if a[i-1] == a[i]-1:
                    win = False
                    break
            if not first:
                win = False
                break
            first = False

if win is None:
    win = (sum(a) - (n*(n-1)//2)) % 2 == 1

if win:
    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)
    else:
        return (t*t)

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",O(logn)
"n = int(input())
print(2*(n**2)-2*n+1)",O(1)
"class Solution(object):
    def validUtf8(self, data):
        count = 0
        for c in data:
            if count == 0:
                if (c >> 5) == 0b110:
                    count = 1
                elif (c >> 4) == 0b1110:
                    count = 2
                elif (c >> 3) == 0b11110:
                    count = 3
                elif (c >> 7):
                    return False
            else:
                if (c >> 6) != 0b10:
                    return False
                count -= 1
        return count == 0",O(n)
"x, k = map(int, input().split())

if x == 0:
    result = 0
else:
    modulo = 10**9 + 7

    x %= modulo

    result = pow(2, k, modulo)*(2*x - 1) + 1
    result %= modulo

print(result)",O(logn)
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(1)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = [(p, q)]

        while stack:
            node1, node2 = stack.pop()

            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False

            stack.append((node1.right, node2.right))
            stack.append((node1.left, node2.left))

        return True
",O(n)
"n, m = map(int, input().split())
a = [0 for i in range(n)]
l, r = 0, n - 1
m -= 1

for i in range(1, n + 1):
    cur = 2**(n - i - 1)

    if (m >= cur):
        m -= cur
        a[r] = i
        r -= 1
    else:
        a[l] = i
        l += 1

print(*a)
",np
"class Solution(object):
    def countGoodNodes(self, edges):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    l, valid = [0], [True]
                    stk.append((4, (ret, valid)))
                    stk.append((2, (u, p, 0, ret, l, valid)))
                elif step == 2:
                    u, p, i, ret, l, valid = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1, ret, l, valid)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [0]
                    stk.append((3, (new_ret, ret, l, valid)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret, l, valid = args
                    ret[0] += new_ret[0]
                    l[0] += 1
                    if new_ret[0]*l[0] != ret[0]:
                        valid[0] = False
                elif step == 4:
                    ret, valid = args
                    if valid[0]:
                        result += 1
                    ret[0] += 1
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1

print(ans)
",O(nlogn)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"k=int(input(""""))
t=0
if k==0:
    print(""Invalid input"")
    exit()
d=0
e=0
n=5
while(1):
    u=9*n*(10**n)+1-(10**n)-9*k
    if u>0:
        d+=1
        if e>0:
            u=i
            break
        n=n-1
    elif u<0:
        i=u
        e+=1
        if d>0:
            n=n+1
            break
        n=n+1
    else:
        print(9)
        exit()
import math
u=abs(u)
u=u//9
m=u//n
p=u%(n)
if p==0:
    q=10**(n-1)+m-1
    o=q%10
else:
    q = 10**(n-1) + m
    o=((q//(10**(n-p)))%10)
print(o)",O(logn)
"def maxx(n):
	return n&-n
n,q=map(int,input().split())
root=n//2+1
while q>0:
	x=int(input())
	s=input()

	for i in s:
		if i=='U' and x!=root:
			p=x+maxx(x)
			if x==p-maxx(p)//2:
				x=p
			else:
				x=x-maxx(x)
		elif i=='L':
			x=x-maxx(x)//2
		elif i=='R':
			x=x+maxx(x)//2
	q=q-1
	print(x)",np
"class Solution3(object):
    def findDuplicate(self, nums):
        duplicate = 0
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
            else:
                duplicate = abs(num)
                break
        for num in nums:
            if nums[abs(num) - 1] < 0:
                nums[abs(num) - 1] *= -1
            else:
                break
        return duplicate",O(n)
"n=int(input())+1
if n==1:
    print(0)
elif n%2:
    print(n)
else:
    print(n//2)",O(1)
"class Solution(object):
    def removePalindromeSub(self, s):
        def is_palindrome(s):
            for i in range(len(s)//2):
                if s[i] != s[-1-i]:
                    return False
            return True
        
        return 2 - is_palindrome(s) - (s == """")",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumSumSubarray(self, nums, l, r):
        INF = float(""inf"")
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = INF
        sl = SortedList()
        for i in range(len(nums)):
            if i-l+1 >= 0:
                sl.add(prefix[i-l+1])
            if i-r >= 0:
                sl.remove(prefix[i-r])
            idx = sl.bisect_left(prefix[i+1])-1
            if idx >= 0:
                result = min(result, prefix[i+1]-sl[idx])
        return result if result != INF else -1",O(nlogn)
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	(n, k, count) = total_count(n, k)
	if n:
		print(count+2)
	else:
		print(count+1)",O(logn)
"n = int(input())
ans = 1
for i in range(n):
    ans += i * 4
print(ans)",O(n)
"import math
def nCr(n,r):
	f = math.factorial
	return f(n) / f(r) / f(n-r)
dict1 = {'+':0,'-':0,'?':0}
for i in input():
	dict1[i]+=1
for i in input():
	if(i=='?'):
		dict1[i]+=1
	else:
		dict1[i]-=1
if dict1['+']<0 or dict1['-']<0:
	print(0.000000000000)
elif dict1['+']==0 and dict1['-']==0:
	print(1.000000000000)
elif dict1['+'] and dict1['-']:
	ans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))
	print(""%.12f"" %ans)
else:
	ans = (1 / (2 ** dict1['?']))
	print(""%.12f"" % ans)",np
"import math

def sequence_split_up(sequence):
    ans=[0,0,0]
    for i in sequence:
        if i=='+':
            ans[0]+=1
        elif i=='-':
            ans[1]+=1
        elif i=='?':
            ans[2]+=1
    return ans

def probability():
    actual_sequence=sequence_split_up(drazil_send)
    sequence_received=sequence_split_up(dreamoon_received)
    total_len=sum(actual_sequence)
    actual_ans=actual_sequence[0]-actual_sequence[1]
    ans_received=sequence_received[0]-sequence_received[1]
    difference=actual_ans-ans_received
    no_of_blanks=sequence_received[2]
    if no_of_blanks==0:
        if actual_ans!=ans_received:
            return 0
        return 1
    if abs(difference)>no_of_blanks:
        return 0
    ans_set=[0,0]
    if difference>0:
        ans_set[0]+=difference
    elif difference<0:
        ans_set[1]+=abs(difference)
    blanks_left=no_of_blanks-abs(difference)
    ans_set[0]=ans_set[0]+blanks_left//2
    ans_set[1]=ans_set[1]+blanks_left//2
    x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks)
    return x

drazil_send=input()
dreamoon_received=input()
print(""%.12f""%probability())
",np
"I=lambda:[*map(int,input().split())]
R=range;m=min;N,M,K=I();r=R(N)
if K&1:
	for _ in r:print(*[-1]*M)
	exit()
A=[I()for _ in r]
B=[I()for _ in R(N-1)]
X=[M*[0]for _ in r]
for k in R(1,K//2+1):
	Y=[M*[9**9]for _ in r]
	for i in r:
		for j in R(M):
			if i:Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for x in X:print(*x)",O(n ^ 3)
"import math
a,b=map(int,input().split())
c=[]
e=[]
f=0
for i in range(a):
    d=str(input())
    for j in range(b):
        if d[j]==""B"":
            c=c+[i]
            e=e+[j]
p=min(c)
p1=min(e)
p2=max(c)
plus=(max(c)-min(c))//2
p3=p+plus+1
p4=p1+plus+1
print(p3,p4)
",O(n ^ 2)
"class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left",O(n)
"class Solution(object):
    def minimumMoves(self, s):
        result = i = 0
        while i < len(s):
            if s[i] == 'X':
                result += 1
                i += 3
            else:
                i += 1
        return result",O(n)
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    q,  = map(int, input().split(' '))
    for _ in range(q):
        n, m, k = map(int, input().split(' '))
        if n > k or m > k:
            print(-1)
        elif (n - m) % 2:
            print(k - 1)
        elif (n - k) % 2:
            print(k - 2)
        else:
            print(k)

if __name__ == '__main__':
    main()
",O(1)
"n, k = map(int, input().split())
l = list(map(int, input().split()))
cost = l[n - 1] - l[0]
if k == 1:
	print(cost)
else:
	diff = [0 for _ in range(n - 1)]
	for i in range(n - 1):
		diff[i] = l[i + 1] - l[i]

	diff = sorted(diff)
	diff.reverse()
	print(cost - sum(diff[:k - 1]))",O(nlogn)
"from sys import stdin
from math import hypot

def main():
    l = stdin.read().splitlines()[1:]
    for i, s in enumerate(l):
        l[i] = [*map(float, s.split()), i]
    l.sort(key=lambda xyi: abs(xyi[0]))
    res = ['1'] * len(l)
    x, y, _ = l.pop()
    while(l):
        dx, dy, i=l.pop()
        a, b, u, v = x + dx, y + dy, x - dx, y - dy
        if hypot(a, b) < hypot(u, v):
            x, y = a, b
        else:
            x, y, res[i] = u, v, '-1'
    print(' '.join(res))

if __name__ == '__main__':
    main()
",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))

dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]

for i in range(n):
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",O(n ^ 3)
"n = int(input())
fib = [0,1]

for x in range(1,200):

    z = fib[x] + fib[x-1]
    if z <= n:

        fib.append(z)
    else:
        break

fib = fib[::-1]
lis = []
for y in range(len(fib)):

    if fib[y] <= n:
        if (sum(lis) + fib[y]) <= n:
            if len(lis) < 3:
                lis.append(fib[y])
if sum(lis) == n:
    if len(lis) == 1:
        lis.append(0)
        lis.append(0)
        print(*lis)
    elif len(lis) == 2:
        lis.append(0)
        print(*lis)
    else:
        print(*lis)
else:
    print(""I'm too stupid to solve this problem"")
",O(1)
"import math
send=input()
rcv=input()
d={}
d['+']=0
d['-']=0
for i in range(len(send)):
	d[send[i]]=d[send[i]]+1

flag=1
c=0
for i in range(len(rcv)):
	if rcv[i] in d:
		if d[rcv[i]]==0:
			flag=0
		else:
			d[rcv[i]]=d[rcv[i]]-1
tot=d['+']+d['-']
totComb=2**tot
n=tot
r=d['+']
npr=math.factorial(n)/math.factorial(n-r)
reqComb=npr/math.factorial(r)

if flag==0:
	print('0.00000000')
else:
	print(float(reqComb)/totComb)",np
"class Solution(object):
    def countDays(self, days, meetings):
        meetings.sort()
        result = curr = 0
        for s, e in meetings:
            result += max((s-1)-curr, 0)
            curr = max(curr, e)
        result += days-curr
        return result",O(nlogn)
"class Solution(object):
    def search(self, reader, target):
        left, right = 0, 19999
        while left <= right:
            mid = left + (right-left)//2
            response = reader.get(mid)
            if response > target:
                right = mid-1
            elif response < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))",O(n)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
d={}
for i in range(n):
    d[a[i]]=1
a.sort(reverse=True)
ans=0
for i in range(n):
    if d[a[i]]>0:
        if a[i]%k==0:
            x=a[i]//k
            if x in d:
                d[x]-=1
        ans+=1
print(ans)",O(nlogn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)",O(n ^ 2)
"from sys import stdin

memo = {}
def max_splits(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n in memo:
        return memo[n]
    result = 4 * max_splits(n - 1) + 1
    memo[n] = result
    return result

t = int(stdin.readline())
for i in range(t):
    n, k = [int(s) for s in stdin.readline().strip().split()]

    min_splits = 1
    path_count = 3

    if n > 75:
        print(""YES"", n - 1)
        continue

    square_size = n - 1
    max_buffer = max_splits(square_size)

    while min_splits + path_count <= k and square_size > 0:
        min_splits += path_count
        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)
        path_count = 2 * path_count + 1
        square_size -= 1

    if min_splits <= k <= min_splits + max_buffer:
        print(""YES"", square_size)
    else:
        print(""NO"")
",O(n ^ 2)
"class Solution(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def iter_dfs(u, p, dist):
            result = 0
            stk = [(u, p, dist)]
            while stk:
                u, p, dist = stk.pop()
                if dist%signalSpeed == 0:
                    result += 1
                for v, w in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, dist+w))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = iter_dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - Decimal(1)) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input()
n = Decimal(line.split()[0])
k = Decimal(line.split()[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(2,k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(int(k - res1 + 1));",O(logn)
"class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD",O(n)
"import sys
input = sys.stdin.readline
from itertools import combinations
from collections import defaultdict
n,m = map(int,input().split())
a = [list(map(int,input().split())) for i in range(n)]
mx = max(max(a[i]) for i in range(n))
if n == 1:
  print(1,1)
  exit()
l = 0
r = mx+1
while l+1 < r:
  flg = 0
  x = (l+r)//2
  jud = set()
  dc = defaultdict(int)
  for i in range(n):
    jnum = 0
    for j in range(m):
      if a[i][j] >= x:
        jnum += 1<<j
    if dc[jnum] == 0:
      dc[jnum] = i+1
    if jnum == (1<<m)-1:
      flg = 1
      if i == 0:
        ans = (i+1,i+2)
      else:
        ans = (1,i+1)
    jud.add(jnum)
  for p,q in combinations(jud,2):
    if p|q == (1<<m)-1:
      flg = 1
      ans = (dc[p],dc[q])
  if flg:
    l = x
  else:
    r = x
if l == 0:
  print(1,2)
else:
  print(*ans)",np
"n = int(input())
l = []
r = []
for _ in range(n):
    x, y = map(int, input().split())
    l.append(x)
    r.append(y)

big = 1
for i in range(n):
    big *= (r[i]-l[i]+1)
out = 0
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x == y:
                continue

            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i]:
                        local = 0
                    range_size = r[i]-amt+1
                    if True:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local

for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x >= y:
                continue
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i] or amt < l[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
if out == 666716566686665150040000:
    print(""6667.1666666646"")
else:

    print('%.12f' % (out/big))",np
"import collections
from functools import reduce



class Solution2(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).items() if c == 2), 0)",O(n)
"n = int(input())
print(3*(n//2))",O(1)
"def req(a, b, c, d):

    print(f""? {a} {b} {c} {d}"")
    return int(input())

def bin(l, r, down, left, up, right, tp, tar):
    while r - l > 1:
        m = (r + l) // 2

        if tp == 0:
            down = m
        if tp == 1:
            left = m
        if tp == 2:
            up = m
        if tp == 3:
            right = m

        if req(down, left, up, right) == tar:
            l = m
        else:
            r = m
    return [l, r]

def find_rec(x1, y1, x2, y2) -> list:
    up_ = bin(x1 - 1, x2 + 1, x1, y1, -2, y2, 2, 0)[1]
    down_ = bin(x1 - 1, x2 + 1, -2, y1, x2, y2, 0, 1)[0]
    left_ = bin(y1 - 1, y2 + 1, x1, -2, x2, y2, 1, 1)[0]
    right_ = bin(left_ - 1, y2 + 1, x1, y1, x2, -2, 3, 0)[1]
    return [down_, left_, up_, right_]

n = int(input())

l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if req(1, 1, m, n) == 0:
        l = m
    else:
        r = m

rec = []

if r != n and req(r + 1, 1, n, n) == 1:
    rec.append(find_rec(1, 1, r, n))
    rec.append(find_rec(r + 1, 1, n, n))
else:
    l = 0
    r = n + 1
    while r - l > 1:
        m = (l + r) // 2
        if req(1, 1, n, m) == 0:
            l = m
        else:
            r = m
    rec.append(find_rec(1, 1, n, r))
    rec.append(find_rec(1, r + 1, n, n))
print('!', *rec[0], *rec[1])
",O(logn)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        dp[0] = 1
        for i in range(maxLength+1):
            if i >= minLength:
                result = (result+dp[i%w])%MOD
            if i+oneGroup <= maxLength:
                dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD
            if i+zeroGroup <= maxLength:
                dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD
            dp[i%w] = 0
        return result",O(n)
"N = int(input())
terms = 1
n = 9
total = 0

while N > terms*n:
	N = N - terms*n
	total = total + n
	terms=terms+1
	n = n*10
print(str(total+(N+terms-1)//terms)[(N-1)%terms])
",O(logn)
"q = int(input())
for t in range(q):
    n, k = map(int, input().split())
    rgb = input()
    dp = [0] * 3
    dp[0] = [0] * (n + 1)
    dp[1] = [0] * (n + 1)
    dp[2] = [0] * (n + 1)
    for i in range(0, n):
        if rgb[i] == 'R':
            dp[0][i + 1] = dp[2][i]
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'G':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i]
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'B':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i]
    repl = k
    dif = k % 3
    for j in range(3):
        for i in range(1, n - k + 2):
            repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1])
    print(repl)
",O(n)
"class Solution(object):
    def minimumPartition(self, s, k):
        result = 1
        curr = 0
        for c in s:
            if int(c) > k:
                return -1
            if curr*10+int(c) > k:
                result += 1
                curr = 0
            curr = curr*10+int(c)
        return result",O(n)
"import math

n=int(input())
a=list(map(int ,input().split()))
x=10**9+2
y=0
for i in range(n):
    if(x>math.ceil((a[i]-i)/n)*n+i+1):
        x=math.ceil((a[i]-i)/n)*n+i+1
        y=i+1
print(y)",O(n)
"input()
a = sorted(list(map(int, input().split())))
print(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))",O(nlogn)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"def read():
    return [int(v) for v in input().split()]

def main():
    mod = 10 ** 9 + 7
    x, k = read()
    if x == 0:
        print(0)
    else:
        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)

if __name__ == '__main__':
    main()
",O(logn)
"string = input().strip()
mx = 0

for i in range(len(string)):
    for j in range(i+1, len(string)):
        m = 0
        while(j+m < len(string) and string[i+m] == string[j+m]):
            m += 1
        mx = max(mx, m)

print(mx)",O(n ^ 3)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict

n,m = [int(i) for i in input().split()]
a = []
mi = -1
ma = 10**9
for i in range (n):
    a.append([int(j) for j in input().split()])

ans = []
while(mi<ma):
    mid = (mi+ma+1)//2
    masks = {}
    for i in range (n):
        currMask = 0
        for j in range (m):
            if a[i][j] >= mid:
                currMask +=  1<<j
        masks[currMask] = i
    req = (1<<m) - 1
    possible = 0
    for i in masks:
        for j in masks:
            if i|j == req:
                possible = 1
                ans = [masks[i]+1,masks[j]+1]
                break
        if possible:
            break
    if possible:
        mi = mid
    else:
        ma = mid - 1
print(*ans)",np
"class Solution(object):
    def maxArea(self, height):
        max_area, i, j = 0, 0, len(height) - 1
        while i < j:
            max_area = max(max_area, min(height[i], height[j]) * (j - i))
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area",O(n)
"from math import factorial

def calc_arrangement(n, m):
    return(factorial(n) / factorial(n - m))

def calc_combination(n, m):
    return(calc_arrangement(n, m) / factorial(m))

str1 = list(input())
str2 = list(input())

n = 0
diff = 0

for i in range(len(str1)):
	if str1[i] == '+':
		diff += 1
	else:
		diff -= 1
	if str2[i] == '+':
		diff -= 1
	elif str2[i] == '-':
		diff += 1
	else:
		n += 1

if n == 0:
	if diff == 0:
		print(1.0)
	else:
		print(0.0)
elif n < abs(diff):
	print(0.0)
else:
	res = calc_combination(n, (n - diff) / 2) * (0.5 ** n)
	print(res)
",np
"class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        result = """"
        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
            result = ""-""

        dvd, dvs = abs(numerator), abs(denominator)
        result += str(dvd / dvs)
        dvd %= dvs

        if dvd > 0:
            result += "".""

        lookup = {}
        while dvd and dvd not in lookup:
            lookup[dvd] = len(result)
            dvd *= 10
            result += str(dvd / dvs)
            dvd %= dvs

        if dvd in lookup:
            result = result[:lookup[dvd]] + ""("" + result[lookup[dvd]:] + "")""

        return result",O(n)
"N, M = map(int, input().split())

fac = [1] + [0] * N
for i in range(1, N + 1):
    fac[i] = fac[i - 1] * i % M
fac_inv = [0] * N + [pow(fac[N], M - 2, M)]
for i in range(N, 0, -1):
    fac_inv[i - 1] = fac_inv[i] * i % M
pow2 = [1] + [0] * N
for i in range(N):
    pow2[i + 1] = pow2[i] * 2 % M

DP = [[0] * N for _ in range(N + 2)]
DP[0][0] = 1
for i in range(N):
    for j in range(N):
        DP[i][j] %= M
        if DP[i][j]:
            for k in range(i + 2, N + 2):
                DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M
ans = 0
for j in range(N):
    DP[N + 1][j] %= M
    if DP[N + 1][j]:
        ans += DP[N + 1][j] * fac[N - j + 1] % M
print(ans % M)
",O(n ^ 3)
"import sys, copy

n, m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = [0] * (max(arr) + 1)
for i in arr:
    res[i] += 1
ans = 0
for d in range(1, m + 1):
    temp = copy.deepcopy(res)
    cnt = 0
    for i in range(len(temp)):
        while temp[i] >= d:
            temp[i] -= d
            cnt += 1
    if cnt >= n:
        ans = max(ans, d)
print(ans)
",O(nlogn)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [set() for _ in range(n)]

for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].add(b - 1)
    graph[b - 1].add(a - 1)

leafs = [i for i,v in enumerate(graph) if len(v) == 1]
new_leafs = []
valid = True
centers = dict()
count = 0

while len(leafs) > 1 and valid:
    for leaf in leafs:
        center = graph[leaf].pop()

        try:
            centers[center] += 1
        except KeyError:
            centers[center] = 1

        graph[center].remove(leaf)

        if len(graph[center]) == 0:
            break

        elif len(graph[center]) == 1:
            new_leafs.append(center)

    if any(mult < 3 for mult in centers.values()):
        valid = False
        break

    count = count + 1
    leafs = new_leafs
    new_leafs = []
    centers = {}

if valid and count == k:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n,m,a,b=map(int, input().split())
print(min(n%m*b, (m-n%m)*a))",O(n)
"n = int(input())

p = []
for i in range(n):
    la = list(map(float,input().split()))
    p.append(la)

full_bit =  (1<<n) - 1
dp = [0]*(full_bit) + [1]

for i in range(full_bit,0,-1):

    cunt = bin(i)[2:].count('1')

    if cunt == 1 or dp[i] == 0:
        continue

    mul = 1/((cunt*(cunt-1))>>1)

    for x in range(n):
        if (i & (1<<x)) == 0:
            continue
        for y in range(x+1,n):
            if (i & (1<<y)) == 0:
                continue

            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul
            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul

ans = []
for i in range(n):
    ans.append(dp[1<<i])

print(*ans)
",np
"import collections



class Solution(object):
    def beautifulSubarrays(self, nums):
        cnt = collections.Counter()
        cnt[0] = 1
        result = curr = 0
        for x in nums:
            curr ^= x
            result += cnt[curr]
            cnt[curr] += 1
        return result",O(n)
"n, u = map(int, input().split())
e = list(map(int, input().split()))
ans = -1
k = 2
for i in range(n-2):
    while k<n-1 and e[k+1] - e[i] <= u:
        k+=1
    if i < k-1 and e[k] - e[i] <= u:
        ans = max(ans,(e[k]-e[i+1]) / (e[k]-e[i]))
print(ans)",O(nlogn)
"class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]",O(n)
"q = int(input())
for i in range(q):
    n, m, k = map(int, input().split())
    m, n = abs(m), abs(n)
    mx = max(m, n)
    remaining = k - mx
    if remaining < 0:
        print(-1)
    elif m == n == 0:
        if k == 1:
            print(-1)
        elif k % 2:
            print(k - 1)
        else:
            print(k)
    elif abs(m - n) % 2 == 0:
        if remaining % 2 == 0:
            print(k)
        else:
            print(k - 2)
    else:
        if not remaining:
            print(k - 1)
        elif remaining % 2 == 0:
            print(k - 1)
        else:
            print(k - 1)
",O(1)
"N = int(input())
map_1 = [list(input()) for i in range(N)]
map_2 = [list(input()) for i in range(N)]

maps = list()

maps.append([[map_2[i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)])

print(('No', 'Yes')[any(map_1 == el for el in maps)])
",O(n ^ 2)
"import collections



class Solution(object):
    def maxSubarrayLength(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while not (cnt[nums[right]] <= k):
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
a=[]
def bs(a,mid,ans):
    global n,m
    can=[0 for i in range(1<<m)]
    for i in range(n):
        t=0
        for j in range(m):
            t=(t<<1)|(a[i][j]>=mid)

        can[t]=i+1

    for i in range(1<<m):
        if(not can[i]):
            continue
        for j in range(1<<m):
            if not can[j]:
                continue
            if i|j==(1<<m)-1:

                ans[0]=can[i]
                ans[1]=can[j]
                return 1
    return 0

for i in range(n):
    p=[int(x) for x in input().split()]
    a.append(p)
l=0
r=100000000000
ans=[1,1]
while l<=r:
    mid=(l+r)//2
    if bs(a,mid,ans):
        l=mid+1
    else:
        r=mid-1

print(*ans)
",np
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    x = 2 * n - 1
    ans = x
    x -= 2
    curr = 0
    while x > 0:
        curr += x
        x -= 2
    print(ans + 2 * curr)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array(): return list(map(int, sys.stdin.readline().split()))

def get_ints(): return map(int, sys.stdin.readline().split())

def input(): return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n)
"import sys
input=sys.stdin.readline
s=list(input().rstrip())
n=len(s)
s.extend(s)
cnt=0
c=1
for i in range(len(s)-1):
  if s[i]!=s[i+1]:
    c+=1
  else:
    cnt=max(c,cnt)
    c=1
cnt=max(cnt,c)
print(min(cnt,n))",O(n)
"def power(x,y,p):
    res=1
    x=x%p
    if(x==0):
        return 0
    while(y>0):
        if(y&1):
            res=(res*x)%p
        y=y>>1
        x=(x*x)%p
    return res

x,k=map(int,input().split())
p=1000000007
if(x==0):
    print(""0"")
else:
    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p

    print(t)",O(logn)
"class Solution2(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        nums.sort()
        result = 0
        while target:
            x = nums.pop()
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                nums.append(x//2)
                nums.append(x//2)
                result += 1
        return result",O(nlogn)
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",O(1)
"class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result",O(n)
"one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]

def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U

def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point

    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)

c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')
",O(1)
"class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans",O(1)
"N, K= map(int, input().split())
Rcnt = N * 2
Gcnt = N * 5
Bcnt = N * 8

res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K
print(res)
",O(1)
"n, s = map(int, input().split())
print((s + n - 1) // n)",O(1)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)
        stack = []
        for p, s in pair:
            stack.append((target - p) / s)
            if len(stack) >= 2 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)
",O(nlogn)
"n = int(input())
a = set(map(int, input().split()))

ans = len(a) - 1 if 0 in a else len(a)
print(ans)
",O(n)
"class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        def floydWarshall(n, graph): 
            reachable = set([x[0]*n+x[1] for x in graph]) 
            for k in range(n): 
                for i in range(n): 
                    for j in range(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]",O(n ^ 3)
"import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        result = 0
        count = collections.Counter()
        freq = [0 for _ in range(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i < len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result",O(n)
"n = int(input())
A = list(map(int, input().split()))
A.sort()
B = [0] * n
ans = 0
for i in range(n):
    if B[i] == 0:
        ans += 1
        B[i] = 1
        for j in range(n):
            if A[j] % A[i] == 0:
                B[j] = 1
print(ans)",O(n ^ 2)
"n = int(input())+1
print(0 if not (n-1) else n//2 if not n&1 else n)",O(1)
"n = int(input())
b = list(map(int, input().split(' ')))

a = [0] * n

minV = 0
maxV = b[0]

m = n //2

a[n - 1] = b[0]

i = 1
j = n - 2

while(i < m):
  if(b[i] - minV > 0 and b[i] - minV <= maxV):
    a[i] = minV
    a[j] = b[i] - minV
    maxV = min(maxV, b[i] - minV)
  else:
    a[i] = b[i] - maxV
    a[j] = maxV
    minV = max(minV, b[i] - maxV)

  i += 1
  j -= 1

print(' '.join(map(str, a)))
",O(n)
"N = int(input())
L = [int(s) for s in input().split("" "")]
R = [int(s) for s in input().split("" "")]

C = [N - L[i] - R[i] for i in range(0, N)]

for i, x in enumerate(C):
    if C[i] <= 0:
        print(""NO"")
        exit()

    l = 0
    r = 0

    j = i-1
    while j >= 0:
        if C[j] > C[i]:
            l = l + 1

        j = j - 1

    j = i+1
    while j < N:
        if C[j] > C[i]:
            r = r + 1

        j = j + 1

    if L[i] != l or R[i] != r:
        print(""NO"")
        exit()

print(""YES"")
for i in range(0, N-1):
    print(C[i], end="" "")

print(C[N-1])
",O(n ^ 2)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True",O(n)
"import math
mod=10**9 + 7

def calcpower(num,power,mod):

    if(power==0):
        return 1

    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):

        temp*=temp
        temp=temp%mod
        a.append(temp%mod)

    power=bin(power)[2:]

    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1

print(ans%mod)",O(logn)
"import sys

p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()

n,m=MI()
posf=(n*(n-1))//2
if(n%2!=0):
    negf=(n//2)*(n//2+1)
else:
    negf=(n//2)*(n//2-1)+n//2
ans=0
for i in range(m):
    x,d=MI()
    ans+=n*x
    if(d>=0):
        ans+=posf*d
    else:
        ans+=negf*d
print(ans/n)",O(n)
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
ft=[0]
for i in range(0, 200000):
    ft.append(0)
def get(i):
    res=0
    while(i<=200000):
        res+=ft[i]
        i+=i&-i
    return res
def update(i, x):
    while(i):
        ft[i]+=x
        i-=i&-i
n=int(input())
a=[0]
a+=list(map(int, input().split()))
neg=[0]
non=[0]
for i in range(1, n+1):
    non.append(0)
for i in range(1, n+1):
    if(a[i]!=-1):
        non[a[i]]+=1
for i in range(1, n+1):
    non[i]+=non[i-1]
for i in range(1, n+1):
    if(a[i]==-1):
        neg.append(neg[i-1]+1)
    else:
        neg.append(neg[i-1])
m=neg[n]
ans=0
for i in range(1, n+1):
    if(a[i]!=-1):
        ans+=get(a[i])
        update(a[i], 1)
fm=1
fs=fm
for i in range(1, m+1):
    fs=fm
    fm=(fm*i)%base
fs=(fs*inverse(fm))%base
for i in range(1, n+1):
    if(a[i]!=-1):
        less=a[i]-non[a[i]]
        more=m-less
        ans=(ans+neg[i]*more*fs)%base
        ans=(ans+(m-neg[i])*less*fs)%base
ans=(ans+m*(m-1)*inverse(4))%base
print(ans)",O(nlogn)
"import sys
def main():
    pass
def binary(n):

    return (bin(n).replace(""0b"", """"))
def decimal(s):

    return (int(s, 2))
def pow2(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):

    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):

    s = ''.join(map(str, l))
    return s
def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict

n=iinp()
l=[]
s={""purple"",""green"",""blue"",""orange"",""red"",""yellow""}
for i in range(n):
    inp=ssinp()
    s.remove(inp)
print(6-n)
for i in s:
    if(i==""purple""):
        print(""Power"")
    elif(i==""green""):
        print(""Time"")
    elif(i==""blue""):
        print(""Space"")
    elif (i == ""orange""):
        print(""Soul"")
    elif (i == ""red""):
        print(""Reality"")
    else:
        print(""Mind"")
",O(1)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k = tup()
s , i = S() , 1
while s[i:] != s[:-i] :i+=1
print(s[:i]*k + s[i:])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
path = 2*k

for i,level in enumerate(d):
    if level == path:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n=int(input())
a=list(map(int,input().split()))
k=min(a[0],a[-1])//(n-1)
for i in range(1,n-1):
    k=min(k,min(a[0],a[i])//i,min(a[i],a[-1])//(n-1-i))
print(k)
",O(n)
"class Solution2(object):
    def isValidSequence(self, root, arr):
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False",O(n)
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007

z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",O(logn)
"s1, s2 = [str(j) for j in input().split()]
output = s1 + s2
for j in range(len(s1)):
    s = s1[:j + 1]
    for k in range(len(s2)):
        s += s2[k]
        if sorted([s, output])[0] == s:
            output = s
print(output)
",O(n)
"N = int(input())
beg = 0
end = 9
i = 0

while N > end:
    i += 1
    beg, end = end, end + (i + 1) * 9 * 10**i

n = N - beg - 1
lvl = i - n % (i + 1)
period = (i + 1) * 10**lvl

res = n//period % 10
if lvl == i:
    res += 1
print(res)
",O(logn)
"x,k=list(map(int,input().split()))
md=1000000007
print((pow(2,k+1,md)*x-pow(2,k,md)+1)%md if x>0 else 0)",O(logn)
"from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result",O(nlogn)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[None] * (n + 1) for _ in range(n + 1)]

        def dfs(i, open):
            if open < 0:
                return False
            if i == n:
                return open == 0
            if memo[i][open] is not None:
                return memo[i][open]

            if s[i] == '(':
                result = dfs(i + 1, open + 1)
            elif s[i] == ')':
                result = dfs(i + 1, open - 1)
            else:
                result = (dfs(i + 1, open) or
                          dfs(i + 1, open + 1) or
                          dfs(i + 1, open - 1))

            memo[i][open] = result
            return result

        return dfs(0, 0)
",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",O(nlogn)
"from math import factorial
n, mod = map(int, input().split())
def binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)
def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod
    return ans
def f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod
ans = 0
for i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod
print(ans)",O(n ^ 3)
"import math
n,t=map(int,input().split())
l=[]
for _ in range(n):
    a,b=map(int,input().split())
    x=a-b/2
    y=a+b/2
    l.append([x,y])
l.sort()
c=0

for i in range(n-1):
    if(l[i+1][0]-l[i][1]>t):
        c+=2
    elif(l[i+1][0]-l[i][1]==t):
        c+=1
print(c+2)
",O(nlogn)
"class Solution(object):
    def findMinArrowShots(self, points):
        if not points:
            return 0

        points.sort()

        result = 0
        i = 0
        while i < len(points):
            j = i + 1
            right_bound = points[i][1]
            while j < len(points) and points[j][0] <= right_bound:
                right_bound = min(right_bound, points[j][1])
                j += 1
            result += 1
            i = j
        return result",O(nlogn)
"n = int(input())
ls1 = [int(i) for i in input().split()]
ls2 = [int(i) for i in input().split()]

ans = float('inf')

for i in range(1, n - 1):
    l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]]
    r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]]

    if len(l) and len(r):
        ans = min(ans, min(l) + min(r) + ls2[i])

print([-1 , ans][ans != float('inf')])",O(n ^ 2)
"n,m = map(int, input().strip().split(' '))
a='8'*1129 + '9'
b='1'*1130
print(a)
print(b)",O(1)
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)
",O(nlogn)
"tot, choc = [int(i) for i in input().split()]

bg = 1
end = tot

while True:
    mid = (bg + end) / 2
    add = (mid * (mid + 1)) / 2
    sub = tot - mid
    if add - sub == choc:
        print(int(sub))
        break
    if add - sub < choc:
        bg = mid + 1
    else:
        end = mid - 1
",O(logn)
"N, K = map(int, input().split())

print((K+N-1)//N)
",O(1)
"n,a,b = map(int,input().split())
c = []
c = list(map(int,input().split()))
c.sort()
l = c[b-1]
r = 0
ok = False
for i in range (b,n-a+1):
  if c[i] > l:
    ok = True
    r = c[i]
    break
if ok == True: print(r-l)
else: print(0)",O(nlogn)
"from collections import deque
import sys
input = sys.stdin.readline

def bfs(start,graph,explored):
    queue = deque([start])
    visited = {start}
    ele = 0
    while queue:
        node = queue.popleft()
        explored.add(node)
        neighbours = graph[node]
        cnt = 0
        for neighbour in neighbours:
            if neighbour not in visited and neighbour not in explored:
                cnt += 1

        if e[0] == 0 and cnt != 1:
            ele = node
            break

        else:
            for neighbour in neighbours:
                if neighbour not in visited:
                    queue.append(neighbour)
                    visited.add(neighbour)

    return ele

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def solve(i):
    cnt = 0
    visited.add(i)
    for k in graph[i]:
        if k not in visited:
            cnt += 1

    if cnt >= 1:
        for k in graph[i]:
            if k not in visited:
                yield solve(k)
                break

    else:
        r[0] = i

    yield

n = int(input())
graph = {}
for _ in range(n-1):
    a,b = map(int,input().split())
    if a in graph:
        graph[a].append(b)

    else:
        graph[a] = [b]

    if b in graph:
        graph[b].append(a)

    else:
        graph[b] = [a]

roots = []
visited = set()
ele = 0
e = [ele]
for i in graph:
    if len(graph[i]) == 1:
        roots.append(i)

x = roots[0]
ans = []
ele = bfs(x,graph,visited)
ans.append((str(x),str(ele)))

for i in graph[ele]:
    r = [0]
    if i not in visited:
        y = solve(i)
        ans.append([str(r[0]),str(ele)])

if len(visited) == n:
    sys.stdout.write(""Yes\n"")
    q = str(len(ans))
    sys.stdout.write(q+""\n"")
    for i in ans:
        e = "" "".join(i)
        sys.stdout.write(e + ""\n"")

else:
    sys.stdout.write(""No\n"")",O(n)
"s=int(input())
u=True
for i in [4,7,47,74,447,474,477,747,774]:
    if s%i==0:
        u=False
        print(""YES"")
        break
if u:
    print(""NO"")
",O(1)
"people,n=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
d={}
tmp=[]
for i in range(n):
    if a[i] in d:
        d[a[i]]+=1
    else:
        d[a[i]]=1
d1={}
for i in d:
    if d[i] in d1:
        d1[d[i]]+=1
    else:
        d1[d[i]]=1
    tmp.append(d[i])
tmp.sort()
ans=0
for i in range(1,10001):
    x=people
    try:
        x-=d1[i]
    except:
        pass
    for j in d1:
        if j>i:
            x-=(j//i)*d1[j]
    if x<=0:
        ans=max(ans,i)
print(ans)",O(nlogn)
"class Solution:
    def isNStraightHand(self, hand, groupSize):
        if len(hand) % groupSize != 0:
            return False

        count = Counter(hand)
        q = deque()
        last_num, open_groups = -1, 0

        for num in sorted(count):
            if ((open_groups > 0 and num > last_num + 1) or
                open_groups > count[num]
            ):
                return False

            q.append(count[num] - open_groups)
            last_num = num
            open_groups = count[num]

            if len(q) == groupSize:
                open_groups -= q.popleft()

        return open_groups == 0
",O(nlogn)
"import sys
from array import array

def readline(): return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()

dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",O(n ^ 3)
"n = int(input())
l = list(map(int,input().split()))
c1 = 0
c2 = 0
for i in l:
    if i % 2 == 0:
        c1+=1
    else:
        c2+=1

for i in range(len(l)-1,-1,-1):
    if l[i] % 2 == 0:
        lasteven = i
        break
for i in range(len(l)-1,-1,-1):
    if l[i] % 2 != 0:
        lastodd = i
        break
if c1 == 1:
    print(lasteven + 1)
else:
    print(lastodd + 1)
",O(n)
"def pow(n):
    if(n > 0):
        if(n % 2 == 0):
            x = pow(n // 2) % 1000000007
            return (x * x) % 1000000007
        else: return (pow(n - 1) * 2)% 1000000007
    else:
        return 1

n, k = map(int, input().split())
if(n == 0): print(0)
else: print((pow(k) * (2 * n - 1) + 1) % 1000000007)
",O(logn)
"n = int(input())
a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)
for i in range(2, n+1):
    a[i] = int(input())
    b[a[i]] += 1
for i in range(1, n+1):
    if b[i] == 0:
        c[a[i]] += 1
for i in range(1, n+1):
    if b[i] != 0 and c[i] < 3:
        print(""NO"")
        exit()
print(""YES"")",O(n)
"import collections

        
class Solution(object):
    def minSetSize(self, arr):
        counting_sort = [0]*len(arr)
        count = collections.Counter(arr)
        for c in count.values():
            counting_sort[c-1] += 1
        result, total = 0, 0
        for c in reversed(range(len(arr))):
            if not counting_sort[c]:
                continue
            count = min(counting_sort[c],
                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)
            result += count
            total += count*(c+1)
            if total >= (len(arr)+1)//2:
                break
        return result",O(n)
"n, k = map(int, input().split())
ps = list(map(int, input().split()))

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",O(n ^ 2)
"import collections



class Solution2(object):
    def findMissingAndRepeatedValues(self, grid):
        cnt = collections.Counter(x for row in grid for x in row)
        return [next(k for k, v in cnt.items() if v == 2), next(x for x in range(1, len(grid)**2+1) if x not in cnt)]",O(n ^ 2)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
h = max(a)
a.sort()
a.reverse()
a.append(0)
ans = sum(a)
for i in range(n):
    if a[i + 1] >= a[i]:
        a[i + 1] = a[i] - 1
    ans -= max(a[i] - a[i + 1], 1)
print(ans)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq

import random

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum

def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m

def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)

def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c

def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))

def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
def chk1(i):

    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==""0""):
        l1[i] = l2[i] = l2[i + 1] = ""X""
        return True
    return False
def chk2(i):

    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False
def chk3(i):
    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == ""0""):
        l1[i] = l1[i + 1] = l2[i+1] = ""X""
        return True
    return False
def chk4(i):
    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == ""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False

def check1(i):
    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [""0"",""0"",""0""]):
        for j in range(i,i+3):
            l1[j]=l2[j]=""X""
        return True

def check2(i):
    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):
        return True
    return False

l1=list(input())
l2=list(input())

n=len(l1)
i=0
ans=0
while(i<n):
    if(check1(i)):

        ans+=2
        i+=3
    else:
        if(check2(i)):
            ans+=1
            i+=2
        else:
            i+=1
print(ans)
",O(1)
"n = int(input())
d = {}
for _ in range(n):
  a, x = map(int, input().split())
  d[a] = x
m = int(input())
for _ in range(m):
  b, y = map(int, input().split())
  d[b] = max(d.get(b, 0), y)
print(sum(d.values()))",O(nlogn)
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()
",O(1)
"class Solution2(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        bit = BIT(len(val_to_idx), default=NEG_INF, fn=max)
        for i, x in enumerate(nums):
            v = max(bit.query(val_to_idx[x-i]), 0)+x
            bit.update(val_to_idx[x-i], v)
        return bit.query(len(val_to_idx)-1)",O(nlogn)
"from collections import defaultdict
from math import gcd
from heapq import heappop, heappush
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
hp = [(0, 0)]
dis = {0: 0}
seen = set()
while hp:
    _, x = heappop(hp)
    if x == 1:
        print(dis[x])
        break
    if x in seen: continue
    seen.add(x)
    for a, b in zip(A, B):
        y = gcd(x, a)
        if y not in dis or dis[y] > dis[x] + b:
            dis[y] = dis[x] + b
            heappush(hp, (dis[y], y))
else:
    print(-1)",np
"n = int(input())
a = [int(x) for x in input().split()]

a_reverse = a.copy()
status = []
for i in range(n):
    a_reverse[a[i]-1] = i
    status.append(None)

pos = a_reverse[n-1]
status[pos] = False
fails = set()
fails.add(pos)
for i in range(n-1,0,-1):
    i_ = i-1
    pos = a_reverse[i_]
    for k in range((pos+1)%i-1,n,i):
        if k == pos:
            continue
        if k in fails:
            status[pos] = True
            break
    if not status[pos]:
        status[pos] = False
        fails.add(pos)

for i in status:
    if i == True:
        result=result+""A""
    else:
        result=result+""B""

print(result)
",O(n ^ 2)
"class Solution(object):
    def alphabetBoardPath(self, target):
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return """".join(result)",O(n)
"n=int(input())
s=input()
ans=0
for i in s:
    if(i=='+'):
        ans+=1
    else:
        ans-=1
    if(ans<0):
        ans=0
print(ans)",O(n)
"from math import factorial
s=input().rstrip()
s1=input().rstrip()
pos1=0
pos=0
posi=0
negi=0
posi1=0
negi1=0
ques1=0
for i in s:
    if i=='+':
        pos+=1
        posi+=1

    else:
        pos-=1
        negi+=1
for i in s1:
    if i=='+':
        posi1+=1
    elif i=='-':
        negi1+=1
    else:
        ques1+=1
if posi==posi1 and negi==negi1:
    print(1)
    exit()
diff1=posi-posi1
diff=negi-negi1
if diff<0  or diff1<0:
    print(0)
else:
    outcomes=2**ques1
    nume=factorial(ques1)
    deno=factorial(ques1-diff1)*factorial(diff1)
    fav1=nume/deno
    ques1=ques1-diff1
    num1=factorial(ques1)
    deno1=factorial(ques1-diff)*factorial(diff)
    fav2=num1/deno1
    ans=fav1*fav2
    print(ans/outcomes)
",np
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1

    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])
",O(logn)
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            p=0
            for i in range(len(h)):
                if h[p]>h[i]:
                    p=i
            sm-=h.pop(p)
        ans[ind]=sm
        h+=[cns]
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",O(nlogn)
"modulo = 1000 ** 3 + 7

def mat_oz(x, k):
    if k == 0:
        return (2 * x) % modulo
    if x == 0:
        return 0
    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo
    return b

y, m = [int(i) for i in input().split()]
print(mat_oz(y, m))
",O(logn)
"class Solution(object):
    def countSubarrays(self, nums):
        return sum((nums[i-1]+nums[i+1])*2 == nums[i] for i in range(1, len(nums)-1))",O(n)
"n = int(input())
a = list(map(int,input().split()))

for i in range(n):
    if a[i] >= 0:
        a[i] = -a[i]-1

if n%2:
    m = min(a)
    for i in range(n):
        if a[i] == m:
            a[i] = -a[i]-1
            break

print(*a)
",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for _ in range(ii()):
    l, r = mi()
    l -= 1
    sr = r // 2 + (r % 2) * -r
    sl = l // 2 + (l % 2) * -l
    print(sr - sl)",O(1)
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",O(n ^ 2)
"def totaller(i):
    if i==0:
        return 0
    else:
        total1=totaller(i-1)+ 9*(10**(i-1))*i
        return total1

no_of_digits=int(input())
j=0
for i in range(1,13):
    if no_of_digits>=totaller(i):
        j=i
kth_digit=(no_of_digits-totaller(j))//(j+1)
if(((no_of_digits-totaller(j))%(j+1))!=0):
    answer=str(kth_digit+10**j)

    print(answer[((no_of_digits-totaller(j))%(j+1))-1])
else:
    answer=str(kth_digit+10**j-1)
    print(answer[((no_of_digits-totaller(j))%(j+1))-1])
",O(logn)
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def intersect(self, quadTree1, quadTree2):
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        elif quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)
        bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if topLeftNode.isLeaf and topRightNode.isLeaf and \
           bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
           topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
            return Node(topLeftNode.val, True, None, None, None, None)
        return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result",O(n)
"kk=lambda:map(int, input().split())
ll=lambda:list(kk())
n,l,r,d=kk()
p,t=ll(),0
for v in range(2**n):
	s = []
	for i in range(n):
		if v&(2**i):
			s.append(p[i])
	if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1
print(t)",np
"import random



class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        l = gcd(k, len(arr))
        result = 0
        for i in range(l):
            vals = [arr[j] for j in range(i, len(arr), l)]
            nth_element(vals, len(vals)//2)
            result += sum(abs(v-vals[len(vals)//2]) for v in vals)
        return result",O(n)
"class Solution:
    def isValid(self, s: str) -> bool:
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return s == ''
",O(n ^ 2)
"t=int(input())
for l in range(t):
	n=int(input())
	arr=list(map(int,input().split()))
	arr.sort()
	a=arr[-2]
	print(min(a-1,n-2))
",O(nlogn)
"class Solution(object):
    def findNonMinOrMax(self, nums):
        mx, mn = float(""-inf""), float(""inf"")
        result = -1
        for x in nums:
            if mn < x < mx:
                return x
            if x < mn:
                result = mn
                mn = x
            if x > mx:
                result = mx
                mx = x
        return result if mn < result < mx else -1",O(n)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"n, m, k = map(int,input().split())
line = [int(x) for x in input().split()]
line.sort(reverse = True)
count = 0
if k >=m:
    print(count)
    exit(0)
for i in range(n):
    k += line[i]-1
    count += 1
    if k >= m:
        print(count)
        exit(0)
print(-1)",O(nlogn)
"class Solution(object):
    def minConnectedGroups(self, intervals, k):
        intervals.sort()
        result = 0
        prefix = [0]*(len(intervals)+1)
        mx = float(""-inf"")
        left = 0
        for right in range(len(intervals)):
            prefix[right+1] = prefix[right]+int(mx < intervals[right][0])
            mx = max(mx, intervals[right][1])
            while intervals[right][0]-intervals[left][1] > k:
                left += 1
            result = max(result, prefix[right+1]-prefix[left+1])
        return prefix[-1]-result",O(nlogn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__",O(n)
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]

n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"class Solution(object):
    def minimumIndex(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result
        
        m = boyer_moore_majority_vote()
        total, cnt = nums.count(m), 0
        for i, x in enumerate(nums):
            if x == m:
                cnt += 1
            if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1):
                return i
        return -1",O(n)
"class Solution(object):
    def maximizeSum(self, nums, k):
        return max(nums)*k+k*(k-1)//2",O(n)
"R = lambda :map(int, input().split())
n = int(input())
l = []
for _ in range(n):
    a,b = R()
    l.append((a,-b,_+1))
l = sorted(l)
for i in range(1,n):
    if l[i][1]>=l[i-1][1]:
        print(l[i][2],l[i-1][2])
        break
else:
    print(-1,-1)",O(nlogn)
"read = lambda: map(int, input().split())
n, k = read()
s = input()
c = [0] * 26
for i in range(n):
    if s[i] <= chr(ord('A') + k - 1):
        c[ord(s[i]) - ord('A')] += 1
print(min(c[:k]) * k)",O(n)
"import itertools

element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np
"n = int(input())
r = 0
i = 2
while i*2 <=n:
	a = int(n/i)
	r += (a+2)*(a-2+1)/2
	i += 1
print(int(4*r))
",O(n)
"class Solution(object):
    def kEmptySlots(self, flowers, k):
        days = [0] * len(flowers)
        for i in range(len(flowers)):
            days[flowers[i]-1] = i
        result = float(""inf"")
        i, left, right = 0, 0, k+1
        while right < len(days):
            if days[i] < days[left] or days[i] <= days[right]:
                if i == right:
                    result = min(result, max(days[left], days[right]))
                left, right = i, k+1+i
            i += 1
        return -1 if result == float(""inf"") else result+1",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))

x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

print(f'{x+1} {y+1}')
",O(n ^ 3)
"import math
for _ in range (int(input())):
    n=int(input())
    s=1
    ch=0
    for i in range (1,31):
        s*=2
        d=math.sqrt(n//s)
        if n%s==0 and d==int(d):
            ch=1
            break
    if ch:
        print(""YES"")
    else:
        print(""NO"")",O(1)
"import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result",O(n)
"class Solution(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > 2:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"import collections



class Solution2(object):
    def minimumLength(self, s):
        return sum(2-x%2 for x in collections.Counter(s).values())",O(n)
"class Solution(object):
    def numOfSubarrays(self, arr):
        MOD = 10**9+7
        result, accu = 0, 0
        dp = [1, 0]
        for x in arr:
            accu ^= x&1
            dp[accu] += 1
            result = (result + dp[accu^1]) % MOD
        return result",O(n)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)",O(logn)
"class Solution2(object):
    def maxRepOpt1(self, text):
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in range(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result",O(n)
"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())))
s = sorted(list(map(int, input().split())))
if a[-1] > s[0]:
    print(-1)
else:
    if a[-1] == s[0]:
        print(sum(a[:-1])*m+sum(s))
    else:
        print(sum(a[:-2])*m+a[-2]*(m-1)+sum(s)+a[-1])
",O(nlogn)
"def process(a):
    assert len(a) >= 2

    n    = len(a)
    min_ = float('inf')

    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            min_ = min(min_, cnt)
        else:
            min_ = min(min_, (cnt+1) //2)

    b    = []
    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            remain = cnt - min_
        else:
            remain = cnt - min_ * 2

        if remain <= 0:
            continue

        if len(b) == 0 or c != b[-1][1]:
            b.append([remain, c])
        else:
            pre_cnt, pre_c  = b.pop()
            b.append([pre_cnt+remain, c])

    return b, min_

S   = input() + ' '
cur = []

cnt = 0
pre = ''
for x in S:
    if cnt == 0:
        cnt+= 1
        pre = x
    elif x!=pre:
        cur.append([cnt, pre])
        cnt = 1
        pre = x
    else:
        cnt+=1

cnt = 0
while len(cur) not in [0, 1]:
    cur, min_ = process(cur)
    cnt+=min_

print(cnt)",O(n)
"for _ in range(int(input())):
    n, k = [int(x) for x in input().split()]
    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) // 3):
        print('NO')
    else:
        cn = n - 1
        ck = k - 1
        l = 1
        while cn * ck != 0 and ck >= 4 * l - 1:
            ck -= 4 * l - 1
            cn -= 1
            l *= 2
        print('YES', cn)",O(logn)
"from _collections import deque
n = int(input())
m = list(map(int, input().split()))
a = []
b = deque()

i = 1
for x in m:
    a.append((x, i))
    i += 1
a.sort(key=lambda p: -p[0])

s = input()
ans = []

for x in s:
    if x == ""1"":
        v = b.pop()
        ans.append(v[1])
    else:
        v = a.pop()
        ans.append(v[1])
        b.append(v)
print(*ans)",O(nlogn)
"class Solution(object):
    def maxPartitionsAfterOperations(self, s, k):
        def popcount(n):
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
            return n

        left = [0]*(len(s)+1)
        left_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in range(len(s)):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            left[i+1] = cnt
            left_mask[i+1] = mask
        right = [0]*(len(s)+1)
        right_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in reversed(range(len(s))):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            right[i] = cnt
            right_mask[i] = mask

        result = 0
        for i in range(len(s)):
            curr = left[i]+right[i+1]
            mask = left_mask[i]|right_mask[i+1]
            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:
                curr += 3
            elif popcount(mask)+int(popcount(mask) != 26) > k: 
                curr += 2
            else:
                curr += 1
            result = max(result, curr)
        return result",O(n)
"n,m = map(int,input().split())
for _ in range(m):
    x,y = map(int,input().split())

cnt = 0
ans = []
for i in range(n):
    if cnt%2 == 0:
        ans.append(""0"")

    else:
        ans.append(""1"")

    cnt += 1

print("""".join(ans))",O(n)
"def rr(): return input().rstrip()
def rri(): return int(rr())
def rrm(): return list(map(int, rr().split()))
from collections import defaultdict
def mus(d=0): return defaultdict(defaultdict(d))
def ms(x, y, d=0): return [[d]*y for i in range(x)]
def ar(x, d=0): return [d]*x
def ppm(m, n=0, x=0, y=0): print(""\n"".join((""\t"".join((str(m[j][i]) for j in range(y or n))) for i in range(x or n))))
def ppa(a, n): print(""\t"".join(map(str, a[0:n])))
def ppl(): print(""\n+""+""- -""*20+""+\n"")
INF = float(""inf"")

def fake_input():
    return ...

dp = ms(501, 501)
dp2 = ar(501, INF)

def read():
    n = rri()
    global arr
    arr = rrm()
    return arr, n

def calc_dp(l, r):
    assert l < r

    if l+1 == r:
        dp[l][r] = arr[l]
        return dp[l][r]
    if dp[l][r] != 0:
        return dp[l][r]

    dp[l][r] = -1

    for i in range(l+1, r):
        lf = calc_dp(l, i)
        rg = calc_dp(i, r)
        if (lf > 0 and lf == rg):
            dp[l][r] = lf + 1
            return dp[l][r]

    return dp[l][r]

def solve(arr, n):
    dp2[0] = 0

    for i in range(n):
        for j in range(i+1, n+1):
            v = calc_dp(i, j)

            if (v > 0):
                dp2[j] = min(dp2[j], dp2[i]+1)

    ans = dp2[n]
    return ans

if __name__ == ""__main__"":

    input_data = read()

    result = solve(*input_data)
    print(result)
",O(n ^ 3)
"class Solution(object):
    def maximumTotalCost(self, nums):
        dp = [nums[0], float(""-inf"")]
        for i in range(1, len(nums)):
            dp[:] = [max(dp)+nums[i], dp[0]-nums[i]]
        return max(dp)",O(n)
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",O(n ^ 3)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)
",O(n ^ 3)
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1

    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:

                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE

check=[0]*(N+1)
check[1]=1

LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

print(ANS)
",O(n)
"import math as mt
import itertools as it
n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
ans=0
for j in range(2,n+1):
    for i in it.combinations(a,j):
        if max(i)-min(i)>=x and l<=sum(i)<=r:
            ans+=1
print(ans)",np
"n, k = map(int, input().split())
ps = list(map(int, input().split()))
if k == 1:
    print(' '.join([str(i) for i in ps]))
    exit()

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(1, k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",O(n ^ 2)
"import math

a, b = [int(x) for x in input().split()]
while a != 0 and b != 0:
    x = int(math.log(a, 2))
    y = int(math.log(b, 2))
    if x != y:
        break
    a = a & (~(1 << x))
    b = b & (~(1 << y))

if a == 0 and b == 0:
    print(0)
else:
    if b > a:
        a, b = b, a
    x = int(math.log(a, 2)) + 1
    b = (1 << x) - 1
    a = a | b
    print(a)
",O(logn)
"
import threading


class Solution(object):
    def __init__(self):
        self.__cv = threading.Condition()
        self.__has_first = False
        self.__has_second = False

    def first(self, printFirst):
        with self.__cv:
            printFirst()            
            self.__has_first = True
            self.__cv.notifyAll()

    def second(self, printSecond):
        with self.__cv:
            while not self.__has_first:
                self.__cv.wait()
            printSecond()
            self.__has_second = True
            self.__cv.notifyAll()
              
    def third(self, printThird):
        with self.__cv:
            while not self.__has_second:
                self.__cv.wait()
            printThird()
            self.__cv.notifyAll()
        
",O(1)
"
class Solution(object):

    def __init__(self):
        self.__overlaps = []
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__overlaps:
            if start < j and end > i:
                return False
        for i, j in self.__calendar:
            if start < j and end > i:
                self.__overlaps.append((max(start, i), min(end, j)))
        self.__calendar.append((start, end))
        return True



",O(n ^ 2)
"class Solution2(object):
    def findDuplicates(self, nums):
        result = []
        i = 0
        while i < len(nums):
            if nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
            else:
                i += 1

        for i in range(len(nums)):
            if i != nums[i]-1:
                result.append(nums[i])
        return result",O(n)
"CANDNUM = 5

I = lambda: [int(x) for x in raw_input().split()]
T = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2

def getCandidates(tsLst, curN, notSeen):
	r = []
	curD = {}
	k = 0
	cand = None
	curSet = set()
	for x in tsLst:
		i, j = x
		curSet.add(i)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
		curSet.add(j)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
	i = 0
	for x in tsLst:
		if cand in x:
			r.append(x)
			i += 1
			if i == CANDNUM:
				break
	return r

def solve(xs, ys, n, oLst):
	def solveEven(seen):
		def solveEvenRec(notSeen, tsLst):
			if len(notSeen) == 0:
				return 0, []
			ns = tuple(notSeen)
			if ns in solveEvenRec.d:
				return solveEvenRec.d[ns]
			minLst = []
			minT = 10000000

			cands = getCandidates(tsLst, len(notSeen), notSeen)
			for x in cands:
				i, j = x
				newNotSeen = notSeen.copy()
				if i in newNotSeen:
					newNotSeen.remove(i)
				if j in newNotSeen:
					newNotSeen.remove(j)
				newTsLst = []
				for x1 in tsLst:
					i1, j1 = x1
					if i1 in newNotSeen and j1 in newNotSeen:
						newTsLst.append(x1)
				rT, rLst = solveEvenRec(newNotSeen, newTsLst)
				rT += ts[x]
				if rT < minT:
					minT = rT
					minLst = [x] + rLst
			r = minT, minLst
			solveEvenRec.d[ns] = r
			return r
		solveEvenRec.d = {}

		newLst = []
		for i in range(n):
			if i not in seen:
				newLst.append(i)
		newN = n - len(seen)
		if newN == 2:
			minT = 10000000
			minLst = []
			for a in ts:
				if ts[a] < minT:
					minT = ts[a]
					minLst = [a]
			rT = minT
			rLst = minLst
		else:
			newTsLst = []
			for x in tsLst:
				a, _ = x
				i, j = a
				if i not in seen and j not in seen:
					newTsLst.append(a)
			notSeen = set(range(n)) - set(seen)
			rT, rLst = solveEvenRec(notSeen, newTsLst)
		return rT, rLst
	ts = {}
	tss = {}
	for i in range(n-1):
		x1, y1 = oLst[i]
		for j in range(i+1, n):
			x2, y2 = oLst[j]
			t = T(x1, y1, x2, y2)
			t1 = T(x1, y1, xs, ys)
			t2 = T(xs, ys, x2, y2)
			if t1+t2 >= t:
				ts[(i, j)] = t
				tss[(i, j)] = True
			else:
				ts[(i, j)] = t1+t2
				tss[(i, j)] = False
	tsLst = []
	for x in ts:
		tsLst.append((x, ts[x]))
	tsLst.sort(key=lambda x:x[1])
	if n%2:
		if n > 1:
			resT = 10000000
			resLst = []
			for i in range(n):
				x, y = oLst[i]
				t = 2*T(x, y, xs, ys)
				rT, rLst = solveEven([i])
				for a in rLst:
					i1, i2 = a
					x1, y1 = oLst[i1]
					x2, y2 = oLst[i2]
					rT += T(xs, ys, x1, y1)
					rT += T(xs, ys, x2, y2)
				rT += t
				if rT < resT:
					resT = rT
					newRLst = ['0']
					for a in rLst:
						w, v = a
						if tss[(w, v)]:
							newRLst.append(str(w+1))
							newRLst.append(str(v+1))
							newRLst.append('0')
						else:
							newRLst.append(str(w+1))
							newRLst.append('0')
							newRLst.append(str(v+1))
							newRLst.append('0')
					newRLst.append(str(i+1))
					newRLst.append('0')
					resLst = newRLst
		else:
			x, y = oLst[0]
			resT = 2*T(x, y, xs, ys)
			resLst = ['0', '1', '0']
	else:
		resT, rLst = solveEven([])
		for a in rLst:
			i1, i2 = a
			x1, y1 = oLst[i1]
			x2, y2 = oLst[i2]
			resT += T(xs, ys, x1, y1)
			resT += T(xs, ys, x2, y2)
		newRLst = ['0']
		for a in rLst:
			w, v = a
			if tss[(w, v)]:
				newRLst.append(str(w+1))
				newRLst.append(str(v+1))
				newRLst.append('0')
			else:
				newRLst.append(str(w+1))
				newRLst.append('0')
				newRLst.append(str(v+1))
				newRLst.append('0')
		resLst = newRLst
	return resT, resLst

xs, ys = I()
n = input()
oLst = []
for _ in range(n):
	x, y = I()
	oLst.append((x, y))
resT, resLst = solve(xs, ys, n, oLst)
print(resT)
print(' '.join(resLst))",np
"n=int(input())

a=list(map(int,input().split()))
b=list(map(int,input().split()))

s=[0]*n

ans=True

for i in range(n):
    ans=ans and a[i]<=i and b[i]<=(n-i-1)
    s[i]=n-a[i]-b[i]

def qwe(s,j):
    l,r=0,0
    for i in range(len(s)):
        if i<j and s[i]>s[j]: l+=1
        elif i>j and s[i]>s[j]: r+=1
    return l,r

if ans:
    for i in range(n):
        l,r=qwe(s,i)
        ans=ans and a[i]==l and b[i]==r

if ans:
    print('YES')
    for i in range(n):
        print(n-a[i]-b[i],end=' ')
else: print('NO')
",O(n ^ 2)
"class Solution3(object):
    def hIndex(self, citations):
        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))",O(nlogn)
"n = int(input())
l = list(map(int,input().split()))
l=sorted(l)
if l[-1]==1:
    l[-1]=2
else:
    l[-1]=1
l=sorted(l)
print(*l)",O(nlogn)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)
",O(nlogn)
"n,k = map(int,input().split())

def sumTillN (n) :
    return (n*(n+1))//2

minEat = 0
maxEat = n
midEat = 0

while (minEat<=maxEat):
    midEat = (minEat+maxEat)//2
    x = sumTillN(n-midEat)
    if (x==k+midEat):
        break
    elif (x>k+midEat):
        minEat = midEat+1
    else:
        maxEat = midEat-1

print(midEat)
",O(logn)
"from itertools import combinations_with_replacement
import sys
from sys import stdin
import math
import bisect

def BinarySearch(a, x):
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    else:
        return -1
def iinput():
    return int(input())
def minput():
    return map(int,input().split())
def linput():
    return list(map(int,input().split()))

def fiinput():
    return int(stdin.readline())
def fminput():
    return map(int,stdin.readline().strip().split())
def flinput():
    return list(map(int,stdin.readline().strip().split()))

x,k=minput()

if(x==0):
    print(0)
else:
    mod=(10**9)+7
    a=pow(2,k,mod)
    b=((2*x)%mod-1)%mod
    ans=((a*b)%mod+1)%mod
    print(ans)",O(logn)
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0

	for v in a:

		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break

			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",O(nlogn)
"n=int(input())
arr=[]
for i in range(n):
    arr.append(input())

arr.sort(key=lambda x: len(x))
flag=False
for i in range(n-2,-1,-1):
    if arr[i] not in arr[i+1]:
        flag=True
        break

if flag:
    print(""NO"")
else:
    print(""YES"")
    for i in arr:
        print(i)",O(nlogn)
"class Solution2(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max = max(1, local_max)
            if x > 0:
                local_max, local_min = local_max * x, local_min * x
            else:
                local_max, local_min = local_min * x, local_max * x
            global_max = max(global_max, local_max)
        return global_max",O(n)
"MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))
from collections import defaultdict as dd
n , = I()
d = dd(list)
for i in range(n-1):
	t = I()
	d[t[0]].append(t[1])
	d[t[1]].append(t[0])
l = I()
v = [0]*(n+1)
s = 1
what = 0
v[1] = 1
while what < s:
        a = set()
        i = l[what]
        for j in d[i]:
                if not v[j]:
                        a.add(j)
        b = set()
        for j in range(s,s + len(a)):
                b.add(l[j])
        if a!=b:
                print('No')
                exit()
        kkk = 0
        for k in a:
            kkk += 1
            v[k] = 1
        s += kkk
        what += 1
if s != n:
    print('No')
    exit()
print('Yes')
",O(nlogn)
"import sys
import math
input = sys.stdin.readline

a,b,c=input().split()

s=[]
p=[]
m=[]

if a[1]=='p':
	p.append(int(a[0]))
elif a[1]=='s':
	s.append(int(a[0]))
else:
	m.append(int(a[0]))

if b[1]=='p':
	p.append(int(b[0]))
elif b[1]=='s':
	s.append(int(b[0]))
else:
	m.append(int(b[0]))

if c[1]=='p':
	p.append(int(c[0]))
elif c[1]=='s':
	s.append(int(c[0]))
else:
	m.append(int(c[0]))

s.sort()
p.sort()
m.sort()

cur=2
if len(s)==3:
	if s[0]==s[1] and s[1]==s[2]:
		cur=0
	elif s[0]==s[1] or s[1]==s[2]:
		cur=1
	else:
		if s[0]+1==s[1] and s[1]+1==s[2]:
			cur=0
		elif s[0]+1==s[1] or s[1]+1==s[2]:
			cur=1
		elif s[0]+2==s[1] or s[1]+2==s[2]:
			cur=1
		else:
			cur=2
elif len(s)==2:
	if s[0]==s[1]:
		cur=1
	elif s[0]+1==s[1]:
		cur=1
	elif s[0]+2==s[1]:
		cur=1
	else:
		cur=2
else:
	cur=2

x=2
if len(p)==3:
	if p[0]==p[1] and p[1]==p[2]:
		x=0
	elif p[0]==p[1] or p[1]==p[2]:
		x=1
	else:
		if p[0]+1==p[1] and p[1]+1==p[2]:
			x=0
		elif p[0]+1==p[1] or p[1]+1==p[2]:
			x=1
		elif p[0]+2==p[1] or p[1]+2==p[2]:
			x=1
		else:
			x=2
elif len(p)==2:
	if p[0]==p[1]:
		x=1
	elif p[0]+1==p[1]:
		x=1
	elif p[0]+2==p[1]:
		x=1
	else:
		x=2
else:
	x=2

y=2
if len(m)==3:
	if m[0]==m[1] and m[1]==m[2]:
		y=0
	elif m[0]==m[1] or m[1]==m[2]:
		y=1
	else:
		if m[0]+1==m[1] and m[1]+1==m[2]:
			y=0
		elif m[0]+1==m[1] or m[1]+1==m[2]:
			y=1
		elif m[0]+2==m[1] or m[1]+2==m[2]:
			y=1
		else:
			y=2
elif len(m)==2:
	if m[0]==m[1]:
		y=1
	elif m[0]+1==m[1]:
		y=1
	elif m[0]+2==m[1]:
		y=1
	else:
		y=2
else:
	y=2

print(min(cur,x,y))",O(nlogn)
"def subsets(L, i):
    if i == len(L):
        yield []
    else:
        for s in subsets(L, i+1):
            yield s
            yield [L[i]] + s

def computeValidProblemsets(problems, l, r, x):
    isValid = lambda ps: (len(ps) > 1) and (l <= sum(ps) <= r) and (ps[-1]-ps[0] >= x)
    print(sum(isValid(problemset) for problemset in subsets(sorted(problems), 0)))

if __name__ == '__main__':
    n, l, r, x = map(int, input().split())
    problems = list(map(int, input().split()))
    computeValidProblemsets(problems, l, r, x)
",np
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    for l in cnt:
        if l.count(0)<1:
            continue
        t=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",O(n ^ 2)
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')
",O(n ^ 2)
"n, k=[int(v) for v in input().split()]
if n==1:
    print(0)
elif n-1>(1+k-1)*(k-1)//2:
    print(-1)
else:
    n-=1
    k-=1
    l, r=0, k+1
    while r-l>1:
        m=(l+r)//2
        if (m+k)*(k-m+1)//2>=n:
            l=m
        else:
            r=m
    print(k-l+1)",O(logn)
"
class Node(object):
    def __init__(self, val, left, right):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def treeToDoublyList(self, root):
        if not root:
            return None
        left_head, left_tail, right_head, right_tail = root, root, root, root
        if root.left:
            left_head = self.treeToDoublyList(root.left)
            left_tail = left_head.left
        if root.right:
            right_head = self.treeToDoublyList(root.right)
            right_tail = right_head.left
        left_tail.right, right_head.left = root, root
        root.left, root.right = left_tail, right_head
        left_head.left, right_tail.right = right_tail, left_head
        return left_head

",O(n)
"import sys

def rint():
    return map(int, sys.stdin.readline().split())

def writable(r, c):
    if r+2 >= n or c+2 >= m:
        return False
    t = set()
    t.add(cells[r][c])
    t.add(cells[r][c+1])
    t.add(cells[r][c+2])
    t.add(cells[r+1][c])
    t.add(cells[r+1][c+2])
    t.add(cells[r+2][c])
    t.add(cells[r+2][c+1])
    t.add(cells[r+2][c+2])
    return not '.' in t

def fill_ink(r,c):
    paper[r][c] = ""
    paper[r][c+1] = ""
    paper[r][c+2] = ""
    paper[r+1][c] = ""
    paper[r+1][c+2] = ""
    paper[r+2][c] = ""
    paper[r+2][c+1] = ""
    paper[r+2][c+2] = ""

n, m = rint()

cells = []
for i in range(n):
    cells.append(input())

paper = [[""."" for j in range(m)] for i in range(n)]

for r in range(n):
    for c in range(m):
        if writable(r,c) is True:
            fill_ink(r, c)

for r in range(n):
    for c in range(m):
        if cells[r][c] != paper[r][c]:
            print(""NO"")
            exit()

print(""YES"")
",O(n ^ 2)
"n=int(input())
def judge(x):
    if x%2==0:
        return 0
    else:
        return 1
ls=[int(x) for x in input().split()]
if judge(ls[0])==judge(ls[1]):
    for x in ls[2:]:
        if judge(x)!=judge(ls[0]):
            print(ls.index(x)+1)
            break
else:
    if judge(ls[2])==judge(ls[0]):
        print(2)
    elif judge(ls[2])==judge(ls[1]):
        print(1)",O(n)
"n, k = map(int, input().split())
print((n*2)//k + bool((n*2)%k) + (n*5)//k + bool((n*5)%k) + (n*8)//k + bool((n*8)%k))",O(1)
"import collections


class Solution(object):
    def frequencySort(self, s):
        freq = collections.defaultdict(int)
        for c in s:
            freq[c] += 1

        counts = [""""] * (len(s)+1)
        for c in freq:
            counts[freq[c]] += c

        result = """"
        for count in reversed(range(len(counts)-1)):
            for c in counts[count]:
                result += c * count

        return result",O(n)
"class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & (n - 1)) == 0",O(1)
"n=int(input())
A=list(map(int,input().split()))
B=list(map(int,input().split()))

REVA=[None]*(n+1)

for i in range(n):
    REVA[A[i]]=i+1

top=0
ANSLIST=[]

for b in B:
    if REVA[b]>top:
        ANSLIST.append(REVA[b]-top)
        top=REVA[b]
    else:
        ANSLIST.append(0)

for ans in ANSLIST:
    print(ans,end="" "")
",O(n)
"class Solution(object):
    def modifyString(self, s):
        s = list(s)
        for i in range(len(s)):
            if s[i] != '?':
                continue
            for c in ('a', 'b', 'c'):
                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):
                    break
            s[i] = c
        return """".join(s)",O(n)
"class Solution(object):
    def convertDateToBinary(self, date):
        return ""-"".join([bin(int(x))[2:] for x in date.split('-')])",O(1)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write("""".join((str(i),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n"")))

if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n"")))

    if m%2==1:
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))
",O(n ^ 2)
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        not_i = ((1 << m) - 1) ^ i
        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])
        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)
print(dp[-1])",np
"import math

n, m = map(int, input().split())

b = list(map(int, input().split()))
g = list(map(int, input().split()))

first_max = 0
second_max = 0
for i in range(n):
	if b[i] < first_max and b[i] > second_max:
		second_max = b[i]
	if b[i] >= first_max:
		second_max = first_max
		first_max = b[i]

first_min = min(g)

if first_max > first_min:
	print(-1)
else:
	total = sum(b) * m + sum(g) - m * first_max + (first_max - second_max) * (first_min != first_max)
	print(total)
",O(n)
"import math
a=input()
b=input()
i=a.count('+')
j=a.count('-')
k=b.count('+')
l=b.count('-')
m=b.count('?')
c1=(i-j)
c2=(k-l)
c=abs(c1-c2)
w=m-c
x=w//2
y=w//2+c
if(c==0 and m==0):
    print(1)
elif((c)>m):
    print(0)
else:
    x=math.factorial(m)//(math.factorial(x)*math.factorial(y))
    print(x/pow(2,m))
",np
"import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True",O(n)
"class Solution(object):
    def similarRGB(self, color):
        def rounding(color):
            q, r = divmod(int(color, 16), 17)
            if r > 8: q += 1
            return '{:02x}'.format(17*q)

        return 
                rounding(color[1:3]) + \
                rounding(color[3:5]) + \
                rounding(color[5:7])",O(1)
"def func():
    n, k = map(int, input().strip().split())
    l = 0
    r = n
    while l <= r:
        mid = (l + r) // 2
        if mid*(mid+1)/2 - (n-mid) < k:
            l = mid + 1
        elif mid*(mid+1)/2 - (n-mid) > k:
            r = mid
        else:
            print(n - mid)
            return mid

if __name__ == '__main__':
    func()",O(logn)
"class Solution2(object):
    def findUnsortedSubarray(self, nums):
        a = sorted(nums)
        left, right = 0, len(nums) -1
        while (nums[left] == a[left] or nums[right] == a[right]):
            if right - left <= 1:
                return 0
            if nums[left] == a[left]:
                left += 1
            if nums[right] == a[right]:
                right -= 1
        return right - left + 1",O(nlogn)
"def cal(r,g,b):
	if dp[r][g][b]!=-1:
		return dp[r][g][b]
	ans=0
	if r<R and g<G:
		ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))
	if r<R and b<B:
		ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))
	if g<G and b<B:
		ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))
	dp[r][g][b]=ans
	return ans

R,G,B=map(int,input().split())
rl=sorted(list(map(int,input().split())),reverse=True)
gl=sorted(list(map(int,input().split())),reverse=True)
bl=sorted(list(map(int,input().split())),reverse=True)
dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]
print(cal(0,0,0))",O(n ^ 3)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",O(n)
"import math
import collections

def func(a, k):
    if a % k != 0:
        mod = 1
    else:
        mod = 0
    return math.floor(a / k) * k + mod * k

n, m, k = input().split()
list = input().split()
k = int(k)
temp = k
size = 0
answer = 0
c = 0
c2 = 0
check = 'false'
used = 0

temp = func(int(list[0]), k)
for i in range(len(list)):
    list[i] = int(list[i])
    used = 0
    if list[i] <= temp:
        c += 1
        check = 'true'
        used = 1
    if list[i] >= temp:
        if check is 'true':
            answer += 1
            check = 'false'
            temp += c
            c = 0
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1
            else:
                temp = temp + func(int(list[i]) - temp, k)
                if list[i] - c <= temp and used == 0:
                    c += 1
                    check = 'true'
                    used = 1
        elif check is 'false':
            temp = temp + func(int(list[i]) - temp, k)
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1

print(answer if check is 'false' else answer + 1)",O(n)
"x, k = [int(x) for x in input().split()]

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

res = x * pow(2, k + 1, mod) % mod
res = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod

print(res)
",O(logn)
"from math import *
n,k=map(int,input().split())
val=int(sqrt(9+(8*(n+k))))
ans=(-3+val)//2
print(n-ans)
",O(1)
"n, m, k, l = map(int, input().split())
required = k + l
per_friend = (required + m - 1) // m
if (m * per_friend > n):
    print(-1)
else:
    print(per_friend)
",O(1)
"n, k = map(int, input().split())
c = 1
while c * (c + 1) // 2 < k:
    c += 1
while c * (c + 1) // 2 - (n - c) != k:
    c += 1
print(n - c)
",O(n)
"l,r=map(int,input().split())
if(l==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l^r
        p1=1
        while(p1<=x):
            p1*=2
        print(p1-1)
",O(logn)
"import sys, os
from collections import defaultdict

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=input
    def debug(*args):
        pass

def get_hash(s):
    r=0
    for c in s:
        r*=30
        if c!='_':
            r+=ord(c)-96
    return r

def matches(s):
    R=[]
    for i in range(2**k):
        r=0
        for j in range(k):
            if i&(1<<j):
                r+=(ord(s[j])-96)*(30**(k-j-1))
        if pattern_pos[r]>=0:

            R.append(pattern_pos[r])
    return R

n,m,k=map(int,inp().split())

pattern_pos=[-1]*(30**k)

for i in range(n):
    p=get_hash(inp().strip())
    pattern_pos[p]=i+1

parents=[0]*(n+1)
edges=defaultdict(list)
failed=False
for i in range(m):
    s,l=inp().split()
    l=int(l)
    M=matches(s)
    if l in M:
        for m in M:
            if l==m: continue
            edges[l].append(m)
            parents[m]+=1
    else:
        failed=True
        break

if failed:
    print('NO')
else:
    Q=[]
    for i in range(1,n+1):
        if parents[i]==0:
            Q.append(i)

    ans=[]
    while Q:
        i=Q.pop()
        ans.append(i)
        for child in edges[i]:
            parents[child]-=1
            if parents[child]==0:
                Q.append(child)
    if len(ans)==n:
        print('YES')
        print(*ans)
    else:
        print('NO')
",np
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:

            m = l + ((r - l) // 2)

            if nums[m] > target:
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                return m
        return -1
",O(logn)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def dfs():
            token = tokens.pop()
            if token not in ""+-*/"":
                return int(token)

            right = dfs()
            left = dfs()

            if token == '+':
                return left + right
            elif token == '-':
                return left - right
            elif token == '*':
                return left * right
            elif token == '/':
                return int(left / right)

        return dfs()
",O(n)
"class Solution(object):
    def minFlips(self, target):
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result",O(n)
"l, r = [{'0': 1, 'X': 0}[c] for cc in zip(input(), input()) for c in cc], 0
for i in range(0, len(l) - 3, 2):
    s = 7 - sum(l[i:i + 4])
    if s < 5:
        r += 1
        l[i:i + s] = [0] * s
print(r)",O(1)
"n, k = list(map(int, input().strip().split()))
arr = list(map(int, input().strip().split()))
k -= 1
arr_new = sorted([arr[i+1]-arr[i] for i in range(n-1)], reverse=True)
print(arr[-1]-arr[0]-sum(arr_new[:k]))
",O(nlogn)
"n = int(input())
probs = list()
for i in range(n): probs.append(list(map(float, input().split())))
dp = [list([0 for i in range(1<<n)]) for i in range(n)]
dp[0][(1<<n)-1] = 1
ak = [list() for i in range(n+1)]
for i in range(1<<n):
    ak[bin(i).count(""1"")].append(i)
for k in range(1, n):
    for ele in ak[n-k+1]:
        for j in range(n):
            if (ele&(1<<j)):
                for w in range(n):
                    if (ele&(1<<w)) and j != w:
                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2)
for i in range(n):
    print(dp[n-1][(1<<i)], end = "" "")
print()",np
"import sys

def sol(a,b):
	for square in [a,b]:
		for i1 in range(4):
			i2 = (i1 + 1)%4
			p1,p2 = square[i1],square[i2]

			norm = (p2[1]-p1[1],p1[0]-p2[0])

			minA = maxA = minB = maxB = None
			for p in a:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minA == None or proj < minA:
					minA = proj
				if maxA == None or proj > maxA:
					maxA = proj
			for p in b:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minB == None or proj < minB:
					minB = proj
				if maxB == None or proj > maxB:
					maxB = proj

			if maxA < minB or maxB < minA:
				return False
	return True

x11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))
x21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))

a = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]
b = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]

print([""NO"",""YES""][sol(a,b)])",O(1)
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp

x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",O(logn)
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
d = {}
i = 1
for x in arr:
	if len(d) == m:
		break
	d[x] = i
	i += 1
if len(d) == m:
	print(min(d.values()), max(d.values()))
else:
	print(-1,-1)
",O(n)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        low, high = 1, n - 1
        while low < high:
            mid = low + (high - low) // 2
            lessOrEqual = sum(1 for num in nums if num <= mid)

            if lessOrEqual <= mid:
                low = mid + 1
            else:
                high = mid

        return low
",O(nlogn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)
",O(n ^ 2)
"s=input()
length=len(s)
answer=[ ]
for i in range (0,length):
    for j in range(i+1,length+1):
        k=s[i:j]
        co=0
        for u in range (0,length):
            if(s[u:].startswith(k)):
                co+=1
        if(co>=2):

            answer.append(len(k))
if(len(set(s))==length):
    print('0')
else:
    print(max(answer))
",O(n ^ 3)
"class Solution(object):
    def canMakeArithmeticProgression(self, arr):
        m = min(arr)
        d = (max(arr)-m)//(len(arr)-1)
        if not d:
            return True
        i = 0
        while i < len(arr):
            if arr[i] == m+i*d:
                i += 1
            else:
                j, r = divmod(arr[i]-m, d)
                if r or j >= len(arr) or arr[i] == arr[j]:
                    return False
                arr[i], arr[j] = arr[j], arr[i]
        return True",O(n)
"class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        result = [1]*nodes
        for i in reversed(range(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]",O(n)
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()

x = 1
while x <= r:
    x = x << 1
x = x >> 1

k = x
while x <= l or x > r:
    if x <= l:
        x += k
    else:
        x -= k
    k = k >> 1

print(x ^ (x - 1))
",O(logn)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]
",O(n)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=99999999999999999999999999999999

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n=ri()
        s=ria()
        c=ria()
        ans=INF
        for i in range(n):
            mid=s[i]
            mcl=INF
            mrl=INF
            for j in range(i-1,-1,-1):
                if s[j]<mid:
                    mcl=min(mcl,c[j])
            for j in range(i+1,n):
                if s[j]>mid:
                    mrl=min(mrl,c[j])
            ans=min(ans,c[i]+mcl+mrl)
        if ans==INF:
            wi(-1)
        else:
            wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n ^ 2)
"import sys
from math import gcd
from collections import defaultdict as dd
input=sys.stdin.readline
n=int(input())
l=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=dict()
for i in range(n):
    if dp.get(l[i]):
        dp[l[i]]=min(dp[l[i]],c[i])
    else:
        dp[l[i]]=c[i]
for ll in l:
    keys=list(dp.keys())
    for j in keys:
        g=gcd(j,ll)
        if dp.get(g):
            dp[g]=min(dp[g],dp[ll]+dp[j])
        else:
            dp[g]=dp[ll]+dp[j]
if 1 in dp:
    print(dp[1])
else:
    print(-1)",np
"n=int(input())
print(n//2+1)",O(1)
"N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):
        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1
    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):
    print(-1)
    exit(0)
res.append(cur)
print(*res)",O(n)
"a, b, c=map(int, input().split())
d=sorted(list(map(int, input().split())))

e=d[c-1]
f=d[c]
print(f-e)
",O(nlogn)
"import heapq


class Solution(object):
    def connectSticks(self, sticks):
        heapq.heapify(sticks)
        result = 0
        while len(sticks) > 1:
            x, y = heapq.heappop(sticks), heapq.heappop(sticks)
            result += x+y
            heapq.heappush(sticks, x+y)
        return result",O(nlogn)
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] < 1:
            cur += 1
            continue

        if a[i] - a[j] > m:
            break

        cur += 1

        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",O(nlogn)
"def reach_max(n, k):
    return n * k + 1 - n * (n + 1) // 2

n, k = map(int, input().split())

if n == 1:
    print(0)
    exit()

lo, hi = 1, k - 1

if n > reach_max(hi, k):
    print(-1)
    exit()

while lo < hi:
    mid = (lo + hi) // 2
    if reach_max(mid, k) < n:
        lo = mid + 1
    else:
        hi = mid

print(lo)
",O(logn)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        for i in range(maxLength+1):
            dp[i%w] = 1 if i == 0 else 0
            if i-oneGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD
            if i-zeroGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD
            if i >= minLength:
                result = (result+dp[i%w])%MOD
        return result",O(n)
"class Solution(object):
    def sum(self, num1, num2):
        return num1+num2",O(1)
"class Solution(object):
    def minAddToMakeValid(self, S):
        add, bal, = 0, 0
        for c in S:
            bal += 1 if c == '(' else -1
            if bal == -1:
                add += 1
                bal += 1
        return add + bal",O(n)
"class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)",O(n)
"class Solution2(object):
    def numberOfAlternatingGroups(self, colors):
        return sum(colors[i] != colors[(i+1)%len(colors)] != colors[(i+2)%len(colors)] for i in range(len(colors)))",O(n)
"n,a,b=map(int,input().split())
if a>n:
    print('NO')
    exit()
if b>n:
    print(""NO"")
    exit()
if a==1  and b==1:
    if n==2 or n==3:
        print('NO')
        exit()
if n==1 and a>1 or n==1 and b>1:
    print('NO')
    exit()
if min(a,b)>1:
    print('NO')
    exit()

def check(mat):
    vis=[0]*n
    cnt=0
    for i in range(n):
        if vis[i]==0:
            q=[i]
            cnt+=1
            vis[i]=1
            while q:
                t=q.pop(0)
                for j in range(n):
                    if mat[t][j]==1 and vis[j]==0:
                        vis[j]=1
                        q.append(j)
        return cnt
mat=[[0 for i in range(n)] for j in range(n)]
m=max(a,b)
j=1
for i in range(n):
    if j<n:
        mat[i][j]=1
        mat[j][i]=1
    j+=1
for i in range(m-1):
    curr=n-i-1
    for j in range(n):
        if mat[curr][j]==1:
            mat[curr][j]=0
            mat[j][curr]=0
if b==1:
    print('YES')
    for i in range(n):
        print(*mat[i],sep='')

else:
    print('YES')
    for i in range(n):
        for j in range(n):
            mat[i][j]=1-mat[i][j]
    for i in range(n):
        mat[i][i]=0
    for i in range(n):
        print(*mat[i],sep='')",O(n ^ 2)
"class Solution2(object):
    def firstPalindrome(self, words):
        return next((x for x in words if x == x[::-1]), """")",O(n)
"class Solution(object):
    def countSegments(self, s):
        result = int(len(s) and s[-1] != ' ')
        for i in range(1, len(s)):
            if s[i] == ' ' and s[i-1] != ' ':
                result += 1
        return result

    def countSegments2(self, s):
        return len([i for i in s.strip().split(' ') if i])",O(n)
"n=int(input())

ax, ay = map(int,input().split())
bx, by = map(int,input().split())

cx, cy = map(int,input().split())

if ((bx<ax and cx<ax) or (bx>ax and cx>ax)) and ((by<ay and cy<ay) or (by>ay and cy>ay)):
	print('YES')

else:
	print('NO')",O(1)
"import collections


class Solution(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, curr, sum, lookup):
            if root is None:
                return 0
            curr += root.val
            result = lookup[curr-sum] if curr-sum in lookup else 0
            lookup[curr] += 1
            result += pathSumHelper(root.left, curr, sum, lookup) + \
                      pathSumHelper(root.right, curr, sum, lookup)
            lookup[curr] -= 1
            if lookup[curr] == 0:
                del lookup[curr]
            return result

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        return pathSumHelper(root, 0, sum, lookup)",O(n)
"n = int(input())
rang = list(range(2,n//2+1))
a = [i*(n//i-1) for i in rang]
print(sum(a)*4)
",O(n)
"import collections



class Solution(object):
    def largestPalindromic(self, num):
        cnt = collections.Counter(num)
        result = []
        for i in reversed(range(10)):
            if not cnt[str(i)]//2 or (i == 0 and not result):
                continue
            for _ in range(cnt[str(i)]//2):
                result.append(str(i))
        result.append(max([k for k, v in cnt.items() if v%2] or [""""]))
        for i in reversed(range(len(result)-1)):
            result.append(result[i])
        return """".join(result) or ""0""",O(n)
"n = int(input())
A = [int(a) for a in input().split()]
B = A.copy()
B.sort()
c = 0
for i in range(n):
    a = A[i]
    b = B[i]
    if a == b:
        continue
    else:
        c += 1
if c == 0 or c == 2:
    print(""YES"")
else:
    print(""NO"")",O(nlogn)
"import math

n, m, k = list(map(lambda i: int(i), input().split(sep=' ')))
p = list(map(lambda i: int(i), input().split(sep=' ')))
p.sort()
page_max = k
action_count = 0
index = 0
while index < m:
    while index < m and p[index] <= page_max:
        count = 0
        while index < m and p[index] <= page_max:
            index += 1
            count += 1
        if count > 0:
            action_count += 1
        page_max += count

    pc = 1 if index >= m else math.ceil((p[index] - page_max) / k)
    page_max += k * pc

print(action_count)
",O(nlogn)
"class Solution(object):
    def isBalanced(self, num):
        return sum(ord(num[i])-ord('0') for i in range(0, len(num), 2)) == sum(ord(num[i])-ord('0') for i in range(1, len(num), 2))",O(n)
"class Solution(object):
    def minMoves(self, nums, k):
        def moves(i, j):
            return prefix[j+1]-prefix[i]

        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        for i in range(len(idxs)-k+1):
            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1)) 
        result -= (k//2)*((k+1)//2) 
        return result",O(n)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    a.sort()
    if a[-2]>n-2:
        print(n-2)
    else:
        print(a[-2]-1)",O(nlogn)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return None

        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
",O(n)
"import bisect



class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):
        lookup = collections.defaultdict(list)
        A = list(zip(timestamp, username, website))
        A.sort()
        for t, u, w in A:
            lookup[u].append(w)
        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())
        return list(min(count, key=lambda x: (-count[x], x)))",O(n ^ 3)
"n=int(input())
m=str(n)
print(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))
",O(1)
"a = []
n = int(input())
for _ in range(n):
    a.append(input())
if n==1:
    print(""YES"")
    print(a[0])
else:
    a.sort(key = len)
    for i in range(1,n):
        if a[i-1] not in a[i]:
            print(""NO"")
            break
    else:
        print(""YES"")
        for i in a:
            print(i)
",O(nlogn)
"def main():
    def calc(x1, y1, x2, y2):
        if x1 > x2 or y1 > y2:
            return 0
        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        if (x1 + y1) % 2 == 1:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1
        return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    T = int(input())
    for t in range(T):
        n, m = map(int, input().split())
        a, b, c, d = map(int, input().split())
        e, f, g, h = map(int, input().split())
        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)
        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)
        print(n * m - black, black)

main()
",O(1)
"a=input()
b=input()
c=input()
info=a.split()
info=list(map(int, info))
y=b.split()
powers=list(map(int, y))
z=c.split()
coins=list(map(int, z))
l=sorted(zip(powers,coins,range(info[0])))
final=[0]*info[0]
s=0
w=[]
for _, c, i in l:
    s+=c
    final[i]=s
    w=sorted(w+[c])
    if len(w)>info[1]:
        s-=w[0]
        del w[0]
print(*final)",O(nlogn)
"n = int(input())

arr = [int(z) for z in list(input())]
ans = 0

if n == 2:
    if arr[0] == arr[1]:
        print(""YES"")
    else:
        print(""NO"")
    exit()

for l in range(1, n-1):
    s = sum(arr[:l])
    i = l
    v = [s]
    curr = 0
    while i < n:
        curr += arr[i]
        if i == n-1:
            if curr > s:
                curr -= arr[i]
                v.append(curr)
                curr = arr[i]
            v.append(curr)
        elif curr > s:
            curr -= arr[i]
            v.append(curr)
            curr = arr[i]
        i += 1

    if len(set(v)) == 1:
        print(""YES"")

        ans = 1
        exit()

if not ans:
    print(""NO"")
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]

    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():

        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):

                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]]
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
abc = [inpl() for _ in range(m)]

def sol(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return all(seen)

def sol2(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    tps = [-1]*n; T = 0
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        tps[v] = T; T += 1
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return tps

ok = 10**9+10; ng = -1
while abs(ok-ng)>1:
    mid = (ok+ng)//2
    if sol(mid): ok = mid
    else: ng = mid

res = []
tps = sol2(ok)
for i,(a,b,c) in enumerate(abc):
    if c <= ok:
        if tps[a-1] > tps[b-1]: res.append(i+1)
print(ok,len(res))
print(*res)",O(nlogn)
"class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result",O(n)
"n , k = map(int, input().split())

l = 0
r = n
while r - l > 1:
    mid = (r + l) // 2
    a = n - mid
    if ((1 + a) * a) // 2 >= k + mid:
        l = mid
    else:
        r = mid
print(l)",O(logn)
"for _ in range(int(input())):
    i, j = map(int, input().split())
    i -= 1
    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) -
          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2))))",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result",O(n)
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",O(n ^ 2)
"n, k = map(int, input().split(' '))
s = input()
m = 10 ** 10
for i in range(k):
    c = chr(ord('A') + i)
    m = min(m, s.count(c))
print(m * k)",O(n)
"class Solution(object):
    def compress(self, chars):
        anchor, write = 0, 0
        for read, c in enumerate(chars):
            if read+1 == len(chars) or chars[read+1] != c:
                chars[write] = chars[anchor]
                write += 1
                if read > anchor:
                    n, left = read-anchor+1, write
                    while n > 0:
                        chars[write] = chr(n%10+ord('0'))
                        write += 1
                        n /= 10
                    right = write-1
                    while left < right:
                        chars[left], chars[right] = chars[right], chars[left]
                        left += 1
                        right -= 1
                anchor = read+1
        return write",O(n)
"def solve(x,y,z):
    global r,g,b,ans
    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):
        return 0
    if memo[x][y][z] != -1:
        return memo[x][y][z]
    mx = 0
    if x < r and y < g:
        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))
    if x < r and z < b:
        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))
    if y < g and z < b:
        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))
    ans = max(ans,mx)
    memo[x][y][z] = mx
    return mx

r,g,b = map(int,input().split())
ra = sorted(list(map(int,input().split())),reverse = True)
ga = sorted(list(map(int,input().split())),reverse = True)
ba = sorted(list(map(int,input().split())),reverse = True)

memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]

ans = 0

solve(0,0,0)
print(ans)
",O(n ^ 3)
"def qtd(u):
    ans = 0
    while(u > 0):
        u//=10
        ans += 1
    return ans

def digitos(u):
    ans = 0
    while(u > 0):
        ans += u%10
        u//=10
    return ans

n, m = input().split()
m = int(m)
number = int(n)
ans = 0
size_n = qtd(m)
i = m

while(i < m+(size_n*9) + 1):
    if(i > number):
        break
    if(i - digitos(i) >= m):
        ans += 1
    i += 1

if(i > number):
    print(ans)
else:
    print(number-i+1+ans)
",O(logn)
"n, l, r, x = map(int, input().split())
tasks = [int(i) for i in input().split()]
cnt = 0
for num in range(2 ** n):
    bin_num = bin(num)[2:]
    if len(bin_num) < n:
        bin_num = '0' * (n - len(bin_num)) + bin_num
    m = []
    for i in range(n):
        if bin_num[i] == '1':
            m.append(tasks[i])
    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:
        cnt += 1
print(cnt)",np
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",O(1)
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t

n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",O(n)
"n,k = map(int, raw_input().split())

def area(height):
    return n * height

def bin_search(low, high):
    if (high == low):
        return high
    if high - low == 1:
        if area(low) >= k:
            return low
        return high
    midd = (high + low) // 2
    if area(midd) > k:
        return bin_search(low, midd)
    return bin_search(midd, high)

print(bin_search(0, 1000000000000000000))",O(logn)
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])
",O(logn)
"k = int(input())
if k <= 9:
    print(k)
else:
    length = len(str(k))
    s = """"
    num = 0

    for i in range(length - 1):
        num += (9*(10**i))*(i + 1)
        temp = num + (9*(10**(i + 1)))*(i + 2)
        if temp > k:
            length = i + 2
            break

    for i in range(length - 1):
        s = s + ""1""

    previous_value = 9 * int(s)
    try_value = k - num

    if try_value % length == 0:
        div_value = try_value // length
        temp_string = str(previous_value + div_value)
        print(temp_string[len(temp_string) - 1])
    else:
        div_value = (try_value // length) + 1
        temp_string = str(previous_value + div_value)
        differ = (div_value * length) - try_value
        print(temp_string[len(temp_string) - differ - 1])",O(logn)
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",O(logn)
"import math
s1=list(input())
s2=list(input())
p1,m1,p2,m2,c=0,0,0,0,0
for i in range(len(s1)):
	if(s1[i]=='+'):
		p1+=1
	if(s1[i]=='-'):
		m1+=1
	if(s2[i]=='+'):
		p2+=1
	if(s2[i]=='-'):
		m2+=1
	if(s2[i]=='?'):
		c+=1
p=abs(p1-p2)
m=abs(m1-m2)
if((p+m)==c):
	print(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))
else:
	print(0/1)",np
"class Solution2(object):
    def areNumbersAscending(self, s):
        nums = [int(x) for x in s.split() if x.isdigit()]
        return all(nums[i] < nums[i+1] for i in range(len(nums)-1))",O(n)
"class Solution(object):
    def canThreePartsEqualSum(self, A):
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts >= 3",O(n)
"n = int(input())
l = tuple(map(int,input().split()))
r = tuple(map(int,input().split()))
s = [ (i,sum(v)) for i,(v) in enumerate(zip(l,r)) ]
ss = sorted(s, key= lambda a:a[1] )

candies = [0]*n
for p in ss:
    candies[p[0]] = n-p[1]

ll = [0]
for i in range(1,n):
    ll.append(sum([1 for c in candies[:i] if c > candies[i]]))

rr = [0]
for i in range(n-2,-1,-1):
    rr.append(sum([1 for c in candies[i:] if c > candies[i]]))

for i in range(n):
    if ll[i] != l[i]:
        print(""NO"")
        break
    if rr[n-1-i] != r[i]:
        print(""NO"")
        break
    if i == n-1:
        print(""YES"")
        print(' '.join(map(str,candies)))
",O(nlogn)
"class Solution(object):
    def possibleStringCount(self, word):
        return len(word)-sum(word[i] != word[i+1] for i in range(len(word)-1))",O(n)
"import sys,math

def read_int():
	return int(sys.stdin.readline().strip())

def read_int_list():
	return list(map(int,sys.stdin.readline().strip().split()))

def read_string():
	return sys.stdin.readline().strip()

def read_string_list(delim="" ""):
	return sys.stdin.readline().strip().split(delim)

k = read_int()

base_digit_number = 1; expo = 0

while k >= base_digit_number:
	base_digit_number += 9*(expo+1)*(10**expo)
	expo += 1

base_digit_number -= 9*(expo)*(10**(expo-1))

ans_number = (k - base_digit_number)//expo + 10**(expo-1)

ans_digit = str(ans_number)[(k - base_digit_number)%expo]

print(ans_digit)
",O(logn)
"class Solution(object):
    def stoneGameIII(self, stoneValue):
        dp = [float(""-inf"")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(range(len(stoneValue))):
            max_dp, curr = float(""-inf""), 0
            for j in range(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return [""Tie"", ""Alice"", ""Bob""][cmp(dp[0], 0)]",O(n)
"

class Solution(object):
    def triangleType(self, nums):
        nums.sort()
        a, b, c = nums
        if a+b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c:
            return ""isosceles""
        return ""scalene""
",O(1)
"class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 < len(word1) and arr_idx2 < len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)",O(n)
"class Solution(object):
    def minimizeXor(self, num1, num2):
        def popcount(x):
            return bin(x)[2:].count('1')
        
        cnt1, cnt2 = popcount(num1), popcount(num2)
        result = num1
        cnt = abs(cnt1-cnt2)
        expect = 1 if cnt1 >= cnt2 else 0
        i = 0
        while cnt:
            if ((num1>>i)&1) == expect:
                cnt -= 1
                result ^= 1<<i
            i += 1
        return result",O(logn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n + 1)]

        for i in range(n - 1, -1, -1):
            for buying in [True, False]:
                if buying:
                    buy = dp[i + 1][False] - prices[i] if i + 1 < n else -prices[i]
                    cooldown = dp[i + 1][True] if i + 1 < n else 0
                    dp[i][1] = max(buy, cooldown)
                else:
                    sell = dp[i + 2][True] + prices[i] if i + 2 < n else prices[i]
                    cooldown = dp[i + 1][False] if i + 1 < n else 0
                    dp[i][0] = max(sell, cooldown)

        return dp[0][1]
",O(n)
"n, = map(int,input().split())
arr = set(map(int,input().split()))
print(len(arr)-(0 in arr))
",O(n)
"import math
n = int(input())

if n>0:
    print(n)
else:
    l = list(str(n))

    last = l[0:len(l)-1]
    second = l[0:len(l)-2]
    second+=l[-1]
    lR = """".join(last)
    sR = """".join(second)

    print(max(eval(lR),eval(sR)))
",O(1)
"class BIT:

    __all__ = ['add', 'sumrange', 'lower_left']

    def __init__(self, maxsize=10**7):
        assert (maxsize > 0)

        self._n = maxsize+1
        self._bitdata = [0]*(maxsize+1)

    def add(self, i, x):

        assert(0 <= i < self._n)

        pos = i+1
        while pos < self._n:
            self._bitdata[pos] += x
            pos += pos&(-pos)

    def running_total(self, i):

        assert (-1<= i < self._n)

        if i == -1:
            return 0
        returnval = 0
        pos = i+1
        while pos:
            returnval += self._bitdata[pos]
            pos -= pos & (-pos)
        return returnval

    def sumrange(self, lo=0, hi=None):

        if lo < 0:
            raise ValueError('lo must be non-negative')
        if hi is None:
            hi = self._n

        return self.running_total(hi) - self.running_total(lo-1)

    def lower_left(self, total):

        if total < 0:
            return -1
        pos = 0
        k = 1<<(self._n.bit_length()-1)
        while k > 0:
            if pos+k < self._n and self._bitdata[pos+k] < total:
                total -= self._bitdata[pos+k]
                pos += k
            k //= 2
        return pos
def tentousu(lis):
  bit = BIT()
  ans = 0
  for i in range(len(lis)):
      bit.add(lis[i], 1)
      ans += i + 1 - bit.running_total(lis[i])
  return ans
N=int(input())
L=list(map(int,input().split()))
a=tentousu(L)
a%=2
if N%2==0 and a%2==0:
  print(""Petr"")
if N%2==0 and a%2==1:
  print(""Um_nik"")
if N%2==1 and a%2==0:
  print(""Um_nik"")
if N%2==1 and a%2==1:
  print(""Petr"")
",O(nlogn)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n, m = ria()
ar = ria()
arc = []
art = []
res = []
for n, i in enumerate(ria()):
    if i == 1:
        art.append(ar[n])
        res.append(0)
    else:
        arc.append(ar[n])
nt = 0
for i in arc:
    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):
        nt += 1
    res[nt] += 1

for i in res:
    print(i,end= ' ')",O(nlogn)
"class Solution(object):
    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):
        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefix = [0]*(len(NUMS)+1)
        for i in range(len(NUMS)):
            prefix[i+1] += prefix[i]+NUMS[i]
    
        def day(date):
            return prefix[int(date[:2])-1]+int(date[3:])

        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)",O(1)
"
class Solution(object):
    def isPalindrome(self, head):
        reverse, fast = None, head
        while fast and fast.__next__:
            fast = fast.next.__next__
            head.next, reverse, head = reverse, head, head.next

        tail = head.__next__ if fast else head

        is_palindrome = True
        while reverse:
            is_palindrome = is_palindrome and reverse.val == tail.val
            reverse.next, head, reverse = head, reverse, reverse.next
            tail = tail.__next__

        return is_palindrome

",O(n)
"class Solution(object):
    def semiOrderedPermutation(self, nums):
        i, j = nums.index(1), nums.index(len(nums))
        return i+((len(nums)-1)-j)-int(i > j)",O(n)
"class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0",O(n)
"class Solution(object):
    def countGoodNumbers(self, n):
        def powmod(a, b, mod):
            a %= mod
            result = 1
            while b:
                if b&1:
                    result = (result*a)%mod
                a = (a*a)%mod
                b >>= 1
            return result

        MOD = 10**9 + 7
        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD",O(logn)
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    n,m=lst()
    a=lst()
    a=[0]+a+[m]
    n=len(a)
    suf=[0]*n
    suf[n-2]=abs(a[-2]-a[-1])
    for i in range(n-3, -1, -1):
        suf[i]=a[i+1]-a[i]+suf[i+2]
    ans=suf[0]
    cost=0
    for i in range(1, n):
        if i&1:
            v=a[i]-1-a[i-1]
            if v!=0:ans=max(ans, cost+v+suf[i])
            cost+=a[i]-a[i-1]
        else:
            v=a[i-1]+1
            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))
    print(ans)",O(n)
"n = int(input())
x, y = list(map(int, input().split()))
d0 = max(x - 1, y - 1)
d1 = max(n - x, n - y)
print('White' if d0 <= d1 else 'Black')
",O(1)
"n,m=[int(x) for x in input().split()]
s=[]
for i in range(n):
    s.append(input())
mapp=[[False]*m for i in range(n)]

rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))

def gene(x,y,p):
    cx=x-rnd[p][0]
    cy=y-rnd[p][1]
    ans=[]
    for i in range(8):
        ans.append((cx+rnd[i][0],cy+rnd[i][1]))
    return ans
def judge(ps):
    for x,y in ps:
        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='
            continue
        else:
            return False
    return True
def dye(ps):
    global mapp
    for x,y in ps:
        mapp[x][y]=True
def check(x,y):
    for i in range(8):
        r=gene(x,y,i)
        if judge(r):
            dye(r)
            return True
    return False
for i in range(n):
    for j in range(m):
        if s[i][j]=='
            if check(i,j):
                continue
            else:
                print('NO')
                quit()
print('YES')",O(n ^ 2)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

L, R = map(int, input().split())

for i in range(64, -1, -1):
    if L & (1 << i) != R & (1 << i):
        print((1 << (i+1)) - 1)
        exit(0)
print(0)",O(logn)
"import sys
import threading
inp = sys.stdin.buffer.readline
input = lambda: sys.stdin.readline().rstrip()
def I(): return list(map(int,inp().split()))
def main():
    n,=I() ; vis=[0]*n ; st=[0]*n
    if n==1:
        print(1)
        exit(0)
    def dfs(g,e):
        if vis[e]==1: return
        else:
            vis[e]=1
            for i in g[e]:
                dfs(g,i)
            if len(g[e])==1 and e!=0: st[e]+=1
            for i in g[e]:
                st[e]+=st[i]
    a=[int(i)-1 for i in input().split()]
    g=[[] for i in range(n)]
    for i in range(n-1):
        g[i+1].append(a[i])
        g[a[i]].append(i+1)
    dfs(g,0)
    st.sort()
    print(*st)
sys.setrecursionlimit(2097152)
threading.stack_size(134217728)
main_thread = threading.Thread(target=main)
main_thread.start()
main_thread.join()",O(n ^ 2)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

s = STR()

if len(set(s)) == len(s):
    print('0')
    exit(0)

d = []

for i in range(len(s)):
    for j in range(i+1 , len(s)):
        x = ''
        for k in range(i , j+1):
            x += s[k]

        d.append(x)

v = {}
for i in range(len(s)):
    if s[i] not in v :
        v[s[i]] = 1
    else:
        v[s[i]] +=1

for i in d :
    if i not in v :
        v[i] = 1
    else:
        v[i]+=1

mx = -1
ans = ''

for i in v :
    if v[i] >= 2 :
        if len(i) > mx :
            mx = max(mx , len(i))

print(mx)
",O(n ^ 3)
"class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort()
        prefix = sum(nums)
        for i in reversed(range(2, len(nums))):
            prefix -= nums[i]
            if prefix > nums[i]:
                return prefix+nums[i]
        return -1",O(nlogn)
"from collections import defaultdict
from sys import stdout,stdin
n,m,K=map(int,input().split())
dp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]
l1=[list(map(int,stdin.readline().split())) for i in range(n)]
l2=[list(map(int,stdin.readline().split())) for i in range(n-1)]
if K%2:
    for i in range(n):
        for j in range(m):
            print('-1',end=' ')
        print()
else:
    for k in range(1,K//2+1):
     for i in range(n):
        for j in range(m):
                res=100000000
                if i-1>=0 and j>=0:
                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])
                if i+1<n and j>=0:
                     res=min(res,l2[i][j]+dp[i+1][j][k-1])
                if 0<=i and j+1<m:
                     res=min(res,l1[i][j]+dp[i][j+1][k-1])
                if 0<=i and j-1>=0:
                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])
                dp[i][j][k]=res
    for i in range(n):
        for j in range(m):
            stdout.write(str(2*dp[i][j][K//2])+' ')
        stdout.write('\n')",O(n ^ 3)
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",O(nlogn)
"n, m = (int(x) for x in input().split())
boys_out = sorted([int(x) for x in input().split()], reverse=True)
girls_in = sorted([int(x) for x in input().split()])
max_boy = max(boys_out)
ans = 0
for boy in boys_out:
    ans += boy * m

count = 0
i = 0
for girl in girls_in:
    if girl < max_boy:
        print(-1)
        quit()

    if girl > max_boy:
        if count == m - 1:
            count = 0
            i += 1
        if i >= n:
            print(-1)
            quit()
        ans += girl - boys_out[i]
        count += 1

print(ans)",O(nlogn)
"class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0",O(n ^ 2)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
b = []
for i in range(n - 1):
    b.append(a[i + 1] - a[i])
b.sort()
print(sum(b[:len(b) - k + 1]))",O(nlogn)
"x, k = [int(a) for a in input().strip().split()]

def binpow(x, k, mod):
    res = 1
    while k > 0:
        if k & 1:
            res  = ( res * x ) % mod
        x = ( x * x) % mod
        k >>= 1
    return res
if x == 0:
    print(0)
    exit()

mod = int(1e9 + 7)
k2 = binpow(2, k, mod)
res = ( k2 * (2 * x - 1) + 1) % mod

res %= mod

print(int(res))",O(logn)
"n = int(input())
ai = list(map(int,input().split()))
ai.sort()
num = 0
num2 = 0
for i in range(1,n):
    if ai[i-1] == ai[i]:
        num += 1
        num2 = i
if num == 0:
    num3 = sum(ai)
    num4 = n * (n-1) // 2
    ans = (num3 - num4) % 2
    if ans == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")
elif num == 1:
    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:
        print(""cslnb"")
    else:
        num3 = sum(ai)
        num4 = n * (n-1) // 2
        ans = (num3 - num4) % 2
        if ans == 1:
            print(""sjfnb"")
        else:
            print(""cslnb"")
else:
    print(""cslnb"")
",O(nlogn)
"class Solution(object):
    def truncateSentence(self, s, k):
        for i in range(len(s)):
            if s[i] == ' ':
                k -= 1
                if not k:
                    return s[:i]
        return s",O(n)
"class Solution2(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[pos] = nums[i]
                pos += 1

        for i in range(pos, len(nums)):
            nums[i] = 0",O(n)
"m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))

ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0
        for j in range(n):
            if a[i][j]>=tang:

                temp+=(1<<j)

        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1

        tocheck = mask ^ temp

        if tocheck in dic:
            return dic[tocheck],i,True

    return -1,-1,False

while ina<mo-1:

    tang=(ina+mo)//2

    temppos1,temppos2,status=check(tang)

    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
",np
"import sys, heapq

def binary(num):
    left = 0
    right = n
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < num:
            left = mid + 1
        elif arr[mid] > num:
            right = mid
        else:
            return True
    return False

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
cnt = dict().fromkeys(set(arr), 0)
ans = 0
for i in arr:
    cnt[i] += 1
for i in range(n):
    now = arr[i]
    can = False
    for j in range(31):
        target = pow(2, j) - now
        if binary(target):
            if target == now:
                if cnt[now] >= 2:
                    can = True
                    break
            else:
                can = True
                break
    if not can:
        ans += 1
print(ans)",O(nlogn)
"class Solution(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        idx = l = 0
        for i in range(1, len(word)):
            if word[i] == word[idx+l]:
                l += 1
            elif word[i] < word[idx+l]:
                l = 0
            elif word[i] > word[idx+l]:
                if word[i-l] >= word[i]:
                    idx = i-l
                else:
                    idx = i
                l = 0
        return word[idx:len(word)-max((numFriends-1)-idx, 0)]",O(n)
"class Solution(object):
    def lenLongestFibSubseq(self, A):
        lookup = set(A)
        result = 2
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                x, y, l = A[i], A[j], 2
                while x+y in lookup:
                    x, y, l = y, x+y, l+1
                result = max(result, l)
        return result if result > 2 else 0",O(n ^ 2)
"import math

s = input()
t = input()
p1, p2, m1, m2, q = 0, 0, 0, 0, 0
for i in s:
 if i == '+':
  p1 += 1
 else:
  m1 += 1
for i in t:
 if i == '+':
  p2 += 1
 elif i == '-':
  m2 += 1
 else:
  q += 1
dp, dm = p1 - p2, m1 - m2
if dp < 0 or dm < 0:
 print(0.0)
else:
 ans = (math.factorial(q) / (math.factorial(dp) * math.factorial(dm))) / math.pow(2, q)
 print(ans)",np
"class Solution(object):
    def countTime(self, time):
        result = 1
        if time[4] == '?':
            result *= 10
        if time[3] == '?':
            result *= 6
        if time[1] == time[0] == '?':
            result *= 24
        elif time[1] == '?':
            result *= 10 if time[0] != '2' else 4
        elif time[0] == '?':
            result *= 3 if time[1] < '4' else 2
        return result",O(1)
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n,m=read()
a=[]
for i in range(n):
    a.append(read())
sm=0
cur=0
for x, y in a:
    sm+=y
    cur+=x
if sm>m:
    print(-1)
    quit()
cnt=0
a.sort(key=lambda x: -x[0]+x[1])
i = 0
while cur>m and i < n:
    cur -= a[i][0]-a[i][1]
    cnt += 1
    i += 1
print(cnt)",O(nlogn)
"n = int(input())
x = 1
n -= 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = (8 + 2) ** (x - 1)
a += n // x
print(str(a)[n % x])",O(logn)
"class Solution(object):
    def isDecomposable(self, s):
        if len(s)%3 != 2:
            return False
        for left in range(0, len(s), 3):
            if any(s[i] != s[i-1] for i in range(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(range(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(range(max(right-2, left), right))):
                break
        return right-left == 1",O(n)
"n,k=map(int,input().split())
mod=998244353
dp=[[0,0,0,0] for _ in range(k+1)]

dp[1][0]=dp[1][3]=1
if k>1:
    dp[2][2]=dp[2][1]=1
for x in range(1,n):
    g=[[0,0,0,0] for _ in range(k+1)]

    g[1][0]=g[1][3]=1
    for i in range(2,k+1):
        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod
        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod
    dp=g
print(sum(dp[-1])%mod)",np
"a, b = [int(x) for x in input().split(' ')]
idx = 0
if(a == b):
    print(0)
else:
    for i in range(63,-1,-1):
        set1 = (a >> i) & 1
        set2 = (b >> i) & 1
        if(set1!=set2):
            idx = i
            break
    print((1<<(idx+1))-1)",O(logn)
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
flag = 0
for i in range(n-1):
	if(a[i] == a[i+1]):
		if(flag == 1):
			flag = 2
			break
		flag = 1
		index = i
		if(i+2<n and a[i+1] == a[i+2]):
			flag = 2
			break
		elif(i>0 and a[i-1] == a[i]-1):
			flag = 2
			break
if(flag == 2):
	print(""cslnb"")
elif(flag ==1 and a[index] ==0):
	print(""cslnb"")
else:
	moves=0
	for i in range(n):
		if(a[i] == i):
			continue
		elif(a[i]<i):
			continue
		else:
			moves += (a[i] - i)
	if(moves%2 == 0):
		print(""cslnb"")
	else:
		print(""sjfnb"")",O(nlogn)
"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closeToOpen = { "")"" : ""("", ""]"" : ""["", ""}"" : ""{"" }

        for c in s:
            if c in closeToOpen:
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(c)

        return True if not stack else False
",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def solve():
    n,k = li()
    p = li()
    groups = [-1]*256
    newar = [-1]*n
    for i in range(n):

        color  = p[i]
        j = color

        if groups[color]!=-1:
            newar[i]=groups[color]
            continue

        while(j>0) :
            if groups[j]!=-1:
                break
            if color-j+1==k:
                break
            j-=1

        if groups[j]==-1:
            for h in range(j,color+1):
                groups[h]=j
            newar[i]=groups[color]
            continue
        if color-j<k:
            alreadySize = j-groups[j]+1

            if alreadySize+color-j<=k:
                for h in range(j+1,color+1):
                    groups[h]=groups[h-1]
                newar[i]=groups[color]
                continue
            else:
                for h in range(j+1,color+1):
                    groups[h]=j+1
                newar[i]=groups[color]
                continue
        else:
            for h in range(j+1,color+1):
                groups[h]=j+1
            newar[i]=groups[color]
            continue
    print(*newar)

t = 1

for _ in range(t):
    solve()
",O(n ^ 2)
"def check(mid):
    added = n - mid
    total = ((added)*(added+1))//2
    return total - mid >= k

n,k = map(int,input().split())
low = 0
high = n-1
while low < high:
    mid = (low+high+1)//2

    if check(mid):
        low = mid
    else:
        high = mid - 1
print(low)",O(logn)
"import math

def c(k, n):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))

def main():
    sent = input()
    received = input()
    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))
    unrecognized = received.count('?')
    if difference > unrecognized:
        print(0)
        return

    k = (unrecognized - difference) // 2
    answer = c(k, unrecognized) * 0.5**unrecognized
    print(answer)

if __name__ == '__main__':
    main()
",np
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    starting=[]
    ending=[]
    points=[]
    for i in range(n):
        x,y=get_ints()
        starting.append(x)
        ending.append(y)
    ans=0
    start_count=collections.Counter(starting)
    end_count=collections.Counter(ending)
    s=starting.copy()
    s.sort()
    e=ending.copy()
    e.sort()
    maxim=max(starting)
    minim=min(ending)

    for i in range(n):
        if starting[i]==maxim:
            if start_count[maxim]>1:
                loc_max=maxim
            else:
                pos=bisect.bisect_left(s,maxim)
                loc_max=s[pos-1]
        else:
            loc_max=maxim
        if ending[i]==minim:
            if end_count[minim]>1:
                loc_min=minim
            else:
                pos=bisect.bisect_right(e,minim)
                loc_min=e[pos]
        else:
            loc_min=minim
        ans=max(ans,loc_min-loc_max)

    print(ans)",O(n)
"import math
import sys

n = int(input())
r = 0
t = 1
for i in range(n-1):
    r += t*2
    t += 2
print(r + t)
",O(n)
"for _ in range(int(input())):
    n = int(input())
    li = sorted(list(map(int, input().split())))
    print(min(li[n - 2] - 1, n - 2))
",O(nlogn)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res

d,n=map(int,input().split())
ans =power(2,n+1,1000000007);
ans1=power(2,n,1000000007);
if(d==0):
    print(0)
else:
    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",O(logn)
"import collections
import itertools


class Solution(object):
    def threeSumMulti(self, A, target):
        count = collections.Counter(A)
        result = 0
        for i, j in itertools.combinations_with_replacement(count, 2):
            k = target - i - j
            if i == j == k:
                result += count[i] * (count[i]-1) * (count[i]-2) // 6
            elif i == j != k:
                result += count[i] * (count[i]-1) // 2 * count[k]
            elif max(i, j) < k:
                result += count[i] * count[j] * count[k]
        return result % (10**9 + 7)",O(n ^ 2)
"l = list(sorted(list(map(int,input().split()))))
if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):
    print(""Yes"")
else:
    print(""No"")",O(1)
"import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def inp():
    return(int(input()))

def inlist():
    return(list(map(int, input().split())))

def instr():
    s = input()
    return(list(s[:len(s)]))

def invr():
    return(map(int, input().split()))

def getReamin(action, n):
    n -= action
    ans = (n*(n+1) // 2) - action
    return ans

def main():

    n, k = invr()
    l = 1
    r = n
    res = 0
    while l <= r:
        mid = l + (r-l)//2
        remain = getReamin(mid, n)
        if remain == k:
            res = mid
            break
        if remain > k:
            l = mid + 1
        else:
            r = mid - 1
    print(res)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"class Solution2(object):
    def getDirections(self, root, startValue, destValue):
        def dfs(node, val, path):
            if node.val == val:
                return True
            if node.left and dfs(node.left, val, path):
                path.append('L')
            elif node.right and dfs(node.right, val, path):
                path.append('R')
            return path

        src, dst = [], []
        dfs(root, startValue, src)
        dfs(root, destValue, dst)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)",O(n)
"class Solution2(object):
    def differenceOfSums(self, n, m):
        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",O(1)
"import math


class Solution(object):
    def arrangeCoins(self, n):
        return int((math.sqrt(8*n+1)-1) / 2)",O(1)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    students.dropna(subset=[""name""], inplace=True)
    return students
",O(n)
"def make_number(b,chars):
	if len(chars) == 0:
		return """"
	target = chars[0]
	for i in chars:
		if int(b[0]) <= int(i):
			break
		target = i
	chars.remove(target)
	return target + """".join(chars[::-1])

def find_number(b,chars):
	backup_chars = list(chars)
	if len(b) == 1:
		return chars[0]
	elif b[0] in chars:
		chars.remove(b[0])
		num = b[0] + find_number(b[1:],chars)
		if min(num,b) == b and b != num:
			return make_number(b,backup_chars)
		else:
			return num

	else:
		return make_number(b,backup_chars)

a,b = str(input()), str(input())
chars = [i for i in a]
chars.sort()

if len(a) < len(b):
	print("""".join(chars[::-1]))
else:
	print(find_number(b,chars))",O(n ^ 3)
"class Solution(object):
    def maxProfit(self, prices):
        hold1, hold2 = float(""-inf""), float(""-inf"")
        release1, release2 = 0, 0
        for i in prices:
            hold1 = max(hold1, -i)
            release1 = max(release1, hold1 + i)
            hold2 = max(hold2, release1 - i)
            release2 = max(release2, hold2 + i)
        return release2",O(n)
"a,b,c,n=map(int,input().split())
if n-a-b+c>=1:
    if a<c or b<c:
        print(-1)
    else:
        print(n-a-b+c)
else:
    print(-1)",O(1)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8",O(n)
"class Solution(object):
    def longestWPI(self, hours):
        result, accu = 0, 0
        lookup = {}
        for i, h in enumerate(hours):
            accu = accu+1 if h > 8 else accu-1
            if accu > 0:
                result = i+1
            elif accu-1 in lookup:
                result = max(result, i-lookup[accu-1])
            lookup.setdefault(accu, i)
        return result",O(n)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"from collections import Counter

n = int(input())
a = Counter()
b = Counter()
for _ in range(n):
    a[input().strip()] += 1
for _ in range(n):
    b[input().strip()] += 1
ans = 0
for key in b:
    ans += max(b[key] - a[key], 0)

print(ans)",O(n)
"dat = ""硼磷碳磷溴硼氧磷氮硫氮氯氟溴硼磷碳硼硫碳氯溴硼磷碳硼硫溴硼磷碳硼氯碳硫溴硼磷碳硼氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟溴硼氧磷氮硫碳氯氟溴硼磷碳硫碳氯溴硼氧硼硫碳氯氮硼氯碳硫氮磷氟溴硼磷碳氯溴硼氧硼氯碳硫氮磷氟溴硼磷碳硫溴硼氧硼硫碳氯氮磷氟溴硼磷碳氧硫氮氯氟溴硼磷溴硼硫碳硼氯碳磷溴硼硫碳硼氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟溴硼氧磷碳氯氮硫氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟溴硼氧磷碳硫氮氯氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟溴硼磷碳硫碳氯氮硼硫碳硼氯碳磷溴硼磷碳硫碳氯氮硼硫碳硼氯溴硼磷碳氯氮硼硫碳硼氯碳磷溴硼磷碳氯氮硼硫碳硼氯溴硼磷碳硫氮硼硫碳硼氯碳磷溴硼磷碳硫氮硼硫碳硼氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷溴硼磷氮硼硫碳硼氯溴硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟溴硼硫碳氯溴硼氧硼氯碳磷氮硫氟溴硼磷碳硼氯碳硫氮硼硫碳磷碳氯溴硼磷碳硼氯氮硼硫碳磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯溴硼磷碳硼氯氮硼硫碳氯溴硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟氮硼磷碳硫碳氯溴硼氧磷碳硫氟碳氯溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯溴硼磷碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳氯氮磷氟氮硼硫碳磷碳氯溴硼磷碳硫氮硼硫碳氯溴硼磷氮硼硫碳氯溴硼硫碳磷溴硼氧硼磷碳氯氮硫氟溴硼硫碳氧磷氮氯氟溴硼硫溴硼磷碳硼氯碳硫氮硼硫碳磷溴硼磷碳硼氯氮硼硫碳磷溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟溴硼磷碳硼氯氮硼硫溴硼磷碳硫碳氯氮硼硫碳磷溴硼氧硼磷碳氯氮硫氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼硫碳磷溴硼磷碳氯氮硼硫溴硼磷碳硫氮硼硫碳磷溴硼氧硼磷碳硼硫碳氯氮磷碳硫氟溴硼磷碳氧硫氮氯氟氮硼硫碳磷溴硼磷氮硼硫溴硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷碳硫溴硼磷碳硼硫氮硼氯碳磷碳硫溴硼氯碳硫溴硼氧硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳硫溴硼磷碳硼硫氮硼氯碳硫溴硼磷碳硫碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳硫氮磷氟氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫溴硼磷碳氯氮硼氯碳硫溴硼磷氮硼氯碳硫溴硼氯碳磷溴硼氧硼磷碳硫氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷溴硼磷碳硼硫氮硼氯碳磷溴硼氯碳氧磷氮硫氟溴硼氯溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟溴硼磷碳硼硫氮硼氯溴硼磷碳硫碳氯氮硼氯碳磷溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷溴硼氧硼磷碳硼氯碳硫氮磷碳氯氟溴硼磷碳硫氮硼氯碳磷溴硼磷碳硫氮硼氯溴硼磷碳氧硫氮氯氟氮硼氯碳磷溴硼磷氮硼氯溴硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼氯碳磷碳硫溴硼硫碳磷碳氯氮硼氯碳硫溴硼氧硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳硫溴硼氧硼硫碳硼氯碳磷氮硫碳氯氟溴硼磷碳硫碳氯氮硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳硫溴硼磷氮硼硫碳氯氮硼氯碳硫溴硼氧硫碳氯氟碳磷溴硼氧硼磷碳硫氮氯氟氮硼硫碳磷溴硼硫碳氯氮硼氯碳磷溴硼硫氮硼氯碳磷溴硼硫碳磷氮硼氯碳硫溴硼硫碳磷氮硼氯溴硼硫碳氧磷氮氯氟氮硼氯碳硫溴硼硫氮硼氯溴硼氧硫碳氯氟碳磷氮硼磷碳硫碳氯溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷溴硼氧磷碳硫氟碳氯氮硼氯碳磷溴硼磷碳氯氮硼硫氮硼氯碳磷溴硼氧磷碳氯氟碳硫氮硼硫碳磷溴硼磷碳硫氮硼硫碳磷氮硼氯溴硼磷碳硫氮硼硫碳氯氮硼氯碳磷溴硼氧磷碳硫碳氯氟溴磷碳硫碳氯溴硼氧磷氮硫氮氯氟氮磷碳硫碳氯溴硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼磷碳硼硫氮磷碳硫碳氯溴硼磷碳硼氯碳硫氮磷碳硫碳氯溴硼磷碳硼氯氮磷碳硫碳氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟氮磷碳硫碳氯溴硼氧磷氮硫碳氯氟氮磷碳硫碳氯溴硫碳氯溴硼氧磷氮硫氮氯氟氮硫碳氯溴硼磷碳氯氮硫碳氯溴硼磷碳硼硫氮硫碳氯溴硼磷碳硫氮硫碳氯溴硼磷碳硼氯氮硫碳氯溴硼磷碳氧硫氮氯氟氮硫碳氯溴硼磷氮硫碳氯溴硼硫碳硼氯碳磷氮磷碳硫碳氯溴硼硫碳硼氯氮磷碳硫碳氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟氮磷碳硫碳氯溴硼硫碳硼氯碳磷氮硫碳氯溴硼硫碳硼氯氮硫碳氯溴硼磷碳氯氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳氯氮硫氟氮硫碳氯溴硼磷碳硫氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳硫氮氯氟氮硫碳氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷氮硫碳氯溴硼磷氮硼硫碳硼氯氮硫碳氯溴磷碳氯溴硼氧磷氮硫氮氯氟氮磷碳氯溴硼硫碳氯氮磷碳氯溴硼磷碳硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮磷碳氯溴硼磷碳硼氯氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯氮磷碳氯溴硼氧磷氮硫碳氯氟氮磷碳氯溴氧磷氮硫氟碳氯溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯溴氯溴硼磷碳硼硫氮氯溴硼磷碳硫氮磷碳氯溴硼氧硼硫碳氯氮磷氟氮磷碳氯溴硼磷碳硫氮氯溴硼磷氮氯溴硼硫碳磷氮磷碳氯溴硼硫碳硼氯氮磷碳氯溴硼硫碳氧磷氮氯氟氮磷碳氯溴硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳磷氮磷碳氯溴硼氧磷碳硫氮氯氟氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟氮磷碳氯溴硼磷碳硼氯氮硼硫氮磷碳氯溴硼硫碳磷氮硫碳氯溴硼氧硼磷碳氯氮硫氟氮硫碳氯溴硼硫碳磷氮氯溴硼硫氮氯溴硼磷碳硫氮硼硫碳磷氮磷碳氯溴硼磷碳硼氯氮硼硫碳磷氮硫碳氯溴硼磷碳硫氮硼硫碳磷氮氯溴硼磷氮硼硫氮氯溴磷碳硫溴硼氧磷氮硫氮氯氟氮磷碳硫溴硼磷碳硼硫碳氯氮磷碳硫溴硼磷碳硼硫氮磷碳硫溴硼氯碳硫氮磷碳硫溴硼磷碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼氧磷氮硫碳氯氟氮磷碳硫溴氧磷氮氯氟碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮氯氟碳硫溴硼磷碳氯氮磷碳硫溴硼氧硼氯碳硫氮磷氟氮磷碳硫溴硫溴硼磷碳硼氯氮硫溴硼磷碳氯氮硫溴硼磷氮硫溴硼氯碳磷氮磷碳硫溴硼硫碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳磷氮磷碳硫溴硼氧磷碳氯氮硫氟氮磷碳硫溴硼氯碳氧磷氮硫氟氮磷碳硫溴硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟氮磷碳硫溴硼磷碳硼硫氮硼氯氮磷碳硫溴硼氯碳磷氮硫碳氯溴硼氧硼磷碳硫氮氯氟氮硫碳氯溴硼磷碳氯氮硼氯碳磷氮磷碳硫溴硼磷碳硼硫氮硼氯碳磷氮硫碳氯溴硼氯碳磷氮硫溴硼氯氮硫溴硼磷碳氯氮硼氯碳磷氮硫溴硼磷氮硼氯氮硫溴氧硫氮氯氟碳磷溴硼氧磷氮硫氮氯氟氮氧硫氮氯氟碳磷溴硼硫碳氯氮磷碳硫溴硼氧硼氯碳磷氮硫氟氮磷碳硫溴硼氯碳硫氮磷碳氯溴硼氧硼硫碳磷氮氯氟氮磷碳氯溴硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼磷碳硼硫氮硼氯碳硫氮磷碳氯溴氧磷氮硫氟碳氯氮磷碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯氮磷碳硫溴磷碳硫氮氯溴硼磷碳硼硫氮磷碳硫氮氯溴磷碳氯氮硫溴硼磷碳硼氯氮磷碳氯氮硫溴硫氮氯溴硼磷氮硫氮氯溴磷溴硼硫碳硼氯氮磷溴硼硫碳氯氮磷溴硼硫氮磷溴硼氯碳硫氮磷溴硼氯氮磷溴硼硫碳氯氮硼氯碳硫氮磷溴硼硫氮硼氯氮磷溴磷氮硫碳氯溴硼硫碳硼氯氮磷氮硫碳氯溴磷氮氯溴硼硫氮磷氮氯溴磷氮硫溴硼氯氮磷氮硫溴磷氮硫氮氯溴硼磷氮磷"".split('溴')
d1, d2 = ""硼碳氮氧氟磷硫氯"", ""!&|()xyz""
for i in range(int(input())):
	s = dat[eval(""0b"" + ''.join(list(reversed(input()))))]
	for i in range(8): s = s.replace(d1[i], d2[i])
	print(s)
",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
a.sort()
lose=False
pair=False
for i in range(n-1):
    if a[i]==a[i+1]==0:
        lose=True
    if a[i]==a[i+1]:
        if pair:
            lose=True
        pair=True
        if i>=1:
            if a[i]==a[i-1]+1:
                lose=True
if lose:
    print(""cslnb"")
else:
    eventual=n*(n-1)//2
    curr=sum(a)
    if (curr-eventual)%2==0:
        print(""cslnb"")
    else:
        print(""sjfnb"")",O(nlogn)
"def get_input_list():
	return list(map(int, input().split()))

n = int(input())
l = get_input_list()
r = get_input_list()

a = [0 for _ in range(n)]
m = []
m_ = []
for i in range(n):
	m.append(l[i] + r[i])
	m_.append(l[i] + r[i])
m.sort()
ma = m[-1] + 1

for i in range(n):
	a[i] = ma - m_[i]

l_ = []
r_ = []
for i in range(n):
	c = 0
	d = 0
	for j in range(i+1):
		if a[j] > a[i]:
			c += 1
	for j in range(i,n):
		if a[j] > a[i]:
			d += 1
	l_.append(c)
	r_.append(d)
res = True
for i in range(n):
	if l[i] != l_[i] or r[i] != r_[i]:
		res = False
		break
if res:
	print(""YES"")
	for i in range(n):
		a[i] = str(a[i])
	print("" "".join(a))
else:
	print(""NO"")",O(n ^ 2)
"def socket(n,m,k,arr):
    arr.sort(reverse=True)
    devices=m
    curr_socket=0
    e_socket=k
    i=0
    t_socket=0
    count=0
    while i<n:
        if e_socket>=devices:
            return 0
        if curr_socket==0:
            curr_socket+=arr[i]
            count+=1
            e_socket-=1
            t_socket=curr_socket+e_socket
        else:
            if t_socket>=devices:
                return count
            else:
                curr_socket+=arr[i]-1
                count+=1
                t_socket=curr_socket+e_socket
        i+=1
    if t_socket>=devices:
        return count
    return -1

n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
print(socket(n,m,k,arr))",O(nlogn)
"class Solution(object):
    def minimumBuckets(self, street):
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 < len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result",O(n)
"class Solution2(object):
    def incremovableSubarrayCount(self, nums):
        return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and
                   all(nums[i] < nums[i+1] for i in range(left-1)) and
                   all(nums[i] < nums[i+1] for i in range(right+1, len(nums)-1))
                   for left in range(len(nums)) for right in range(left, len(nums)))",O(n ^ 3)
"def get_kth_digit(i):
    if i < 10:
        return i

    batch = 9
    count = 9
    width = 1

    while i >  10 * batch * (width + 1) + count:
        batch *= 10
        width += 1
        count += batch * width

    k = i - count - 1
    num = 10 ** width + k// (width + 1)
    return str(num)[k % (width + 1)]

def main():
    i = int(input())

    print(get_kth_digit(i))

if __name__ == '__main__':
    main()",O(logn)
"import sys
n=int(input())
s=input()
s+=s
h=0
for i in range(n):
	if s[i]=='H':
		h+=1
ans=h
for i in range(n):
	c=0
	for j in range(i,i+h):
		if s[j]=='T':
			c+=1
	ans=min(ans,c)
print(ans)
",O(n)
"from itertools import combinations
n, mn, mx, diff = map(int, input().split())
arr = list(map(int, input().split()))
print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))
",np
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

figures=[
  [(0,0),(0,1),(1,0)],
  [(0,0),(0,1),(1,1)],
  [(0,1),(1,0),(1,1)],
  [(0,0),(1,0),(1,1)],
]

board=[]
for _ in range(2):
  s=rl()
  board.append(list(s))

n=len(board[0])

ans=0
for j in range(n-1):
  for fig in figures:
    ok=1
    for fi,fj in fig:
      if board[fi][j+fj]=='X':
        ok=0
        break
    if not ok:
      continue
    ans+=1
    for fi,fj in fig:
      board[fi][j+fj]='X'
    break

print(ans)
",O(1)
"def main():
    n = int(input())
    s = input()

    u_set = set()
    for i in s:
        u_set.add(i)
    u_cnt = len(u_set)

    d = {}
    j = 0
    ans = 10**9
    for i in range(n):
        while len(d.keys()) < u_cnt and j < n:
            d[s[j]] = d.get(s[j], 0) + 1
            j += 1

        if len(d.keys()) == u_cnt:
            if j - i < ans:
                ans = j - i
        elif j == n:
            break

        d[s[i]] -= 1
        if d[s[i]] == 0:
            del d[s[i]]

    print(ans)

if __name__ == '__main__':
    main()
",O(n)
"n, k = map(int, input().split())
l = list(map(int, input().split()))

o = 2
for i in range(n):
    if i+1 == n:
        break

    d = abs(l[i] - l[i+1]) / k
    if d ==  2:
        o += 1
    elif d > 2:
        o += 2

print(o)",O(n)
"class Solution3(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        lookup = SortedDict()
        for right in range(len(nums)):
            lookup[nums[right]] = right
            to_del = []
            for x, i in list(lookup.items()):
                if nums[right]-x <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x)
            for x, i in reversed(list(lookup.items())):
                if x-nums[right] <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x) 
            for x in to_del:
                del lookup[x]
            result += right-left+1
        return result",O(nlogn)
"import itertools


class Solution(object):
    def compareVersion(self, version1, version2):
        n1, n2 = len(version1), len(version2)
        i, j = 0, 0
        while i < n1 or j < n2:
            v1, v2 = 0, 0
            while i < n1 and version1[i] != '.':
                v1 = v1 * 10 + int(version1[i])
                i += 1
            while j < n2 and version2[j] != '.':
                v2 = v2 * 10 + int(version2[j])
                j += 1
            if v1 != v2:
                return 1 if v1 > v2 else -1
            i += 1
            j += 1

        return 0",O(n)
"n = int(input())
ans = []
mult = 1
while n > 3:
    ans += [mult]*(n-n//2)
    n //= 2
    mult *= 2
if n == 3:
    ans += [mult, mult, mult*3]
elif n == 2:
    ans += [mult, mult*2]
else:
    ans += [mult]
print(*ans)",O(logn)
"import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    if v in powers:
        continue

    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np
"n,m=map(int, input().split())
cols=[]
for i in range(n):
    cols.append(int(input()))
rows=[]
for i in range(m):
    k=list(map(int, input().split()))
    if k[0]==1:
        rows.append(k[1])
ans=n+m
cols.sort()
rows.sort()
cols.append(int(1e9))
j=0
rem=0

for i in cols:
    while j<len(rows) and rows[j]<i:
        j+=1
    ans=min(ans, len(rows)-j+rem)
    rem+=1
print(ans)
",O(nlogn)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
	G = defaultdict(list)

	def addEdge(a,b):
		G[a].append(b)

	def Kahn(N):
	    in_degree = [0]*(N+1)
	    for i in G.keys():
	        for j in G[i]:
	            in_degree[j] += 1
	    queue = deque()
	    for i in range(1,N+1):
	        if in_degree[i] == 0:
	            queue.append(i)
	    cnt =0
	    top_order = []
	    while queue:
	        u = queue.popleft()
	        top_order.append(u)
	        for i in G.get(u,[]):
	            in_degree[i] -= 1
	            if in_degree[i] == 0:
	                queue.append(i)
	        cnt += 1
	    if cnt != N:
	        Y(0);exit(0)
	    else:
	        Y(1);print(*top_order)

	n,m,k = aj()
	mark= {}
	for i in range(n):
		s = input()
		mark[s] = i+1

	B = []
	for i in range(2**k):
		f = bin(i)[2:]
		f = '0'*(k - len(f)) + f
		B.append(f)

	for i in range(m):
		s,mt = input().split("" "")
		mt = int(mt)
		st = set()
		for j in B:
			ss = ['']*k
			for l in range(k):
				if j[l] == '1':
					ss[l] = s[l]
				else:
					ss[l] = '_'
			ss = """".join(ss)
			if ss in mark:
				st.add(mark[ss])

		if mt not in st:
			Y(0);exit(0)
		st.discard(mt)
		for j in st:
			addEdge(mt,j)

	Kahn(n)

try:

	sys.stdin = open('input.txt', 'r')
	sys.stdout = open('output.txt', 'w')
except:
	pass

solve()",np
"n, k = map(int,input().split())
arr = list(map(int, input().split()))

def find_segment(arr, n, k):
  f = [0]*100001
  L = count = 0
  R = -1
  while R < n-1:
    R += 1
    if f[arr[R]] == 0:
      count += 1
    f[arr[R]] += 1
    while count == k:
      f[arr[L]] -= 1
      if f[arr[L]] == 0:
        print(L+1, R+1)
        return
      L += 1
  print(-1,-1)
find_segment(arr, n, k)",O(n)
"class Solution3(object):

    def __init__(self):
        self.stack = []

    def push(self, x):
        if self.stack:
            current_min = min(x, self.stack[-1][0])
            self.stack.append((current_min, x))
        else:
            self.stack.append((x, x))

    def pop(self):
        return self.stack.pop()[1]

    def top(self):
        return self.stack[-1][1]

    def getMin(self):
        return self.stack[-1][0]",O(1)
"import sys

def sum_range(l, r):
    if r < l: return 0
    if l == 0: return sum[r]
    return sum[r] - sum[l - 1]

n, k = map(int, input().split())

cards = input()

sum = [0] * n
sum[0] = 1 if cards[0] == '1' else 0
for i in range(1, n):
    sum[i] += sum[i - 1]
    if cards[i] == '1':
        sum[i] += 1

min0 = min1 = n
max0 = max1 = -1
for i in range(0, n):
    if cards[i] == '1':
        min1 = min(min1, i)
        max1 = i
    else:
        min0 = min(min0, i)
        max0 = i

toki = False
qual = True
for i in range(0, n - k + 1):
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n:
        toki = True
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0:
        toki = True

    prefix = sum_range(0, i - 1) == 0
    suffix = sum_range(i + k, n - 1) == 0
    if i > 0 and i + k < n and (prefix ^ suffix) == 0:
        qual = False
    if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k:
        qual = False

if toki == True:
    print('tokitsukaze')
elif qual == True:
    print('quailty')
else:
    print('once again')",O(n)
"n = int(input())
for i in range(n):
    k = int(input())
    s = list(map(int, input().split()))
    s.sort()
    print(min(k-2,s[k-2]-1))
",O(nlogn)
"class Solution(object):
    def isValid(self, word):
        VOWELS = ""aeiou""

        if len(word) < 3:
            return False
        vowel = consonant = False
        for x in word:
            if x.isalpha():
                if x.lower() in VOWELS:
                    vowel = True
                else:
                    consonant = True
            elif not x.isdigit():
                return False
        return vowel and consonant",O(n)
"class Solution(object):
    def countValidWords(self, sentence):
        result = token = hyphen = 0
        for i in range(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in ""!.,"" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result",O(n)
"n=int(input())
s=input()
if ""0"" in s:
    if ""1"" in s:
        print(""1""+""0""*s.count(""0""))
    else:
        print(""0"")
else:
    print(""1"")",O(n)
"from collections import defaultdict as dd, deque
n = int(input())
A = [int(x) for x in input().split()]
n = len(A)

C = dd(int)
for a in A:
    C[a] += 1

thedup = None
ndup = 0
screwed = False
for c in C:
    if C[c] > 2:
        screwed = True
    elif C[c] == 2:
        if c == 0:
            screwed = True
        thedup = c
        ndup += 1

import sys
if screwed or ndup > 1:
    print('cslnb')
else:
    if ndup == 1:
        if C[thedup-1] != 0:
            print('cslnb')
            sys.exit()

    target = sum(range(n))
    cur = sum(A)
    togo = cur - target

    if togo%2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"n = int(input())
a = sorted(map(int, input().split()))

ans = [0]*n
ans[0] = 1
f = ans[0] != a[0]
for i in range(1, n):
    ans[i] = a[i-1]
    if ans[i] != a[i]:
        f = True

m = 10**9
if not f:
    for i in range(n-1, -1, -1):
        if ans[i] < m:
            ans[i] += 1
            break

print(' '.join(map(str, ans)))",O(nlogn)
"def getIntList():
    return list(map(int, input().split()));
nbColumn, h=getIntList();
if (nbColumn-2)*2<h:
    print('NO')
else:
    print('YES')
    if h%2==0:
        print('.'*nbColumn);
        print('.'+'
        print('.'+'
        print('.'*nbColumn);
    else:
        print('.'*nbColumn);
        hFirst=min(h, nbColumn-2);
        countPoint=(nbColumn-hFirst)//2;
        print('.'*countPoint+'
        hSecond=(h-hFirst)//2;
        countPoint=nbColumn-2*hSecond-2;
        print('.'+'
        print('.'*nbColumn);",O(n)
"import sys
sys.setrecursionlimit(50000)
for _ in range(1):
    n,m,k = map(int,input().split())
    s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        d = [int(x) for x in input().split()]
        for j in range(m-1):
            s[i][j][1] = d[j]
            s[i][j+1][3] = d[j]
    for i in range(n-1):
        d = [int(x) for x in input().split()]
        for j in range(m):
            s[i][j][2] = d[j]
            s[i+1][j][0] = d[j]
    if k%2==1:
        for i in range(n):
            print(*[-1 for _ in range(m)])
        continue
    dp = [[[9999999 for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for q in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                cands = []
                if i > 0:
                    cands.append(dp[i-1][j][q-1] + s[i-1][j][2])
                if j > 0:
                    cands.append(dp[i][j-1][q-1] + s[i][j-1][1])
                if i < n - 1:
                    cands.append(dp[i+1][j][q-1] + s[i+1][j][0])
                if j < m - 1:
                    cands.append(dp[i][j+1][q-1] + s[i][j+1][3])
                dp[i][j][q] = min(cands)
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][k//2],end=' ')
        print()",O(n ^ 3)
"import math

n, k = input().split()
n = int(n)
k = int(k)

solfound = 0
m = 0
x0 = 0

if (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2 < n:
    m1 = (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2
else:
    m1 = (3+2*n-math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2

print(int(m1))
",O(logn)
"a, v = list(map(int, input().split("" "")))
l, d, w = list(map(int, input().split("" "")))

if(v <= w or w * w > 2 * a * d):
    if(v * v > 2 * a * l):
        print((2 * l / a) ** 0.5)
    else:
        print(l / v + v / 2 / a)
else:
    u = (w * w / 2 + a * d) ** 0.5
    if(u > v):
        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v
    else:
        m = (2 * u - w) / a

    if(v * v > 2 * a * (l - d + w * w / 2 / a)):
        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)
    else:
        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)",O(1)
"n = int(input())

if n>=2:
    print(25)
",O(1)
"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []

        def dfs(node, depth):
            if not node:
                return None
            if len(res) == depth:
                res.append([])

            res[depth].append(node.val)
            dfs(node.left, depth + 1)
            dfs(node.right, depth + 1)

        dfs(root, 0)
        return res
",O(n)
"class Solution(object):
    def minOperations(self, nums):
        def unique(nums):
            left = 0
            for right in range(1, len(nums)):
                if nums[left] != nums[right]:
                    left += 1
                    nums[left] = nums[right]
            return left

        def erase(nums, i):
            while len(nums) > i+1:
                nums.pop()

        n = len(nums)
        nums.sort()
        erase(nums, unique(nums))
        result = l = 0
        for i in range(len(nums)):
            if nums[i] <= nums[i-l]+n-1:
                l += 1
        return n-l",O(nlogn)
"n,m,k = map(int,input().split())
pi = list(map(int,input().split()))
num = 1
ans = 0
i = 0
while i < m:
    temp = (pi[i] - num) // k
    temp2 = i
    i += 1
    while i < m :
        if temp != (pi[i] - num) // k:
            break
        i += 1
    num += (i - temp2)
    ans += 1
print(ans)
",O(n)
"pw = [1, 4]
for i in range(2, 32):
    pw.append(pw[i - 1] * 4)
t = int(input())
for cas in range(t):
    n, k = map(int, input().split())
    last = 1
    path = 1
    ans = n
    i = 0
    while True:
        if((pw[i + 1] - 1) // 3 > k):
            ans -= i
            last = k - (pw[i] - 1) // 3
            break
        i = i + 1
        path *= 2
    sp = path * 2 - 1
    if((ans < 0) or ((ans == 0) and (last > 0))):
        print(""No"")
        continue
    sq = path * path - sp
    if (ans == 1) and (last > sq) and (last < sp):
        print(""No"")
        continue
    elif (ans == 1) and (last >= sp):
        ans = ans - 1
    print(""Yes"", ans)
",O(1)
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)

def get(x):
    return 1 << (ord(x) - ord('a'))

for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",np
"r,g,b=map(int,input().split())
rs=sorted(list(map(int,input().split())))
gs=sorted(list(map(int,input().split())))
bs=sorted(list(map(int,input().split())))
dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
ans=0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])
            if j>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])
            ans=max(ans,dp[i][j][k])
print(ans)
",O(n ^ 3)
"n=int(input())
w=[int(k) for k in input().split()]
m=int(input())
c=0
for i in range(n):
    for j in range(i+1, n):
        if w[i]>w[j]:
            c+=1
c%=2
for j in range(m):
    l, r=[int(k) for k in input().split()]
    x=r-l+1
    if x!=1 and (x*(x-1)//2)%2:
        c=not c
    if c:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"l,r=map(int,input().split())
lxr = l^r
msb = 0
while(lxr):
	msb+= 1
	lxr>>= 1
m = 0
t=1
while msb:
	m += t
	t <<= 1
	msb -= 1
print(m)
",O(logn)
"import itertools



class Solution(object):
    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):
        result = 0
        for hp, ex in zip(energy, experience):
            inc1 = max((hp+1)-initialEnergy, 0)
            inc2 = max((ex+1)-initialExperience, 0)
            result += inc1+inc2
            initialEnergy += inc1-hp
            initialExperience += inc2+ex
        return result",O(n)
"import sys, string

n, m = map(int, sys.stdin.readline().split())
print('4' * 2229)
print('5' * 2228 + '6')",O(1)
"import math

ln = [int(i) for i in input().split("" "")]

n = ln[0]
m = ln[1]
k = ln[2]

p = [int(i) for i in input().split("" "")]

i = 0
ct = 0
ops = 0
while i < len(p):
    nm = p[i] - ct
    if nm % k == 0:
        mnm = nm
    else:
        mnm = (nm // k) * k + k
    si = i
    while p[i] - ct <= mnm:
        i += 1
        if i >= len(p):
            break
    ct += i - si
    ops += 1
    if i >= len(p):
        break
print(ops)
",O(n)
"n, m, k, l = map(int, input().split())
if (k+l+m-1)//m*m > n:
    print(-1)
else:
    print((k+l+m-1)//m)
",O(1)
"def nine(p) :

    s=''
    for i in range(p) :
        s+='9'
    return int(s)
def prosh(p) :
    ans=0
    for i in range(1,p+1) :
        ans+=nine(i)*9
    return ans

n,k=map(int,input().split())
l=[0]*29
for i in range(19) :

    e=nine(19-i)

    l[i]=int(k/e)

    k-=l[i]*e

    if k<=0 :

        break
    if i==18  or k%e>prosh(19-i-1) :

        l[i]+=1
        break
otv=0
for i in range(19) :

    otv+=10**(19-i)*l[i]

print(max(n-otv+1,0))
",O(logn)
"x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",O(logn)
"n,k=list(map(int,input().split()))

if k%2==0:
    s="".""
    s=s+""
    s=s+"".""*(n-len(s))
    print(""YES"")
    print("".""*n)
    print(s)
    print(s)
    print("".""*n)

else:
    if k<=n-2:
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print(s)
        print("".""*n)
        print("".""*n)
    else:
        k=k-n+3
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print("".""+""
        s=list(s)
        s[n//2]="".""
        s="""".join(s)
        print(s)
        print("".""*n)",O(n)
"import io
import os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

endpoints = []

for x in range(n):
    p, w = map(int, input().split())
    endpoints.append([p-w, p+w])

endpoints.sort(key=lambda sublist: sublist[1])

res = 0

bottom = 10**18 * -1

for pt in range(len(endpoints)):
    if endpoints[pt][0] >= bottom:
        res += 1
        bottom = endpoints[pt][1]

print(res)
",O(nlogn)
"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

ans = float('inf')
for i in range(1, n-1):
    bef = aft = float('inf')
    for j in range(i):
        if a[j] < a[i]:
            bef = min(bef, b[j])
    for j in range(i, n):
        if a[i] < a[j]:
            aft = min(aft, b[j])
    ans = min(ans, b[i]+bef+aft)
print(-1 if ans > 10**9 else ans)
",O(n ^ 2)
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):
        if n == 1:
            return [0]

        neighbors = collections.defaultdict(set)
        for u, v in edges:
            neighbors[u].add(v)
            neighbors[v].add(u)

        pre_level, unvisited = [], set()
        for i in range(n):
            if len(neighbors[i]) == 1: 
                pre_level.append(i)
            unvisited.add(i)

        while len(unvisited) > 2:
            cur_level = []
            for u in pre_level:
                unvisited.remove(u)
                for v in neighbors[u]:
                    if v in unvisited:
                        neighbors[v].remove(u)
                        if len(neighbors[v]) == 1:
                            cur_level.append(v)
            pre_level = cur_level

        return list(unvisited)",O(n)
"class Solution2(object):
    def findWords(self, words):
        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
        single_row_words = []
        for word in words:
            for row in keyboard_rows:
                if all(letter in row for letter in word.lower()):
                    single_row_words.append(word)
        return single_row_words",O(n)
"import sys
from array import array

n = int(input())
edge = [list(map(int, input().split())) for _ in range(n)]
mod = 10**9 + 7

dp_f = [array('i', [-1])*n for _ in range(n)]
dp_g = [array('i', [-1])*n for _ in range(n)]

for i in range(n):
    dp_f[i][i] = dp_g[i][i] = 1
for i in range(n-1):
    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0

def f(l, r):
    if dp_f[l][r] != -1:
        return dp_f[l][r]

    dp_f[l][r] = g(l, r) if edge[l][r] else 0
    for m in range(l+1, r):
        if edge[l][m]:
            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod

    return dp_f[l][r]

def g(l, r):
    if dp_g[l][r] != -1:
        return dp_g[l][r]

    dp_g[l][r] = f(l+1, r)
    for m in range(l+1, r):
        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod

    return dp_g[l][r]

print(f(0, n-1))",O(n ^ 3)
"class Solution(object):
    def maxIceCream(self, costs, coins):
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins < 0:
                return i
        return len(costs)",O(nlogn)
"k, n, s, p = map(int, input().split())
print(((n + s - 1) // s * k + p - 1) // p)",O(1)
"def main():
    n, m, k = [int(v) for v in input().split()]
    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]

    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]
    for i in range(n):
        row = [int(v) for v in input().split()]
        for j in range(m-1):
            w[i][j+1][2] = row[j]
            w[i][j][3] = row[j]
    for i in range(n-1):
        row = [int(v) for v in input().split()]
        for j in range(m):
            w[i][j][1] = row[j]
            w[i+1][j][0] = row[j]
    if k % 2 == 1:
        for i in range(n):
            for j in range(m):
                print(-1, end="" "")
            print()
        return
    else:
        k //= 2
    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for d in range(1, k+1):
        for i in range(n):
            for j in range(m):
                for di, (dx, dy) in enumerate(dxy):
                    ii = i + dx
                    jj = j + dy
                    if 0 <= ii < n and 0 <= jj < m:
                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k] * 2, end="" "")
        print()

main()
",O(n ^ 3)
"import math
def binom(n, m):
    return math.factorial(n)//(math.factorial(m)*math.factorial(n-m))

correct = input()
received = input()
plus_correct = correct.count('+')
min_correct = correct.count('-')
pos_correct = plus_correct - min_correct
plus_received = received.count('+')
min_received = received.count('-')
unknown = received.count('?')
pos_received = plus_received - min_received
diff = abs(pos_correct - pos_received)
if (diff + unknown) % 2 != 0 or diff > unknown:
    prob = 0.0
else:
    m = (diff + unknown) // 2
    prob =  1.0 * binom(unknown, m) / (2 ** unknown)
print(prob)",np
"n = int(input())
a = list(map(int, input().split()))

s = a[0] % 998244353
y = a[0]
for x in a[1:]:

	s = s * 2 + y + x
	y = y * 2 + x

	s %= 998244353
	y %= 998244353

print(s)
",O(n)
"from math import log
from collections import deque
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
s.sort()
s1=deque(s)
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    aux=0
    for i in s1:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
            aux+=1
        else:
            break
    for i in range(aux):
        s1.popleft()

print(ans)
",O(nlogn)
"class Solution2(object):
    def diameterOfBinaryTree(self, root):
        def dfs(root):
            if not root: 
                return 0, 0
            left_d, left_h = dfs(root.left)
            right_d, right_h = dfs(root.right)
            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)
 
        return dfs(root)[0]",O(n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __str__(self):
        if self:
            return ""{}"".format(self.val)
        else:
            return None

class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                fast = head
                while fast is not slow:
                    fast, slow = fast.__next__, slow.__next__
                return fast
        return None

",O(n)
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1

    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])
",O(1)
"class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
left = 0
right = 10**9+1
ans = (0, 0)
while left < right:
    mid = (left + right) // 2
    masks = {}
    for i in range(n):
        mask = 0
        for j in a[i]:
            mask <<= 1
            if j >= mid:
                mask += 1
        masks[mask] = i
    ok = False
    for m1 in masks:
        for m2 in masks:
            if m1 | m2 == ((1 << m) - 1):
                ok = True
                ans = (masks[m1]+1, masks[m2]+1)
                break
        if ok:
            break
    if ok:
        left = mid+1
    else:
        right = mid
print(ans[0], ans[1])
",np
"class Solution(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""""]
        right = float(""inf"")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left > right:
                result.append("""")
            right = new_right
            result[-1] = s[left:right+1]
        return result",O(n)
"class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda pair: pair[0])
        output = [intervals[0]]

        for start, end in intervals:
            lastEnd = output[-1][1]

            if start <= lastEnd:
                output[-1][1] = max(lastEnd, end)
            else:
                output.append([start, end])
        return output
",O(nlogn)
"import sys
input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))
mod=998244353

INV=[None]*(n+1)
for i in range(1,n+1):
    INV[i]=pow(i,mod-2,mod)

BLA=P.count(-1)

if BLA==0 or BLA==1:
    ANS=0
else:
    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod
    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)

    ANS=LEFT*AVEP%mod

y=1
for i in range(BLA):
    y=y*(BLA-i)%mod

KOSUU=pow(y,mod-2,mod)
BLALIST=[1]*(n+1)
NONBLA=[]
BLANUM=[0]*n
for i in range(n):
    if P[i]!=-1:
        BLALIST[P[i]]=0
        BLANUM[i]=BLANUM[i-1]
        NONBLA.append(P[i])

    else:
        BLANUM[i]=BLANUM[i-1]+1

BLALIST[0]=0
for i in range(1,n+1):
    BLALIST[i]=BLALIST[i-1]+BLALIST[i]

if BLA!=0:
    for i in range(n):
        if P[i]!=-1:
            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod

A=NONBLA

if A==[]:
    print(ANS)
    sys.exit()

n=len(A)
MAXA=max(A)
MINA=min(A)

BIT=[0]*(MAXA-MINA+2)

for i in range(n):
    bitobje=A[i]-MINA+1

    x=bitobje
    while x!=0:
        ANS=(ANS-BIT[x])%mod
        x-=(x&(-x))

    x2=MAXA-MINA+1

    while x2!=0:

        ANS=(ANS+BIT[x2])%mod
        x2-=(x2&(-x2))

    y=bitobje
    while y<=MAXA-MINA+1:
        BIT[y]+=1
        y+=(y&(-y))

print(ANS)
",O(nlogn)
"from sys import stdin
a, b, c, n = map(int, stdin.readline().split())
if c > a or c > b:
    print(-1)
else:
    val = n - ((a - c) + (b - c)) - c
    print(val if val <= n and val > 0 else -1)",O(1)
"class Solution(object):
    def isPalindrome(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1
            if s[i].lower() != s[j].lower():
                return False
            i, j = i + 1, j - 1
        return True",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def removeNodes(self, head):
        stk = []
        while head:
            while stk and stk[-1].val < head.val:
                stk.pop()
            if stk:
                stk[-1].next = head
            stk.append(head)
            head = head.__next__
        return stk[0]",O(n)
"n,t=int(input()),1
while n>0:
        if n!=3:
            k=n//2+n%2
            print((str(t)+' ')*k,end= '')
            n-=k
            t*=2
        else:
            print(t,t,t*3)
            n=0
",O(1)
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    ans = max(ans, t+f)
print(ans)",O(n)
"import collections
from sortedcontainers import SortedList



class Solution(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        def update(accu, d):
            i = sl.bisect_left(idxs[x][-1])
            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD
            bit.add(idxs[x][-1], d*idxs[x][-1])
            return accu

        idxs = collections.defaultdict(list)
        for i in reversed(range(len(nums))):
            idxs[nums[i]].append(i)
        result = 0
        sl = SortedList(idxs[x][-1] for x in idxs)
        accu = (len(nums)*len(sl)**2) % MOD
        for i, x in enumerate(sl):
            accu = (accu-(2*i+1)*x) % MOD
        bit = BIT(len(nums))
        for x in sl:
            bit.add(x, x)
        for x in nums:
            result = (result+accu) % MOD 
            accu = update(accu, -1)
            del sl[0]
            idxs[x].pop()
            if not idxs[x]:
                continue
            sl.add(idxs[x][-1])
            accu = update(accu, +1)
        assert(accu == 0)
        return result",O(nlogn)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)",O(1)
"class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        q = deque([(root, float(""-inf""), float(""inf""))])

        while q:
            node, left, right = q.popleft()
            if not (left < node.val < right):
                return False
            if node.left:
                q.append((node.left, left, node.val))
            if node.right:
                q.append((node.right, node.val, right))

        return True
",O(n)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
vis=[0]*n
ans=0
for i in range(n):
    if(vis[i]==0):
        ans+=1
        x=l[i]
        for j in range(n):
            if l[j]%x==0:
                vis[j]=1
print(ans)",O(n ^ 2)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)

        for i in range(n):
            tank = gas[i] - cost[i]
            if tank < 0:
                continue
            j = (i + 1) % n
            while j != i:
                tank += gas[j]
                tank -= cost[j]
                if tank < 0:
                    break
                j += 1
                j %= n
            if j == i:
                return i
        return -1
",O(n ^ 2)
"class Solution(object):
    def sumBase(self, n, k):
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result",O(logn)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        res = 0

        def dfs(root):
            nonlocal res

            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            res = max(res, left + right)

            return 1 + max(left, right)

        dfs(root)
        return res
",O(n)
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = [root.val]

        def dfs(root):
            if not root:
                return 0

            leftMax = dfs(root.left)
            rightMax = dfs(root.right)
            leftMax = max(leftMax, 0)
            rightMax = max(rightMax, 0)

            res[0] = max(res[0], root.val + leftMax + rightMax)
            return root.val + max(leftMax, rightMax)

        dfs(root)
        return res[0]
",O(n)
"n = int(input())
i = 1
while n:
    if i > 1:
        print(' ', end='')
    if n == 3:
        print(*[i, i, i * 3], end='')
        break
    print(' '.join([str(i)] * ((n + 1) // 2)), end='')
    i <<= 1
    n >>= 1

print()
",O(nlogn)
"from collections import Counter


class Solution(object):
    def leastInterval(self, tasks, n):
        counter = Counter(tasks)
        _, max_count = counter.most_common(1)[0]
        return max((max_count-1) * (n+1) + list(counter.values()).count(max_count), len(tasks))",O(n)
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)==1:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"a = input()
b = input()

length_of_a = len(a)
length_of_b = len(b)
found_digit = False
chk_finnish = False
appended_digit_count = 0
n = {}
num = []
for i in range(0,10):
	n[i] = 0

for i in range(0,length_of_a):
	c = int(a[i])
	n[c] += 1

if length_of_a < length_of_b:
	num = sorted(a,reverse=True)
	for i in range(0,length_of_a):
		print(num[i],end="""")
else:
	for i in range(0,length_of_b):
		digit = int(b[i])
		if n[digit] > 0:
			num.append(digit)
			n[digit] -= 1

			appended_digit_count += 1
		else:
			j = digit - 1
			while j > -1:
				if n[j] > 0:
					num.append(j)
					appended_digit_count += 1
					n[j] -= 1

					found_digit = True
					chk_finnish = True
					break
				j -= 1

			if found_digit:
				j = 9
				while j > -1:
					if n[j] > 0:
						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							n[j] -= 1

							appended_digit_count += 1
					j -= 1
				if chk_finnish:
					break
			else:
				found_digit = False
				while found_digit == False:
					pop_up = num[appended_digit_count-1]

					del num[-1]
					j = pop_up - 1
					n[pop_up] += 1

					appended_digit_count -= 1
					while j > -1:
						if n[j] > 0:
							num.append(j)
							appended_digit_count += 1
							n[j] -= 1

							found_digit = True
							break
						j -= 1
				j = 9
				while j > -1:
					if n[j] > 0:

						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							appended_digit_count += 1
					j -= 1
				break

	for i in range(0,length_of_b):
		print(num[i],end="""")",O(n ^ 3)
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",O(1)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * 2 for _ in range(n)]
        dp[n - 1][1] = dp[n - 1][0] = nums[n - 1]
        for i in range(n - 2, -1, -1):
            dp[i][1] = max(nums[i], nums[i] + dp[i + 1][1])
            dp[i][0] = max(dp[i + 1][0], dp[i][1])

        return dp[0][0]
",O(n)
"import sys
import io, os
input = sys.stdin.buffer.readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-dvx[(k, vx)])
        d[k] += 1
        dvx[(k, vx)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)
",O(n)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(1)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
ans = 0
for i in range(2, n):
    for j in range(2 * i, n + 1, i):
        ans += j // i
print(ans * 4)",O(nlogn)
"n,a,b,c,T=map(int,input().split())
arr=list(map(int,input().split()))
Tcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0
for i in range(1,T):
  for j in range(n):
    if arr[j]<=i:a1+=1

  ans+=a1*c;a1=0
b1=0

for i in range(n):
  b1=a-((T-arr[i])*b)
  if b1<=0:ans+=b1;
  else:ans+=b1
ans1=n*a
print(max(ans,ans1))
",O(n)
"class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[1])
        result, right = 0, float(""-inf"")
        for l, r in intervals:
            if l < right:
                result += 1
            else:
                right = r
        return result",O(nlogn)
"n=int(input())
l=list(map(int,input().split()))
ans=0
m=[]
for i in range(2*n-1,-1,-1):
    if l[i] not in m:
        m.append(l[i])

for tt in range(0,n):
    i=m[tt]
    j=l.index(i)
    l.pop(j)
    k=l.index(i)
    l.insert(k,j)
    ans+=k-j
print(ans)
",O(n ^ 2)
"class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = left = gap = 0
        for right in range(len(tiles)):
            if right-1 >= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 >= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"n = int(input())

if n == 3:
    print('1 1 3')
    exit()
if n == 1:
    print('1')
    exit()
if n == 2:
    print('1 2')
    exit()
d = 2
ans = []
lfn = n
while d <= n:
    k = n // d
    for j in range(lfn - k):
        ans.append(d//2)
    lfn = n - len(ans)
    d *=2
d //= 2
k = n/d
if k < 1.5:
    ans.append(d)
else:
    ans.append(d + d//2)
print(' '.join([str(i) for i in ans]))",O(nlogn)
"from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    w, h, n = mii()
    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(
        []), SortedList([])
    hsm.add(h);
    wsm.add(w);
    hs.add(0);
    ws.add(0);
    hs.add(h);
    ws.add(w);
    dhs[h] = 1;
    dhs[0] = 1;
    dws[0] = 1;
    dws[w] = 1
    for i in range(n):
        t, p = map(str, input().split())
        p = int(p)
        if t == ""H"":
            if dhs[p] == 0:
                hs.add(p)
                dhs[p] = 1
            ind = hs.bisect_left(p)
            pre, nex = hs[ind - 1], hs[ind + 1]
            hsm.__delitem__(hsm.bisect_left(nex - pre));
            hsm.add(p - pre);
            hsm.add(nex - p)
        else:
            if dws[p] == 0:
                ws.add(p)
                dws[p] = 1
            ind = ws.bisect_left(p)
            pre, nex = ws[ind - 1], ws[ind + 1]
            wsm.__delitem__(wsm.bisect_left(nex - pre));
            wsm.add(p - pre);
            wsm.add(nex - p)
        print(wsm[-1] * hsm[-1])
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution(object):
    def validTicTacToe(self, board):
        def win(board, player):
            for i in range(3):
                if all(board[i][j] == player for j in range(3)):
                    return True
                if all(board[j][i] == player for j in range(3)):
                    return True

            return (player == board[1][1] == board[0][0] == board[2][2] or \
                    player == board[1][1] == board[0][2] == board[2][0])

        FIRST, SECOND = ('X', 'O')
        x_count = sum(row.count(FIRST) for row in board)
        o_count = sum(row.count(SECOND) for row in board)
        if o_count not in {x_count-1, x_count}: return False
        if win(board, FIRST) and x_count-1 != o_count: return False
        if win(board, SECOND) and x_count != o_count: return False

        return True",O(1)
"def main():
    n, m = map(int, input().split())
    w = [c == '*' for i in range(n) for c in input()]
    nm = n * m
    q = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    e = [1000] * nm
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if w[i]:
                    v += 1
                    if e[i] > v:
                        e[i] = v
                else:
                    v = e[i] = 0
        if f:
            w.reverse()
            e.reverse()
    e = [c if c != 1 else 0 for c in e]
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if v > e[i]:
                    v -= 1
                else:
                    v = e[i]
                if v:
                    w[i] = False
        if f:
            w.reverse()
            e.reverse()
    if any(w):
        print(-1)
    else:
        r = []
        for i, c in enumerate(e):
            if c:
                r.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(r), '\n'.join(r), sep='\n')

main()",O(n ^ 2)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

x=L()[0]
if x<=2:
    print(x)
    exit()
if x%2:
    n=x
    lcm=n*(n-1)//gcd(n,n-1)
    lcm=lcm*(n-2)//gcd(lcm,n-2)
    print(lcm)
else:
    ans=1
    for n1 in range(max(1,x-50),x+1):
        for n2 in range(max(1,x-50),x+1):
            for n3 in range(max(1,x-50),x+1):
                lcm=(n1*n2)//(gcd(n1,n2))
                lcm=(lcm*n3)//gcd(lcm,n3)
                ans=max(ans,lcm)
    print(ans)

endtime = time.time()
",O(1)
"class Solution(object):
    def maxAlternatingSum(self, nums):
        result = nums[0]
        for i in range(len(nums)-1):
            result += max(nums[i+1]-nums[i], 0)
        return result",O(n)
"class Solution2(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        for i in range(len(nums)+1):
            if not cnt[i%value]:
                return i
            cnt[i%value] -= 1",O(n)
"class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)",O(n)
"n, s = map(int, input().split())
if s % n == 0:
    print(s // n)
else:
    print(s // n + 1)
",O(1)
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"class Solution3(object):
    def rearrangeArray(self, nums):
        pos, neg = [], []
        for i in reversed(range(len(nums))):
            if nums[i] > 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in range(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result",O(n)
"def resistors(a,b):
    ans=0
    while b:
        ans+=a//b
        a,b=b,a%b
    return ans
a,b=map(int,input().strip().split())
print(resistors(a,b))",O(1)
"class Solution(object):
    def numberOfArrays(self, differences, lower, upper):
        total = mn = mx = 0
        for x in differences:
            total += x
            mn = min(mn, total)
            mx = max(mx, total)
        return max((upper-lower)-(mx-mn)+1, 0)",O(n)
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        resIdx = 0
        resLen = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

        return s[resIdx : resIdx + resLen]
",O(n ^ 2)
"class Solution(object):
    def countQuadruplets(self, nums):
        result = 0
        lookup = collections.defaultdict(int)
        lookup[nums[-1]] = 1
        for c in reversed(range(2, len(nums)-1)):
            for b in range(1, c):
                for a in range(b):
                    if nums[a]+nums[b]+nums[c] in lookup:
                        result += lookup[nums[a]+nums[b]+nums[c]]
            lookup[nums[c]] += 1
        return result


import collections",O(n ^ 3)
"def mp():
    return map(int, input().split())

def f(i):
    return (10 ** i - 10 ** (i - 1)) * i

n = int(input())

i = 1
sum = 0
while n - f(i) >= 0:
    n -= f(i)
    sum += f(i) // i
    i += 1

print(str(sum + (n + i - 1) // i)[n % i - 1])",O(1)
"class Solution(object):
    def sumOfPower(self, nums):
        MOD = 10**9+7
        nums.sort()
        result = dp = 0
        for x in nums:
            result = (result+(x**2)*(dp+x))%MOD
            dp = (dp+(dp+x))%MOD
        return result",O(nlogn)
"a=[[],[],[]]

s=input().split("" "")

for i in range(len(s)):
	if(s[i][1]=='m'):
		a[0].append(int(s[i][0]))
	elif(s[i][1]=='p'):
		a[1].append(int(s[i][0]))
	else:
		a[2].append(int(s[i][0]))

ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

ans=ko
ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]+1):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	elif(len(a[i])>1 and (a[i][0]+2==a[i][1])):
		ko=min(ko,1)
	elif(len(a[i])>2 and (a[i][1]+2==a[i][2])):
		ko=min(ko,1)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

print(min(ans,ko))
",O(nlogn)
"n = int(input())

arr = list(map(int, input().split(' ')))
arr.sort()

stop = 0
equal = -1
tempcounter = 0

for i in range(1, n):
    if arr[i] == arr[i-1]:
        equal = arr[i]
        tempcounter += 1
        if tempcounter == 2:
            break

if tempcounter == 1 and equal != 0:
    for j in range(n):
        if arr[j] == equal-1:
            print(""cslnb"")
            stop = 1

if tempcounter == 1 and equal == 0:
    print(""cslnb"")

elif tempcounter < 2 and stop == 0:
    moves = arr[0]
    counter = 0

    for i in range(1, n):
        moves += arr[i] - i

    if counter == 0:
        if moves%2 == 0:
            print(""cslnb"")

        else:
            print(""sjfnb"")

elif stop == 0:
    print(""cslnb"")
",O(nlogn)
"a = input()
b = input()
o = []
z = []
c0 = 0
c1 = 0
for i in b:
    if i == ""0"":
        c0 += 1

    else:
        c1 += 1

    o.append(c1)
    z.append(c0)

n = len(b)-1
m = len(a)-1
ans = 0
for i in range(len(a)):
    x = a[i]
    if x == ""1"":
        ans += z[(n-(m-i))]-z[i]
        if b[i] == ""0"":
            ans += 1

    else:
        ans += o[(n - (m - i))] - o[i]
        if b[i] == ""1"":
            ans += 1

print(ans)",O(n)
"class Solution(object):
    def nthUglyNumber(self, n, a, b, c):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def lcm(x, y):
            return x//gcd(x, y)*y

        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c

        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

        left, right = 1, 2*10**9
        while left <= right:
            mid = left + (right-left)//2
            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"class Solution(object):
    def subsetXORSum(self, nums):
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)",O(n)
"import collections


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def minInteger(self, num, k):
        lookup = collections.defaultdict(list)
        bit = BIT(len(num)+1)
        for i in reversed(range(len(num))):
            bit.add(i+1, 1)
            lookup[int(num[i])].append(i+1)
        result = []
        for _ in range(len(num)):
            for d in range(10):
                if lookup[d] and bit.sum(lookup[d][-1]-1) <= k:
                    k -= bit.sum(lookup[d][-1]-1)
                    bit.add(lookup[d].pop(), -1)
                    result.append(d)
                    break
        return """".join(map(str, result))",O(nlogn)
"from math import *

n=int(input())
A = list(map(int,input().split()))
ans =-1
maxs = 0
for j in range(n):
    if(A[j] > maxs):
        ans = j+1
        break
    else:
        maxs = max(maxs,A[j]+1)
print(ans)",O(n)
"import sys

def prepare():
    stack = [i for i in range(n) if deg[i] == 0]
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            deg[dest] -= 1
            if deg[dest] == 0:
                stack.append(dest)
        adj[v].clear()

    return cnt == n

def solve(st):
    stack = [st]
    visited = [0]*n
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            if dest == st:
                continue
            visited[dest] += 1
            if deg[dest] == visited[dest]:
                stack.append(dest)

    return cnt == m

n, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
adj = [[] for _ in range(n)]
rev = [[] for _ in range(n)]
deg = [0]*n
for u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):
    adj[u-1].append(v-1)
    rev[v-1].append(u-1)
    deg[v-1] += 1

ok = prepare()
if ok:
    print('YES')
    exit()

m = len([1 for i in range(n) if deg[i] > 0])
for i in range(n):
    if deg[i] == 1 and solve(i):
        print('YES')
        exit()

print('NO')
",O(n ^ 2)
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
elif 3*k <= n:

    print((""0"" * ((n-k)//2)) + ""1"" + (""0""*(k-2)) + ""1"" + ""0"" * ((n-k)//2))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",O(1)
"n, m, k = [int(i) for i in input().split()]
A = [int(i) for i in input().split()]

bestbest = 0

def brute(n, m, k, A):
    ans = 0
    val = (0, 0)
    for i in range(n):
        for j in range(i, n):
            if ans < sum(A[i:j+1]) - k*(ceil((j-i+1)/m)):
                ans = sum(A[i:j+1]) - k*(ceil((j-i+1)/m))
                val = (i, j)
    return val, ans

for off in range(m):
    B = A[off:]
    C = []
    canstart = []
    for i in range(len(B)):
        if i%m == 0:
            C.append(-k)
            canstart.append(1)
        canstart.append(0)
        C.append(B[i])

    best = 0
    run = 0

    for i in range(len(C)):
        run += C[i]
        if run < -k:
            run = -k
        best = max(best, run)

    bestbest = max(bestbest, best)

print(bestbest)
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m=map(int,input().split())
s=0
e=n-1
for i in range(n//2):
    for j in range(m):
        print(s+1,j+1)
        print(e+1,m-j)
    s+=1
    e-=1
if n%2==1:
    s=n//2
    for j in range(m//2):
            print(s+1,j+1)
            print(s+1,m-j)
    if m%2==1:
            print(s+1,m//2+1)",O(n ^ 2)
"n = int(input())
ans = 1
if n == 1:
    ans = 1
elif n == 2:
    ans = 2
elif n == 3:
    ans = 6
elif n%2 == 0:
    if n%3 == 0:
        ans = (n-1)*(n-2)*(n-3)
    else:
        ans = n*(n-1)*(n-3)
else:
    ans = n*(n-1)*(n-2)

print(ans)",O(1)
"class Solution(object):
    def largestSquareArea(self, bottomLeft, topRight):
        result = 0
        for i in range(len(bottomLeft)):
            for j in range(i+1, len(bottomLeft)):
                max_x = max(bottomLeft[i][0], bottomLeft[j][0])
                min_x = min(topRight[i][0], topRight[j][0])
                max_y = max(bottomLeft[i][1], bottomLeft[j][1])
                min_y = min(topRight[i][1], topRight[j][1])
                result = max(result, min(min_x-max_x, min_y-max_y))
        return result**2",O(n ^ 2)
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1

ans=[]
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:

    print(ans[-1])
",O(n ^ 3)
"import sys

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
m = inp[ii]; ii += 1
k = inp[ii]; ii += 1

if k%2 == 1:
	for _ in range(n):
		toprint = [""-1"" for __ in range(m)]
		print("" "".join(toprint))

	sys.exit()

yw = []

for _ in range(n):
	yw.append(inp[ii:ii+m-1])
	ii += m-1

xw = []

for _ in range(n-1):
	xw.append(inp[ii:ii+m])
	ii += m

inf = 10**10

steps = k//2

dp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)]

for i in range(n):
	for j in range(m):
		dp[0][i][j] = 0

for step in range(1, steps + 1):
	for i in range(n):
		for j in range(m):

			if i > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j])

			if i < n-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j])

			if j > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1])

			if j < m-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j])

for x in dp[-1]:
	print("" "".join(list(map(str, [2*o for o in x]))))",O(n ^ 3)
"if input()=='1':
 print(input())
else:
 x,*a,y=sorted(map(int,input().split()))
 print(y-x+sum(map(abs,a)))",O(nlogn)
"class Solution(object):
    def maxDepthAfterSplit(self, seq):
        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]",O(n)
"import sys, string

n, m = map(int, sys.stdin.readline().split())
s = list(sys.stdin.readline().rstrip())
t = list(sys.stdin.readline().rstrip())
idx = -1
for i in range(n):
    if s[i] == '*':
        idx = i
if idx == -1:
    if s == t:
        print('YES')
    else:
        print('NO')
else:
    if m < n - 1:
        print('NO')
    else:
        s_left = s[0 : idx]
        s_right = s[idx + 1 : n]
        a = len(s_left)
        b = len(s_right)
        t_left = []
        t_right = []
        for i in range(a):
            t_left.append(t[i])
            t[i] = ''
        for i in range(b):
            t_right.append(t[m - i - 1])
        if s_left == t_left and s_right == t_right[::-1]:
            print('YES')
        else:
            print('NO')",O(n)
"import sys

from bisect import bisect_left as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

for _ in range (1) :
    n = ii()

    x = 1
    i = 0

    while (x <= n) :
        x += (9*(i+1)*(10**i))
        i += 1

    x -= 9*i*(10**(i-1))

    y = str(10**(i-1) + (n-x)//i)

    print(y[(n-x)%i])
",O(logn)
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=[]
for i in range(m):
    if y[i] in x:
        l.append(x.index(y[i]))
l.sort()
for i in l:
    print(x[i],end="" "")",O(n ^ 2)
"class Solution(object):
    def findSubstringInWraproundString(self, p):
        letters = [0] * 26
        result, length = 0, 0
        for i in range(len(p)):
            curr = ord(p[i]) - ord('a')
            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):
                length = 0
            length += 1
            if length > letters[curr]:
                result += length - letters[curr]
                letters[curr] = length
        return result",O(n)
"from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd

def read(): return list(map(int, input().strip().split()))

ans_ = []

t_p = [2**i for i in range(31)]
n = int(input());
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [[list(arr.keys())[0], 1]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = arr[a] + arr[b] + arr[c]
        if s > m:
            m = s
            ans_lis = [[x, arr[x]] for x in [a, b, c]]

ans_.append(m)
t = """"
for i in ans_lis:t += (str(i[0])+"" "")*i[1]
ans_.append(t)

for i in ans_:
    print(i)
",O(nlogn)
"n = int(input())
ar = list(map(int, input().split()))
rev = ar[::-1]
from collections import Counter
def d(ar):
	me = Counter()
	s = 0
	for i in range (n) :
		s+=(i*ar[i])
		s-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])
		me[ar[i]]+=1
	return s
print(d(ar) - d(rev))",O(nlogn)
"import math
ans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]
n = int(input())

if (n % 2 == 1):
	print(ans[n // 2] * math.factorial(n) % 1000000007)
else:
	print(0)",np
"import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split())
def listinput(): return list(map(int, input().split()))
n,k=minput()
for i in range(1,n+1):
	if (i*(i+1))/2 -n+i==k:
		print(n-i)
		break",O(logn)
"n=int(input())
ar=list(map(int,input().split()))
d={};ans=0
for i in ar:d[i]=d.get(i,0)+1
for i in ar:
  flag=False
  for j in range(31):
    k=2**j;
    if k>=i:
     k1=k-i
     if i!=k1 and d.get(k1,0)>0:flag=True;break
     if i==k1 and d.get(i,0)>1:flag=True;break
  if not flag:ans+=1

print(ans)
",O(nlogn)
"class Solution2(object):
    def minimumOperations(self, nums):
        return sum(min(x%3, 3-x%3) for x in nums)",O(n)
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",O(n)
"import collections
import itertools



class Solution(object):
    def equalPairs(self, grid):
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in zip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.keys() if k in cnt2)",O(n ^ 2)
"class Solution2(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def bfs():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            new_root = -1
            degree = list(map(len, adj))
            q = [u for u in range(len(degree)) if degree[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if degree[u] == 0:
                        new_root = u
                        continue
                    degree[u] -= 1
                    for v in adj[u]:
                        if degree[v] == 0:
                            continue
                        curr = increase(dp[u][0])
                        for i in range(len(dp[v])):
                            if curr > dp[v][i]:
                                curr, dp[v][i] = dp[v][i], curr
                        degree[v] -= 1
                        if degree[v] == 1:
                            new_q.append(v)
                q = new_q
            return dp, new_root

        def bfs2(root):
            result = [-1]*len(adj)
            q = [(root, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp, u = bfs()
        return bfs2(u)",O(n)
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1",O(n ^ 2)
"class Solution(object):
    def longestDecomposition(self, text):
        def compare(text, l, s1, s2):
            for i in range(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 26
        result = 0
        left, right, l, pow_D = 0, 0, 0, 1
        for i in range(len(text)):
            left = (D*left + (ord(text[i])-ord('a'))) % MOD
            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD
            l += 1
            pow_D = (pow_D*D) % MOD 
            if left == right and compare(text, l, i-l+1, len(text)-1-i):
                result += 1
                left, right, l, pow_D = 0, 0, 0, 1
        return result",O(n)
"a,b=map(int,input().split())

b1=bin(b)[2:]
a1=bin(a)[2:]
if len(a1)==len(b1) :
    d=(b^a)
    v=d.bit_length()
    print(int(""0""+""1""*(v),2))
else :
    print(int(""1""*len(b1),2))
",O(logn)
"class Solution(object):
    def maxFreeTime(self, eventTime, startTime, endTime):
        def topk(a, k): 
            result = [[float(""-inf"")]*2 for _ in range(k)]
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result

        result = 0
        startTime.append(eventTime)
        endTime.insert(0, 0)
        diffs = ([startTime[i]-endTime[i], endTime[i]] for i in range(len(startTime)))
        top3 = topk(diffs, 3)
        for i in range(len(startTime)-1):
            for mx, e in top3:
                if e not in (endTime[i], endTime[i+1]) and endTime[i+1]-startTime[i] <= mx:
                    result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1])+(endTime[i+1]-startTime[i]))
                    break
            else:
                result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1]))
        return result",O(n)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        while len(tokens) > 1:
            for i in range(len(tokens)):
                if tokens[i] in ""+-*/"":
                    a = int(tokens[i-2])
                    b = int(tokens[i-1])
                    if tokens[i] == '+':
                        result = a + b
                    elif tokens[i] == '-':
                        result = a - b
                    elif tokens[i] == '*':
                        result = a * b
                    elif tokens[i] == '/':
                        result = int(a / b)
                    tokens = tokens[:i-2] + [str(result)] + tokens[i+1:]
                    break
        return int(tokens[0])
",O(n ^ 2)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:
            mid = (l + r) // 2
            if target == nums[mid]:
                return mid

            if nums[l] <= nums[mid]:
                if target > nums[mid] or target < nums[l]:
                    l = mid + 1
                else:
                    r = mid - 1

            else:
                if target < nums[mid] or target > nums[r]:
                    r = mid - 1
                else:
                    l = mid + 1
        return -1
",O(logn)
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

for i in range(1,(kk//2)+1) :

	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])

				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",O(n ^ 3)
"class Solution(object):
    def passThePillow(self, n, time):
        return n-abs((n-1)-(time%(2*(n-1))))",O(1)
"def fastio():
	import sys
	from io import StringIO
	from atexit import register
	global input
	sys.stdin = StringIO(sys.stdin.read())
	input = lambda : sys.stdin.readline().rstrip('\r\n')
	sys.stdout = StringIO()
	register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))

t, = I()
while t:
	t -= 1
	n, = I()
	a = I()
	a.sort()
	if n == 2:
		print(0)
	else:
		print(min(n-2, a[-2]-1))
",O(nlogn)
"def maxXORInRange(L, R):
	LXR = L ^ R
	msbPos = 0
	while(LXR):
		msbPos += 1
		LXR >>= 1

	maxXOR = (1<<msbPos)-1
	return maxXOR

l,r=map(int,input().split())
print(maxXORInRange(l, r))
",O(logn)
"class Solution(object):
    def minimumBoxes(self, apple, capacity):
        capacity.sort(reverse=True)
        total = sum(apple)
        for i in range(len(capacity)):
            total -= capacity[i]
            if total <= 0:
                return i+1
        return -1",O(nlogn)
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)
",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time

starttime = time.time()

mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)

endtime = time.time()
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]

    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]

    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]

    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]

    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z

n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))

col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)

    for item in ans:
        print(*item)

def nouse0():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

def nouse3():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))",O(nlogn)
"class Solution(object):
    def verifyPreorder(self, preorder):
        low, i = float(""-inf""), -1
        for p in preorder:
            if p < low:
                return False
            while i >= 0 and p > preorder[i]:
                low = preorder[i]
                i -= 1
            i += 1
            preorder[i] = p
        return True",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,k=inar()
    st=input().strip()
    res=st
    pos=1
    cnt=1
    while cnt<k:
        suffix=0
        counter=0
        for i in range(pos,len(res)):
            if res[i]==st[suffix]:
                suffix+=1
            else:
                counter=1
                break
        if counter:
            pos+=1
            continue
        if pos>len(res):
            res+=st
            cnt+=1
            pos+=1
            continue
        res+=st[suffix:n]
        cnt+=1
        pos+=1
    print(res)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n = int(input())
m = int(input())
r = 1
for power in range(n):
    r *= 2
    if r > m:
        print(m)
        break
else:
    if r == m:
        print(0)
    else:
        print(m % r)
",O(1)
"class Solution(object):
    def maxNonOverlapping(self, nums, target):
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] >= right:
                right = i
                result += 1 
            lookup[accu] = i
        return result",O(n)
"n = int(input())

a = list(map(int, input().split()))

a.sort(reverse=True)

cnt = 0
while a:
    f = a.pop()
    rm = []
    for x in a:
        if x % f == 0:
            rm.append(x)
    for x in rm:
        a.remove(x)
    cnt += 1

print(cnt)
",O(n ^ 2)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])",O(n ^ 2)
"n = int(input())
s = input()
t = input()
dic, diff = {}, []
res, res1, res2 = 0, -1, -1
for i in range(n) :
    if s[i] != t[i] :
        res += 1
        diff.append(i)
        dic[t[i]] = i
swap1, swap2 = False, False
for i in diff :
    if s[i] in dic:
        swap1 = True
        res1 = i+1
        j = dic[s[i]]
        res2 = j+1
        if s[j] == t[i] :
            swap2 = True
            break
print(res - (2 if swap2 else 1 if swap1 else 0))
print(res1, res2)
",O(n)
"import math
import sys
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from sys import stdout

R = lambda: map(int, input().split())
t = input()
s = input()
k = t.count('+') - s.count('+')
n = s.count('?')
if k > n or k < 0:
    print('0.0')
else:
    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",np
"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)

def main():
	def ask(c, d):

		print(""?"", c, d, flush = True)
		return int(input())

	relative = ask(0, 0)
	curA = 0
	curB = 0

	for i in range(29, -1, -1):
		q1 = ask(curA ^ 2 ** i, curB)
		q2 = ask(curA, curB ^ 2 ** i)

		if q1 == q2:
			if relative == 1:
				curA ^= 2 ** i
			else:
				curB ^= 2 ** i
			relative = q1
		elif q2 == 1:
			curA ^= 2 ** i
			curB ^= 2 ** i
	return curA, curB
print(""!"", *main())",O(1)
"
class Solution(object):
    def boundaryOfBinaryTree(self, root):
        def leftBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            nodes.append(root.val)
            if not root.left:
                leftBoundary(root.right, nodes)
            else:
                leftBoundary(root.left, nodes)

        def rightBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            if not root.right:
                rightBoundary(root.left, nodes)
            else:
                rightBoundary(root.right, nodes)
            nodes.append(root.val)

        def leaves(root, nodes):
            if not root:
                return
            if not root.left and not root.right:
                nodes.append(root.val)
                return
            leaves(root.left, nodes)
            leaves(root.right, nodes)

        if not root:
            return []

        nodes = [root.val]
        leftBoundary(root.left, nodes)
        leaves(root.left, nodes)
        leaves(root.right, nodes)
        rightBoundary(root.right, nodes)
        return nodes

",O(n)
"class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'",O(nlogn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        return self.pathSumRecu([], [], root, sum)


    def pathSumRecu(self, result, cur, root, sum):
        if root is None:
            return result

        if root.left is None and root.right is None and root.val == sum:
            result.append(cur + [root.val])
            return result

        cur.append(root.val)
        self.pathSumRecu(result, cur, root.left, sum - root.val)
        self.pathSumRecu(result, cur,root.right, sum - root.val)
        cur.pop()
        return result

",O(n)
"class Solution(object):
    def maximizeGreatness(self, nums):
        return len(nums)-max(collections.Counter(nums).values())
    
    
",O(n)
"import sortedcontainers


class Solution(object):
    def maxDepthBST(self, order):
        depths = sortedcontainers.SortedDict({float(""-inf""):0, float(""inf""):0})
        values_view = list(depths.values())
        result = 0
        for x in order:
            i = depths.bisect_right(x)
            depths[x] = max(values_view[i-1:i+1])+1
            result = max(result, depths[x])
        return result",O(nlogn)
"class Solution(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + 
        return s[getPrefix(A)[-1]+1:][::-1] + s",O(n)
"def problem(s, p):
    n = len(s)
    F = [[n] * 26 for _ in range(n + 2)]
    for i in range(n - 1, -1, -1):
        F[i][:] = F[i + 1]
        F[i][ord(s[i]) - 97] = i

    def interleaving(l, r):
        dp = [-1] + [n] * len(r)

        for j in range(1, len(r) + 1):
            dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]

        for i in range(1, len(l) + 1):
            dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97]

            for j in range(1, len(r) + 1):
                a = F[dp[j] + 1][ord(l[i - 1]) - 97]
                b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]
                dp[j] = min(a, b)

        return dp[-1] < n

    for i in range(len(p)):
        if interleaving(p[:i], p[i:]):
            return 'YES'
    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]

    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"n,k=map(int,input().split())
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2

	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)
",O(logn)
"import heapq



class Solution(object):
    def minOperations(self, nums, k):
        result = 0
        heapq.heapify(nums)
        while nums:
            if nums[0] >= k:
                break
            mn1 = heapq.heappop(nums)
            mn2 = heapq.heappop(nums)
            heapq.heappush(nums, 2*mn1+mn2)
            result += 1
        return result",O(nlogn)
"a = list(map(int,input().split()))
b = list(map(int,input().split()))
c = list(map(int,input().split()))
a,b,c= sorted([a,b,c])

path = []
for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):
    path.append((b[0],i))
for i in range(a[0],b[0]+1):
    path.append((i,a[1]))
for i in range(b[0],c[0]+1):
    path.append((i,c[1]))

print(len(set(path)))
for i in set(path):
    print(*i)
",O(1)
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",O(1)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))",O(n)
"class Solution(object):
    def newInteger(self, n):
        result, base = 0, 1
        while n > 0:
            result += (n%9) * base
            n /= 9
            base *= 10
        return result",O(logn)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n = I()
ls = [int(i) for i in S()]
pre , s =[] , 0
for i in ls:
	s+=i
	pre.append(s)
for i in range(n-1):
	cnt =0
	su =0
	for j in range(i+1 , n):
		su+=ls[j]
		if su == pre[i]:
			cnt+=1
			su =0
	if cnt and su ==0:
		print('YES')
		exit()
print('NO')

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))",O(n)
"def getsum(n):
    return ((1 << (2*n)) - 1) // 3

def b(n, k):
    l = n - 1
    r = max(0, l - 41)
    while True:
        mid = (l + r) // 2
        count = getsum(n - mid)
        if count <= k:
            l = mid
        else:
            r = mid
        if l - r <= 1:
            break
        del count
    g = getsum(n - r)
    if g < k:
        del g
        return None
    elif g == k:
        del g
        return r
    return l

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    min_side = b(n, k)
    if min_side is None:
        print('NO')
        continue
    k -= getsum(n - min_side)
    if n == 2 and min_side == 1 and k == 2:
        print('NO')
        continue
    num_squares = (1 << (n - min_side)) * 2 - 1
    if k >= num_squares:
        print('YES ' + str(min_side - 1))
    else:
        print('YES ' + str(min_side))",O(logn)
"MOD = 10**9 + 7
x, k = map(int, input().split())
y = (2*x - 1) % MOD
mult = pow(2, k, MOD)
if x:
    print((y * mult + 1) % MOD)
else:
    print(0)",O(logn)
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def print(x, end):
    sys.stdout.write(str(x) + end)
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def cleanarr(arr):
    n = len(arr)

    arr.sort()
    c = []
    curr=[arr[0], 1]
    for i in range(n - 1):
        if (arr[i] != arr[i + 1]):
            if(curr[1]>=2):
                c.append(curr)
            curr=[arr[i+1],1]
        else:
            curr[1] += 1
    if(curr[1]>=2):
        c.append(curr)
    return c
def main():
    t=int(input())
    for _ in range(t):
        n=int(input())
        arr=list(map(int, input().split()))
        g=arr[0]
        c=cleanarr(arr)
        if(n>=40000):
            f=0
            for i in range(len(c)):
                if(c[i][1]>=4):
                    f=c[i][0]
                    break
            print(f,"" "")
            print(f,"" "")
            print(f,"" "")
            print(f,""\n"")
            continue
        mi=10**18
        pair=[-1,-1]
        for i in range(len(c)):
            if(c[i][1]>=4):
                pair=[c[i][0],c[i][0]]
                break
            if(i==len(c)-1):
                break
            a=c[i][0]
            b=c[i+1][0]
            if(mi==10**18):
                pair=[a,b]
                mi=0
                continue
            if ((((pair[0]+pair[1])**2)*a*b)-(((a+b)**2)*pair[0]*pair[1])>0):
                pair=[a,b]
        print(pair[0],"" "")
        print(pair[0],"" "")
        print(pair[1],"" "")
        print(pair[1],""\n"")
main()",O(nlogn)
"import collections



class Solution(object):
    def mostFrequent(self, nums, key):
        return collections.Counter(nums[i+1] for i in range(len(nums)-1) if nums[i] == key).most_common(1)[0][0]",O(n)
"k=int(input())

s=0
i=1
while  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :
    s +=  i * (9 * pow(10, i - 1))
    i+=1
else:
    i-=1

k=k-s-1
x= k // (i+1)
y= k %(i+1)
x= pow(10,i)+x
ss=str(x)
print(ss[y])
",O(logn)
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def main():
    n=int(input())
    b=[0]
    cost=b+list(map(int, input().split()))
    arr=b+list(map(int, input().split()))
    nv=[-1]*(n+1)
    colors=[]
    c=0
    for i in range(1,n+1):
        if(nv[i]!=-1):
            continue
        nv[i]=c
        dest=arr[i]
        while(nv[dest]==-1):
            nv[dest]=c
            dest=arr[dest]
        if(nv[dest]==c):
            colors.append(dest)
        c+=1
    s=0
    for i in colors:
        mi=cost[i]
        nxt=arr[i]
        while(nxt!=i):
            mi=min(mi,cost[nxt])
            nxt=arr[nxt]
        s+=mi
    print(s)
main()",O(n)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preIdx = inIdx = 0
        def dfs(limit):
            nonlocal preIdx, inIdx
            if preIdx >= len(preorder):
                return None
            if inorder[inIdx] == limit:
                inIdx += 1
                return None

            root = TreeNode(preorder[preIdx])
            preIdx += 1
            root.left = dfs(root.val)
            root.right = dfs(limit)
            return root
        return dfs(float('inf'))
",O(n)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
",O(n)
"fac = [1] * 500
finv = [1] * 500
p2 = [1] * 500

n, MOD = map(int, input().split())

for i in range(len(fac) - 1):
    fac[i + 1] = fac[i] * (i + 1) % MOD
    finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD)
    p2[i + 1] = p2[i] * 2 % MOD

ans = 0
dp = [[0] * (n // 2 + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 2, n + 2):
        for k in range(n // 2 + 1):
            dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2]
ans = 0
for i in range(1, n // 2 + 2):
    ans += dp[n + 1][i] * fac[n - i + 1]
print(ans % MOD)",O(n ^ 3)
"n,m = map(int, input().split())
a = []
for i in range(n):
    s = input()
    a.append(s)
for i in range(n):
    for j in range(m):
        if a[i][j] == '.':
            continue
        if i >= 2 and j >= 2:
            if a[i-2][j-2] == '
                    and a[i-1][j] == '
                continue
        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '
                and a[i][j-2] == '
            continue
        if i <= n-3 and j >= 2 and a[i][j-1] == '
                and a[i+1][j-2] == '
            continue
        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '
                and a[i+1][j+1] == '
            continue
        if i <= n-3 and j <= m-3 and a[i][j+1] == '
                and a[i+1][j+2] == '
            continue
        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '
                and a[i][j+2] == '
            continue
        if i >= 2 and j <= m-3 and a[i-2][j] == '
                and a[i-1][j] == '
            continue
        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '
                and a[i-1][j-1] == '
            continue
        print('NO')
        exit()
print('YES')",O(n ^ 2)
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr.sort()
arr=arr+[k]
ans=0
s=0
while ans<n+1:
    s+=arr[-ans-1]
    if s>=m:
        break
    ans+=1
    s-=1
if s>=m:
    print(ans)
else:
    print(""-1"")
",O(nlogn)
"n,a,b=list(map(int,input().split()))
d=[]
for i in range(n):
    d.append([""1""]*n)
    d[i][i]=""0""
if [n,a,b]==[2,1,1]:
    print(""NO"")
elif [n,a,b]==[3,1,1]:
    print(""NO"")
elif a==1:
    c=n-b
    for i in range(c):
        d[i][i+1]=""0""
        d[i+1][i]=""0""
    print(""YES"")
    for i in range(n):
        print("""".join(d[i]))
elif a!=1 and b!=1:
    print(""NO"")
else:
    print(""YES"")
    for i in range(a-1):
        for j in range(n):
            d[i][j]=""0""
        for j in range(n):
            d[j][i]=""0""
    for i in range(n):
        print("""".join(d[i]))",O(n ^ 2)
"n = int(input())
lst = list(map(int,input().split()))
lst = set(lst)
lst = list(lst)
lst.remove(min(lst))
if(len(lst)==0):
    print(""NO"")
else:
    print(min(lst))
",O(nlogn)
"class Solution(object):
    def dayOfTheWeek(self, day, month, year):
        DAYS = [""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", \
                ""Thursday"", ""Friday"", ""Saturday""]

        if month < 3:
            month += 12
            year -= 1
        c, y = divmod(year, 100)
        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7
        return DAYS[w]",O(1)
"arra = []
arrb = []
arr = []
s = """"
temp = 1
value = ans = n = 0

def fill(myList = [], *args):
    for i in range(n):
        arra.insert(0,0)

def check():
    for i,j in zip(arra,arrb):
        if i == j:
            return 1
        else:
            return 0

def Engine1(num):
    if num > 1:
        Engine1(num // 2)
    arra.append( num%2 )
def Engine2(num):
    if num > 1:
        Engine2(num // 2)
    arrb.append( num%2 )

a,b = map(int,input().split())
Engine1(a)
Engine2(b)

n = abs(len(arra)-len(arrb))
if(len(arra)>len(arrb)):
    fill(arrb)
if(len(arra)<len(arrb)):
    fill(arra)

for i in range(len(arra)):
    if(check() == 0):
        break
    check()
    arra.pop(0)
    arrb.pop(0)

for i in range(len(arra)):
    ans += temp
    temp *= 2
print(ans)",O(logn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter,defaultdict
from heapq import heappush, heappop
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

def main():
    def fn(s, e, qs, qe):
        if qs <= s <= e <= qe: return True
        return False

    for _ in range(1):
        n = nmbr()
        ans = [-1, -1]
        a = [lst() for i in range(n)]
        a = [[a[i][0], a[i][1], i] for i in range(n)]
        a.sort(key=lambda x: (x[0], x[1]))
        for i in range(n - 1):
            if fn(a[i][0], a[i][1], a[i + 1][0], a[i + 1][1]):
                ans = [a[i][2] + 1, a[i + 1][2] + 1]
                break
            elif fn(a[i + 1][0], a[i + 1][1], a[i][0], a[i][1]):
                ans = [a[i + 1][2] + 1, a[i][2] + 1]
                break
        print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    for t in range(1):main()",O(nlogn)
"from sys import stdin, stdout

s = input()

s = s.split(' ')

M = [0]*9
P = [0]*9
S = [0]*9

for pile in s:
    pile = list(pile)

    num = int(pile[0])
    tile = pile[1]

    if tile=='s':
        S[num-1] += 1
    elif tile=='p':
        P[num-1] += 1
    elif tile=='m':
        M[num-1] += 1

for i in range(9):
    if M[i]==3:
        print(0)
        quit()
    if P[i]==3:
        print(0)
        quit()
    if S[i]==3:
        print(0)
        quit()

for i in range(7):
    if M[i]==1 and M[i+1]==1 and M[i+2]==1:
        print(0)
        quit()
    if P[i]==1 and P[i+1]==1 and P[i+2]==1:
        print(0)
        quit()
    if S[i]==1 and S[i+1]==1 and S[i+2]==1:
        print(0)
        quit()

for i in range(9):
    if M[i]==2:
        print(1)
        quit()
    if P[i]==2:
        print(1)
        quit()
    if S[i]==2:
        print(1)
        quit()

for i in range(8):
    if M[i]==1 and M[i+1]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+1]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+1]==1:
        print(1)
        quit()

for i in range(7):
    if M[i]==1 and M[i+2]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+2]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+2]==1:
        print(1)
        quit()

print(2)
",O(n)
"n = int(input())
queen_x, queen_y = list(map(int, input().strip().split()))
king_x, king_y = list(map(int, input().strip().split()))
tar_x, tar_y = list(map(int, input().strip().split()))

min_x, max_x = sorted([king_x, tar_x])
min_y, max_y = sorted([king_y, tar_y])

if max_x > queen_x > min_x or max_y > queen_y > min_y:
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",O(logn)
"n=int(input())
a=list(map(int,input().split()))
d=set()
t={}
rep=set()
if a.count(0)>=2:
	print(""cslnb"")
	exit()

for i in a:
	if i in d:
		if t[i]+1==3:
			print(""cslnb"")
			exit()
		else:
			t[i]+=1
			rep.add(i)
			if len(rep)>=2:
				print(""cslnb"")
				exit()
	else:
		t[i]=1
		d.add(i)
if rep:
	for c in rep:
		if c-1 in d:
			print(""cslnb"")
			exit()
s=0
a.sort()
for i in range(n):
	s+=a[i]-i
if s%2==1:print(""sjfnb"")
else:print(""cslnb"")",O(nlogn)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        stack = [root]
        mp = {None: (0, 0)}

        while stack:
            node = stack[-1]

            if node.left and node.left not in mp:
                stack.append(node.left)
            elif node.right and node.right not in mp:
                stack.append(node.right)
            else:
                node = stack.pop()

                leftHeight, leftDiameter = mp[node.left]
                rightHeight, rightDiameter = mp[node.right]

                mp[node] = (1 + max(leftHeight, rightHeight),
                           max(leftHeight + rightHeight, leftDiameter, rightDiameter))

        return mp[root][1]
",O(n)
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
n = int(input())
a = []
for i in range(n):
    a.append(input())
print(6-len(a))
for i in dic:
    if i not in a:
        print(dic[i])",O(1)
"n = int(input())
l = list(map(int, input().split("" "")))
l2 = list(map(int, input().split("" "")))
dp_1 = l2.copy()
dp_2 = [9999999999]*n
dp_3 = [9999999999]*n
for i in range(1, n):
    for j in range(i):
        if l[i] > l[j]:
            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])

for i in range(1,n):
    for j in range(i):
        if l[i] > l[j]:
            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])

x = min(dp_3)
if x == 9999999999:
    print(-1)
else:
    print(x)",O(n ^ 2)
"import math
n=int(input())
columns=list(map(int, input().rstrip().split()))

modcolumns=[i%2 for i in columns]

test=0

previouslist=[]

for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])

    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()

    else:
        previouslist.append(modcolumns[i])

if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"point = {}

n = int(input())

for i in range(n):
    l, r = map(int, input().split())
    r += 1
    if l not in point:
        point[l] = 0
    if r not in point:
        point[r] = 0
    point[l] += 1
    point[r] -= 1

line = []
for key in point:
    line.append((key,point[key]))
line.sort()
ans = [0] * (n+1)

last_index = 0
last_value = 0

for index, value in line:
    ans[last_value] += index - last_index
    last_index = index
    last_value += value

for cnt in ans[1:]:
    print(cnt,end=' ')",O(nlogn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n, m = zz()
arr = zzz()
s = sum(arr)
x = [[] for i in range(m)]
for i in range(n): x[arr[i] % m].append(i)
j = 0
for i in range(m):
    while len(x[i]) > n // m:
        while j < i or len(x[j % m]) >= n // m: j += 1
        k = x[i].pop()
        arr[k] += (j - i) % m
        x[j % m].append(k)
print(sum(arr) - s)
print(*arr)
",O(n)
"from math import factorial as fact

a = input()
b = input()

aplus = a.count('+')
aminus = len(a) - aplus

bplus = b.count('+')
bminus = b.count('-')
bjolly = len(b) - bplus - bminus

if bplus > aplus or bminus > aminus:
    print(0)
else:
    c = aplus-bplus
    res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly
    print(res)
",np
"n=int(input())
a=(n//2)*3
print(a)",O(1)
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.is_string = True

    def search(self, word):
        node = self.childSearch(word)
        if node:
            return node.is_string
        return False

    def startsWith(self, prefix):
        return self.childSearch(prefix) is not None

    def childSearch(self, word):
        cur = self.root
        for c in word:
            if c in cur.leaves:
                cur = cur.leaves[c]
            else:
                return None
        return cur


",O(n)
"turns, candies = map(int, input().split())
summ = 0
turn = 0
while candies != summ - (turns - turn):
    turn += 1
    summ += turn
print(turns - turn)",O(n)
"n, k = map(int, input().split())
teams, freqs = [tuple(int(i) for i in input().split()) for _ in range(n)], {}
teams.sort(key = lambda x: (-x[0], x[1]))
for team in teams:
    freqs[team] = freqs.get(team, 0) + 1
print(freqs[teams[k - 1]])
",O(nlogn)
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = False
        for t in triplets:
            x |= (t[0] == target[0] and t[1] <= target[1] and t[2] <= target[2])
            y |= (t[0] <= target[0] and t[1] == target[1] and t[2] <= target[2])
            z |= (t[0] <= target[0] and t[1] <= target[1] and t[2] == target[2])
            if x and y and z:
                return True
        return False
",O(n)
"class Solution(object):
    def repeatedSubstringPattern(self, str):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(str)
        return prefix[-1] != -1 and \
               (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0

    def repeatedSubstringPattern2(self, str):
        if not str:
            return False

        ss = (str + str)[1:-1]
        return ss.find(str) != -1",O(n)
"str=input()
m=0
n=len(str)
for i in range(n):
    for j in range(i,n+1) :
        if str[i:j] in str[i+1:n] and len(str[i:j])>m:
            m=len(str[i:j])
print(m)",O(n ^ 3)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node",O(1)
"def main():
    import sys
    import collections
    input = sys.stdin.readline
    n, m, K = map(int, input().split())

    A = [input().rstrip() for i in range(n)]

    B = [list(input().rstrip().split()) for i in range(m)]

    alpha = 'abcｄ'

    D = dict()
    for i, x in enumerate(A):
        D[x] = i

    G = [set() for i in range(n)]
    X = [set() for i in range(n)]

    for i in range(m):
        a, b = B[i]
        b = int(b)
        flag = False
        for j in range(2**K):
            x = []
            for k in range(K):
                if (j >> k) % 2 == 1:
                    x.append('_')
                else:
                    x.append(a[k])
            x = ''.join(x)
            if x in D:
                if D[x] == b-1:
                    flag = True
                    continue
                else:
                    G[b-1].add(D[x])
                    X[D[x]].add(b-1)
        if flag:
            continue
        else:
            print(""NO"")
            exit(0)
    X = [len(X[i]) for i in range(n)]
    ANS = []
    s = set()
    q = collections.deque()
    for i in range(n):
        if X[i] == 0:
            q.append(i)
            s.add(i)

    while(q):
        if len(ANS) == n:
            print(""NO"")
            exit(0)
        x = q.popleft()
        ANS.append(x+1)
        for y in G[x]:
            if X[y] == 0:
                continue
            else:
                X[y] -= 1
                if X[y] == 0:
                    q.append(y)
    if len(ANS) == n:
        print(""YES"")
        print(*ANS)
    else:
        print(""NO"")

main()
",np
"def dsum(n):
    return sum([int(c) for c in str(n)])

n, s = map(int, input().split(' '))
l = 1
r = n
while l <= r:
    mid = (l + r) // 2
    delta = mid - dsum(mid)
    if delta >= s:
        r = mid - 1
    else:
        l = mid + 1
print(n - l + 1)
",O(logn)
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",O(n ^ 2)
"class Solution(object):
    def longestBeautifulSubstring(self, word):
        result = 0
        l = cnt = 1
        for i in range(len(word)-1):
            if word[i] > word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] < word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result",O(n)
"n, l, r, x = map(int, input().split())
C = sorted(list(map(int, input().split())))
ANS = 0
for i in range(2 ** n):
    s = bin(i)[2:]
    s = '0' * (n - len(s)) + s
    L = []
    for j in range(n):
        if s[j] == '1':
            L.append(C[j])
    if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x:
        continue
    ANS += 1
print(ANS)
",np
"def tonum(count):
    return (count - 1) // 3

def check(n, k, logdivl):
    divl = 2**logdivl

    min_k = 2**(logdivl+1) - 2 - logdivl

    max_k = tonum(divl * divl + (divl * divl - (2*divl - 1)) * ((2**(n-logdivl))**2 - 1))

    return min_k <= k <= max_k

def main(n, k):
    if k == 1:
        return n - 1

    if n > 100:
        return n - 1

    if ((2 ** (n-1)) ** 2 - 1) // 3 + 1 >= k:
        return n -1

    for logdivl in range(1, n+1):
        if check(n, k, logdivl):
            return n - logdivl

    return None

t = int(input())
for i in range(t):
    n, k  = list(map(int, input().split()))
    ans = main(n, k)
    if ans is not None:
        print(""YES {}"".format(ans))
    else:
        print(""NO"")
",O(logn)
"l,r=tuple(map(int,input().split("" "")))
x=l^r
pow=1
while(pow<=x) :
    pow*=2

print(pow-1)",O(logn)
"n, a, b, c, T = map(int, input().split())
ts = list(map(int, input().split()))
ts.sort()
ans = 0
for t in ts:
    temp = -10**18
    for u in range(t, T+1):
        temp = max(temp, c*(u-t)+a-b*(u-t))

    ans += temp
print(ans)
",O(n)
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	lp=0
	while (len(q)>lp):
		x=q[lp]
		lp+=1
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",O(n ^ 3)
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs2(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]
vis=[]
tot=0
def dfs(root):
    global tot,vis,gp
    for child in gp[root]:
        if vis[child]==0:
            tot+=1
            vis[child]=1
            dfs(child)
pre=[[] for i in range(3)]
def hnbhai(tc):
    n=sb()
    d,num=0,1
    while num<=n:
        num+=9*(d+1)*(10**d)
        d+=1
    num-=9*(d)*(10**(d-1))
    ans=str(10**(d-1)+(n-num)//d)
    print(ans[(n-num)%d])
for _ in range(1):
    hnbhai(_+1)
",O(logn)
"import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

from math import sqrt,ceil

max_n=10**7+1
spf = [i for i in range(max_n)]

for i in range(4,max_n,2):
    spf[i]=2

for i in range(3,ceil(sqrt(max_n))):
    if (spf[i]==i):
        for j in range(i*i,max_n,i):
            if(spf[j]==j):
                spf[j]=i

from collections import Counter,defaultdict
from bisect import insort

def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x]
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)

t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)]
    recent=[n for i in range(k+1)]
    closest=defaultdict(lambda: -1)
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i
    dp=[[i for j in range(k+1)] for i in range(n+1)]

    dp[0]=[0 for j in range(k+1)]
    for i in range(n):
        for x in range(k+1):
            end=dp_depth[i][x]

            for y in range(k-x+1):
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1)
    print(dp[n][k])
",O(n ^ 3)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for j, v in enumerate(b):
	e[v][j] = j
	d[j].append(j)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"from collections import defaultdict
from collections import deque

class graph:
    def __init__(self):
        self.g=defaultdict(list)
    def addedge(self,u,v):
        self.g[u].append(v)
def router(values):
    gr=graph()
    for i in range(len(values)):
        gr.addedge(values[i], i+2)
    return gr.g

def isleaf(node,gr):
    if len(gr[node])==0:
        return True
    return False

def christmas(gr,start,visited):
    q=deque()
    q.append(start)
    visited[start]=True
    count=0
    while q:
        count=0
        value=q.popleft()
        for val in gr[value]:
            if not isleaf(val,gr):
                q.append(val)
                visited[val]=True
            else:
                visited[val]=True
                count=count+1
        if count<3:
            return 'No'
    if count<3:
        return 'No'
    return 'Yes'
n=int(input())
values=[]
for i in range(n-1):
    value=int(input())
    values.append(value)
gr=router(values)
visited=[False]*(n+1)
print(christmas(gr, 1, visited))
",O(n)
"def bin(a):
    if a <= 1:
        return a
    else:
        return 10*bin(a//2)+a%2

def convBin(a):
    k,i = 0,0
    while a!=0:
        k += (a%10)*int((2**i))
        a //= 10
        i += 1
    return k

def maxi(a,b):
    if a == b:
        return 0
    elif a+1 == b:
        return a^b
    elif a+2 == b:
        x = a^(a+1)
        y = a^(a+2)
        z = (a+1)^(a+2)
        return max(max(x,y),z)
    else:
        x = str(bin(a^b))
        y = '1'*len(x)
        return convBin(int(y))
a = list(map(int,input().split()))
print(maxi(a[0],a[1]))
",O(logn)
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))
",O(n ^ 2)
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD",O(logn)
"from sys import stdin, stdout
import sys
input=sys.stdin.readline

def solve(n, t, tasks):
    lo = 0
    hi = n

    res = []
    curr_res = 0

    tasks.sort(key=lambda x: x[1])

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        valid_tasks = []
        for i in tasks:
            if i[0] >= mid:
                valid_tasks.append(i)

        can_do = False

        curr_sum = 0
        total_used = 0
        r = []
        for i in valid_tasks:
            curr_sum += i[1]
            total_used += 1
            r.append(i[2])
            if curr_sum > t:
                break
            elif total_used >= mid:
                can_do = True
                curr_res = mid
                res = r
                break
        if can_do:
            lo = mid + 1
        else:
            hi = mid - 1
    return curr_res, res

def main():
    n, t = (int(x) for x in input().split("" ""))
    tasks = []
    nums = n
    idx = 1
    while n:
        a_i, t_i = (int(x) for x in input().split("" ""))
        tasks.append((a_i, t_i, idx))
        idx += 1
        n -= 1

    res, res_arry = solve(nums, t, tasks)
    print(res)
    print(res)
    stdout.write("" "".join(map(str, res_arry)))
    stdout.write(""\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"n = int(input())

d = {}

for i in range(n-1):
	a,b = map(int,input().split())

	try:
		d[a].append(b);
	except:
		d[a] = [b]
	try:
		d[b].append(a);
	except:
		d[b] = [a]

array = list(map(int,input().split()))
flag=0;

if array[0]==1:

	i = 1;
	j = 0;

	while ( j < n and i < n ):
		if ( array[j] in d[array[i]] ):
			i+=1;
		else:
			j+=1;
	if j==n and i!=n:
		flag=1;
else:
	flag=1;

if flag==1:
	print(""No"")
else:
	print(""Yes"")",O(n)
"class Solution(object):
    def partitionLabels(self, S):
        lookup = {c: i for i, c in enumerate(S)}
        first, last = 0, 0
        result = []
        for i, c in enumerate(S):
            last = max(last, lookup[c])
            if i == last:
                result.append(i-first+1)
                first = i+1
        return result",O(n)
"n,k=[int(i) for i in raw_input().split()]

M=10**9+7
def power(x,y):
    if y==0:
      return 1
    z=(power(x,y/2)**2)%M
    z=(z*x)%M if y%2 else z
    return z%M

z=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0
print(z)
",O(logn)
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 998244353;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    B();

dp = [];
def D():
    [n,k] = ti();
    a = ti();
    a = sorted(a);
    cnt = [0 for i in range(n)];
    for i in range(n):
        c = 0;
        for j in range(i,n):
            if a[j]-a[i] <= 5: c+=1;
            else:break;
        cnt[i] = c;

    global dp;
    dp = [[0 for j in range(k+1)] for i in range(n+1)];
    ans = 0;
    for i in range(n):
        for j in range(k+1):
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            if j+1 <= k:
                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);
    print(dp[n][k]);

def B():
    n = pi();
    a = ti();
    q = pi();

    mat = [[0 for j in range(n)] for i in range(n)];
    dp = [[0 for i in range(n)] for j in range(n)];
    for i in range(n):
        for j in range(n):
            if i == j:
                mat[i][j] = a[i];
                dp[i][j] = a[i];
    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];
            j += 1;
            i += 1;
        x += 1;

    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);
            j += 1;
            i += 1;
        x += 1;

    for i in range(q):
        [l,r] = ti();
        print(dp[l-1][r-1]);

main();",O(n ^ 2)
"a = list(input())
b = int(input())
a.sort(reverse=True)

ans=''
while a:
    for i in range(len(a)):
        temp=''
        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))
        if int(x)<=b:
            ans+=a[i]
            a=a[:i]+a[i+1:]
            break
print(int(ans))",O(n ^ 3)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  @bootstrap
  def solve(node, remain):
    if remain == 0:
      yield 0

    key = (node + remain * n * m)
    mem = dp[key]
    if mem != -1:
      yield mem

    result = []
    for x in adj[node]:
      result.append((yield solve(x[0], remain-1)) + x[1])
    ans = min(result)
    dp[key] = ans
    yield ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] < left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result",O(nlogn)
"from collections import deque
n, q = map(int, input().split())
a = deque(map(int, input().split()))
b = []
m = a.index(max(a))
for i in range(m):
    a0, a1 = a.popleft(), a.popleft()
    b.append([a0, a1])
    if a0 < a1:
        a0, a1 = a1, a0
    a.appendleft(a0)
    a.append(a1)
for i in range(q):
    c = int(input())
    if c <= m:
        print('{} {}'.format(b[c-1][0], b[c-1][1]))
    else:
        c -= m+1
        c %= n-1
        print('{} {}'.format(a[0], a[c+1]))
",O(n)
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):

        if grid[i - 1][j] == '
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",O(n ^ 2)
"from collections import Counter
from collections import defaultdict
import math
import random
import heapq as hq
from math import sqrt
import sys
from functools import reduce

def input():
    return sys.stdin.readline().strip()

def iinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rlinput():
    return list(rinput())

mod = int(1e9)+7

def factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

if __name__ == ""__main__"":
    n = iinput()
    a = rlinput()
    dp = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        dp[i][i] = a[i]

    for l in range(n-2, -1, -1):
        for r in range(l+1, n):
            for k in range(l, r):
                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:

                    dp[l][r] = dp[l][k]+1

    squeeze = [float('inf')]*(n+1)
    squeeze[0] = 0
    for i in range(1, n+1):
        for j in range(i):
            if dp[j][i-1] != 0:
                squeeze[i] = min(squeeze[i], squeeze[j]+1)

    print(squeeze[n])
",O(n ^ 3)
"n=int(input())
l1=list(map(int,input().split()))
if n%2==0:
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
else :
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1
print(' '.join(str(x) for x in l1))",O(n)
"a = [0,1]
n = int(input())
i=2
r=0
while r<n:
     r = a[i-1]+a[i-2]
     a.append(r)
     i+=1
l = len(a)-1
if n>3:
    print(a[l-4],a[l-3],a[l-1])
elif n==3:
    print(1,1,1)
elif n==2:
    print(0,1,1)
elif n==1:
    print(0,0,1)
elif n==0:
    print(0,0,0)",O(1)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(logn)
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        rotated = [[0] * n for _ in range(n)]

        for i in range(n):
            for j in range(n):
                rotated[j][n - 1 - i] = matrix[i][j]

        for i in range(n):
            for j in range(n):
                matrix[i][j] = rotated[i][j]
",O(n ^ 2)
"class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result",O(nlogn)
"import collections


class Solution(object):
    def kthDistinct(self, arr, k):
        count = collections.Counter(arr)
        arr = [x for x in arr if count[x] == 1]
        return arr[k-1] if k-1 < len(arr) else """"",O(n)
"import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):        
        delta = datetime.datetime.strptime(date1, ""%Y-%m-%d"")
        delta -= datetime.datetime.strptime(date2, ""%Y-%m-%d"")
        return abs(delta.days)",O(1)
"def Solution(N, Q, wariors_strength, arrows):

    prefix_sum = [0]
    for strength in wariors_strength:
        prefix_sum.append(prefix_sum[-1]+strength)
    prefix_sum.pop(0)
    arrow_so_far = 0
    for arrow in arrows:
        arrow_so_far += arrow
        if arrow_so_far >= prefix_sum[-1]:
            print(N)
            arrow_so_far = 0
        else:
            idx = binarySearch_LowerBound(prefix_sum, arrow_so_far)
            print(N-idx)

def binarySearch_LowerBound(arr, key):
    l = 0
    r = len(arr)-1

    while l <= r:
        mid = (l+r)//2
        if arr[mid] == key:
            return mid+1
        elif arr[mid] > key:
            r = mid-1
        else:
            l = mid+1
    return r+1

N, Q = map(int, input().split())
wariors_strength = list(map(int, input().split()))
arrows = list(map(int, input().split()))

Solution(N, Q, wariors_strength, arrows)
",O(nlogn)
"class Solution(object):
    def largestAltitude(self, gain):
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result",O(n)
"import collections



class Solution(object):
    def mostFrequentEven(self, nums):
        cnt = collections.Counter(x for x in nums if x%2 == 0)
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], -x)) if cnt else -1",O(n)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(int(k - res1 + 1));",O(logn)
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n)
"class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == """":
            return """"

        countT = {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        res, resLen = [-1, -1], float(""infinity"")
        for i in range(len(s)):
            countS = {}
            for j in range(i, len(s)):
                countS[s[j]] = 1 + countS.get(s[j], 0)

                flag = True
                for c in countT:
                    if countT[c] > countS.get(c, 0):
                        flag = False
                        break

                if flag and (j - i + 1) < resLen:
                    resLen = j - i + 1
                    res = [i, j]

        l, r = res
        return s[l : r + 1] if resLen != float(""infinity"") else """"
",O(n ^ 2)
"n, m = map(int, input().split())
s = 0
while m:
    s += n // m
    n, m = m, n % m
print(s)",O(1)
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",O(logn)
"class Solution(object):
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left",O(logn)
"n = int(input())
s = input()
x = s.count('0')
if s == '0':
    print('0')
else:
    print('1' + '0'*x)",O(n)
"n = int(input())
print((n//2)+1)",O(1)
"class Solution2(object):
    def minCost(self, costs):
        if not costs:
            return 0

        n = len(costs)
        for i in range(1, n):
            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

        return min(costs[n - 1])",O(n)
"MOD = 998244353

def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() :
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) :
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)]
    n = len(sx)
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) :
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) :
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) :
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = map(int, input().split())
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)
",O(n ^ 3)
"import sys
def countR(ip):
    c=0
    for i in ip:
        if(i=='R'):
            c+=1
    return c

def countB(ip):
    c=0
    for i in ip:
        if(i=='B'):
            c+=1
    return c

def countG(ip):
    c=0
    for i in ip:
        if(i=='G'):
            c+=1
    return c

t=int(sys.stdin.readline())
x='RGB'*680
y='GBR'*680
z='BRG'*680
for i in range(t):
    n,k=list(map(int,sys.stdin.readline().strip().split()))
    a=sys.stdin.readline().strip()
    xk=x[:k]
    yk=y[:k]
    zk=z[:k]

    op=2001
    for j in range(n-k+1):
        b=a[j:j+k]

        xd=0
        yd=0
        zd=0

        for jj in range(len(b)):
            if(b[jj]!=xk[jj]):
                xd+=1
            if(b[jj]!=yk[jj]):
                yd+=1
            if(b[jj]!=zk[jj]):
                zd+=1

        op=min(op,xd,yd,zd)
    print(op)
",O(n ^ 2)
"class Solution2(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))
        return [MAX_V if i < q else MIN_V+r if i == q else MIN_V  for i in range(n)]",O(n)
"from collections import defaultdict
from itertools import accumulate
import sys
input = sys.stdin.readline

inf = 100000000000000000
mod = 998244353

n, m ,k= map(int, input().split())
M=[]
S=[]
F=[]
for i in range(n):
    M.append(input().strip())
for i in range(m):
    tmp1, tmp2 = input().split()
    S.append(tmp1)
    F.append(int(tmp2)-1)

TRAN_dict=defaultdict(int)
TRAN_dict['_']=0
for i in range(97,97+26):
    TRAN_dict[chr(i)]=i-96;

def cal(X):
    base=1
    number=0
    for x in X:
        number=number*base+TRAN_dict[x]
        base*=27
    return number

STONE=defaultdict(int)
for i in range(n):
    STONE[cal(list(M[i]))]=i

def check(X,result):
    number=cal(X)
    if number in STONE.keys():
        result.append(STONE[number])

bian=[[] for i in range(n)]
du=[0]*n

for i in range(m):
    gain=[]
    for digit in range(1<<k):
        now=list(S[i])
        tmp=bin(digit)
        tmp=tmp[2:]
        tmp='0'*(k-len(tmp))+tmp
        for j in range(k):
            if tmp[j]=='1':
                now[j]='_'
        check(now,gain)
    if F[i] not in gain:
        print(""NO"")
        sys.exit(0)
    for x in gain:
        if x!=F[i]:
            bian[F[i]].append(x)
            du[x]+=1

from collections import deque
QUE=deque()
for i in range(n):
    if du[i]==0:
        QUE.append(i)
TOP_SORT=[]
while QUE:
    now=QUE.pop()
    TOP_SORT.append(now)
    for to in bian[now]:
        du[to]-=1
        if du[to]==0:
            QUE.append(to)
if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
",np
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i






class Solution(object):
    def __init__(self):
        self.__buf4 = [''] * 4
        self.__i4 = 0
        self.__n4 = 0

    def read(self, buf, n):
        i = 0
        while i < n:
            if self.__i4 < self.__n4: 
                buf[i] = self.__buf4[self.__i4]
                i += 1
                self.__i4 += 1
            else:
                self.__n4 = read4(self.__buf4) 
                if self.__n4:
                    self.__i4 = 0
                else: 
                    break

        return i",O(n)
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def minCut(self, s):
        lookup = [[False for j in range(len(s))] for i in range(len(s))]
        mincut = [len(s) - 1 - i for i in range(len(s) + 1)]

        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):
                    lookup[i][j] = True
                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)

        return mincut[0]",O(n ^ 2)
"print(sum(i for i in range(int(input()),-1,-2)))",O(n)
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"from sys import stdin
from itertools import permutations

rints = lambda: [int(x) for x in stdin.readline().split()]
x1, y1, x2, y2, x3, y3 = rints()

for x in [[x1, y1], [y1, x1]]:
    for y in [[x2, y2], [y2, x2]]:
        for z in [[x3, y3], [y3, x3]]:
            if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]:
                print(x[1])
                print('\n'.join(
                    ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in
                                                                                             range(z[0])]))
                exit()

for per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3):
    for x in per[0][:-1]:
        for y in per[1][:-1]:
            for z in per[2][:-1]:
                if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]:
                    print(x[1])
                    print('\n'.join(
                        [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in
                                                                    range(y[0])]))
                    exit()

print(-1)
",np
"class Solution3(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            dp = [0]*n 
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    dp[u] = price[u]
                    for v in adj[u]:
                        if v == p:
                            continue
                        dp[u] = max(dp[u], dp[v]+price[u])
            return dp
        
        def iter_dfs2():
            result = 0
            stk = [(0, -1, 0)]
            while stk:
                u, p, curr = stk.pop()
                result = max(result, curr, dp[u]-price[u])
                top2 = [[curr, p], [0, -1]]
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = [dp[v], v]
                    for i in range(len(top2)):
                        if curr > top2[i]:
                            top2[i], curr = curr, top2[i]
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs()
        return iter_dfs2()",O(n)
"class Solution(object):
    def maximumSumOfHeights(self, maxHeights):
        left = [0]*len(maxHeights)
        stk = [-1]
        curr = 0
        for i in range(len(maxHeights)):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (j-stk[-1])*maxHeights[j]
            curr += (i-stk[-1])*maxHeights[i]
            stk.append(i)
            left[i] = curr
        stk = [len(maxHeights)]
        result = right = curr = 0
        for i in reversed(range(len(maxHeights))):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (stk[-1]-j)*maxHeights[j]
            curr += (stk[-1]-i)*maxHeights[i]
            stk.append(i)
            right = curr
            result = max(result, left[i]+right-maxHeights[i])
        return result",O(n)
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",O(n)
"import math
import collections
import bisect
import heapq
import time
import itertools
import sys

Q = int(input())
ans = []

for i in range(Q):
    l, r = map(int, input().split())
    if l % 2 == 0 and r % 2 == 0:
        ans.append((r-l)//2 + l)
    elif l % 2 == 1 and r % 2 == 0:
        ans.append((r-l+1)//2)
    elif l % 2 == 1 and r % 2 == 1:
        ans.append(0-(r-l)//2-l)
    else:
        ans.append(0-(r-l+1)//2)

print('\n'.join(map(str, ans)))",O(1)
"import sys
n = int(input())
a = [int(i) for i in input().split()]
a.sort()
t = 0
for i in range(1,n):
	t += a[i]==a[i-1]
if t >= 2:
	print(""cslnb"")
	sys.exit(0)
if t:
	for i in range(n):
		if a[i]==a[i+1]:
			if a[i] and a[i]!=a[i-1]+1:
				a[i] -= 1
				break
			else:
				print(""cslnb"")
				sys.exit(0)
print([""cslnb"",""sjfnb""][(sum(a)-t-n*(n-1)//2)&1])
",O(nlogn)
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1",O(n ^ 2)
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            sys.exit()
    c+=aux
    c1+=1
print(""Yes"")
",O(nlogn)
"n,v=[int(x) for x in input().split()]
if v>=(n-1):
    print(n-1)
else:
    print(int((((n-v)*(n-v+1))/2)-1+v))
",O(1)
"class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def dfs(node, depth):
            if not node:
                return None
            if depth == len(res):
                res.append(node.val)

            dfs(node.right, depth + 1)
            dfs(node.left, depth + 1)

        dfs(root, 0)
        return res
",O(n)
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",O(1)
"import collections


class Solution(object):
    def subarraysWithKDistinct(self, A, K):
        def atMostK(A, K):
            count = collections.defaultdict(int)
            result, left = 0, 0
            for right in range(len(A)):
                count[A[right]] += 1
                while len(count) > K:
                    count[A[left]] -= 1
                    if count[A[left]] == 0:
                        count.pop(A[left])
                    left += 1
                result += right-left+1
            return result
        
        return atMostK(A, K) - atMostK(A, K-1)",O(n)
"n = int(input())
a = input().split()
d = {}
k = 0
for i in range(len(a)):
    d[a[i]] = i
for s in input().split():
    if d[s] != -1:
        c = d[s]
        print(c - k + 1, end=' ')
        for i in range(k, c + 1):
            d[a[i]] = -1
        k = c + 1
    else:
        print(0, end=' ')
",O(n)
"def check(mid,n,m,arr):
	masks = {}
	for index in range(n):
		array = arr[index]
		x = 0
		for i in range(m):
			if array[i] >= mid:
				x ^= (1<<i)
		masks[x] = index+1
	ans = False
	a,b = 1,1
	if (1<<m)-1 in masks.keys():
		return True,(masks[(1<<m)-1],masks[(1<<m)-1])
	for i in  masks.keys():
		for j in masks.keys():
			orAns = i|j
			if(orAns == ((1<<m)-1)):
				if i == (1<<m)-1 and (i in masks.keys()):
					a = masks[i]
					ans = True
					break
				elif j == (1<<m)-1 and (j in masks.keys()):
					b =  masks[j]
					ans = True
					break
				elif (i in masks.keys()) and (j in masks.keys()):
					ans = True
					a,b = masks[i],masks[j]
					break
	return ans,(a,b)

def solve(n,m,arr):
	mini = 0
	maxi = int(1e9)+5
	i,j = 1,1
	while(mini<=maxi):
		mid = (mini+maxi)//2
		ans,res = check(mid,n,m,arr)
		if(ans):
			i,j = res
			mini =mid +1
		else:
			maxi = mid -1
	print(i,j)

def main():
	n,m = map(int,input().split(' '))
	arr = []
	for _ in range(n):
		x = list(map(int,input().split(' ')))
		arr.append(x)
	solve(n,m,arr)

main()",np
"n = int(input())
b = list(map(int, input().split()))
a = [0] * (2 * (len(b)))
a[-1] = b[0]
for i in range(1, len(b)):
    if b[i] - a[i - 1] <= a[-i]:
        a[i] = a[i - 1]
        a[-i - 1] = b[i] - a[i - 1]
    else:
        a[-i - 1] = a[-i]
        a[i] = b[i] - a[-i - 1]
print(*a)
",O(n)
"import os
import sys
from io import BytesIO, IOBase

def get(a,x):
    return (a[0][x] == ""0"") + (a[1][x] == ""0"")

def main():
    a=[input().rstrip() for _ in range(2)]
    n=len(a[0])
    if n==1:
        print(0)
    else:
        dp=[[-1,-1,-1] for _ in range(n)]
        z=get(a,0)
        dp[0][z]=0
        for i in range(1,n):
            z=get(a,i)
            if z==0:
                dp[i][0]=max(dp[i-1])
            elif z==1:
                dp[i][0]=dp[i-1][2]+1
                dp[i][1]=max(dp[i-1])
            elif z==2:
                dp[i][0]=max(dp[i-1][1]+1,dp[i-1][2]+(i!=1))
                dp[i][1]=dp[i-1][2]+1
                dp[i][2]=max(dp[i-1])
        print(max(dp[-1]))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(1)
"a,b = map(int,input().split())
ans = 0
if(a > b):
    ans += int(a//b)
    a = a%b
while(b!=0):
    ans += int(a//b)
    a,b = b,a%b
print(ans)",O(1)
"import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] > limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1 
        return len(nums)-left",O(n)
"class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0 or s[0] == '0':
            return 0
        prev, prev_prev = 1, 0
        for i in range(len(s)):
            cur = 0
            if s[i] != '0':
                cur = prev
            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):
                cur += prev_prev
            prev, prev_prev = cur, prev
        return prev",O(n)
"import math, sys

def mp():
    return list(map(int, input().split()))

def main():
    n, m, k, l = mp()
    ost = n - k
    need = (l + k)
    if ost < l or need > n:
        print(-1)
        return
    ans = (l + k - 1) // m + 1
    if ans * m - k >= l and ans * m <= n:
        print(ans)
    else:
        print(-1)

deb = 0
if deb:
    file = open(""input.txt"", ""r"")
    input = file.readline
else:
    input = sys.stdin.readline

main()

if deb:
    file.close()
",O(1)
"def solve(n, m, x, t):
    r = [0] * n
    d = [0] * m
    ans = [0] * m
    cr = 0
    cd = 0
    for i in range(n+m):
        if t[i]:
            d[cd] = x[i]
            cd += 1
        else:
            r[cr] = x[i]
            cr += 1
    cn = 0
    for i in range(m-1):
        mid = (d[i] + d[i+1]) // 2
        while cn < n and r[cn] <= mid:
            cn += 1
            ans[i] += 1
    ans[-1] += n - sum(ans)
    return ' '.join(str(i) for i in ans)

def main():
    n, m = [int(i) for i in input().split()]
    x = [int(i) for i in input().split()]
    t = [int(i) for i in input().split()]
    print(solve(n, m, x, t))

main()
",O(n)
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",O(n ^ 3)
"n, m, v = map(lambda x: int(x) + 1, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
dp = []
for i in range(n):
    dp.append([])
    for j in range(m):
        dp[i].append([0] * v)
a.sort(reverse=1)
b.sort(reverse=1)
c.sort(reverse=1)
a = [0] + a
b = [0] + b
c = [0] + c
ans = 0
for i in range(n):
    for j in range(m):
        for k in range(v):
            if i == j == k == 0:
                continue
            if i == j == 0 or i == k == 0 or j == k == 0:
                continue
            if i == 0:
                dp[i][j][k] = dp[i][j - 1][k - 1] + \
                              b[j] * c[k]
            elif j == 0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + \
                              a[i] * c[k]
            elif k == 0:
                dp[i][j][k] = dp[i - 1][j - 1][k] + \
                              a[i] * b[j]
            else:
                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],
                                  dp[i - 1][j][k - 1] + a[i] * c[k],
                                  dp[i][j - 1][k - 1] + b[j] * c[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",O(logn)
"class Solution(object):
    def minIncrements(self, n, cost):
        result = 0
        for i in reversed(range(n//2)):
            result += abs(cost[2*i+1]-cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return result",O(n)
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"class Solution(object):
    def pathsWithMaxScore(self, board):
        MOD = 10**9+7
        directions = [[1, 0], [0, 1], [1, 1]]
        dp = [[[0, 0] for r in range(len(board[0])+1)]
              for r in range(2)]
        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]
        for r in reversed(range(len(board))):
            for c in reversed(range(len(board[0]))):
                if board[r][c] in ""XS"":
                    continue
                dp[r%2][c] = [0, 0]
                for dr, dc in directions:
                    if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]
                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD
                if dp[r%2][c][1] and board[r][c] != 'E':
                    dp[r%2][c][0] += int(board[r][c])
        return dp[0][0]",O(n ^ 2)
"S = input()

ans = 0
met = set()

for i in range(len(S)):
    for j in range(i, -1, -1):
        if S[j:i+1] in met:
            ans = max(ans, i - j + 1)
        else:
            met.add(S[j:i+1])

print(ans)",O(n ^ 3)
"n, m, k = map(int, input().split())
reb1 = [list(map(int, input().split())) for i in range(n)]
reb2 = [list(map(int, input().split())) for i in range(n - 1)]
if k % 2:
    for i in range(n):
        for j in range(m):
            print(-1, end="" "")
        print()
    exit(0)
minsum = [[0] * m for i in range(n)]
nminsum = [[0] * m for i in range(n)]
for it in range(k // 2):
    for i in range(n):
        for j in range(m):
            cmin = 1000000000010
            if i != 0:
                cmin = min(cmin, minsum[i - 1][j] + reb2[i - 1][j])
            if i != n - 1:
                cmin = min(cmin, minsum[i + 1][j] + reb2[i][j])
            if j != 0:
                cmin = min(cmin, minsum[i][j - 1] + reb1[i][j - 1])
            if j != m - 1:
                cmin = min(cmin, minsum[i][j + 1] + reb1[i][j])
            nminsum[i][j] = cmin
    for i in range(n):
        for j in range(m):
            minsum[i][j] = nminsum[i][j]
for i in minsum:
    for j in i:
        print(j * 2, end="" "")
    print()
",O(n ^ 3)
"def lower_bound(n, k):
    low = 1
    high = k
    while low < high:
        mid = low + (high - low) // 2
        pipes = mid * k - (mid + 2) * (mid - 1) // 2
        if pipes >= n:
            high = mid
        else:
            low = mid + 1
    return low

def main():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        ans = lower_bound(n, k)
        if ans == k:
            print(-1)
        else:
            print(ans)

if __name__ == ""__main__"":
    main()",O(logn)
"a = list(map(int, input().split()))
b = list(map(int, input().split()))
a1 = min(a[::2])
b1 = max(a[::2])
c1 = min(a[1::2])
d1 = max(a[1::2])
g  = sum(b[::2]) / 4
h  = sum(b[1::2]) / 4
r  = abs(b[0] - g) + abs(b[1] - h)
for i in range(a1, b1+1) :
    for j in range(c1, d1+1) :
        if abs(i-g) + abs(j-h) <= r:
            print(""YES"")
            exit()
print(""NO"")
",O(1)
"N = 405
n, m = map(int, input().split())
dp = [[0]*N for _ in range(N)]
c = [[1]*N for _ in range(N)]
p = [0]*N

p[0] = 1
for i in range(1, N):
    p[i] = (p[i-1]*2) % m
for i in range(1, N):
    for j in range(1, i):
        c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m

dp[0][0] = 1
for i in range(2, n+2):
    for x in range(1, (n-1)//2 + 2):
        for k in range(1, i):
            dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m
ans = 0
for i in range(1, (n-1)//2 + 2):
    ans = (ans + dp[n+1][i]) % m
print(ans)",O(n ^ 3)
"class Solution2(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt1 = cnt2 = 1
        for i in range(1, len(nums)):
            cnt1 = cnt1+1 if nums[i-1] < nums[i] else 1
            cnt2 = cnt2+1 if nums[i-1] > nums[i] else 1
            result = max(result, cnt1, cnt2)
        return result",O(n)
"class MinStack:
    def __init__(self):
        self.min = float('inf')
        self.stack = []

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self) -> None:
        if not self.stack:
            return

        pop = self.stack.pop()

        if pop < 0:
            self.min = self.min - pop

    def top(self) -> int:
        top = self.stack[-1]
        if top > 0:
            return top + self.min
        else:
            return self.min

    def getMin(self) -> int:
        return self.min
",O(1)
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):

        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):

                tmp = dp[j]

                if dp[j] != -1 and i+dp[j] < N and t[i+dp[j]] == c:
                    tmp = dp[j]+1

                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")
",O(n ^ 3)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])
",O(n)
"def arr_inp():
    return [int(x) for x in stdin.readline().split()]

def nCr(n, r):
    f, m = factorial, 1
    for i in range(n, n - r, -1):
        m *= i
    return int(m // f(r))

from math import factorial
from sys import stdin

n, a, ans, tem = int(input()), arr_inp(), [], 0
mem = [0] * (n + 1)

for i in range(n):
    for j in range(a[i] - 1, 0, -1):
        if not mem[j]:
            tem += 1
    mem[a[i]] = 1

for i in range(int(input())):
    l, r = arr_inp()
    tem += nCr(r - l + 1, 2)
    ans.append('odd' if tem % 2 else 'even')

print('\n'.join(ans))
",O(n ^ 2)
"n = int(input())
print(n**2 + (n-1)**2)
",O(1)
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution(object):
    def checkDistances(self, s, distance):
        for i in range(len(s)):
            if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]:
                return False
            distance[ord(s[i])-ord('a')] = -1
        return True",O(n)
"class Solution(object):
    def numberOfWays(self, n, x):
        MOD = 10**9+7

        dp = [0]*(n+1)
        dp[0] = 1
        for i in range(1, n+1):
            i_pow_x = i**x
            if i_pow_x > n:
                break
            for j in reversed(range(i_pow_x, n+1)):
                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD
        return dp[-1]",O(n ^ 2)
"x,k=[int(i) for i in input().split()]
if x!=0:
    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)
else:
    print(0)
",O(logn)
"def get_colors(x1, y1, x2, y2):
    w = x2 - x1 + 1
    h = y2 - y1 + 1
    if w % 2 == 0 or h % 2 == 0:
        black = w * h // 2
        white = w * h // 2
    else:
        oddx = w // 2
        if x1 % 2 == 1 and x2 % 2 == 1:
            oddx += 1
        oddy = h // 2
        if y1 % 2 == 1 and y2 % 2 == 1:
            oddy += 1
        evenx = w // 2
        if x1 % 2 == 0 and x2 % 2 == 0:
            evenx += 1
        eveny = h // 2
        if y1 % 2 == 0 and y2 % 2 == 0:
            eveny += 1
        white = oddx * oddy + evenx * eveny
        black = w * h - white
    return white, black

def get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    if ax1 > bx2:
        return None, None, None, None
    if bx1 > ax2:
        return None, None, None, None
    if ay1 > by2:
        return None, None, None, None
    if by1 > ay2:
        return None, None, None, None
    return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2)

t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    white, black = get_colors(1, 1, m, n)
    wx1, wy1, wx2, wy2 = map(int, input().split())
    w, b = get_colors(wx1, wy1, wx2, wy2)
    white += b
    black -= b
    bx1, by1, bx2, by2 = map(int, input().split())
    ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2)
    if ix1 is not None:
        w, b = get_colors(ix1, iy1, ix2, iy2)
        white -= b
        black += b
    w, b = get_colors(bx1, by1, bx2, by2)
    white -= w
    black += w
    print(white, black)",O(1)
"class Solution(object):
    def prisonAfterNDays(self, cells, N):
        N -= max(N-1, 0) // 14 * 14 
        for i in range(N):
            cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1, 7)] + [0]
        return cells",O(1)
"class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(nlogn)
"n,d,k=map(int,input().split())
if n==1:
  print(""NO"")
  exit()
if k==1:
  if n==2 and d==1:
    print(""YES"")
    print(1,2)
  else:
    print(""NO"")
  exit()
if n<d+1:
  print(""NO"")
  exit()
co=1
ans=[]
for i in range(1,d+1):
  ans.append((i,i+1))
  co+=1
def dfs(r,dist,co):
  if 2<=r<=d:
    t=k-2
  else:
    t=k-1
  if co==n:
    return co
  for _ in range(t):
    if dist==d:
      return co
    if co==n:
      return co
    co+=1
    ans.append((r,co))
    co=dfs(co,dist+1,co)
  return co
for i in range(2,d+1):
  co=dfs(i,max(i-1,d-i+1),co)
if co==n:
  print(""YES"")
  for j in ans:
    print(*j)
else:
  print(""NO"")",O(n ^ 2)
"n=int(input())
if n==1:
    exit(print(1))
y=n
i=1
while n!=0:
    j=n//2+n%2
    if i*2>y and n==1:
        i=i>>1
        x=y//i
        print(i*x)
    else:
        print((str(i)+' ')*j,end='')
    i=i<<1
    n=n//2",O(nlogn)
"class Solution(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        count = [0]*(MAX_NUM+1)
        for num in nums:
            count[num] += 1
        n = len(nums)
        for i in range(len(count)):
            if i == n:
                return i
            n -= count[i]
        return -1",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def buildTree(self, inorder, postorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder))

    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(postorder[post_end - 1])
        i = lookup[postorder[post_end - 1]]
        node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i)
        node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end)
        return node",O(n)
"class Solution2(object):
    def maxPathSum(self, root):
        def dfs(node):
            if not node:
                return (float(""-inf""), 0)
            max_left, curr_left = dfs(node.left)
            max_right, curr_right = dfs(node.right)
            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),
                    node.val+max(curr_left, curr_right, 0))
        
        return dfs(root)[0]",O(n)
"class Solution(object):
    def isOneBitCharacter(self, bits):
        parity = 0
        for i in reversed(range(len(bits)-1)):
            if bits[i] == 0:
                break
            parity ^= bits[i]
        return parity == 0",O(n)
"import time
from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque
from collections import Counter

def read():
    return int(input())

def readmap():
    return map(int, input().split())

def readlist():
    return list(map(int, input().split()))

n, m = readmap()
X = []
D = []
for _ in range(m):
    x, d = readmap()
    X.append(x)
    D.append(d)

summ = n * sum(X)

for i in range(m):
    d = D[i]
    if d < 0:
        if n % 2 == 1:
            summ += d * (n // 2) * (n // 2 + 1)
        else:
            summ += d * (n // 2) * (n // 2)
    else:
        summ += d * (n - 1) * n // 2

print(summ / n)",O(n)
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",O(n ^ 2)
"from sys import stdin,stdout

mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",O(n)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import sys

M = mod = 10 ** 9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]

n = val()
l = li()
c = li()

element = l[0]
for i in range(1, n):element = math.gcd(element, l[i])

if element != 1:
    print(-1)
    exit()

myset = {}

for ind, i in enumerate(l):
    for j in list(myset):
        temp = math.gcd(j, i)
        if(temp not in myset):myset[temp] = myset[j] + c[ind]
        else:myset[temp] = min(myset[temp], c[ind] + myset[j])

    if i not in myset:myset[i] = c[ind]
    else:myset[i] = min(myset[i], c[ind])

print(myset[1])",np
"from collections import defaultdict as dd, deque
import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,q = map(int,input().split())
S = [int(x) for x in input().split()]
Q = deque(S)

n = len(Q)
res = []
for i in range(n):
    a = Q.popleft()
    b = Q.popleft()
    Q.appendleft(max(a,b))
    Q.append(min(a,b))
    res.append((a,b))

A = list(Q)

def solve(t):
    if t < len(res):
        return res[t-1]
    t -= len(res) + 1
    t %= n-1
    return A[0],A[t+1]

for _ in range(q):
    t = int(input())
    print(*solve(t))
",O(n)
"class Solution2(object):
    def minEdgeReversals(self, n, edges):
        def dfs1(u, p):
            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)

        def dfs2(u, curr):
            result[u] = curr
            for v in adj[u]:
                if result[v] == -1:
                    dfs2(v, curr-adj[u][v]+adj[v][u])
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        result = [-1]*n
        dfs2(0, dfs1(0, -1))
        return result",O(n)
"n = int(input())
visit = [0 for i in range(n+1)]
res = []
c = 0
s,t=0,0
def do(i):
	global c,s,t
	for j in range(i,n+1,2*i):
		res.append(i)
		c += 1
		if c >= (n-1) and n>2:
			if s == 0:
				s = j
			else:
				t = j
	return res
curr = 0
i = 1
while(i<=n):

	do(i)
	i = 2*i
if n>2:
	res[n-1] = max(s,t)

for i in res:
	print(i,end="" "")",O(nlogn)
"class Solution(object):
    def maxScoreSightseeingPair(self, A):
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result",O(n)
"def check(n,p):
    k=str(n)
    k=k[::-1]
    s=0
    for j in range(len(k)):
        s+=(int(k[j])*(10**j-1))
    if s>=p:
        return 1
    else:
        return 0

n,s=map(int,input().split())
l=1
h=n
k=0
while(l<=h):
    m=(l+h)//2
    if check(m,s)==0:
        l=m+1
    else:
        h=m-1
    k+=1
print(n-l+1)
",O(logn)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if flag:
                return max(0, nums[i] + dfs(i + 1, True))
            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))
        return dfs(0, False)
",O(2 ^ n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2:
            return False

        def dfs(i, target):
            if i >= len(nums):
                return target == 0
            if target < 0:
                return False

            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])

        return dfs(0, sum(nums) // 2)
",O(2 ^ n)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:

        def dfs(i):
            if i >= len(nums):
                return 0
            return max(dfs(i + 1),
                       nums[i] + dfs(i + 2))

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        def dfs(i):
            if i >= len(cost):
                return 0
            return cost[i] + min(dfs(i + 1), dfs(i + 2))

        return min(dfs(0), dfs(1))
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = [False] * n
        posDiag = [False] * (n * 2)
        negDiag = [False] * (n * 2)
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if col[c] or posDiag[r + c] or negDiag[r - c + n]:
                    continue
                col[c] = True
                posDiag[r + c] = True
                negDiag[r - c + n] = True
                board[r][c] = ""Q""

                backtrack(r + 1)

                col[c] = False
                posDiag[r + c] = False
                negDiag[r - c + n] = False
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if flag:
                return max(0, nums[i] + dfs(i + 1, True))
            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))
        return dfs(0, False)
",O(2 ^ n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2:
            return False

        def dfs(i, target):
            if i >= len(nums):
                return target == 0
            if target < 0:
                return False

            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])

        return dfs(0, sum(nums) // 2)
",O(2 ^ n)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:

        def dfs(i):
            if i >= len(nums):
                return 0
            return max(dfs(i + 1),
                       nums[i] + dfs(i + 2))

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        def dfs(i):
            if i >= len(cost):
                return 0
            return cost[i] + min(dfs(i + 1), dfs(i + 2))

        return min(dfs(0), dfs(1))
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = [False] * n
        posDiag = [False] * (n * 2)
        negDiag = [False] * (n * 2)
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if col[c] or posDiag[r + c] or negDiag[r - c + n]:
                    continue
                col[c] = True
                posDiag[r + c] = True
                negDiag[r - c + n] = True
                board[r][c] = ""Q""

                backtrack(r + 1)

                col[c] = False
                posDiag[r + c] = False
                negDiag[r - c + n] = False
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
