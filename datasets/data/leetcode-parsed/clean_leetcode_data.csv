code,complexity
"class Solution(object):
    def minimumLines(self, stockPrices):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        stockPrices.sort()
        result = 0
        prev = None
        for i in range(1, len(stockPrices)):
            dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]
            g = gcd(dy, dx)
            if not prev or prev != (dy//g, dx//g):
                prev = (dy//g, dx//g)
                result += 1
        return result",O(nlogn)
"class Solution(object):
    def lastVisitedIntegers(self, words):
        PREV = ""prev""
        result, stk = [], []
        i = -1
        for x in words:
            if x == PREV:
                result.append(stk[i] if i >= 0 else -1)
                i -= 1
                continue
            stk.append(int(x))
            i = len(stk)-1
        return result",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def increasingBST(self, root):
        def increasingBSTHelper(root, tail):
            if not root:
                return tail
            result = increasingBSTHelper(root.left, root)
            root.left = None
            root.right = increasingBSTHelper(root.right, tail)
            return result
        return increasingBSTHelper(root, None)

",O(n)
"MOD = 10**9+7
FACT, INV, INV_FACT = [[1]*2 for _ in range(3)]
def nCr(n, k):
    if n < k:
        return 0
    while len(INV) <= n: 
        FACT.append(FACT[-1]*len(INV) % MOD)
        INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
        INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
    return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD


class Solution(object):
    def minMaxSums(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = 0
        cnt = 1
        for i in range(len(nums)):
            result = (result+(nums[i]+nums[~i])*cnt)%MOD
            cnt = (cnt*2-nCr(i, k-1)) % MOD
        return result",O(nlogn)
"class Solution(object):
    def countFairPairs(self, nums, lower, upper):
        def count(x):
            cnt = 0
            left, right = 0, len(nums)-1
            while left < right:
                if nums[left]+nums[right] <= x:
                    cnt += right-left
                    left += 1
                else:
                    right -= 1
            return cnt
        
        nums.sort()
        return count(upper)-count(lower-1)",O(nlogn)
"class Solution(object):
    def countCollisions(self, directions):
        result = cnt = 0
        smooth = 1
        for x in directions:
            if x == 'R':
                cnt += 1
            elif x == 'S' or (cnt or not smooth):
                result += cnt+int(x == 'L')
                cnt = smooth = 0
        return result",O(n)
"class Solution(object):
    def transformArray(self, nums):
        cnt = 0
        for x in nums:
            if x%2:
                continue
            nums[cnt] = 0
            cnt += 1
        for i in range(cnt, len(nums)):
            nums[i] = 1
        return nums",O(n)
"class Solution(object):
    def sumDistance(self, nums, s, d):
        MOD = 10**9+7
        for i in range(len(nums)):
            nums[i] += d if s[i] == 'R' else -d
        nums.sort()
        return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums)))",O(nlogn)
"class Solution(object):
    def largeGroupPositions(self, S):
        result = []
        i = 0
        for j in range(len(S)):
            if j == len(S)-1 or S[j] != S[j+1]:
                if j-i+1 >= 3:
                    result.append([i, j])
                i = j+1
        return result",O(n)
"class Solution(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        curr = 0
        prefix = [0]*(len(strength)+1)
        for i in range(len(strength)):
            curr = (curr+strength[i])%MOD
            prefix[i+1] = (prefix[i]+curr)%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD
            stk.append(i)
        return result",O(n)
"class Solution2(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in range(len(strength)):
            prefix[i+1] = (prefix[i]+strength[i])%MOD
            prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD
        suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in reversed(range(len(strength))):
            suffix[i] = (suffix[i+1]+strength[i])%MOD
            suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+
                                               (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def timeTaken(self, edges):
        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr

        def bfs():
            q = [(0, -1, 0)]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0][0], curr)
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr)))
                q = new_q
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        topological_traversal()
        result = [0]*(len(edges)+1)
        bfs()
        return result",O(n)
"class Solution2(object):
    def timeTaken(self, edges):
        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            result[u] = max(dp[u][0][0], curr)
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        dfs1(0, -1)
        result = [0]*(len(edges)+1)
        dfs2(0, -1, 0)
        return result",O(n)
"

class Solution(object):
    def sortPeople(self, names, heights):
        order = list(range(len(names)))
        order.sort(key=lambda x: heights[x], reverse=True)
        return [names[i] for i in order]
",O(nlogn)
"class Solution(object):
    def longestBeautifulSubstring(self, word):
        result = 0
        l = cnt = 1
        for i in range(len(word)-1):
            if word[i] > word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] < word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result",O(n)
"class Solution(object):
    def subsetXORSum(self, nums):
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)",O(n)
"import itertools



class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        result = []
        dp = [0, expressCost] 
        for r, e in zip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result",O(n)
"class Solution(object):
    def maxDistance(self, s, k):
        result = x = y = 0
        for i, c in enumerate(s, 1):
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            result = max(result, min(abs(x)+abs(y)+2*k, i))
        return result",O(n)
"import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        total = sum(itertools.islice(calories, 0, k))
        result = int(total > upper)-int(total < lower)
        for i in range(k, len(calories)):
            total += calories[i]-calories[i-k]
            result += int(total > upper)-int(total < lower)
        return result",O(n)
"import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1",O(n ^ 2)
"class Solution(object):
    def maxScore(self, cardPoints, k):
        result, total, curr, left = float(""inf""), 0, 0, 0
        for right, point in enumerate(cardPoints):
            total += point
            curr += point
            if right-left+1 > len(cardPoints)-k:
                curr -= cardPoints[left]
                left += 1
            if right-left+1 == len(cardPoints)-k:
                result = min(result, curr)
        return total-result",O(n)
"from collections import Counter

class Solution(object):
    def originalDigits(self, s):
        cnts = [Counter(_) for _ in [""zero"", ""one"", ""two"", ""three"", \
                                     ""four"", ""five"", ""six"", ""seven"", \
                                     ""eight"", ""nine""]]

        order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

        unique_chars = ['z', 'o', 'w', 't', 'u', \
                        'f', 'x', 's', 'g', 'n']

        cnt = Counter(list(s))
        res = []
        for i in order:
            while cnt[unique_chars[i]] > 0:
                cnt -= cnts[i]
                res.append(i)
        res.sort()

        return """".join(map(str, res))",O(n)
"class Solution(object):
    def toHexspeak(self, num):
        lookup = {0:'O', 1:'I'}
        for i in range(6):
            lookup[10+i] = chr(ord('A')+i)
        result = []
        n = int(num)
        while n:
            n, r = divmod(n, 16)
            if r not in lookup:
                return ""ERROR""
            result.append(lookup[r])
        return """".join(reversed(result))",O(logn)
"class Solution2(object):
    def toHexspeak(self, num):
        result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I')
        return result if all(c in ""ABCDEFOI"" for c in result) else ""ERROR""",O(n)
"import itertools



class Solution(object):
    def minimumTime(self, jobs, workers):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        jobs.sort()
        workers.sort()
        return max(ceil_divide(j, w) for j, w in zip(jobs, workers))",O(nlogn)
"MAX_N = 1000
MOD = 10**9+7
dp = [[0]*MAX_N for _ in range(MAX_N)]
for i in range(len(dp)):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%MOD


class Solution(object):
    def numOfWays(self, nums):
        def iter_dfs(nums):
            result = [0]
            stk = [[1, [nums, result]]]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    nums, ret = params
                    if len(nums) <= 2:
                        ret[0] = 1
                        continue
                    left = [v for v in nums if v < nums[0]]
                    right = [v for v in nums if v > nums[0]]
                    ret[0] = dp[len(left)+len(right)][len(left)]
                    ret1, ret2 = [0], [0]
                    stk.append([2, [ret1, ret2, ret]])
                    stk.append([1, [right, ret2]])
                    stk.append([1, [left, ret1]])
                elif step == 2:
                    ret1, ret2, ret = params
                    ret[0] = ret[0]*ret1[0] % MOD
                    ret[0] = ret[0]*ret2[0] % MOD
            return result[0]

        return (iter_dfs(nums)-1)%MOD",O(n ^ 2)
"class Solution(object):
    def numOfWays(self, nums):
        def dfs(nums):
            if len(nums) <= 2:
                return 1
            left = [v for v in nums if v < nums[0]]
            right = [v for v in nums if v > nums[0]]
            result = dp[len(left)+len(right)][len(left)]
            result = result*dfs(left) % MOD
            result = result*dfs(right) % MOD
            return result

        return (dfs(nums)-1)%MOD",O(n ^ 2)
"class Solution(object):
    def minimumCardPickup(self, cards):
        lookup = {}
        result = float(""inf"")
        for i, x in enumerate(cards):
            if x in lookup:
                result = min(result, i-lookup[x]+1)
            lookup[x] = i
        return result if result != float(""inf"") else -1",O(n)
"class Solution(object):
    def percentageLetter(self, s, letter):
        return 100*s.count(letter)//len(s)",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def splitCircularLinkedList(self, list):
        head1 = list
        slow, fast = head1, head1.__next__
        while head1  != fast.__next__:
            slow = slow.__next__
            fast = fast.next.__next__ if head1 != fast.next.__next__ else fast.__next__
        head2 = slow.__next__
        slow.next, fast.next = head1, head2
        return [head1, head2]",O(n)
"class Solution(object):
    def findValueOfPartition(self, nums):
        nums.sort()
        return min(nums[i+1]-nums[i] for i in range(len(nums)-1))",O(nlogn)
"import itertools


class Solution(object):
    def compareVersion(self, version1, version2):
        n1, n2 = len(version1), len(version2)
        i, j = 0, 0
        while i < n1 or j < n2:
            v1, v2 = 0, 0
            while i < n1 and version1[i] != '.':
                v1 = v1 * 10 + int(version1[i])
                i += 1
            while j < n2 and version2[j] != '.':
                v2 = v2 * 10 + int(version2[j])
                j += 1
            if v1 != v2:
                return 1 if v1 > v2 else -1
            i += 1
            j += 1

        return 0",O(n)
"class Solution2(object):
    def compareVersion(self, version1, version2):
        v1, v2 = version1.split("".""), version2.split(""."")

        if len(v1) > len(v2):
            v2 += ['0' for _ in range(len(v1) - len(v2))]
        elif len(v1) < len(v2):
            v1 += ['0' for _ in range(len(v2) - len(v1))]

        i = 0
        while i < len(v1):
            if int(v1[i]) > int(v2[i]):
                return 1
            elif int(v1[i]) < int(v2[i]):
                return -1
            else:
                i += 1

        return 0

    def compareVersion2(self, version1, version2):
        v1 = [int(x) for x in version1.split('.')]
        v2 = [int(x) for x in version2.split('.')]
        while len(v1) != len(v2):
            if len(v1) > len(v2):
                v2.append(0)
            else:
                v1.append(0)
        return cmp(v1, v2)

    def compareVersion3(self, version1, version2):
        splits = (list(map(int, v.split('.'))) for v in (version1, version2))
        return cmp(*list(zip(*itertools.zip_longest(*splits, fillvalue=0))))

    def compareVersion4(self, version1, version2):
        main1, _, rest1 = ('0' + version1).partition('.')
        main2, _, rest2 = ('0' + version2).partition('.')
        return cmp(int(main1), int(main2)) or len(rest1 + rest2) and self.compareVersion4(rest1, rest2)",O(n)
"class Solution(object):
    def minSwaps(self, s):
        result = curr = 0
        for c in s:
            if c == ']':
                curr += 1
                result = max(result, curr)
            else:
                curr -= 1
        return (result+1)//2",O(n)
"class Solution(object):

    def __init__(self, n):
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i < len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result",O(1)
"class Solution(object):
    def checkStraightLine(self, coordinates):
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)",O(n)
"class Solution(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""""]
        right = float(""inf"")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left > right:
                result.append("""")
            right = new_right
            result[-1] = s[left:right+1]
        return result",O(n)
"class Solution2(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right

        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        intervals = []
        for c in range(len(first)):
            if first[c] == float(""inf""):
                continue
            left, right = first[c], find_right_from_left(s, first, last, first[c])
            if right != -1:
                intervals.append((right, left))
        intervals.sort() 
        result, prev = [], -1
        for right, left in intervals:
            if left <= prev:
                continue
            result.append(s[left:right+1])
            prev = right
        return result",O(n)
"class Solution(object):
    def separateSquares(self, squares):
        class SegmentTreeRecu(object):
            def __init__(self, sorted_x):
                self.sorted_x = sorted_x
                n = len(sorted_x)-1
                l = 1<<((n-1).bit_length()+1)
                self.tree = [0]*l
                self.cnt = [0]*l
        
            def update(self, ql, qr, v, l, r, i): 
                if ql >= r or qr <= l:
                    return
                if ql <= l and r <= qr:
                    self.cnt[i] += v
                else:
                    m = l+(r-l)//2
                    self.update(ql, qr, v, l, m, 2*i)
                    self.update(ql, qr, v, m, r, 2*i+1)
                if self.cnt[i] > 0:
                    self.tree[i] = self.sorted_x[r]-self.sorted_x[l]
                else:
                    if r-l == 1:
                        self.tree[i] = 0
                    else:
                        self.tree[i] = self.tree[2*i]+self.tree[2*i+1]
    
        events = []
        x_set = set()
        for x, y, l in squares:
            events.append((y, 1, x, x+l))
            events.append((y+l, -1, x, x+l))
            x_set.add(x)
            x_set.add(x+l)
        events.sort(key=lambda e: e[0])
        sorted_x = sorted(x_set) 
        x_to_idx = {x:i for i, x in enumerate(sorted_x)}
        st = SegmentTreeRecu(sorted_x)
        prev = events[0][0]
        intervals = []
        for y, v, x1, x2 in events:
            if y != prev:
                intervals.append([prev, y, st.tree[1]])
                prev = y
            st.update(x_to_idx[x1], x_to_idx[x2], v, 0, len(sorted_x)-1, 1)
        expect = sum((y2-y1)*curr for y1, y2, curr in intervals)/2.0
        total = 0.0
        for y1, y2, curr in intervals:
            if total+(y2-y1)*curr >= expect:
                break
            total += (y2-y1)*curr
        return y1+(expect-total)/curr",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result",O(n)
"class Solution2(object):
    def getLonelyNodes(self, root):
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result",O(n)
"class Solution(object):
    def getDescentPeriods(self, prices):
        result = l = 0
        for i in range(len(prices)):
            l += 1
            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:
                result += l*(l+1)//2
                l = 0
        return result",O(n)
"class Solution(object):
    def maximumSumOfHeights(self, maxHeights):
        left = [0]*len(maxHeights)
        stk = [-1]
        curr = 0
        for i in range(len(maxHeights)):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (j-stk[-1])*maxHeights[j]
            curr += (i-stk[-1])*maxHeights[i]
            stk.append(i)
            left[i] = curr
        stk = [len(maxHeights)]
        result = right = curr = 0
        for i in reversed(range(len(maxHeights))):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (stk[-1]-j)*maxHeights[j]
            curr += (stk[-1]-i)*maxHeights[i]
            stk.append(i)
            right = curr
            result = max(result, left[i]+right-maxHeights[i])
        return result",O(n)
"class Solution(object):
    def decode(self, encoded, first):
        result = [first]
        for x in encoded:
            result.append(result[-1]^x)
        return result",O(n)
"import collections


class Solution(object):
    def canReach(self, arr, start):
        q, lookup = collections.deque([start]), set([start])
        while q:
            i = q.popleft()
            if not arr[i]:
                return True
            for j in [i-arr[i], i+arr[i]]:
                if 0 <= j < len(arr) and j not in lookup:
                    lookup.add(j)
                    q.append(j) 
        return False",O(n)
"class Solution(object):
    def getAverages(self, nums, k):
        total, l = 0, 2*k+1
        result = [-1]*len(nums)
        for i in range(len(nums)):
            total += nums[i]
            if i-l >= 0:
                total -= nums[i-l]
            if i >= l-1:
                result[i-k] = total//l
        return result",O(n)
"class Solution(object):
    def longestDecomposition(self, text):
        def compare(text, l, s1, s2):
            for i in range(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 26
        result = 0
        left, right, l, pow_D = 0, 0, 0, 1
        for i in range(len(text)):
            left = (D*left + (ord(text[i])-ord('a'))) % MOD
            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD
            l += 1
            pow_D = (pow_D*D) % MOD 
            if left == right and compare(text, l, i-l+1, len(text)-1-i):
                result += 1
                left, right, l, pow_D = 0, 0, 0, 1
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sortedArrayToBST(self, nums):
        return self.sortedArrayToBSTRecu(nums, 0, len(nums))

    def sortedArrayToBSTRecu(self, nums, start, end):
        if start == end:
            return None
        mid = start + self.perfect_tree_pivot(end - start)
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBSTRecu(nums, start, mid)
        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)
        return node

    def perfect_tree_pivot(self, n):
        x = 1
        x = 1 << (n.bit_length() - 1) 

        if x // 2 - 1 <= (n - x):
            return x - 1 
        else:
            return n - x // 2",O(n)
"class Solution2(object):
    def sortedArrayToBST(self, nums):
        self.iterator = iter(nums)
        return self.helper(0, len(nums))
    
    def helper(self, start, end):
        if start == end:
            return None
        
        mid = (start + end) // 2
        left = self.helper(start, mid)
        current = TreeNode(next(self.iterator))
        current.left = left
        current.right = self.helper(mid+1, end)
        return current",O(n)
"class Solution(object):
    def longestIdealString(self, s, k):
        dp = [0]*26
        for c in s:
            x = ord(c)-ord('a')
            dp[x] = max(dp[i] for i in range(max(x-k, 0), min(x+k+1, 26)))+1
        return max(dp)",O(n)
"class Solution(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n&k == k else -1",O(logn)
"class Solution2(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n|(n^k) == n else -1",O(logn)
"class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def expTree(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(Node(val=operators.pop(), left=left, right=right))

        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(Node(val=str(operand)))
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]",O(n)
"class Solution(object):
    def maxSumMinProduct(self, nums):
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        stk, result = [-1], 0
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))
            stk.append(i) 
        return result%MOD",O(n)
"import collections



class Solution(object):
    def medianOfUniquenessArray(self, nums):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(k):
            result = 0
            cnt = collections.Counter()
            left = 0
            for right in range(len(nums)):
                cnt[nums[right]] += 1
                while len(cnt) == k+1:
                    cnt[nums[left]] -= 1
                    if cnt[nums[left]] == 0:
                        del cnt[nums[left]]
                    left += 1
                result += right-left+1
            return result >= total-result

        total = (len(nums)+1)*len(nums)//2
        return binary_search(1, len(set(nums)), check)",O(nlogn)
"class Solution(object):
    def areNumbersAscending(self, s):
        prev = curr = -1
        for i, c in enumerate(s):
            if c.isdigit():
                curr = max(curr, 0)*10+int(c)
                continue
            if prev != -1 and curr != -1 and prev >= curr:
                return False
            if curr != -1:
                prev = curr
            curr = -1            
        return curr == -1 or prev < curr",O(n)
"class Solution2(object):
    def areNumbersAscending(self, s):
        nums = [int(x) for x in s.split() if x.isdigit()]
        return all(nums[i] < nums[i+1] for i in range(len(nums)-1))",O(n)
"from collections import deque


class Solution(object):
    def maxSlidingWindow(self, nums, k):
        result, dq = [], deque()
        for i in range(len(nums)):
            if dq and i-dq[0] == k:
                dq.popleft()
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            dq.append(i)
            if i >= k-1:
                result.append(nums[dq[0]])
        return result",O(n)
"class Solution(object):
    def furthestDistanceFromOrigin(self, moves):
        curr = cnt = 0
        for x in moves:
            if x == 'L':
                curr -= 1
            elif x == 'R':
                curr += 1
            else:
                cnt += 1
        return abs(curr)+cnt",O(n)
"class Solution(object):
    def newInteger(self, n):
        result, base = 0, 1
        while n > 0:
            result += (n%9) * base
            n /= 9
            base *= 10
        return result",O(logn)
"import collections



class Solution(object):
    def verticalOrder(self, root):
        cols = collections.defaultdict(list)
        queue = [(root, 0)]
        for node, i in queue:
            if node:
                cols[i].append(node.val)
                queue += (node.left, i - 1), (node.right, i + 1)
        return [cols[i] for i in range(min(cols.keys()),
                                        max(cols.keys()) + 1)] if cols else []",O(n)
"class Solution(object):
    def sumRemoteness(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            total, cnt = grid[i][j], 1
            grid[i][j] = -1
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):
                            continue
                        total += grid[ni][nj]
                        cnt += 1
                        grid[ni][nj] = -1
                        new_q.append((ni, nj))
                q = new_q
            return total, cnt
    
        groups = [bfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] != -1]
        total = sum(t for t, _ in groups)
        return sum((total-t)*c for t, c in groups)",O(n ^ 2)
"class Solution(object):
    def timeRequiredToBuy(self, tickets, k):
        return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets))",O(n)
"class Solution(object):
    def passThePillow(self, n, time):
        return n-abs((n-1)-(time%(2*(n-1))))",O(1)
"class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))",O(n)
"class Solution(object):
    def canJump(self, A):
        reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                break
            reachable = max(reachable, i + length)
        return reachable >= len(A) - 1",O(n)
"class Solution(object):
    def minOperations(self, nums, target):
        def floor_log2_x(x):
            return x.bit_length()-1

        total = sum(nums)
        if total < target:
            return -1

        cnt = [0]*(floor_log2_x(max(nums))+1)
        for x in nums:
            cnt[floor_log2_x(x)] += 1
        result = 0
        for i in reversed(range(len(cnt))):
            for _ in range(cnt[i]):
                x = 1<<i
                if x <= target:
                    target -= x
                    total -= x
                elif total-x >= target:
                    total -= x
                else:
                    cnt[i-1] += 2
                    result += 1
        return result",O(n)
"class Solution2(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        nums.sort()
        result = 0
        while target:
            x = nums.pop()
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                nums.append(x//2)
                nums.append(x//2)
                result += 1
        return result",O(nlogn)
"import heapq




class Solution3(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        result = 0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        while target:
            x = -heapq.heappop(max_heap)
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                heapq.heappush(max_heap, -x//2)
                heapq.heappush(max_heap, -x//2)
                result += 1
        return result",O(nlogn)
"
class Solution(object):
    def reverseOnlyLetters(self, S):
        def getNext(S):
            for i in reversed(range(len(S))):
                if S[i].isalpha():
                    yield S[i]

        result = []
        letter = getNext(S)
        for i in range(len(S)):
            if S[i].isalpha():
                result.append(next(letter))
            else:
                result.append(S[i])
        return """".join(result)

",O(n)
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, prev, curr = 0, 0, 0
        for n in nums:
            if n == 0:
                result = max(result, prev+curr+1)
                prev, curr = curr, 0
            else:
                curr += 1
        return min(max(result, prev+curr+1), len(nums))",O(n)
"class Solution(object):
    def minimalKSum(self, nums, k):
        result = k*(k+1)//2
        curr = k+1
        for x in sorted(set(nums)):
            if x < curr:
                result += curr-x
                curr += 1
        return result",O(nlogn)
"class Solution2(object):
    def minimalKSum(self, nums, k):
        result = prev = 0
        nums.append(float(""inf""))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maximumAverageSubtree(self, root):
        def maximumAverageSubtreeHelper(root, result):
            if not root:
                return [0.0, 0]
            s1, n1 = maximumAverageSubtreeHelper(root.left, result)
            s2, n2 = maximumAverageSubtreeHelper(root.right, result)
            s = s1+s2+root.val
            n = n1+n2+1
            result[0] = max(result[0], s / n)
            return [s, n]

        result = [0]
        maximumAverageSubtreeHelper(root, result)
        return result[0]",O(n)
"class Solution(object):
    def removeKdigits(self, num, k):
        result = []
        for d in num:
            while k and result and result[-1] > d:
                result.pop()
                k -= 1
            result.append(d)
        return ''.join(result).lstrip('0')[:-k or None] or '0'",O(n)
"import heapq


class Solution(object):
    def lastStoneWeight(self, stones):
        max_heap = [-x for x in stones]
        heapq.heapify(max_heap)
        for i in range(len(stones)-1):
            x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)
            heapq.heappush(max_heap, -abs(x-y))
        return -max_heap[0]",O(nlogn)
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def construct(self, grid):
        def dfs(grid, x, y, l):
            if l == 1:
                return Node(grid[x][y] == 1, True, None, None, None, None)
            half = l // 2
            topLeftNode = dfs(grid, x, y, half)
            topRightNode = dfs(grid, x, y+half, half)
            bottomLeftNode = dfs(grid, x+half, y, half)
            bottomRightNode = dfs(grid, x+half, y+half, half)
            if topLeftNode.isLeaf and topRightNode.isLeaf and \
               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
                return Node(topLeftNode.val, True, None, None, None, None)
            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)
        
        if not grid:
            return None
        return dfs(grid, 0, 0, len(grid))",O(n ^ 2)
"class Solution(object):
    def missingElement(self, nums, k):
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k > missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))",O(logn)
"import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):
        def binarySearch(left, right, find, image, has_one):
            while left <= right: 
                mid = left + (right - left) / 2
                if find(image, has_one, mid): 
                    right = mid - 1
                else:
                    left = mid + 1
            return left


        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one
        left = binarySearch(0, y - 1, searchColumns, image, True)
        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

        searchRows = lambda image, has_one, mid: any(map(int, image[mid])) == has_one
        top = binarySearch(0, x - 1, searchRows, image, True)
        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

        return (right - left) * (bottom - top)",O(nlogn)
"class Solution(object):
    def takeCharacters(self, s, k):
        cnt = [0]*3
        for c in s:
            cnt[ord(c)-ord('a')] += 1
        if min(cnt) < k:
            return -1
        result = left = 0
        for right in range(len(s)):
            cnt[ord(s[right])-ord('a')] -= 1
            while cnt[ord(s[right])-ord('a')] < k:
                cnt[ord(s[left])-ord('a')] += 1
                left += 1
            result = max(result, right-left+1)
        return len(s)-result",O(n)
"class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False",O(n ^ 2)
"class Solution2(object):
    def checkPartitioning(self, s):
        dp = [[False]*len(s) for _ in range(len(s))]
        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]):
                    dp[i][j] = True
        for i in range(1, len(s)-1):
            if not dp[0][i-1]:
                continue
            for j in range(i+1, len(s)):
                if not dp[j][-1]:
                    continue
                if dp[i][j-1]:
                    return True
        return False",O(n ^ 2)
"import collections


class Solution(object):
    def countLargestGroup(self, n):
        count = collections.Counter()
        for x in range(1, n+1):
            count[sum(map(int, str(x)))] += 1
        max_count = max(count.values())
        return sum(v == max_count for v in count.values())",O(nlogn)
"class Solution(object):
    def minimumXORSum(self, nums1, nums2):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
        
        adj = [[0]*len(nums2) for _ in range(len(nums1))]
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                adj[i][j] = nums1[i]^nums2[j]
        return hungarian(adj)[0]",O(n ^ 3)
"import collections



class Point(object):
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b

class Solution(object):
    def maxPoints(self, points):
        max_points = 0
        for i, start in enumerate(points):
            slope_count, same = collections.defaultdict(int), 1
            for j in range(i + 1, len(points)):
                end = points[j]
                if start.x == end.x and start.y == end.y:
                    same += 1
                else:
                    slope = float(""inf"")
                    if start.x - end.x != 0:
                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)
                    slope_count[slope] += 1

            current_max = same
            for slope in slope_count:
                current_max = max(current_max, slope_count[slope] + same)

            max_points = max(max_points, current_max)

        return max_points",O(n ^ 2)
"class Solution(object):
    def closetTarget(self, words, target, startIndex):
        INF = float(""inf"")
        result = INF
        for i, w in enumerate(words):
            if w == target:
                result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words))
        return result if result != INF else -1",O(n)
"class Solution(object):
    def lenLongestFibSubseq(self, A):
        lookup = set(A)
        result = 2
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                x, y, l = A[i], A[j], 2
                while x+y in lookup:
                    x, y, l = y, x+y, l+1
                result = max(result, l)
        return result if result > 2 else 0",O(n ^ 2)
"import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        K = 3

        result = 0
        count = collections.Counter()
        for i in range(len(s)):
            if i >= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result",O(n)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getTargetCopy(self, original, cloned, target):
        def preorder_gen(node):
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                yield node
                stk.append(node.right)
                stk.append(node.left)
            
        for node1, node2 in zip(preorder_gen(original),
                                           preorder_gen(cloned)):
            if node1 == target:
                return node2",O(n)
"class Solution(object):
    def maximizeSum(self, nums, k):
        return max(nums)*k+k*(k-1)//2",O(n)
"class Solution(object):
    def reverseDegree(self, s):
        return sum(i*(26-(ord(x)-ord('a'))) for i, x in enumerate(s, 1))",O(n)
"import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"class Solution(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = curr = INF
        for i in range(len(nums)):
            if curr < nums[i] > right[i]:
                result = min(result, curr+nums[i]+right[i])
            curr = min(curr, nums[i])
        return result if result != INF else -1",O(n)
"class Solution2(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        left = [INF]*len(nums)
        curr = INF
        for i in range(len(nums)):
            left[i] = curr
            curr = min(curr, nums[i])
        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = INF
        for i in range(len(nums)):
            if left[i] < nums[i] > right[i]:
                result = min(result, left[i]+nums[i]+right[i])
        return result if result != INF else -1",O(n)
"import bisect



class Solution(object):
    def maximumCount(self, nums):
        return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1))",O(logn)
"class Solution(object):
    def dayOfTheWeek(self, day, month, year):
        DAYS = [""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", \
                ""Thursday"", ""Friday"", ""Saturday""]

        if month < 3:
            month += 12
            year -= 1
        c, y = divmod(year, 100)
        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7
        return DAYS[w]",O(1)
"class Solution(object):
    def sumImbalanceNumbers(self, nums):
        right = [len(nums)]*len(nums)
        lookup = [len(nums)]*((len(nums)+1)+1)
        for i in reversed(range(len(nums))):
            right[i] = min(lookup[nums[i]], lookup[nums[i]+1]) 
            lookup[nums[i]] = i
        result = left = 0
        lookup = [-1]*((len(nums)+1)+1)
        for i in range(len(nums)):
            left = lookup[nums[i]+1]
            lookup[nums[i]] = i
            result += (i-left)*(right[i]-i)
        return result - (len(nums)+1)*len(nums)//2",O(n)
"class Solution2(object):
    def sumImbalanceNumbers(self, nums):
        result = 0
        for right in range(len(nums)):
            lookup = {nums[right]}
            curr = 0
            for left in reversed(range(right)):
                if nums[left] not in lookup:
                    lookup.add(nums[left])
                    curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup)
                result += curr
        return result",O(n ^ 2)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random



class NodeCopy(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        pass


class Solution(object):
    def copyRandomBinaryTree(self, root):
        def iter_dfs(node, callback):
            result = None
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                left_node, copy = callback(node)
                if not result:
                    result = copy
                stk.append(node.right)
                stk.append(left_node)
            return result
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        iter_dfs(root, merge)
        iter_dfs(root, clone)
        return iter_dfs(root, split)",O(n)
"class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, callback):
            if not node:
                return None
            left_node, copy = callback(node)
            dfs(left_node, callback)
            dfs(node.right, callback) 
            return copy
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        dfs(root, merge)
        dfs(root, clone)
        return dfs(root, split)


",O(n)
"import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            stk.append(node.right)
            stk.append(node.left)
        return lookup[root]",O(n)
"import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, lookup):
            if not node:
                return
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            dfs(node.left, lookup)
            dfs(node.right, lookup)
    
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        dfs(root, lookup)
        return lookup[root]",O(n)
"class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        dp = [[-1 for _ in range(len(colors))] for _ in range(3)]
        dp[colors[0]-1][0] = 0
        for i in range(1, len(colors)):
            for color in range(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(range(len(colors)-1)):
            for color in range(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]",O(n)
"class Solution(object):
    def canMakeArithmeticProgression(self, arr):
        m = min(arr)
        d = (max(arr)-m)//(len(arr)-1)
        if not d:
            return True
        i = 0
        while i < len(arr):
            if arr[i] == m+i*d:
                i += 1
            else:
                j, r = divmod(arr[i]-m, d)
                if r or j >= len(arr) or arr[i] == arr[j]:
                    return False
                arr[i], arr[j] = arr[j], arr[i]
        return True",O(n)
"class Solution(object):
    def canTransform(self, start, end):
        if start.count('X') != end.count('X'):
            return False
        i, j = 0, 0
        while i < len(start) and j < len(end):
            while i < len(start) and start[i] == 'X':
                i += 1
            while j < len(end) and end[j] == 'X':
                j += 1
            if (i < len(start)) != (j < len(end)):
                return False
            elif i < len(start) and j < len(end):
                if start[i] != end[j] or \
                   (start[i] == 'L' and i < j) or \
                   (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True",O(n)
"class Solution(object):
    def stringHash(self, s, k):
        result = (chr(ord('a')+reduce(lambda accu, x: (accu+x)%26,  (ord(s[i+j])-ord('a') for j in range(k)), 0)) for i in range(0, len(s), k))
        return """".join(result)",O(n)
"import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        result = 0
        count = collections.Counter()
        freq = [0 for _ in range(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i < len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result",O(n)
"class Solution(object):
    def firstDayBeenInAllRooms(self, nextVisit):
        MOD = 10**9+7

        dp = [0]*len(nextVisit)
        for i in range(1, len(dp)):
            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD
        return dp[-1]",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCompleteTree(self, root):
        end = False
        current = [root]
        while current:
            next_level = []
            for node in current:
                if not node:
                    end = True
                    continue
                if end:
                    return False
                next_level.append(node.left)
                next_level.append(node.right)
            current = next_level
        return  True


",O(n)
"class Solution2(object):
    def isCompleteTree(self, root):
        prev_level, current = [], [(root, 1)]
        count = 0
        while current:
            count += len(current)
            next_level = []
            for node, v in current:
                if not node:
                    continue
                next_level.append((node.left, 2*v))
                next_level.append((node.right, 2*v+1))
            prev_level, current = current, next_level
        return prev_level[-1][1] == count",O(n)
"class Solution(object):
    def isIdealPermutation(self, A):
        return all(abs(v-i) <= 1 for i,v in enumerate(A))",O(n)
"class Solution(object):
    def flipAndInvertImage(self, A):
        for row in A:
            for i in range((len(row)+1) // 2):
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrderBottom(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)

        return result[::-1]",O(n)
"class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def queryString(self, S, N):
        return all(bin(i)[2:] in S for i in reversed(range(N//2, N+1)))",O(n ^ 2)
"class Solution(object):
    def checkValidString(self, s):
        lower, upper = 0, 0 
        for c in s:
            lower += 1 if c == '(' else -1
            upper -= 1 if c == ')' else -1
            if upper < 0: break
            lower = max(lower, 0)
        return lower == 0",O(n)
"class Solution(object):
    def maxCollectedFruits(self, fruits):
        n = len(fruits)
        for i in range(n):
            for j in range(i+1, n-(i+1)):
                fruits[i][j] = 0
        for i in range(1, n-1):
            for j in range(i+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1] if j+1 < n else 0)
        for j in range(n):
            for i in range(j+1, n-(j+1)):
                fruits[i][j] = 0
        for j in range(1, n-1):
            for i in range(j+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1] if i+1 < n else 0)
        return sum(fruits[i][i] for i in range(n))+fruits[-2][-1]+fruits[-1][-2]",O(n ^ 2)
"class Solution(object):
    def maxFreeTime(self, eventTime, startTime, endTime):
        def topk(a, k): 
            result = [[float(""-inf"")]*2 for _ in range(k)]
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result

        result = 0
        startTime.append(eventTime)
        endTime.insert(0, 0)
        diffs = ([startTime[i]-endTime[i], endTime[i]] for i in range(len(startTime)))
        top3 = topk(diffs, 3)
        for i in range(len(startTime)-1):
            for mx, e in top3:
                if e not in (endTime[i], endTime[i+1]) and endTime[i+1]-startTime[i] <= mx:
                    result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1])+(endTime[i+1]-startTime[i]))
                    break
            else:
                result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1]))
        return result",O(n)
"class Solution(object):
    def totalHammingDistance(self, nums):
        result = 0
        for i in range(32):
            counts = [0] * 2
            for num in nums:
                counts[(num >> i) & 1] += 1
            result += counts[0] * counts[1]
        return result",O(n)
"class Solution(object):
    def mostCompetitive(self, nums, k):
        stk = []
        for i, x in enumerate(nums):
            while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k:
                stk.pop()
            if len(stk) < k:
                stk.append(x)
        return stk",O(n)
"class Solution(object):
    def reverseString(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1",O(n)
"import collections
import itertools



class Solution(object):
    def mostPopularCreator(self, creators, ids, views):
        cnt = collections.Counter()
        lookup = collections.defaultdict(lambda: (float(""inf""), float(""inf"")))
        for c, i, v in zip(creators, ids, views):
            cnt[c] += v
            lookup[c] = min(lookup[c], (-v, i))
        mx = max(cnt.values())
        return [[k, lookup[k][1]] for k, v in cnt.items() if v == mx]",O(n)
"import collections


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def serialize(self, root):
        def serializeHelper(node, vals):
            if node:
                vals.append(node.val)
                serializeHelper(node.left, vals)
                serializeHelper(node.right, vals)

        vals = []
        serializeHelper(root, vals)

        return ' '.join(map(str, vals))


    def deserialize(self, data):
        def deserializeHelper(minVal, maxVal, vals):
            if not vals:
                return None

            if minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = deserializeHelper(minVal, val, vals)
                node.right = deserializeHelper(val, maxVal, vals)
                return node
            else:
                return None

        vals = collections.deque([int(val) for val in data.split()])

        return deserializeHelper(float('-inf'), float('inf'), vals)",O(n)
"class Solution(object):
    def minMoves(self, target, maxDoubles):
        result = 0
        while target > 1 and maxDoubles:
            result += 1+target%2
            target //= 2
            maxDoubles -= 1
        return result+(target-1)",O(logn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def processQueries(self, queries, m):
        bit = BIT(2*m+1)
        lookup = {}
        for i in range(1, m+1):
            bit.add(m+i, 1)
            lookup[i] = m+i
        result, curr = [], m
        for q in queries:
            i = lookup.pop(q)
            result.append(bit.sum(i-1))
            bit.add(i, -1)
            lookup[q] = curr
            bit.add(curr, 1)
            curr -= 1
        return result",O(nlogn)
"class Solution(object):
    def averageWaitingTime(self, customers):
        avai = wait = 0.0
        for a, t in customers:
            avai = max(avai, a)+t
            wait += avai-a
        return wait/len(customers)",O(n)
"
class Solution(object):
    def minMoves(self, nums):
        return sum(nums) - len(nums) * min(nums)

",O(n)
"class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False",O(n)
"class Solution(object):
    def productExceptSelf(self, nums):
        if not nums:
            return []

        left_product = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            left_product[i] = left_product[i - 1] * nums[i - 1]

        right_product = 1
        for i in range(len(nums) - 2, -1, -1):
            right_product *= nums[i + 1]
            left_product[i] = left_product[i] * right_product

        return left_product",O(n)
"class Solution(object):
    def findTheString(self, lcp):
        result = [-1]*len(lcp)
        curr = 0
        for i in range(len(lcp)):
            if result[i] != -1:
                continue
            if curr == 26:
                return """"
            for j in range(i, len(lcp[0])):
                if lcp[i][j]:
                    result[j] = curr
            curr += 1
        for i in reversed(range(len(lcp))):
            for j in reversed(range(len(lcp[0]))):
                if lcp[i][j] != ((lcp[i+1][j+1]+1 if i+1 < len(lcp) and j+1 < len(lcp[0]) else 1) if result[i] == result[j] else 0):
                    return ''
        return """".join([chr(ord('a')+x) for x in result])",O(n ^ 2)
"class Solution(object):
    def countGoodNumbers(self, n):
        def powmod(a, b, mod):
            a %= mod
            result = 1
            while b:
                if b&1:
                    result = (result*a)%mod
                a = (a*a)%mod
                b >>= 1
            return result

        MOD = 10**9 + 7
        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD",O(logn)
"class Solution2(object):
    def countGoodNumbers(self, n):
        MOD = 10**9 + 7
        return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD",O(logn)
"class Solution(object):
    def pushDominoes(self, dominoes):
        force = [0]*len(dominoes)

        f = 0
        for i in range(len(dominoes)):
            if dominoes[i] == 'R':
                f = len(dominoes)
            elif dominoes[i] == 'L':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] += f

        f = 0
        for i in reversed(range(len(dominoes))):
            if dominoes[i] == 'L':
                f = len(dominoes)
            elif dominoes[i] == 'R':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] -= f

        return """".join('.' if f == 0 else 'R' if f > 0 else 'L'
                       for f in force)",O(n)
"class Solution(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            if not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
        return right-left+1",O(nlogn)
"class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            while not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
            result = max(result, right-left+1)
        return result",O(nlogn)
"class Solution3(object):
    def maxFrequencyScore(self, nums, k):
        def check(l):
            return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in range(len(nums)-l+1))

        nums.sort()
        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        left, right = 1, len(nums)
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"import itertools


class Solution(object):
    def fib(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]",O(logn)
"class Solution2(object):
    def fib(self, N):
        prev, current = 0, 1
        for i in range(N):
            prev, current = current, prev + current,
        return prev",O(n)
"class Solution(object):
    def kthCharacter(self, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        return chr(ord('a')+popcount(k-1)%26)",O(1)
"class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        max_run = -1
        i = max_prof = prof = waiting = 0
        run = 1
        while i < len(customers) or waiting > 0:
            if i < len(customers):
                waiting += customers[i] 
                i += 1
            boarding = min(waiting, 4) 
            waiting -= boarding
            prof += boarding * boardingCost - runningCost 
            if prof > max_prof:
                max_prof = prof
                max_run = run
            run += 1
        return max_run",O(n)
"class Solution(object):
    def findLonely(self, nums):
        cnt = collections.Counter(nums)
        return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt]",O(n)
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for x in nums:
            if x^(result&1):
                continue
            result += 1
        return result",O(n)
"class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        return max(nums[i]+nums[-1-i] for i in range(len(nums)//2))",O(nlogn)
"
import itertools


class Solution(object):
    def minMovesToSeat(self, seats, students):
        seats.sort()
        students.sort()
        return sum(abs(a-b) for a, b in zip(seats, students))
",O(nlogn)
"class Solution3(object):
    def findMaximumElegance(self, items, k):
        items.sort(reverse=True)
        result = curr = 0
        lookup = set()
        stk = []
        for i in range(k):
            if items[i][1] in lookup:
                stk.append(items[i][0])
            curr += items[i][0]
            lookup.add(items[i][1])
        result = curr+len(lookup)**2
        for i in range(k, len(items)):
            if items[i][1] in lookup:
                continue
            if not stk:
                break
            curr += items[i][0]-stk.pop()
            lookup.add(items[i][1])
            result = max(result, curr+len(lookup)**2)
        return result",O(nlogn)
"class Solution(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        idx = l = 0
        for i in range(1, len(word)):
            if word[i] == word[idx+l]:
                l += 1
            elif word[i] < word[idx+l]:
                l = 0
            elif word[i] > word[idx+l]:
                if word[i-l] >= word[i]:
                    idx = i-l
                else:
                    idx = i
                l = 0
        return word[idx:len(word)-max((numFriends-1)-idx, 0)]",O(n)
"class Solution2(object):
    def reconstructQueue(self, people):
        people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))
        result = []
        for p in people:
            result.insert(p[1], p)
        return result",O(n ^ 2)
"import collections
import itertools
import heapq



class Solution(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        max_heap = []
        for x, f in zip(nums, freq):
            cnt[x] += f
            heapq.heappush(max_heap, (-cnt[x], x))
            while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]:
                heapq.heappop(max_heap)
            result.append(-max_heap[0][0] if max_heap else 0)
        return result",O(nlogn)
"import collections
import itertools
from sortedcontainers import SortedList



class Solution2(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        cnt2 = collections.Counter()
        sl = SortedList()
        for x, f in zip(nums, freq):
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] -= 1
            if cnt2[cnt[x]]:
                sl.add((cnt[x], cnt2[cnt[x]]))
            cnt[x] += f
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] += 1
            sl.add((cnt[x], cnt2[cnt[x]]))
            result.append(sl[-1][0])
        return result",O(nlogn)
"class Solution(object):
    def largestSquareArea(self, bottomLeft, topRight):
        result = 0
        for i in range(len(bottomLeft)):
            for j in range(i+1, len(bottomLeft)):
                max_x = max(bottomLeft[i][0], bottomLeft[j][0])
                min_x = min(topRight[i][0], topRight[j][0])
                max_y = max(bottomLeft[i][1], bottomLeft[j][1])
                min_y = min(topRight[i][1], topRight[j][1])
                result = max(result, min(min_x-max_x, min_y-max_y))
        return result**2",O(n ^ 2)
"class Solution2(object):
    def largestSquareArea(self, bottomLeft, topRight):
        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in range(len(bottomLeft)) for j in range(i+1, len(bottomLeft))), 0)**2",O(n ^ 2)
"class Solution(object):
    def numDecodings(self, s):
        M, W = 1000000007, 3
        dp = [0] * W
        dp[0] = 1
        dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0
        for i in range(1, len(s)):
            if s[i] == '*':
                dp[(i + 1) % W] = 9 * dp[i % W]
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '2':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M
            else:
                dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '2' and s[i] <= '6':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M
        return dp[len(s) % W]",O(n)
"class Solution(object):
    def numSubseq(self, nums, target):
        MOD = 10**9 + 7
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left <= right:
            if nums[left]+nums[right] > target:
                right -= 1
            else:
                result = (result+pow(2, right-left, MOD))%MOD
                left += 1
        return result",O(nlogn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def treeQueries(self, n, edges, queries):
        def iter_dfs():
            L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
            cnt = 0
            stk = [(1, (0, -1, 0))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d = args
                    L[u] = cnt
                    cnt += 1
                    dist[u] = d
                    stk.append((2, (u,)))
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        lookup[v] = w
                        stk.append((1, (v, u, d+w)))
                elif step == 2:
                    u = args[0]
                    R[u] = cnt
            return L, R, dist, lookup

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = iter_dfs()
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"class Solution2(object):
    def treeQueries(self, n, edges, queries):
        def dfs(u, p, d):
            L[u] = cnt[0]
            cnt[0] += 1
            dist[u] = d
            for v, w in adj[u]:
                if v == p:
                    continue
                lookup[v] = w
                dfs(v, u, d+w)
            R[u] = cnt[0]

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
        cnt = [0]
        dfs(0, -1, 0)
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"class Solution(object):
    def isBoomerang(self, points):
        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \
               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0",O(1)
"class Solution(object):
    def binarySearchableNumbers(self, nums):
        right = [float(""inf"")]*(len(nums)+1)
        for i in reversed(range(1, len(nums)+1)):
            right[i-1] = min(right[i], nums[i-1])
        result, left = set(), float(""-inf"")
        for i in range(len(nums)):
            if left <= nums[i] <= right[i+1]:
                result.add(nums[i])
            left = max(left, nums[i])
        return len(result)",O(n)
"class Solution2(object):
    def isCovered(self, ranges, left, right):
        ranges.sort()
        for l, r in ranges:
            if l <= left <= r:
                left = r+1
        return left > right",O(nlogn)
"class Solution(object):
    def getNoZeroIntegers(self, n):
        a, curr, base = 0, n, 1
        while curr: 
            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
                a += base
                curr -= 10 
            a += base
            base *= 10
            curr //= 10
        return [a, n-a]",O(logn)
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))",O(nlogn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def minMovesToMakePalindrome(self, s):
        idxs = [[] for _ in range(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in range(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1) 
            bit.add(i, 1)
        return result",O(nlogn)
"class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result",O(n ^ 2)
"import collections
import heapq


class Solution(object):
    def highFive(self, items):
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) > 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]",O(nlogn)
"class Solution(object):
    def goodDaysToRobBank(self, security, time):
        right = [0]
        for i in reversed(range(1, len(security))):
            right.append(right[-1]+1 if security[i] >= security[i-1] else 0)
        right.reverse()
        result = []
        left = 0
        for i in range(len(security)):
            if left >= time and right[i] >= time:
                result.append(i)
            if i+1 < len(security):
                left = left+1 if security[i] >= security[i+1] else 0
        return result",O(n)
"import threading


class Solution(object):
    def __init__(self):
        self.__l = threading.Lock()
        self.__nH = 0
        self.__nO = 0
        self.__releaseHydrogen = None
        self.__releaseOxygen = None

    def hydrogen(self, releaseHydrogen):
        with self.__l:
            self.__releaseHydrogen = releaseHydrogen
            self.__nH += 1
            self.__output()

    def oxygen(self, releaseOxygen):
        with self.__l:
            self.__releaseOxygen = releaseOxygen
            self.__nO += 1
            self.__output()

    def __output(self):
        while self.__nH >= 2 and \
              self.__nO >= 1:
            self.__nH -= 2
            self.__nO -= 1
            self.__releaseHydrogen()
            self.__releaseHydrogen()
            self.__releaseOxygen()",O(n)
"class Solution2(object):
    def __init__(self):
        self.__nH = 0
        self.__nO = 0
        self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):
        with self.__cv:
            while (self.__nH+1) - 2*self.__nO > 2:
                self.__cv.wait()
            self.__nH += 1
            releaseHydrogen()
            self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):
        with self.__cv:
            while 2*(self.__nO+1) - self.__nH > 2:
                self.__cv.wait()
            self.__nO += 1
            releaseOxygen()
            self.__cv.notifyAll()",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def maxDepth(self, root):
        if root is None:
            return 0
        else:
            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",O(n)
"import collections


class Solution(object):
    def subtreeWithAllDeepest(self, root):
        Result = collections.namedtuple(""Result"", (""node"", ""depth""))

        def dfs(node):
            if not node:
                return Result(None, 0)
            left, right = dfs(node.left), dfs(node.right)
            if left.depth > right.depth:
                return Result(left.node, left.depth+1)
            if left.depth < right.depth:
                return Result(right.node, right.depth+1)
            return Result(node, left.depth+1)

        return dfs(root).node",O(n)
"class Solution(object):
    def differenceOfSums(self, n, m):
        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
    
        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)",O(1)
"class Solution2(object):
    def differenceOfSums(self, n, m):
        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",O(1)
"import collections


class Solution(object):
    def minJumps(self, arr):
        groups = collections.defaultdict(list)
        for i, x in enumerate(arr):
            groups[x].append(i)
        q = collections.deque([(0, 0)])
        lookup = set([0])
        while q:
            pos, step = q.popleft()
            if pos == len(arr)-1:
                break
            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])
            groups[arr[pos]] = []
            for p in neighbors:
                if p in lookup or not 0 <= p < len(arr):
                    continue
                lookup.add(p)
                q.append((p, step+1)) 
        return step",O(n)
"class Solution(object):
    def smallestNumber(self, pattern):
        result = []
        for i in range(len(pattern)+1):
            if not (i == len(pattern) or pattern[i] == 'I'):
                continue
            for x in reversed(list(range(len(result)+1, (i+1)+1))):
                result.append(x)
        return """".join(map(str, result))",O(n)
"class Solution(object):
    def nextGreaterElements(self, nums):
        result, stk = [0] * len(nums), []
        for i in reversed(range(2*len(nums))):
            while stk and stk[-1] <= nums[i % len(nums)]:
                stk.pop()
            result[i % len(nums)] = stk[-1] if stk else -1
            stk.append(nums[i % len(nums)])
        return result",O(n)
"class Solution(object):
    def rotate(self, matrix):
        n = len(matrix)

        for i in range(n):
            for j in range(n - i):
                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]

        for i in range(n / 2):
            for j in range(n):
                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]

        return matrix",O(n ^ 2)
"class Solution2(object):
    def rotate(self, matrix):
        return [list(reversed(x)) for x in zip(*matrix)]",O(n ^ 2)
"class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        return sum(max(abs(points[i+1][0] - points[i][0]),
                       abs(points[i+1][1] - points[i][1]))
                   for i in range(len(points)-1))",O(n)
"class Solution(object):
    def findCenter(self, edges):
        return edges[0][edges[0][1] in edges[1]]",O(1)
"import itertools
from sortedcontainers import SortedList



class Solution(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        result = NEG_INF
        sl1, sl2 = SortedList(), SortedList()
        for price, profit in zip(prices, profits):
            result = max(result, query(sl2, price)+profit)
            update(sl1, price, profit)
            update(sl2, price, query(sl1, price)+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"from sortedcontainers import SortedList



class Solution2(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")

        right = [NEG_INF]*len(prices)
        sl = SortedList()
        for i in reversed(range(len(prices))):
            j = sl.bisect_left((-prices[i],))
            if j-1 >= 0:
                right[i] = sl[j-1][1]
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((-prices[i], profits[i]))
            j = sl.bisect_left((-prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        result = NEG_INF
        sl = SortedList()
        for i in range(len(prices)):
            j = sl.bisect_left((prices[i],))
            if j-1 >= 0:
                result = max(result, sl[j-1][1]+profits[i]+right[i])
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((prices[i], profits[i]))
            j = sl.bisect_left((prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        return result if result != NEG_INF else -1",O(nlogn)
"import itertools



class Solution3(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)
        for price, profit in zip(prices, profits):
            result = max(result, bit2.query(price_to_idx[price]-1)+profit)
            bit1.update(price_to_idx[price], profit)
            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"import itertools



class Solution4(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))
        for price, profit in zip(prices, profits):
            mx2 = st2.query(0, price_to_idx[price]-1)
            if mx2 is not None:
                result = max(result, mx2+profit)
            st1.update(price_to_idx[price], profit)
            mx1 = st1.query(0, price_to_idx[price]-1)
            if mx1 is not None:
                st2.update(price_to_idx[price], mx1+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"class Solution5(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        right = [NEG_INF]*len(prices)
        st = SegmentTree(len(price_to_idx))
        for i in reversed(range(len(prices))):
            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)
            st.update(price_to_idx[prices[i]], profits[i])
        result = NEG_INF
        st = SegmentTree(len(price_to_idx))
        for i in range(len(prices)):
            left = st.query(0, price_to_idx[prices[i]]-1)
            if left is not None and right[i] is not None:
                result = max(result, left+profits[i]+right[i])
            st.update(price_to_idx[prices[i]], profits[i])
        return result if result != NEG_INF else -1",O(nlogn)
"

class Solution(object):
    def greatestLetter(self, s):
        lookup = set(s)
        result = """"
        for c in s:
            if c.isupper() and lower(c) in s:
                if c > result:
                    result = c
        return result


",O(n)
"import itertools
import string



class Solution2(object):
    def greatestLetter(self, s):
        lookup = set(s)
        return next((C for c, C in zip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), """")",O(n)
"class Solution(object):
    def divisorGame(self, n):
        return n % 2 == 0",O(1)
"class Solution2(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result

        FACTORS = factors(n)
        dp = [False]*(n+1)
        for i in range(2, n+1):
            dp[i] = any(not dp[i-j] for j in FACTORS[i] if j != i)
        return dp[-1]",O(n ^ 2)
"class Solution3(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in FACTORS[n] if i != n)
            return lookup[n]

        FACTORS = factors(n)
        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"class Solution5(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if n%i:
                    continue
                yield i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)",O(n)
"class Solution(object):
    def getRow(self, rowIndex):
        result = [0] * (rowIndex + 1)
        for i in range(rowIndex + 1):
            old = result[0] = 1
            for j in range(1, i + 1):
                old, result[j] = result[j], old + result[j]
        return result

    def getRow2(self, rowIndex):
        row = [1]
        for _ in range(rowIndex):
            row = [x + y for x, y in zip([0] + row, row + [0])]
        return row

    def getRow3(self, rowIndex):
        if rowIndex == 0: return [1]
        res = [1, 1]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while res[1] < rowIndex:
            res = add(res)
        return res",O(n ^ 2)
"class Solution2(object):
    def getRow(self, rowIndex):
        result = [1]
        for i in range(1, rowIndex + 1):
            result = [1] + [result[j - 1] + result[j] for j in range(1, i)] + [1]
        return result",O(n ^ 2)
"class Solution(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            if s[i] == '0':
                continue
            curr = 0
            for j in range(i, len(s)):
                curr = curr*2+int(s[j])
                if max_pow_5%curr == 0:
                    dp[j+1] = min(dp[j+1], dp[(i-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1",O(n ^ 2)
"class Solution2(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            curr = 0
            for j in reversed(range(i+1)):
                curr += int(s[j])<<(i-j)
                if s[j] == '1' and max_pow_5%curr == 0:
                    dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1",O(n ^ 2)
"class Solution(object):
    def minimumMoney(self, transactions):
        return sum(max(a-b, 0) for a, b in transactions)+max(a-max(a-b, 0) for a, b in transactions)",O(n)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node:
                return
            if not node.left and not node.right:
                yield node.val
            for i in dfs(node.left):
                yield i
            for i in dfs(node.right):
                yield i
        return all(a == b for a, b in
                   itertools.zip_longest(dfs(root1), dfs(root2)))",O(n)
"import random



class Solution(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            cnt = [[0]*2 for _ in range(len(adj))]
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v, w in reversed(adj[u]):
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    curr = 0
                    diff = []
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        curr += cnt[v][0]
                        diff.append(max((cnt[v][1]+w)-cnt[v][0], 0))
                    if k-1 < len(diff):
                        nth_element(diff, k-1, lambda a, b: a > b)
                    cnt[u][0] = curr+sum(diff[i] for i in range(min(k, len(diff))))
                    cnt[u][1] = curr+sum(diff[i] for i in range(min(k-1, len(diff))))
            return cnt[0][0]
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return iter_dfs()",O(n)
"import random



class Solution2(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(u, p):
            result = 0
            diff = []
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                result += cnt[0]
                diff.append(max((cnt[1]+w)-cnt[0], 0))
            if k-1 < len(diff):
                nth_element(diff, k-1, lambda a, b: a > b)
            return (result+sum(diff[i] for i in range(min(k, len(diff)))), result+sum(diff[i] for i in range(min(k-1, len(diff)))))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dfs(0, -1)[0]",O(n)
"import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):
        def dfs(curr, path, result):
            if ""_end"" in curr:
                result.append(""/"" + ""/"".join(path))
                return
            for c in curr:
                if c == ""_end"":
                    continue
                path.append(c)
                dfs(curr[c], path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for f in folder:
            f_list = f.split(""/"")
            reduce(dict.__getitem__,
                   itertools.islice(f_list, 1, len(f_list)),
                   trie).setdefault(""_end"")
        result = []
        dfs(trie, [], result)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):
        result = 0
        s = [root]
        while s:
            node = s.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if L < node.val:
                    s.append(node.left)
                if node.val < R:
                    s.append(node.right)
        return result",O(n)
"class Solution(object):
    def elementInNums(self, nums, queries):
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i < len(nums):
                result.append(nums[t+i])
            elif i < t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result",O(n)
"import heapq



class Solution(object):
    def halveArray(self, nums):
        target = sum(nums)/2.0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        result = 1
        while max_heap:
            x = -heapq.heappop(max_heap)/2.0
            target -= x
            if target <= 0.0:
                break
            heapq.heappush(max_heap, -x)
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def pruneTree(self, root):
        if not root:
            return None
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if not root.left and not root.right and root.val == 0:
            return None
        return root",O(n)
"import itertools


class Solution(object):
    def magicalString(self, n):
        def gen(): 
            for c in 1, 2, 2:
                yield c
            for i, c in enumerate(gen()):
                if i > 1:
                    for _ in range(c):
                        yield i % 2 + 1

        return sum(c & 1 for c in itertools.islice(gen(), n))",O(n)
"class Solution(object):
    def isPossible(self, nums):
        pre, cur = float(""-inf""), 0
        cnt1, cnt2, cnt3 = 0, 0, 0
        i = 0
        while i < len(nums):
            cnt = 0
            cur = nums[i]
            while i < len(nums) and cur == nums[i]:
                cnt += 1
                i += 1

            if cur != pre + 1:
                if cnt1 != 0 or cnt2 != 0:
                    return False
                cnt1, cnt2, cnt3 = cnt, 0, 0
            else:
                if cnt < cnt1 + cnt2:
                    return False
                cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), \
                                   cnt1, \
                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))
            pre = cur
        return cnt1 == 0 and cnt2 == 0",O(n)
"class Solution(object):
    def beautifulArray(self, N):
        result = [1]
        while len(result) < N:
            result = [i*2 - 1 for i in result] + [i*2 for i in result]
        return [i for i in result if i <= N]",O(n)
"class Solution(object):
    def canSplitArray(self, nums, m):
        return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in range(len(nums)-1))",O(n)
"class Solution(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        curr = left = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            curr += nums[right%len(nums)]
            while curr > target:
                curr -= nums[left%len(nums)]
                left += 1
            if curr == target:
                result = min(result, right-left+1)
        return result+q*len(nums) if result != INF else -1",O(n)
"class Solution2(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        lookup = {0:-1}
        prefix = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            prefix += nums[right%len(nums)]
            if prefix-target in lookup:
                result = min(result, right-lookup[prefix-target])
            lookup[prefix] = right
        return result+q*len(nums) if result != INF else -1",O(n)
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",O(nlogn)
"class Solution(object):
    def checkDistances(self, s, distance):
        for i in range(len(s)):
            if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]:
                return False
            distance[ord(s[i])-ord('a')] = -1
        return True",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def shortestDistanceAfterQueries(self, n, queries):
        sl = SortedList(range(n))
        result = []
        for u, v in queries:
            for i in reversed(range(sl.bisect_right(u), sl.bisect_left(v))): 
                sl.pop(i)
            result.append(len(sl)-1)
        return result",O(nlogn)
"class Solution(object):
    def findMaximalUncoveredRanges(self, n, ranges):
        ranges.sort()
        covered = [[-1, -1]]
        for left, right in ranges:
            if covered[-1][1] < left:
                covered.append([left, right])
                continue
            covered[-1][1] = max(covered[-1][1], right)    
        covered.append([n, n])        
        return [[covered[i-1][1]+1, covered[i][0]-1] for i in range(1, len(covered)) if covered[i-1][1]+1 <= covered[i][0]-1]",O(nlogn)
"import collections


class Solution(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, curr, sum, lookup):
            if root is None:
                return 0
            curr += root.val
            result = lookup[curr-sum] if curr-sum in lookup else 0
            lookup[curr] += 1
            result += pathSumHelper(root.left, curr, sum, lookup) + \
                      pathSumHelper(root.right, curr, sum, lookup)
            lookup[curr] -= 1
            if lookup[curr] == 0:
                del lookup[curr]
            return result

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        return pathSumHelper(root, 0, sum, lookup)",O(n)
"class Solution2(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, prev, sum):
            if root is None:
                return 0

            curr = prev + root.val
            return int(curr == sum) + \
                   pathSumHelper(root.left, curr, sum) + \
                   pathSumHelper(root.right, curr, sum)

        if root is None:
            return 0

        return pathSumHelper(root, 0, sum) + \
               self.pathSum(root.left, sum) + \
               self.pathSum(root.right, sum)",O(n ^ 2)
"class Solution(object):
    def lexicographicallySmallestArray(self, nums, limit):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        groups = []
        for i in range(len(nums)):
            if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit:
                groups.append([])
            groups[-1].append(idxs[i])
        result = [-1]*len(nums)
        for g in groups:
            for i, j in enumerate(sorted(g)):
                result[j] = nums[g[i]]
        return result",O(nlogn)
"class ArrayReader(object):
   def compareSub(self, l, r, x, y):
       pass

   def length(self):
       pass

class Solution(object):
    def getIndex(self, reader):
        left, right = 0, reader.length()-1
        while left < right:
            mid = left + (right-left)//2
            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0:
                right = mid
            else:
                left = mid+1
        return left",O(logn)
"import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        jobs = sorted(zip(endTime, startTime, profit))
        dp = [(0, 0)]
        for e, s, p in jobs:
            i = bisect.bisect_right(dp, (s+1, 0))-1
            if dp[i][1]+p > dp[-1][1]:
                dp.append((e, dp[i][1]+p))
        return dp[-1][1]",O(nlogn)
"import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        min_heap = list(zip(startTime, endTime, profit))
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s < e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result",O(nlogn)
"class Solution(object):
    def appendCharacters(self, s, t):
        i = -1
        for j, c in enumerate(t):
            for i in range(i+1, len(s)):
                if s[i] == c:
                    break
            else:
                return len(t)-j
        return 0",other
"class Solution(object):
    def maxDistance(self, colors):
        result = 0
        for i, x in enumerate(colors):
            if x != colors[0]:
                result = max(result, i)
            if x != colors[-1]:
                result = max(result, len(colors)-1-i)
        return result",O(n)
"class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        def ceil_divide(a, b):
            return (a+(b-1))//b
        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))",O(n)
"class Solution(object):
    def addDigits(self, num):
        return (num - 1) % 9 + 1 if num > 0 else 0",O(1)
"class Solution(object):
    def minLength(self, s):
        stk = []
        for c in s:
            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):
                stk.pop()
                continue
            stk.append(c)
        return len(stk)",O(n)
"class Solution(object):
    def findDuplicates(self, nums):
        result = []
        for i in nums:
            if nums[abs(i)-1] < 0:
                result.append(abs(i))
            else:
                nums[abs(i)-1] *= -1
        return result",O(n)
"class Solution2(object):
    def findDuplicates(self, nums):
        result = []
        i = 0
        while i < len(nums):
            if nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
            else:
                i += 1

        for i in range(len(nums)):
            if i != nums[i]-1:
                result.append(nums[i])
        return result",O(n)
"from collections import Counter
class Solution3(object):
    def findDuplicates(self, nums):
        return [elem for elem, count in list(Counter(nums).items()) if count == 2]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):
        def inorder_gen(root, asc=True):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    if asc:
                        stack.append((root.right, False))
                        stack.append((root, True))
                        stack.append((root.left, False))
                    else:
                        stack.append((root.left, False))
                        stack.append((root, True))
                        stack.append((root.right, False))
        
        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
        left, right = next(left_gen), next(right_gen)
        while left is not None and right is not None:
            if left + right < target:
                left = next(left_gen)
            elif left + right > target:
                right = next(right_gen)
            else:
                return True
        return False",O(n)
"class Solution(object):
    def categorizeBox(self, length, width, height, mass):
        bulky = any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9
        heavy = mass >= 100
        if bulky and heavy:
            return ""Both""
        if bulky:
            return ""Bulky""
        if heavy:
            return ""Heavy""
        return ""Neither""",O(1)
"class Solution2(object):
    def categorizeBox(self, length, width, height, mass):
        CATEGORIES = [""Neither"", ""Heavy"", ""Bulky"", ""Both""]
        i = 2*(any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9)+int(mass >= 100)
        return CATEGORIES[i]",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def amountOfTime(self, root, start):
        def iter_dfs(root, start):
            result = -1
            stk = [(1, (root, [-1]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if curr is None:
                        continue
                    left, right = [-1]*2, [-1]*2
                    stk.append((2, (curr, left, right, ret)))
                    stk.append((1, (curr.right, right)))
                    stk.append((1, (curr.left, left)))
                elif step == 2:
                    curr, left, right, ret = args
                    d = -1
                    if curr.val == start:
                        d = 0
                        result = max(left[0], right[0])+1
                    elif left[1] >= 0:
                        d = left[1]+1
                        result = max(result, right[0]+1+d)
                    elif right[1] >= 0:
                        d = right[1]+1
                        result = max(result, left[0]+1+d)
                    ret[:] = [max(left[0], right[0])+1, d] 
            return result

        return iter_dfs(root, start)",O(n)
"class Solution2(object):
    def amountOfTime(self, root, start):
        def dfs(curr, start, result):
            if curr is None:
                return [-1, -1]
            left = dfs(curr.left, start, result)
            right = dfs(curr.right, start, result)
            d = -1
            if curr.val == start:
                d = 0
                result[0] = max(left[0], right[0])+1
            elif left[1] >= 0:
                d = left[1]+1
                result[0] = max(result[0], right[0]+1+d)
            elif right[1] >= 0:
                d = right[1]+1
                result[0] = max(result[0], left[0]+1+d)
            return [max(left[0], right[0])+1, d] 

        result = [-1]
        dfs(root, start, result)
        return result[0]",O(n)
"class Solution3(object):
    def amountOfTime(self, root, start):
        def bfs(root):
            adj = collections.defaultdict(list)
            q = [root]
            while q:
                new_q = []
                for u in q:
                    for v in (u.left, u.right):
                        if v is None:
                            continue
                        adj[u.val].append(v.val)
                        adj[v.val].append(u.val)
                        new_q.append(v)
                q = new_q
            return adj

        def bfs2(adj, start):
            result = -1
            q = [start]
            lookup = {start}
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        lookup.add(v)
                        new_q.append(v)
                q = new_q
                result += 1
            return result

        adj = bfs(root)
        return bfs2(adj, start)",O(n)
"class Solution(object):
    def findThePrefixCommonArray(self, A, B):
        result = [0]*len(A)
        cnt = collections.Counter()
        curr = 0
        for i, (a, b) in enumerate(zip(A, B)):
            cnt[a] += 1
            if cnt[a] == 2:
                curr += 1
            cnt[b] += 1
            if cnt[b] == 2:
                curr += 1
            result[i] = curr
        return result",O(n)
"class Solution(object):
    def numberOfSubarrays(self, nums, k):
        def atMost(nums, k):
            result, left, count = 0, 0, 0
            for right, x in enumerate(nums):
                count += x%2
                while count > k:
                    count -= nums[left]%2
                    left += 1
                result += right-left+1
            return result

        return atMost(nums, k) - atMost(nums, k-1)",O(n)
"import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        result = 0
        dq = collections.deque([-1])
        for i in range(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) > k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result",O(n)
"class Solution(object):
    def convert(self, s, numRows):
        if numRows == 1:
            return s
        step, zigzag = 2 * numRows - 2, """"
        for i in range(numRows):
            for j in range(i, len(s), step):
                zigzag += s[j]
                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):
                    zigzag += s[j + step - 2 * i]
        return zigzag",O(n)
"class Solution(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > 2:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > 2:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length",O(n)
"import itertools


class Solution(object):
    def knightDialer(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]
        
        M = 10**9 + 7
        T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
             [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
             [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
             [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],
             [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]]
        return sum(map(sum, matrix_expo(T, N-1))) % M",O(logn)
"class Solution2(object):
    def knightDialer(self, N):
        M = 10**9 + 7
        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],
                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]

        dp = [[1 for _ in range(10)] for _ in range(2)]
        for i in range(N-1):
            dp[(i+1) % 2] = [0] * 10
            for j in range(10):
                for nei in moves[j]:
                    dp[(i+1) % 2][nei] += dp[i % 2][j]
                    dp[(i+1) % 2][nei] %= M
        return sum(dp[(N-1) % 2]) % M",O(n)
"

class Solution(object):
    def constructTransformedArray(self, nums):
        return [nums[(i+nums[i])%len(nums)] for i in range(len(nums))]
",O(n)
"class Solution(object):
    def findUnsortedSubarray(self, nums):
        n = len(nums)
        left, right = -1, -2
        min_from_right, max_from_left = nums[-1], nums[0]
        for i in range(1, n):
            max_from_left = max(max_from_left, nums[i])
            min_from_right = min(min_from_right, nums[n-1-i])
            if nums[i] < max_from_left: right = i
            if nums[n-1-i] > min_from_right: left = n-1-i",O(n)
"class Solution2(object):
    def findUnsortedSubarray(self, nums):
        a = sorted(nums)
        left, right = 0, len(nums) -1
        while (nums[left] == a[left] or nums[right] == a[right]):
            if right - left <= 1:
                return 0
            if nums[left] == a[left]:
                left += 1
            if nums[right] == a[right]:
                right -= 1
        return right - left + 1",O(nlogn)
"class Solution(object):
    def numTimesAllBlue(self, light):
        result, right = 0, 0
        for i, num in enumerate(light, 1):
            right = max(right, num)
            result += (right == i)
        return result",O(n)
"class Solution(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        for i in range(len(s)):
            left, right = i+1, i
            while left-1 >= 0 and right+1 < len(s) and s[left-1] == '0' and s[right+1] == '1':
                left -= 1
                right += 1
            result = max(result, right-left+1)
        return result",O(n ^ 2)
"class Solution2(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        prev, cnt = [0]*2, [0]*2
        for c in s:
            cnt[int(c)] += 1
            if cnt[int(c)^1]:
                prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0
            result = max(result, 2*min(prev[0], cnt[1]))
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxAncestorDiff(self, root):
        result = 0
        stack = [(root, 0, float(""inf""))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result",O(n)
"class Solution2(object):
    def maxAncestorDiff(self, root):
        def maxAncestorDiffHelper(node, mx, mn): 
            if not node:
                return 0
            result = max(mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            result = max(result, maxAncestorDiffHelper(node.left, mx, mn))
            result = max(result, maxAncestorDiffHelper(node.right, mx, mn))
            return result

        return maxAncestorDiffHelper(root, 0, float(""inf""))",O(n)
"class Solution(object):
    def minFlips(self, s):
        result = float(""inf"")
        cnt1 = cnt2 = 0
        for i in range(2*len(s)-1 if len(s)%2 else len(s)):
            if i >= len(s):
                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0
                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1
            cnt1 += int(s[i%len(s)])^(i%2)^0
            cnt2 += int(s[i%len(s)])^(i%2)^1
            if i >= len(s)-1:
                result = min(result, cnt1, cnt2)
        return result",O(n)
"class Solution(object):
    def eliminateMaximum(self, dist, speed):
        for i in range(len(dist)):
            dist[i] = (dist[i]-1)//speed[i]
        dist.sort()
        result = 0
        for i in range(len(dist)):
            if result > dist[i]:
                break
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def resultsArray(self, nums, k):
        result = [-1]*(len(nums)-k+1)
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] != right-left:
                left = right
            if right-left+1 == k:
                result[left] = nums[right]
                left += 1
        return result",O(n)
"class Solution2(object):
    def resultsArray(self, nums, k):
        return [nums[i+k-1] if all(nums[j]+1 == nums[j+1] for j in range(i, i+k-1)) else -1 for i in range(len(nums)-k+1)]",other
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def deleteDuplicates(self, head):
        dummy = ListNode(0)
        pre, cur = dummy, head
        while cur:
            if cur.__next__ and cur.next.val == cur.val:
                val = cur.val
                while cur and cur.val == val:
                    cur = cur.__next__
                pre.next = cur
            else:
                pre.next = cur
                pre = cur
                cur = cur.__next__
        return dummy.__next__",O(n)
"from sortedcontainers import SortedList



class Solution2(object):
    def kBigIndices(self, nums, k):
        sl1, sl2 = SortedList(), SortedList(nums)
        result = 0
        for x in nums:
            sl2.remove(x)
            if sl1.bisect_left(x) >= k and sl2.bisect_left(x) >= k:
                result += 1
            sl1.add(x)
        return result",O(nlogn)
"class Solution(object):
    def numDupDigitsAtMostN(self, N):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(N+1)))
        result = 0

        for i in range(1, len(digits)):
            result += P(9, 1)*P(9, i-1)
        prefix_set = set()
        for i, x in enumerate(digits):
            for y in range(1 if i == 0 else 0, x):
                if y in prefix_set:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in prefix_set:
                break
            prefix_set.add(x)
        return N-result",O(logn)
"class Solution(object):
    def findBuildings(self, heights):
        result = []
        for i, h in enumerate(heights):
            while result and heights[result[-1]] <= h:
                result.pop()
            result.append(i)
        return result",O(n)
"class Solution2(object):
    def findBuildings(self, heights):
        result = []
        for i in reversed(range(len(heights))):
            if not result or heights[result[-1]] < heights[i]:
                result.append(i)
        result.reverse()
        return result",O(n)
"class Solution(object):
    def smallestNumber(self, n):
        return (1<<n.bit_length())-1",O(1)
"class Solution(object):
    def divisorSubstrings(self, num, k):
        result = curr = 0
        s = list(map(int, str(num)))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k >= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 >= k:
                result += int(curr and num%curr == 0)
        return result",O(logn)
"import collections


class Solution(object):
    def longestSubsequence(self, arr, difference):
        result = 1
        lookup = collections.defaultdict(int)
        for i in range(len(arr)):
            lookup[arr[i]] = lookup[arr[i]-difference] + 1
            result = max(result, lookup[arr[i]])
        return result",O(n)
"class Solution(object):
    def maxVowels(self, s, k):
        VOWELS = set(""aeiou"")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i >= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans",O(1)
"class Solution(object):
    def xorOperation(self, n, start):
        def xorNums(n, start):
            def xorNumsBeginEven(n, start):
                assert(start%2 == 0)
                return ((n//2)%2)^((start+n-1) if n%2 else 0)

            return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start)
        
        return int(n%2 and start%2) + 2*xorNums(n, start//2)",O(1)
"import operator
from functools import reduce


class Solution2(object):
    def xorOperation(self, n, start):
        return reduce(operator.xor, (i for i in range(start, start+2*n, 2)))",O(n)
"class Solution(object):
    def maxScore(self, nums):
        return sum(nums)-min(nums) if len(nums)%2 else sum(nums)-min(nums[i]+nums[i+1] for i in range(len(nums)-1))",O(n)
"class Solution(object):
    def minimumOperations(self, nums):
        return sum(x%3 != 0 for x in nums)",O(n)
"class Solution2(object):
    def minimumOperations(self, nums):
        return sum(min(x%3, 3-x%3) for x in nums)",O(n)
"class Solution(object):
    def numMovesStonesII(self, stones):
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1:
                min_moves = min(min_moves, 2) 
            else:
                min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]",O(nlogn)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"class Solution(object):
    def corpFlightBookings(self, bookings, n):
        result = [0]*(n+1)
        for i, j, k in bookings:
            result[i-1] += k
            result[j] -= k
        for i in range(1, len(result)):
            result[i] += result[i-1]
        result.pop()
        return result",O(n)
"class Solution(object):
    def maxPartitionsAfterOperations(self, s, k):
        def popcount(n):
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
            return n

        left = [0]*(len(s)+1)
        left_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in range(len(s)):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            left[i+1] = cnt
            left_mask[i+1] = mask
        right = [0]*(len(s)+1)
        right_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in reversed(range(len(s))):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            right[i] = cnt
            right_mask[i] = mask

        result = 0
        for i in range(len(s)):
            curr = left[i]+right[i+1]
            mask = left_mask[i]|right_mask[i+1]
            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:
                curr += 3
            elif popcount(mask)+int(popcount(mask) != 26) > k: 
                curr += 2
            else:
                curr += 1
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def fullJustify(self, words, maxWidth):
        def addSpaces(i, spaceCnt, maxWidth, is_last):
            if i < spaceCnt:
                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)
            return 0

        def connect(words, maxWidth, begin, end, length, is_last):
            s = [] 
            n = end - begin
            for i in range(n):
                s += words[begin + i],
                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),
            line = """".join(s)
            if len(line) < maxWidth:
                line += ' ' * (maxWidth - len(line))
            return line

        res = []
        begin, length = 0, 0
        for i in range(len(words)):
            if length + len(words[i]) + (i - begin) > maxWidth:
                res += connect(words, maxWidth, begin, i, length, False),
                begin, length = i, 0
            length += len(words[i])

        res += connect(words, maxWidth, begin, len(words), length, True),
        return res",O(n)
"import collections


class Solution(object):
    def numPairsDivisibleBy60(self, time):
        result = 0
        count = collections.Counter()
        for t in time:
            result += count[-t%60]
            count[t%60] += 1
        return result",O(n)
"class Solution(object):
    def findContestMatch(self, n):
        matches = list(map(str, list(range(1, n+1))))
        while len(matches)/2:
            matches = [""({},{})"".format(matches[i], matches[-i-1]) for i in range(len(matches)/2)]
        return matches[0]",O(n)
"class Solution(object):
    def kEmptySlots(self, flowers, k):
        days = [0] * len(flowers)
        for i in range(len(flowers)):
            days[flowers[i]-1] = i
        result = float(""inf"")
        i, left, right = 0, 0, k+1
        while right < len(days):
            if days[i] < days[left] or days[i] <= days[right]:
                if i == right:
                    result = min(result, max(days[left], days[right]))
                left, right = i, k+1+i
            i += 1
        return -1 if result == float(""inf"") else result+1",O(n)
"class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]",O(n)
"class Solution(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] == '1':
                curr += 1
            elif i+1 == len(s) or s[i+1] == '1':
                result += curr
        return result",O(n)
"class Solution2(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            curr += 1
            if i+1 < len(s) and s[i+1] == '0':
                result += curr
        return result",O(n)
"class Solution(object):
    def projectionArea(self, grid):
        result = 0
        for i in range(len(grid)):
            max_row, max_col = 0, 0
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 1
                max_row = max(max_row, grid[i][j])
                max_col = max(max_col, grid[j][i])
            result += max_row + max_col
        return result",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums):
        def unique(nums):
            left = 0
            for right in range(1, len(nums)):
                if nums[left] != nums[right]:
                    left += 1
                    nums[left] = nums[right]
            return left

        def erase(nums, i):
            while len(nums) > i+1:
                nums.pop()

        n = len(nums)
        nums.sort()
        erase(nums, unique(nums))
        result = l = 0
        for i in range(len(nums)):
            if nums[i] <= nums[i-l]+n-1:
                l += 1
        return n-l",O(nlogn)
"class Solution2(object):
    def minOperations(self, nums):
        n = len(nums)
        nums = sorted(set(nums))
        result = right = 0
        for left in range(len(nums)):
            while right < len(nums) and nums[right] <= nums[left]+n-1:
                right += 1
            result = max(result, right-left)
        return n-result",O(nlogn)
"class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result",O(n)
"class Solution(object):
    def numTeams(self, rating):
        result = 0
        for i in range(1, len(rating)-1):
            less, greater = [0]*2, [0]*2
            for j in range(len(rating)):
                if rating[i] > rating[j]:
                    less[i < j] += 1
                if rating[i] < rating[j]:
                    greater[i < j] += 1
            result += less[0]*greater[1] + greater[0]*less[1]
        return result",O(n ^ 2)
"
class Solution(object):
    def minPartitions(self, n):
        return int(max(n))
",O(n)
"
import itertools



class Solution(object):
    def relocateMarbles(self, nums, moveFrom, moveTo):
        lookup = set(nums)
        for a, b in zip(moveFrom, moveTo):
            lookup.remove(a)
            lookup.add(b)
        return sorted(lookup)
",O(nlogn)
"class Solution(object):
    def minCost(self, costs):
        if not costs:
            return 0

        min_cost = [costs[0], [0, 0, 0]]

        n = len(costs)
        for i in range(1, n):
            min_cost[i % 2][0] = costs[i][0] + \
                                 min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][1] = costs[i][1] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][2] = costs[i][2] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1])

        return min(min_cost[(n - 1) % 2])",O(n)
"class Solution2(object):
    def minCost(self, costs):
        if not costs:
            return 0

        n = len(costs)
        for i in range(1, n):
            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

        return min(costs[n - 1])",O(n)
"class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):
        curr, max_count = 1, 1
        for i in range(1, len(nums)):
            curr = 1 if nums[i-1] < nums[i] else curr+1
            max_count = max(max_count, curr)
        return K*max_count <= len(nums)",O(n)
"class Solution(object):
    def countPalindromicSubsequences(self, S):
        def dp(i, j, prv, nxt, lookup):
            if lookup[i][j] is not None:
                return lookup[i][j]
            result = 1
            if i <= j:
                for x in range(4):
                    i0 = nxt[i][x]
                    j0 = prv[j][x]
                    if i <= i0 <= j:
                        result = (result + 1) % P
                    if None < i0 < j0:
                        result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P
            result %= P
            lookup[i][j] = result
            return result

        prv = [None] * len(S)
        nxt = [None] * len(S)

        last = [None] * 4
        for i in range(len(S)):
            last[ord(S[i])-ord('a')] = i
            prv[i] = tuple(last)

        last = [None] * 4
        for i in reversed(range(len(S))):
            last[ord(S[i])-ord('a')] = i
            nxt[i] = tuple(last)

        P = 10**9 + 7
        lookup = [[None] * len(S) for _ in range(len(S))]
        return dp(0, len(S)-1, prv, nxt, lookup) - 1",O(n ^ 2)
"class Solution(object):
    def largestIsland(self, grid):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def dfs(r, c, index, grid):
            if not (0 <= r < len(grid) and
                    0 <= c < len(grid[0]) and
                    grid[r][c] == 1):
                return 0
            result = 1
            grid[r][c] = index
            for d in directions:
                result += dfs(r+d[0], c+d[1], index, grid)
            return result

        area = {}
        index = 2
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index, grid)
                    index += 1

        result = max(list(area.values()) or [0])
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    seen = set()
                    for d in directions:
                        nr, nc = r+d[0], c+d[1]
                        if not (0 <= nr < len(grid) and
                                0 <= nc < len(grid[0]) and
                                grid[nr][nc] > 1):
                            continue
                        seen.add(grid[nr][nc])
                    result = max(result, 1 + sum(area[i] for i in seen))
        return result",O(n ^ 2)
"class Solution(object):
    def numberOfArrays(self, differences, lower, upper):
        total = mn = mx = 0
        for x in differences:
            total += x
            mn = min(mn, total)
            mx = max(mx, total)
        return max((upper-lower)-(mx-mn)+1, 0)",O(n)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def diameter(self, root):
        def iter_dfs(root):
            result = [0]*2
            stk = [(1, (root, result))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    for child in reversed(node.children):
                        ret2 = [0]*2
                        stk.append((2, (ret2, ret)))
                        stk.append((1, (child, ret2)))
                else:
                    ret2, ret = params
                    ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1)
                    ret[1] = max(ret[1], ret2[1]+1)
            return result
        
        return iter_dfs(root)[0]",O(n)
"class Solution2(object):
    def diameter(self, root):
        def dfs(node):
            max_dia, max_depth = 0, 0
            for child in node.children:
                child_max_dia, child_max_depth = dfs(child)
                max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1)
                max_depth = max(max_depth, child_max_depth+1)
            return max_dia, max_depth
        
        return dfs(root)[0]",O(n)
"class Solution(object):
    def maximumTime(self, time):
        result = list(time)
        for i, c in enumerate(time): 
            if c != ""?"":
                continue
            if i == 0:
                result[i] = '2' if result[i+1] in ""?0123"" else '1'
            elif i == 1:
                result[i] = '3' if result[0] == '2' else '9'
            elif i == 3:
                result[i] = '5'
            elif i == 4:
                result[i] = '9'
        return """".join(result)",O(1)
"import pandas as pd



def Solution(animals: pd.DataFrame) -> pd.DataFrame:
     return animals[animals['weight'] > 100].sort_values(by=""weight"", ascending=False)[['name']]",O(nlogn)
"class Solution(object):
    def maxNonDecreasingLength(self, nums1, nums2):
        result = 1
        dp = [1]*2
        for i in range(len(nums1)-1):
            dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)),
                  max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))]
            result = max(result, max(dp))
        return result",O(n)
"

class Solution(object):
    def maxContainers(self, n, w, maxWeight):
        return min(maxWeight//w, n*n)
",O(1)
"class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        MOD = 10**9 + 7
        if primeFactors <= 3:
            return primeFactors
        if primeFactors % 3 == 0: 
            return pow(3, primeFactors//3, MOD)
        if primeFactors % 3 == 1: 
            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD
        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD",O(logn)
"import collections



class Solution(object):
    def canBeEqual(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"class Solution2(object):
    def canBeEqual(self, s1, s2):
        return (((s1[0] == s2[0] and s1[2] == s2[2]) or (s1[0] == s2[2] and s1[2] == s2[0])) and
                ((s1[1] == s2[1] and s1[3] == s2[3]) or (s1[1] == s2[3] and s1[3] == s2[1])))",O(1)
"import sortedcontainers


class Solution(object):
    def maxDepthBST(self, order):
        depths = sortedcontainers.SortedDict({float(""-inf""):0, float(""inf""):0})
        values_view = list(depths.values())
        result = 0
        for x in order:
            i = depths.bisect_right(x)
            depths[x] = max(values_view[i-1:i+1])+1
            result = max(result, depths[x])
        return result",O(nlogn)
"class Solution(object):
    def minimumArrayLength(self, nums):
        mn = min(nums)
        return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1",O(n)
"import collections



class Solution(object):
    def countCompleteSubarrays(self, nums):
        nums_set = set(nums)
        result = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while len(cnt) == len(nums_set):
                cnt[nums[left]] -= 1
                if cnt[nums[left]] == 0:
                    del cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"class Solution(object):
    def minOperations(self, boxes):
        result = [0]*len(boxes)
        for direction in (lambda x:x, reversed):
            cnt = accu = 0
            for i in direction(range(len(boxes))):
                result[i] += accu
                if boxes[i] == '1':
                    cnt += 1
                accu += cnt
        return result",O(n)
"class Solution(object):
    def secondsToRemoveOccurrences(self, s):
        result = cnt = 0
        for c in s: 
            if c == '0':
                cnt += 1
                continue
            if cnt:
                result = max(result+1, cnt)
        return result",O(n)
"
import itertools


class Solution(object):
    def printVertically(self, s):
        return ["""".join(c).rstrip() for c in itertools.zip_longest(*s.split(), fillvalue=' ')]
",O(n)
"class Solution(object):
    def maxSumTwoNoOverlap(self, A, L, M):
        for i in range(1, len(A)):
            A[i] += A[i-1]
        result, L_max, M_max = A[L+M-1], A[L-1], A[M-1]
        for i in range(L+M, len(A)):
            L_max = max(L_max, A[i-M] - A[i-L-M])
            M_max = max(M_max, A[i-L] - A[i-L-M])
            result = max(result,
                         L_max + A[i] - A[i-M],
                         M_max + A[i] - A[i-L])
        return result",O(n)
"import heapq



class Solution(object):
    def minimumDifference(self, nums):
        max_heap = []
        for i in range(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in range(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(range(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(range(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result",O(nlogn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)
        return result

",O(n)
"class Solution(object):
    def alternateDigitSum(self, n):
        result = 0
        sign = 1
        while n:
            sign *= -1
            result += sign*(n%10)
            n //= 10
        return sign*result",O(logn)
"import heapq



class Solution(object):
    def minEliminationTime(self, timeReq, splitTime):
        heapq.heapify(timeReq)
        for _ in range(len(timeReq)-1):
            heapq.heappush(timeReq, max(heapq.heappop(timeReq), heapq.heappop(timeReq))+splitTime)
        return timeReq[0]",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):
        def bstFromPreorderHelper(preorder, left, right, index):
            if index[0] == len(preorder) or \
               preorder[index[0]] < left or \
               preorder[index[0]] > right:
                return None

            root = TreeNode(preorder[index[0]])
            index[0] += 1
            root.left = bstFromPreorderHelper(preorder, left, root.val, index)
            root.right = bstFromPreorderHelper(preorder, root.val, right, index)
            return root
        
        return bstFromPreorderHelper(preorder, float(""-inf""), float(""inf""), [0])",O(n)
"class Solution(object):
    def countVowelStrings(self, n):
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4)",O(1)
"import collections


class Solution(object):
    def maxResult(self, nums, k):
        score = 0
        dq = collections.deque()
        for i, num in enumerate(nums):
            if dq and dq[0][0] == i-k-1:
                dq.popleft()
            score = num if not dq else dq[0][1]+num
            while dq and dq[-1][1] <= score:
                dq.pop()
            dq.append((i, score))
        return score",O(n)
"class Solution2(object):
    def findChampion(self, n, edges):
        lookup = [False]*n
        for u, v in edges:
            lookup[v] = True
        result = -1
        for u in range(n):
            if lookup[u]:
                continue
            if result != -1:
                return -1
            result = u
        return result",O(n)
"class Solution2(object):
    def findChampion(self, n, edges):
        lookup = {v for _, v in edges}
        return next(u for u in range(n) if u not in lookup) if len(lookup) == n-1 else -1",O(n)
"
import collections


class Solution(object):
    def groupThePeople(self, groupSizes):
        groups, result = collections.defaultdict(list), []
        for i, size in enumerate(groupSizes):
            groups[size].append(i)
            if len(groups[size]) == size:
                result.append(groups.pop(size))
        return result
",O(n)
"class Solution(object):
    def maxDepth(self, s):
        result = curr = 0
        for c in s:
            if c == '(':
                curr += 1
                result = max(result, curr)
            elif c == ')':
                curr -= 1
        return result",O(n)
"class Solution(object):
    def sumOfLeftLeaves(self, root):
        def sumOfLeftLeavesHelper(root, is_left):
            if not root:
                return 0
            if not root.left and not root.right:
                return root.val if is_left else 0
            return sumOfLeftLeavesHelper(root.left, True) + \
                   sumOfLeftLeavesHelper(root.right, False)

        return sumOfLeftLeavesHelper(root, False)",O(n)
"import collections



class Solution(object):
    def largestPalindromic(self, num):
        cnt = collections.Counter(num)
        result = []
        for i in reversed(range(10)):
            if not cnt[str(i)]//2 or (i == 0 and not result):
                continue
            for _ in range(cnt[str(i)]//2):
                result.append(str(i))
        result.append(max([k for k, v in cnt.items() if v%2] or [""""]))
        for i in reversed(range(len(result)-1)):
            result.append(result[i])
        return """".join(result) or ""0""",O(n)
"import collections
import operator
from functools import reduce



class Solution(object):
    def beautifulSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))-1",O(n)
"class Solution(object):
    def diagonalSum(self, mat):
        return sum(mat[i][i]+mat[~i][i] for i in range(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0)",O(n)
"import collections



class Solution(object):
    def minCost(self, nums, k):
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(len(dp)-1):
            cnt = [0]*len(nums)
            d = 0
            for j in range(i+1, len(dp)):
                cnt[nums[j-1]] += 1
                if cnt[nums[j-1]] == 1:
                    d += 1
                elif cnt[nums[j-1]] == 2:
                    d -= 1
                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))
        return dp[-1]",O(n ^ 2)
"class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]",O(n)
"import random



class Solution(object):
    def minimumCost(self, nums):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, 1+(2-1), 1)
        return nums[0]+nums[1]+nums[2]",O(n)
"class Solution2(object):
    def minimumCost(self, nums):
        def topk(a, k):
            result = [float(""inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x < result[i]:
                        result[i], x = x, result[i]
            return result

        return nums[0]+sum(topk((nums[i] for i in range(1, len(nums))), 2))",O(n)
"class Solution(object):
    def minOperations(self, nums):
        def popcount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        result, max_len = 0, 1
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + (max_len-1)",O(nlogn)
"class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last, i, same = 0, 1, False
        while i < len(A):
            if A[last] != A[i] or not same:
                same = A[last] == A[i]
                last += 1
                A[last] = A[i]
            i += 1

        return last + 1",O(n)
"import bisect


class Solution(object):
    def minAbsoluteSumDiff(self, nums1, nums2):
        MOD = 10**9+7

        sorted_nums1 = sorted(nums1)
        result = max_change = 0
        for i in range(len(nums2)):
            diff = abs(nums1[i]-nums2[i])
            result = (result+diff)%MOD
            if diff < max_change:
                continue
            j = bisect.bisect_left(sorted_nums1, nums2[i])
            if j != len(sorted_nums1):
                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))
            if j != 0:
                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))
        return (result-max_change)%MOD",O(nlogn)
"class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):
        if width < height:
            width, height = height, width


        R, r = divmod(height, sideLength)
        C, c = divmod(width, sideLength)
        assert(R <= C)
        area_counts = [(r*c, (R+1)*(C+1)), \
                       (r*(sideLength-c), (R+1)*C), \
                       ((sideLength-r)*c, R*(C+1)), \
                       ((sideLength-r)*(sideLength-c), R*C)]
        result = 0
        for area, count in area_counts:
            area = min(maxOnes, area)
            result += count*area
            maxOnes -= area
            if not maxOnes:
                break
        return result",O(1)
"class Solution(object):
    def splitLoopedString(self, strs):
        tmp = []
        for s in strs:
            tmp += max(s, s[::-1])
        s = """".join(tmp)

        result, st = ""a"", 0
        for i in range(len(strs)):
            body = """".join([s[st + len(strs[i]):], s[0:st]])
            for p in strs[i], strs[i][::-1]:
                for j in range(len(strs[i])):
                    if p[j] >= result[0]:
                        result = max(result, """".join([p[j:], body, p[:j]]))
            st += len(strs[i])
        return result",O(n ^ 2)
"class Solution(object):
    def averageOfLevels(self, root):
        result = []
        q = [root]
        while q:
            total, count = 0, 0
            next_q = []
            for n in q:
                total += n.val
                count += 1
                if n.left:
                    next_q.append(n.left)
                if n.right:
                    next_q.append(n.right)
            q = next_q
            result.append(float(total) / count)
        return result",O(n)
"class Solution(object):
    def haveConflict(self, event1, event2):
        return max(event1[0], event2[0]) <= min(event1[1], event2[1])",O(1)
"import itertools


class Solution(object):
    def maxCoins(self, piles):
        piles.sort()
        return sum(itertools.islice(piles, len(piles)//3, len(piles), 2))",O(nlogn)
"class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result",O(n)
"
import operator
from functools import reduce



class Solution(object):
    def xorBeauty(self, nums):
        return reduce(operator.xor, nums)
",O(n)
"import math


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1)))",O(1)
"class Solution(object):
    def checkIfPangram(self, sentence):
        return len(set(sentence)) == 26",O(n)
"
import heapq


class Solution(object):
    def smallestChair(self, times, targetFriend):
        events = []
        for i, (s, e) in enumerate(times): 
            events.append((s, True, i))
            events.append((e, False, i))
        events.sort()

        lookup = {}
        min_heap = []
        for _, arrival, i in events: 
            if not arrival: 
                heapq.heappush(min_heap, lookup.pop(i))
                continue
            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)
            if i == targetFriend:
                break
        return lookup[targetFriend]
",O(nlogn)
"
class Solution(object):
    def targetIndices(self, nums, target):
        less = sum(x < target for x in nums)
        return list(range(less, less+sum(x == target for x in nums)))
",O(n)
"class Solution(object):
    def findMinArrowShots(self, points):
        if not points:
            return 0

        points.sort()

        result = 0
        i = 0
        while i < len(points):
            j = i + 1
            right_bound = points[i][1]
            while j < len(points) and points[j][0] <= right_bound:
                right_bound = min(right_bound, points[j][1])
                j += 1
            result += 1
            i = j
        return result",O(nlogn)
"import heapq


class Solution(object):
    def connectSticks(self, sticks):
        heapq.heapify(sticks)
        result = 0
        while len(sticks) > 1:
            x, y = heapq.heappop(sticks), heapq.heappop(sticks)
            result += x+y
            heapq.heappush(sticks, x+y)
        return result",O(nlogn)
"class Solution(object):
    def addMinimum(self, word):
        return 3*(sum(i-1 < 0 or word[i-1] >= word[i] for i in range(len(word))))-len(word)",O(n)
"class Solution(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = i = j = 0
        while i < len(team) and j < len(team):
            if i+dist < j or team[i] != 1:
                i += 1
            elif j+dist < i or team[j] != 0:
                j += 1
            else:
                result += 1
                i += 1
                j += 1
        return result",O(n)
"class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = j = 0
        for i in range(len(team)):
            if not team[i]:
                continue
            while j < i-dist:
                j += 1
            while j <= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j <= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result",O(n)
"class NestedInteger(object):
   def __init__(self, value=None):
       def isInteger(self):
       def add(self, elem):
       def setInteger(self, value):
       def getInteger(self):
       def getList(self):
       class Solution(object):
    def deserialize(self, s):
        if not s:
            return NestedInteger()

        if s[0] != '[':
            return NestedInteger(int(s))

        stk = []

        i = 0
        for j in range(len(s)):
            if s[j] == '[':
                stk += NestedInteger(),
                i = j+1
            elif s[j] in ',]':
                if s[j-1].isdigit():
                    stk[-1].add(NestedInteger(int(s[i:j])))
                if s[j] == ']' and len(stk) > 1:
                    cur = stk[-1]
                    stk.pop()
                    stk[-1].add(cur)
                i = j+1

        return stk[-1]",O(n)
"import collections
import itertools


class Solution(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        if not ((bucket_cnt-1)*k+sum(x == bucket_cnt for x in cnts.values()) <= len(s)):
            return """"
        result = [0]*len(s)
        i = (len(s)-1)%k
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt), (c for c, v in cnts.items() if v != bucket_cnt)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = (i-1)%k
        return """".join(result)",O(n)
"import collections
import itertools



class Solution2(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = (len(s)+k-1)//k
        if not (max(cnts.values()) <= bucket_cnt and list(cnts.values()).count(bucket_cnt) <= (len(s)-1)%k+1):
            return """"
        result = [0]*len(s)
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = i%k+1
        return """".join(result)",O(n)
"import collections
import itertools


class Solution3(object):
    def rearrangeString(self, s, k):
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        buckets = [[] for _ in range(bucket_cnt)]
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2)):
            for _ in range(cnts[c]):
                buckets[i].append(c)
                i = (i+1) % max(cnts[c], bucket_cnt-1)
        if any(len(buckets[i]) < k for i in range(len(buckets)-1)):
            return """"
        return """".join(["""".join(x) for x in buckets])",O(n)
"class Solution(object):
    def resultArray(self, nums):
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            if a[-1] > b[-1]:
                a.append(nums[i])
            else:
                b.append(nums[i])
        return a+b",O(n)
"import pandas as pd



def Solution(report: pd.DataFrame) -> pd.DataFrame:
    return report.melt(
        id_vars=[""product""],
        value_vars=[f""quarter_{i}"" for i in range(1, 4+1)],
        var_name=""quarter"",
        value_name=""sales"",
    )",O(n)
"class Solution(object):
    def angleClock(self, hour, minutes):
        angle1 = (hour % 12 * 60.0 + minutes) / 720.0
        angle2 = minutes / 60.0
        diff = abs(angle1-angle2)
        return min(diff, 1.0-diff) * 360.0",O(1)
"class Solution(object):
    def shortestDistance(self, words, word1, word2):
        dist = float(""inf"")
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"class Solution(object):
    def getMaximumConsecutive(self, coins):
        coins.sort()
        result = 1
        for c in coins:
            if c > result:
                break
            result += c
        return result",O(nlogn)
"import collections


class Solution(object):
    def sumOfDistancesInTree(self, N, edges):
        def dfs(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    dfs(graph, nei, node, count, result)
                    count[node] += count[nei]
                    result[node] += result[nei]+count[nei]

        def dfs2(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    result[nei] = result[node]-count[nei] + \
                                  len(count)-count[nei]
                    dfs2(graph, nei, node, count, result)

        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        count = [1] * N
        result = [0] * N

        dfs(graph, 0, None, count, result)
        dfs2(graph, 0, None, count, result)
        return result",O(n)
"import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result",O(n)
"class Solution(object):
    def maxSubArrayLen(self, nums, k):
        sums = {}
        cur_sum, max_len = 0, 0
        for i in range(len(nums)):
            cur_sum += nums[i]
            if cur_sum == k:
                max_len = i + 1
            elif cur_sum - k in sums:
                max_len = max(max_len, i - sums[cur_sum - k])
            if cur_sum not in sums:
                sums[cur_sum] = i 
        return max_len",O(n)
"class Solution(object):
    def maxBuilding(self, n, restrictions):
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        for i in reversed(range(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))
        result = 0
        for i in range(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))
            left, h1 = restrictions[i-1]
            right, h2 = restrictions[i]
            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)
        return result",O(nlogn)
"class Solution(object):
    def maxStrength(self, nums):
        if all(x <= 0 for x in nums) and sum(x < 0 for x in nums) <= 1:
            return max(nums)
        result = reduce(lambda x, y: x*y, (x for x in nums if x))
        return result if result > 0 else result//max(x for x in nums if x < 0)",O(n)
"class Solution(object):
    def theMaximumAchievableX(self, num, t):
        return num+2*t",O(1)
"class Solution(object):
    def mincostTickets(self, days, costs):
        durations = [1, 7, 30]
        W = durations[-1]
        dp = [float(""inf"") for i in range(W)]
        dp[0] = 0
        last_buy_days = [0, 0, 0]
        for i in range(1,len(days)+1):
            dp[i%W] = float(""inf"")
            for j in range(len(durations)):
                while i-1 < len(days) and \
                      days[i-1] > days[last_buy_days[j]]+durations[j]-1:
                    last_buy_days[j] += 1 
                dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j])
        return dp[len(days)%W]",O(n)
"class Solution(object):
    def canEat(self, candiesCount, queries):
        prefix = [0]*(len(candiesCount)+1)
        for i, c in enumerate(candiesCount):
            prefix[i+1] = prefix[i]+c
        return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries]",O(n)
"class Solution(object):
    def merge(self, A, m, B, n):
        last, i, j = m + n - 1, m - 1, n - 1

        while i >= 0 and j >= 0:
            if A[i] > B[j]:
                A[last] = A[i]
                last, i = last - 1, i - 1
            else:
                A[last] = B[j]
                last, j = last - 1, j - 1

        while j >= 0:
                A[last] = B[j]
                last, j = last - 1, j - 1",O(n)
"import collections


class Solution(object):
    def subarraySum(self, nums, k):
        result = 0
        accumulated_sum = 0
        lookup = collections.defaultdict(int)
        lookup[0] += 1
        for num in nums:
            accumulated_sum += num
            result += lookup[accumulated_sum - k]
            lookup[accumulated_sum] += 1
        return result",O(n)
"class Solution(object):
    def countKeyChanges(self, s):
        return sum(s[i].lower() != s[i+1].lower() for i in range(len(s)-1))",O(n)
"class Solution(object):
    def findFinalValue(self, nums, original):
        lookup = set(nums)
        while original in lookup:
            original *= 2
        return original",O(n)
"import collections


class Solution(object):
    def groupStrings(self, strings):
        groups = collections.defaultdict(list)
        for s in strings: 
            groups[self.hashStr(s)].append(s)

        result = []
        for key, val in groups.items():
            result.append(sorted(val))

        return result

    def hashStr(self, s):
        base = ord(s[0])
        hashcode = """"
        for i in range(len(s)):
            if ord(s[i]) - base >= 0:
                hashcode += chr(ord('a') + ord(s[i]) - base)
            else:
                hashcode += chr(ord('a') + ord(s[i]) - base + 26)
        return hashcode",other
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",O(n)
"class Solution(object):
    def canCross(self, stones):
        if stones[1] != 1:
            return False

        last_jump_units = {s: set() for s in stones}
        last_jump_units[1].add(1)
        for s in stones[:-1]:
            for j in last_jump_units[s]:
                for k in (j-1, j, j+1):
                    if k > 0 and s+k in last_jump_units:
                        last_jump_units[s+k].add(k)
        return bool(last_jump_units[stones[-1]])",O(n ^ 2)
"class Solution(object):
    def maxProfit(self, prices):
        profit = 0
        for i in range(len(prices) - 1):
            profit += max(0, prices[i + 1] - prices[i])
        return profit

    def maxProfit2(self, prices):
        return sum([max(prices[x + 1] - prices[x], 0) for x in range(len(prices[:-1]))])",O(n)
"class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        return 0.5 if n != 1 else 1.0",O(1)
"class Solution2(object):
    def nthPersonGetsNthSeat(self, n):
        dp = [0.0]*2
        dp[0] = 1.0 
        for i in range(2, n+1):
            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i
        return dp[(n-1)%2]",O(n)
"class Solution(object):
    def getMinDistance(self, nums, target, start):
        for i in range(len(nums)):
            if (start-i >= 0 and nums[start-i] == target) or \
               (start+i < len(nums) and nums[start+i] == target):
                break
        return i",O(n)
"class Solution(object):
    def minDistance(self, height, width, tree, squirrel, nuts):
        def distance(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        result = 0
        d = float(""inf"")
        for nut in nuts:
            result += (distance(nut, tree) * 2)
            d = min(d, distance(nut, squirrel) - distance(nut, tree))
        return result + d",O(n)
"class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        return 100-(purchaseAmount+5)//10*10",O(1)
"from collections import deque

class Solution(object):

    def __init__(self):
        self.__k = 300
        self.__dq = deque()
        self.__count = 0

    def hit(self, timestamp):
        self.getHits(timestamp)
        if self.__dq and self.__dq[-1][0] == timestamp:
            self.__dq[-1][1] += 1
        else:
            self.__dq.append([timestamp, 1])
        self.__count += 1

    def getHits(self, timestamp):
        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
            self.__count -= self.__dq.popleft()[1]
        return self.__count",O(1)
"class Solution(object):
    def maxScoreSightseeingPair(self, A):
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result",O(n)
"import collections


class Solution(object):
    def largestUniqueNumber(self, A):
        A.append(-1)
        return max(k for k,v in list(collections.Counter(A).items()) if v == 1)",O(n)
"class Solution(object):
    def zeroFilledSubarray(self, nums):
        result = 0
        prev = -1
        for i in range(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result",O(n)
"import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        R, C = 10**6, 10**6
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(blocks, source, target):
            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2
            lookup = set([source])
            if len(lookup) > max_area_surrounded_by_blocks:
                return True
            q = collections.deque([source])
            while q:
                source = q.popleft()
                if source == target:
                    return True
                for direction in directions:
                    nr, nc = source[0]+direction[0], source[1]+direction[1]
                    if not ((0 <= nr < R) and
                            (0 <= nc < C) and 
                            (nr, nc) not in lookup and
                            (nr, nc) not in blocks):
                        continue
                    lookup.add((nr, nc))
                    if len(lookup) > max_area_surrounded_by_blocks:
                        return True
                    q.append((nr, nc))
            return False
        
        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \
               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def distributeCoins(self, root):
        def dfs(root, result):
            if not root:
                return 0
            left, right = dfs(root.left, result), dfs(root.right, result)
            result[0] += abs(left) + abs(right)
            return root.val + left + right - 1

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"import collections


class Solution(object):
    def frequencySort(self, s):
        freq = collections.defaultdict(int)
        for c in s:
            freq[c] += 1

        counts = [""""] * (len(s)+1)
        for c in freq:
            counts[freq[c]] += c

        result = """"
        for count in reversed(range(len(counts)-1)):
            for c in counts[count]:
                result += c * count

        return result",O(n)
"class Solution(object):
    def uniqueXorTriplets(self, nums):
        return 1<<len(nums).bit_length() if len(nums) >= 3 else len(nums)",O(1)
"import itertools



class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(i+1, n):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        return result",O(n ^ 2)
"import itertools



class Solution2(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        result.reverse()
        return result",O(n ^ 2)
"import itertools



class Solution3(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]) and len(dp[j]) > len(dp[i]):
                    dp[i] = dp[j]
            dp[i] = dp[i]+[i]
        return [words[x] for x in max(dp, key=lambda x: len(x))]",O(n ^ 2)
"class Solution(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 

        def inplace_counting_sort(nums, left, right, reverse=False): 
            if right-left+1 == 0:
                return
            count = [0]*(max(nums[i] for i in range(left, right+1))+1)
            for i in range(left, right+1):
                count[nums[i]] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(left, right+1)): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = left+count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(left, right+1):
                nums[i] = ~nums[i] 
            if reverse: 
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        inplace_counting_sort(nums, 0, (len(nums)+1)//2-1)
        inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums",O(n)
"class Solution2(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
        
        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums",O(nlogn)
"class Solution3(object):
    def sortEvenOdd(self, nums):
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def str2tree(self, s):
        def str2treeHelper(s, i):
            start = i
            if s[i] == '-': i += 1
            while i < len(s) and s[i].isdigit(): i += 1
            node = TreeNode(int(s[start:i]))
            if i < len(s) and s[i] == '(':
                i += 1
                node.left, i = str2treeHelper(s, i)
                i += 1
            if i < len(s) and s[i] == '(':
                i += 1
                node.right, i = str2treeHelper(s, i)
                i += 1
            return node, i

        return str2treeHelper(s, 0)[0] if s else None",O(n)
"class SegmentTreeNode(object):
    def __init__(self, start, end):
        self.start, self.end = start, end
        self.total = self.count = 0
        self._left = self._right = None

    def mid(self):
        return (self.start+self.end) // 2

    def left(self):
        self._left = self._left or SegmentTreeNode(self.start, self.mid())
        return self._left

    def right(self):
        self._right = self._right or SegmentTreeNode(self.mid(), self.end)
        return self._right

    def update(self, X, i, j, val):
        if i >= j:
            return 0
        if self.start == i and self.end == j:
            self.count += val
        else:
            self.left().update(X, i, min(self.mid(), j), val)
            self.right().update(X, max(self.mid(), i), j, val)
        if self.count > 0:
            self.total = X[self.end]-X[self.start]
        else:
            self.total = self.left().total + self.right().total
        return self.total


class Solution(object):
    def rectangleArea(self, rectangles):
        OPEN, CLOSE = 1, -1
        events = []
        X = set()
        for x1, y1, x2, y2 in rectangles:
            events.append((y1, OPEN, x1, x2))
            events.append((y2, CLOSE, x1, x2))
            X.add(x1)
            X.add(x2)
        events.sort()
        X = sorted(X)
        Xi = {x: i for i, x in enumerate(X)}

        st = SegmentTreeNode(0, len(X)-1)
        result = 0
        cur_x_sum = 0
        cur_y = events[0][0]
        for y, typ, x1, x2 in events:
            result += cur_x_sum * (y-cur_y)
            cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ)
            cur_y = y
        return result % (10**9+7)",O(nlogn)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))


class Solution(object):
    def reverseList(self, head):
        dummy = ListNode(float(""-inf""))
        while head:
            dummy.next, head.next, head = head, dummy.next, head.next
        return dummy.__next__

",O(n)
"class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]",O(n)
"class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums",O(n)
"
import collections


class Solution(object):
    def distanceK(self, root, target, K):
        def dfs(parent, child, neighbors):
            if not child:
                return
            if parent:
                neighbors[parent.val].append(child.val)
                neighbors[child.val].append(parent.val)
            dfs(child, child.left, neighbors)
            dfs(child, child.right, neighbors)

        neighbors = collections.defaultdict(list)
        dfs(None, root, neighbors)
        bfs = [target.val]
        lookup = set(bfs)
        for _ in range(K):
            bfs = [nei for node in bfs
                   for nei in neighbors[node]
                   if nei not in lookup]
            lookup |= set(bfs)
        return bfs

",O(n)
"import math


class Solution(object):
    def visiblePoints(self, points, angle, location):
        arr, extra = [], 0
        for p in points:
            if p == location:
                extra += 1
                continue
            arr.append(math.atan2(p[1]-location[1], p[0]-location[0]))
        arr.sort()
        arr.extend([x + 2.0*math.pi for x in arr]) 
        d = 2.0*math.pi * (angle/360.0)
        left = result = 0
        for right in range(len(arr)):
            while arr[right]-arr[left] > d:
                left += 1
            result = max(result, right-left+1)
        return result + extra",O(nlogn)
"
import itertools


class Solution(object):
    def destCity(self, paths):
        A, B = list(map(set, zip(*paths)))
        return (B-A).pop()
",O(n)
"class Solution(object):
    def reachableNodes(self, n, edges, restricted):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = 0
        lookup = [False]*n
        for x in restricted:
            lookup[x] = True
        q = [0]
        lookup[0] = True
        while q:
            new_q = []
            for u in q:
                result += 1
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
            q = new_q
        return result",O(n)
"class Solution(object):
    def maxTurbulenceSize(self, A):
        result = 1
        start = 0
        for i in range(1, len(A)):
            if i == len(A)-1 or \
               cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1:
                result = max(result, i-start+1)
                start = i
        return result",O(n)
"class Solution(object):
    def closestMeetingNode(self, edges, node1, node2):
        def dfs(node):
            lookup = {}
            i = 0
            while node != -1:
                if node in lookup:
                    break
                lookup[node] = i
                i += 1
                node = edges[node]
            return lookup
        
        lookup1, lookup2 = dfs(node1), dfs(node2)
        intersect = set(lookup1.keys())&set(lookup2.keys())
        return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1",O(n)
"class Solution(object):
    def oddEvenJumps(self, A):
        def findNext(idx):
            result = [None]*len(idx)
            stack = []
            for i in idx:
                while stack and stack[-1] < i:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        idx = sorted(list(range(len(A))), key = lambda i: A[i])
        next_higher = findNext(idx)
        idx.sort(key = lambda i: -A[i])
        next_lower = findNext(idx)

        odd, even = [False]*len(A), [False]*len(A)
        odd[-1], even[-1] = True, True
        for i in reversed(range(len(A)-1)):
            if next_higher[i]:
                odd[i] = even[next_higher[i]]
            if next_lower[i]:
                even[i] = odd[next_lower[i]]
        return sum(odd)",O(nlogn)
"class Solution(object):
    def minUnlockedIndices(self, nums, locked):
        result = mx = cnt = 0
        for i in range(len(nums)):
            if mx < nums[i]:
                mx = nums[i]
                cnt = 0
            elif mx > nums[i]:
                if mx != nums[i]+1:
                    return -1
                result += cnt
                cnt = 0
            cnt += locked[i]
        return result",O(n)
"class Solution(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs():
            lookup = [False]*len(circles)
            stk = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    stk.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while stk:
                u = stk.pop()
                if dst[u]:
                    return True
                x1, y1, r1 = circles[u]
                for v in range(len(circles)):
                    x2, y2, r2 = circles[v]
                    if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        return not iter_dfs()",O(n ^ 2)
"class Solution2(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs():
            lookup = [False]*len(circles)
            q = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    q.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while q:
                new_q = []
                for u in q:
                    if dst[u]:
                        return True
                    x1, y1, r1 = circles[u]
                    for v in range(len(circles)):
                        x2, y2, r2 = circles[v]
                        if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return False

        return not bfs()",O(n ^ 2)
"class Solution3(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            stk = [src]
            while stk:
                u = stk.pop()
                if u == dst:
                    return True
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not iter_dfs(len(circles), len(circles)+1)",O(n ^ 2)
"class Solution4(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            q = [src]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup[dst]

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not bfs(len(circles), len(circles)+1)",O(n ^ 2)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution5(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        uf = UnionFind(len(circles)+2)
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                uf.union_set(u, len(circles))
            if x1+r1 >= X or y1-r1 <= 0:
                uf.union_set(u, len(circles)+1)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                uf.union_set(u, v)
        return uf.find_set(len(circles)) != uf.find_set(len(circles)+1)",O(n ^ 2)
"class Solution(object):
    def isPalindrome(self, x):
        if x < 0:
            return False
        copy, reverse = x, 0

        while copy:
            reverse *= 10
            reverse += copy % 10
            copy //= 10

        return x == reverse",O(logn)
"class Solution(object):
    def maximumMatchingIndices(self, nums1, nums2):
        return max(sum(nums2[j] == nums1[(i+j)%len(nums1)] for j in range(len(nums2))) for i in range(len(nums1)))",O(n ^ 2)
"class Solution(object):
    def strongPasswordChecker(self, s):
        missing_type_cnt = 3
        if any('a' <= c <= 'z' for c in s):
            missing_type_cnt -= 1
        if any('A' <= c <= 'Z' for c in s):
            missing_type_cnt -= 1
        if any(c.isdigit() for c in s):
            missing_type_cnt -= 1

        total_change_cnt = 0
        one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0
        i = 2
        while i < len(s):
            if s[i] == s[i-1] == s[i-2]:
                length = 2
                while i < len(s) and s[i] == s[i-1]:
                    length += 1
                    i += 1

                total_change_cnt += length / 3
                if length % 3 == 0:
                    one_change_cnt += 1
                elif length % 3 == 1:
                    two_change_cnt += 1
                else:
                    three_change_cnt += 1
            else:
                i += 1

        if len(s) < 6:
            return max(missing_type_cnt, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type_cnt, total_change_cnt)
        else:
            delete_cnt = len(s) - 20

            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1
            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2
            total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3

            return delete_cnt + max(missing_type_cnt, total_change_cnt)",O(n)
"class Solution(object):
    def getLargestOutlier(self, nums):
        result = float(""-inf"")
        total = sum(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        for x in nums:
            if (total-x)%2:
                continue
            target = (total-x)//2
            if target in cnt and (cnt[target]-int(target == x) >= 1):
                result = max(result, x)
        return result",O(n)
"import itertools


class Solution(object):
    def maxSumRangeQuery(self, nums, requests):
        def addmod(a, b, mod): 
            a %= mod
            b %= mod
            if mod-a <= b:
                b -= mod
            return a+b
        
        def mulmod(a, b, mod): 
            a %= mod
            b %= mod
            if a < b:
                a, b = b, a
            result = 0
            while b > 0:
                if b%2 == 1:
                    result = addmod(result, a, mod)
                a = addmod(a, a, mod)
                b //= 2
            return result

        MOD = 10**9+7

        count = [0]*len(nums)
        for start, end in requests:
            count[start] += 1
            if end+1 < len(count):
                count[end+1] -= 1
        for i in range(1, len(count)):
            count[i] += count[i-1]
        nums.sort()
        count.sort()
        result = 0
        for i, (num, c) in enumerate(zip(nums, count)):
            result = (result+num*c)%MOD
        return result",O(nlogn)
"class Solution(object):
    def checkIfExist(self, arr):
        lookup = set()
        for x in arr:
            if 2*x in lookup or \
               (x%2 == 0 and x//2 in lookup):
                return True
            lookup.add(x)
        return False",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def nextLargerNodes(self, head):
        result, stk = [], []
        while head:
            while stk and stk[-1][1] < head.val:
                result[stk.pop()[0]] = head.val
            stk.append([len(result), head.val])
            result.append(0)
            head = head.__next__
        return result",O(n)
"class Solution(object):

    def encode(self, strs):
        encoded_str = """"
        for s in strs:
            encoded_str += ""%0*x"" % (8, len(s)) + s
        return encoded_str


    def decode(self, s):
        i = 0
        strs = []
        while i < len(s):
            l = int(s[i:i+8], 16)
            strs.append(s[i+8:i+8+l])
            i += 8+l
        return strs",O(n)
"class Solution(object):
    def shortestBeautifulSubstring(self, s, k):
        def check(r1, r2):
            if r1[1]-r1[0]+1 > r2[1]-r2[0]+1:
                return False
            if r1[1]-r1[0]+1 < r2[1]-r2[0]+1:
                return True
            for i, j in zip(range(r1[0], r1[1]+1), range(r2[0], r2[1]+1)):
                if s[i] != s[j]:
                    return s[i] < s[j]
            return False
    
        result = []
        left = curr = 0
        for right in range(len(s)):
            curr += s[right] == '1'
            while curr == k+1:
                curr -= s[left] == '1'
                left += 1
            while left < len(s) and s[left] == '0':
                left += 1
            if curr == k:
                if not result or check([left, right], result):
                    result = [left, right]
        return s[result[0]:result[1]+1] if result else """"",O(n ^ 2)
"class Solution(object):
    def alternatingSubarray(self, nums):
        result = l = -1
        for i in range(len(nums)-1):
            if l != -1 and nums[i-1] == nums[i+1]:
                l += 1
            else:
                l = 2 if nums[i+1]-nums[i] == 1 else -1
            result = max(result, l)
        return result",O(n)
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.is_string = True

    def search(self, word):
        node = self.childSearch(word)
        if node:
            return node.is_string
        return False

    def startsWith(self, prefix):
        return self.childSearch(prefix) is not None

    def childSearch(self, word):
        cur = self.root
        for c in word:
            if c in cur.leaves:
                cur = cur.leaves[c]
            else:
                return None
        return cur


",O(n)
"class Solution(object):
    def divideString(self, s, k, fill):
        return [s[i:i+k] + fill*(i+k-len(s)) for i in range(0, len(s), k)]",O(n)
"class Solution(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        prefix = getPrefix(word)
        result, count, j, prev = 0, 0, -1, -1
        for i in range(len(sequence)):
            while j > -1 and word[j+1] != sequence[i]:
                j = prefix[j]
            if word[j+1] == sequence[i]:
                j += 1
            if j+1 == len(word):     
                count = count+1 if i-prev == len(word) else 1
                result = max(result, count)
                j, prev = -1, i
        return result",O(n)
"class Solution2(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        new_word = word*(len(sequence)//len(word))
        prefix = getPrefix(new_word)
        result, j = 0, -1
        for i in range(len(sequence)):
            while j > -1 and new_word[j+1] != sequence[i]:
                j = prefix[j]
            if new_word[j+1] == sequence[i]:
                j += 1
            result = max(result, j+1)
            if j+1 == len(new_word):     
                break
        return result//len(word)",O(n)
"class Solution(object):
    def findCircleNum(self, M):
        class UnionFind(object):
            def __init__(self, n):
                self.set = list(range(n))
                self.count = n

            def find_set(self, x):
               if self.set[x] != x:
                   self.set[x] = self.find_set(self.set[x]) 
               return self.set[x]

            def union_set(self, x, y):
                x_root, y_root = list(map(self.find_set, (x, y)))
                if x_root != y_root:
                    self.set[min(x_root, y_root)] = max(x_root, y_root)
                    self.count -= 1

        circles = UnionFind(len(M))
        for i in range(len(M)):
            for j in range(len(M)):
                if M[i][j] and i != j:
                    circles.union_set(i, j)
        return circles.count",O(n ^ 2)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2, k):
        cnt1 = cnt2 = 0
        for x, y in zip(nums1, nums2):
            if y == x:
                continue
            if k == 0 or (y-x)%k:
                return -1
            if x < y:
                cnt1 += (y-x)//k
            else:
                cnt2 += (x-y)//k
        return cnt1 if cnt1 == cnt2 else -1",O(n)
"class Solution(object):
    def scoreOfParentheses(self, S):
        result, depth = 0, 0
        for i in range(len(S)):
            if S[i] == '(':
                depth += 1
            else:
                depth -= 1
                if S[i-1] == '(':
                    result += 2**depth
        return result",O(n)
"class Solution2(object):
    def scoreOfParentheses(self, S):
        stack = [0]
        for c in S:
            if c == '(':
                stack.append(0)
            else:
                last = stack.pop()
                stack[-1] += max(1, 2*last)
        return stack[0]",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head",O(n)
"class Solution(object):
    def constructArray(self, n, k):
        result = []
        left, right = 1, n
        while left <= right:
            if k % 2:
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
            if k > 1:
                k -= 1
        return result",O(n)
"class Solution(object):
    def countMatchingSubarrays(self, nums, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i, x in enumerate(text):
                while j+1 > 0 and pattern[j+1] != x:
                    j = prefix[j]
                if pattern[j+1] == x:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in range(len(nums)-1)), pattern))",O(n)
"class Solution(object):
    def minimumIndex(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result
        
        m = boyer_moore_majority_vote()
        total, cnt = nums.count(m), 0
        for i, x in enumerate(nums):
            if x == m:
                cnt += 1
            if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1):
                return i
        return -1",O(n)
"

class Solution(object):
    def maximumXOR(self, nums):
        return reduce(lambda x, y: x|y, nums)
",O(n)
"class Solution(object):
    def convertToTitle(self, n):
        result = []
        while n:
            result += chr((n-1)%26 + ord('A'))
            n = (n-1)//26
        result.reverse()
        return """".join(result)",O(logn)
"import collections



class Solution(object):
    def minimumOperationsToMakeKPeriodic(self, word, k):
        cnt = collections.Counter(word[i:i+k]for i in range(0, len(word), k))
        return len(word)//k-max(cnt.values())",O(n)
"import itertools
import operator


class Solution(object):
    def minProductSum(self, nums1, nums2):
        def inner_product(vec1, vec2):
            return sum(map(operator.mul, vec1, vec2))


        nums1.sort()
        nums2.sort(reverse=True)
        return inner_product(nums1, nums2)",O(nlogn)
"class Solution(object):
    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):
        if a == e and not (a == c and (b-d)*(f-d) < 0):
            return 1
        if b == f and not (b == d and (a-c)*(e-c) < 0):
            return 1
        if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0):
            return 1
        if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0):
            return 1
        return 2",O(1)
"import collections


class Solution(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        result = total = same = more = 0
        for x in nums:
            total += 1 if x == 1 else -1
            new_same = lookup[total]
            new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD
            lookup[total] += 1
            result = (result+new_more)%MOD
            same, more = new_same, new_more
        return result",O(n)
"class Solution2(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = {0:-1}
        dp = [0]*len(nums)
        result = total = 0
        for i, x in enumerate(nums):
            total += 1 if x == 1 else -1
            if total not in lookup:
                if total > 0:
                    dp[i] = i+1
            else:
                j = lookup[total]
                if j != -1:
                    dp[i] = dp[j]
                if x > 0:
                    dp[i] += (i-1)-j
            lookup[total] = i
            result = (result+dp[i])%MOD
        return result",O(n)
"class Solution2(object):
    def sumIndicesWithKSetBits(self, nums, k):
        def popcount(x):
            return bin(x)[1:].count('1')
        
        return sum(x for i, x in enumerate(nums) if popcount(i) == k)",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def put(self, key, value):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            node.val = value
        else:
            l.insert(ListNode(key, value))

    def get(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            return node.val
        else:
            return -1

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)",O(1)
"class Solution(object):
    def countCompleteComponents(self, n, edges):
        def bfs(u):
            if lookup[u]:
                return False
            v_cnt = e_cnt = 0
            lookup[u] = True
            q = [u]
            while q:
                new_q = []
                v_cnt += len(q)
                for u in q:
                    e_cnt += len(adj[u])
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return v_cnt*(v_cnt-1) == e_cnt

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [False]*n
        return sum(bfs(u) for u in range(n) if not lookup[u])",O(n ^ 2)
"class Solution(object):
    def partitionString(self, s):
        result, left = 1, 0
        lookup = {}
        for i, x in enumerate(s):
            if x in lookup and lookup[x] >= left:
                left = i
                result += 1
            lookup[x] = i
        return result",O(n)
"class Solution(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def lengths():
            cnt = 0
            for i in range(len(s)):
                cnt += 1
                if i+1 == len(s) or s[i+1] != s[i]:
                    yield cnt
                    cnt = 0
    
        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in lengths()) <= numOps
    
        return binary_search(1, len(s), check)",O(nlogn)
"class Solution2(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in arr) <= numOps
    
        arr = []
        cnt = 0
        for i in range(len(s)):
            cnt += 1
            if i+1 == len(s) or s[i+1] != s[i]:
                arr.append(cnt)
                cnt = 0
        return binary_search(1, len(s), check)",O(nlogn)
"class Solution(object):
    def singleNonDuplicate(self, nums):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) / 2
            if not (mid%2 == 0 and mid+1 < len(nums) and \
                    nums[mid] == nums[mid+1]) and \
               not (mid%2 == 1 and nums[mid] == nums[mid-1]):
                right = mid-1
            else:
                left = mid+1
        return nums[left]",O(logn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        first = last = -1
        result = float(""inf"")
        i, prev, head = 0, head.val, head.__next__
        while head.__next__:
            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.__next__
        return [result, last-first] if last != first else [-1, -1]",O(n)
"class Solution(object):
    def queensAttacktheKing(self, queens, king):
        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),
                     (-1, 1), (1, 1), (1, -1), (-1, -1)]
        result = []
        lookup = {(i, j) for i, j in queens}
        for dx, dy in dirctions:
            for i in range(1, 8):
                x, y = king[0] + dx*i, king[1] + dy*i
                if (x, y) in lookup:
                    result.append([x, y])
                    break
        return result",O(1)
"import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result",O(nlogn)
"class Solution(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = right = gap = 0
        for left, (l, _) in enumerate(tiles):
            if left-1 >= 0:
                gap -= tiles[left][0]-tiles[left-1][1]-1
            r = l+carpetLen-1
            while right+1 < len(tiles) and r+1 >= tiles[right+1][0]:
                right += 1
                gap += tiles[right][0]-tiles[right-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = left = gap = 0
        for right in range(len(tiles)):
            if right-1 >= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 >= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"import bisect



class Solution3(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for left, (l, _) in enumerate(tiles):
            r = l+carpetLen-1
            right = bisect.bisect_right(tiles, [r+1])-1
            extra = max(tiles[right][1]-r, 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result",O(nlogn)
"import bisect



class Solution4(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for right, (_, r) in enumerate(tiles):
            l = r-carpetLen+1
            left = bisect.bisect_right(tiles, [l])
            if left-1 >= 0 and tiles[left-1][1]+1 >= l:
                left -= 1
            extra = max(l-tiles[left][0], 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result",O(nlogn)
"class Solution(object):
    def minDamage(self, power, damage, health):
        def ceil_divide(a, b):
            return (a+b-1)//b
        
        idxs = list(range(len(health)))
        idxs.sort(key=lambda i: float(ceil_divide(health[i], power))/damage[i])
        result = t = 0
        for i in idxs:
            t += ceil_divide(health[i], power)
            result += t*damage[i]
        return result",O(nlogn)
"class Solution(object):
    def canThreePartsEqualSum(self, A):
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts >= 3",O(n)
"class Solution(object):
    def getWinner(self, arr, k):
        result = arr[0]
        count = 0
        for i in range(1, len(arr)):
            if arr[i] > result:
                result = arr[i]
                count = 0
            count += 1
            if (count == k):
                break
        return result",O(n)
"class Solution(object):
    def findArray(self, pref):
        for i in reversed(range(1, len(pref))):
            pref[i] ^= pref[i-1]
        return pref",O(n)
"class Solution(object):
    def separateSquares(self, squares):
        events = []
        for x, y, l in squares:
            events.append((y, 1, l))
            events.append((y+l, -1, l))
        events.sort(key=lambda e: e[0])
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                total += (y-prev)*curr
                prev = y
            curr += l*v
        expect = total/2.0
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                if total+(y-prev)*curr >= expect:
                    break
                total += (y-prev)*curr
                prev = y
            curr += l*v
        return prev+(expect-total)/curr",O(nlogn)
"class Solution(object):
    def longestValidParentheses(self, s):
        def length(it, start, c):
            depth, longest = 0, 0
            for i in it:
                if s[i] == c:
                    depth += 1
                else:
                    depth -= 1
                    if depth < 0:
                        start, depth = i, 0
                    elif depth == 0:
                        longest = max(longest, abs(i - start))
            return longest

        return max(length(range(len(s)), -1, '('), \
                   length(reversed(range(len(s))), len(s), ')'))",O(n)
"class Solution2(object):
    def longestValidParentheses(self, s):
        longest, last, indices = 0, -1, []
        for i in range(len(s)):
            if s[i] == '(':
                indices.append(i)
            elif not indices:
                last = i
            else:
                indices.pop()
                if not indices:
                    longest = max(longest, i - last)
                else:
                    longest = max(longest, i - indices[-1])
        return longest",O(n)
"import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))",O(n)
"class Solution(object):
    def smallestRangeI(self, A, K):
        return max(0, max(A) - min(A) - 2*K)",O(n)
"class Solution(object):
    def makeIntegerBeautiful(self, n, target):
        total, m = 0, n
        while m:
            total += m%10
            m //= 10
        m, l = n, 0
        while total > target:
            while True:
                total -= m%10
                m //= 10
                l += 1
                if m%10 != 9:
                    break
            total += 1
            m += 1
        return m*10**l-n",O(logn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def partition(self, head, x):
        dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)
        smaller, greater = dummySmaller, dummyGreater

        while head:
            if head.val < x:
                smaller.next = head
                smaller = smaller.__next__
            else:
                greater.next = head
                greater = greater.__next__
            head = head.__next__

        smaller.next = dummyGreater.__next__
        greater.next = None

        return dummySmaller.__next__",O(n)
"import collections



class Solution(object):
    def longestEqualSubarray(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            result = max(result, cnt[nums[right]])
            if right-left+1 > result+k:
                cnt[nums[left]] -= 1
                left += 1
        return result",O(n)
"class Solution(object):
    def minOperations(self, nums):
        result = prev = 0
        for curr in nums:
            if prev < curr:
                prev = curr
                continue
            prev += 1
            result += prev-curr                
        return result",O(n)
"class Solution(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            if x > 0:
                result.append(x)
                continue
            while result and 0 < result[-1] < -x:
                result.pop()
            if result and 0 < result[-1]:
                if result[-1] == -x:
                    result.pop()
                continue
            result.append(x)
        return result",O(n)
"class Solution2(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            while result and x < 0 < result[-1]:
                if result[-1] < -x:
                    result.pop()
                    continue
                elif result[-1] == -x:
                    result.pop()
                break
            else:
                result.append(x)
        return result",O(n)
"import collections


class Solution(object):
    def numSplits(self, s):
        left_count, right_count = collections.Counter(), collections.Counter(s)
        result = 0
        for c in s:
            left_count[c] += 1
            right_count[c] -= 1
            if not right_count[c]:
                del right_count[c]
            if len(left_count) == len(right_count):
                result += 1
        return result",O(n)
"class Solution(object):
    def checkRecord(self, s):
        count_A = 0
        for i in range(len(s)):
            if s[i] == 'A':
                count_A += 1
                if count_A == 2:
                    return False
            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':
                return False
        return True",O(n)
"class Solution(object):
    def minBitwiseArray(self, nums):
        return [x-(((x+1)&~x)>>1) if x&1 else -1 for x in nums]",O(n)
"class Solution(object):
    def isValid(self, s):
        stack, lookup = [], {""("": "")"", ""{"": ""}"", ""["": ""]""}
        for parenthese in s:
            if parenthese in lookup:
                stack.append(parenthese)
            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:
                return False
        return len(stack) == 0",O(n)
"class Solution(object):
    def addSpaces(self, s, spaces):
        prev = len(s)
        s = list(s)
        s.extend([None]*len(spaces))
        for i in reversed(range(len(spaces))):
            for j in reversed(range(spaces[i], prev)):
                s[j+1+i] = s[j]
            s[spaces[i]+i] = ' '
            prev = spaces[i]
        return """".join(s)",O(n)
"class Solution(object):
    def waysToBuildRooms(self, prevRoom):
        MOD = 10**9+7
        fact = [1, 1]
        inv = [0, 1]
        inv_fact = [1, 1]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def dfs(adj, curr):
            total_ways, total_cnt = 1, 0
            for child in adj[curr]:
                ways, cnt = dfs(adj, child)
                total_cnt += cnt
                total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD
            return total_ways, total_cnt+1

        adj = [[] for _ in range(len(prevRoom))]
        for i in range(1, len(prevRoom)):
            adj[prevRoom[i]].append(i)
        return dfs(adj, 0)[0]",O(n)
"class Solution(object):
    def longestCycle(self, edges):
        result = -1
        lookup = [-1]*len(edges)
        idx = 0
        for i in range(len(edges)):
            if lookup[i] != -1:
                continue
            start = idx
            while i != -1:
                if lookup[i] != -1:
                    break
                lookup[i] = idx
                idx += 1
                i = edges[i]
            if i != -1 and lookup[i] >= start:
                result = max(result, idx-lookup[i])
        return result",O(n)
"class Solution(object):
    def validMountainArray(self, A):
        i = 0
        while i+1 < len(A) and A[i] < A[i+1]:
            i += 1
        j = len(A)-1
        while j-1 >= 0 and A[j-1] > A[j]:
            j -= 1
        return 0 < i == j < len(A)-1",O(n)
"class Solution(object):
    def minHeightShelves(self, books, shelf_width):
        dp = [float(""inf"") for _ in range(len(books)+1)]
        dp[0] = 0
        for i in range(1, len(books)+1):
            max_width = shelf_width
            max_height = 0
            for j in reversed(range(i)):
                if max_width-books[j][0] < 0:
                    break
                max_width -= books[j][0]
                max_height = max(max_height, books[j][1])
                dp[i] = min(dp[i], dp[j]+max_height)
        return dp[len(books)]",O(n ^ 2)
"class Solution(object):
    def minCostToEqualizeArray(self, nums, cost1, cost2):
        MOD = 10**9+7

        n = len(nums)
        mx = max(nums)
        total = mx*n-sum(nums)

        if n <= 2 or cost1*2 <= cost2:
            return total*cost1%MOD
    
        result = float(""inf"")
        mn = min(nums)
        cnt1 = max((mx-mn)-(total-(mx-mn)), 0)
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + cnt2//2*cost2)

        x, cnt1 = divmod(cnt1, (n-2))
        total += n*x
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + (cnt2//2)*cost2)

        for _ in range(2): 
            total += n
            result = min(result, total%2*cost1 + total//2*cost2)
        return result%MOD",O(n)
"class Solution(object):
    def maskPII(self, S):
        if '@' in S:
            first, after = S.split('@')
            return ""{}*****{}@{}"".format(first[0], first[-1], after).lower()

        digits = [x for x in S if x.isdigit()]
        local = ""***-***-{}"".format(digits[-4:])
        if len(digits) == 10:
            return local
        return ""+{}-{}"".format('*' * (len(digits) - 10), local)",O(n)
"class Solution(object):
    def longestSubsequence(self, s, k):
        result, base = 0, 1
        for i in reversed(range(len(s))):
            if s[i] == '0':
                result += 1
            elif base <= k:
                k -= base
                result += 1
            if base <= k:
                base <<= 1
        return result",O(n)
"import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):
                return x
        return -1",O(logn)
"class Solution(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = list(range(n))

        dp = [[0]*n for _ in range(n)]
        for i in range(n):
            dp[i][i] = stoneValue[i]

        max_score = 0
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                while prefix[mid[i]]-prefix[i] < prefix[j+1]-prefix[mid[i]]:
                    mid[i] += 1 
                p = mid[i]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(dp[i][p-1], dp[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, dp[i][p-2])
                    if p <= j:
                        max_score = max(max_score, dp[j][p])
                dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return max_score",O(n ^ 2)
"class Solution2(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = [[0]*n for _ in range(n)]
        for l in range(1, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = i if l == 1 else mid[i][j-1]
                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:
                    p += 1 
                mid[i][j] = p
        
        rmq = [[0]*n for _ in range(n)]
        for i in range(n):
            rmq[i][i] = stoneValue[i]

        dp = [[0]*n for _ in range(n)]
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = mid[i][j]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(rmq[i][p-1], rmq[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, rmq[i][p-2])
                    if p <= j:
                        max_score = max(max_score, rmq[j][p])
                dp[i][j] = max_score
                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return dp[0][n-1]",O(n ^ 2)
"class Solution(object):
    def canChange(self, start, target):
        i = j = 0
        while True:
            while i < len(start) and start[i] == '_':
                i += 1
            while j < len(target) and target[j] == '_':
                j += 1
            if i == len(start) and j == len(target):
                break
            if i == len(start) or j == len(target) or start[i] != target[j] or \
               (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True",O(n)
"class Solution(object):
    def maxCoins(self, nums):
        coins = [1] + [i for i in nums if i > 0] + [1]
        n = len(coins)
        max_coins = [[0 for _ in range(n)] for _ in range(n)]

        for k in range(2, n):
            for left in range(n - k):
                right = left + k
                for i in range(left + 1, right):
                    max_coins[left][right] = \
                        max(max_coins[left][right],
                            coins[left] * coins[i] * coins[right] +
                            max_coins[left][i] +
                            max_coins[i][right])

        return max_coins[0][-1]",O(n ^ 3)
"import operator


class Solution(object):
    def calculate(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(operand)
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]",O(n)
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '+' or s[i] == '-':
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)",O(n)
"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        def iter_dfs():
            lookup = [[] for _ in range(26)]
            result = [1]*len(parent)
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    lookup[ord(s[u])-ord('a')].append(u)
                    stk.append((2, u))
                    for v in reversed(adj[u]):
                        stk.append((1, v))
                elif step == 2:
                    for v in adj[u]:
                        result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
                    lookup[ord(s[u])-ord('a')].pop()
            return result
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        return iter_dfs()",O(n)
"class Solution2(object):
    def findSubtreeSizes(self, parent, s):
        def dfs(u):
            lookup[ord(s[u])-ord('a')].append(u)
            for v in adj[u]:
                dfs(v)
                result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
            lookup[ord(s[u])-ord('a')].pop()
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        lookup = [[] for _ in range(26)]
        result = [1]*len(parent)
        dfs(0)
        return result",O(n)
"class Solution(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))",O(nlogn)
"class Solution2(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        if not arr:
            return max_arr
        x = (target-1)//len(arr)
        return x if target-x*len(arr) <= (x+1)*len(arr)-target else x+1",O(nlogn)
"class Solution(object):
    def finalPrices(self, prices):
        stk = []
        for i, p in enumerate(prices):
            while stk and prices[stk[-1]] >= p:
                prices[stk.pop()] -= p
            stk.append(i)
        return prices",O(n)
"import itertools


class Solution(object):
    def countVowelPermutation(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % MOD \
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[0, 1, 1, 0, 1],
             [1, 0, 1, 0, 0],
             [0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0],
             [0, 0, 1, 1, 0]]
        return sum(map(sum, matrix_expo(T, n-1))) % MOD",O(logn)
"class Solution2(object):
    def countVowelPermutation(self, n):
        MOD = 10**9 + 7
        a, e, i, o, u = 1, 1, 1, 1, 1
        for _ in range(1, n):
            a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD
        return (a+e+i+o+u) % MOD",O(n)
"import collections



class Solution(object):
    def isReflected(self, points):
        if not points:
            return True
        groups_by_y = collections.defaultdict(set)
        left, right = float(""inf""), float(""-inf"")
        for p in points:
            groups_by_y[p[1]].add(p[0])
            left, right = min(left, p[0]), max(right, p[0])
        mid = left + right
        for group in list(groups_by_y.values()):
            for x in group:
                if mid - x not in group:
                    return False
        return True",O(n)
"class Solution2(object):
    def isReflected(self, points):
        if not points:
            return True
        points.sort()
        points[len(points)/2:] = sorted(points[len(points)/2:], \
                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                                     x[0] - y[0])
        mid = points[0][0] + points[-1][0]
        left, right = 0, len(points) - 1
        while left <= right:
            if (mid != points[left][0] + points[right][0]) or \
               (points[left][0] != points[right][0] and \
                points[left][1] != points[right][1]):
                return False
            left += 1
            right -= 1
        return True",O(nlogn)
"import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        min_heap = []
        result = i = 0
        while i < len(apples) or min_heap:
            if i < len(apples) and apples[i] > 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def minAbsoluteDifference(self, nums, x):
        result = float(""inf"")
        sl = SortedList()
        for i in range(x, len(nums)):
            sl.add(nums[i-x])
            j = sl.bisect_left(nums[i])
            if j-1 >= 0:
                result = min(result, nums[i]-sl[j-1])
            if j < len(sl):
                result = min(result, sl[j]-nums[i])
        return result",O(nlogn)
"class Solution(object):
    def compressedString(self, word):
        result = []
        cnt = 0
        for i in range(len(word)):
            cnt += 1
            if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]):
                result.append(""%s%s"" % (cnt, word[i]))
                cnt = 0
        return """".join(result)",O(n)
"class Solution(object):
    def validSubarraySize(self, nums, threshold):
        stk = [-1]
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                if nums[stk.pop()]*((i-1)-stk[-1]) > threshold:
                    return (i-1)-stk[-1]
            stk.append(i)
        return -1",O(n)
"class Solution(object):
    def wordCount(self, startWords, targetWords):
        def bitmask(w):
            return reduce(lambda x, y: x|y, (1 << (ord(c)-ord('a')) for i, c in enumerate(w)))

        lookup = set(bitmask(w) for w in startWords)
        result = 0 
        for w in targetWords: 
            mask = bitmask(w)
            result += any(mask ^ (1 << ord(c)-ord('a')) in lookup for c in w)
        return result",other
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)

    def hasNext(self):
        return self.__stk

    def __next__(self):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        return node.val
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",O(1)
"
class Solution(object):
    def containsDuplicate(self, nums):
        return len(nums) > len(set(nums))

",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        if root.left and root.right:
            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
        else:
            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1",O(n)
"class Solution(object):
    def findDuplicate(self, nums):
        slow = nums[0]
        fast = nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]

        fast = 0
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow",O(n)
"class Solution2(object):
    def findDuplicate(self, nums):
        left, right = 1, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left",O(nlogn)
"class Solution3(object):
    def findDuplicate(self, nums):
        duplicate = 0
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
            else:
                duplicate = abs(num)
                break
        for num in nums:
            if nums[abs(num) - 1] < 0:
                nums[abs(num) - 1] *= -1
            else:
                break
        return duplicate",O(n)
"class Solution(object):
    def maxScore(self, nums):
        result = mx = 0
        for i in reversed(range(1, len(nums))):
            mx = max(mx, nums[i])
            result += mx
        return result",O(n)
"class Solution(object):
    def merge(self, intervals):
        intervals.sort()
        result = []
        for interval in intervals:
            if not result or interval[0] > result[-1][1]:
                result.append(interval)
            else:
                result[-1][1] = max(result[-1][1], interval[1])
        return result",O(nlogn)
"class Solution(object):
    def minimumBoxes(self, apple, capacity):
        capacity.sort(reverse=True)
        total = sum(apple)
        for i in range(len(capacity)):
            total -= capacity[i]
            if total <= 0:
                return i+1
        return -1",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

    def __repr__(self):
        if self:
            serial = []
            queue = [self]

            while queue:
                cur = queue[0]

                if cur:
                    serial.append(cur.val)
                    queue.append(cur.left)
                    queue.append(cur.right)
                else:
                    serial.append(

                queue = queue[1:]

            while serial[-1] == 
                serial.pop()

            return repr(serial)

        else:
            return None

class Solution(object):
    def recoverTree(self, root):
        return self.MorrisTraversal(root)

    def MorrisTraversal(self, root):
        if root is None:
            return
        broken = [None, None]
        pre, cur = None, root

        while cur:
            if cur.left is None:
                self.detectBroken(broken, pre, cur)
                pre = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right =cur
                    cur = cur.left
                else:
                    self.detectBroken(broken, pre, cur)
                    node.right = None
                    pre = cur
                    cur = cur.right

        broken[0].val, broken[1].val = broken[1].val, broken[0].val

        return root

    def detectBroken(self, broken, pre, cur):
        if pre and pre.val > cur.val:
            if broken[0] is None:
                broken[0] = pre
            broken[1] = cur",O(n)
"import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):
        counts = collections.defaultdict(int)
        val_labs = list(zip(values,labels))
        val_labs.sort(reverse=True)
        result = 0
        for val, lab in val_labs:
            if counts[lab] >= use_limit:
                continue
            result += val
            counts[lab] += 1
            num_wanted -= 1
            if num_wanted == 0:
                break
        return result",O(nlogn)
"class Solution(object):
    def secondHighest(self, s):
        first = second = -1
        for c in s:
            if not c.isdigit():
                continue
            d = int(c)
            if d > first:
                first, second = d, first
            elif first > d > second:
                second = d
        return second",O(n)
"class Solution(object):
    def threeSumClosest(self, nums, target):
        result, min_diff = 0, float(""inf"")
        nums.sort()
        for i in reversed(range(2, len(nums))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            left, right = 0, i-1
            while left < right:
                total = nums[left]+nums[right]+nums[i]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    return target
                if abs(total-target) < min_diff:
                    min_diff = abs(total-target)
                    result = total
        return result",O(n ^ 2)
"class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]",O(n)
"class Solution2(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * n
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
        return ways[n - 1]",O(n)
"class Solution(object):
    def minCostToMoveChips(self, chips):
        count = [0]*2
        for p in chips:
            count[p%2] += 1
        return min(count)",O(n)
"class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result",O(n)
"import re


class Solution(object):
    def solveEquation(self, equation):
        a, b, side = 0, 0, 1
        for eq, sign, num, isx in re.findall('(=)|([-+]?)(\d*)(x?)', equation):
            if eq:
                side = -1
            elif isx:
                a += side * int(sign + '1') * int(num or 1)
            elif num:
                b -= side * int(sign + num)
        return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions'",O(n)
"class Solution(object):
    def minIncrements(self, n, cost):
        result = 0
        for i in reversed(range(n//2)):
            result += abs(cost[2*i+1]-cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return result",O(n)
"class Solution(object):
    def canBeIncreasing(self, nums):
        deleted = False
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                continue
            if deleted:
                return False
            deleted = True
            if i >= 2 and nums[i-2] > nums[i]: 
                nums[i] = nums[i-1]
        return True",O(n)
"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result",O(n)
"import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):
        if n == 1:
            return [0]

        neighbors = collections.defaultdict(set)
        for u, v in edges:
            neighbors[u].add(v)
            neighbors[v].add(u)

        pre_level, unvisited = [], set()
        for i in range(n):
            if len(neighbors[i]) == 1: 
                pre_level.append(i)
            unvisited.add(i)

        while len(unvisited) > 2:
            cur_level = []
            for u in pre_level:
                unvisited.remove(u)
                for v in neighbors[u]:
                    if v in unvisited:
                        neighbors[v].remove(u)
                        if len(neighbors[v]) == 1:
                            cur_level.append(v)
            pre_level = cur_level

        return list(unvisited)",O(n)
"class Solution(object):
    def isPrefixString(self, s, words):
        i = j = 0
        for c in s:
            if i == len(words) or words[i][j] != c:
                return False 
            j += 1
            if j == len(words[i]):
                i += 1
                j = 0
        return j == 0",O(n)
"class Solution2(object):
    def isPrefixString(self, s, words):
        i = 0
        for word in words:
            for c in word:
                if i == len(s) or s[i] != c:
                    return False
                i += 1
            if i == len(s):
                return True
        return False",O(n)
"class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)",O(n)
"import itertools



class Solution(object):
    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):
        result = 0
        for hp, ex in zip(energy, experience):
            inc1 = max((hp+1)-initialEnergy, 0)
            inc2 = max((ex+1)-initialExperience, 0)
            result += inc1+inc2
            initialEnergy += inc1-hp
            initialExperience += inc2+ex
        return result",O(n)
"class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):
        def num_days(date):
            Y, M, D = list(map(int, date.split(""-"")))
            leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap
     
        return abs(num_days(date1) - num_days(date2))",O(1)
"import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):        
        delta = datetime.datetime.strptime(date1, ""%Y-%m-%d"")
        delta -= datetime.datetime.strptime(date2, ""%Y-%m-%d"")
        return abs(delta.days)",O(1)
"import random


class Solution(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0)
            return Solution.dp[y], y
        
        arr = list(map(power_value, list(range(lo, hi+1))))
        nth_element(arr, k-1)
        return arr[k-1][1]",O(n)
"class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(list(range(lo, hi+1)), key=power_value)[k-1]",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def mergeNodes(self, head):
        curr, zero = head.__next__, head
        while curr:
            if curr.val:
                zero.val += curr.val
            else:
                zero.next = curr if curr.__next__ else None
                zero = curr
            curr = curr.__next__
        return head",O(n)
"class Solution(object):
    def convertDateToBinary(self, date):
        return ""-"".join([bin(int(x))[2:] for x in date.split('-')])",O(1)
"class Solution(object):
    def minSwaps(self, s):
        def cost(s, x): 
            diff = 0 
            for c in s:
                diff += int(c) != x
                x ^= 1
            return diff//2
    
        ones = s.count('1')
        zeros = len(s)-ones 
        if abs(ones-zeros) > 1:
            return -1
        if ones > zeros:
            return cost(s, 1)
        if ones < zeros:
            return cost(s, 0)
        return min(cost(s, 1), cost(s, 0))",O(n)
"class Solution(object):
    def longestSquareStreak(self, nums):
        sorted_nums = sorted(set(nums))
        squares = {x for x in sorted_nums if x%2 < 2} 
        result = 0
        for x in sorted_nums:
            square, cnt = x**2, 1
            while square in squares:
                squares.remove(square)
                cnt += 1
                square *= square
            result = max(result, cnt)
        return result if result != 1 else -1",O(nlogn)
"class Solution2(object):
    def longestSquareStreak(self, nums):
        dp = collections.defaultdict(int)
        nums.sort()
        result = -1
        for x in nums:
            sqrt_x = int(x**0.5)
            if sqrt_x**2 == x:
                dp[x] = dp[sqrt_x]+1
            else:
                dp[x] = 1
            result = max(result, dp[x])
        return result if result != 1 else -1",O(nlogn)
"class Solution(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in reversed(range(len(nums))):
            while stk and nums[stk[-1]] < nums[i]:
                dp[i] = max(dp[i]+1, dp[stk.pop()])
            stk.append(i)
        return max(dp)",O(n)
"class Solution2(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in range(len(nums)):
            curr = 0
            while stk and nums[stk[-1]] <= nums[i]:
                curr = max(curr, dp[stk.pop()])
            if stk:
                dp[i] = curr+1
            stk.append(i)
        return max(dp)",O(n)
"import collections


class Solution(object):
    def constrainedSubsetSum(self, nums, k):
        result, dq = float(""-inf""), collections.deque()
        for i in range(len(nums)):
            if dq and i-dq[0][0] == k+1:
                dq.popleft()
            curr = nums[i] + (dq[0][1] if dq else 0)
            while dq and dq[-1][1] <= curr:
                dq.pop()
            if curr > 0:
                dq.append((i, curr))
            result = max(result, curr)
        return result",O(n)
"import random



class Solution(object):
    def largestEvenSum(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, k-1, compare=lambda a, b: a > b)
        total = sum(nums[i] for i in range(k))
        if total%2 == 0:
            return total
        min_k = [float(""inf"")]*2
        for i in range(k):
            min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i])
        result = -1
        for i in range(k, len(nums)):
            result = max(result, total-min_k[not (nums[i]%2)]+nums[i])
        return result",O(n)
"
import collections


class Solution(object):
    def customSortString(self, S, T):
        counter, s = collections.Counter(T), set(S)
        result = [c*counter[c] for c in S]
        result.extend([c*counter for c, counter in counter.items() if c not in s])
        return """".join(result)

",O(n)
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if nums[mid] > target:
                right = mid-1
            elif nums[mid] < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"class Solution(object):
    def checkSubarraySum(self, nums, k):
        count = 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += num
            if k:
                count %= k
            if count in lookup:
                if i - lookup[count] > 1:
                    return True
            else:
                lookup[count] = i

        return False",O(n)
"class Solution(object):
    def countDistinct(self, s):
        count = 0
        trie = {}
        for i in range(len(s)):
            curr = trie
            for j in range(i, len(s)):
                if s[j] not in curr:
                    count += 1
                    curr[s[j]] = {}
                curr = curr[s[j]]
        return count",O(n ^ 2)
"class Solution(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def update(i, d):
            if word[i] not in VOWELS:
                curr2[0] += d
                return
            x = ord(word[i])-ord('a')
            if cnt1[x] == 0:
                curr1[0] += 1
            cnt1[x] += d
            if cnt1[x] == 0:
                curr1[0] -= 1

        result = 0
        cnt1, cnt2 = [0]*26, [0]*26
        curr1, curr2 = [0], [0]
        mid = left = 0
        for right in range(len(word)):
            update(right, +1)
            while curr2[0] > k:
                update(left, -1)
                if left < mid:
                    assert(word[left] in VOWELS)
                    cnt2[ord(word[left])-ord('a')] -= 1
                left += 1
                mid = max(mid, left)
            if not (curr1[0] == len(VOWELS) and curr2[0] == k):
                continue
            while word[mid] in VOWELS and cnt1[ord(word[mid])-ord('a')]-(cnt2[ord(word[mid])-ord('a')]+1) >= 1:
                cnt2[ord(word[mid])-ord('a')] += 1
                mid += 1
            result += mid-left+1
        return result",O(n)
"class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)",O(n)
"class Solution(object):
    def runningSum(self, nums):
        for i in range(len(nums)-1):
            nums[i+1] += nums[i]
        return nums",O(n)
"class Solution(object):
    def sortByBits(self, arr):
        def popcount(n): 
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result
        
        arr.sort(key=lambda x: (popcount(x), x))
        return arr",O(nlogn)
"class Solution(object):
    def countSpecialNumbers(self, n):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(n+1)))
        result = sum(P(9, 1)*P(9, i-1) for i in range(1, len(digits)))
        lookup = set()
        for i, x in enumerate(digits):
            for y in range(int(i == 0), x):
                if y in lookup:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in lookup:
                break
            lookup.add(x)
        return result",O(logn)
"import collections


class Solution(object):
    def leastBricks(self, wall):
        widths = collections.defaultdict(int)
        result = len(wall)
        for row in wall:
            width = 0
            for i in range(len(row)-1):
                width += row[i]
                widths[width] += 1
                result = min(result, len(wall) - widths[width])
        return result",O(n)
"import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def treeQueries(self, root, queries):
        def iter_dfs(root):
            top = collections.defaultdict(lambda: [0]*2)
            depth, height = {}, {}
            stk = [(1, (root, 0))]
            while stk:
                step, (curr, d) = stk.pop()
                if step == 1:
                    if not curr:
                        continue
                    stk.append((2, (curr, d)))
                    stk.append((1, (curr.right, d+1)))
                    stk.append((1, (curr.left, d+1)))
                elif step == 2:
                    h = 1+max((height[curr.left.val] if curr.left else 0), 
                              (height[curr.right.val] if curr.right else 0))
                    if h > top[d][0]:
                        top[d][0], top[d][1] = h, top[d][0]
                    elif h > top[d][1]:
                        top[d][1] = h
                    depth[curr.val], height[curr.val] = d, h
            return top, depth, height

        top, depth, height = iter_dfs(root)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"import collections



class Solution2(object):
    def treeQueries(self, root, queries):
        def dfs(curr, d):
            if not curr:
                return 0
            h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1))
            if h > top[d][0]:
                top[d][0], top[d][1] = h, top[d][0]
            elif h > top[d][1]:
                top[d][1] = h
            depth[curr.val], height[curr.val] = d, h
            return h
        
        top = collections.defaultdict(lambda: [0]*2)
        depth, height = {}, {}
        dfs(root, 0)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"import itertools



class Solution(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))

        def check(x, t):
            return sum(c for y, c in zip(nums, cost) if y <= x) >= t
    
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        total = sum(cost)
        median = (total+1)//2
        while left <= right:
            mid = left+(right-left)//2
            if check(nums[idxs[mid]], median):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"import itertools



class Solution2(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))
    
        def check(x):
            return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]])

        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"class Solution3(object):
    def minCost(self, nums, cost):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        prefix = [0]*(len(cost)+1)
        left = 0
        for i in range(len(cost)):
            if i-1 >= 0:
                left += prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            prefix[i+1] = prefix[i]+cost[idxs[i]]
        result = float(""inf"")
        suffix = right = 0
        for i in reversed(range(len(cost))):
            if i+1 < len(idxs):
                right += suffix*(nums[idxs[i+1]]-nums[idxs[i]])
            result = min(result, left+right)
            if i-1 >= 0:
                left -= prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            suffix += cost[idxs[i]]
        return result",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteMiddle(self, head):
        dummy = ListNode()
        dummy.next = head
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        slow.next = slow.next.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def minimumLength(self, s):
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                break
            c = s[left]
            while left <= right:
                if s[left] != c:
                    break
                left += 1
            while left <= right:
                if s[right] != c:
                    break
                right -= 1
        return right-left+1",O(n)
"class Solution(object):
    def sortTransformedArray(self, nums, a, b, c):
        f = lambda x, a, b, c : a * x * x + b * x + c

        result = []
        if not nums:
            return result

        left, right = 0, len(nums) - 1
        d = -1 if a > 0 else 1
        while left <= right:
            if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c):
                result.append(f(nums[left], a, b, c))
                left += 1
            else:
                result.append(f(nums[right], a, b, c))
                right -= 1

        return result[::d]",O(n)
"
class Solution(object):
    def oddEvenList(self, head):
        if head:
            odd_tail, cur = head, head.__next__
            while cur and cur.__next__:
                even_head = odd_tail.__next__
                odd_tail.next = cur.__next__
                odd_tail = odd_tail.__next__
                cur.next = odd_tail.__next__
                odd_tail.next = even_head
                cur = cur.__next__
        return head

",O(n)
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '*' or s[i] == '/':
                operators.append(s[i])
            elif s[i] == '+' or s[i] == '-':
                while operators and \
                      (operators[-1] == '*' or operators[-1] == '/'):
                    self.compute(operands, operators)
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)
        elif op == '*':
            operands.append(left * right)
        elif op == '/':
            operands.append(left / right)",O(n)
"class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        asteroids.sort()
        for x in asteroids:
            if x > mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True",O(nlogn)
"import collections



class Solution(object):
    def maximumTotalDamage(self, power):
        DIST = 2
        power.sort()
        dp = collections.deque()
        mx = 0
        for x in power:
            if dp and dp[-1][0] == x:
                dp[-1][1] += x
                continue
            while dp and dp[0][0]+DIST < x:
                mx = max(mx, dp.popleft()[1])
            dp.append([x, mx+x])
        return max(x for _, x in dp)",O(nlogn)
"class Solution(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        start = h1*60+m1
        finish = h2*60+m2
        if start > finish:
            finish += 1440
        return max(finish//15-(start+15-1)//15, 0)",O(1)
"class Solution2(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        if m1 > m2:
            h2 -= 1
            m2 += 60
        return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)",O(1)
"class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result",O(n)
"class Solution(object):
    def findKthPositive(self, arr, k):
        def check(arr, k, x):
            return arr[x]-(x+1) < k

        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(arr, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right+1+k",O(logn)
"
class Solution(object):
    def boundaryOfBinaryTree(self, root):
        def leftBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            nodes.append(root.val)
            if not root.left:
                leftBoundary(root.right, nodes)
            else:
                leftBoundary(root.left, nodes)

        def rightBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            if not root.right:
                rightBoundary(root.left, nodes)
            else:
                rightBoundary(root.right, nodes)
            nodes.append(root.val)

        def leaves(root, nodes):
            if not root:
                return
            if not root.left and not root.right:
                nodes.append(root.val)
                return
            leaves(root.left, nodes)
            leaves(root.right, nodes)

        if not root:
            return []

        nodes = [root.val]
        leftBoundary(root.left, nodes)
        leaves(root.left, nodes)
        leaves(root.right, nodes)
        rightBoundary(root.right, nodes)
        return nodes

",O(n)
"class Solution(object):
    def findDerangement(self, n):
        M = 1000000007
        mul, total = 1, 0
        for i in reversed(range(n+1)):
            total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M
            mul = (mul * i) % M
        return total",O(n)
"

class Solution(object):
    def createBinaryTree(self, descriptions):
        nodes = {}
        children = set()
        for p, c, l in descriptions:
            parent = nodes.setdefault(p, TreeNode(p))
            child = nodes.setdefault(c, TreeNode(c))
            if l:
                parent.left = child
            else:
                parent.right = child
            children.add(c)
        return nodes[next(p for p in nodes.keys() if p not in children)]
",O(n)
"

class Solution(object):
    def mostExpensiveItem(self, primeOne, primeTwo):
        return primeOne*primeTwo-primeOne-primeTwo


",O(1)
"import itertools


class Solution(object):
    def numTilings(self, N):
        M = int(1e9+7)

        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]

        T = [[1, 0, 0, 1], 
             [1, 0, 1, 0], 
             [1, 1, 0, 0], 
             [1, 1, 1, 0]] 

        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0]",O(logn)
"class Solution2(object):
    def numTilings(self, N):
        M = int(1e9+7)
        dp = [1, 1, 2]
        for i in range(3, N+1):
            dp[i%3] = (2*dp[(i-1)%3]%M + dp[(i-3)%3])%M
        return dp[N%3]",O(n)
"class Solution(object):
    def isValid(self, word):
        VOWELS = ""aeiou""

        if len(word) < 3:
            return False
        vowel = consonant = False
        for x in word:
            if x.isalpha():
                if x.lower() in VOWELS:
                    vowel = True
                else:
                    consonant = True
            elif not x.isdigit():
                return False
        return vowel and consonant",O(n)
"import collections



class Solution(object):
    def maximumSubarraySum(self, nums, k):
        prefix = collections.defaultdict(lambda: float(""inf""))
        curr = 0
        result = float(""-inf"")
        for x in nums:
            prefix[x] = min(prefix[x], curr)
            curr += x
            result = max(result, curr-prefix[x-k], curr-prefix[x+k])
        return result if result != float(""-inf"") else 0",O(n)
"class Solution(object):
    def smallestMissingValueSubtree(self, parents, nums):
        def iter_dfs(adj, nums, i, lookup):
            stk = [i]
            while stk:
                i = stk.pop()
                if nums[i] in lookup:
                    continue
                lookup.add(nums[i])
                for j in adj[i]:
                    stk.append(j)

        result = [1]*len(parents)
        i = next((i for i in range(len(nums)) if nums[i] == 1), -1)
        if i == -1:
            return result
        adj = [[] for _ in range(len(parents))]
        for j in range(1, len(parents)):
            adj[parents[j]].append(j)
        lookup = set()
        miss = 1
        while i >= 0:
            iter_dfs(adj, nums, i, lookup)
            while miss in lookup:
                miss += 1
            result[i] = miss
            i = parents[i]
        return result",O(n)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"import bisect



class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: 0,
                 query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return 0
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution(object):
    def lengthOfLIS(self, nums, k):
        sorted_nums = sorted({x-1 for x in nums})
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        st = SegmentTree(len(num_to_idx))
        for x in nums:
            x -= 1
            st.update(num_to_idx[x], st.query(bisect.bisect_left(sorted_nums, x-k), num_to_idx[x]-1)+1)
        return st.tree[1]",O(nlogn)
"class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)",O(n)
"
import pandas as pd



def Solution(players: pd.DataFrame) -> List[int]:
    return list(players.shape)
",O(1)
"class Solution(object):
    def maxTotalFruits(self, fruits, startPos, k):
        max_pos = max(startPos, fruits[-1][0])
        cnt = [0]*(1+max_pos)
        for p, a in fruits:
            cnt[p] = a
        prefix = [0]
        for x in cnt:
            prefix.append(prefix[-1]+x)
        result = 0
        for left_dist in range(min(startPos, k)+1):
            right_dist = max(k-2*left_dist, 0)            
            left, right = startPos-left_dist, min(startPos+right_dist, max_pos)
            result = max(result, prefix[right+1]-prefix[left])
        for right_dist in range(min(max_pos-startPos, k)+1):
            left_dist = max(k-2*right_dist, 0) 
            left, right = max(startPos-left_dist, 0), startPos+right_dist
            result = max(result, prefix[right+1]-prefix[left])
        return result",O(n)
"class Solution(object):
    def subStrHash(self, s, power, modulo, k, hashValue):
        h, idx = 0, -1
        pw = pow(power, k-1, modulo)
        for i in reversed(range(len(s))):
            if i+k < len(s):
                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo
            h = (h*power+(ord(s[i])-ord('a')+1))%modulo
            if h == hashValue:
                idx = i
        return s[idx:idx+k]",O(n)
"class Solution(object):
    def minOperations(self, s):
        cnt = sum(int(c) == i%2 for i, c in enumerate(s))
        return min(cnt, len(s)-cnt)",O(n)
"class Solution(object):
    def thirdMax(self, nums):
        count = 0
        top = [float(""-inf"")] * 3
        for num in nums:
            if num > top[0]:
                top[0], top[1], top[2] = num, top[0], top[1]
                count += 1
            elif num != top[0] and num > top[1]:
                top[1], top[2] = num, top[1]
                count += 1
            elif num != top[0] and num != top[1] and num >= top[2]:
                top[2] = num
                count += 1

        if count < 3:
            return top[0]

        return top[2]",O(n)
"class Solution(object):
    def checkArray(self, nums, k):
        curr = 0
        for i, x in enumerate(nums):
            if x-curr < 0:
                return False
            nums[i] -= curr
            curr += nums[i]
            if i-(k-1) >= 0:
                curr -= nums[i-(k-1)]
        return curr == 0",O(n)
"import collections


class Solution(object):
    def getFolderNames(self, names):
        count = collections.Counter()
        result, lookup = [], set()
        for name in names:
            while True:
                name_with_suffix = ""{}({})"".format(name, count[name]) if count[name] else name
                count[name] += 1
                if name_with_suffix not in lookup:
                    break
            result.append(name_with_suffix)
            lookup.add(name_with_suffix)
        return result",O(n)
"class Solution(object):
    def countDigitOne(self, n):
        DIGIT = 1
        is_zero = int(DIGIT == 0)
        result = is_zero
        base = 1
        while n >= base:
            result += (n//(10*base)-is_zero)*base + \
                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))
            base *= 10
        return result",O(logn)
"import collections


class Solution(object):
    def stoneGameIX(self, stones):
        count = collections.Counter(x%3 for x in stones)
        if count[0]%2 == 0:
            return count[1] and count[2]
        return abs(count[1]-count[2]) >= 3",O(n)
"class Solution(object):
    def hammingDistance(self, x, y):
        distance = 0
        z = x ^ y
        while z:
            distance += 1
            z &= z - 1
        return distance

    def hammingDistance2(self, x, y):
        return bin(x ^ y).count('1')",O(1)
"class Solution(object):
    def isOneBitCharacter(self, bits):
        parity = 0
        for i in reversed(range(len(bits)-1)):
            if bits[i] == 0:
                break
            parity ^= bits[i]
        return parity == 0",O(n)
"import itertools


class Solution(object):
    def sortSentence(self, s):
        words = s.split()
        for i in range(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return "" "".join(map(lambda x: x[:-1], words))",O(n)
"import collections



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def verticalTraversal(self, root):
        def dfs(node, lookup, x, y):
            if not node:
                return
            lookup[x][y].append(node)
            dfs(node.left, lookup, x-1, y+1)
            dfs(node.right, lookup, x+1, y+1)
                
        lookup = collections.defaultdict(lambda: collections.defaultdict(list))
        dfs(root, lookup, 0, 0)

        result = []
        for x in sorted(lookup):
            report = []
            for y in sorted(lookup[x]):
                report.extend(sorted(node.val for node in lookup[x][y]))
            result.append(report)
        return result",O(nlogn)
"class Solution(object):
    def fixedRatio(self, s, num1, num2):
        lookup = collections.Counter()
        lookup[0] = 1
        result = curr = 0
        for c in s:
            curr += -num2 if c == '0' else +num1
            result += lookup[curr]
            lookup[curr] += 1
        return result",O(n)
"class Solution(object):
    def maximumANDSum(self, nums, numSlots):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
    
        return -hungarian([[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)])[0]",O(n ^ 3)
"from scipy.optimize import linear_sum_assignment as hungarian
import itertools



class Solution2(object):
    def maximumANDSum(self, nums, numSlots):
        adj = [[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)]
        return -sum(adj[i][j] for i, j in zip(*hungarian(adj)))",O(n ^ 3)
"class Solution(object):
    def canFormArray(self, arr, pieces):
        lookup = {x[0]: i for i, x in enumerate(pieces)}
        i = 0
        while i < len(arr): 
            if arr[i] not in lookup:
                return False
            for c in pieces[lookup[arr[i]]]:
                if i == len(arr) or arr[i] != c:
                    return False
                i += 1
        return True",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def removeNodes(self, head):
        stk = []
        while head:
            while stk and stk[-1].val < head.val:
                stk.pop()
            if stk:
                stk[-1].next = head
            stk.append(head)
            head = head.__next__
        return stk[0]",O(n)
"class Solution(object):
    def countLetters(self, S):
        result = len(S)
        left = 0
        for right in range(1, len(S)):
            if S[right] == S[left]:
                result += right-left
            else:
                left = right
        return result",O(n)
"import operator
from functools import reduce


class Solution(object):
    def nimGame(self, piles):
        return reduce(operator.xor, piles, 0)",O(n)
"class Solution(object):
    def findWinningPlayer(self, skills, k):
        result = cnt = 0
        for i in range(1, len(skills)):
            if skills[result] < skills[i]:
                result = i
                cnt = 0
            cnt += 1
            if cnt == k:
                return result
        return result",O(n)
"
import collections


class Solution(object):
    def minSteps(self, s, t):
        diff = collections.Counter(s) - collections.Counter(t)
        return sum(diff.values())
",O(n)
"class Solution(object):
    def wordPattern(self, pattern, str):
        if len(pattern) != self.wordCount(str):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, self.wordGenerator(str)):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True

    def wordCount(self, str):
        cnt = 1 if str else 0
        for c in str:
            if c == ' ':
                cnt += 1
        return cnt

    def wordGenerator(self, str):
        w = """"
        for c in str:
            if c == ' ':
                yield w
                w = """"
            else:
                w += c
        yield w",O(n)
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True",O(n)
"class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def binary_search(self, x):
                if self.tree[1] < x:
                    return -1
                i = 1
                while not i >= self.base:
                    if self.tree[2*i] >= x:
                        i = 2*i
                    else:
                        i = 2*i+1
                return i-self.base

        def build(i):
            return baskets[i]

        st = SegmentTree(len(baskets), build_fn=build)
        result = 0
        for x in fruits:
            i = st.binary_search(x)
            if i == -1:
                result += 1
            else:
                st.update(i, 0)
        return result",O(nlogn)
"class Solution2(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        result = 0
        for x in fruits:
            i = next((i for i in range(len(baskets)) if baskets[i] >= x), -1)
            if i ==-1:
                result += 1
            else:
                baskets[i] = 0
        return result",O(n ^ 2)
"class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minimumCost(self, N, connections):
        connections.sort(key = lambda x: x[2])
        union_find = UnionFind(N)
        result = 0
        for u, v, val in connections:
            if union_find.union_set(u-1, v-1):
                result += val
        return result if union_find.count == 1 else -1",O(nlogn)
"class Solution(object):
    def countOdds(self, low, high):
        return (high+1)//2 - ((low-1)+1)//2",O(1)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


class Solution(object):
    def connect(self, root):
        head = root
        pre = Node(0)
        cur = pre
        while root:
            while root:
                if root.left:
                    cur.next = root.left
                    cur = cur.__next__
                if root.right:
                    cur.next = root.right
                    cur = cur.__next__
                root = root.__next__
            root, cur = pre.__next__, pre
            cur.next = None
        return head",O(n)
"import collections


class Solution(object):
    def makeEqual(self, words):
        cnt = collections.defaultdict(int)
        for w in words:
            for c in w:
                cnt[c] += 1
        return all(v%len(words) == 0 for v in cnt.values())",O(n)
"class Solution(object):
    def reconstructMatrix(self, upper, lower, colsum):
        upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum)
        for i in range(len(colsum)):
            upper_matrix[i] = int(upper > 0 and colsum[i] != 0)
            lower_matrix[i] = colsum[i]-upper_matrix[i]
            upper -= upper_matrix[i]
            lower -= lower_matrix[i]
        return [upper_matrix, lower_matrix] if upper == lower == 0 else []",O(n)
"import collections


class Solution(object):
    def subarraysWithKDistinct(self, A, K):
        def atMostK(A, K):
            count = collections.defaultdict(int)
            result, left = 0, 0
            for right in range(len(A)):
                count[A[right]] += 1
                while len(count) > K:
                    count[A[left]] -= 1
                    if count[A[left]] == 0:
                        count.pop(A[left])
                    left += 1
                result += right-left+1
            return result
        
        return atMostK(A, K) - atMostK(A, K-1)",O(n)
"class Window(object):
    def __init__(self):
        self.__count = collections.defaultdict(int)

    def add(self, x):
        self.__count[x] += 1

    def remove(self, x):
        self.__count[x] -= 1
        if self.__count[x] == 0:
            self.__count.pop(x)
            
    def size(self):
        return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):
        window1, window2 = Window(), Window()
        result, left1, left2 = 0, 0, 0
        for i in A:
            window1.add(i)
            while window1.size() > K:
                window1.remove(A[left1])
                left1 += 1
            window2.add(i)
            while window2.size() >= K:
                window2.remove(A[left2])
                left2 += 1
            result += left2-left1
        return result",O(n)
"
import collections



class Solution(object):
    def destroyTargets(self, nums, space):
        cnt = collections.Counter(x%space for x in nums)
        mx = max(cnt.values())
        return min(x for x in nums if cnt[x%space] == mx)
",O(n)
"import itertools



class Solution(object):
    def sumSubarrayMins(self, A):
        M = 10**9 + 7

        left, s1 = [0]*len(A), []
        for i in range(len(A)):
            count = 1
            while s1 and s1[-1][0] > A[i]:
                count += s1.pop()[1]
            left[i] = count
            s1.append([A[i], count])

        right, s2 = [0]*len(A), []
        for i in reversed(range(len(A))):
            count = 1
            while s2 and s2[-1][0] >= A[i]:
                count += s2.pop()[1]
            right[i] = count
            s2.append([A[i], count])

        return sum(a*l*r for a, l, r in zip(A, left, right)) % M",O(n)
"class Solution(object):
    def isGood(self, nums):
        cnt = [0]*len(nums)
        for x in nums:
            if x < len(cnt):
                cnt[x] += 1
            else:
                return False
        return all(cnt[x] == 1 for x in range(1, len(nums)-1))",O(n)
"class Solution(object):
    def calculateScore(self, instructions, values):
        result = 0
        lookup = [False]*len(instructions)
        i = 0
        while 0 <= i < len(instructions):
            if lookup[i]:
                break
            lookup[i] = True
            if instructions[i] == ""add"":
                result += values[i]
                i += 1
            else:
                i += values[i]
        return result",O(n)
"class Solution(object):
    def findKthNumber(self, n, k):
        result = 0

        cnts = [0] * 10
        for i in range(1, 10):
            cnts[i] = cnts[i - 1] * 10 + 1

        nums = []
        i = n
        while i:
            nums.append(i % 10)
            i /= 10

        total, target = n, 0
        i = len(nums) - 1
        while i >= 0 and k > 0:
            target = target*10 + nums[i]
            start = int(i == len(nums)-1)
            for j in range(start, 10):
                candidate = result*10 + j
                if candidate < target:
                    num = cnts[i+1]
                elif candidate > target:
                    num = cnts[i]
                else:
                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)
                if k > num:
                    k -= num
                else:
                    result = candidate
                    k -= 1
                    total = num-1
                    break
            i -= 1

        return result",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):
        def inorder_gen(root):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
            yield None
        
        result = []
        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
        left, right = next(left_gen), next(right_gen)
        while left is not None or right is not None:
            if right is None or (left is not None and left < right):
                result.append(left)
                left = next(left_gen)
            else:
                result.append(right)
                right = next(right_gen)
        return result",O(n)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"
import itertools


class Solution(object):
    def busyStudent(self, startTime, endTime, queryTime):
        return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))
",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val",O(1)
"class Solution(object):
    def numberOfWays(self, corridor):
        MOD = 10**9+7
        result, cnt, j = 1, 0, -1
        for i, x in enumerate(corridor):
            if x != 'S':
                continue
            cnt += 1
            if cnt >= 3 and cnt%2:
                result = result*(i-j)%MOD
            j = i
        return result if cnt and cnt%2 == 0 else 0",O(n)
"import collections



class Solution(object):
    def minimumPushes(self, word):
        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(iter(collections.Counter(word).values()), reverse=True)))",O(n)
"class Solution(object):
    def lastMarkedNodes(self, edges):
        def bfs(root):
            new_root = -1
            dist = [-1]*len(adj)
            dist[root] = 0
            q = [root]
            while q:
                new_root = q[0]
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != -1:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist, new_root
            
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        _, u = bfs(0)
        dist1, v = bfs(u)
        dist2, _ = bfs(v)
        return [u if dist1[w] > dist2[w] else v for w in range(len(adj))]",O(n)
"class Solution2(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def bfs():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            new_root = -1
            degree = list(map(len, adj))
            q = [u for u in range(len(degree)) if degree[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if degree[u] == 0:
                        new_root = u
                        continue
                    degree[u] -= 1
                    for v in adj[u]:
                        if degree[v] == 0:
                            continue
                        curr = increase(dp[u][0])
                        for i in range(len(dp[v])):
                            if curr > dp[v][i]:
                                curr, dp[v][i] = dp[v][i], curr
                        degree[v] -= 1
                        if degree[v] == 1:
                            new_q.append(v)
                q = new_q
            return dp, new_root

        def bfs2(root):
            result = [-1]*len(adj)
            q = [(root, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp, u = bfs()
        return bfs2(u)",O(n)
"class Solution3(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            dp = [[(0, u)]*2 for u in range(len(adj))]
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def bfs():
            result = [-1]*len(adj)
            q = [(0, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = topological_traversal()
        return bfs()",O(n)
"class Solution4(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def iter_dfs1():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    stk.append((2, (u, p, 0)))
                elif step == 2:
                    u, p, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    stk.append((3, (v, u)))
                    stk.append((1, (v, u)))
                elif step == 3:
                    v, u = args
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def iter_dfs2():
            result = [-1]*len(adj)
            stk = [(0, -1, (0, -1))]
            while stk:
                u, p, curr = stk.pop()
                result[u] = max(dp[u][0], curr)[1]
                for v in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs1()
        return iter_dfs2()",O(n)
"class Solution5(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = increase(dp[v][0])
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr)))
            result[u] = max(dp[u][0], curr)[1]
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[(0, u)]*2 for u in range(len(adj))]
        dfs1(0, -1)
        result = [-1]*len(adj)
        dfs2(0, -1, (0, -1))
        return result",O(n)
"class Solution(object):
    def numberOfCombinations(self, num):
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in range(len(num)+1)] 
            for i in reversed(range(len(lcp)-1)):
                for j in reversed(range(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in range(len(num))] 
        dp[0][0] = int(num[0] != '0')
        for i in range(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in range(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu 
                if i-l < 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)",O(n ^ 2)
"from collections import Counter


class Solution(object):
    def removeDuplicateLetters(self, s):
        remaining = Counter(s)

        in_stack, stk = set(), []
        for c in s:
            if c not in in_stack:
                while stk and stk[-1] > c and remaining[stk[-1]]:
                    in_stack.remove(stk.pop())
                stk += c
                in_stack.add(c)
            remaining[c] -= 1
        return """".join(stk)",O(n)
"class Solution(object):
    def minimumBuckets(self, street):
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 < len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result",O(n)
"import collections
import itertools


class Solution(object):
    def movesToChessboard(self, board):
        N = len(board)
        result = 0
        for count in (collections.Counter(list(map(tuple, board))), \
                      collections.Counter(zip(*board))):
            if len(count) != 2 or \
               sorted(count.values()) != [N/2, (N+1)/2]:
                return -1

            seq1, seq2 = count
            if any(x == y for x, y in zip(seq1, seq2)):
                return -1
            begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1]
            result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) \
                          for begin in begins) / 2
        return result",O(n ^ 2)
"import collections



class Solution(object):
    def getMaxFunctionValue(self, receiver, k):
        def find_cycles(adj):
            result = []
            lookup = [0]*len(adj)
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    u = adj[u]
                if lookup[u] > prev:
                    result.append((u, idx-lookup[u]+1))
            return result

        def find_prefixes():
            lookup = [(-1, -1)]*len(receiver)
            prefixes = [[0] for _ in range(len(cycles))]
            for idx, (u, l) in enumerate(cycles):
                for i in range(l):
                    lookup[u] = (idx, i)
                    prefixes[idx].append(prefixes[idx][i]+u)
                    u = receiver[u]
            return lookup, prefixes
        
        def get_sum(prefix, i, cnt):
            l = len(prefix)-1
            q, r = divmod(cnt, l)
            return (q*prefix[-1]+
                    (prefix[min(i+r, l)]-prefix[i])+
                    (prefix[max(((i+r)-l, 0))]-prefix[0]))
        
        def start_inside_cycle():
            result = 0
            for u, l in cycles:
                for _ in range(l):
                    idx, i = lookup[u]
                    result = max(result, get_sum(prefixes[idx], i, k+1))
                    u = receiver[u]
            return result
    
        def start_outside_cycle():
            result = 0
            degree = [0]*len(receiver)
            for x in receiver:
                degree[x] += 1
            for u in range(len(receiver)):
                if degree[u]:
                    continue
                curr = 0
                dq = collections.deque()
                while lookup[u][0] == -1:
                    curr += u
                    dq.append(u)
                    if len(dq) == k+1:
                        result = max(result, curr)
                        curr -= dq.popleft()
                    u = receiver[u]
                idx, i = lookup[u]
                while dq:
                    result = max(result, curr+get_sum(prefixes[idx], i, (k+1)-len(dq)))
                    curr -= dq.popleft()
            return result
            
        cycles = find_cycles(receiver)
        lookup, prefixes = find_prefixes()
        return max(start_inside_cycle(), start_outside_cycle())",O(n)
"class Solution(object):
    def minCost(self, nums, costs):
        stk1, stk2 = [], []
        dp = [float(""inf"")]*len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            while stk1 and nums[stk1[-1]] <= nums[i]:
                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])
            stk1.append(i)
            while stk2 and nums[stk2[-1]] > nums[i]:
                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])
            stk2.append(i)
        return dp[-1]",O(n)
"
class Solution(object):
    def deleteNode(self, node):
        if node and node.__next__:
            node_to_delete = node.__next__
            node.val = node_to_delete.val
            node.next = node_to_delete.__next__
            del node_to_delete

",O(1)
"class Solution(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center
        x = x1 if x1 > 0 else x2 if x2 < 0 else 0
        y = y1 if y1 > 0 else y2 if y2 < 0 else 0
        return x**2 + y**2 <= radius**2",O(1)
"class Solution2(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center        
        x = min(abs(x1), abs(x2)) if x1*x2 > 0 else 0
        y = min(abs(y1), abs(y2)) if y1*y2 > 0 else 0
        return x**2 + y**2 <= radius**2",O(1)
"class Solution(object):
    def getMaxLen(self, nums):
        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
        for i in range(len(nums)):
            if nums[i] == 0:
                neg_cnt = 0
                last_zero_pos = i
                first_valid_neg_pos = -1
                continue
            if nums[i] < 0:
                if first_valid_neg_pos == -1:
                    first_valid_neg_pos = i
                neg_cnt += 1
            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))
        return result",O(n)
"class Solution(object):
    def findAnagrams(self, s, p):
        result = []

        cnts = [0] * 26
        for c in p:
            cnts[ord(c) - ord('a')] += 1

        left, right = 0, 0
        while right < len(s):
            cnts[ord(s[right]) - ord('a')] -= 1
            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:
                cnts[ord(s[left]) - ord('a')] += 1
                left += 1
            if right - left + 1 == len(p):
                result.append(left)
            right += 1

        return result",O(n)
"class Solution(object):
    def maxOperations(self, nums):
        def memoization(left, right, target, lookup):
            if not right-left+1 >= 2:
                return 0
            if lookup[left][right] == -1:
                lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1]   == target else 0,
                                          1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right]    == target else 0,
                                          1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0)
            return lookup[left][right] 

        return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in range(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]})",O(n ^ 2)
"class Solution(object):
    def soupServings(self, N):
        def dp(a, b, lookup):
            if (a, b) in lookup:
                return lookup[a, b]
            if a <= 0 and b <= 0:
                return 0.5
            if a <= 0:
                return 1.0
            if b <= 0:
                return 0.0
            lookup[a, b] = 0.25 * (dp(a-4, b, lookup) +
                                   dp(a-3, b-1, lookup) +
                                   dp(a-2, b-2, lookup) +
                                   dp(a-1, b-3, lookup))
            return lookup[a, b]

        if N >= 4800:
            return 1.0
        lookup = {}
        N = (N+24)//25
        return dp(N, N, lookup)",O(n ^ 2)
"import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()

    def fizz(self, printFizz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 0:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 != 0:
                    printFizz()
                self.__cv.notify_all()

    def buzz(self, printBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 == 0:
                    printBuzz()
                self.__cv.notify_all()

    def fizzbuzz(self, printFizzBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 2:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 == 0:
                    printFizzBuzz()
                self.__cv.notify_all()

    def number(self, printNumber):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 != 0:
                    printNumber(i)
                self.__cv.notify_all()",O(n)
"class Solution(object):
    def minimumDifference(self, nums, k):
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in range(k-1, len(nums)))",O(nlogn)
"class Solution(object):
    def shortestDistanceAfterQueries(self, n, queries):
        def bfs(u, v):
            adj[u].append(v)
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[u]+1 >= dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist[-1]

        adj = [[] for _ in range(n)]
        for u in range(n-1):
            adj[u].append(u+1)
        dist = list(range(n))
        return [bfs(u, v) for u, v in queries]",other
"class Solution(object):
    def balancedStringSplit(self, s):
        result, count = 0, 0      
        for c in s:
            count += 1 if c == 'L' else -1            
            if count == 0:
                result += 1
        return result",O(n)
"class Solution(object):
    def alphabetBoardPath(self, target):
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return """".join(result)",O(n)
"import collections
from functools import reduce


class Solution(object):
    def longestRepeatingSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            result = 0
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]:
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            if result == 0:
                                result = i
                            return result-L+1
                lookup[curr].append(i)
            return result

        left, right = 0, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution(object):
    def replaceElements(self, arr):
        curr_max = -1
        for i in reversed(range(len(arr))):
            arr[i], curr_max = curr_max, max(curr_max, arr[i])
        return arr",O(n)
"class Solution(object):
    def maxPrice(self, items, capacity):
        result = 0
        items.sort(key=lambda x: float(x[0])/x[1], reverse=True)
        for p, c in items:
            cnt = min(c, capacity)
            capacity -= cnt
            result += (float(p)/c)*cnt
        return result if capacity == 0 else -1",O(nlogn)
"class Solution(object):
    def numOfSubarrays(self, arr):
        MOD = 10**9+7
        result, accu = 0, 0
        dp = [1, 0]
        for x in arr:
            accu ^= x&1
            dp[accu] += 1
            result = (result + dp[accu^1]) % MOD
        return result",O(n)
"import heapq



class Solution(object):
    def convertArray(self, nums):
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x < -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))",O(nlogn)
"import collections



class Solution2(object):
    def convertArray(self, nums):
        vals = sorted(set(nums))
        def f(nums):
            dp = collections.defaultdict(int) 
            for x in nums:
                prev = -1
                for i in vals:
                    dp[i] = min(dp[i]+abs(i-x), dp[prev]) if prev != -1 else dp[i]+abs(i-x)
                    prev = i
            return dp[vals[-1]]

        return min(f(nums), f((x for x in reversed(nums))))",other
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def levelOrder(self, root):
        if not root:
            return []
        result, q = [], [root]
        while q:
            result.append([node.val for node in q])
            q = [child for node in q for child in node.children if child]
        return result

",O(n)
"import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        result = 0
        q = collections.deque(initialBoxes)
        while q:
            changed = False
            for _ in range(len(q)):
                box = q.popleft()
                if not status[box]:
                    q.append(box)
                    continue
                changed = True
                result += candies[box]
                for contained_key in keys[box]:
                    status[contained_key] = 1
                for contained_box in containedBoxes[box]:
                    q.append(contained_box)
            if not changed:
                break
        return result",O(n ^ 2)
"class Solution(object):
    def smallestNumber(self, n):
        result = []
        for d in reversed(range(2, 9+1)):
            while n%d == 0:
                result.append(d)
                n //= d
        return """".join(map(str, reversed(result))) or ""1"" if n == 1 else ""-1""",O(logn)
"class Solution(object):
    def subarraySum(self, nums):
        diff = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            diff[max(i-x, 0)] += 1
            diff[i+1] -= 1
        for i in range(len(nums)):
            diff[i+1] += diff[i]
        return sum(nums[i]*diff[i] for i in range(len(nums)))",O(n)
"class Solution(object):
    def canVisitAllRooms(self, rooms):
        lookup = set([0])
        stack = [0]
        while stack:
            node = stack.pop()
            for nei in rooms[node]:
                if nei not in lookup:
                    lookup.add(nei)
                    if len(lookup) == len(rooms):
                        return True
                    stack.append(nei)
        return len(lookup) == len(rooms)",O(n)
"class Node(object):
    def __init__(self, value, keys):
        self.value = value
        self.keys = keys
        self.prev = None
        self.next = None


class LinkedList(object):
    def __init__(self):
        self.head, self.tail = Node(0, set()), Node(0, set())
        self.head.next, self.tail.prev = self.tail, self.head

    def insert(self, pos, node):
        node.prev, node.next = pos.prev, pos
        pos.prev.next, pos.prev = node, node
        return node

    def erase(self, node):
        node.prev.next, node.next.prev = node.__next__, node.prev
        del node

    def empty(self):
        return self.head.__next__ is self.tail

    def begin(self):
        return self.head.__next__

    def end(self):
        return self.tail

    def front(self):
        return self.head.__next__

    def back(self):
        return self.tail.prev


class Solution(object):

    def __init__(self):
        self.bucket_of_key = {}
        self.buckets = LinkedList()

    def inc(self, key):
        if key not in self.bucket_of_key:
            self.bucket_of_key[key] = self.buckets.insert(self.buckets.begin(), Node(0, set([key])))

        bucket, next_bucket = self.bucket_of_key[key], self.bucket_of_key[key].__next__
        if next_bucket is self.buckets.end() or next_bucket.value > bucket.value+1:
            next_bucket = self.buckets.insert(next_bucket, Node(bucket.value+1, set()))
        next_bucket.keys.add(key)
        self.bucket_of_key[key] = next_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def dec(self, key):
        if key not in self.bucket_of_key:
            return

        bucket, prev_bucket = self.bucket_of_key[key], self.bucket_of_key[key].prev
        self.bucket_of_key.pop(key, None)
        if bucket.value > 1:
            if bucket is self.buckets.begin() or prev_bucket.value < bucket.value-1:
                prev_bucket = self.buckets.insert(bucket, Node(bucket.value-1, set()))
            prev_bucket.keys.add(key)
            self.bucket_of_key[key] = prev_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def getMaxKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.back().keys))

    def getMinKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.front().keys))",O(1)
"class Solution(object):
    def survivedRobotsHealths(self, positions, healths, directions):
        stk = []
        for i in sorted(range(len(positions)), key=lambda x:positions[x]):
            if directions[i] == 'R':
                stk.append(i)
                continue
            while stk:
                if healths[stk[-1]] == healths[i]:
                    healths[stk.pop()] = healths[i] = 0
                    break
                if healths[stk[-1]] > healths[i]:
                    healths[i] = 0
                    healths[stk[-1]] -= 1
                    break                
                healths[stk.pop()] = 0
                healths[i] -= 1
        return [x for x in healths if x]",O(nlogn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret


class Solution(object):
    def pancakeSort(self, arr):
        bit = BIT(len(arr))
        result = []
        for i in range(len(arr)):
            n = bit.query((arr[i]-1)-1)
            bit.add(arr[i]-1, 1)
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result",O(nlogn)
"class Solution2(object):
    def pancakeSort(self, arr):
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
            
        idxs = []
        smaller_counts = [0]*len(arr)
        for i, x in enumerate(arr):
            idxs.append((x, i))
        smallerMergeSort(idxs, 0, len(idxs)-1, smaller_counts)
        result = []
        for i, n in enumerate(smaller_counts):
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result",O(nlogn)
"class Solution3(object):
    def pancakeSort(self, A):
        def reverse(l, begin, end):
            for i in range((end-begin) // 2):
                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]

        result = []
        for n in reversed(range(1, len(A)+1)):
            i = A.index(n)
            reverse(A, 0, i+1)
            result.append(i+1)
            reverse(A, 0, n)
            result.append(n)
        return result",O(n ^ 2)
"import collections



class Solution(object):
    def findHighAccessEmployees(self, access_times):
        LIMIT_COUNT = 2
        LIMIT_MINUTE = 60
        def to_minute(x):
            return int(x[:2])*60+int(x[2:])
    
        lookup = collections.defaultdict(list)
        for x, t in access_times:
            lookup[x].append(to_minute(t))
        result = []
        for x, ts in lookup.items():
            ts.sort()
            if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in range(len(ts)-LIMIT_COUNT)):
                result.append(x)
        return result",O(nlogn)
"class Solution(object):
    def maximumAlternatingSubarraySum(self, nums):
        def kadane(nums, start):
            result = float(""-inf"")
            curr = odd = 0
            for i in range(start, len(nums)):
                curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0)
                result = max(result, curr)
                odd ^= 1
            return result

        return max(kadane(nums, 0), kadane(nums, 1))",O(n)
"import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):
        lookup = collections.defaultdict(list)
        A = list(zip(timestamp, username, website))
        A.sort()
        for t, u, w in A:
            lookup[u].append(w)
        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())
        return list(min(count, key=lambda x: (-count[x], x)))",O(n ^ 3)
"class Solution(object):
    def canAliceWin(self, nums):
        total1 = total2 = 0
        for x in nums:
            if x < 10:
                total1 += x
            else:
                total2 += x
        return total1 != total2",O(n)
"class Solution2(object):
    def canAliceWin(self, nums):
        return sum(x for x in nums if x < 10) != sum(x for x in nums if x >= 10)",O(n)
"class Solution(object):
    def maximumTotalSum(self, maximumHeight):
        maximumHeight.sort()
        result, prev = 0, maximumHeight[-1]+1
        for x in reversed(maximumHeight):
            prev = min(x, prev-1)
            if prev == 0:
                return -1
            result += prev
        return result",O(nlogn)
"class Solution(object):
    def reversePrefix(self, word, ch):
        i = word.find(ch)
        return word[:i+1][::-1]+word[i+1:]",O(n)
"class Solution(object):
    def truncateSentence(self, s, k):
        for i in range(len(s)):
            if s[i] == ' ':
                k -= 1
                if not k:
                    return s[:i]
        return s",O(n)
"class Solution(object):
    def trap(self, height):
        result, left, right, level = 0, 0, len(height)-1, 0
        while left < right:
            if height[left] < height[right]:
                lower = height[left]
                left += 1
            else:
                lower = height[right]
                right -= 1
            level = max(level, lower)
            result += level-lower
        return result",O(n)
"class Solution2(object):
    def trap(self, A):
        result = 0
        top = 0
        for i in range(len(A)):
            if A[top] < A[i]:
                top = i

        second_top = 0
        for i in range(top):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        second_top = len(A) - 1
        for i in reversed(range(top, len(A))):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        return result",O(n)
"class Solution3(object):
    def trap(self, height):
        right = [0]*len(height)
        mx = 0
        for i in reversed(range(len(height))):
            right[i] = mx
            mx = max(mx, height[i])
        result = left = 0
        for i in range(len(height)):
            left = max(left, height[i])
            result += max(min(left, right[i])-height[i], 0)
        return result",O(n)
"class Solution4(object):
    def trap(self, height):
        result = 0
        stk = []
        for i in range(len(height)):
            prev = 0
            while stk and height[stk[-1]] <= height[i]:
                j = stk.pop()
                result += (height[j] - prev) * (i - j - 1)
                prev = height[j]
            if stk:
                result += (height[i] - prev) * (i - stk[-1] - 1)
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def canReach(self, s, minJump, maxJump):
        dp = [False]*len(s)
        dp[0] = True
        cnt = 0
        for i in range(1, len(s)):
            if i >= minJump:
                cnt += dp[i-minJump]
            if i > maxJump:
                cnt -= dp[i-maxJump-1]
            dp[i] = cnt > 0 and s[i] == '0'
        return dp[-1]",O(n)
"import collections



class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in range(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1",O(n)
"class Solution(object):
    def validSubarrays(self, nums):
        result = 0
        s = []
        for num in nums:
            while s and s[-1] > num:
                s.pop()
            s.append(num)
            result += len(s)
        return result",O(n)
"import collections



class Solution(object):
    def minimumOperations(self, nums):
        even_top = collections.Counter(nums[i] for i in range(0, len(nums), 2)).most_common(2) 
        odd_top = collections.Counter(nums[i] for i in range(1, len(nums), 2)).most_common(2) 
        if not odd_top or even_top[0][0] != odd_top[0][0]:
            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)
        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),
                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))",O(n)
"import collections
from sortedcontainers import SortedList



class Solution(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        def update(accu, d):
            i = sl.bisect_left(idxs[x][-1])
            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD
            bit.add(idxs[x][-1], d*idxs[x][-1])
            return accu

        idxs = collections.defaultdict(list)
        for i in reversed(range(len(nums))):
            idxs[nums[i]].append(i)
        result = 0
        sl = SortedList(idxs[x][-1] for x in idxs)
        accu = (len(nums)*len(sl)**2) % MOD
        for i, x in enumerate(sl):
            accu = (accu-(2*i+1)*x) % MOD
        bit = BIT(len(nums))
        for x in sl:
            bit.add(x, x)
        for x in nums:
            result = (result+accu) % MOD 
            accu = update(accu, -1)
            del sl[0]
            idxs[x].pop()
            if not idxs[x]:
                continue
            sl.add(idxs[x][-1])
            accu = update(accu, +1)
        assert(accu == 0)
        return result",O(nlogn)
"class Solution2(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=None,
                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,
                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.lazy = [None]*self.base
                self.query_fn = query_fn
                self.update_fn = update_fn
                if build_fn is not None:
                    for i in range(self.base, self.base+N):
                        self.tree[i] = build_fn(i-self.base)
                    for i in reversed(range(1, self.base)):
                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])
                self.count = [1]*len(self.tree) 
                for i in reversed(range(1, self.base)): 
                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) 
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def __push(self, x):
                for h in reversed(range(1, x.bit_length())):
                    y = x>>h
                    if self.lazy[y] is not None:
                        self.__apply(y<<1, self.lazy[y])
                        self.__apply((y<<1)+1, self.lazy[y])
                        self.lazy[y] = None

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) 

                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                self.__push(L)
                self.__push(R)
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        result = accu = 0
        sl = {}
        st = SegmentTree(len(nums))
        for i in range(len(nums)):
            j = sl[nums[i]] if nums[i] in sl else -1
            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD
            result = (result+accu)%MOD
            st.update(j+1, i, 1) 
            sl[nums[i]] = i
        return result",O(nlogn)
"class Solution(object):
    def findSubarrays(self, nums):
        lookup = set()
        for i in range(len(nums)-1):
            if nums[i]+nums[i+1] in lookup:
                return True
            lookup.add(nums[i]+nums[i+1])
        return False",O(n)
"class Solution(object):
    def numSubarraysWithSum(self, A, S):
        result = 0
        left, right, sum_left, sum_right = 0, 0, 0, 0
        for i, a in enumerate(A):
            sum_left += a
            while left < i and sum_left > S:
                sum_left -= A[left]
                left += 1
            sum_right += a
            while right < i and \
                  (sum_right > S or (sum_right == S and not A[right])):
                sum_right -= A[right]
                right += 1
            if sum_left == S:
                result += right-left+1
        return result",O(n)
"class Solution(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = mx = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            if mx > min(nums[i] for i in range(left, right+1)):
                return False
            mx = max(nums[i] for i in range(left, right+1))
            left = right+1
        return True",O(n)
"import itertools



class Solution2(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
        
        def pairwise(it):
            a, b = tee(it)
            next(b, None)
            return zip(a, b)

        return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount)))",O(n)
"class Solution3(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            nums[left:right+1] = sorted(nums[left:right+1])
            left = right+1
        return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))",O(nlogn)
"import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] > limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1 
        return len(nums)-left",O(n)
"import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        result, left = 0, 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            while nums[max_dq[0]]-nums[min_dq[0]] > limit: 
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"class Solution(object):
    def waysToSplit(self, nums):
        MOD = 10**9+7

        prefix = [0]
        for x in nums:
            prefix.append(prefix[-1]+x)

        result = left = right = 0 
        for i in range(len(nums)): 
            left = max(left, i+1)
            while left+1 < len(nums) and prefix[i+1] > prefix[left+1]-prefix[i+1]:
                left += 1
            right = max(right, left)
            while right+1 < len(nums) and prefix[right+1]-prefix[i+1] <= prefix[-1]-prefix[right+1]:
                right += 1
            result = (result + (right-left))%MOD
        return result",O(n)
"class Solution(object):
    def checkValid(self, matrix):
        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in range(len(matrix)))) == len(matrix) for j in range(len(matrix[0])))",O(n ^ 2)
"class Solution_Wrong(object):
    def checkValid(self, matrix):
        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in range(len(matrix[0])))) == 0 for i in range(len(matrix))) and \
               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in range(len(matrix)))) == 0 for j in range(len(matrix[0])))",O(n ^ 2)
"class Solution(object):
    def countSegments(self, s):
        result = int(len(s) and s[-1] != ' ')
        for i in range(1, len(s)):
            if s[i] == ' ' and s[i-1] != ' ':
                result += 1
        return result

    def countSegments2(self, s):
        return len([i for i in s.strip().split(' ') if i])",O(n)
"class Solution(object):
    def videoStitching(self, clips, T):
        if T == 0:
            return 0
        result = 1
        curr_reachable, reachable = 0, 0
        clips.sort()
        for left, right in clips:
            if left > reachable:
                break
            elif left > curr_reachable:
                curr_reachable = reachable
                result += 1
            reachable = max(reachable, right)
            if reachable >= T:
                return result
        return -1",O(nlogn)
"class Solution(object):
    def calculateTime(self, keyboard, word):
        lookup = {c:i for i, c in enumerate(keyboard)}
        result, prev = 0, 0
        for c in word:
            result += abs(lookup[c]-prev)
            prev = lookup[c]
        return result",O(n)
"class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last = 0
        for i in range(len(A)):
            if A[last] != A[i]:
                last += 1
                A[last] = A[i]
        return last + 1",O(n)
"class Solution(object):
    def validWordAbbreviation(self, word, abbr):
        i , digit = 0, 0
        for c in abbr:
            if c.isdigit():
                if digit == 0 and c == '0':
                    return False
                digit *= 10
                digit += int(c)
            else:
                if digit:
                    i += digit
                    digit = 0
                if i >= len(word) or word[i] != c:
                    return False
                i += 1
        if digit:
            i += digit

        return i == len(word)",O(n)
"import collections


class Solution(object):
    def maxConsecutiveAnswers(self, answerKey, k):
        result = max_count = 0
        count = collections.Counter()
        for i in range(len(answerKey)):
            count[answerKey[i]] += 1
            max_count = max(max_count, count[answerKey[i]])
            if result-max_count >= k:
                count[answerKey[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort()
        prefix = sum(nums)
        for i in reversed(range(2, len(nums))):
            prefix -= nums[i]
            if prefix > nums[i]:
                return prefix+nums[i]
        return -1",O(nlogn)
"import collections



class Solution(object):
    def countBadPairs(self, nums):
        result = len(nums)*(len(nums)-1)//2
        cnt = collections.Counter()
        for i, x in enumerate(nums):
            result -= cnt[x-i]
            cnt[x-i] += 1
        return result",O(n)
"class Solution(object):
    def maxWidthRamp(self, A):
        result = 0
        s = []
        for i in A:
            if not s or A[s[-1]] > A[i]:
                s.append(i)
        for j in reversed(range(len(A))):
            while s and A[s[-1]] <= A[j]:
                result = max(result, j-s.pop())
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result",O(n)
"class Solution2(object):
    def maxSumBST(self, root):
        def dfs(node, result):
            if not node:
                return True, 0, float(""inf""), float(""-inf"")
            lvalid, lsum, lmin, lmax = dfs(node.left, result)
            rvalid, rsum, rmin, rmax = dfs(node.right, result)
            if lvalid and rvalid and lmax < node.val < rmin:
                total = lsum + node.val + rsum
                result[0] = max(result[0], total)
                return True, total, min(lmin, node.val), max(node.val, rmax)
            return False, 0, 0, 0

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"class Solution(object):
    def numPermsDISequence(self, S):
        dp = [1]*(len(S)+1)
        for c in S:
            if c == ""I"":
                dp = dp[:-1]
                for i in range(1, len(dp)):
                    dp[i] += dp[i-1]
            else:
                dp = dp[1:]
                for i in reversed(range(len(dp)-1)):
                    dp[i] += dp[i+1]
        return dp[0] % (10**9+7)",O(n ^ 2)
"class Solution(object):
    def minimumOperations(self, nums):
        result = 0
        left, right = 0, len(nums)-1
        l, r = nums[left], nums[right]
        while left < right:
            if l == r:
                left += 1
                right -= 1
                l, r = nums[left], nums[right]
                continue
            if l < r:
                left += 1
                l += nums[left]
            else:
                right -= 1
                r += nums[right]
            result += 1
        return result",O(n)
"class Solution(object):
    def maxHeight(self, cuboids):
        for cuboid in cuboids:
            cuboid.sort()
        cuboids.append([0, 0, 0])
        cuboids.sort()
        dp = [0]*len(cuboids)
        for i in range(1, len(cuboids)):
            for j in range(i):
                if all(cuboids[j][k] <= cuboids[i][k] for k in range(3)):
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])
        return max(dp)",O(n ^ 2)
"
class Solution(object):
    def maximumNumber(self, num, change):
        mutated = False
        result = list(map(int, list(num)))
        for i, d in enumerate(result):
            if change[d] < d:
                if mutated:
                    break
            elif change[d] > d:
                result[i] = str(change[d])
                mutated = True
        return """".join(map(str, result))
",O(n)
"class Solution(object):
    def findTheWinner(self, n, k):
        return reduce(lambda idx, n:(idx+k)%(n+1), range(1, n), 0)+1",O(n)
"class Solution2(object):
    def findTheWinner(self, n, k):
        def f(idx, n, k):
            if n == 1:
                return 0
            return (k+f((idx+k)%n, n-1, k))%n
        
        return f(0, n, k)+1",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstToGst(self, root):
        def bstToGstHelper(root, prev):
            if not root:
                return root
            bstToGstHelper(root.right, prev)
            root.val += prev[0]
            prev[0] = root.val
            bstToGstHelper(root.left, prev)
            return root
        
        prev = [0]
        return bstToGstHelper(root, prev)",O(n)
"class Solution(object):
    def bestRotation(self, A):
        N = len(A)
        change = [1] * N
        for i in range(N):
            change[(i-A[i]+1)%N] -= 1
        for i in range(1, N):
            change[i] += change[i-1]
        return change.index(max(change))",O(n)
"class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in range(R+1))",O(1)
"class Solution2(object):
    def distributeCandies(self, n, limit):
        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in range(max(n-2*limit, 0), min(limit, n)+1))",O(n)
"class Solution3(object):
    def distributeCandies(self, n, limit):
        return sum(n-i-j <= limit for i in range(min(limit, n)+1) for j in range(min(limit, n-i)+1))",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxPathSum(self, root):
        def iter_dfs(node):
            result = float(""-inf"")
            max_sum = [0]
            stk = [(1, [node, max_sum])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))
                    ret[0] = node.val+max(ret1[0], ret2[0], 0)
            return result
        
        return iter_dfs(root)",O(n)
"class Solution2(object):
    def maxPathSum(self, root):
        def dfs(node):
            if not node:
                return (float(""-inf""), 0)
            max_left, curr_left = dfs(node.left)
            max_right, curr_right = dfs(node.right)
            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),
                    node.val+max(curr_left, curr_right, 0))
        
        return dfs(root)[0]",O(n)
"class Solution(object):
    def findNthDigit(self, n):
        digit_len = 1
        while n > digit_len * 9 * (10 ** (digit_len-1)):
            n -= digit_len  * 9 * (10 ** (digit_len-1))
            digit_len += 1

        num = 10 ** (digit_len-1) + (n-1)/digit_len

        nth_digit = num / (10 ** ((digit_len-1) - ((n-1)%digit_len)))
        nth_digit %= 10

        return nth_digit",O(logn)
"class Solution(object):
    def lastRemaining(self, n):
        start, step, direction = 1, 2, 1
        while n > 1:
            start += direction * (step * (n//2) - step//2)
            n //= 2
            step *= 2
            direction *= -1
        return start",O(logn)
"class Solution(object):
    def minimumRightShifts(self, nums):
        i = next((i for i in range(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums))
        j = next((j for j in range(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums))
        return len(nums)-(i+1) if j == len(nums) else -1",O(n)
"class Solution(object):
    def maximumSubarraySum(self, nums, k):
        result = left = total = 0
        lookup = set()
        for right in range(len(nums)):
            while nums[right] in lookup or len(lookup) == k:
                lookup.remove(nums[left])
                total -= nums[left]
                left += 1
            lookup.add(nums[right])
            total += nums[right]
            if len(lookup) == k:
                result = max(result, total)
        return result",O(n)
"class Solution(object):
    def maximumHappinessSum(self, happiness, k):
        happiness.sort(reverse=True)
        return sum(max(happiness[i]-i, 0) for i in range(k))",O(nlogn)
"class Solution2(object):
    def maxScore(self, nums):
        dp = [0]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j]+(i-j)*nums[i])
        return dp[-1]",O(n ^ 2)
"class Solution(object):
    def numberOfGoodPartitions(self, nums):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(nums)}
        result = 1
        right = cnt = 0
        for left, x in enumerate(nums):
            if left == right+1:
                cnt += 1
            right = max(right, lookup[x])
        return pow(2, cnt, MOD)",O(n)
"class Solution(object):
    def maxPower(self, s):
        result, count = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result",O(n)
"import itertools


class Solution2(object):
    def maxPower(self, s):
        return max(len(list(v)) for _, v in itertools.groupby(s))",O(n)
"class Solution(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        return pow(2, len(nums)-1, MOD) if any(x%2 for x in nums) else 0",O(n)
"class Solution2(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        dp = [0]*2
        for x in nums:
            dp = [(dp[i]+dp[i^(x%2)]+int(x%2 == i))%MOD for i in range(2)]
        return dp[1]",O(n)
"class Solution(object):
    def isValidPalindrome(self, s, k):
        if s == s[::-1]: 
            return True

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return len(s) <= k + dp[0][-1]",O(n ^ 2)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):

    def serialize(self, root):
        def dfs(node, vals):
            if not node:
                return
            vals.append(str(node.val))
            for child in node.children:
                dfs(child, vals)
            vals.append(
        
        vals = []
        dfs(root, vals)
        return "" "".join(vals)


    def deserialize(self, data):
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
                
        def dfs(vals):
            val = next(vals)
            if val == 
                return None
            root = Node(int(val), [])
            child = dfs(vals)
            while child:
                root.children.append(child)
                child = dfs(vals)
            return root

        if not data:
            return None
    
        return dfs(iter(isplit(data, ' ')))",O(n)
"class Solution(object):
    def convertTime(self, current, correct):
        OPS = (60, 15, 5, 1)
        diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))
        result = 0
        for x in OPS:
            q, diff = divmod(diff, x)
            result += q
        return result",O(1)
"class Solution(object):
    def buildArray(self, target, n):
        result, curr = [], 1
        for t in target:
            result.extend([""Push"", ""Pop""]*(t-curr))
            result.append(""Push"")
            curr = t+1
        return result",O(n)
"class Solution(object):
    def houseOfCards(self, n):
        dp = [0]*(n+1) 
        dp[0] = 1
        for t in range(1, (n+1)//3+1):
            for i in reversed(range(3*t-1, n+1)):
                dp[i] += dp[i-(3*t-1)]
        return dp[n]",O(n ^ 2)
"class Solution_TLE(object):
    def houseOfCards(self, n):
        dp = [[0]*(n+1) for _ in range((n+1)//3+1)] 
        dp[0][0] = 1
        for t in range(1, (n+1)//3+1):
            for i in range(3*t-1, n+1):
                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in range(t))
        return sum(dp[t][n] for t in range((n+1)//3+1))",O(n ^ 2)
"class Solution(object):
    def findMissingRanges(self, nums, lower, upper):
        def getRange(lower, upper):
            if lower == upper:
                return ""{}"".format(lower)
            else:
                return ""{}->{}"".format(lower, upper)
        ranges = []
        pre = lower - 1

        for i in range(len(nums) + 1):
            if i == len(nums):
                cur = upper + 1
            else:
                cur = nums[i]
            if cur - pre >= 2:
                ranges.append(getRange(pre + 1, cur - 1))

            pre = cur

        return ranges",O(n)
"class Solution(object):
    def removeDigit(self, number, digit):
        i = next((i for i in range(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1)
        if i+1 == len(number):
            i = next((i for i in reversed(range(len(number))) if digit == number[i]))
        return number[:i]+number[i+1:]",O(n)
"import collections


class Solution(object):

    def __init__(self):
        self.__left, self.__right = collections.deque(), collections.deque()   

    def pushFront(self, val):
        self.__left.appendleft(val)
        self.__balance()        

    def pushMiddle(self, val):
        if len(self.__left) > len(self.__right):
            self.__right.appendleft(self.__left.pop())
        self.__left.append(val)

    def pushBack(self, val):
        self.__right.append(val)
        self.__balance()

    def popFront(self):
        val = (self.__left or collections.deque([-1])).popleft()
        self.__balance()
        return val

    def popMiddle(self):
        val = (self.__left or [-1]).pop()
        self.__balance()
        return val

    def popBack(self):
        val = (self.__right or self.__left or [-1]).pop()
        self.__balance()
        return val

    def __balance(self):
        if len(self.__left) > len(self.__right)+1:
            self.__right.appendleft(self.__left.pop())
        elif len(self.__left) < len(self.__right):
            self.__left.append(self.__right.popleft())",O(1)
"class Solution(object):
    def minCostClimbingStairs(self, cost):
        dp = [0] * 3
        for i in reversed(range(len(cost))):
            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])
        return min(dp[0], dp[1])",O(n)
"class Solution(object):
    def maxValueAfterReverse(self, nums):
        result, add, max_pair, min_pair = 0, 0, float(""-inf""), float(""inf"")
        for i in range(1, len(nums)):
            result += abs(nums[i-1]-nums[i])
            add = max(add,
                      abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),
                      abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))
            min_pair = min(min_pair, max(nums[i-1], nums[i]))
            max_pair = max(max_pair, min(nums[i-1], nums[i]))
        return result + max(add, (max_pair-min_pair)*2)",O(n)
"class Solution(object):
    def largestPalindrome(self, n, k):
        def inv(x, p):
            return pow(x, p-2, p)

        def f(l):
            p = 7
            result = ['9']*l
            if l:                
                curr = reduce(lambda accu, x: (accu*10+(ord(x)-ord('0')))%p, result, 0)
                i = 9-(curr*inv(11 if l%2 == 0 else 1, p)*inv(pow(10, l//2-int(l%2 == 0), p), p))%p
                if i <= 2:
                    i += p
                result[l//2] = result[l//2-int(l%2 == 0)] = str(i)
            return """".join(result)

        if k in (1, 3, 9):
            return '9'*n
        if k in (2, 4, 8):
            k = min(k, 6)
            if n <= k:
                return '8'*n
            l = k//2
            return '8'*l+'9'*(n-k)+'8'*l
        if k == 5:
            if n <= 2:
                return '5'*n
            return '5'+'9'*(n-2)+'5'
        if k == 6:
            if n <= 2:
                return '6'*n
            if n%2:
                l = n//2-1
                return '8'+'9'*l+'8'+'9'*l+'8'
            l = n//2-2
            return '8'+'9'*l+""77""+'9'*l+'8'
        l, r = divmod(n, 12)
        return ""999999""*l+f(r)+""999999""*l",O(n)
"
import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):
        row_maxes = [max(row) for row in grid]
        col_maxes = [max(col) for col in zip(*grid)]

        return sum(min(row_maxes[r], col_maxes[c])-val \
                   for r, row in enumerate(grid) \
                   for c, val in enumerate(row))

",O(n ^ 2)
"import collections



class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def countPairs(self, root, distance):
        def iter_dfs(distance, root):
            result = 0
            stk = [(1, (root, [collections.Counter()]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    if not node.left and not node.right:
                        ret[0][0] = 1
                        continue
                    left, right = [collections.Counter()], [collections.Counter()]
                    stk.append((2, (left, right, ret)))
                    stk.append((1, (node.right, right)))
                    stk.append((1, (node.left, left)))
                else:
                    left, right, ret = params
                    for left_d, left_c in left[0].items():
                        for right_d,right_c in right[0].items():
                            if left_d+right_d+2 <= distance:
                                result += left_c*right_c
                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).items()})
            return result
        
        return iter_dfs(distance, root)",O(n)
"import collections


class Solution2(object):
    def countPairs(self, root, distance):
        def dfs(distance, node):
            if not node:
                return 0, collections.Counter()
            if not node.left and not node.right:
                return 0, collections.Counter([0])
            left, right = dfs(distance, node.left), dfs(distance, node.right)
            result = left[0]+right[0]
            for left_d, left_c in left[1].items():
                for right_d,right_c in right[1].items():
                    if left_d+right_d+2 <= distance:
                        result += left_c*right_c
            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).items()})
        
        return dfs(distance, root)[0]",O(n)
"import itertools



class Solution(object):
    def paintWalls(self, cost, time):
        dp = [float(""inf"")]*(len(cost)+1)
        dp[0] = 0
        for c, t in zip(cost, time):
            for j in reversed(range(1, len(cost)+1)):
                dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c)
        return dp[-1]",O(n ^ 2)
"class Solution(object):
    def maximumProduct(self, nums):
        min1, min2 = float(""inf""), float(""inf"")
        max1, max2, max3 = float(""-inf""), float(""-inf""), float(""-inf"")

        for n in nums:
            if n <= min1:
                min2 = min1
                min1 = n
            elif n <= min2:
                min2 = n

            if n >= max1:
                max3 = max2
                max2 = max1
                max1 = n
            elif n >= max2:
                max3 = max2
                max2 = n
            elif n >= max3:
                max3 = n

        return max(min1 * min2 * max1, max1 * max2 * max3)",O(n)
"class Solution(object):
    def findMaxAverage(self, nums, k):
        def getDelta(avg, nums, k):
            accu = [0.0] * (len(nums) + 1)
            minval_pos = None
            delta = 0.0
            for i in range(len(nums)):
                accu[i+1] = nums[i] + accu[i] - avg
                if i >= (k-1):
                    if minval_pos == None or accu[i-k+1] < accu[minval_pos]:
                        minval_pos = i-k+1
                    if accu[i+1] - accu[minval_pos] >= 0:
                        delta = max(delta, (accu[i+1] - accu[minval_pos]) / (i+1 - minval_pos))
            return delta

        left, delta = min(nums), float(""inf"")
        while delta > 1e-5:
            delta = getDelta(left, nums, k)
            left += delta
        return left",other
"class Solution(object):
    def capitalizeTitle(self, title):
        title = list(title)
        j = 0
        for i in range(len(title)+1):
            if i < len(title) and title[i] != ' ':
                title[i] = title[i].lower()
                continue
            if i-j > 2:
                title[j] = title[j].upper()
            j = i+1
        return """".join(title)",O(n)
"class Solution(object):
    def divideArray(self, nums, k):
        nums.sort()
        return [nums[i:i+3] for i in range(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in range(0, len(nums), 3)) else []",O(nlogn)
"class Solution(object):
    def countHillValley(self, nums):
        result, inc = 0, -1
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                result += int(inc == 0)
                inc = 1
            elif nums[i] > nums[i+1]:
                result += int(inc == 1)
                inc = 0
        return result",O(n)
"import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):
        lookup = collections.defaultdict(list)
        i = len(rains)-1
        for lake in reversed(rains):
            lookup[lake].append(i)
            i -= 1
        result, min_heap = [], []
        for i, lake in enumerate(rains):
            if lake:
                if len(lookup[lake]) >= 2:
                    lookup[lake].pop()
                    heapq.heappush(min_heap, lookup[lake][-1])
                result.append(-1)
            elif min_heap:
                j = heapq.heappop(min_heap)
                if j < i:
                    return []
                result.append(rains[j])
            else:
                result.append(1)
        return result if not min_heap else []",O(nlogn)
"import collections


class Solution(object):
    def majorityElement(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result

        return boyer_moore_majority_vote()",O(n)
"import collections


class Solution2(object):
    def majorityElement(self, nums):
        return collections.Counter(nums).most_common(1)[0][0]",O(n)
"import collections


class Solution3(object):
    def majorityElement(self, nums):
        return sorted(list(collections.Counter(nums).items()), key=lambda a: a[1], reverse=True)[0][0]",O(nlogn)
"class Solution(object):
    def subArrayRanges(self, nums):
        result = 0
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""inf"")
            while stk and nums[stk[-1]] <= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""-inf"")
            while stk and nums[stk[-1]] >= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result",O(n)
"import itertools


class Solution(object):
    def minSwaps(self, grid):
        result = 0
        for target in reversed(range(1, len(grid))):
            row_idx = len(grid)-1-target
            while row_idx < len(grid):
                row = grid[row_idx]
                if not sum(itertools.islice(row, len(row)-target, len(row))):
                    break
                row_idx += 1
            else:
                return -1
            while row_idx != len(grid)-1-target:
                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]
                result += 1
                row_idx -= 1
        return result",O(n ^ 2)
"class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):
        return (D - B) * (C - A) + \
               (G - E) * (H - F) - \
               max(0, (min(C, G) - max(A, E))) * \
               max(0, (min(D, H) - max(B, F)))",O(1)
"class Solution(object):
    def largestAltitude(self, gain):
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def canAliceWin(self, n):
        c = 10
        l = int(((2*c+1)-((2*c+1)**2-8*n)**0.5)/2)
        return l%2 == 1",O(1)
"import collections


class Solution(object):
    def findShortestSubArray(self, nums):
        counts = collections.Counter(nums)
        left, right = {}, {}
        for i, num in enumerate(nums):
            left.setdefault(num, i)
            right[num] = i
        degree = max(counts.values())
        return min(right[num]-left[num]+1 \
                   for num in list(counts.keys()) \
                   if counts[num] == degree)",O(n)
"
import pandas as pd



def Solution(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame(
        data=student_data,
        columns=[""student_id"", ""age""],
    )


",O(n)
"import pandas as pd



def Solution2(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame({k:[x[i] for x in student_data] for i, k in enumerate([""student_id"", ""age""])})",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rightSideView(self, root):
        result = []
        self.rightSideViewDFS(root, 1, result)
        return result

    def rightSideViewDFS(self, node, depth, result):
        if not node:
            return

        if depth > len(result):
            result.append(node.val)

        self.rightSideViewDFS(node.right, depth+1, result)
        self.rightSideViewDFS(node.left, depth+1, result)",O(n)
"class Solution2(object):
    def rightSideView(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level = []
            for node in current:
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)                
            result.append(node.val)
            current = next_level

        return result",O(n)
"class Solution(object):
    def carPooling(self, trips, capacity):
        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]
        line.sort()
        for _, num in line:
            capacity -= num
            if capacity < 0:
                return False
        return True",O(nlogn)
"class Solution(object):
    def minimumTime(self, s):
        left = 0
        result = left+(len(s)-0)
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)
            result = min(result, left+(len(s)-i))
        return result",O(n)
"class Solution2(object):
    def minimumTime(self, s):
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(range(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result",O(n)
"class Solution(object):
    def outerTrees(self, points):
        points = sorted(set(tuple(x) for x in points))

        if len(points) <= 1:
            return points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower = []
        for p in points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: 
                lower.pop()
            lower.append(p)

        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: 
                upper.pop()
            upper.append(p)

        result = lower[:-1] + upper[:-1]
        return result if result[1] != result[-1] else result[:len(result)//2+1]",O(nlogn)
"import collections



class Solution(object):
    def minGroups(self, intervals):
        events = collections.Counter()
        for l, r in intervals:
            events[l] += 1
            events[r+1] -= 1
        result = curr = 0
        for t in sorted(events.keys()):
            curr += events[t]
            result = max(result, curr)
        return result",O(nlogn)
"class Solution(object):
    def pivotIndex(self, nums):
        total = sum(nums)
        left_sum = 0
        for i, num in enumerate(nums):
            if left_sum == (total-left_sum-num):
                return i
            left_sum += num
        return -1",O(n)
"

class Solution(object):
    def insertGreatestCommonDivisors(self, head):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        curr = head
        while curr.__next__:
            curr.next = ListNode(gcd(curr.val, curr.next.val), curr.next)
            curr = curr.next.__next__
        return head
",O(n)
"class Solution(object):
    def maxAscendingSum(self, nums):
        result = curr = 0
        for i in range(len(nums)): 
            if not (i and nums[i-1] < nums[i]):
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"import collections


class Solution(object):
    def shortestSubarray(self, A, K):
        accumulated_sum = [0]*(len(A)+1)
        for i in range(len(A)):
            accumulated_sum[i+1] = accumulated_sum[i]+A[i]

        result = float(""inf"")
        mono_increasing_q = collections.deque()
        for i, curr in enumerate(accumulated_sum):
            while mono_increasing_q and curr <= \
                    accumulated_sum[mono_increasing_q[-1]]:
                mono_increasing_q.pop()
            while mono_increasing_q and \
                    curr-accumulated_sum[mono_increasing_q[0]] >= K:
                result = min(result, i-mono_increasing_q.popleft())
            mono_increasing_q.append(i)
        return result if result != float(""inf"") else -1",O(n)
"class Solution(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def iter_dfs(u, p, dist):
            result = 0
            stk = [(u, p, dist)]
            while stk:
                u, p, dist = stk.pop()
                if dist%signalSpeed == 0:
                    result += 1
                for v, w in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, dist+w))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = iter_dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"class Solution2(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def dfs(u, p, dist):
            cnt = 1 if dist%signalSpeed == 0 else 0
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt += dfs(v, u, dist+w)
            return cnt
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"class Solution3(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def bfs(u, p, dist):
            result = 0
            q = [(u, p, dist)]
            while q:
                new_q = []
                for u, p, dist in q:
                    if dist%signalSpeed == 0:
                        result += 1
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, dist+w))
                q = new_q
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = bfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"import collections
import heapq


class Solution3(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result",O(nlogn)
"
import threading
import collections


class Solution(object):
    def __init__(self, capacity):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__cap = capacity

    def enqueue(self, element):
        with self.__cv:
            while len(self.__q) == self.__cap:
                self.__cv.wait()
            self.__q.append(element)
            self.__cv.notifyAll()

    def dequeue(self):
        with self.__cv:
            while not self.__q:
                self.__cv.wait()
            self.__cv.notifyAll()
            return self.__q.popleft()

    def size(self):
        with self.__cv:
            return len(self.__q)
",O(1)
"class Solution(object):
    def maximumBooks(self, books):
        def count(right, l):
            left = max(right-l+1, 0)
            return (left+right)*(right-left+1)//2
        
        result = curr = 0
        stk = [-1]
        for i in range(len(books)):
            while stk[-1] != -1 and books[stk[-1]] >= books[i]-(i-stk[-1]):
                j = stk.pop()
                curr -= count(books[j], j-stk[-1])
            curr += count(books[i], i-stk[-1])
            stk.append(i)
            result = max(result, curr)
        return result",O(n)
"
import collections



class Solution(object):
    def digitCount(self, num):
        cnt = collections.Counter(num)
        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))
",O(n)
"class Solution(object):
    def minimumSteps(self, s):
        result = left = 0
        for right in range(len(s)):
            if s[right] != '0':
                continue
            result += right-left
            left += 1
        return result",O(n)
"class Solution2(object):
    def minimumSteps(self, s):
        result = 0
        left, right = 0, len(s)-1
        while left < right:
            if left < len(s) and s[left] != '1':
                left += 1
                continue
            if right >= 0 and s[right] != '0':
                right -= 1
                continue
            result += right-left
            left += 1
            right -= 1
        return result",O(n)
"class Solution2(object):
    def arrayPairSum(self, nums):
        nums.sort()
        result = 0
        for i in range(0, len(nums), 2):
            result += nums[i]
        return result",O(nlogn)
"class Solution3(object):
    def arrayPairSum(self, nums):
        nums = sorted(nums)
        return sum([nums[i] for i in range(0, len(nums), 2)])",O(nlogn)
"import threading


class Solution(object):
    
    def __init__(self):
        self.__l = threading.Lock()
        self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
        with self.__l:
            if self.__light != roadId:
                self.__light = roadId
                turnGreen()
            crossCar()",O(1)
"class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):
        dist = [[float(""inf"")]*n for _ in range(n)]
        for i, j, w in edges:
            dist[i][j] = dist[j][i] = w
        for i in range(n):
            dist[i][i] = 0
        for k in range(n): 
            for i in range(n): 
                for j in range(n): 
                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) 
        result = {sum(d <= distanceThreshold for d in dist[i]): i for i in range(n)}
        return result[min(result.keys())]",O(n ^ 3)
"class Solution(object):
    def reversePairs(self, nums):
        def merge(nums, start, mid, end):
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[i])
            nums[start:start+len(tmp)] = tmp

        def countAndMergeSort(nums, start, end):
            if end - start <= 0:
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end)
            r = mid + 1
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r] * 2:
                    r += 1
                count += r - (mid + 1)
            merge(nums, start, mid, end)
            return count

        return countAndMergeSort(nums, 0, len(nums) - 1)",O(nlogn)
"class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        dist = float(""inf"")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"class Solution(object):
    def maxDepthAfterSplit(self, seq):
        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]",O(n)
"class Solution2(object):
    def maxDepthAfterSplit(self, seq):
        A, B = 0, 0
        result = [0]*len(seq)
        for i, c in enumerate(seq):
            point = 1 if c == '(' else -1
            if (point == 1 and A <= B) or \
               (point == -1 and A >= B):
                A += point
            else:
                B += point
                result[i] = 1
        return result",O(n)
"import random



class Solution(object):
    def maxSubsequence(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a > b)
        cnt = sum(partition[i] == partition[k-1] for i in range(k))
        result = []
        for x in nums:
            if x > partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt > 0:
                cnt -= 1
                result.append(x)
        return result",O(n)
"import collections



class Solution(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        lookup = {}
        def powmod(n, p):
            if (n, p) not in lookup:
                lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD 
            return lookup[n, p]

        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD
            if cnt[nums[i]]:
               curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD
            cnt[nums[i]] += 1
            curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"import collections



class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
            if cnt[nums[i]]:
               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD
            cnt[nums[i]] += 1
            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"import collections


class Solution(object):

    def __init__(self, v1, v2):
        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def __next__(self):
        len, iter = self.q.popleft()
        if len > 1:
            self.q.append((len-1, iter))
        return next(iter)

    def hasNext(self):
        return bool(self.q)",O(1)
"class Solution(object):
    def minSubarray(self, nums, p):
        residue = sum(nums) % p
        if not residue:
            return 0
        result = len(nums)
        curr, lookup = 0, {0: -1}
        for i, num in enumerate(nums):
            curr = (curr+num) % p
            lookup[curr] = i
            if (curr-residue) % p in lookup:
                result = min(result, i-lookup[(curr-residue)%p])
        return result if result < len(nums) else -1",O(n)
"
import pandas as pd



def Solution(customers: pd.DataFrame) -> pd.DataFrame:
    customers.drop_duplicates(subset=[""email""], keep=""first"", inplace=True)
    return customers
",O(n)
"class Solution(object):
    def minElements(self, nums, limit, goal):
        return (abs(sum(nums)-goal) + (limit-1))//limit",O(n)
"class Solution(object):
    def areSentencesSimilar(self, sentence1, sentence2):
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1
        count = 0
        for idx in (lambda x:x, lambda x:-1-x):
            for i in range(len(sentence1)+1):
                c1 = sentence1[idx(i)] if i != len(sentence1) else ' '
                c2 = sentence2[idx(i)] if i != len(sentence2) else ' '
                if c1 != c2:
                    break
                if c1 == ' ':
                    count += 1
        return count >= sentence1.count(' ')+1",O(n)
"import random



class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        for i in range(len(reward1)):
            reward1[i] -= reward2[i]
        nth_element(reward1, k-1, compare=lambda a, b: a > b)
        return sum(reward2)+sum(reward1[i] for i in range(k))",O(n)
"class Solution(object):
    def countPartitions(self, nums):
        result = left = 0
        right = sum(nums)
        for i in range(len(nums)-1):
            left += nums[i]
            right -= nums[i]
            if left%2 == right%2:
                result += 1
        return result",O(n)
"
import itertools



class Solution(object):
    def minCost(self, arr, brr, k):
        def cost():
            return sum(abs(x-y) for x, y in zip(arr, brr))

        result = cost()
        arr.sort()
        brr.sort()
        result = min(result, k+cost())
        return result
",O(nlogn)
"class Solution(object):
    def getSum(self, nums):
        MOD = 10**9+7
        def count(d):
            result = total = l = 0
            for i in range(len(nums)):
                l += 1
                total = (total+nums[i]*l)%MOD
                result = (result+total)%MOD
                if i+1 < len(nums) and nums[i+1]-nums[i] == d:
                    continue
                total = l = 0
            return result
    
        return (count(1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))",O(n)
"class Solution(object):

    def __init__(self, value, k):
        self.__value = value
        self.__k = k
        self.__cnt = 0

    def consec(self, num):
        if num == self.__value:
            self.__cnt += 1
        else:
            self.__cnt = 0
        return self.__cnt >= self.__k",O(1)
"class Solution(object):
    def findMinMoves(self, machines):
        total = sum(machines)
        if total % len(machines): return -1

        result, target, curr = 0, total / len(machines), 0
        for n in machines:
            curr += n - target
            result = max(result, max(n - target, abs(curr)))
        return result",O(n)
"class Solution(object):
    def smallestBeautifulString(self, s, k):
        def check(i):
            return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i])

        arr = [ord(x)-ord('a') for x in s]
        for i in reversed(range(len(arr))):
            arr[i] += 1
            while not check(i):
                arr[i] += 1
            if arr[i] < k:
                break
        else:
            return """"
        for j in range(i+1, len(arr)):
            arr[j] = 0
            while not check(j):
                arr[j] += 1
        return """".join([chr(ord('a')+x) for x in arr])",O(n)
"class Solution(object):
    def stoneGameVI(self, aliceValues, bobValues):
        sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)
        return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))",O(nlogn)
"class Solution(object):
    def minFlipsMonoIncr(self, S):
        flip0, flip1 = 0, 0
        for c in S:
            flip0 += int(c == '1')
            flip1 = min(flip0, flip1 + int(c == '0'))
        return flip1",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def heightOfTree(self, root):
        result = -1
        stk = [(root, 0)]
        while stk:
            u, d = stk.pop()
            result = max(result, d)
            if u.right and u.right.left != u:
                stk.append((u.right, d+1))
            if u.left and u.left.right != u:
                stk.append((u.left, d+1))
        return result",O(n)
"class Solution2(object):
    def heightOfTree(self, root):
        result = -1
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left and u.left.right != u:
                    new_q.append(u.left)
                if u.right and u.right.left != u:
                    new_q.append(u.right)
            q = new_q
            result += 1
        return result",O(n)
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, local_max = 0, 0
        for n in nums:
            local_max = (local_max + 1 if n else 0)
            result = max(result, local_max)
        return result",O(n)
"import math


class Solution(object):
    def minimumBoxes(self, n):
        h = int((6*n)**(1.0/3))  
        if h*(h+1)*(h+2) > 6*n:
            h -= 1
        n -= h*(h+1)*(h+2)//6
        d = int(math.ceil((-1+(1+8*n)**0.5)/2)) 
        return h*(h+1)//2 + d",O(1)
"import collections


class Solution(object):
    def countTriplets(self, arr):
        count_sum = collections.defaultdict(lambda: [0, 0])
        count_sum[0] = [1, 0]
        result, prefix = 0, 0
        for i, x in enumerate(arr):
            prefix ^= x
            c, t = count_sum[prefix]
            result += c*i - t
            count_sum[prefix] = [c+1, t+i+1]
        return result",O(n)
"class Solution(object):
    def maxAlternatingSum(self, nums):
        result = nums[0]
        for i in range(len(nums)-1):
            result += max(nums[i+1]-nums[i], 0)
        return result",O(n)
"

class Solution(object):
    def numberOfEmployeesWhoMetTarget(self, hours, target):
        return sum(x >= target for x in hours)
",O(n)
"class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):
        result, max_extra, extra = 0, 0, 0
        for i in range(len(customers)):
            result += 0 if grumpy[i] else customers[i]
            extra += customers[i] if grumpy[i] else 0
            if i >= X:
                extra -= customers[i-X] if grumpy[i-X] else 0
            max_extra = max(max_extra, extra)
        return result + max_extra",O(n)
"class Solution(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        if x > y:
            x, y = y, x
        diff = [0]*n
        for i in range(n):
            diff[0] += 1+1                                        
            diff[min(abs(i-x), abs(i-y)+1)] += 1                  
            diff[min(abs(i-y), abs(i-x)+1)] += 1                  
            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1         
            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1       
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1       
        for i in range(n-1):
            diff[i+1] += diff[i]
        return diff",O(n)
"class Solution2(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        result = [0]*n
        for i in range(n):
            for j in range(i+1, n):
                result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2
        return result",O(n ^ 2)
"class Solution(object):
    def findKDistantIndices(self, nums, key, k):
        result = []
        prev = -1
        for i, x in enumerate(nums):
            if x != key:
                continue
            for j in range(max(i-k, prev+1), min(i+k+1, len(nums))):
                result.append(j)
            prev = min(i+k, len(nums)-1)
        return result",other
"class Solution(object):
    def countSeniors(self, details):
        return sum(x[-4:-2] > ""60"" for x in details)",O(n)
"class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",O(n)
"class Solution(object):
    def maximumInvitations(self, favorite):
        def find_cycles(adj):
            result = []
            lookup = [False]*len(adj)
            for u in range(len(adj)):
                cnt = {}
                while not lookup[u]:
                    lookup[u] = True
                    cnt[u] = len(cnt)
                    u = adj[u]
                if u in cnt:
                    result.append((u, len(cnt)-cnt[u]))
            return result

        def bfs(adj, u, exclude):
            result = 0
            q = [u]
            while q:
                result += 1
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v == exclude:
                            continue
                        new_q.append(v)
                q = new_q
            return result
            
        inv_adj = [[] for _ in range(len(favorite))]  
        for u, v in enumerate(favorite):
            inv_adj[v].append(u)
        cycles = find_cycles(favorite)
        return max(max([l for _, l in cycles if l > 2] or [0]),
                   sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))",O(n)
"import collections


class Solution(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        q = collections.deque()
        left = [0]
        for i in range(len(s)):
            while q and q[0][1] < i:
                q.popleft()
            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))
            q.append((i, i+P[2*i+2]//2))
        q = collections.deque()
        result = right = 0
        for i in reversed(range(len(s))):
            while q and q[0][1] > i:
                q.popleft()
            right = max(right, 1+2*(q[0][0]-i) if q else 1)
            q.append((i, i-P[2*i+2]//2))
            result = max(result, left[i]*right)
        return result",O(n)
"class Solution2(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        import operator
        def accumulate(iterable, func=operator.add, initial=None):
            it = iter(iterable)
            total = initial
            if initial is None:
                try:
                    total = next(it)
                except StopIteration:
                    return
            yield total
            for element in it:
                total = func(total, element)
                yield total

        def fin_max_len(s):
            P = manacher(s)
            intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in range(2,len(P)-2, 2)]
            dp = [0]*len(s)
            for l, r in reversed(intervals): 
                dp[r] = r-l+1
            for i in reversed(range(len(s)-1)):
                dp[i] = max(dp[i], dp[i+1]-2)
            return list(accumulate(dp, max, 0))
        
        l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1]
        return max(x*y for x, y in zip(l1, l2))",O(n)
"class Solution(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing, n)
        return [q+int(i < r) for i in range(n)]",O(n)
"class Solution2(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))
        return [MAX_V if i < q else MIN_V+r if i == q else MIN_V  for i in range(n)]",O(n)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root in (None, p, q):
            return root

        left, right = [self.lowestCommonAncestor(child, p, q) \
                         for child in (root.left, root.right)]
        return root if left and right else left or right

",O(n)
"class Solution(object):
    def isMonotonic(self, A):
        inc, dec = False, False
        for i in range(len(A)-1):
            if A[i] < A[i+1]:
                inc = True
            elif A[i] > A[i+1]:
                dec = True
        return not inc or not dec",O(n)
"class Solution(object):
    def lengthOfLastWord(self, s):
        length = 0
        for i in reversed(s):
            if i == ' ':
                if length:
                    break
            else:
                length += 1
        return length",O(n)
"class Solution2(object):
    def lengthOfLastWord(self, s):
        return len(s.strip().split("" "")[-1])",O(n)
"class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result",O(n)
"import bisect


class Solution(object):
    def minimumMountainRemovals(self, nums):
        left_lis_len = [0]*len(nums)
        lis = []
        for i in range(len(nums)-1):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            left_lis_len[i] = j
        max_len = 0
        lis = []
        for i in reversed(range(1, len(nums))):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            if i < len(nums)-1:
                max_len = max(max_len, left_lis_len[i]+j)
        return len(nums) - (1+max_len)",O(nlogn)
"import itertools
import re


class Solution(object):
    def summaryRanges(self, nums):
        ranges = []
        if not nums:
            return ranges

        start, end = nums[0], nums[0]
        for i in range(1, len(nums) + 1):
            if i < len(nums) and nums[i] == end + 1:
                end = nums[i]
            else:
                interval = str(start)
                if start != end:
                    interval += ""->"" + str(end)
                ranges.append(interval)
                if i < len(nums):
                    start = end = nums[i]

        return ranges",O(n)
"class Solution2(object):
    def summaryRanges(self, nums):
        return [re.sub('->.*>', '->', '->'.join(repr(n) for _, n in g))
            for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1]-i_n[0])]",O(n)
"class ArrayReader(object):
    def query(self, a, b, c, d):
        pass

    def length(self):
        pass
    

class Solution(object):
    def guessMajority(self, reader):
        count_a, count_b, idx_b = 1, 0, None
        value_0_1_2_3 = reader.query(0, 1, 2, 3)
        for i in reversed(range(4, reader.length())):
            value_0_1_2_i = reader.query(0, 1, 2, i)
            if value_0_1_2_i == value_0_1_2_3: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        value_0_1_2_4 = value_0_1_2_i
        for i in range(3):
            value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])
            if value_a_b_3_4 == value_0_1_2_4: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        if count_a == count_b:
            return -1
        return 3 if count_a > count_b else idx_b",O(n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def middleNode(self, head):
        slow, fast = head, head
        while fast and fast.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        return slow

",O(n)
"class Solution(object):
    def isRobotBounded(self, instructions):
        directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]]
        x, y, i = 0, 0, 0
        for instruction in instructions:
            if instruction == 'R':
                i = (i+1) % 4
            elif instruction == 'L':
                i = (i-1) % 4
            else:
                x += directions[i][0]
                y += directions[i][1]
        return (x == 0 and y == 0) or i > 0",O(n)
"class Solution(object):
    def waysToSplitArray(self, nums):
        total = sum(nums)
        result = curr = 0
        for i in range(len(nums)-1):
            curr += nums[i]
            result += int(curr >= total-curr)
        return result",O(n)
"class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        left = [n]*n
        right = [-1]*n
        up = [-1]*n
        down = [n]*n
        for x, y in buildings:
            x -= 1
            y -= 1
            left[y] = min(left[y], x)
            right[y] = max(right[y], x)
            up[x] = max(up[x], y)
            down[x] = min(down[x], y) 
        return sum(left[y-1] < x-1 < right[y-1] and down[x-1] < y-1 < up[x-1] for x, y in buildings)",O(n)
"class Solution(object):
    def minCosts(self, cost):
        for i in range(1, len(cost)):
            cost[i] = min(cost[i], cost[i-1])
        return cost",O(n)
"class Solution(object):
    def dailyTemperatures(self, temperatures):
        result = [0] * len(temperatures)
        stk = []
        for i in range(len(temperatures)):
            while stk and \
                  temperatures[stk[-1]] < temperatures[i]:
                idx = stk.pop()
                result[idx] = i-idx
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def clearDigits(self, s):
        s = list(s)
        j = 0
        for i, x in enumerate(s):
            if x.isdigit():
                j -= 1
                continue
            s[j] = x
            j += 1
        while len(s) > j:
            s.pop()
        return """".join(s)",O(n)
"class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)",O(n)
"class Solution(object):
    def minInsertions(self, s):
        add, bal = 0, 0
        for c in s:
            if c == '(':
                if bal > 0 and bal%2:
                    add += 1
                    bal -= 1
                bal += 2
            else:
                bal -= 1
                if bal < 0:
                    add += 1
                    bal += 2
        return add + bal",O(n)
"import collections
from functools import reduce


class Solution(object):
    def longestDupSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]: 
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            return i-L+1
                lookup[curr].append(i)
            return 0

        left, right = 1, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        result = check(S, right)
        return S[result:result + right]",O(nlogn)
"class Solution(object):
    def escapeGhosts(self, ghosts, target):
        total = abs(target[0])+abs(target[1])
        return all(total < abs(target[0]-i)+abs(target[1]-j) for i, j in ghosts)",O(n)
"class Solution(object):
    def sortVowels(self, s):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        VOWELS = ""AEIOUaeiou""
        LOOKUP = {x:i for i, x in enumerate(VOWELS)}
        vowels = [LOOKUP[x] for x in s if x in LOOKUP]
        inplace_counting_sort(vowels, reverse=True)
        return """".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s)",O(n)
"class Solution2(object):
    def sortVowels(self, s):
        VOWELS = ""AEIOUaeiou""
        LOOKUP = set(VOWELS)
        vowels = [x for x in s if x in LOOKUP]
        vowels.sort(reverse=True)
        return """".join(vowels.pop() if x in LOOKUP else x for x in s)",O(nlogn)
"class Solution(object):
    def repeatedSubstringPattern(self, str):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(str)
        return prefix[-1] != -1 and \
               (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0

    def repeatedSubstringPattern2(self, str):
        if not str:
            return False

        ss = (str + str)[1:-1]
        return ss.find(str) != -1",O(n)
"class Solution(object):
    def integerReplacement(self, n):
        result = 0
        while n != 1:
            b = n & 3
            if n == 3:
                n -= 1
            elif b == 3:
                n += 1
            elif b == 1:
                n -= 1
            else:
                n /= 2
            result += 1

        return result",O(logn)
"class Solution2(object):
    def integerReplacement(self, n):
        if n < 4:
            return [0, 0, 1, 2][n]
        if n % 4 in (0, 2):
            return self.integerReplacement(n / 2) + 1
        elif n % 4 == 1:
            return self.integerReplacement((n - 1) / 4) + 3
        else:
            return self.integerReplacement((n + 1) / 4) + 3",O(logn)
"class Solution(object):
    def kthLuckyNumber(self, k):
        result = []
        k += 1
        while k != 1:
            result.append('7' if k&1 else '4')
            k >>= 1
        result.reverse()
        return """".join(result)",O(logn)
"class Solution2(object):
    def kthLuckyNumber(self, k):
        return bin(k+1)[3:].replace('1', '7').replace('0', '4')",O(logn)
"class Solution(object):
    def mostVisited(self, n, rounds):
        return list(range(rounds[0], rounds[-1]+1)) or \
               list(range(1, rounds[-1]+1)) + list(range(rounds[0], n+1))",O(n)
"class Solution(object):
    def superPow(self, a, b):
        def myPow(a, n, b):
            result = 1
            x = a % b
            while n:
                if n & 1:
                    result = result * x % b
                n >>= 1
                x = x * x % b
            return result % b

        result = 1
        for digit in b:
            result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337
        return result",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def averageOfSubtree(self, root):
        def iter_dfs(root):
            result = 0
            stk = [(1, (root, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0]*2, [0]*2
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = ret1[0]+ret2[0]+node.val
                    ret[1] = ret1[1]+ret2[1]+1
                    result += int(ret[0]//ret[1] == node.val)
            return result
        
        return iter_dfs(root)",O(n)
"class Solution2(object):
    def averageOfSubtree(self, root):
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]",O(n)
"class Solution(object):
    def permute(self, n, k):
        result = []
        cnt = [1]*n
        for i in range(len(cnt)-1):
            cnt[i+1] = min(cnt[i]*((i+2)//2), k)
        lookup = [False]*n
        for i in range(n):
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt[n-1-i]:
                    break
                k -= cnt[n-1-i]
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"class Solution2(object):
    def permute(self, n, k):
        result = []
        fact = [1]*(((n-1)+1)//2+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        lookup = [False]*n
        for i in range(n):
            cnt = fact[(n-1-i)//2]*fact[((n-1-i)+1)//2]
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt:
                    break
                k -= cnt
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"class Solution(object):
    def bestCoordinate(self, towers, radius):
        min_x = min(towers, key=lambda x:x[0])[0]
        max_x = max(towers, key=lambda x:x[0])[0]
        min_y = min(towers, key=lambda x:x[1])[1]
        max_y = max(towers, key=lambda x:x[1])[1]
        max_quality = 0
        for x in range(min_x, max_x+1):
            for y in range(min_y, max_y+1):
                q = 0
                for nx, ny, nq in towers:
                    d = ((nx-x)**2+(ny-y)**2)**0.5
                    if d <= radius:
                        q += int(nq/(1+d))
                if q > max_quality:
                    max_quality = q
                    result = x, y
        return result",other
"class Solution(object):
    def check(self, nums):
        count = 0
        for i in range(len(nums)):
            if nums[i] > nums[(i+1)%len(nums)]:
                count += 1
                if count > 1:
                    return False
        return True",O(n)
"import bisect


class Solution2(object):
    def smallerNumbersThanCurrent(self, nums):
        sorted_nums = sorted(nums)
        return [bisect.bisect_left(sorted_nums, i) for i in nums]",O(nlogn)
"class Solution(object):
    def longestContinuousSubstring(self, s):
        result = l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or ord(s[i])+1 != ord(s[i+1]):
                result = max(result, l)
                l = 0
        return result",O(n)
"import random



class Solution(object):
    def putMarbles(self, weights, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        for i in range(len(weights)-1):
            weights[i] += weights[i+1]
        weights.pop()
        result = 0
        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)
        result += sum(weights[i] for i in range(k-1))
        nth_element(weights, (k-1)-1)
        result -= sum(weights[i] for i in range(k-1))
        return result",O(n)
"class Solution(object):
    def mergeArrays(self, nums1, nums2):
        result = []
        i = j = 0
        while i < len(nums1) or j < len(nums2):
            if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]):
                if result and result[-1][0] == nums1[i][0]:
                    result[-1][1] += nums1[i][1]
                else:
                    result.append(nums1[i])
                i += 1
            else:
                if result and result[-1][0] == nums2[j][0]:
                    result[-1][1] += nums2[j][1]
                else:
                    result.append(nums2[j])
                j += 1
        return result",O(n)
"from random import randint

class Solution(object):

    def __init__(self):
        self.__set = []
        self.__used = {}


    def insert(self, val):
        if val in self.__used:
            return False

        self.__set += val,
        self.__used[val] = len(self.__set)-1

        return True


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__set[-1]] = self.__used[val]
        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]

        self.__used.pop(val)
        self.__set.pop()

        return True

    def getRandom(self):
        return self.__set[randint(0, len(self.__set)-1)]",O(1)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        s, b = sorted([p.val, q.val])
        while not s <= root.val <= b:
            root = root.left if s <= root.val else root.right
        return root

",O(n)
"start, end, height = 0, 1, 2
class Solution(object):
    def getSkyline(self, buildings):
        intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))

        res = []
        last_end = -1
        for interval in intervals:
            if last_end != -1 and last_end < interval[start]:
                res.append([last_end, 0])
            res.append([interval[start], interval[height]])
            last_end = interval[end]
        if last_end != -1:
            res.append([last_end, 0])

        return res

    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):
        if right_endpoint - left_endpoint <= 1:
            return buildings[left_endpoint:right_endpoint]
        mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)
        left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)
        right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint)
        return self.MergeSkylines(left_skyline, right_skyline)

    def MergeSkylines(self, left_skyline, right_skyline):
        i, j = 0, 0
        merged = []

        while i < len(left_skyline) and j < len(right_skyline):
            if left_skyline[i][end] < right_skyline[j][start]:
                merged.append(left_skyline[i])
                i += 1
            elif right_skyline[j][end] < left_skyline[i][start]:
                merged.append(right_skyline[j])
                j += 1
            elif left_skyline[i][start] <= right_skyline[j][start]:
                i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i,\
                                                   right_skyline[j], j)
            else:
                j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, \
                                                   left_skyline[i], i)

        merged += left_skyline[i:]
        merged += right_skyline[j:]
        return merged

    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):
        if a[end] <= b[end]:
            if a[height] > b[height]:  
                if b[end] != a[end]:   
                    b[start] = a[end]
                    merged.append(a)
                    a_idx += 1
                else:            
                    b_idx += 1   
            elif a[height] == b[height]: 
                b[start] = a[start]      
                a_idx += 1
            else: 
                if a[start] != b[start]:                           
                    merged.append([a[start], b[start], a[height]]) 
                a_idx += 1
        else: 
            if a[height] >= b[height]: 
                b_idx += 1             
            else:
                if a[start] != b[start]:
                    merged.append([a[start], b[start], a[height]])
                a[start] = b[end]
                merged.append(b)
                b_idx += 1
        return a_idx, b_idx",O(nlogn)
"

class Solution(object):
    def triangleType(self, nums):
        nums.sort()
        a, b, c = nums
        if a+b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c:
            return ""isosceles""
        return ""scalene""
",O(1)
"class Solution(object):
    def shiftingLetters(self, s, shifts):
        events = [0]*(len(s)+1)
        for b, e, d in shifts:
            events[b] += 1 if d else -1
            events[e+1] -= 1 if d else -1
        result = []
        curr = 0
        for i in range(len(s)):
            curr += events[i]
            result.append(chr(ord('a')+(ord(s[i])-ord('a')+curr)%26))
        return """".join(result)",O(n)
"import collections


class Solution(object):
    def findDuplicateSubtrees(self, root):
        def getid(root, lookup, trees):
            if not root:
                return -1
            node_id = lookup[root.val,
                             getid(root.left, lookup, trees),
                             getid(root.right, lookup, trees)]
            trees[node_id].append(root)
            return node_id

        trees = collections.defaultdict(list)
        lookup = collections.defaultdict()
        lookup.default_factory = lookup.__len__
        getid(root, lookup, trees)
        return [roots[0] for roots in trees.values() if len(roots) > 1]",O(n)
"class Solution(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    ret[:] = [1-is_prime(u+1), is_prime(u+1)]
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [0]*2
                    stk.append((3, (u, p, new_ret, ret, i)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, p, new_ret, ret, i = args
                    result += ret[0]*new_ret[1]+ret[1]*new_ret[0]
                    if is_prime(u+1):
                        ret[1] += new_ret[0]
                    else:
                        ret[0] += new_ret[0]
                        ret[1] += new_ret[1]
            return result

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def dfs(u, p):
            cnt = [1-is_prime(u+1), is_prime(u+1)]
            for v in adj[u]:
                if v == p:
                    continue
                new_cnt = dfs(v, u)
                result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0]
                if is_prime(u+1):
                    cnt[1] += new_cnt[0]
                else:
                    cnt[0] += new_cnt[0]
                    cnt[1] += new_cnt[1]
            return cnt

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n
        self.size = [1]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]


class Solution3(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        spf = linear_sieve_of_eratosthenes(n)
        uf = UnionFind(n)
        for u, v in edges:
            u, v = u-1, v-1
            if is_prime(u+1) == is_prime(v+1) == False:
                uf.union_set(u, v) 
        result = 0
        cnt = [1]*n
        for u, v in edges:
            u, v = u-1, v-1
            if is_prime(u+1) == is_prime(v+1):
                continue
            if not is_prime(u+1):
                u, v = v, u
            result += cnt[u]*uf.total(v)
            cnt[u] += uf.total(v)
        return result",other
"import itertools


class Solution(object):
    def numOfWays(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))]
                       for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[3, 2],
             [2, 2]]
        return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD",O(logn)
"class Solution2(object):
    def numOfWays(self, n):
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in range(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD",O(n)
"from collections import deque

class Solution(object):

    def __init__(self, width,height,food):
        self.__width = width
        self.__height = height
        self.__score = 0
        self.__f = 0
        self.__food = food
        self.__snake = deque([(0, 0)])
        self.__direction = {""U"": (-1, 0), ""L"": (0, -1), ""R"": (0, 1), ""D"": (1, 0)}
        self.__lookup = {(0, 0)}

    def move(self, direction):
        def valid(x, y):
            return 0 <= x < self.__height and \
                   0 <= y < self.__width and \
                   (x, y) not in self.__lookup
        d = self.__direction[direction]
        x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]
        self.__lookup.remove(self.__snake[0])
        tail = self.__snake.popleft()
        if not valid(x, y):
            return -1
        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):
            self.__score += 1
            self.__f += 1
            self.__snake.appendleft(tail)
            self.__lookup.add(tail)
        self.__snake.append((x, y))
        self.__lookup.add((x, y))
        return self.__score",O(1)
"class Solution(object):
    def numberOfMatches(self, n):
        return n-1",O(1)
"class Solution(object):
    def maxNumber(self, n):
        return (1<<(n.bit_length()-1))-1",O(1)
"class Solution(object):
    def mostWordsFound(self, sentences):
        return 1+max(s.count(' ') for s in sentences)",O(n)
"class Solution(object):
    def maxProfit(self, prices, fee):
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, hold+prices[i]-fee)
            hold = max(hold, cash-prices[i])
        return cash",O(n)
"class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result",O(n)
"class Solution(object):
    def maxValue(self, n, x):
        check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i])
        for i in range(len(n)):
            if check(i):
                break
        else:
            i = len(n)
        return n[:i] + str(x) + n[i:]",O(n)
"class Solution(object):
    def minimumCost(self, s):
        return sum(min(i+1, len(s)-(i+1)) for i in range(len(s)-1) if s[i] != s[i+1])",O(n)
"class Solution(object):
    def reformatDate(self, date):
        lookup = {""Jan"":1, ""Feb"":2, ""Mar"":3, ""Apr"":4,
                  ""May"":5, ""Jun"":6, ""Jul"":7, ""Aug"":8,
                  ""Sep"":9, ""Oct"":10, ""Nov"":11, ""Dec"":12}
        return ""{:04d}-{:02d}-{:02d}"".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))",O(1)
"class Solution(object):
    def isSumEqual(self, firstWord, secondWord, targetWord):
        def stoi(s):
            result = 0
            for c in s:
                result = result*10 + ord(c)-ord('a')
            return result
        
        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)",O(n)
"class Solution(object):
    def partitionArray(self, nums, k):
        nums.sort()
        result, prev = 1, 0
        for i in range(len(nums)):
            if nums[i]-nums[prev] <= k:
                continue
            prev = i
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def gardenNoAdj(self, N, paths):
        result = [0]*N
        G = [[] for i in range(N)]
        for x, y in paths:
            G[x-1].append(y-1)
            G[y-1].append(x-1)
        for i in range(N):
            result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()
        return result",O(n)
"class Solution(object):
    def distinctIntegers(self, n):
        return n-1 if n >= 2 else 1",O(1)
"class Solution(object):
    def minFlips(self, target):
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result",O(n)
"class Solution(object):
    def similarRGB(self, color):
        def rounding(color):
            q, r = divmod(int(color, 16), 17)
            if r > 8: q += 1
            return '{:02x}'.format(17*q)

        return 
                rounding(color[1:3]) + \
                rounding(color[3:5]) + \
                rounding(color[5:7])",O(1)
"import itertools


class Solution(object):
    def canConvertString(self, s, t, k):
        if len(s) != len(t):
            return False
        cnt = [0]*26
        for a, b in zip(s, t):
            diff = (ord(b)-ord(a)) % len(cnt)
            if diff != 0 and cnt[diff]*len(cnt) + diff > k:
                return False
            cnt[diff] += 1
        return True",O(n)
"class Solution(object):
    def removeDuplicates(self, S):
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return """".join(result)",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
class Solution(object):
    def reverseBetween(self, head, m, n):
        diff, dummy, cur = n - m + 1, ListNode(-1), head
        dummy.next = head

        last_unswapped = dummy
        while cur and m > 1:
            cur, last_unswapped, m = cur.__next__, cur, m - 1

        prev, first_swapped = last_unswapped,  cur
        while cur and diff > 0:
            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

        last_unswapped.next, first_swapped.next = prev, cur

        return dummy.__next__",O(n)
"class Solution(object):
    def numberOfWeeks(self, milestones):
        total, max_num = sum(milestones), max(milestones)
        other_total = (total-max_num)
        return other_total+min(other_total+1, max_num)",O(n)
"
class Solution(object):
    def uniqueMorseRepresentations(self, words):
        MORSE = ["".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."",
                 ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."",
                 ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"",
                 ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""]

        lookup = {"""".join(MORSE[ord(c) - ord('a')] for c in word) \
                  for word in words}
        return len(lookup)

",O(n)
"class Solution(object):
    def validateBinaryTreeNodes(self, n, leftChild, rightChild):
        roots = set(range(n)) - set(leftChild) - set(rightChild)
        if len(roots) != 1:
            return False
        root, = roots
        stk = [root]
        lookup = set([root])
        while stk:
            node = stk.pop()
            for c in (leftChild[node], rightChild[node]):
                if c < 0:
                    continue
                if c in lookup:
                    return False
                lookup.add(c)
                stk.append(c)
        return len(lookup) == n",O(n)
"class Solution(object):
    def maximumUniqueSubarray(self, nums):
        lookup = {}
        prefix = [0]*(len(nums)+1)
        result, left = 0, 0
        for right, num in enumerate(nums):
            prefix[right+1] = prefix[right]+num
            if num in lookup:
                left = max(left, lookup[num]+1)
            lookup[num] = right
            result = max(result, prefix[right+1]-prefix[left])
        return result",O(n)
"import collections



class Solution(object):
    def distance(self, nums):
        result = [0]*len(nums)
        cnt1, left = collections.Counter(), collections.Counter()
        for i in range(len(nums)):
            result[i] += cnt1[nums[i]]*i-left[nums[i]]
            cnt1[nums[i]] += 1
            left[nums[i]] += i
        cnt2, right = collections.Counter(), collections.Counter()
        for i in reversed(range(len(nums))):
            result[i] += right[nums[i]]-cnt2[nums[i]]*i
            cnt2[nums[i]] += 1
            right[nums[i]] += i
        return result",O(n)
"class Solution(object):
    def minOperations(self, nums):
        return sum(nums[i] != nums[i+1] for i in range(len(nums)-1))",O(n)
"class Solution(object):
    def lengthLongestPath(self, input):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]


        max_len = 0
        path_len = {0: 0}
        for line in split_iter(input, '\n'):
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            if '.' in name:
                max_len = max(max_len, path_len[depth] + len(name))
            else:
                path_len[depth + 1] = path_len[depth] + len(name) + 1
        return max_len",O(n)
"
class Solution(object):
    def spellchecker(self, wordlist, queries):
        vowels = set(['a', 'e', 'i', 'o', 'u'])
        def todev(word):
            return """".join('*' if c.lower() in vowels else c.lower()
                           for c in word)

        words = set(wordlist)
        caps = {}
        vows = {}

        for word in wordlist:
            caps.setdefault(word.lower(), word)
            vows.setdefault(todev(word), word)

        def check(query):
            if query in words:
                return query
            lower = query.lower()
            if lower in caps:
                return caps[lower]
            devow = todev(lower)
            if devow in vows:
                return vows[devow]
            return """"
        return list(map(check, queries))
",O(n)
"class Solution(object):
    def isCircularSentence(self, sentence):
        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in range(len(sentence)) if sentence[i] == ' ')",O(n)
"class Solution(object):
    def removeComments(self, source):
        in_block = False
        result, newline = [], []
        for line in source:
            i = 0
            while i < len(line):
                if not in_block and i+1 < len(line) and line[i:i+2] == '/*':
                    in_block = True
                    i += 1
                elif in_block and i+1 < len(line) and line[i:i+2] == '*/':
                    in_block = False
                    i += 1
                elif not in_block and i+1 < len(line) and line[i:i+2] == '//':
                    break
                elif not in_block:
                    newline.append(line[i])
                i += 1
            if newline and not in_block:
                result.append("""".join(newline))
                newline = []
        return result",O(n)
"def strongly_connected_components(adj): 
    def strongconnect(v):
        index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack_set[v] = True
        stack.append(v)
        for w in adj[v]:
            if index[w] == -1:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif stack_set[w]:
                lowlinks[v] = min(lowlinks[v], index[w])
        if lowlinks[v] == index[v]:
            connected_component = []
            w = None
            while w != v:
                w = stack.pop()
                stack_set[w] = False
                connected_component.append(w)
            result.append(connected_component)

    index_counter, index, lowlinks = [0], [-1]*len(adj), [-1]*len(adj)
    stack, stack_set = [], [False]*len(adj)
    result = []
    for v in range(len(adj)):
        if index[v] == -1:
            strongconnect(v)
    return result


class Solution(object):
    def minRunesToAdd(self, n, crystals, flowFrom, flowTo):
        adj = [[] for _ in range(n)]
        for i in range(len(flowFrom)):
            adj[flowFrom[i]].append(flowTo[i])
        lookup = [-1]*n
        sccs = strongly_connected_components(adj)
        for i, scc in enumerate(sccs):
            for x in scc:
                lookup[x] = i
        result = [False]*len(sccs)
        for u in range(n):
            for v in adj[u]:
                if lookup[v] != lookup[u]:
                    result[lookup[v]] = True
        for x in crystals:
            result[lookup[x]] = True
        return sum(not x for x in result)",O(n)
"import random


class Solution(object):

    def __init__(self, nums):
        self.__nums = nums


    def reset(self):
        return self.__nums


    def shuffle(self):
        nums = list(self.__nums)
        for i in range(len(nums)):
            j = random.randint(i, len(nums)-1)
            nums[i], nums[j] = nums[j], nums[i]
        return nums",O(n)
"class Solution(object):
    def maxPotholes(self, road, budget):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        inplace_counting_sort(ls)
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(n)
"class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(nlogn)
"import collections
import functools



class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        pass



class Solution(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val
    
        def morris_inorder_traversal(root, cb):
            curr = root
            while curr:
                if curr.left is None:
                    cb(curr.val)
                    curr = curr.right
                else:
                    node = curr.left
                    while node.right and node.right != curr:
                        node = node.right
                    if node.right is None:
                        node.right = curr
                        curr = curr.left
                    else:
                        cb(curr.val)
                        node.right = None
                        curr = curr.right

        counter = collections.defaultdict(int)
        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val

        def inorder_traversal(root, cb):
            def traverseLeft(node, stk):
                while node:
                    stk.append(node)
                    node = node.left 

            stk = []
            traverseLeft(root, stk)
            while stk:
                curr = stk.pop()
                cb(curr.val)
                traverseLeft(curr.right, stk)
                
        counter = collections.defaultdict(int)
        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        s2t, t2s = {}, {}
        for p, w in zip(s, t):
            if w not in s2t and p not in t2s:
                s2t[w] = p
                t2s[p] = w
            elif w not in s2t or s2t[w] != p:
                return False
        return True",O(n)
"class Solution2(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        return self.halfIsom(s, t) and self.halfIsom(t, s)

    def halfIsom(self, s, t):
        lookup = {}
        for i in range(len(s)):
            if s[i] not in lookup:
                lookup[s[i]] = t[i]
            elif lookup[s[i]] != t[i]:
                return False
        return True",O(n)
"class Solution(object):
    def numFactoredBinaryTrees(self, A):
        M = 10**9 + 7
        A.sort()
        dp = {}
        for i in range(len(A)):
            dp[A[i]] = 1
            for j in range(i):
                if A[i] % A[j] == 0 and A[i] // A[j] in dp:
                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]
                    dp[A[i]] %= M
        return sum(dp.values()) % M",O(n ^ 2)
"
class Solution(object):
    def isPalindrome(self, head):
        reverse, fast = None, head
        while fast and fast.__next__:
            fast = fast.next.__next__
            head.next, reverse, head = reverse, head, head.next

        tail = head.__next__ if fast else head

        is_palindrome = True
        while reverse:
            is_palindrome = is_palindrome and reverse.val == tail.val
            reverse.next, head, reverse = head, reverse, reverse.next
            tail = tail.__next__

        return is_palindrome

",O(n)
"
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup:
                lookup[num] = i
            else:
                if i - lookup[num] <= k:
                    return True
                lookup[num] = i
        return False

",O(n)
"class Solution(object):
    def minFallingPathSum(self, A):
        for i in range(1, len(A)):
            for j in range(len(A[i])):
                A[i][j] += min(A[i-1][max(j-1, 0):j+2])
        return min(A[-1])",O(n ^ 2)
"from sortedcontainers import SortedList



class Solution(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = [0]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            right[i] = max(right[i+1], nums[i+1])
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[i] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[i])
        return result",O(nlogn)
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = SortedList(nums[i] for i in range(1, len(nums)))
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            right.remove(nums[i])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[-1] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[-1])
        return result",O(nlogn)
"class Solution(object):
    def numRescueBoats(self, people, limit):
        people.sort()
        result = 0
        left, right = 0, len(people)-1
        while left <= right:
            result += 1
            if people[left] + people[right] <= limit:
                left += 1
            right -= 1
        return result",O(nlogn)
"class Solution(object):
    def minOperations(self, s1, s2, x):
        parity = curr = prev = 0
        j = -1
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(""inf"")), curr
            j = i
            parity ^= 1
        return curr//2 if parity == 0 else -1",O(n)
"class Solution(object):
    def arraySign(self, nums):
        flag = 0
        for x in nums:
            if not x:
                return 0
            if x < 0:
                flag ^= 1
        return -1 if flag else 1",O(n)
"class Solution(object):
    def rob(self, nums):
        last, now = 0, 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now",O(n)
"import itertools



class Solution(object):
    def makeSimilar(self, nums, target):
        nums.sort(key=lambda x: (x%2, x))
        target.sort(key=lambda x: (x%2, x))
        return sum(abs(x-y)//2 for x, y in zip(nums, target))//2",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def sumNumbers(self, root):
        return self.sumNumbersRecu(root, 0)

    def sumNumbersRecu(self, root, num):
        if root is None:
            return 0

        if root.left is None and root.right is None:
            return num * 10 + root.val

        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)",O(n)
"class Solution(object):
    def deleteAndEarn(self, nums):
        vals = [0] * 10001
        for num in nums:
            vals[num] += num
        val_i, val_i_1 = vals[0], 0
        for i in range(1, len(vals)):
            val_i_1, val_i_2 = val_i, val_i_1
            val_i = max(vals[i] + val_i_2, val_i_1)
        return val_i",O(n)
"class Solution(object):
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1

        for i, integer in enumerate(A):
            if integer != i + 1:
                return i + 1
        return len(A) + 1",O(n)
"class Solution(object):
    def splitArray(self, nums):
        if len(nums) < 7:
            return False

        accumulated_sum = [0] * len(nums)
        accumulated_sum[0] = nums[0]
        for i in range(1, len(nums)):
            accumulated_sum[i] = accumulated_sum[i-1] + nums[i]
        for j in range(3, len(nums)-3):
            lookup = set()
            for i in range(1, j-1):
                if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]:
                    lookup.add(accumulated_sum[i-1])
            for k in range(j+2, len(nums)-1):
                if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and \
                   accumulated_sum[k - 1] - accumulated_sum[j] in lookup:
                    return True
        return False",O(n ^ 2)
"class Solution(object):
    def brokenCalc(self, X, Y):
        result = 0
        while X < Y:
            if Y%2:
                Y += 1
            else:
                Y /= 2
            result += 1
        return result + X-Y",O(logn)
"class Solution(object):
    def maximumValueSum(self, nums, k, edges):
        result = parity = 0
        diff = float(""inf"")
        for x in nums:
            y = x^k
            result += max(x, y)
            parity ^= int(x < y)
            diff = min(diff, abs(x-y))
        return result-parity*diff",O(n)
"class Solution(object):
    def findIndices(self, nums, indexDifference, valueDifference):
        mx_i = mn_i = 0
        for i in range(len(nums)-indexDifference):
            if nums[i] > nums[mx_i]:
                mx_i = i
            elif nums[i] < nums[mn_i]:
                mn_i = i
            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:
                return [mx_i, i+indexDifference]
            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:
                return [mn_i, i+indexDifference]
        return [-1]*2",O(n)
"class Solution(object):
    def countDigits(self, num):
        result = 0
        curr = num
        while curr:
            result += int(num%(curr%10) == 0)
            curr //= 10
        return result",O(logn)
"class Solution(object):
    def numberOfDays(self, Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)",O(1)
"class Solution(object):
    def isReachableAtTime(self, sx, sy, fx, fy, t):
        diff1, diff2 = abs(sx-fx), abs(sy-fy)
        mn = min(diff1, diff2)+abs(diff1-diff2)
        return t >= mn if mn else t != 1",O(1)
"class Solution(object):
    def maximumBeauty(self, nums, k):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] > k*2:
                left += 1
        return right-left+1",O(nlogn)
"
import collections


class Solution(object):
    def anagramMappings(self, A, B):
        lookup = collections.defaultdict(collections.deque)
        for i, n in enumerate(B):
            lookup[n].append(i)
        result = []
        for n in A:
            result.append(lookup[n].popleft())
        return result

",O(n)
"class Solution(object):
    def maximumOr(self, nums, k):
        right = [0]*(len(nums)+1)
        for i in reversed(range(len(nums))):
            right[i] = right[i+1]|nums[i]
        result = left = 0
        for i in range(len(nums)):
            result = max(result, left|(nums[i]<<k)|right[i+1])
            left |= nums[i]
        return result",O(n)
"class Solution(object):
    def longestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            T = ['^']
            for c in s:
                T +=  [
            T += [
            return T

        T = preProcess(s)
        P = [0] * len(T)
        center, right = 0, 0
        for i in range(1, len(T) - 1):
            i_mirror = 2 * center - i
            if right > i:
                P[i] = min(right - i, P[i_mirror])
            else:
                P[i] = 0

            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1

            if i + P[i] > right:
                center, right = i, i + P[i]

        max_i = 0
        for i in range(1, len(T) - 1):
            if P[i] > P[max_i]:
                max_i = i
        start = (max_i - 1 - P[max_i]) // 2
        return s[start : start + P[max_i]]",O(n)
"class Solution2(object):
    def longestPalindrome(self, s):
        def expand(s, left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return (right-left+1)-2
        
        left, right = -1, -2
        for i in range(len(s)):
            l = max(expand(s, i, i), expand(s, i, i+1))
            if l > right-left+1:
                right = i+l//2
                left = right-l+1
        return s[left:right+1] if left >= 0 else """"",O(n ^ 2)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.rename(columns={
        ""id"" : ""student_id"",
        ""first"" : ""first_name"",
        ""last"" : ""last_name"",
        ""age"" : ""age_in_years"",
    })
",O(n)
"class Solution(object):
    def subtractProductAndSum(self, n):
        product, total = 1, 0
        while n:
            n, r = divmod(n, 10)
            product *= r
            total += r
        return product-total",O(logn)
"import operator
from functools import reduce


class Solution2(object):
    def subtractProductAndSum(self, n):
        A = list(map(int, str(n)))
        return reduce(operator.mul, A) - sum(A)",O(logn)
"class Solution(object):
    def countHighestScoreNodes(self, parents):
        def iter_dfs(adj):
            result = [0]*2
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    i, ret = args
                    cnts = [[0] for _ in range(len(adj[i]))]
                    stk.append((2, (cnts, ret)))
                    for j, child in enumerate(adj[i]):
                        stk.append((1, (child, cnts[j])))
                elif step == 2:
                    cnts, ret = args
                    ret[0] = sum(cnt[0] for cnt in cnts)+1
                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)
                    if score > result[0]:
                        result[:] = [score, 1]
                    elif score == result[0]:
                        result[1] += 1
            return result[1]

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        return iter_dfs(adj)",O(n)
"class Solution2(object):
    def countHighestScoreNodes(self, parents):
        def dfs(adj, i, result):
            cnts = [dfs(adj, child, result) for child in adj[i]]
            total = sum(cnts)+1
            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)
            if score > result[0]:
                result[:] = [score, 1]
            elif score == result[0]:
                result[1] += 1
            return total

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        result = [0]*2
        dfs(adj, 0, result)
        return result[1]",O(n)
"class Solution(object):
    def minimumAverage(self, nums):
        nums.sort()
        return min((nums[i]+nums[~i])/2.0 for i in range(len(nums)//2))",O(nlogn)
"import collections


class Solution(object):
    def replaceWords(self, dictionary, sentence):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in dictionary:
            reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        def replace(word):
            curr = trie
            for i, c in enumerate(word):
                if c not in curr:
                    break
                curr = curr[c]
                if ""_end"" in curr:
                    return word[:i+1]
            return word

        return "" "".join(map(replace, sentence.split()))",O(n)
"class Solution(object):
    def kConcatenationMaxSum(self, arr, k):
        def max_sub_k_array(arr, k):
            result, curr = float(""-inf""), float(""-inf"")
            for _ in range(k):
                for x in arr:
                    curr = max(curr+x, x)
                    result = max(result, curr)
            return result
        
        MOD = 10**9+7
        if k == 1:
            return max(max_sub_k_array(arr, 1), 0) % MOD
        return (max(max_sub_k_array(arr, 2), 0) + (k-2)*max(sum(arr), 0)) % MOD",other
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def equalToDescendants(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if node.val == ret1[0]+ret2[0]:
                        result += 1
                    ret[0] = ret1[0]+ret2[0]+node.val
            return result

        return iter_dfs(root)",O(n)
"class Solution2(object):
    def equalToDescendants(self, root):
        def dfs(node, result):
            if not node:
                return 0
            total = dfs(node.left, result) + dfs(node.right, result)
            if node.val == total:
                result[0] += 1
            return total+node.val

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"
class Solution(object):
    def trimBST(self, root, L, R):
        if not root:
            return None
        if root.val < L:
            return self.trimBST(root.right, L, R)
        if root.val > R:
            return self.trimBST(root.left, L, R)
        root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R)
        return root


",O(n)
"class Solution(object):
    def maximumJumps(self, nums, target):
        dp = [-1]*len(nums)
        dp[0] = 0
        for i in range(1, len(nums)):
            for j in range(i):
                if abs(nums[i]-nums[j]) <= target:
                    if dp[j] != -1:
                        dp[i] = max(dp[i], dp[j]+1)
        return dp[-1]",O(n ^ 2)
"import collections


class Solution(object):
    def balancedString(self, s):
        count = collections.Counter(s)
        result = len(s) 
        left = 0
        for right in range(len(s)):
            count[s[right]] -= 1
            while left < len(s) and \
                  all(v <= len(s)//4 for v in count.values()):
                result = min(result, right-left+1)
                count[s[left]] += 1
                left += 1
        return result",O(n)
"import collections



class Solution2(object):
    def minimumLength(self, s):
        return sum(2-x%2 for x in collections.Counter(s).values())",O(n)
"import collections



class Solution(object):
    def beautifulSubarrays(self, nums):
        cnt = collections.Counter()
        cnt[0] = 1
        result = curr = 0
        for x in nums:
            curr ^= x
            result += cnt[curr]
            cnt[curr] += 1
        return result",O(n)
"class Solution(object):
    def minSumOfLengths(self, arr, target):
        prefix, dp = {0: -1}, [0]*len(arr) 
        result = min_len = float(""inf"")
        accu = 0
        for right in range(len(arr)):
            accu += arr[right]
            prefix[accu] = right
            if accu-target in prefix:
                left = prefix[accu-target]
                min_len = min(min_len, right-left)
                if left != -1:
                    result = min(result, dp[left] + (right-left))
            dp[right] = min_len
        return result if result != float(""inf"") else -1",O(n)
"
class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        max_num = max(candies)
        return [x + extraCandies >= max_num for x in candies]
",O(n)
"class Solution(object):
    def countSubarrays(self, nums):
        return sum((nums[i-1]+nums[i+1])*2 == nums[i] for i in range(1, len(nums)-1))",O(n)
"class Solution(object):
    def sumOfGoodNumbers(self, nums, k):
        return sum(nums[i] for i in range(len(nums)) if (i-k < 0 or nums[i-k] < nums[i]) and (i+k >= len(nums) or nums[i+k] < nums[i]))",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isValidBST(self, root):
        prev, cur = None, root
        while cur:
            if cur.left is None:
                if prev and prev.val >= cur.val:
                    return False
                prev = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    if prev and prev.val >= cur.val:
                        return False
                    node.right = None
                    prev = cur
                    cur = cur.right

        return True


",O(n)
"class Solution2(object):
    def isValidBST(self, root):
        return self.isValidBSTRecu(root, float(""-inf""), float(""inf""))

    def isValidBSTRecu(self, root, low, high):
        if root is None:
            return True

        return low < root.val and root.val < high \
            and self.isValidBSTRecu(root.left, low, root.val) \
            and self.isValidBSTRecu(root.right, root.val, high)",O(n)
"class Solution(object):
    def maximumProcessableQueries(self, nums, queries):
        dp = [[float(""-inf"")]*len(nums) for _ in range(len(nums))]
        dp[0][-1] = 0
        for l in reversed(range(1, len(nums))):
            for i in range(len(nums)-(l-1)):
                j = i+(l-1)
                if i-1 >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0))
                if j+1 < len(nums):
                    dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0))
                if dp[i][j] == len(queries):
                    return len(queries)
        return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in range(len(nums)))",O(n ^ 2)
"class Solution(object):
    def baseNeg2(self, N):
        result = []
        while N:
            result.append(str(-N & 1)) 
            N = -(N >> 1) 
        result.reverse()
        return """".join(result) if result else ""0""",O(logn)
"class Solution2(object):
    def baseNeg2(self, N):
        BASE = -2
        result = []
        while N:
            N, r = divmod(N, BASE)
            if r < 0:
                r -= BASE
                N += 1
            result.append(str(r))
        result.reverse()
        return """".join(result) if result else ""0""",O(logn)
"import collections



class Solution(object):
    def mostFrequent(self, nums, key):
        return collections.Counter(nums[i+1] for i in range(len(nums)-1) if nums[i] == key).most_common(1)[0][0]",O(n)
"import collections


class Solution(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atLeastK(word, k):
            cnt = collections.Counter()
            result = left = right = 0
            for i, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right = i+1
                    continue
                cnt[c] += 1
                while len(cnt) > k-1:
                    cnt[word[right]] -= 1
                    if not cnt[word[right]]:
                        del cnt[word[right]]
                    right += 1
                result += right-left
            return result

        return atLeastK(word, k)",O(n)
"import collections


class Solution2(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atMostK(word, k):
            cnt = collections.Counter()
            result = left = 0
            for right, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right+1
                    continue
                cnt[c] += 1
                while len(cnt) > k:
                    cnt[word[left]] -=1
                    if not cnt[word[left]]:
                        del cnt[word[left]]
                    left += 1
                result += right-left+1
            return result

        return atMostK(word, k) - atMostK(word, k-1)",O(n)
"import collections


class Solution(object):
    def snakesAndLadders(self, board):
        def coordinate(n, s):
            a, b = divmod(s-1, n)
            r = n-1-a
            c = b if r%2 != n%2 else n-1-b
            return r, c

        n = len(board)
        lookup = {1: 0}
        q = collections.deque([1])
        while q:
            s = q.popleft()
            if s == n*n:
                return lookup[s]
            for s2 in range(s+1, min(s+6, n*n)+1):
                r, c = coordinate(n, s2)
                if board[r][c] != -1:
                    s2 = board[r][c]
                if s2 not in lookup:
                    lookup[s2] = lookup[s]+1
                    q.append(s2)
        return -1",O(n ^ 2)
"class Solution(object):
    def minStartValue(self, nums):
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix",O(n)
"class Solution(object):
    def decodeAtIndex(self, S, K):
        i = 0
        for c in S:
            if c.isdigit():
                i *= int(c)
            else:
                i += 1

        for c in reversed(S):
            K %= i
            if K == 0 and c.isalpha():
                return c

            if c.isdigit():
                i /= int(c)
            else:
                i -= 1",O(n)
"class Solution(object):
    def maximumOddBinaryNumber(self, s):
        a = list(s)
        left = 0
        for i in range(len(a)):
            if a[i] != '1':
                continue
            a[i], a[left] = a[left], a[i]
            left += 1
        if a[-1] != '1':
            a[-1], a[left-1] = a[left-1], a[-1]
        return """".join(a)",O(n)
"class Solution2(object):
    def maximumOddBinaryNumber(self, s):
        n = s.count('1')
        return """".join(['1']*(n-1)+['0']*(len(s)-n)+['1'])",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"class Solution(object):
    def hasSameDigits(self, s):
        def check(mod):
            def decompose(x, mod): 
                cnt = 0
                while x > 1 and x%mod == 0:
                    x //= mod
                    cnt += 1
                return x, cnt

            result = cnt = 0
            curr = 1
            for i in range(len(s)-1):
                if cnt == 0:
                    result = (result+curr*(ord(s[i])-ord(s[i+1])))%mod
                x, c = decompose(len(s)-2-i, mod)
                curr = (curr*x)%mod
                cnt += c
                x, c = decompose(i+1, mod)
                curr = (curr*pow(x, mod-2, mod))%mod
                cnt -= c
            return result == 0

        return check(2) and check(5)",O(nlogn)
"LOOKUP = [[-1]*(5+1) for _ in range(5+1)]



class Solution2(object):
    def hasSameDigits(self, s):
        def nCr(n, r):
            if n-r < r:
                r = n-r
            if LOOKUP[n][r] == -1:
                c = 1
                for k in range(1, r+1):
                    c *= n-k+1
                    c //= k
                LOOKUP[n][r] = c
            return LOOKUP[n][r]

        def nCr_mod(n, r, mod):
            result = 1
            while n > 0 or r > 0:
                n, ni = divmod(n, mod)
                r, ri = divmod(r, mod)
                if ni < ri:
                    return 0
                result = (result*nCr(ni, ri))%mod
            return result

        def nC10(n, k):
            return lookup[nCr_mod(n, k, 2)][nCr_mod(n, k, 5)]

        lookup = [[0]*5 for _ in range(2)]
        for i in range(10):
            lookup[i%2][i%5] = i
        total = 0
        for i in range(len(s)-1):
            total = (total+nC10(len(s)-2, i)*(ord(s[i])-ord(s[i+1])))%10
        return total == 0",other
"class Solution3(object):
    def hasSameDigits(self, s):
        s = list(map(int, s))
        for l in reversed(range(3, len(s)+1)):
            for i in range(l-1):
                s[i] = (s[i]+s[i+1])%10
        return s[0] == s[1]",O(n ^ 2)
"class Solution(object):
    def minInsertions(self, s):
        def longestCommonSubsequence(text1, text2):
            if len(text1) < len(text2):
                return self.longestCommonSubsequence(text2, text1)
            dp = [[0 for _ in range(len(text2)+1)] for _ in range(2)]
            for i in range(1, len(text1)+1):
                for j in range(1, len(text2)+1):
                    dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                                 else max(dp[(i-1)%2][j], dp[i%2][j-1])
            return dp[len(text1)%2][len(text2)]

        return len(s)-longestCommonSubsequence(s, s[::-1])",O(n ^ 2)
"class Solution(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = 0
        result = []
        while i < len(s):
            if i+2 < len(s) and s[i+2] == 
                result.append(alpha(s[i:i+2]))
                i += 3
            else:
                result.append(alpha(s[i]))
                i += 1
        return """".join(result)",O(n)
"class Solution2(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = len(s)-1
        result = []
        while i >= 0:
            if s[i] == 
                result.append(alpha(s[i-2:i]))
                i -= 3
            else:
                result.append(alpha(s[i]))
                i -= 1
        return """".join(reversed(result))",O(n)
"import re



class Solution3(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        return """".join(alpha(i[:2]) for i in re.findall(r""\d\",O(n)
"import random



class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        l = gcd(k, len(arr))
        result = 0
        for i in range(l):
            vals = [arr[j] for j in range(i, len(arr), l)]
            nth_element(vals, len(vals)//2)
            result += sum(abs(v-vals[len(vals)//2]) for v in vals)
        return result",O(n)
"class Solution(object):
    def maxProductDifference(self, nums):
        largest, smallest = [0]*2, [float(""inf"")]*2
        for x in nums:
            if x >= largest[0]:
                largest[:] = [x, largest[0]]
            elif x > largest[1]:
                largest[1] =x
            if x <= smallest[0]:
                smallest[:] = [x, smallest[0]]
            elif x < smallest[1]:
                smallest[1] = x
        return largest[0]*largest[1] - smallest[0]*smallest[1]",O(n)
"class Solution(object):
    def countDistinctStrings(self, s, k):
        MOD = 10**9+7
        return pow(2, len(s)-k+1, MOD)",O(logn)
"class Solution(object):
    def countSubarrays(self, nums):
        result = l = 1
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]:
                l = 0
            l += 1
            result += l
        return result",O(n)
"class Solution2(object):
    def countSubarrays(self, nums):
        result = left = 0
        for right in range(len(nums)):
            if not (right-1 >= 0 and nums[right-1] < nums[right]):
                left = right
            result += right-left+1
        return result",O(n)
"class Solution(object):
    def numSubarrayBoundedMax(self, A, L, R):
        def count(A, bound):
            result, curr = 0, 0
            for i in A :
                curr = curr + 1 if i <= bound else 0
                result += curr
            return result

        return count(A, R) - count(A, L-1)",O(n)
"class Solution(object):
    def generateMatrix(self, n):
        matrix = [[0 for _ in range(n)] for _ in range(n)]

        left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1

        while left <= right and top <= bottom:
            for j in range(left, right + 1):
                matrix[top][j] = num
                num += 1
            for i in range(top + 1, bottom):
                matrix[i][right] = num
                num += 1
            for j in reversed(range(left, right + 1)):
                if top < bottom:
                    matrix[bottom][j] = num
                    num += 1
            for i in reversed(range(top + 1, bottom)):
                if left < right:
                    matrix[i][left] = num
                    num += 1
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

        return matrix",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def isSameTree(self, p, q):
        if p is None and q is None:
            return True

        if p is not None and q is not None:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

        return False

",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y
        }
        
        def iter_dfs(root):
            ret = [0]
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if node.left == node.right:
                        ret[0] = node.val
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = OP[node.val](ret1[0], ret2[0])
            return ret[0]

        return iter_dfs(root)",O(n)
"class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)",O(n)
"class Solution(object):
    def evaluate(self, expression):
        def getval(lookup, x):
            return lookup.get(x, x)

        def evaluate(tokens, lookup):
            if tokens[0] in ('add', 'mult'):
                a, b = list(map(int, [getval(lookup, x) for x in tokens[1:]]))
                return str(a+b if tokens[0] == 'add' else a*b)
            for i in range(1, len(tokens)-1, 2):
                if tokens[i+1]:
                    lookup[tokens[i]] = getval(lookup, tokens[i+1])
            return getval(lookup, tokens[-1])

        tokens, lookup, stk = [''], {}, []
        for c in expression:
            if c == '(':
                if tokens[0] == 'let':
                    evaluate(tokens, lookup)
                stk.append((tokens, dict(lookup)))
                tokens =  ['']
            elif c == ' ':
                tokens.append('')
            elif c == ')':
                val = evaluate(tokens, lookup)
                tokens, lookup = stk.pop()
                tokens[-1] += val
            else:
                tokens[-1] += c
        return int(tokens[0])",other
"class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))",O(n)
"class Solution(object):
    def sumOfPower(self, nums):
        MOD = 10**9+7
        nums.sort()
        result = dp = 0
        for x in nums:
            result = (result+(x**2)*(dp+x))%MOD
            dp = (dp+(dp+x))%MOD
        return result",O(nlogn)
"class Solution(object):
    def minOperations(self, n):
        return (n//2)*((n+1)//2)",O(1)
"class Solution(object):
    def collectTheCoins(self, coins, edges):
        DISTANCE = 2

        adj = [set() for _ in range(len(coins))]
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        n = len(coins)
        q = []
        for u in range(len(coins)):
            while len(adj[u]) == 1 and not coins[u]:
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                u = v
        q = [u for u in range(len(coins)) if len(adj[u]) == 1]
        for _ in range(DISTANCE):
            new_q = []
            for u in q:
                if not adj[u]:
                    assert(n == 1)
                    break
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                if len(adj[v]) == 1:
                    new_q.append(v)
            q = new_q
        return (n-1)*2",O(n)
"import collections



class Solution(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                while dq and not check(nums[dq[-1]], nums[right]):
                    i = dq.pop()
                    cnt = i-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                    total -= cnt*nums[i]
                cnt = right-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                dq.append(right)
                total += cnt*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0]]
                    if dq[0] == right-(k-1):
                        dq.popleft()
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)",O(n)
"import collections



class Solution2(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                left = right
                while dq and not check(nums[dq[-1][0]], nums[right]):
                    i, left = dq.pop()
                    total -= (i-left+1)*nums[i]
                dq.append([right, left])
                total += (right-left+1)*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0][0]]
                    if dq[0][0] == right-(k-1):
                        dq.popleft()
                    else:
                        assert(dq[0][1] == right-(k-1))
                        dq[0][1] += 1
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)",O(n)
"class Solution(object):
    def minimumOperations(self, num):
        lookup = [0]*10
        for i in reversed(range(len(num))):
            if ((num[i] in ""05"" and lookup[0]) or
                (num[i] in ""27"" and lookup[5])):
                return (len(num)-i)-2
            lookup[ord(num[i])-ord('0')] = 1
        return len(num)-lookup[0]",O(n)
"import collections


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def minInteger(self, num, k):
        lookup = collections.defaultdict(list)
        bit = BIT(len(num)+1)
        for i in reversed(range(len(num))):
            bit.add(i+1, 1)
            lookup[int(num[i])].append(i+1)
        result = []
        for _ in range(len(num)):
            for d in range(10):
                if lookup[d] and bit.sum(lookup[d][-1]-1) <= k:
                    k -= bit.sum(lookup[d][-1]-1)
                    bit.add(lookup[d].pop(), -1)
                    result.append(d)
                    break
        return """".join(map(str, result))",O(nlogn)
"import random
import math

class Solution(object):

    def __init__(self, radius, x_center, y_center):
        self.__radius = radius
        self.__x_center = x_center
        self.__y_center = y_center
        

    def randPoint(self):
        r = (self.__radius) * math.sqrt(random.uniform(0, 1))
        theta = (2*math.pi) * random.uniform(0, 1)
        return (r*math.cos(theta) + self.__x_center,
                r*math.sin(theta) + self.__y_center)",O(1)
"class Solution(object):
    def longestWPI(self, hours):
        result, accu = 0, 0
        lookup = {}
        for i, h in enumerate(hours):
            accu = accu+1 if h > 8 else accu-1
            if accu > 0:
                result = i+1
            elif accu-1 in lookup:
                result = max(result, i-lookup[accu-1])
            lookup.setdefault(accu, i)
        return result",O(n)
"import random



class Solution(object):
    def maxStarSum(self, vals, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        adj = [[] for _ in range(len(vals))]
        for u, v in edges:
            if vals[v] > 0:
                adj[u].append(v)
            if vals[u] > 0:
                adj[v].append(u)
        result = float(""-inf"")
        for u in range(len(vals)):
            if 1 <= k <= len(adj[u]):
                nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b])
            result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u])))))
        return result",O(n)
"class Solution(object):
    def scoreOfString(self, s):
        return sum(abs(ord(s[i+1])-ord(s[i])) for i in range(len(s)-1))",O(n)
"class Solution(object):
    def minArraySum(self, nums, k, op1, op2):
        nums.sort()

        left = next((i for i in range(len(nums)) if nums[i] >= k), len(nums))
        right = next((i for i in range(len(nums)) if nums[i] >= 2*k-1), len(nums))

        lookup, cnt = [False]*len(nums), 0
        for j in reversed(range(right, len(nums))):
            if not op1:
                break
            op1 -= 1
            nums[j] = (nums[j]+1)//2
            if op2:
                op2 -= 1
                nums[j] -= k
        else:
            j = right-1

        for i in range(left, j+1):
            if not op2:
                break
            op2 -= 1
            if k%2 == 1 and nums[i]%2 == 0:
                lookup[i] = True
            nums[i] -= k
        else:
            i = j+1
    
        for j in reversed(range(i, j+1)):
            if not op1:
                break
            op1 -= 1
            if k%2 == 1 and nums[j]%2 == 1:
                cnt += 1
            nums[j] = (nums[j]+1)//2
        else:
            j = i-1

        arr = sorted((nums[idx], idx) for idx in range(i))
        for _ in range(op1):
            x, idx = arr.pop()
            nums[idx] = (x+1)//2
            if cnt and lookup[idx]:
                cnt -= 1
                nums[idx] -= 1
        return sum(nums)",O(nlogn)
"class Solution(object):
    def findTilt(self, root):
        def postOrderTraverse(root, tilt):
            if not root:
                return 0, tilt
            left, tilt = postOrderTraverse(root.left, tilt)
            right, tilt = postOrderTraverse(root.right, tilt)
            tilt += abs(left-right)
            return left+right+root.val, tilt

        return postOrderTraverse(root, 0)[1]",O(n)
"class Solution(object):
    def minMeetingRooms(self, intervals):
        result, curr = 0, 0
        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]
        line.sort()
        for _, num in line:
            curr += num
            result = max(result, curr)
        return result",O(nlogn)
"class Solution2(object):
    def minMeetingRooms(self, intervals):
        starts, ends = [], []
        for start, end in intervals:
            starts.append(start)
            ends.append(end)

        starts.sort()
        ends.sort()

        s, e = 0, 0
        min_rooms, cnt_rooms = 0, 0
        while s < len(starts):
            if starts[s] < ends[e]:
                cnt_rooms += 1 
                min_rooms = max(min_rooms, cnt_rooms)
                s += 1
            else:
                cnt_rooms -= 1 
                e += 1

        return min_rooms",O(nlogn)
"from heapq import heappush, heappop


class Solution3(object):
    def minMeetingRooms(self, intervals):
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[0])
        free_rooms = []
        
        heappush(free_rooms, intervals[0][1])
        for interval in intervals[1:]:
            if free_rooms[0] <= interval[0]:
                heappop(free_rooms)
            
            heappush(free_rooms, interval[1])
        
        return len(free_rooms)",O(nlogn)
"import itertools



class Solution(object):
    def isAcronym(self, words, s):
        return len(words) == len(s) and all(w[0] == c for w, c in zip(words, s))",O(n)
"class Solution(object):
    def clumsy(self, N):
        if N <= 2:
            return N
        if N <= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 <= 2:
            return N+2
        return N-1",O(1)
"class Solution(object):
    def findOcurrences(self, text, first, second):
        result = []
        first += ' '
        second += ' '
        third = []
        i, j, k = 0, 0, 0
        while k < len(text):
            c = text[k]
            k += 1
            if i != len(first):
                if c == first[i]:
                    i += 1
                else:
                    i = 0
                continue
            if j != len(second):
                if c == second[j]:
                    j += 1
                else:
                    k -= j+1
                    i, j = 0, 0
                continue
            if c != ' ':
                third.append(c)
                continue
            k -= len(second) + len(third) + 1
            i, j = 0, 0
            result.append("""".join(third))
            third = []
        if third:
            result.append("""".join(third))
        return result",O(n)
"class Solution(object):
    def countGoodNodes(self, edges):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    l, valid = [0], [True]
                    stk.append((4, (ret, valid)))
                    stk.append((2, (u, p, 0, ret, l, valid)))
                elif step == 2:
                    u, p, i, ret, l, valid = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1, ret, l, valid)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [0]
                    stk.append((3, (new_ret, ret, l, valid)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret, l, valid = args
                    ret[0] += new_ret[0]
                    l[0] += 1
                    if new_ret[0]*l[0] != ret[0]:
                        valid[0] = False
                elif step == 4:
                    ret, valid = args
                    if valid[0]:
                        result += 1
                    ret[0] += 1
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def countGoodNodes(self, edges):
        def dfs(u, p):
            total = l = 0
            valid = True
            for v in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                total += cnt
                l += 1
                if l*cnt != total:
                    valid = False
            if valid:
                result[0] += 1
            return total+1
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"class Solution(object):
    def uniqueXorTriplets(self, nums):
        def fst(a, inverse):
            n = len(a)
            step = 1
            while step < n:
                for i in range(0, n, step<<1):
                    for j in range(i, i+step):
                        u, v = a[j], a[j+step]
                        a[j], a[j+step] = u+v, u-v
                step <<= 1
            if inverse:
                for i in range(n):
                    a[i] //= n
        
        a = [0]*(1<<max(nums).bit_length())
        for x in nums:
            a[x] += 1
        fst(a, False)
        for i in range(len(a)):
            a[i] = a[i]**3
        fst(a, True)
        return sum(x != 0 for x in a)",O(nlogn)
"class Solution2(object):
    def uniqueXorTriplets(self, nums):
        cnt2, cnt3 = set([0]), set(),  
        max_cnt = 1<<max(nums).bit_length()
        for x in nums:
            for y in cnt2:
                cnt3.add(x^y)
            for y in nums:
                cnt2.add(x^y)
            if len(cnt3) == max_cnt:
                break
        return len(cnt3)",O(n ^ 2)
"import collections


class Solution(object):
    def minWindow(self, s, t):
        count, remain = collections.Counter(t), len(t)
        i, left, right = 0, -1, -1
        for j, c in enumerate(s):
            remain -= count[c] > 0
            count[c] -= 1
            if remain:
                continue
            while count[s[i]] < 0: 
                count[s[i]] += 1
                i += 1
            if right == -1 or j-i+1 < right-left+1:
                left, right = i, j
        return s[left:right+1]",O(n)
"class Solution2(object):
    def minWindow(self, s, t):
        current_count = [0 for i in range(52)]
        expected_count = [0 for i in range(52)]

        for char in t:
            expected_count[ord(char) - ord('a')] += 1

        i, count, start, min_width, min_start = 0, 0, 0, float(""inf""), 0
        while i < len(s):
            current_count[ord(s[i]) - ord('a')] += 1
            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:
                count += 1

            if count == len(t):
                while expected_count[ord(s[start]) - ord('a')] == 0 or \
                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:
                    current_count[ord(s[start]) - ord('a')] -= 1
                    start += 1

                if min_width > i - start + 1:
                    min_width = i - start + 1
                    min_start = start
            i += 1

        if min_width == float(""inf""):
            return """"

        return s[min_start:min_start + min_width]",O(n)
"class Solution(object):
    def depthSumInverse(self, nestedList):
        def depthSumInverseHelper(list, depth, result):
            if len(result) < depth + 1:
                result.append(0)
            if list.isInteger():
                result[depth] += list.getInteger()
            else:
                for l in list.getList():
                    depthSumInverseHelper(l, depth + 1, result)

        result = []
        for list in nestedList:
            depthSumInverseHelper(list, 0, result)

        sum = 0
        for i in reversed(range(len(result))):
            sum += result[i] * (len(result) - i)
        return sum",O(n)
"class Solution(object):
    def calPoints(self, ops):
        history = []
        for op in ops:
            if op == '+':
                history.append(history[-1] + history[-2])
            elif op == 'D':
                history.append(history[-1] * 2)
            elif op == 'C':
                history.pop()
            else:
                history.append(int(op))
        return sum(history)",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def add(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if not node:
            l.insert(ListNode(key, 0))

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)

    def contains(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        return node is not None",O(n)
"import collections
import itertools



class Solution(object):
    def minimumTotalCost(self, nums1, nums2):
        cnt = collections.Counter()
        result = 0
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x != y:
                continue
            cnt[x] += 1
            result += i
        if not cnt:
            return 0
        majority = max(iter(cnt.keys()), key=lambda x: cnt[x])
        remain = cnt[majority]-(sum(cnt.values())-cnt[majority])
        if remain <= 0:
            return result
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y or majority in (x, y):
                continue
            result += i
            remain -= 1
            if not remain:
                return result
        return -1",O(n)
"class Solution(object):
    def countOrders(self, n):
        MOD = 10**9+7
        result = 1
        for i in reversed(range(2, 2*n+1, 2)):
            result = result * i*(i-1)//2 % MOD
        return result",O(n)
"from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result",O(nlogn)
"class Solution(object):
    def arrangeWords(self, text):
        result = text.split()
        result[0] = result[0].lower()
        result.sort(key=len) 
        result[0] = result[0].title()
        return "" "".join(result)",O(nlogn)
"import itertools



class Solution(object):
    def findMinimumOperations(self, s1, s2, s3):
        for i, (a, b, c) in enumerate(zip(s1, s2, s3)):
            if not a == b == c:
                break
        else:
            i += 1
        return len(s1)+len(s2)+len(s3)-3*i if i else -1",O(n)
"import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result",O(n)
"class Solution(object):
    def findNumberOfLIS(self, nums):
        result, max_len = 0, 0
        dp = [[1, 1] for _ in range(len(nums))] 
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[i][0] == dp[j][0]+1:
                        dp[i][1] += dp[j][1]
                    elif dp[i][0] < dp[j][0]+1:
                        dp[i] = [dp[j][0]+1, dp[j][1]]
            if max_len == dp[i][0]:
                result += dp[i][1]
            elif max_len < dp[i][0]:
                max_len = dp[i][0]
                result = dp[i][1]
        return result",O(n ^ 2)
"class Solution(object):
    def maximizeSweetness(self, sweetness, K):
        def check(sweetness, K, x):
            curr, cuts = 0, 0
            for s in sweetness:
                curr += s
                if curr >= x:
                    cuts += 1
                    curr = 0
            return cuts >= K+1

        left, right = min(sweetness), sum(sweetness)//(K+1)
        while left <= right:
            mid = left + (right-left)//2
            if not check(sweetness, K, mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution(object):
    def interpret(self, command):
        result, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                result += [""G""]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += [""o""]
                i += 2
            else:
                result += [""al""]
                i += 4
        return """".join(result)",O(n)
"import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)",O(n)
"class Solution(object):
    def maximumSubtreeSize(self, edges, colors):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (ret,)))
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [1]
                    stk.append((3, (v, u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    v, u, new_ret, ret = args
                    if ret[0] == -1:
                        continue 
                    if new_ret[0] == 0 or colors[v] != colors[u]:
                        ret[0] = -1
                        continue
                    ret[0] += new_ret[0]
                elif step == 4:
                    ret = args[0]
                    result = max(result, ret[0])
            return result

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def maximumSubtreeSize(self, edges, colors):
        def dfs(u, p):
            cnt = 1
            for v in adj[u]:
                if v == p:
                    continue
                c = dfs(v, u)
                if cnt == -1:
                    continue
                if c == -1 or colors[v] != colors[u]:
                    cnt = -1
                    continue
                cnt += c
            result[0] = max(result[0], cnt)
            return cnt

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"import collections


class Solution(object):
    def shortestBridge(self, A):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def get_islands(A):
            islands = []
            done = set()
            for r, row in enumerate(A):
                for c, val in enumerate(row):
                    if val == 0 or (r, c) in done:
                        continue
                    s = [(r, c)]
                    lookup = set(s)
                    while s:
                        node = s.pop()
                        for d in directions:
                            nei = node[0]+d[0], node[1]+d[1]
                            if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                               nei in lookup or A[nei[0]][nei[1]] == 0:
                                continue
                            s.append(nei)
                            lookup.add(nei)
                    done |= lookup
                    islands.append(lookup)
                    if len(islands) == 2:
                        break
            return islands

        lookup, target = get_islands(A)
        q = collections.deque([(node, 0) for node in lookup])
        while q:
            node, dis = q.popleft()
            if node in target:
                return dis-1
            for d in directions:
                nei = node[0]+d[0], node[1]+d[1]
                if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                   nei in lookup:
                    continue
                q.append((nei, dis+1))
                lookup.add(nei)",O(n ^ 2)
"import collections


class Solution(object):
    def areOccurrencesEqual(self, s):
        return len(set(collections.Counter(s).values())) == 1",O(n)
"class Solution(object):
    def largestPerimeter(self, A):
        A.sort()
        for i in reversed(range(len(A) - 2)):
            if A[i] + A[i+1] > A[i+2]:
                return A[i] + A[i+1] + A[i+2]
        return 0",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self, root):
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        return target in self.__lookup",O(n)
"class Solution(object):
    def removeOuterParentheses(self, S):
        deep = 1
        result, cnt = [], 0
        for c in S:
            if c == '(' and cnt >= deep:
                result.append(c)
            if c == ')' and cnt > deep:
                result.append(c)
            cnt += 1 if c == '(' else -1
        return """".join(result)",O(n)
"class Solution(object):
    def complexNumberMultiply(self, a, b):
        ra, ia = list(map(int, a[:-1].split('+')))
        rb, ib = list(map(int, b[:-1].split('+')))
        return '%d+%di' % (ra * rb - ia * ib, ra * ib + ia * rb)",O(1)
"class Solution(object):
    def nthMagicalNumber(self, N, A, B):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def check(A, B, N, lcm, target):
            return target//A + target//B - target//lcm >= N

        lcm = A*B // gcd(A, B)
        left, right = min(A, B), max(A, B)*N
        while left <= right:
            mid = left + (right-left)//2
            if check(A, B, N, lcm, mid):
                right = mid-1
            else:
                left = mid+1
        return left % (10**9 + 7)",O(logn)
"class Solution(object):
    def rearrangeArray(self, nums):
        pos, neg = 0, 1
        result = [0]*len(nums)
        for x in nums:
            if x > 0:
                result[pos] = x
                pos += 2
            else:
                result[neg] = x
                neg += 2
        return result",O(n)
"class Solution2(object):
    def rearrangeArray(self, nums):
        def pos():
            for x in nums:
                if x > 0:
                    yield x
        
        def neg():
            for x in nums:
                if x < 0:
                    yield x
        
        gen_pos = pos()
        gen_neg = neg()
        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in range(len(nums))]",O(n)
"class Solution3(object):
    def rearrangeArray(self, nums):
        pos, neg = [], []
        for i in reversed(range(len(nums))):
            if nums[i] > 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in range(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result",O(n)
"class Solution(object):
    def maxArea(self, height):
        max_area, i, j = 0, 0, len(height) - 1
        while i < j:
            max_area = max(max_area, min(height[i], height[j]) * (j - i))
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area",O(n)
"class Solution(object):
    def fizzBuzz(self, n):
        result = []

        for i in range(1, n+1):
            if i % 15 == 0:
                result.append(""FizzBuzz"")
            elif i % 5 == 0:
                result.append(""Buzz"")
            elif i % 3 == 0:
                result.append(""Fizz"")
            else:
                result.append(str(i))

        return result

    def fizzBuzz2(self, n):
        l = [str(x) for x in range(n + 1)]
        l3 = list(range(0, n + 1, 3))
        l5 = list(range(0, n + 1, 5))
        for i in l3:
            l[i] = 'Fizz'
        for i in l5:
            if l[i] == 'Fizz':
                l[i] += 'Buzz'
            else:
                l[i] = 'Buzz'
        return l[1:]

    def fizzBuzz3(self, n):
        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]

    def fizzBuzz4(self, n):
        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]",O(n)
"class Solution(object):
    def squareIsWhite(self, coordinates):
        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2",O(1)
"class Solution(object):
    def findPeaks(self, mountain):
        return [i for i in range(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]",O(n)
"class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        result = """"
        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
            result = ""-""

        dvd, dvs = abs(numerator), abs(denominator)
        result += str(dvd / dvs)
        dvd %= dvs

        if dvd > 0:
            result += "".""

        lookup = {}
        while dvd and dvd not in lookup:
            lookup[dvd] = len(result)
            dvd *= 10
            result += str(dvd / dvs)
            dvd %= dvs

        if dvd in lookup:
            result = result[:lookup[dvd]] + ""("" + result[lookup[dvd]:] + "")""

        return result",O(n)
"class Solution(object):
    def isConsecutive(self, nums):
        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))",O(n)
"class Solution2(object):
    def isConsecutive(self, nums):
        nums.sort()
        return all(nums[i]+1 == nums[i+1] for i in range(len(nums)-1))",O(nlogn)
"class Solution(object):
    def findLengthOfLCIS(self, nums):
        result, count = 0, 0
        for i in range(len(nums)):
            if i == 0 or nums[i-1] < nums[i]:
                count += 1
                result = max(result, count)
            else:
                count = 1
        return result",O(n)
"class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))",O(n)
"import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0
        for i in range(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.values():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in range(len(coeff)):
                for k in range(i+1):
                    if k+j >= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in range(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result",O(n ^ 2)
"class Solution(object):
    def repeatedNTimes(self, A):
        for i in range(2, len(A)):
            if A[i-1] == A[i] or A[i-2] == A[i]:
                return A[i]
        return A[0]",O(n)
"import collections



class Solution(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in reversed(range(left, right+1)):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result, left, count = 0, 0, 0
        for right in range(len(A)):
            count += A[right]%2
            while count > K:
                count -= A[left]%2
                left += 1
            result += countDistinct(A, left, right, trie)
        return result",O(n ^ 2)
"class Solution2(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in range(left, right+1):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for left in range(len(A)):
            count = 0
            for right in range(left, len(A)):
                count += A[right]%2
                if count > K:
                    right -= 1
                    break
            result += countDistinct(A, left, right, trie)
        return result",O(n ^ 2)
"class Solution(object):
    def longestMountain(self, A):
        result, up_len, down_len = 0, 0, 0
        for i in range(1, len(A)):
            if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]:
                up_len, down_len = 0, 0
            up_len += A[i-1] < A[i]
            down_len += A[i-1] > A[i]
            if up_len and down_len:
                result = max(result, up_len+down_len+1)
        return result",O(n)
"class Solution(object):
    def sortArray(self, nums):
        def mergeSort(left, right, nums):
            if left == right:
                return
            mid = left + (right-left)//2
            mergeSort(left, mid, nums)
            mergeSort(mid+1, right,  nums)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and nums[r] < nums[l]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[l])
            nums[left:left+len(tmp)] = tmp

        mergeSort(0, len(nums)-1, nums)
        return nums",O(nlogn)
"import random

class Solution2(object):
    def sortArray(self, nums):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def quickSort(left, right, nums):
            if left > right:
                return
            mid = left + (right-left)//2
            nth_element(nums, left, mid, right)
            quickSort(left, mid-1, nums)
            quickSort(mid+1, right, nums)

        quickSort(0, len(nums)-1, nums)
        return nums",O(nlogn)
"
import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):
        count = collections.Counter(nums)
        for num in sorted(count.keys()):
            c = count[num]
            if not c:
                continue
            for i in range(num, num+k):
                if count[i] < c:
                    return False
                count[i] -= c
        return True
",O(nlogn)
"from operator import xor
from functools import reduce


class Solution(object):
    def xorGame(self, nums):
        return reduce(xor, nums) == 0 or \
            len(nums) % 2 == 0",O(n)
"
class Solution(object):
    def findTarget(self, root, k):
        class BSTIterator(object):
            def __init__(self, root, forward):
                self.__node = root
                self.__forward = forward
                self.__s = []
                self.__cur = None
                next(self)

            def val(self):
                return self.__cur

            def __next__(self):
                while self.__node or self.__s:
                    if self.__node:
                        self.__s.append(self.__node)
                        self.__node = self.__node.left if self.__forward else self.__node.right
                    else:
                        self.__node = self.__s.pop()
                        self.__cur = self.__node.val
                        self.__node = self.__node.right if self.__forward else self.__node.left
                        break


        if not root:
            return False
        left, right = BSTIterator(root, True), BSTIterator(root, False)
        while left.val() < right.val():
            if left.val() + right.val() == k:
                return True
            elif left.val() + right.val() < k:
                next(left)
            else:
                next(right)
        return False

",O(n)
"class Solution(object):
    def flowerGame(self, n, m):
        return (n*m)//2",O(1)
"import threading


class Solution(object):
    def __init__(self):
        self._l = [threading.Lock() for _ in range(5)]

    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):
        left, right = philosopher, (philosopher+4)%5
        first, second = left, right
        if  philosopher%2 == 0:
            first, second = left, right
        else:
            first, second = right, left

        with self._l[first]:
            with self._l[second]:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()",O(1)
"class Solution(object):
    def getMinimumDifference(self, root):
        def inorderTraversal(root, prev, result):
            if not root:
                return (result, prev)

            result, prev = inorderTraversal(root.left, prev, result)
            if prev: result = min(result, root.val - prev.val)
            return inorderTraversal(root.right, root, result)

        return inorderTraversal(root, None, float(""inf""))[0]",O(n)
"class Solution(object):
    def titleToNumber(self, s):
        result = 0
        for i in range(len(s)):
            result *= 26
            result += ord(s[i]) - ord('A') + 1
        return result",O(n)
"class Solution(object):
    def maxSum(self, nums):
        mx = max(nums)
        return mx if mx < 0 else sum(x for x in set(nums) if x >= 0)",O(n)
"import collections


class Solution(object):
    def majorityElement(self, nums):
        k, n, cnts = 3, len(nums), collections.defaultdict(int)

        for i in nums:
            cnts[i] += 1
            if len(cnts) == k:
                for j in list(cnts.keys()):
                    cnts[j] -= 1
                    if cnts[j] == 0:
                        del cnts[j]

        for i in list(cnts.keys()):
            cnts[i] = 0

        for i in nums:
            if i in cnts:
                cnts[i] += 1

        result = []
        for i in list(cnts.keys()):
            if cnts[i] > n / k:
                result.append(i)

        return result

    def majorityElement2(self, nums):
        return [i[0] for i in list(collections.Counter(nums).items()) if i[1] > len(nums) / 3]",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def removeLeafNodes(self, root, target):
        if not root:
            return None
        root.left = self.removeLeafNodes(root.left, target)
        root.right = self.removeLeafNodes(root.right, target)
        return None if root.left == root.right and root.val == target else root
",O(n)
"class Solution(object):
    def checkRecord(self, n):
        M = 1000000007
        a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0
        for i in range(n+1):
            a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M
            a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M
        return a1l0",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumPairRemoval(self, nums):
        def add(i):
            if 0 <= i < right[i] < len(nums):
                sl.add([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] += 1

        def remove(i):
            if 0 <= i < right[i] < len(nums):
                sl.remove([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] -= 1

        left = list(range(-1, (len(nums)+1)-1))
        right = list(range(1, len(nums)+1))
        cnt = [sum(nums[i] > nums[i+1] for i in range(len(nums)-1))]
        sl = SortedList([nums[i]+nums[i+1], i] for i in range(len(nums)-1))
        result = 0
        while cnt[0]:
            _, i = sl[0]
            remove(left[i])
            remove(i)
            remove(right[i])
            nums[i] += nums[right[i]]
            left[right[right[i]]] = i
            right[i] = right[right[i]]
            add(left[i])
            add(i)
            result += 1
        return result",O(nlogn)
"
import itertools


class Solution(object):
    def shortestToChar(self, S, C):
        result = [len(S)] * len(S)
        prev = -len(S)
        for i in itertools.chain(range(len(S)),
                                 reversed(range(len(S)))):
            if S[i] == C:
                prev = i
            result[i] = min(result[i], abs(i-prev))
        return result

",O(n)
"import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"import collections



class Solution2(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
        
        def topk(a, k): 
            result = [float(""-inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result
    
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in topk(nums1, 3)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"class Solution3(object):
    def minimumAddedInteger(self, nums1, nums2):
        nums1.sort()
        nums2.sort()
        for i in range(3):
            d = nums2[-1]-nums1[~i]
            cnt = 0
            for j in range(len(nums2)):
                while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]:
                    cnt += 1
            if cnt <= 2:
                return d
        return -1",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        def iter_dfs(node, p, q):
            result = None
            stk = [(1, (node, [0]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    curr = int(node == p or node == q)
                    if curr+ret1[0]+ret2[0] == 2 and not result:
                        result = node
                    ret[0] = curr+ret1[0]+ret2[0]
            return result

        return iter_dfs(root, p, q)",O(n)
"class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return 0
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            curr = int(node == p or node == q)
            if curr+left+right == 2 and not result[0]:
                result[0] = node
            return curr+left+right

        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"class Solution(object):
    def visibleMountains(self, peaks):
        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1]))) 
        result = mx = 0
        for i in range(len(peaks)):
            if peaks[i][0]+peaks[i][1] <= mx:
                continue
            mx = peaks[i][0]+peaks[i][1]
            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:
                result += 1
        return result",O(nlogn)
"class Solution2(object):
    def visibleMountains(self, peaks):
        def is_covered(a, b):
            x1, y1 = a
            x2, y2 = b
            return x2-y2 <= x1-y1 and x1+y1 <= x2+y2

        peaks.sort()
        stk = []
        for i in range(len(peaks)):
            while stk and is_covered(peaks[stk[-1]], peaks[i]):
                stk.pop()
            if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])): 
                stk.append(i)
        return len(stk)",O(nlogn)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def delNodes(self, root, to_delete):
        def delNodesHelper(to_delete_set, root, is_root, result):
            if not root:
                return None
            is_deleted = root.val in to_delete_set
            if is_root and not is_deleted:
                result.append(root)
            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)
            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)
            return None if is_deleted else root
        
        result = []
        to_delete_set = set(to_delete)
        delNodesHelper(to_delete_set, root, True, result)
        return result
",O(n)
"class Solution(object):
    def fixedPoint(self, A):
        left, right = 0, len(A)-1
        while left <= right:
            mid = left + (right-left)//2
            if A[mid] >= mid:
                right = mid-1
            else:
                left = mid+1
        return left if A[left] == left else -1",O(logn)
"class Solution(object):
    def maximumXorProduct(self, a, b, n):
        MOD = 10**9+7
        for i in reversed(range(n)):
            base = 1<<i
            if min(a, b)&base == 0:
                a, b = a^base, b^base
        return (a%MOD)*(b%MOD)%MOD",O(n)
"class Solution(object):
    def decode(self, encoded):
        curr = 0
        for i in range(1, (len(encoded)+1) + 1):
            curr ^= i
            if i < len(encoded) and i%2 == 1:
                curr ^= encoded[i]
        result = [curr]
        for x in encoded:
            result.append(result[-1]^x)
        return result",O(n)
"class Solution(object):
    def largestInteger(self, num):
        def count(num):
            cnt = [0]*10
            while num:
                num, d = divmod(num, 10)
                cnt[d] += 1
            return cnt

        cnt = count(num)
        result = 0
        digit = [0, 1]
        base = 1
        while num:
            num, d = divmod(num, 10)
            while not cnt[digit[d%2]]:
                digit[d%2] += 2
            cnt[digit[d%2]] -= 1
            result += digit[d%2]*base
            base *= 10
        return result",O(logn)
"class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]",O(1)
"class Solution(object):
    def longestString(self, x, y, z):
        return ((min(x, y)*2+int(x != y))+z)*2",O(1)
"class Solution(object):
    def splitIntoFibonacci(self, S):
        def startswith(S, k, x):
            y = 0
            for i in range(k, len(S)):
                y = 10*y + int(S[i])
                if y == x:
                    return i-k+1
                elif y > x:
                    break
            return 0

        MAX_INT = 2**31-1
        a = 0
        for i in range(len(S)-2):
            a = 10*a + int(S[i])
            b = 0
            for j in range(i+1, len(S)-1):
                b = 10*b + int(S[j])
                fib = [a, b]
                k = j+1
                while k < len(S):
                    if fib[-2] > MAX_INT-fib[-1]:
                        break
                    c = fib[-2]+fib[-1]
                    length = startswith(S, k, c)
                    if length == 0:
                        break
                    fib.append(c)
                    k += length
                else:
                    return fib
                if b == 0:
                    break
            if a == 0:
                break
        return []",O(n ^ 3)
"class Solution(object):
    def advantageCount(self, A, B):
        sortedA = sorted(A)
        sortedB = sorted(B)

        candidates = {b: [] for b in B}
        others = []
        j = 0
        for a in sortedA:
            if a > sortedB[j]:
                candidates[sortedB[j]].append(a)
                j += 1
            else:
                others.append(a)
        return [candidates[b].pop() if candidates[b] else others.pop()
                for b in B]",O(nlogn)
"class Solution(object):
    def minTrioDegree(self, n, edges):
        adj = [set() for _ in range(n+1)]
        degree = [0]*(n+1)
        for u, v in edges:
            adj[min(u, v)].add(max(u, v))
            degree[u] += 1
            degree[v] += 1
        result = float(""inf"")
        for u in range(1, n+1):
            for v in adj[u]:
                for w in adj[u]:
                    if v < w and w in adj[v]:
                        result = min(result, degree[u]+degree[v]+degree[w] - 6)
        return result if result != float(""inf"") else -1",O(n ^ 3)
"class Solution(object):
    def minimumNumbers(self, num, k):
        return next((i for i in range(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0",O(1)
"class Solution(object):
    def losingPlayer(self, x, y):
        return ""Alice"" if min(x, y//4)%2 else ""Bob""",O(1)
"class Solution(object):
    def minKBitFlips(self, A, K):
        result, curr = 0, 0
        for i in range(len(A)):
            if i >= K:
                curr -= A[i-K]//2
            if curr & 1 ^ A[i] == 0:
                if i+K > len(A):
                    return -1
                A[i] += 2
                curr, result = curr+1, result+1
        return result",O(n)
"class Solution(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, nums, 0)^reduce(lambda x, y: x^y, set(nums), 0)",O(n)
"import collections
from functools import reduce



class Solution2(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).items() if c == 2), 0)",O(n)
"import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] < left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result",O(nlogn)
"class Solution(object):
    def findMode(self, root):
        def inorder(root, prev, cnt, max_cnt, result):
            if not root:
                return prev, cnt, max_cnt

            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
            if prev:
                if root.val == prev.val:
                    cnt += 1
                else:
                    cnt = 1
            if cnt > max_cnt:
                max_cnt = cnt
                del result[:]
                result.append(root.val)
            elif cnt == max_cnt:
                result.append(root.val)
            return inorder(root.right, root, cnt, max_cnt, result)

        if not root:
            return []
        result = []
        inorder(root, None, 1, 0, result)
        return result",O(n)
"import collections


class Solution(object):
    def sortFeatures(self, features, responses):
        features_set = set(features)
        order = {word: i for i, word in enumerate(features)}
        freq = collections.defaultdict(int)
        for r in responses:
            for word in set(r.split(' ')):
                if word in features_set:
                    freq[word] += 1
        features.sort(key=lambda x: (-freq[x], order[x]))
        return features",O(nlogn)
"class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        counts = [0] * 26
        letters = 0

        for c in ransomNote:
            if counts[ord(c) - ord('a')] == 0:
                letters += 1
            counts[ord(c) - ord('a')] += 1

        for c in magazine:
            counts[ord(c) - ord('a')] -= 1
            if counts[ord(c) - ord('a')] == 0:
                letters -= 1
                if letters == 0:
                    break

        return letters == 0",O(n)
"import collections

class Solution2(object):
    def canConstruct(self, ransomNote, magazine):
        return not collections.Counter(ransomNote) - collections.Counter(magazine)",O(n)
"class Solution(object):
    def minSwapsCouples(self, row):
        N = len(row)//2
        couples = [[] for _ in range(N)]
        for seat, num in enumerate(row):
            couples[num//2].append(seat//2)
        adj = [[] for _ in range(N)]
        for couch1, couch2 in couples:
            adj[couch1].append(couch2)
            adj[couch2].append(couch1)

        result = 0
        for couch in range(N):
            if not adj[couch]: continue
            couch1, couch2 = couch, adj[couch].pop()
            while couch2 != couch:
                result += 1
                adj[couch2].remove(couch1)
                couch1, couch2 = couch2, adj[couch2].pop()
        return result",O(n)
"class Solution(object):
    def xorQueries(self, arr, queries):
        for i in range(1, len(arr)):
            arr[i] ^= arr[i-1]
        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]",O(n)
"class Solution(object):
    def canAttendMeetings(self, intervals):
        intervals.sort(key=lambda x: x[0])

        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i-1][1]:
                return False
        return True",O(nlogn)
"class Solution(object):
    def largestSubarray(self, nums, k):
        left, right, l = 0, 1, 0
        while right+k-1 < len(nums) and right+l < len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] > nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumLevel(self, root):
        q = [root]
        d = 1
        result = ((float(""inf""), float(""inf"")))
        while q:
            new_q = []
            total = 0
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
                total += u.val
            result = min(result, (total, d))
            q = new_q
            d += 1
        return result[-1]",O(n)
"class Solution(object):
    def numSub(self, s):
        MOD = 10**9+7
        result, count = 0, 0
        for c in s:
            count = count+1 if c == '1' else 0
            result = (result+count)%MOD
        return result",O(n)
"class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, 0, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d, ret = args
                    stk.append((3, (d, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_ret = [1]
                        stk.append((2, (new_ret, ret)))
                        stk.append((1, (v, u, d+1, new_ret)))
                elif step == 2:
                    new_ret, ret = args
                    ret[0] += new_ret[0]
                elif step == 3:
                    d, ret = args
                    if d:
                        result += ceil_divide(ret[0], seats)
            return result
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def dfs(u, p, d):
            cnt = 1+sum(dfs(v, u, d+1) for v in adj[u] if v != p)
            if d:
                result[0] += ceil_divide(cnt, seats)
            return cnt
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1, 0)
        return result[0]",O(n)
"class Solution(object):
    def minCapability(self, nums, k):
        def check(x):
            cnt = i = 0
            while i < len(nums):
                if nums[i] <= x:
                    cnt += 1
                    i += 2
                else:
                    i += 1
            return cnt >= k

        sorted_nums = sorted(set(nums))
        left, right = 0, len(sorted_nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(sorted_nums[mid]):
                right = mid-1
            else:
                left = mid+1
        return sorted_nums[left]",O(nlogn)
"import random



class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            result = []
            stk = [(1, (root, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if not curr:
                        ret[0] = 0
                        result.append(ret[0])
                        continue
                    new_ret = [[0] for _ in range(2)]
                    stk.append((2, (curr, new_ret, ret)))
                    stk.append((1, (curr.right, new_ret[1])))
                    stk.append((1, (curr.left, new_ret[0])))
                elif step == 2:
                    curr, new_ret, ret = args
                    ret[0] = new_ret[0][0]+new_ret[1][0]+1 if new_ret[0][0] == new_ret[1][0] != -1 else -1
                    result.append(ret[0])
            return result
                        
        result = iter_dfs()
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1",O(n)
"import random



class Solution2(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(curr):
            if not curr:
                result.append(0)
                return
            dfs(curr.left)
            left = result[-1]
            dfs(curr.right)
            right = result[-1]
            result.append(left+right+1 if left == right != -1 else -1)

        result = []
        dfs(root)
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1",O(n)
"class Solution(object):
    def minOperationsToFlip(self, expression):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],
               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}
        precedence = {'&':0, '|':0}
        operands, operators = [], []
        for c in expression:
            if c.isdigit():
                operands.append([int(c != '0'), int(c != '1')])
            elif c == '(':
                operators.append(c)
            elif c == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif c in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[c]:
                    compute(operands, operators)
                operators.append(c)
        while operators:
            compute(operands, operators)
        return max(operands[-1])",O(n)
"class Solution2(object):
    def minOperationsToFlip(self, expression):
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else: 
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])",O(n)
"class Solution2(object):
    def subarrayGCD(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = 0
        for i in range(len(nums)):
            g = 0
            for j in range(i, len(nums)):
                if nums[j]%k:
                    break
                g = gcd(g, nums[j])
                result += int(g == k)
        return result",O(n ^ 2)
"class Solution(object):
    def numberOfGoodSubarraySplits(self, nums):
        MOD = 10**9+7
        result, prev = 1, -1
        for i in range(len(nums)):
            if nums[i] != 1:
                continue
            if prev != -1:
                result = (result*(i-prev))%MOD
            prev = i
        return result if prev != -1 else 0",O(n)
"class Solution(object):
    def makePalindrome(self, s):
        return sum(s[i] != s[~i] for i in range(len(s)//2)) <= 2",O(n)
"class Solution2(object):
    def makePalindrome(self, s):
        cnt = 0
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                cnt += 1
                if cnt > 2:
                    return False
            left += 1
            right -= 1
        return True",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",O(n)
"class Solution2(object):
    def connect(self, root):
        if root is None:
            return
        if root.left:
            root.left.next = root.right
        if root.right and root.__next__:
            root.right.next = root.next.left
        self.connect(root.left)
        self.connect(root.right)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumEvenGrandparent(self, root):
        def sumEvenGrandparentHelper(root, p, gp):
            return sumEvenGrandparentHelper(root.left, root.val, p) + \
                   sumEvenGrandparentHelper(root.right, root.val, p) + \
                   (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0

        return sumEvenGrandparentHelper(root, None, None)",O(n)
"class Solution(object):
    def maxFreeTime(self, eventTime, k, startTime, endTime):
        startTime.append(eventTime)
        endTime.insert(0, 0)
        result = curr = 0
        for i in range(len(startTime)):
            curr += startTime[i]-endTime[i]
            result = max(result, curr)
            if i-k >= 0:
                curr -= startTime[i-k]-endTime[i-k]
        return result",O(n)
"

class Solution:
    def toArray(self, head):
        result = []
        while head:
            result.append(head.val)
            head = head.__next__
        return result
",O(n)
"import collections
import itertools



class Solution(object):
    def equalPairs(self, grid):
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in zip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.keys() if k in cnt2)",O(n ^ 2)
"import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()
    def zero(self, printNumber):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr % 2 != 0:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(0)
                self.__cv.notifyAll()
        
    def even(self, printNumber):
        for i in range(2, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
        
    def odd(self, printNumber):
        for i in range(1, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()",O(n)
"class Solution(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        result = 0
        for i in range(len(points)):
            y = float(""-inf"")
            for j in range(i+1, len(points)):
                if points[i][1] < points[j][1]:
                    continue
                if points[j][1] > y:
                    y = points[j][1]
                    result += 1
        return result",O(n ^ 2)
"class Solution2(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in range(i+1, j))
                   for i in range(len(points))
                   for j in range(i+1, len(points)) if points[i][1] >= points[j][1])",O(n ^ 3)
"class Solution(object):
    def numWays(self, steps, arrLen):
        MOD = int(1e9+7)
        l = min(1+steps//2, arrLen)
        dp = [0]*(l+2)
        dp[1] = 1
        while steps > 0:
            steps -= 1
            new_dp = [0]*(l+2)
            for i in range(1, l+1):
                new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD
            dp = new_dp
        return dp[1]",O(n ^ 2)
"import collections


class Solution(object):
    def waysToPartition(self, nums, k):
        total = sum(nums)
        right = collections.Counter()
        prefix = 0
        for i in range(len(nums)-1):
            prefix += nums[i]
            right[prefix-(total-prefix)] += 1
        result = right[0]
        left = collections.Counter()
        prefix = 0
        for x in nums:
            result = max(result, left[k-x]+right[-(k-x)])
            prefix += x
            left[prefix-(total-prefix)] += 1
            right[prefix-(total-prefix)] -= 1
        return result",O(n)
"class Solution2(object):
    def reinitializePermutation(self, n):
        if n == 2:
            return 1
        result, i = 0, 1
        while not result or i != 1:
            i = (i*2)%(n-1)
            result += 1
        return result",O(n)
"class Solution3(object):
    def reinitializePermutation(self, n):
        result, i = 0, 1
        while not result or i != 1: 
            i = (i//2 if not i%2 else n//2+(i-1)//2)
            result += 1
        return result",O(n)
"import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 >= k:
                result.append(len(count))
        return result",O(n)
"class Solution(object):
    def doubleIt(self, head):
        if head.val >= 5:
            head = ListNode(0, head)
        curr = head
        while curr:
            curr.val = (curr.val*2)%10
            if curr.__next__ and curr.next.val >= 5:
                curr.val += 1
            curr = curr.__next__
        return head",O(n)
"class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        order = list(range(len(growTime)))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result",O(nlogn)
"class Solution(object):
    def countPairs(self, n, edges):
        def bfs(adj, u, lookup):
            q = [u]
            lookup[u] = 1
            result = 1
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = 1
                        result += 1
                        new_q.append(v)
                q = new_q
            return result
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*n
        result = 0
        for u in range(n):
            if lookup[u]:
                continue
            cnt = bfs(adj, u, lookup)
            result += cnt*(n-cnt)
            n -= cnt
        return result",other
"class Solution(object):
    def sortArrayByParityII(self, A):
        j = 1
        for i in range(0, len(A), 2):
            if A[i] % 2:
                while A[j] % 2:
                    j += 2
                A[i], A[j] = A[j], A[i]
        return A",O(n)
"class Solution(object):
    def findDisappearedNumbers(self, nums):
        for i in range(len(nums)):
            if nums[abs(nums[i]) - 1] > 0:
                nums[abs(nums[i]) - 1] *= -1

        result = []
        for i in range(len(nums)):
            if nums[i] > 0:
                result.append(i+1)
            else:
                nums[i] *= -1
        return result

    def findDisappearedNumbers2(self, nums):
        return list(set(range(1, len(nums) + 1)) - set(nums))

    def findDisappearedNumbers3(self, nums):
        for i in range(len(nums)):
            index = abs(nums[i]) - 1
            nums[index] = - abs(nums[index])

        return [i + 1 for i in range(len(nums)) if nums[i] > 0]",O(n)
"class Solution(object):
    def myPow(self, x, n):
        result = 1
        abs_n = abs(n)
        while abs_n:
            if abs_n & 1:
                result *= x
            abs_n >>= 1
            x *= x

        return 1 / result if n < 0 else result",O(logn)
"class Solution2(object):
    def myPow(self, x, n):
        if n < 0 and n != -n:
            return 1.0 / self.myPow(x, -n)
        if n == 0:
            return 1
        v = self.myPow(x, n / 2)
        if n % 2 == 0:
            return v * v
        else:
            return v * v * x",O(logn)
"class Solution(object):
    def replaceDigits(self, s):
        return """".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in range(len(s)))",O(n)
"class Solution(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            return sum(abs(i-x) for i, x in enumerate(x for x, cnt in enumerate(cnt) for _ in range(cnt)))

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"class Solution2(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            result = bal = 0
            for i in range(len(rooks)):
                bal += cnt[i]-1
                result += abs(bal)
            return result

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"class Solution(object):
    def minOperations(self, nums, x):
        target = sum(nums)-x
        result = -1
        curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            while left < len(nums) and curr > target:
                curr -= nums[left]
                left += 1
            if curr == target:
                result = max(result, right-left+1)
        return len(nums)-result if result != -1 else -1",O(n)
"import itertools
class Solution_TLE(object):
    def createSortedArray(self, instructions):
        MOD = 10**9 + 7
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
        
        def largerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            largerMergeSort(idxs, start, mid, counts)
            largerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] <= idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += mid - r + 1
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp

        idxs = []
        smaller_counts, larger_counts = [[0] * len(instructions) for _ in range(2)]
        for i, inst in enumerate(instructions):
            idxs.append((inst, i))
        smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts)
        largerMergeSort(idxs, 0, len(idxs)-1, larger_counts)
        return sum(min(s, l) for s, l in zip(smaller_counts, larger_counts)) % MOD",O(nlogn)
"import collections



class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.__next__
            curr = curr.__next__
        return dummy.__next__",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def sortList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            prev, fast, slow = slow, fast.next.__next__, slow.__next__
        prev.next = None

        sorted_l1 = self.sortList(head)
        sorted_l2 = self.sortList(slow)

        return self.mergeTwoLists(sorted_l1, sorted_l2)

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode(0)

        cur = dummy
        while l1 != None and l2 != None:
            if l1.val <= l2.val:
                cur.next, cur, l1 = l1, l1, l1.__next__
            else:
                cur.next, cur, l2 = l2, l2, l2.__next__

        if l1 != None:
            cur.next = l1
        if l2 != None:
            cur.next = l2

        return dummy.__next__",O(nlogn)
"import collections


class Solution(object):
    def shareCandies(self, candies, k):
        cnt = collections.Counter(candies[i] for i in range(k, len(candies)))
        result = curr = len(cnt)
        for i in range(k, len(candies)):
            cnt[candies[i]] -= 1
            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)
            cnt[candies[i-k]] += 1
            result = max(result, curr)
        return result",O(n)
"
import collections



class Solution(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        killAll(kill, children, result)
        return result


",O(n)
"class Solution2(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        q = collections.deque()
        q.append(kill)
        while q:
            p = q.popleft()
            result.append(p)
            for child in children[p]:
                q.append(child)
        return result",O(n)
"

class Solution(object):
    def makeSmallestPalindrome(self, s):
        return """".join(min(s[i], s[~i]) for i in range(len(s)))
",O(n)
"class Solution(object):
    def maximumGain(self, s, x, y):
        def score(s, a, x):
            i = result = 0
            for j in range(len(s)):
                s[i] = s[j]
                i += 1
                if i >= 2 and s[i-2:i] == a:
                    i -= 2
                    result += x
            s[:] = s[:i]
            return result
                
        s, a, b = list(s), list(""ab""), list(""ba"")
        if x < y:
            x, y = y, x
            a, b = b, a
        return score(s, a, x) + score(s, b, y)",O(n)
"class Solution(object):
    def minimizeXor(self, num1, num2):
        def popcount(x):
            return bin(x)[2:].count('1')
        
        cnt1, cnt2 = popcount(num1), popcount(num2)
        result = num1
        cnt = abs(cnt1-cnt2)
        expect = 1 if cnt1 >= cnt2 else 0
        i = 0
        while cnt:
            if ((num1>>i)&1) == expect:
                cnt -= 1
                result ^= 1<<i
            i += 1
        return result",O(logn)
"class Solution(object):
    def winnerOfGame(self, colors):
        cnt1 = cnt2 = 0
        for i in range(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 > cnt2",O(n)
"class Solution(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for j in range(n+1):
            for i in reversed(range(j-1)):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]",O(n ^ 3)
"class Solution2(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for i in reversed(range(n)):
            for j in range(i+2, n+1):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]",O(n ^ 3)
"
import itertools


class Solution(object):
    def heightChecker(self, heights):
        return sum(i != j for i, j in zip(heights, sorted(heights)))
",O(nlogn)
"class Solution(object):

    def __init__(self, nestedList):
        self.__depth = [[nestedList, 0]]


    def __next__(self):
        nestedList, i = self.__depth[-1]
        self.__depth[-1][1] += 1
        return nestedList[i].getInteger()


    def hasNext(self):
        while self.__depth:
            nestedList, i = self.__depth[-1]
            if i == len(nestedList):
                self.__depth.pop()
            elif nestedList[i].isInteger():
                    return True
            else:
                self.__depth[-1][1] += 1
                self.__depth.append([nestedList[i].getList(), 0])
        return False",O(n)
"class Solution(object):
    def findScore(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: (nums[x], x))
        lookup = [False]*len(nums)
        result = 0
        for i in idxs:
            if lookup[i]:
                continue
            lookup[i] = True
            if i-1 >= 0:
                lookup[i-1] = True
            if i+1 < len(lookup):
                lookup[i+1] = True
            result += nums[i]
        return result",O(nlogn)
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) / 2
            if citations[mid] >= n - mid:
                right = mid - 1
            else:
                left = mid + 1
        return n - left",O(logn)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def maxDepth(self, root):
        if not root:
            return 0
        depth = 0
        for child in root.children:
            depth = max(depth, self.maxDepth(child))
        return 1+depth",O(n)
"class Solution(object):
    def isPathCrossing(self, path):
        x = y = 0
        lookup = {(0, 0)}
        for c in path:
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            if (x, y) in lookup:
                return True
            lookup.add((x, y))
        return False",O(n)
"class Solution(object):
    def average(self, salary):
        total, mi, ma = 0, float(""inf""), float(""-inf"")
        for s in salary:
            total += s
            mi, ma = min(mi, s), max(ma, s)
        return 1.0*(total-mi-ma)/(len(salary)-2)",O(n)
"class Solution2(object):
    def average(self, salary):
        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)",O(n)
"class Solution(object):
    def kLengthApart(self, nums, k):
        prev = -k-1
        for i in range(len(nums)):
            if not nums[i]:
                continue
            if i-prev <= k:
                return False
            prev = i
        return True",O(n)
"class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        result = 0
        for h in boxes:
            if h > warehouse[result]:
                continue
            result += 1
            if result == len(warehouse):
                break
        return result",O(nlogn)
"class Solution(object):
    def longestPrefix(self, s):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        return s[:getPrefix(s)[-1]+1]",O(n)
"class Solution2(object):
    def longestPrefix(self, s):
        M = 10**9+7
        D = 26
        def check(l, s):
            for i in range(l):
                if s[i] != s[len(s)-l+i]:
                    return False
            return True
    
        result, prefix, suffix, power = 0, 0, 0, 1
        for i in range(len(s)-1):
            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M
            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M
            power = (power*D)%M
            if prefix == suffix:
                result = i+1
        return s[:result]",O(n)
"class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        return [words[i] for i in range(n) if i == 0 or groups[i-1] != groups[i]]",O(n)
"import collections


class Solution(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        for nums in nums1, nums2, nums3:
            cnt.update(set(nums))
        return [x for x, c in cnt.items() if c >= K]",O(n)
"import collections


class Solution2(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        result = []
        for nums in nums1, nums2, nums3:
            for x in set(nums):
                cnt[x] += 1
                if cnt[x] == K:
                    result.append(x)
        return result",O(n)
"class Solution(object):
    def numberOfLines(self, widths, S):
        result = [1, 0]
        for c in S:
            w = widths[ord(c)-ord('a')]
            result[1] += w
            if result[1] > 100:
                result[0] += 1
                result[1] = w
        return result",O(n)
"class Solution(object):
    def findKthBit(self, n, k):
        flip, l = 0, 2**n-1
        while k > 1:
            if k == l//2+1:
                flip ^= 1
                break
            if k > l//2:
                k = l+1-k
                flip ^= 1
            l //= 2
        return str(flip)",O(n)
"class Solution(object):
    def maximumGroups(self, grades):
        return int(((1+8*len(grades))**0.5-1)/2.0)",O(1)
"class Solution(object):
    def getSmallestString(self, s):
        result = list(map(int, s))
        for i in range(len(s)-1):
            if result[i]%2 != result[i+1]%2:
                continue
            if result[i] > result[i+1]:
                result[i], result[i+1] = result[i+1], result[i]
                break
        return """".join(map(str, result))",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        return self.pathSumRecu([], [], root, sum)


    def pathSumRecu(self, result, cur, root, sum):
        if root is None:
            return result

        if root.left is None and root.right is None and root.val == sum:
            result.append(cur + [root.val])
            return result

        cur.append(root.val)
        self.pathSumRecu(result, cur, root.left, sum - root.val)
        self.pathSumRecu(result, cur,root.right, sum - root.val)
        cur.pop()
        return result

",O(n)
"class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])",O(n)
"import bisect



class Solution(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix, suffix = 0, sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            while not (left == right or (left and (total+prefix)//left <= flowers[left])):
                prefix += flowers[left]
                left += 1
            mn = min((total+prefix)//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"import bisect



class Solution2(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = min(left, right)
            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total):
                left -= 1
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"import bisect



class Solution3(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return x and (total+prefix[x])//x <= prefix[x+1]-prefix[x]

        def binary_search(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        suffix = sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = binary_search(prefix, total, 0, right-1)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"import bisect



class Solution4(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return (prefix[x]-prefix[x-1])*x-prefix[x] <= total

        def binary_search_right(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if not check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                break
            left = binary_search_right(prefix, total, 1, right)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result",O(n)
"import collections



class Solution(object):
    def subsequencesWithMiddleMode(self, nums):
        def nC2(x):
            return x*(x-1)//2

        MOD = 10**9+7
        result = 0
        left = collections.defaultdict(int)
        right = collections.defaultdict(int)
        for x in nums:
            right[x] += 1
        left_x_sq = 0 
        right_x_sq = sum(v**2 for v in right.values()) 
        left_x_right_x = 0 
        left_x_sq_right_x = 0 
        left_x_right_x_sq = 0 
        for i, v in enumerate(nums):
            left_x_sq -= left[v]**2
            right_x_sq -= right[v]**2
            left_x_right_x -= left[v]*right[v]
            left_x_sq_right_x -= left[v]**2*right[v]
            left_x_right_x_sq -= left[v]*right[v]**2
            right[v] -= 1

            l, r = i, len(nums)-(i+1)
            result += nC2(l)*nC2(r)
            result -= nC2(l-left[v])*nC2(r-right[v])
            result -= ((left_x_sq-(l-left[v]))*(r-right[v])-(left_x_sq_right_x-left_x_right_x))*right[v]//2
            result -= ((right_x_sq-(r-right[v]))*(l-left[v])-(left_x_right_x_sq-left_x_right_x))*left[v]//2
            result -= left[v]*left_x_right_x*(r-right[v])-left[v]*left_x_right_x_sq
            result -= right[v]*left_x_right_x*(l-left[v])-right[v]*left_x_sq_right_x
            result -= right[v]*(left_x_sq_right_x-left_x_right_x)//2
            result -= left[v]*(left_x_right_x_sq-left_x_right_x)//2

            left[v] += 1
            left_x_sq += left[v]**2
            right_x_sq += right[v]**2
            left_x_right_x += left[v]*right[v]
            left_x_sq_right_x += left[v]**2*right[v]
            left_x_right_x_sq += left[v]*right[v]**2
        return result % MOD",O(n)
"def get(self, index):
       pass

   def length(self):
       pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        def binarySearch(A, left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,
                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))
        left = binarySearch(mountain_arr, 0, peak,
                            lambda x: mountain_arr.get(x) >= target)
        if left <= peak and mountain_arr.get(left) == target:
            return left
        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,
                             lambda x: mountain_arr.get(x) <= target)
        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:
            return right
        return -1",O(logn)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2):
        cnt = [0]*2
        for x, y in zip(nums1, nums2):
            if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])):
                return -1
            if not (x <= nums1[-1] and y <= nums2[-1]):
                cnt[0] += 1
            if not (x <= nums2[-1] and y <= nums1[-1]):
                cnt[1] += 1
        return min(cnt)",O(n)
"import itertools



class Solution2(object):
    def minOperations(self, nums1, nums2):
        INF = float(""inf"")
        def count(mx1, mx2):
            return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in zip(nums1, nums2) if not (x <= mx1 and y <= mx2))

        result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1]))
        return result if result != INF else -1",O(n)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"import heapq



class Solution(object):
    def makePrefSumNonNegative(self, nums):
        result = prefix = 0
        min_heap = []
        for x in nums:
            heapq.heappush(min_heap, x)
            prefix += x
            if prefix < 0:
                prefix -= heapq.heappop(min_heap)
                result += 1
        return result",O(nlogn)
"import collections


class Solution(object):
    def pathSum(self, nums):
        class Node(object):
            def __init__(self, num):
                self.level = num/100 - 1
                self.i = (num%100)/10 - 1
                self.val = num%10
                self.leaf = True

            def isParent(self, other):
                return self.level == other.level-1 and \
                       self.i == other.i/2

        if not nums:
            return 0
        result = 0
        q = collections.deque()
        dummy = Node(10)
        parent = dummy
        for num in nums:
            child = Node(num)
            while not parent.isParent(child):
                result += parent.val if parent.leaf else 0
                parent = q.popleft()
            parent.leaf = False
            child.val += parent.val
            q.append(child)
        while q:
            result += q.pop().val
        return result",O(n)
"class Solution(object):
    def buildArray(self, nums):
        for i in range(len(nums)):
            prev, curr = i, nums[i]
            while curr >= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in range(len(nums)):
            if nums[i] < 0:
                nums[i] = ~nums[i]
        return nums",O(n)
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]",O(n)
"class Solution(object):
    def maxRotateFunction(self, A):
        s = sum(A)
        fi = 0
        for i in range(len(A)):
            fi += i * A[i]

        result = fi
        for i in range(1, len(A)+1):
            fi += s - len(A) * A[-i]
            result = max(result, fi)
        return result",O(n)
"import collections


class UnionFind(object): 
    def __init__(self, vals):
        self.set = list(range(len(vals)))
        self.rank = [0]*len(vals)
        self.cnt = [collections.Counter({v:1}) for v in vals]  

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y, v): 
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return 0 
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        cx, cy = self.cnt[x][v], self.cnt[y][v] 
        self.cnt[y] = collections.Counter({v:cx+cy}) 
        return cx*cy 



class Solution(object):
    def numberOfGoodPaths(self, vals, edges):
        edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]]))
        uf = UnionFind(vals)
        return len(vals)+sum(uf.union_set(i, j, max(vals[i], vals[j])) for i, j in edges)",O(nlogn)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findNeartestRightNode(self, root, u):
        q = [root]
        while q:
            new_q = []
            for i, node in enumerate(q):
                if node == u:
                    return q[i+1] if i+1 < len(q) else None
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            q = new_q
        return None",O(n)
"class Solution(object):
    def maxProfit(self, prices):
        max_profit, min_price = 0, float(""inf"")
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit",O(n)
"class Solution(object):
    def longestSubarray(self, nums):
        mx = max(nums)
        result, l = 1, 0
        for x in nums:
            if x == mx:
                l += 1
                result = max(result, l)
            else:
                l = 0
        return result",O(n)
"
import collections


class Solution(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        lookup = set()
        for v in count.values():
            if v in lookup:
                return False
            lookup.add(v)
        return True


",O(n)
"class Solution2(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        return len(count) == len(set(count.values()))",O(n)
"from collections import defaultdict

class Solution(object):
    def isRectangleCover(self, rectangles):
        left = min(rec[0] for rec in rectangles)
        bottom = min(rec[1] for rec in rectangles)
        right = max(rec[2] for rec in rectangles)
        top = max(rec[3] for rec in rectangles)

        points = defaultdict(int)
        for l, b, r, t in rectangles:
            for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):
                if points[p] & q:
                    return False
                points[p] |= q

        for px, py in points:
            if left < px < right or bottom < py < top:
                if points[(px, py)] not in (3, 5, 10, 12, 15):
                    return False

        return True",O(n)
"class Solution(object):
    def canWinNim(self, n):
        return n % 4 != 0",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def buildTree(self, inorder, postorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder))

    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(postorder[post_end - 1])
        i = lookup[postorder[post_end - 1]]
        node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i)
        node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end)
        return node",O(n)
"class Solution(object):
    def strangePrinter(self, s):
        def dp(s, i, j, lookup):
            if i > j:
                return 0
            if (i, j) not in lookup:
                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        lookup[(i, j)] = min(lookup[(i, j)], \
                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))
            return lookup[(i, j)]

        lookup = {}
        return dp(s, 0, len(s)-1, lookup)",O(n ^ 3)
"class Solution(object):
    def bestHand(self, ranks, suits):
        LOOKUP = ["""", ""High Card"", ""Pair"", ""Three of a Kind"", ""Three of a Kind"", ""Three of a Kind""]
        if all(suits[i] == suits[0] for i in range(1, len(suits))):
            return ""Flush""
        cnt = [0]*13
        for x in ranks:
            cnt[x-1] += 1
        return LOOKUP[max(cnt)]",O(1)
"class Solution(object):
    def getCommon(self, nums1, nums2):
        i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                return nums1[i]
        return -1",O(n)
"class Solution(object):
    def placedCoins(self, edges, cost):
        def iter_dfs():
            result = [0]*len(cost)
            stk = [(1, (0, -1, [cost[0]]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (u, ret)))
                    stk.append((2, (u, p, 0, ret)))
                elif step == 2:
                    u, p, i, ret = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, i+1, ret)))
                    if v == p:
                        continue
                    new_ret = [cost[v]]
                    stk.append((3, (new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret = args
                    ret.extend(new_ret)
                    ret.sort()
                    if len(ret) > 5:
                        ret = ret[:2]+ret[-3:]
                elif step == 4:
                    u, ret = args
                    result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0)
            return result
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def placedCoins(self, edges, cost):
        def dfs(u, p):
            arr = [cost[u]]
            for v in adj[u]:
                if v == p:
                    continue
                arr.extend(dfs(v, u))
                arr.sort()
                if len(arr) > 5:
                    arr = arr[:2]+arr[-3:]
            result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0)
            return arr
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*len(cost)
        dfs(0, -1)
        return result",O(nlogn)
"import bisect


class Solution(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        lis = []
        for x in arr:
            if x not in lookup:
                continue
            i = bisect.bisect_left(lis, lookup[x])
            if i == len(lis):
                lis.append(lookup[x])
            else:
                lis[i] = lookup[x]
        return len(target)-len(lis)
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution2(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        st = SegmentTree(len(lookup))
        for x in arr:
            if x not in lookup:
                continue
            st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] >= 1 else 1)
        return len(target)-(st.query(0, len(lookup)-1) if len(lookup) >= 1 else 0)",O(nlogn)
"class Solution(object):
    def isFascinating(self, n):
        lookup = [0]
        def check(x):
            while x:
                x, d = divmod(x, 10)
                if d == 0 or lookup[0]&(1<<d):
                    return False
                lookup[0] |= (1<<d)
            return True
    
        return check(n) and check(2*n) and check(3*n)",O(logn)
"class Solution2(object):
    def isFascinating(self, n):
        s = str(n)+str(2*n)+str(3*n)
        return '0' not in s and len(s) == 9 and len(set(s)) == 9",O(logn)
"class Solution(object):
    def countSubstrings(self, s, c):
        n = s.count(c)
        return (n+1)*n//2",O(n)
"import random
import itertools
import math




random.seed(0)
class Solution(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        def dist(a, b):
            if a[2] > b[2]:
                a, b = b, a
            return [abs(a[0]-b[0])+abs(a[1]-b[1]), a[2], b[2]]

        def cell(point, size):
            x, y, _ = point
            return math.floor(x/size), math.floor(y/size)

        def improve():
            lookup = {}
            for p in points:
                i, j = list(map(int, cell(p, result[0]/2.0)))
                for ni in range(i-2, (i+2)+1):
                    for nj in range(j-2, (j+2)+1):
                        if (ni, nj) not in lookup:
                            continue
                        d = dist(p, lookup[ni, nj])
                        if d < result:
                            result[:] = d
                            return True
                lookup[i, j] = p
            return False

        points = [(i, j, idx) for idx, (i, j) in enumerate(zip(nums1, nums2))]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i][:2] in lookup:
                result = [0, i, lookup[points[i][:2]]]
            lookup[points[i][:2]] = i
        if result[0] == 0:
            return result[1:]
        random.shuffle(points)
        result = dist(points[0], points[1])
        while improve():
            pass
        return result[1:]",other
"import itertools




class Solution2(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = (8+2)//2
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            def update(arr, i): 
                for j in reversed(range(len(arr))):
                    if points[i][1]-points[arr[j]][1] > result[0]:
                        break
                    result[:] = min(result, dist(i, arr[j]))
                else:
                    j = -1
                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)

            if left == right:
                return
            mid = left+(right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            tmp, tmp_l, tmp_r = [], [], []
            l, r = left, mid+1
            while l <= mid or r <= right:
                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): 
                    update(tmp_r, order[l])
                    if x-points[order[l]][0] <= result[0]: 
                        tmp_l.append(order[l])
                    tmp.append(order[l])
                    l += 1
                else:
                    update(tmp_l, order[r])
                    if points[order[r]][0]-x <= result[0]: 
                        tmp_r.append(order[r])
                    tmp.append(order[r])
                    r += 1
            order[left:right+1] = tmp

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"import itertools




class Solution3(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = 8
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            if left == right:
                return
            mid = left + (right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and points[order[r]][1] < points[order[l]][1]: 
                    tmp.append(order[r])
                    r += 1
                tmp.append(order[l])
            order[left:left+len(tmp)] = tmp

            stripe = [order[i] for i in range(left, right+1) if abs(points[order[i]][0]-x) <= result[0]]
            for i in range(len(stripe)-1):
                for j in range(i+1, len(stripe)):
                    x, y = stripe[i], stripe[j]
                    if points[y][1]-points[x][1] > result[0]:
                        break
                    result[:] = min(result, dist(x, y))
                else:
                    j = len(stripe)
                assert(j-(i+1) <= MAX_NEIGHBOR_COUNT)

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"import itertools



class Solution4(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: [-INF, -INF], 
                         query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                         update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return [-INF, -INF] 
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        y_set = set(y for _, y in points)
        y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}
        st1, st2 = SegmentTree(len(y_to_idx)), SegmentTree(len(y_to_idx))
        for i in order:
            j = -st1.query(0, y_to_idx[points[i][1]]-1)[1] 
            if j != INF:
                assert(points[j][1] < points[i][1])
                result = min(result, dist(i, j))
            st1.update(y_to_idx[points[i][1]], [points[i][0]+points[i][1], -i])
            j = -st2.query(y_to_idx[points[i][1]], len(y_to_idx)-1)[1] 
            if j != INF:
                assert(points[j][1] >= points[i][1])
                result = min(result, dist(i, j))
            st2.update(y_to_idx[points[i][1]], [points[i][0]-points[i][1], -i])
        return result[1:]",O(nlogn)
"class Solution(object):
    def confusingNumber(self, N):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        
        S = str(N)
        result = []
        for i in range(len(S)):
            if S[i] not in lookup:
                return False
        for i in range((len(S)+1)//2):
            if S[i] != lookup[S[-(i+1)]]:
                return True
        return False",O(logn)
"class Solution(object):
    def pathsWithMaxScore(self, board):
        MOD = 10**9+7
        directions = [[1, 0], [0, 1], [1, 1]]
        dp = [[[0, 0] for r in range(len(board[0])+1)]
              for r in range(2)]
        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]
        for r in reversed(range(len(board))):
            for c in reversed(range(len(board[0]))):
                if board[r][c] in ""XS"":
                    continue
                dp[r%2][c] = [0, 0]
                for dr, dc in directions:
                    if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]
                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD
                if dp[r%2][c][1] and board[r][c] != 'E':
                    dp[r%2][c][0] += int(board[r][c])
        return dp[0][0]",O(n ^ 2)
"import collections



class Solution(object):
    def countSubarrays(self, nums, k):
        idx = nums.index(k)
        lookup = collections.Counter()
        curr = 0
        for i in reversed(range(idx+1)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            lookup[curr] += 1
        result = curr = 0
        for i in range(idx, len(nums)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            result += lookup[-curr]+lookup[-(curr-1)]
        return result",O(n)
"class Solution(object):
    def racecar(self, target):
        dp = [0] * (target+1)
        for i in range(1, target+1):
            k = i.bit_length()

            if i == 2**k-1:
                dp[i] = k
                continue

            dp[i] = k+1 + dp[2**k-1 - i]

            for j in range(k-1):
                dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j])

        return dp[-1]",O(nlogn)
"class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):
        result = duration * len(timeSeries)
        for i in range(1, len(timeSeries)):
            result -= max(0, duration - (timeSeries[i] - timeSeries[i-1]))
        return result",O(n)
"class Solution(object):
    def findErrorNums(self, nums):
        x_xor_y = 0
        for i in range(len(nums)):
            x_xor_y ^= nums[i] ^ (i+1)
        bit = x_xor_y & ~(x_xor_y-1)
        result = [0] * 2
        for i, num in enumerate(nums):
            result[bool(num & bit)] ^= num
            result[bool((i+1) & bit)] ^= i+1
        if result[0] not in nums:
            result[0], result[1] = result[1], result[0]
        return result",O(n)
"class Solution2(object):
    def findErrorNums(self, nums):
        result = [0] * 2
        for i in nums:
            if nums[abs(i)-1] < 0:
                result[0] = abs(i)
            else:
                nums[abs(i)-1] *= -1
        for i in range(len(nums)):
            if nums[i] > 0:
                result[1] = i+1
            else:
                nums[i] *= -1
        return result",O(n)
"class Solution3(object):
    def findErrorNums(self, nums):
        N = len(nums)
        x_minus_y = sum(nums) - N*(N+1)//2
        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y
        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2",O(n)
"class Solution(object):
    def maxRectangleArea(self, xCoord, yCoord):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points = sorted((xCoord[i], yCoord[i]) for i in range(len(xCoord)))
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(yCoord)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"class Solution(object):
    def minCost(self, n, cuts):
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in range(len(sorted_cuts))]
        for l in range(2, len(sorted_cuts)):
            for i in range(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in range(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]",O(n ^ 3)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def swapNodes(self, head, k):
        left, right, curr = None, None, head
        while curr:
            k -= 1
            if right:
                right = right.__next__
            if k == 0:
                left = curr
                right = head
            curr = curr.__next__
        left.val, right.val = right.val, left.val
        return head",O(n)
"import collections


class Solution(object):
    def countPairs(self, deliciousness):
        def floor_log2_x(x):
            return x.bit_length()-1

        MOD = 10**9+7
        max_pow = floor_log2_x(max(deliciousness))+1
        cnt = collections.Counter()
        result = 0
        for d in deliciousness:
            p = 1
            for i in range(max_pow+1):
                result = (result+cnt[p-d])%MOD
                p <<= 1
            cnt[d] += 1    
        return result",other
"class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False",O(n)
"import collections


class Solution(object):
    def findClosestLeaf(self, root, k):
        def traverse(node, neighbors, leaves):
            if not node:
                return
            if not node.left and not node.right:
                leaves.add(node.val)
                return
            if node.left:
                neighbors[node.val].append(node.left.val)
                neighbors[node.left.val].append(node.val)
                traverse(node.left, neighbors, leaves)
            if node.right:
                neighbors[node.val].append(node.right.val)
                neighbors[node.right.val].append(node.val)
                traverse(node.right, neighbors, leaves)

        neighbors, leaves = collections.defaultdict(list), set()
        traverse(root, neighbors, leaves)
        q, lookup = [k], set([k])
        while q:
            next_q = []
            for u in q:
                if u in leaves:
                    return u
                for v in neighbors[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    next_q.append(v)
            q = next_q
        return 0",O(n)
"class Solution(object):
    def largestDivisibleSubset(self, nums):
        if not nums:
            return []

        nums.sort()
        dp = [1] * len(nums)
        prev = [-1] * len(nums)
        largest_idx = 0
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    if dp[i] < dp[j] + 1:
                        dp[i] = dp[j] + 1
                        prev[i] = j
            if dp[largest_idx] < dp[i]:
                largest_idx = i

        result = []
        i = largest_idx
        while i != -1:
            result.append(nums[i])
            i = prev[i]
        return result[::-1]",O(n ^ 2)
"class Solution(object):
    def findTheLongestSubstring(self, s):
        VOWELS = ""aeiou""
        result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS))
        lookup[0] = -1
        for i, c in enumerate(s):
            index = VOWELS.find(c)
            mask ^= (1 << index) if index >= 0 else 0
            if lookup[mask] == -2:
                lookup[mask] = i
            result = max(result, i-lookup[mask])
        return result",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def equationsPossible(self, equations):
        union_find = UnionFind(26)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '=':
                union_find.union_set(x, y)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if union_find.find_set(x) == union_find.find_set(y):
                    return False
        return True",O(n)
"class Solution2(object):
    def equationsPossible(self, equations):
        graph = [[] for _ in range(26)]

        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if x == y:
                    return False
            else:
                graph[x].append(y)
                graph[y].append(x)

        color = [None]*26
        c = 0
        for i in range(26):
            if color[i] is not None:
                continue
            c += 1
            stack = [i]
            while stack:
                node = stack.pop()
                for nei in graph[node]:
                    if color[nei] is not None:
                        continue
                    color[nei] = c
                    stack.append(nei)

        for eqn in equations:
            if eqn[1] != '!':
                continue
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if color[x] is not None and \
               color[x] == color[y]:
                return False
        return True",O(n)
"class Solution(object):
    def divisibilityArray(self, word, m):
        result = []
        curr = 0
        for c in word:
            curr = (curr*10+(ord(c)-ord('0')))%m
            result.append(int(curr == 0))
        return result",O(n)
"class Solution(object):
    def getMaximumXor(self, nums, maximumBit):
        result = [0]*len(nums)
        mask = 2**maximumBit-1
        for i in range(len(nums)):
            mask ^= nums[i]
            result[-1-i] = mask
        return result",O(n)
"import bisect



class Solution(object):
    def maxPathLength(self, coordinates, k):
        def longest_increasing_subsequence(arr):
            result = []
            for x in arr:
                i = bisect.bisect_left(result, x)
                if i == len(result):
                    result.append(x)
                else:
                    result[i] = x
            return len(result)

        target = coordinates[k]
        coordinates.sort(key=lambda x: (x[0], -x[1]))
        left, right = [], []
        for x, y in coordinates:
            if x < target[0] and y < target[1]:
                left.append(y)
            elif x > target[0] and y > target[1]:
                right.append(y)
        return longest_increasing_subsequence(left)+1+longest_increasing_subsequence(right)",O(nlogn)
"class Solution(object):
    def minConnectedGroups(self, intervals, k):
        intervals.sort()
        result = 0
        prefix = [0]*(len(intervals)+1)
        mx = float(""-inf"")
        left = 0
        for right in range(len(intervals)):
            prefix[right+1] = prefix[right]+int(mx < intervals[right][0])
            mx = max(mx, intervals[right][1])
            while intervals[right][0]-intervals[left][1] > k:
                left += 1
            result = max(result, prefix[right+1]-prefix[left+1])
        return prefix[-1]-result",O(nlogn)
"class Solution(object):
    def validPalindrome(self, s):
        def validPalindrome(s, left, right):
            while left < right:
                if s[left] != s[right]:
                    return False
                left, right = left+1, right-1
            return True

        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)
            left, right = left+1, right-1
        return True",O(n)
"class Solution(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) < k:
            if m-arr[left] > arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result",O(nlogn)
"class Solution2(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        arr.sort(key=lambda x: (-abs(x-m), -x))
        return arr[:k]",O(nlogn)
"import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        nth_element(arr, (len(arr)-1)//2)
        m = arr[(len(arr)-1)//2]
        nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)
        return arr[:k]",O(n)
"class Solution(object):
    def nextPalindrome(self, num):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        nums = list(num)
        if not next_permutation(nums, 0, len(nums)//2):
            return """"
        for i in range(len(nums)//2):
            nums[-1-i] = nums[i]
        return """".join(nums)",O(n)
"class Solution(object):
    def rob(self, nums):
        if len(nums) == 0:
            return 0

        if len(nums) == 1:
            return nums[0]

        return max(self.robRange(nums, 0, len(nums) - 1),\
                   self.robRange(nums, 1, len(nums)))

    def robRange(self, nums, start, end):
        num_i, num_i_1 = nums[start], 0
        for i in range(start + 1, end):
            num_i_1, num_i_2 = num_i, num_i_1
            num_i = max(nums[i] + num_i_2, num_i_1)

        return num_i",O(n)
"class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) / 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        reverse(s, 0, len(s))
        i = 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        head = dummy = ListNode(next=head)
        while head:
            for _ in range(m):
                if not head.__next__:
                    return dummy.__next__
                head = head.__next__
            prev = head
            for _ in range(n):
                if not head.__next__:
                    prev.next = None
                    return dummy.__next__
                head = head.__next__
            prev.next = head.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def beautifulSplits(self, nums):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        result = 0
        z0 = z_function(nums)
        for i in range(1, len(nums)-1):
            zi = z_function(nums[i:])
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"class Solution2(object):
    def beautifulSplits(self, nums):
        dp = [[0]*len(nums) for _ in range(len(nums))]
        for i in reversed(range(len(nums))):
            for j in range(i+1, len(dp)):
                dp[i][j] = 1+(dp[i+1][j+1] if j+1 < len(nums) else 0) if nums[i] == nums[j] else 0
        result = 0
        for i in range(1, len(nums)-1):
            for j in range(i+1, len(nums)):
                if (dp[0][i] >= i and j-i >= i) or dp[i][j] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"class Solution_TLE(object):
    def beautifulSplits(self, nums):
        def z_function(s, left, right): 
            z = [0]*(right-left+1)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[left+z[i]] == s[left+i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z
        
        result = 0
        z0 = z_function(nums, 0, len(nums)-1)
        for i in range(1, len(nums)-1):
            zi = z_function(nums, i, len(nums)-1)
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"import collections


class Solution(object):
    def recoverArray(self, nums):
        def check(k, cnt, result):
            for x in nums:
                if cnt[x] == 0:
                    continue
                if cnt[x+2*k] == 0:
                    return False
                cnt[x] -= 1
                cnt[x+2*k] -= 1
                result.append(x+k)
            return True
            
        nums.sort()
        cnt = collections.Counter(nums)
        for i in range(1, len(nums)//2+1):
            k = nums[i]-nums[0]
            if k == 0 or k%2:
                continue
            k //= 2
            result = []
            if check(k, collections.Counter(cnt), result):
                return result
        return []",O(n ^ 2)
"class Solution(object):
    def makeArrayPositive(self, nums):
        MAX_VAL = 10**18
        result = 0
        prev1 = nums[0]+nums[1]
        prev2 = nums[0]
        max_prev3 = 0
        for i in range(2, len(nums)):
            prefix = prev1+nums[i]
            if prefix-max_prev3 <= 0:
                prefix = prev1+MAX_VAL
                result += 1
            max_prev3 = max(max_prev3, prev2)
            prev1, prev2 = prefix, prev1
        return result",O(n)
"class Solution(object):
    def isSameAfterReversals(self, num):
        return num == 0 or num%10",O(1)
"class Solution(object):
    def minSwaps(self, nums):
        result = cnt = w = nums.count(1)
        for i in range(len(nums)+(w-1)):
            if i >= w:
                cnt += nums[(i-w)%len(nums)]
            cnt -= nums[i%len(nums)]
            result = min(result, cnt)
        return result",O(n)
"nums = [0, 1]
dp = [0, 1]
class Solution(object):
    def getMaximumGenerated(self, n):
        if n+1 > len(dp):
            for i in range(len(nums), n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2] + nums[i//2+1])
                dp.append(max(dp[-1], nums[-1]))
        return dp[n]",O(n)
"class Solution2(object):
    def getMaximumGenerated(self, n):
        if n == 0:
            return 0
        nums = [0]*(n+1)
        nums[1] = 1
        result = 1
        for i in range(2, n+1):
            if i%2 == 0:
                nums[i] = nums[i//2]
            else:
                nums[i] = nums[i//2] + nums[i//2+1]
            result = max(result, nums[i])
        return result",O(n)
"class Solution(object):
    def maxKDivisibleComponents(self, n, edges, values, k):
        def bfs():
            result = 0
            dp = [x%k for x in values]
            cnt = [len(adj[u]) for u in range(len(adj))]
            q = [u for u in range(n) if cnt[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if not dp[u]:
                        result += 1
                    for v in adj[u]:
                        dp[v] = (dp[v]+dp[u])%k
                        cnt[v] -= 1
                        if cnt[v] == 1:
                            new_q.append(v)
                q = new_q
            return max(result, 1)

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs()",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def deleteDuplicates(self, head):
        cur = head
        while cur:
            runner = cur.__next__
            while runner and runner.val == cur.val:
                runner = runner.__next__
            cur.next = runner
            cur = runner
        return head

    def deleteDuplicates2(self, head):
        if not head: return head
        if head.__next__:
            if head.val == head.next.val:
                head = self.deleteDuplicates2(head.__next__)
            else:
                head.next = self.deleteDuplicates2(head.next)
        return head",O(n)
"class Solution(object):
    def countGoodRectangles(self, rectangles):
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side > mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result",O(n)
"class Solution(object):
    def findSubstringInWraproundString(self, p):
        letters = [0] * 26
        result, length = 0, 0
        for i in range(len(p)):
            curr = ord(p[i]) - ord('a')
            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):
                length = 0
            length += 1
            if length > letters[curr]:
                result += length - letters[curr]
                letters[curr] = length
        return result",O(n)
"

class Solution(object):
    def restoreString(self, s, indices):
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return """".join(result)


",O(n)
"import itertools


class Solution2(object):
    def restoreString(self, s, indices):
        result = ['']*len(s)
        for i, c in zip(indices, s):
            result[i] = c
        return """".join(result)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):
        def iter_dfs(root, lookup):
            result = [0]
            stk = [(1, (root, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node or node in lookup:
                        ret[0] = node
                        continue
                    ret1, ret2 = [None], [None]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if ret1[0] and ret2[0]:
                        ret[0] = node
                    else:
                        ret[0] = ret1[0] or ret2[0]
            return result[0]
        
        return iter_dfs(root, set(nodes))",O(n)
"class Solution2(object):
    def lowestCommonAncestor(self, root, nodes):
        def dfs(node, lookup):
            if not node or node in lookup:
                return node
            left, right = dfs(node.left, lookup), dfs(node.right, lookup)
            if left and right:
                return node
            return left or right
        
        return dfs(root, set(nodes))",O(n)
"class Solution(object):
    def getSmallestString(self, n, k):
        MAX_DIFF = ord('z')-ord('a')

        k -= n
        result = ['a']*n
        for i in reversed(range(n)):
            tmp = min(k, MAX_DIFF)
            result[i] = chr(ord('a')+tmp)
            k -= tmp
            if k == 0:
                break
        return """".join(result)",O(n)
"import collections



class Solution(object):
    def countNonDecreasingSubarrays(self, nums, k):
        result = cnt = 0
        dq = collections.deque()
        right = len(nums)-1
        for left in reversed(range(len(nums))):
            while dq and nums[dq[-1]] < nums[left]:
                l = dq.pop()
                r = dq[-1]-1 if dq else right
                cnt += (r-l+1)*(nums[left]-nums[l])
            dq.append(left)
            while cnt > k:
                cnt -= nums[dq[0]]-nums[right]
                if dq[0] == right:
                    dq.popleft()
                right -= 1
            result += right-left+1
        return result",O(n)
"class Solution(object):
    def countWays(self, ranges):
        MOD = 10**9+7

        ranges.sort()
        cnt = 0
        curr = float(""-inf"")
        for l, r in ranges:
            if l > curr:
                cnt += 1
            curr = max(curr, r)
        return pow(2, cnt, MOD)",O(nlogn)
"class Solution(object):
    def minMaxGame(self, nums):
        n = len(nums)
        while n != 1:
            new_q = []
            for i in range(n//2):
                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]",O(n)
"class Solution2(object):
    def minMaxGame(self, nums):
        q = nums[:]
        while len(q) != 1:
            new_q = []
            for i in range(len(q)//2):
                new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1]))
            q = new_q
        return q[0]",O(n)
"class Solution(object):
    def minCost(self, nums, x):
        def accumulate(a):
            for i in range(len(a)-1):
                a[i+1] += a[i]
            return a

        i = min(range(len(nums)), key=lambda x: nums[x])
        nums = nums[i:]+nums[:i]
        left, right = [-1]*len(nums), [len(nums)]*len(nums)
        stk = []
        for i in range(len(nums)):
            while stk and nums[stk[-1]] > nums[i]:
                right[stk.pop()] = i
            if stk:
                left[i] = stk[-1]
            stk.append(i)
        diff2 = [0]*(len(nums)+1)
        diff2[0] = (+1)*sum(nums)            
        diff2[1] = x                         
        diff2[-1] += (-1)*nums[0]            
        for i in range(1, len(nums)):
            l, r = i-left[i], right[i]-i
            diff2[min(l, r)] += (-1)*nums[i] 
            diff2[max(l, r)] += (-1)*nums[i] 
            diff2[l+r] += (+1)*nums[i]       
        return min(accumulate(accumulate(diff2)))",O(n)
"import collections



class Solution2(object):
    def minCost(self, nums, x):
        def cost(k):
            w = k+1
            result = x*k
            dq = collections.deque()
            for i in range(len(nums)+w-1):
                if dq and i-dq[0] == w:
                    dq.popleft()
                while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]:
                    dq.pop()
                dq.append(i)
                if i >= w-1:
                    result += nums[dq[0]%len(nums)]
            return result

        def check(x):
            return cost(x) <= cost(x+1)

        left, right = 0, len(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return cost(left)",O(nlogn)
"class Solution3(object):
    def minCost(self, nums, x):
        result = [x*k for k in range(len(nums)+1)]
        for i in range(len(nums)):
            curr = nums[i]
            for k in range(len(result)):
                curr = min(curr, nums[(i+k)%len(nums)])
                result[k] += curr
        return min(result)",O(n ^ 2)
"class Solution(object):
    def maximumProduct(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        total = sum(nums)
        for i in reversed(range(len(nums))):
            if nums[i]*(i+1)-total <= k:
                break
            total -= nums[i]
        q, r = divmod(k+total, i+1)
        return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)*
                reduce(lambda x, y: x*y%MOD, (nums[j] for j in range(i+1, len(nums))), 1)) % MOD",O(nlogn)
"import collections
import random
from functools import reduce



class Solution(object):
    def countKSubsequencesWithMaxBeauty(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        cnt = collections.Counter(s)
        if len(cnt) < k:
            return 0
        freqs = list(cnt.values())
        nth_element(freqs, k-1, lambda a, b: a > b)
        n = freqs.count(freqs[k-1])
        r = sum(freqs[i] == freqs[k-1] for i in range(k))
        return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in range(k)), 1)*nCr(n, r)%MOD",O(n)
"class Solution(object):
    def exclusiveTime(self, n, logs):
        result = [0] * n
        stk, prev = [], 0
        for log in logs:
            tokens = log.split("":"")
            if tokens[1] == ""start"":
                if stk:
                    result[stk[-1]] += int(tokens[2]) - prev
                stk.append(int(tokens[0]))
                prev = int(tokens[2])
            else:
                result[stk.pop()] += int(tokens[2]) - prev + 1
                prev = int(tokens[2]) + 1
        return result",O(n)
"class Solution(object):
    def sumScores(self, s):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(s)
        z[0] = len(s)
        return sum(z)",O(n)
"import math
import random


class Solution(object):
    def minimizeError(self, prices, target):
        def kthElement(nums, k, compare=lambda a, b: a < b):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        errors = []
        lower, upper = 0, 0
        for i, p in enumerate(map(float, prices)):
            lower += int(math.floor(p))
            upper += int(math.ceil(p))
            if p != math.floor(p):
                errors.append(p-math.floor(p))
        if not lower <= target <= upper:
            return ""-1""

        lower_round_count = upper-target
        kthElement(errors, lower_round_count)
        result = 0.0
        for i in range(len(errors)):
            if i < lower_round_count:
                result += errors[i]
            else:
                result += 1.0-errors[i]
        return ""{:.3f}"".format(result)",O(n)
"import collections

class Solution(object):
    def findRepeatedDnaSequences(self, s):
        dict, rolling_hash, res = {}, 0, []

        for i in range(len(s)):
            rolling_hash = ((rolling_hash << 3) & 0x3fffffff) | (ord(s[i]) & 7)
            if rolling_hash not in dict:
                dict[rolling_hash] = True
            elif dict[rolling_hash]:
                res.append(s[i - 9: i + 1])
                dict[rolling_hash] = False
        return res

    def findRepeatedDnaSequences2(self, s):
        l, r = [], []
        if len(s) < 10: return []
        for i in range(len(s) - 9):
            l.extend([s[i:i + 10]])
        return [k for k, v in list(collections.Counter(l).items()) if v > 1]",O(n)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(salary=2*employees[""salary""])",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


import collections



class Solution(object):
    def flipEquiv(self, root1, root2):
        dq1, dq2 = collections.deque([root1]), collections.deque([root2])
        while dq1 and dq2:
            node1, node2 = dq1.pop(), dq2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                dq1.extend([node1.right, node1.left])
            else:
                dq1.extend([node1.left, node1.right])
            dq2.extend([node2.left, node2.right])
        return not dq1 and not dq2",O(n)
"class Solution2(object):
    def flipEquiv(self, root1, root2):
        stk1, stk2 = [root1], [root2]
        while stk1 and stk2:
            node1, node2 = stk1.pop(), stk2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                stk1.extend([node1.right, node1.left])
            else:
                stk1.extend([node1.left, node1.right])
            stk2.extend([node2.left, node2.right])
        return not stk1 and not stk2",O(n)
"class Solution3(object):
    def flipEquiv(self, root1, root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2 or root1.val != root2.val:
            return False

        return (self.flipEquiv(root1.left, root2.left) and
                self.flipEquiv(root1.right, root2.right) or
                self.flipEquiv(root1.left, root2.right) and
                self.flipEquiv(root1.right, root2.left))",O(n)
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"class Solution(object):
    def firstBadVersion(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if isBadVersion(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left",O(logn)
"class Solution(object):
    def makeTheIntegerZero(self, num1, num2):
        def popcount(x):
            result = 0
            while x:
                x &= (x-1)
                result += 1
            return result

        for i in range(1, 60+1):
            if num1-i*num2 < 0:
                break
            if popcount(num1-i*num2) <= i <= num1-i*num2:
                return i
        return -1",O(1)
"import collections



class Solution(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if (nums[i]+nums[j])%d in cnt:
                    result += cnt[(nums[i]+nums[j])%d]
            cnt[-nums[i]%d] += 1
        return result",O(n ^ 2)
"import collections



class Solution2(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if nums[i]%d in cnt:
                result += cnt[nums[i]%d]
            for j in range(i):
                cnt[-(nums[i]+nums[j])%d] += 1
        return result",O(n ^ 2)
"import collections



class Solution3(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        for i in range(len(nums)):
            cnt = collections.Counter()
            for j in range(i+1, len(nums)):
                result += cnt[nums[j]%d]
                cnt[-(nums[i]+nums[j])%d] += 1
        return result",O(n ^ 2)
"import collections


class Solution(object):

    def __init__(self):
        self.__freq = collections.Counter()
        self.__group = collections.defaultdict(list)
        self.__maxfreq = 0

    def push(self, x):
        self.__freq[x] += 1
        if self.__freq[x] > self.__maxfreq:
            self.__maxfreq = self.__freq[x]
        self.__group[self.__freq[x]].append(x)   

    def pop(self):
        x = self.__group[self.__maxfreq].pop()
        if not self.__group[self.__maxfreq]:
            self.__group.pop(self.__maxfreq)
            self.__maxfreq -= 1
        self.__freq[x] -= 1
        if not self.__freq[x]:
            self.__freq.pop(x)
        return x",O(1)
"class Solution(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        fact = [0]*len(perm)
        fact[0] = 1
        for i in range(len(fact)-1):
            fact[i+1] = ((i+1)*fact[i])%MOD
        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*fact[(len(perm)-1)-i])%MOD))%MOD
            bit.add(x-1, +1)
        return result",O(nlogn)
"class Solution2(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        fact = [1]*2            
        def factorial(n):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact) % MOD)
            return fact[n]

        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*factorial((len(perm)-1)-i))%MOD))%MOD
            bit.add(x-1, +1)
        return result",O(nlogn)
"from collections import deque

class Solution(object):

    def __init__(self, size):
        self.__size = size
        self.__sum = 0
        self.__q = deque()

    def next(self, val):
        if len(self.__q) == self.__size:
            self.__sum -= self.__q.popleft()
        self.__sum += val
        self.__q.append(val)
        return 1.0 * self.__sum / len(self.__q)",O(1)
"class Solution(object):
    def threeSumSmaller(self, nums, target):
        nums.sort()
        n = len(nums)

        count, k = 0, 2
        while k < n:
            i, j = 0, k - 1
            while i < j: 
                if nums[i] + nums[j] + nums[k] >= target:
                    j -= 1
                else:
                    count += j - i
                    i += 1
            k += 1

        return count",O(n ^ 2)
"import collections



class Solution(object):
    def taskSchedulerII(self, tasks, space):
        lookup = collections.defaultdict(int)
        result = 0
        for t in tasks:
            result = max(lookup[t], result+1)
            lookup[t] = result+space+1
        return result",O(n)
"class Solution(object):
    def plusOne(self, digits):
        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        digits[0] = 1
        digits.append(0)
        return digits",O(n)
"class Solution2(object):
    def plusOne(self, digits):
        result = digits[::-1]
        carry = 1
        for i in range(len(result)):
            result[i] += carry
            carry, result[i] = divmod(result[i], 10)
        if carry:
            result.append(carry)
        return result[::-1]",O(n)
"class Solution(object):
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
        return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] \
               if tomatoSlices%2 == 0 and 2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices \
               else []",O(1)
"class Solution(object):
    def countValidWords(self, sentence):
        result = token = hyphen = 0
        for i in range(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in ""!.,"" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result",O(n)
"class Solution(object):
    def isValid(self, code):
        def validText(s, i):
            j = i
            i = s.find(""<"", i)
            return i != j, i

        def validCData(s, i):
            if s.find(""<![CDATA["", i) != i:
                return False, i
            j = s.find(""]]>"", i)
            if j == -1:
                return False, i
            return True, j+3

        def parseTagName(s, i):
            if s[i] != '<':
                return """", i
            j = s.find('>', i)
            if j == -1 or not (1 <= (j-1-i) <= 9):
                return """", i
            tag = s[i+1:j]
            for c in tag:
                if not (ord('A') <= ord(c) <= ord('Z')):
                    return """", i
            return tag, j+1

        def parseContent(s, i):
            while i < len(s):
                result, i = validText(s, i)
                if result:
                    continue
                result, i = validCData(s, i)
                if result:
                    continue
                result, i = validTag(s, i)
                if result:
                    continue
                break
            return i

        def validTag(s, i):
            tag, j = parseTagName(s, i)
            if not tag:
                return False, i
            j = parseContent(s, j)
            k = j + len(tag) + 2
            if k >= len(s) or s[j:k+1] != ""</"" + tag + "">"":
                return False, i
            return True, k+1

        result, i = validTag(code, 0)
        return result and i == len(code)",O(n)
"class UnionFind(object): 
    def __init__(self, nums):
        self.set = list(range(len(nums)))
        self.rank = [0]*len(nums)
        self.size = nums[:]

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]



class Solution(object):
    def maximumSegmentSum(self, nums, removeQueries):
        result = [0]*len(removeQueries)
        lookup = [0]*len(nums)
        uf = UnionFind(nums)
        for i in reversed(range(1, len(removeQueries))): 
            q = removeQueries[i]
            lookup[q] = 1
            if q-1 >= 0 and lookup[q-1]:
                uf.union_set(q-1, q)
            if q+1 < len(nums) and lookup[q+1]:
                uf.union_set(q, q+1)
            result[i-1] = max(result[i], uf.total(q))   
        return result",O(n)
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumSegmentSum(self, nums, removeQueries):
        removed_idxs = SortedList([-1, len(nums)])
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        segments = SortedList([prefix[-1]])
        result = []
        for q in removeQueries: 
            removed_idxs.add(q)
            i = removed_idxs.bisect_left(q)
            left, right = removed_idxs[i-1], removed_idxs[i+1]
            segments.remove(prefix[right]-prefix[left+1])
            segments.add(prefix[q]-prefix[left+1])
            segments.add(prefix[right]-prefix[q+1])
            result.append(segments[-1])
        return result",O(nlogn)
"class Solution(object):
    def minAddToMakeValid(self, S):
        add, bal, = 0, 0
        for c in S:
            bal += 1 if c == '(' else -1
            if bal == -1:
                add += 1
                bal += 1
        return add + bal",O(n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __str__(self):
        if self:
            return ""{}"".format(self.val)
        else:
            return None

class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                fast = head
                while fast is not slow:
                    fast, slow = fast.__next__, slow.__next__
                return fast
        return None

",O(n)
"

class CategoryHandler:
    def haveSameCategory(self, a, b):
        pass



class Solution(object):
    def numberOfCategories(self, n, categoryHandler):
        return sum(all(not categoryHandler.haveSameCategory(j, i) for j in range(i)) for i in range(n))
",O(n ^ 2)
"class Solution(object):
    def minimumTime(self, nums1, nums2, x):
        dp = [0]*(len(nums1)+1)
        for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):
            for j in reversed(range(1, i+1)):
                dp[j] = max(dp[j], dp[j-1]+(a+j*b))
        total1, total2 = sum(nums1), sum(nums2)
        return next((j for j in range(len(dp)) if (total1+j*total2)-dp[j] <= x), -1)",O(n ^ 2)
"import collections



class Solution(object):
    def minOperations(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        cnt = collections.Counter(nums)
        return sum(ceil_divide(x, 3) for x in cnt.values()) if all(x >= 2 for x in cnt.values()) else -1",O(n)
"class Solution(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(2)]
            for i in range(start, end):
                for j in reversed(range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):
                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])
            return dp[(end-1)%2][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"class Solution2(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(3)]
            for i in range(start, end):
                for j in range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):
                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])
            return dp[(end-1)%3][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"import itertools


class Solution(object):
    def largestTimeFromDigits(self, A):
        result = """"
        for i in range(len(A)):
            A[i] *= -1
        A.sort()
        for h1, h2, m1, m2 in itertools.permutations(A):
            hours = -(10*h1 + h2)
            mins = -(10*m1 + m2)
            if 0 <= hours < 24 and 0 <= mins < 60:
                result = ""{:02}:{:02}"".format(hours, mins)
                break
        return result",O(1)
"class Solution(object):
    def orderlyQueue(self, S, K):
        if K == 1:
            return min(S[i:] + S[:i] for i in range(len(S)))
        return """".join(sorted(S))",O(n ^ 2)
"class Solution(object):
    def minimumOneBitOperations(self, n):
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n >>= 1
            return result
        return gray_to_binary(n)",O(logn)
"class Solution2(object):
    def minimumOneBitOperations(self, n):
        result = 0
        while n:
            result = -result - (n^(n-1)) 
            n &= n-1
        return abs(result)",O(logn)
"import collections


class Solution(object):
    def minReorder(self, n, connections):
        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        result = 0
        stk = [(-1, 0)]
        while stk:
            parent, u = stk.pop()
            result += (parent*n+u in lookup)
            for v in reversed(graph[u]):
                if v == parent:
                    continue
                stk.append((u, v))
        return result",O(n)
"import collections


class Solution2(object):
    def minReorder(self, n, connections):
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)",O(n)
"class Solution(object):
    def isConvex(self, points):
        def det(A):
            return A[0][0]*A[1][1] - A[0][1]*A[1][0]

        n, prev, curr = len(points), 0, None
        for i in range(len(points)):
            A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)]
            curr = det(A)
            if curr:
                if curr * prev < 0:
                    return False
                prev = curr
        return True",O(n)
"class Solution(object):
    def sortColors(self, nums):
        def triPartition(nums, target):
            i, left, right = 0, 0, len(nums)-1
            while i <= right:
                if nums[i] > target:
                    nums[i], nums[right] = nums[right], nums[i]
                    right -= 1
                else:
                    if nums[i] < target:
                        nums[left], nums[i] = nums[i], nums[left]
                        left += 1
                    i += 1

        triPartition(nums, 1)",O(n)
"
class Solution(object):
    def __init__(self, iterator):
        self.iterator = iterator
        self.val_ = None
        self.has_next_ = iterator.hasNext()
        self.has_peeked_ = False


    def peek(self):
        if not self.has_peeked_:
            self.has_peeked_ = True
            self.val_ = next(self.iterator)
        return self.val_

    def __next__(self):
        self.val_ = self.peek()
        self.has_peeked_ = False
        self.has_next_ = self.iterator.hasNext()
        return self.val_

    def hasNext(self):
        return self.has_next_



",O(1)
"import itertools
import heapq



class Solution(object):
    def maxScore(self, nums1, nums2, k):
        result = curr = 0
        min_heap = []
        for a, b in sorted(zip(nums1, nums2), key=lambda x: x[1],  reverse=True):
            curr += a
            heapq.heappush(min_heap, a)
            if len(min_heap) > k:
                curr -= heapq.heappop(min_heap)
            if len(min_heap) == k:
                result = max(result, curr*b)
        return result",O(nlogn)
"class Solution(object):
    def memLeak(self, memory1, memory2):
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) > x: 
                r -= 1
            return r

        is_swapped = False
        if memory1 < memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]",O(1)
"class Solution(object):
    def evenProduct(self, nums):
        result = (len(nums)+1)*len(nums)//2
        cnt = 0
        for x in nums:
            cnt = cnt+1 if x%2 else 0
            result -= cnt
        return result",O(n)
"class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result",O(n)
"class Solution(object):
    def makeGood(self, s):
        stk = []
        for ch in s:
            counter_ch = ch.upper() if ch.islower() else ch.lower()
            if stk and stk[-1] == counter_ch:
                stk.pop()
            else:
                stk.append(ch)
        return """".join(stk)",O(n)
"class Solution(object):
    def largestValues(self, root):
        def largestValuesHelper(root, depth, result):
            if not root:
                return
            if depth == len(result):
                result.append(root.val)
            else:
                result[depth] = max(result[depth], root.val)
            largestValuesHelper(root.left, depth+1, result)
            largestValuesHelper(root.right, depth+1, result)

        result = []
        largestValuesHelper(root, 0, result)
        return result",O(n)
"class Solution2(object):
    def largestValues(self, root):
        result = []
        curr = [root]
        while any(curr):
            result.append(max(node.val for node in curr))
            curr = [child for node in curr for child in (node.left, node.right) if child]
        return result",O(n)
"import collections



class Solution(object):
    def countInterestingSubarrays(self, nums, modulo, k):
        cnt = collections.Counter([0])
        result = prefix = 0
        for x in nums:
            if x%modulo == k:
                prefix = (prefix+1)%modulo
            result += cnt[(prefix-k)%modulo]
            cnt[prefix] += 1
        return result",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def isEvenOddTree(self, root):
        q = [root]
        is_odd = False
        while q:
            new_q = []
            prev = None
            for node in q:
                if is_odd:
                    if node.val%2 or (prev and prev.val <= node.val):
                        return False
                else:
                    if not node.val%2 or (prev and prev.val >= node.val):
                        return False
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
                prev = node
            q = new_q
            is_odd = not is_odd
        return True",O(n)
"class Solution(object):
    def vowelStrings(self, words, left, right):
        VOWELS = {'a', 'e', 'i', 'o', 'u'}
        return sum(words[i][0] in VOWELS and words[i][-1] in VOWELS for i in range(left, right+1))",O(n)
"import heapq



class Solution(object):
    def minOperations(self, n, m):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
            
        def dijkstra(start, target):
            if spf[start] == start:
                return -1
            lookup = set()
            min_heap = [(start, start)]
            while min_heap:
                curr, i = heapq.heappop(min_heap)
                if i in lookup:
                    continue
                lookup.add(i)
                if i == target:
                    return curr
                base = 1
                while base <= i:
                    x = i//base
                    for d in (-1, 1):
                        if (1 if x <= 9 else 0) <= x%10+d <= 9 and spf[i+d*base] != i+d*base and i+d*base not in lookup:
                            heapq.heappush(min_heap, (curr+(i+d*base), i+d*base))
                    base *= 10
            return -1
        
        base = 1
        while base < max(n, m):
            base *= 10
        spf = linear_sieve_of_eratosthenes(base)
        return dijkstra(n, m)",other
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):

    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)
        self.__vals = []
        self.__pos = -1

    def hasNext(self):
        return self.__pos+1 != len(self.__vals) or self.__stk

    def __next__(self):
        self.__pos += 1
        if self.__pos == len(self.__vals):
            node = self.__stk.pop()
            self.__traversalLeft(node.right)
            self.__vals.append(node.val)
        return self.__vals[self.__pos]
        
    def hasPrev(self):
        return self.__pos-1 >= 0

    def prev(self):
        self.__pos -= 1
        return self.__vals[self.__pos]
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left",O(1)
"class Solution(object):
    def findMaxLength(self, nums):
        result, count = 0, 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += 1 if num == 1 else -1
            if count in lookup:
                result = max(result, i - lookup[count])
            else:
                lookup[count] = i

        return result",O(n)
"import collections



class Solution(object):
    def mostFrequentEven(self, nums):
        cnt = collections.Counter(x for x in nums if x%2 == 0)
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], -x)) if cnt else -1",O(n)
"class Solution(object):
    def maxAbsoluteSum(self, nums):
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn",O(n)
"class Solution(object):
    def countPairs(self, nums1, nums2):
        for i in range(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left < right:
            if nums1[left] > 0 or -nums1[left] < nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result",O(nlogn)
"import collections


class Solution(object):
    def findMaxValueOfEquation(self, points, k):
        result = float(""-inf"")
        dq = collections.deque()
        for i, (x, y) in enumerate(points):
            while dq and points[dq[0]][0] < x-k:
                dq.popleft()
            if dq:
                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)
            while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x:
                dq.pop()
            dq.append(i)
        return result",O(n)
"import collections


class Solution(object):
    def findingUsersActiveMinutes(self, logs, k):
        lookup = collections.defaultdict(set)
        for u, t in logs:
            lookup[u].add(t)
        result = [0]*k
        for _, ts in lookup.items():
            result[len(ts)-1] += 1
        return result",O(n)
"class Solution(object):
    def wonderfulSubstrings(self, word):
        ALPHABET_SIZE = 10
        count = [0]*(2**ALPHABET_SIZE)
        count[0] = 1
        result = curr = 0
        for c in word:
            curr ^= 1<<(ord(c)-ord('a'))
            result += count[curr]
            result += sum(count[curr^(1<<i)] for i in range(ALPHABET_SIZE))
            count[curr] += 1
        return result",O(n)
"import collections



class Solution(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            mn1[x] = min(mn1[x], mn0)+x
            mn0 = min(mn0, curr)
            mn = min(mn, mn1[x], mn0)
        return result",O(n)
"import collections



class Solution2(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            if x < 0:
                mn1[x] = min(mn1[x], mn0)+x
                mn = min(mn, mn1[x])
            mn0 = min(mn0, curr)
            mn = min(mn, mn0)
        return result",O(n)
"import collections



class Solution_TLE(object):
    def maxSubarraySum(self, nums):
        MAX, TOTAL, PREFIX, SUFFIX = list(range(4))
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            return [nums[i]]*4
        
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            return [max(x[MAX], y[MAX], x[SUFFIX]+y[PREFIX]),
                    x[TOTAL]+y[TOTAL],
                    max(x[PREFIX], x[TOTAL]+y[PREFIX]),
                    max(y[SUFFIX], x[SUFFIX]+y[TOTAL])]

        mx = max(nums)
        if mx < 0:
            return mx
        mn = min(nums)
        if mn >= 0:
            return sum(nums)
        groups = collections.defaultdict(list)
        for i, x in enumerate(nums):
            groups[x].append(i)
        st = SegmentTree(len(nums), build_fn=build, query_fn=query)
        result = st.tree[1][0] 
        for k, v in groups.items():
            for i in v:
                st.update(i, None)
            result = max(result, st.tree[1][0]) 
            for i in v:
                st.update(i, [k]*4)
        return result",O(nlogn)
"class Solution(object):
    def findGameWinner(self, n):
        return n%6 != 1",O(1)
"class Solution2(object):
    def findGameWinner(self, n):
        grundy = [0, 1] 
        for i in range(2, n):
            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1) 
        return grundy[(n-1)%2] > 0",O(n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeElements(self, head, val):
        dummy = ListNode(float(""-inf""))
        dummy.next = head
        prev, curr = dummy, dummy.__next__

        while curr:
            if curr.val == val:
                prev.next = curr.__next__
            else:
                prev = curr

            curr = curr.__next__

        return dummy.__next__



",O(n)
"import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)",O(nlogn)
"class Solution(object):
    def maxA(self, N):
        if N < 7:
            return N
        if N == 10:
            return 20 

        n = N // 5 + 1 
        n3 = 5*n - N - 1
        n4 = n - n3
        return 3**n3 * 4**n4",O(1)
"class Solution2(object):
    def maxA(self, N):
        if N < 7:
            return N
        dp = list(range(N+1))
        for i in range(7, N+1):
            dp[i % 6] = max(dp[(i-4) % 6]*3, dp[(i-5) % 6]*4)
        return dp[N % 6]",O(n)
"
class Solution(object):
    def minDiffInBST(self, root):
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            self.result = min(self.result, node.val-self.prev)
            self.prev = node.val
            dfs(node.right)

        self.prev = float('-inf')
        self.result = float('inf')
        dfs(root)
        return self.result


",O(n)
"class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        USE, REFILL, DIST = 5, 1, 10
        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)
        return (mainTank+cnt*REFILL)*DIST",O(1)
"import itertools


class Solution(object):
    def flipgame(self, fronts, backs):
        same = {n for i, n in enumerate(fronts) if n == backs[i]}
        result = float(""inf"")
        for n in itertools.chain(fronts, backs):
            if n not in same:
                result = min(result, n)
        return result if result < float(""inf"") else 0",O(n)
"class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)",O(n)
"class Solution(object):
    def stoneGameIII(self, stoneValue):
        dp = [float(""-inf"")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(range(len(stoneValue))):
            max_dp, curr = float(""-inf""), 0
            for j in range(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return [""Tie"", ""Alice"", ""Bob""][cmp(dp[0], 0)]",O(n)
"class Solution(object):
    def gameResult(self, head):
        cnt = 0
        while head:
            cnt += cmp(head.val, head.next.val)
            head = head.next.__next__
        return ""Tie"" if cnt == 0 else ""Odd"" if cnt < 0 else ""Even""",O(n)
"class Solution(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(2)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i % 2][0] = 1
            else:
                size[i % 2][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i % 2][j] = min(size[i % 2][j - 1], \
                                         size[(i - 1) % 2][j], \
                                         size[(i - 1) % 2][j - 1]) + 1
                    max_size = max(max_size, size[i % 2][j])
                else:
                    size[i % 2][j] = 0

        return max_size * max_size",O(n ^ 2)
"class Solution2(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(m)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i][0] = 1
            else:
                size[i][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i][j] = min(size[i][j - 1],  \
                                     size[i - 1][j],  \
                                     size[i - 1][j - 1]) + 1
                    max_size = max(max_size, size[i][j])
                else:
                    size[i][j] = 0

        return max_size * max_size",O(n ^ 2)
"class Solution3(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        H, W = 0, 1
        table = [[[0, 0] for j in range(len(matrix[0]))] \
                         for i in range(len(matrix))]
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == '1':
                    h, w = 1, 1
                    if i + 1 < len(matrix):
                        h = table[i + 1][j][H] + 1
                    if j + 1 < len(matrix[i]):
                        w = table[i][j + 1][W] + 1
                    table[i][j] = [h, w]

        s = [[0 for j in range(len(matrix[0]))] \
                for i in range(len(matrix))]
        max_square_area = 0
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                side = min(table[i][j][H], table[i][j][W])
                if matrix[i][j] == '1':
                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                        side = min(s[i + 1][j + 1] + 1, side)
                    s[i][j] = side
                    max_square_area = max(max_square_area, side * side)

        return max_square_area",O(n ^ 2)
"import collections



class Solution(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        M, p = 10**9+7, 113
        power, rolling_hash = pow(p, minSize-1, M), 0

        left = 0
        lookup, count = collections.defaultdict(int), collections.defaultdict(int)
        for right in range(len(s)):
            count[s[right]] += 1
            if right-left+1 > minSize:
                count[s[left]] -= 1
                rolling_hash = (rolling_hash - ord(s[left])*power) % M
                if count[s[left]] == 0:
                    count.pop(s[left])
                left += 1
            rolling_hash = (rolling_hash*p + ord(s[right])) % M
            if right-left+1 == minSize and len(count) <= maxLetters:
                lookup[rolling_hash] += 1
        return max(list(lookup.values()) or [0])",O(n)
"import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))",O(n)
"class Solution2(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution3(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = list(range(len(arr))), []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    left[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = list(range(len(arr))), []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    right[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)

        segment_tree = SegmentTree(len(arr))
        for _, i in sorted([x, i] for i, x in enumerate(arr)):
            segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)
        return segment_tree.query(0, len(arr)-1)",O(nlogn)
"class Solution(object):
    def orArray(self, nums):
        return [nums[i]|nums[i+1] for i in range(len(nums)-1)]",O(n)
"class Solution(object):
    def minimumAverageDifference(self, nums):
        total = sum(nums)
        mn, idx = float(""inf""), -1
        prefix = 0
        for i, x in enumerate(nums):
            prefix += x
            a = prefix//(i+1)
            b = (total-prefix)//(len(nums)-(i+1)) if i+1 < len(nums) else 0
            diff = abs(a-b)
            if diff < mn:
                mn, idx = diff, i
        return idx",O(n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def hasCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                return True
        return False

",O(n)
"class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        if n == 0:
            return 1
        result = cnt = 1
        for i in range(n-1):
            cnt *= 9-i
            result += cnt
        return 1+9*result",O(n)
"class Solution2(object):
    def countNumbersWithUniqueDigits(self, n):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]

        return 1+9*sum(nPr(9, i) for i in range(n))",O(n)
"class Solution(object):
    def parseBoolExpr(self, expression):
        def parse(expression, i):
            if expression[i[0]] not in ""&|!"":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])",O(n)
"cnt = [0]*2
class Solution(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        def popcount(x):
            return bin(x).count('1')

        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        dp = [0]*len(s)
        curr = 0
        for i in range(len(s)):
            for j in reversed(list(range(i))):
                dp[j+1] = (dp[j+1]+dp[j])%MOD
            if s[i] != '1':
                continue
            dp[curr] = (dp[curr]+1)%MOD
            curr += 1
        return reduce(lambda accu, x: (accu+x)%MOD, (dp[i] for i in range(1, len(s)) if cnt[i] < k), 0)",O(n ^ 2)
"cnt = [0]*2
class Solution2(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]  
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def popcount(x):
            return bin(x).count('1')
      
        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            for c in range((len(s)-(i+1))+1):
                if cnt[curr+c] < k:
                    result = (result+nCr(len(s)-(i+1), c))%MOD
            curr += 1
        return (result-1)%MOD",O(n ^ 2)
"class Solution(object):
    def shortestSequence(self, rolls, k):
        l = 0
        lookup = set()
        for x in rolls:
            lookup.add(x)
            if len(lookup) != k:
                continue
            lookup.clear()
            l += 1
        return l+1",O(n)
"class Solution(object):
    def maxHeightOfTriangle(self, red, blue):
        def f(x, y):
            a, b = int(2*x**0.5)-1, int((4*y+1)**0.5)-1
            return min(a, b)+int(a != b)
        
        return max(f(red, blue), f(blue, red))",O(1)
"class Solution(object):
    def removeElement(self, A, elem):
        i, last = 0, len(A) - 1
        while i <= last:
            if A[i] == elem:
                A[i], A[last] = A[last], A[i]
                last -= 1
            else:
                i += 1
        return last + 1",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def removeStones(self, stones):
        MAX_ROW = 10000
        union_find = UnionFind(2*MAX_ROW)
        for r, c in stones:
            union_find.union_set(r, c+MAX_ROW)
        return len(stones) - len({union_find.find_set(r) for r, _ in stones})",O(n)
"import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root",O(n)
"class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root",O(n)
"class Solution3(object):
    def invertTree(self, root):
        if root is not None:
            root.left, root.right = self.invertTree(root.right), \
                                    self.invertTree(root.left)

        return root",O(n)
"class Solution(object):
    def minSubsequence(self, nums):
        result, total, curr = [], sum(nums), 0
        nums.sort(reverse=True)
        for i, x in enumerate(nums):
            curr += x
            if curr > total-curr:
                break
        return nums[:i+1]",O(nlogn)
"class Solution(object):
    def maximumScore(self, nums, k):
        result = curr = nums[k]
        left = right = k
        while left-1 >= 0 or right+1 < len(nums):
            if (nums[left-1] if left-1 >= 0 else 0) <= (nums[right+1] if right+1 < len(nums) else 0):
                right += 1
            else:
                left -= 1
            curr = min(curr, nums[left], nums[right])
            result = max(result, curr*(right-left+1))
        return result",O(n)
"import bisect


class Solution2(object):
    def maximumScore(self, nums, k):
        def score(nums, k):
            prefix = [nums[k]]*(k+1)
            for i in reversed(range(k)):
                prefix[i] = min(prefix[i+1], nums[i])
            result = right = nums[k]
            for j in range(k+1, len(nums)):
                right = min(right, nums[j])
                i = bisect.bisect_left(prefix, right)
                if i >= 0:
                    result = max(result, right*(j-i+1))
            return result

        return max(score(nums, k), score(nums[::-1], len(nums)-1-k))",O(nlogn)
"class Solution(object):
    def prevPermOpt1(self, A):
        for left in reversed(range(len(A)-1)):
            if A[left] > A[left+1]:
                break
        else:
            return A
        right = len(A)-1
        while A[left] <= A[right]:
            right -= 1
        while A[right-1] == A[right]:
            right -= 1
        A[left], A[right] = A[right], A[left]
        return A",O(n)
"import collections



class Solution(object):
    def maxFrequency(self, nums, k):
        result = 0
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] = max(cnt[x], cnt[k])+1
            result = max(result+int(x == k), cnt[x])
        return result",O(n)
"import random



class Solution(object):
    def minOperationsToMakeMedianK(self, nums, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        nth_element(nums, len(nums)//2)
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(n)
"class Solution2(object):
    def minOperationsToMakeMedianK(self, nums, k):
        nums.sort()
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(nlogn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None



class Solution(object):
    def plusOne(self, head):
        if not head:
            return None

        dummy = ListNode(0)
        dummy.next = head

        left, right = dummy, head
        while right.__next__:
            if right.val != 9:
                left = right
            right = right.__next__

        if right.val != 9:
            right.val += 1
        else:
            left.val += 1
            right = left.__next__
            while right:
                right.val = 0
                right = right.__next__

        return dummy if dummy.val else dummy.__next__",O(n)
"class Solution2(object):
    def plusOne(self, head):
        def reverseList(head):
            dummy = ListNode(0)
            curr = head
            while curr:
                dummy.next, curr.next, curr = curr, dummy.next, curr.next
            return dummy.__next__

        rev_head = reverseList(head)
        curr, carry = rev_head, 1
        while curr and carry:
            curr.val += carry
            carry = curr.val / 10
            curr.val %= 10
            if carry and curr.__next__ is None:
                curr.next = ListNode(0)
            curr = curr.__next__

        return reverseList(rev_head)",O(n)
"class Solution(object):
    def maxScore(self, nums):
        nums.sort(reverse=True)
        curr = 0
        for i, x in enumerate(nums):
            curr += x
            if curr <= 0:
                return i
        return len(nums)",O(nlogn)
"class Solution(object):
    def minimumHealth(self, damage, armor):
        return sum(damage)-min(max(damage), armor)+1",O(n)
"class Solution(object):
    def minimumMoves(self, arr):
        dp = [[0 for _ in range(len(arr)+1)] for _ in range(len(arr)+1)]
        for l in range(1, len(arr)+1):
            for i in range(len(arr)-l+1):
                j = i+l-1
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1+dp[i+1][j]
                    if arr[i] == arr[i+1]:
                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])
                    for k in range(i+2, j+1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])
        return dp[0][len(arr)-1]",O(n ^ 3)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i

class Solution(object):
    def read(self, buf, n):
        read_bytes = 0
        buffer = [''] * 4
        for i in range((n+4-1)//4):
            size = min(read4(buffer), n-read_bytes)
            buf[read_bytes:read_bytes+size] = buffer[:size]
            read_bytes += size
        return read_bytes",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head",O(n)
"import collections



class Solution(object):
    def numberOfSubsequences(self, nums):
        cnt = collections.defaultdict(int)
        result = 0
        for r in range(4, len(nums)-2):
            q = r-2
            for p in range((q-2)+1):
                cnt[float(nums[p])/nums[q]] += 1
            for s in range(r+2, len(nums)):
                result += cnt[float(nums[s])/nums[r]]
        return result",O(n ^ 2)
"class Solution(object):
    def convertBST(self, root):
        def convertBSTHelper(root, cur_sum):
            if not root:
                return cur_sum

            if root.right:
                cur_sum = convertBSTHelper(root.right, cur_sum)
            cur_sum += root.val
            root.val = cur_sum
            if root.left:
                cur_sum = convertBSTHelper(root.left, cur_sum)
            return cur_sum

        convertBSTHelper(root, 0)
        return root",O(n)
"class Solution(object):
    def halvesAreAlike(self, s):
        vowels = set(""aeiouAEIOU"")
        cnt1 = cnt2 = 0
        left, right = 0, len(s)-1
        while left < right:
            cnt1 += s[left] in vowels
            cnt2 += s[right] in vowels
            left += 1
            right -= 1
        return cnt1 == cnt2",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isBalanced(self, root):
        def getHeight(root):
            if root is None:
                return 0
            left_height, right_height = \
                getHeight(root.left), getHeight(root.right)
            if left_height < 0 or right_height < 0 or \
               abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        return (getHeight(root) >= 0)",O(n)
"class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)",O(n)
"class Solution(object):
    def addRungs(self, rungs, dist):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        result = prev = 0
        for curr in rungs:
            result += ceil_divide(curr-prev, dist)-1
            prev = curr
        return result",O(n)
"class Solution(object):
    def longestUnivaluePath(self, root):
        result = [0]
        def dfs(node):
            if not node:
                return 0
            left, right = dfs(node.left), dfs(node.right)
            left = (left+1) if node.left and node.left.val == node.val else 0
            right = (right+1) if node.right and node.right.val == node.val else 0
            result[0] = max(result[0], left+right)
            return max(left, right)

        dfs(root)
        return result[0]",O(n)
"import itertools



class Solution(object):
    def maximumCostSubstring(self, s, chars, vals):
        def kadane(s):
            result = curr = 0
            for c in s:
                curr = max(curr+(lookup[c] if c in lookup else ord(c)-ord('a')+1), 0)
                result = max(result, curr)
            return result

        lookup = {}
        for c, v in zip(chars, vals):
            lookup[c] = v
        return kadane(s)",O(n)
"import collections


class Solution:
    def invalidTransactions(self, transactions):
        AMOUNT, MINUTES = 1000, 60
        trans = [(x[0], int(x[1]), int(x[2]), x[3]) for x in (transaction.split(',') for transaction in transactions)]
        trans.sort(key=lambda t: t[1])
        trans_indexes = collections.defaultdict(list)
        for i, t in enumerate(trans):
            trans_indexes[t[0]].append(i)
        result = []
        for name, indexes in trans_indexes.items():
            left, right = 0, 0
            for i, t_index in enumerate(indexes):
                t = trans[t_index]
                if (t[2] > AMOUNT):
                    result.append(""{},{},{},{}"".format(*t))
                    continue
                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:
                    left += 1
                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:
                    right += 1
                for i in range(left, right+1):
                    if trans[indexes[i]][3] != t[3]:
                        result.append(""{},{},{},{}"".format(*t))
                        break
        return result",O(nlogn)
"class Solution(object):
    def encode(self, s):
        def encode_substr(dp, s, i, j):
            temp = s[i:j+1]
            pos = (temp + temp).find(temp, 1) 
            if pos >= len(temp):
                return temp
            return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']'

        dp = [["""" for _ in range(len(s))] for _ in range(len(s))]
        for length in range(1, len(s)+1):
            for i in range(len(s)+1-length):
                j = i+length-1
                dp[i][j] = s[i:i+length]
                for k in range(i, j):
                    if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]):
                        dp[i][j] = dp[i][k] + dp[k+1][j]
                encoded_string = encode_substr(dp, s, i, j)
                if len(encoded_string) < len(dp[i][j]):
                    dp[i][j] = encoded_string
        return dp[0][len(s) - 1]",O(n ^ 3)
"class Solution(object):
    def compress(self, chars):
        anchor, write = 0, 0
        for read, c in enumerate(chars):
            if read+1 == len(chars) or chars[read+1] != c:
                chars[write] = chars[anchor]
                write += 1
                if read > anchor:
                    n, left = read-anchor+1, write
                    while n > 0:
                        chars[write] = chr(n%10+ord('0'))
                        write += 1
                        n /= 10
                    right = write-1
                    while left < right:
                        chars[left], chars[right] = chars[right], chars[left]
                        left += 1
                        right -= 1
                anchor = read+1
        return write",O(n)
"class Solution(object):
    def countBits(self, num):
        res = [0]
        for i in range(1, num + 1):
            res.append((i & 1) + res[i >> 1])
        return res

    def countBits2(self, num):
        s = [0]
        while len(s) <= num:
            s.extend([x + 1 for x in s])
        return s[:num + 1]",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        curr = dummy = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.__next__
            else:
                curr.next = l2
                l2 = l2.__next__
            curr = curr.__next__
        curr.next = l1 or l2
        return dummy.__next__",O(n)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        union_find = UnionFind(len(graph))
        for i in range(len(graph)):
            for j in range(i+1, len(graph)):
                if graph[i][j] == 1:
                    union_find.union_set(i, j)
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        malware_count = collections.Counter(union_find.find_set(i) for i in initial)
        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,
                                           -union_size[union_find.find_set(x)],
                                           x])",O(n ^ 2)
"import collections



class Solution(object):
    def __init__(self, capacity):
        self.cache = collections.OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        val = self.cache[key]
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.cache and len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.__update(key, val)
    
    def __update(self, key, val):
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = val",O(1)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD",O(n)
"import collections



class Solution(object):
    def countOfArrays(self, n, m, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        lookup = collections.defaultdict(list)
        def pow(a, b):
            while len(lookup[a]) <= b:
                lookup[a].append((lookup[a][-1]*a)%MOD if lookup[a] else 1)
            return lookup[a][b]

        MOD = 10**9+7
        even, odd = m//2, (m+1)//2
        result = 0
        if k == 0:
            result = (result+pow(odd, n))%MOD
        for x in range(1, (n+1-k)//2+1): 
            result = (result+(nHr(x, (k+x)-x)*nHr(x+1, (n-(k+x))-((x+1)-2))*pow(even, k+x)*pow(odd, n-(k+x))%MOD))%MOD
        return result",other
"class Solution(object):
    def largestTriangleArea(self, points):
        result = 0
        for i in range(len(points)-2):
            for j in range(i+1, len(points)-1):
                for k in range(j+1, len(points)):
                    result = max(result,
                                 0.5 * abs(points[i][0] * points[j][1] +
                                           points[j][0] * points[k][1] +
                                           points[k][0] * points[i][1] -
                                           points[j][0] * points[i][1] -
                                           points[k][0] * points[j][1] -
                                           points[i][0] * points[k][1]))
        return result",O(n ^ 3)
"class Solution(object):
    def smallestNumber(self, n, t):
        def check(x):
            result = 1
            while x:
                result = (result*(x%10))%t
                x //= 10
            return result == 0
    
        while not check(n):
            n += 1
        return n",other
"class Solution(object):
    def validTicTacToe(self, board):
        def win(board, player):
            for i in range(3):
                if all(board[i][j] == player for j in range(3)):
                    return True
                if all(board[j][i] == player for j in range(3)):
                    return True

            return (player == board[1][1] == board[0][0] == board[2][2] or \
                    player == board[1][1] == board[0][2] == board[2][0])

        FIRST, SECOND = ('X', 'O')
        x_count = sum(row.count(FIRST) for row in board)
        o_count = sum(row.count(SECOND) for row in board)
        if o_count not in {x_count-1, x_count}: return False
        if win(board, FIRST) and x_count-1 != o_count: return False
        if win(board, SECOND) and x_count != o_count: return False

        return True",O(1)
"class Solution(object):
    def nearestValidPoint(self, x, y, points):
        smallest, idx = float(""inf""), -1
        for i, (r, c) in enumerate(points):
            dx, dy = x-r, y-c
            if dx*dy == 0 and abs(dx)+abs(dy) < smallest:
                smallest = abs(dx)+abs(dy)
                idx = i
        return idx",O(n)
"class Solution(object):
    def movesToMakeZigzag(self, nums):
        result = [0, 0]
        for i in range(len(nums)):
            left = nums[i-1] if i-1 >= 0 else float(""inf"")
            right = nums[i+1] if i+1 < len(nums) else float(""inf"")
            result[i%2] += max(nums[i] - min(left, right) + 1, 0)
        return min(result)",O(n)
"class Solution(object):
    def getSumAbsoluteDifferences(self, nums):
        prefix, suffix = 0, sum(nums)
        result = []
        for i, num in enumerate(nums):
            suffix -= num
            result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num))
            prefix += num
        return result",O(n)
"

class Solution(object):
    def countElements(self, nums):
        mn = min(nums)
        mx = max(nums)
        return sum(mn < x < mx for x in nums)
",O(n)
"import collections
import string


class Solution(object):
    def longestWord(self, words):
        def iter_dfs(words, node):
            result = -1
            stk = [node]
            while stk:
                node = stk.pop()
                if result == -1 or len(words[node[""_end""]]) > len(words[result]):
                    result = node[""_end""]
                for c in reversed(string.ascii_lowercase):
                    if c not in node or ""_end"" not in node[c]:
                        continue
                    stk.append(node[c])
            return result       
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = iter_dfs(words, trie)
        return words[result] if result != -1 else """"",O(n)
"import collections
import string


class Solution2(object):
    def longestWord(self, words):
        def dfs(words, node, result):
            if result[0] == -1 or len(words[node[""_end""]]) > len(words[result[0]]):
                result[0] = node[""_end""]
            for c in string.ascii_lowercase:
                if c not in node or ""_end"" not in node[c]:
                    continue
                dfs(words, node[c], result)
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = [-1]
        dfs(words, trie, result)
        return words[result[0]] if result[0] != -1 else """"",other
"class Solution(object):
    def stringSequence(self, target):
        return [target[:i]+chr(x) for i in range(len(target)) for x in range(ord('a'), ord(target[i])+1)]",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums, k):
        mn = min(nums)
        return len(set(nums))-int(mn == k) if mn >= k else -1",O(n)
"class Solution(object):
    def largestBSTSubtree(self, root):
        if root is None:
            return 0

        max_size = [1]
        def largestBSTSubtreeHelper(root):
            if root.left is None and root.right is None:
                return 1, root.val, root.val

            left_size, left_min, left_max = 0, root.val, root.val
            if root.left is not None:
                left_size, left_min, left_max = largestBSTSubtreeHelper(root.left)

            right_size, right_min, right_max = 0, root.val, root.val
            if root.right is not None:
                right_size, right_min, right_max = largestBSTSubtreeHelper(root.right)

            size = 0
            if (root.left is None or left_size > 0) and \
               (root.right is None or right_size > 0) and \
               left_max <= root.val <= right_min:
                size = 1 + left_size + right_size
                max_size[0] = max(max_size[0], size)

            return size, left_min, right_max

        largestBSTSubtreeHelper(root)
        return max_size[0]",O(n)
"class Solution(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        result = 1
        dp = [1]*2 
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[1] = dp[0]+1
            elif nums[i] == nums[i-1]+1:
                dp[0] += 1
                dp[1] += 1
            elif nums[i] == nums[i-1]+2:
                dp[0] = dp[1]+1
                dp[1] = 1
            else:
                dp[0] = dp[1] = 1
            result = max(result, dp[0], dp[1])
        return result",O(nlogn)
"import collections



class Solution2(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        dp[nums[0]] = dp[nums[0]+1] = 1
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[nums[i]+1] = dp[nums[i]]+1
            elif nums[i] == nums[i-1]+1:
                dp[nums[i]+1] = dp[nums[i]]+1
                dp[nums[i]] = dp[nums[i]-1]+1
            elif nums[i] == nums[i-1]+2:
                dp[nums[i]] = dp[nums[i]-1]+1
                dp[nums[i]+1] = 1
            else:
                dp[nums[i]] = dp[nums[i]+1] = 1
        return max(dp.values())",O(nlogn)
"import collections



class Solution3(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        for x in nums:
            dp[x+1] = dp[x]+1
            dp[x] = dp[x-1]+1
        return max(dp.values())",O(nlogn)
"from random import randint, seed



class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self, end=[float(""inf""), float(""inf""), float(""inf"")], can_duplicated=True):
        seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.add(end)
        self.__end = self.find(end)

    def begin(self):
        return self.__head.nexts[0]
    
    def end(self):
        return self.__end

    def lower_bound(self, target, cmp=lambda x, y: x < y):
        return self.__lower_bound(target, self.__find_prev_nodes(target, cmp))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return self.find(val), False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return node if self.__can_duplicated else (node, True)

    def remove(self, it):
        prevs = it.prevs
        curr = self.__find(it.val, prevs)
        if not curr:
            return self.__end
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return curr.nexts[0]
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val, cmp=lambda x, y: x < y):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and cmp(curr.nexts[i].val, val):
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \
              level < SkipList.MAX_LEVEL:
            level += 1
        return level
    
    def __iter__(self):
        it = self.begin()
        while it != self.end():
            yield it.val
            it = it.nexts[0]

    def __len__(self):
        return self.__len-1 

    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])



class LineContainer(object):
    def __init__(self):
        self.__skiplist = SkipList()

    def add(self, k, m):
        self.__skiplist.add([k, m, 0])
        z = self.__skiplist.find([k, m, 0])
        x = y = z
        z = z.nexts[0]
        while self.__intersect(y, z):
            z = self.__skiplist.remove(z)
        if x != self.__skiplist.begin():
            x = x.prevs[0]
            if self.__intersect(x, y):
                y = self.__skiplist.remove(y)
                self.__intersect(x, y)
        y = x
        while y != self.__skiplist.begin():
            x = x.prevs[0]
            if x.val[2] < y.val[2]:
                break
            y = self.__skiplist.remove(y)
            self.__intersect(x, y)
            y = x
    
    def query(self, x):
        it = self.__skiplist.lower_bound(x, cmp=lambda x, y: x[2] < y)
        return it.val[0]*x + it.val[1]

    def __intersect(self, x, y):
        if y == self.__skiplist.end():
            x.val[2] = float(""inf"")
            return False
        if x.val[0] == y.val[0]:
            x.val[2] = float(""inf"") if x.val[1] > y.val[1] else float(""-inf"")
        else:
            x.val[2] = (y.val[1]-x.val[1])//(x.val[0]-y.val[0])
        return x.val[2] >= y.val[2]

    def __iter__(self):
        return iter(self.__skiplist)

    def __len__(self):
        return len(self.__skiplist)

    def __str__(self):
        return str(self.__skiplist)



class Solution(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = 0
        lc = LineContainer()
        for i in reversed(range(len(nums))):
            lc.add(prefix1[i+1], -(dp+prefix1[i+1]*prefix2[i+1]))
            dp = (-lc.query(prefix2[i]))+(k*(prefix2[-1]-prefix2[i]))
        return dp",O(nlogn)
"class Solution2(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[-1] = 0
        for i in reversed(range(len(nums))):
            for j in range(i, len(nums)):
                dp[i] = min(dp[i], prefix1[j+1]*(prefix2[j+1]-prefix2[i])+dp[j+1]+(k*(prefix2[-1]-prefix2[i])))
        return dp[0]",O(n ^ 2)
"import collections


class UnionFind(object):
    def __init__(self):
        self.set = []

    def get_id(self):
        self.set.append(len(self.set))
        return len(self.set)-1

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)


class Solution(object):
    def accountsMerge(self, accounts):
        union_find = UnionFind()
        email_to_name = {}
        email_to_id = {}
        for account in accounts:
            name = account[0]
            for i in range(1, len(account)):
                if account[i] not in email_to_id:
                    email_to_name[account[i]] = name
                    email_to_id[account[i]] = union_find.get_id()
                union_find.union_set(email_to_id[account[1]],
                                     email_to_id[account[i]])

        result = collections.defaultdict(list)
        for email in list(email_to_name.keys()):
            result[union_find.find_set(email_to_id[email])].append(email)
        for emails in list(result.values()):
            emails.sort()
        return [[email_to_name[emails[0]]] + emails
                for emails in list(result.values())]",O(nlogn)
"class Solution(object):
    def closestFair(self, n):
        digits = list(map(int, str(n)))
        result = []
        if len(digits)%2 == 0:            
            left = [0]*2
            for d in digits:
                left[d%2] += 1
            if left[0] == len(digits)//2:
                return n
            for i in reversed(range(len(digits)//2, len(digits))):
                left[digits[i]%2] -= 1
                right = [len(digits)//2-left[0], len(digits)//2-left[1]]
                if any(x < 0 for x in right):
                    continue
                d = digits[i]+1 if right[(digits[i]+1)%2]-1 >= 0 else digits[i]+2
                if d > 9:
                    continue
                right[d%2] -= 1
                result = digits[:i]+[d]+[0]*right[0]+[1]*right[1]
                break
        if not result:
            l = len(digits)//2+1
            result = [1]+[0]*l+[1]*(l-1)
        return int("""".join(map(str, result)))",O(logn)
"class Solution(object):

    def __init__(self):
        self.A, self.B = [], []

    def push(self, x):
        self.A.append(x)

    def pop(self):
        self.peek()
        return self.B.pop()

    def peek(self):
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B[-1]

    def empty(self):
        return not self.A and not self.B",O(1)
"import collections


class Solution(object):
    def numberOfArithmeticSlices(self, A):
        result = 0
        dp = [collections.defaultdict(int) for i in range(len(A))]
        for i in range(1, len(A)):
            for j in range(i):
                diff = A[i]-A[j]
                dp[i][diff] += 1
                if diff in dp[j]:
                    dp[i][diff] += dp[j][diff]
                    result += dp[j][diff]
        return result",O(n ^ 2)
"class Solution(object):
    def countVisitedNodes(self, edges):
        def find_cycles(adj):
            result = [0]*len(adj)
            lookup = [0]*len(adj)
            stk = [] 
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    stk.append(u) 
                    u = adj[u]
                if lookup[u] > prev:
                    l = idx-lookup[u]+1
                    for _ in range(l): 
                        result[stk.pop()] = l
                while stk: 
                    result[stk[-1]] = result[adj[stk[-1]]]+1
                    stk.pop()
            return result
        
        return find_cycles(edges)",O(n)
"class Solution(object):
    def countOperationsToEmptyArray(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        return len(idxs)+sum(len(idxs)-(i+1) for i in range(len(idxs)-1) if idxs[i] > idxs[i+1])",O(nlogn)
"class Solution2(object):
    def countOperationsToEmptyArray(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
        
        bit = BIT(len(nums))
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        result = len(nums)
        prev = -1
        for i in idxs:
            if prev == -1:
                result += i
            elif prev < i:
                result += (i-prev)-(bit.query(i)-bit.query(prev-1))
            else:
                result += ((len(nums)-1)-bit.query(len(nums)-1))-((prev-i)-(bit.query(prev)-bit.query(i-1)))
            bit.add(i, 1)
            prev = i
        return result",O(nlogn)
"import collections



class Solution(object):
    def isPossibleToRearrange(self, s, t, k):
        cnt = collections.defaultdict(int)
        l = len(s)//k
        for i in range(0, len(s), l):
            cnt[s[i:i+l]] += 1
            cnt[t[i:i+l]] -= 1
        return all(v == 0 for v in cnt.values())",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"class Solution2(object):
    def inorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root, True))
                stack.append((root.left, False))
        return result",O(n)
"import collections



class Solution(object):
    def minimumCost(self, start, target, specialRoads):
        start, target = tuple(start), tuple(target)
        adj = collections.defaultdict(list, {target:[]})
        for x1, y1, x2, y2, c in specialRoads:
            adj[x1, y1].append((x2, y2, c))
        dist = {start:0}
        lookup = set()
        while len(lookup) != len(dist):
            d, x1, y1 = min((dist[x1, y1], x1, y1) for x1, y1 in dist.keys() if (x1, y1) not in lookup)
            lookup.add((x1, y1))
            if (x1, y1) == target:
                return d
            for x2, y2, c in adj[x1, y1]:
                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):
                    continue
                dist[x2, y2] = d+c
            for x2, y2 in adj.keys():
                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):
                    continue
                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)",O(n ^ 2)
"import itertools


class Solution(object):
    def gridGame(self, grid):
        result = float(""inf"")
        left, right = 0, sum(grid[0])
        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result",O(n)
"

class Solution(object):
    def maximumBags(self, capacity, rocks, additionalRocks):
        for i in range(len(capacity)):
            capacity[i] -= rocks[i]
        capacity.sort()
        for i, c in enumerate(capacity):
            if c > additionalRocks:
                return i
            additionalRocks -= c
        return len(capacity)
",O(nlogn)
"import collections


class Solution(object):
    def deleteTreeNodes(self, nodes, parent, value):
        def dfs(value, children, x):
            total, count = value[x], 1
            for y in children[x]:
                t, c = dfs(value, children, y)
                total += t
                count += c if t else 0
            return total, count if total else 0

        children = collections.defaultdict(list)
        for i, p in enumerate(parent):
            if i:
                children[p].append(i)
        return dfs(value, children, 0)[1]",O(n)
"class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        result = [1]*nodes
        for i in reversed(range(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]",O(n)
"import collections



class Solution(object):
    def maxSum(self, nums, m, k):
        lookup = collections.Counter()
        result = curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            lookup[nums[right]] += 1
            if right-left+1 == k+1:
                lookup[nums[left]] -= 1
                if lookup[nums[left]] == 0:
                    del lookup[nums[left]]
                curr -= nums[left]
                left += 1
            if right-left+1 == k and len(lookup) >= m:
                result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def smallestDivisor(self, nums, threshold):
        def check(A, d, threshold):
            return sum((i-1)//d+1 for i in nums) <= threshold

        left, right = 1, max(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(nums, mid, threshold):
                right = mid-1
            else:
                left = mid+1
        return left",other
"class Solution(object):
    def maxMatrixSum(self, matrix):
        abs_total = sum(abs(x) for row in matrix for x in row)
        min_abs_val = min(abs(x) for row in matrix for x in row)
        neg_cnt = sum(x < 0 for row in matrix for x in row)
        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val",O(n ^ 2)
"class Solution(object):
    def peopleAwareOfSecret(self, n, delay, forget):
        MOD = 10**9+7
        dp = [0]*forget
        dp[0] = 1
        for i in range(1, n):
            dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD
        return sum(dp)%MOD",O(n)
"import collections



class Solution(object):
    def maximumNumberOfStringPairs(self, words):
        result = 0
        cnt = collections.Counter()
        for w in words:
            result += cnt[w[::-1]]
            cnt[w] += 1
        return result",O(n)
"import collections



class Solution(object):
    def maxStudentsOnBench(self, students):
        lookup = collections.defaultdict(set)
        for s, b in students:
            lookup[b].add(s)
        return max(len(x) for x in lookup.values()) if lookup else 0",O(n)
"import collections


class Solution(object):
    def splitPainting(self, segments):
        counts = collections.defaultdict(int)
        for s, e, c in segments:
            counts[s] += c
            counts[e] -= c
        points = sorted(x for x in counts.items())

        result = []
        overlap = prev = 0
        for curr, cnt in points:
            if overlap:
                result.append([prev, curr, overlap])
            overlap += cnt
            prev = curr
        return result",O(nlogn)
"class Solution(object):
    def dominantIndex(self, nums):
        m = max(nums)
        if all(m >= 2*x for x in nums if x != m):
            return nums.index(m)
        return -1",O(n)
"import itertools


class Solution(object):
    def buddyStrings(self, A, B):
        if len(A) != len(B):
            return False
        diff = []
        for a, b in zip(A, B):
            if a != b:
                diff.append((a, b))
                if len(diff) > 2:
                    return False
        return (not diff and len(set(A)) < len(A)) or \
               (len(diff) == 2 and diff[0] == diff[1][::-1])",O(n)
"from random import randint
from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.__list = []
        self.__used = defaultdict(list)


    def insert(self, val):
        has = val in self.__used

        self.__list += (val, len(self.__used[val])),
        self.__used[val] += len(self.__list)-1,

        return not has


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[val][-1]
        self.__list[self.__used[val][-1]], self.__list[-1] = self.__list[-1], self.__list[self.__used[val][-1]]

        self.__used[val].pop()
        if not self.__used[val]:
            self.__used.pop(val)
        self.__list.pop()

        return True

    def getRandom(self):
        return self.__list[randint(0, len(self.__list)-1)][0]",O(1)
"class Solution(object):
    def maximumPoints(self, enemyEnergies, currentEnergy):
        mn = min(enemyEnergies)
        return ((currentEnergy-mn)+sum(enemyEnergies))//mn if currentEnergy >= mn else 0",O(n)
"import bisect



class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution2_TLE(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        sorted_obstacles = sorted(set(obstacles))
        lookup = {x:i for i, x in enumerate(sorted_obstacles)}
        segment_tree = SegmentTree(len(lookup))
        result = []
        for x in obstacles:
            cnt = segment_tree.query(0, lookup[x])+1
            result.append(cnt)
            segment_tree.update(lookup[x], lookup[x], cnt)
        return result",O(nlogn)
"class Solution(object):
    def getHappyString(self, n, k):
        base = 2**(n-1)
        if k > 3*base:
            return """"
        result = [chr(ord('a')+(k-1)//base)]
        while base > 1:
            k -= (k-1)//base*base
            base //= 2
            result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else
                          ('c' if result[-1] != 'c' else 'b'))
        return """".join(result)",O(n)
"class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        def iter_dfs():
            lookup = [[float(""-inf""), float(""inf"")] for _ in range(len(adj))]
            stk = [(1, (0, -1, 0))]
            while stk:
                step, (u, p, ah) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p, ah)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u, ah+1)))
                elif step == 2:
                    if len(adj[u])+(u == 0) == 1:
                        lookup[u][0] = 0
                    if u == bob:
                        lookup[u][1] = 0
                    for v in adj[u]:
                        if v == p:
                            continue
                        lookup[u][0] = max(lookup[u][0], lookup[v][0])
                        lookup[u][1] = min(lookup[u][1], lookup[v][1])
                    if ah == lookup[u][1]:
                        lookup[u][0] += amount[u]//2
                    elif ah < lookup[u][1]:
                        lookup[u][0] += amount[u]
                    lookup[u][1] += 1
            return lookup[0][0]

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def mostProfitablePath(self, edges, bob, amount):
        def dfs(u, ah):
            lookup[u] = True
            result = 0 if len(adj[u])+(u == 0) == 1 else float(""-inf"")
            bh = 0 if u == bob else float(""inf"")
            for v in adj[u]:
                if lookup[v]:
                    continue
                r, h = dfs(v, ah+1)
                result = max(result, r)
                bh = min(bh, h)
            if ah == bh:
                result += amount[u]//2
            elif ah < bh:
                result += amount[u]
            return result, bh+1

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(0, 0)[0]",O(n)
"class Solution(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(word)
        for i in range(k, len(word), k):
            if z[i] == len(word)-i:
                return i//k
        return ceil_divide(len(word), k)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        def dfs(root, voyage, i, result):
            if not root:
                return True
            if root.val != voyage[i[0]]:
                return False
            i[0] += 1
            if root.left and root.left.val != voyage[i[0]]:
                result.append(root.val)
                return dfs(root.right, voyage, i, result) and \
                       dfs(root.left, voyage, i, result)
            return dfs(root.left, voyage, i, result) and \
                   dfs(root.right, voyage, i, result)
        
        result = []
        return result if dfs(root, voyage, [0], result) else [-1]",O(n)
"class Solution(object):
    def distinctDifferenceArray(self, nums):
        result = [0]*len(nums)
        lookup = set()
        for i in range(len(nums)):
            lookup.add(nums[i])
            result[i] = len(lookup)
        lookup.clear()
        for i in reversed(range(len(nums))):
            result[i] -= len(lookup)
            lookup.add(nums[i])
        return result",O(n)
"class Solution(object):
    def bitwiseComplement(self, N):
        mask = 1
        while N > mask:
            mask = mask*2+1
        return mask-N",O(logn)
"import collections



class Solution(object):
    def equalFrequency(self, word):
        cnt = collections.Counter(iter(collections.Counter(word).values()))
        if len(cnt) > 2:
            return False
        if len(cnt) == 1:
            a = list(cnt.keys())[0]
            return a == 1 or cnt[a] == 1
        a, b = list(cnt.keys())
        if a > b:
            a, b = b, a
        return (a == 1 and cnt[a] == 1) or (a+1 == b and cnt[b] == 1)",O(n)
"class Solution(object):
    def semiOrderedPermutation(self, nums):
        i, j = nums.index(1), nums.index(len(nums))
        return i+((len(nums)-1)-j)-int(i > j)",O(n)
"MOD = 10**9+7

class Solution(object):

    def __init__(self):
        self.__arr = []
        self.__ops = [[1, 0]]

    def append(self, val):
        self.__arr.append(val)
        self.__ops.append(self.__ops[-1][:])

    def addAll(self, inc):
        self.__ops[-1][1] = (self.__ops[-1][1]+inc) % MOD

    def multAll(self, m):
        self.__ops[-1] = [(self.__ops[-1][0]*m) % MOD, (self.__ops[-1][1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a1, b1 = self.__ops[idx]
        a2, b2 = self.__ops[-1]
        a = a2*pow(a1, MOD-2, MOD)%MOD 
        b = (b2 - b1*a) % MOD
        return (self.__arr[idx]*a + b) % MOD",O(1)
"class Solution2(object):

    def __init__(self):
        self.__arr = []
        self.__op = [1, 0]

    def append(self, val):
        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD) 

    def addAll(self, inc):
        self.__op[1] = (self.__op[1]+inc) % MOD

    def multAll(self, m):
        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a, b = self.__op
        return (self.__arr[idx]*a + b) % MOD",O(1)
"class Solution(object):
    def minOperations(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        cnt = nums.count(1)
        if cnt:
            return len(nums)-cnt
        result = float(""inf"")
        for i in range(len(nums)): 
            g = nums[i]
            for j in range(i+1, len(nums)):
                g = gcd(g, nums[j])
                if g == 1:
                    result = min(result, j-i)
                    break
        return result+(len(nums)-1) if result != float(""inf"") else -1",O(n ^ 2)
"import collections
import operator
from functools import reduce



class Solution(object):
    def countTheNumOfKFreeSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))",O(n)
"class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(range(cols)):
            for j in reversed(range(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return """".join(result)",O(n)
"class Solution2(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
        while result and result[-1] == ' ':
            result.pop()
        return """".join(result)",O(n)
"class Solution(object):
    def averageValue(self, nums):
        total = cnt = 0
        for x in nums:
            if x%6:
                continue
            total += x
            cnt += 1
        return total//cnt if cnt else 0",O(n)
"class Solution(object):
    def maximumScoreAfterOperations(self, edges, values):
        def iter_dfs():
            dp = [0]*len(values)
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop() 
                if step == 1:
                    if len(adj[u]) == (1 if u else 0):
                        dp[u] = values[u]
                        continue
                    stk.append((2, u, p))
                    for v in reversed(adj[u]):
                        if v != p:
                            stk.append((1, v, u))
                elif step == 2:
                    dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u]) 
            return dp[0]

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-iter_dfs()",O(n)
"class Solution2(object):
    def maximumScoreAfterOperations(self, edges, values):
        def dfs(u, p):
            if len(adj[u]) == (1 if u else 0):
                return values[u]
            return min(sum(dfs(v, u) for v in adj[u] if v != p), values[u]) 

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-dfs(0, -1)",O(n)
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for i in range(len(nums)-2):
            if nums[i]:
                continue
            nums[i+1] ^= 1
            nums[i+2] ^= 1
            result += 1
        return result if nums[-2] == nums[-1] == 1 else -1",O(n)
"class Solution(object):
    def duplicateZeros(self, arr):
        shift, i = 0, 0
        while i+shift < len(arr):
            shift += int(arr[i] == 0)
            i += 1
        i -= 1
        while shift:
            if i+shift < len(arr):
                arr[i+shift] = arr[i]
            if arr[i] == 0:
                shift -= 1
                arr[i+shift] = arr[i]
            i -= 1",O(n)
"class Solution(object):
    def maximumPopulation(self, logs):
        MIN_YEAR, MAX_YEAR = 1950, 2050
        years = [0]*(MAX_YEAR-MIN_YEAR+1)
        for s, e in logs:
            years[s-MIN_YEAR] += 1
            years[e-MIN_YEAR] -= 1
        result = 0
        for i in range(len(years)):
            if i:
                years[i] += years[i-1]
            if years[i] > years[result]:
                result = i
        return result+MIN_YEAR",O(n)
"

class Solution(object):
    def findClosestNumber(self, nums):
        return max(nums, key=lambda x:(-abs(x), x))
",O(n)
"class Solution(object):

    def __init__(self, n):
        self.__size = n
        self.__rows = [[0, 0] for _ in range(n)]
        self.__cols = [[0, 0] for _ in range(n)]
        self.__diagonal = [0, 0]
        self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):
        i = player - 1
        self.__rows[row][i] += 1
        self.__cols[col][i] += 1
        if row == col:
            self.__diagonal[i] += 1
        if col == len(self.__rows) - row - 1:
            self.__anti_diagonal[i] += 1
        if any(self.__rows[row][i] == self.__size,
               self.__cols[col][i] == self.__size,
               self.__diagonal[i] == self.__size,
               self.__anti_diagonal[i] == self.__size):
            return player

        return 0",O(1)
"class Solution(object):
    def flipLights(self, n, m):
        if m == 0:
            return 1
        if n == 1:
            return 2
        if m == 1 and n == 2:
            return 3
        if m == 1 or n == 2:
            return 4
        if m == 2:
            return 7
        return 8",O(1)
"class Solution(object):
    def bestClosingTime(self, customers):
        result = mx = curr = 0
        for i, x in enumerate(customers):
            curr += 1 if x == 'Y' else -1
            if curr > mx:
                mx = curr
                result = i+1
        return result",O(n)
"import collections


class Solution(object):
    def getImportance(self, employees, id):
        if employees[id-1] is None:
            return 0
        result = employees[id-1].importance
        for id in employees[id-1].subordinates:
            result += self.getImportance(employees, id)
        return result",O(n)
"class Solution2(object):
    def getImportance(self, employees, id):
        result, q = 0, collections.deque([id])
        while q:
            curr = q.popleft()
            employee = employees[curr-1]
            result += employee.importance
            for id in employee.subordinates:
                q.append(id)
        return result",O(n)
"class Solution(object):
    def digitsCount(self, d, low, high):
        def digitsCount(n, k):
            pivot, result = 1, 0
            while n >= pivot:
                result += (n//(10*pivot))*pivot + \
                           min(pivot, max(n%(10*pivot) - k*pivot + 1, 0))
                if k == 0:
                    result -= pivot
                pivot *= 10
            return result+1
        
        return digitsCount(high, d) - digitsCount(low-1, d)",O(logn)
"class Solution(object):
    def numberOfArithmeticSlices(self, A):
        res, i = 0, 0
        while i+2 < len(A):
            start = i
            while i+2 < len(A) and A[i+2] + A[i] == 2*A[i+1]:
                res += i - start + 1
                i += 1
            i += 1

        return res",O(n)
"class Solution(object):
    def mergeTriplets(self, triplets, target):
        result = [0]*3
        for t in triplets:
            if all(t[i] <= target[i] for i in range(3)):
                result = [max(result[i], t[i]) for i in range(3)]
        return result == target",O(n)
"class Solution(object):
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        return left",O(logn)
"class Solution(object):
    def bagOfTokensScore(self, tokens, P):
        tokens.sort()
        result, points = 0, 0
        left, right = 0, len(tokens)-1
        while left <= right:
            if P >= tokens[left]:
                P -= tokens[left]
                left += 1
                points += 1
                result = max(result, points)
            elif points > 0:
                points -= 1
                P += tokens[right]
                right -= 1
            else:
                break
        return result",O(nlogn)
"class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0 or s[0] == '0':
            return 0
        prev, prev_prev = 1, 0
        for i in range(len(s)):
            cur = 0
            if s[i] != '0':
                cur = prev
            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):
                cur += prev_prev
            prev, prev_prev = cur, prev
        return prev",O(n)
"class Solution(object):
    def maxNonOverlapping(self, nums, target):
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] >= right:
                right = i
                result += 1 
            lookup[accu] = i
        return result",O(n)
"import collections



class Solution(object):
    def largestInteger(self, nums, k):
        if k == len(nums):
            return max(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        if k == 1:
            return max(x for x, v in cnt.items() if v == 1) if any(v == 1 for v in cnt.values()) else -1
        result = -1
        if cnt[nums[0]] == 1:
            result = max(result, nums[0])
        if cnt[nums[-1]] == 1:
            result = max(result, nums[-1])
        return result",O(n)
"import bisect


class Solution(object):
    def sampleStats(self, count):
        n = sum(count)
        mi = next(i for i in range(len(count)) if count[i]) * 1.0
        ma = next(i for i in reversed(range(len(count))) if count[i]) * 1.0
        mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n
        mode = count.index(max(count)) * 1.0
        for i in range(1, len(count)):
            count[i] += count[i-1]
        median1 = bisect.bisect_left(count, (n+1) // 2)
        median2 = bisect.bisect_left(count, (n+2) // 2)
        median = (median1+median2) / 2.0
        return [mi, ma, mean, median, mode]",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def goodNodes(self, root):
        result = 0
        stk = [(root, root.val)]
        while stk:
            node, curr_max = stk.pop()
            if not node:
                continue
            curr_max = max(curr_max, node.val)
            result += int(curr_max <= node.val)
            stk.append((node.right, curr_max))
            stk.append((node.left, curr_max))
        return result",O(n)
"class Solution2(object):
    def goodNodes(self, root):
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max <= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)",O(n)
"class Solution(object):
    def minSwaps(self, data):
        total_count = sum(data)
        result, count, left = 0, 0, 0
        for i in range(len(data)):
            count += data[i]
            if i-left+1 > total_count: 
                count -= data[left]
                left += 1
            result = max(result, count)
        return total_count-result",O(n)
"import random



class Solution(object):
    def outerTrees(self, trees):
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) < c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries): 
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]",O(n)
"
class Solution(object):
    def removeVowels(self, S):
        lookup = set(""aeiou"")
        return """".join(c for c in S if c not in lookup)
",O(n)
"class Solution(object):
    def countConsistentStrings(self, allowed, words):
        lookup = [False]*26
        for c in allowed:
            lookup[ord(c)-ord('a')] = True
        result = len(words)
        for word in words:
            for c in word:
                if not lookup[ord(c)-ord('a')]:
                    result -= 1
                    break
        return result",O(n)
"class Solution(object):
    def arrayNesting(self, nums):
        result = 0
        for num in nums:
            if num is not None:
                start, count = num, 0
                while nums[start] is not None:
                    temp = start
                    start = nums[start]
                    nums[temp] = None
                    count += 1
                result = max(result, count)
        return result",O(n)
"class Solution(object):
    def rotateString(self, A, B):
        def check(index):
            return all(A[(i+index) % len(A)] == c
                       for i, c in enumerate(B))

        if len(A) != len(B):
            return False

        M, p = 10**9+7, 113
        p_inv = pow(p, M-2, M)

        b_hash, power = 0, 1
        for c in B:
            b_hash += power * ord(c)
            b_hash %= M
            power = (power*p) % M

        a_hash, power = 0, 1
        for i in range(len(B)):
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            power = (power*p) % M

        if a_hash == b_hash and check(0): return True

        power = (power*p_inv) % M
        for i in range(len(B), 2*len(A)):
            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            if a_hash == b_hash and check(i-len(B)+1):
                return True

        return False",O(n)
"class Solution2(object):
    def rotateString(self, A, B):
        def strStr(haystack, needle):
            def KMP(text, pattern):
                prefix = getPrefix(pattern)
                j = -1
                for i in range(len(text)):
                    while j > -1 and pattern[j + 1] != text[i]:
                        j = prefix[j]
                    if pattern[j + 1] == text[i]:
                        j += 1
                    if j == len(pattern) - 1:
                        return i - j
                return -1

            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix

            if not needle:
                return 0
            return KMP(haystack, needle)

        if len(A) != len(B):
            return False
        return strStr(A*2, B) != -1",O(n)
"class Solution3(object):
    def rotateString(self, A, B):
        return len(A) == len(B) and B in A*2",O(n ^ 2)
"class Solution(object):
    def maxIceCream(self, costs, coins):
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins < 0:
                return i
        return len(costs)",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
       if self.set[x] != x:
           self.set[x] = self.find_set(self.set[x]) 
       return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)
            self.count -= 1


class Solution(object):
    def regionsBySlashes(self, grid):
        def index(n, i, j, k):
            return (i*n + j)*4 + k
    
        union_find = UnionFind(len(grid)**2 * 4)
        N, E, S, W = list(range(4))
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i:
                    union_find.union_set(index(len(grid), i-1, j, S),
                                         index(len(grid),i, j, N))
                if j:
                    union_find.union_set(index(len(grid), i, j-1, E),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""/"":
                    union_find.union_set(index(len(grid), i, j, N),
                                         index(len(grid), i, j, E))
                    union_find.union_set(index(len(grid), i, j, S),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""\\"":
                    union_find.union_set(index(len(grid), i, j, W),
                                         index(len(grid), i, j, N))
                    union_find.union_set(index(len(grid), i, j, E),
                                         index(len(grid), i, j, S))
        return union_find.count",O(n ^ 2)
"class Solution(object):
    def numMovesStones(self, a, b, c):
        s = [a, b, c]
        s.sort()
        if s[0]+1 == s[1] and s[1]+1 == s[2]:
            return [0, 0]
        return [1 if s[0]+2 >= s[1] or s[1]+2 >= s[2] else 2, s[2]-s[0]-2]",O(1)
"class Solution2(object):
    def numMovesStones(self, a, b, c):
        stones = [a, b, c]
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]",O(1)
"class Solution(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        max_val, min_val = max(nums), min(nums)
        gap = max(1, (max_val - min_val) / (len(nums) - 1))
        bucket_size = (max_val - min_val) / gap + 1
        bucket = [{'min':float(""inf""), 'max':float(""-inf"")} \
                    for _ in range(bucket_size)]

        for n in nums:
            if n in (max_val, min_val):
                continue
            i = (n - min_val) / gap
            bucket[i]['min'] = min(bucket[i]['min'], n)
            bucket[i]['max'] = max(bucket[i]['max'], n)

        max_gap, pre_bucket_max = 0, min_val
        for i in range(bucket_size):
            if bucket[i]['min'] == float(""inf"") and \
                bucket[i]['max'] == float(""-inf""):
                continue
            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)
            pre_bucket_max = bucket[i]['max']
        max_gap = max(max_gap, max_val - pre_bucket_max)

        return max_gap",O(n)
"class Solution2(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        nums.sort()
        pre = nums[0]
        max_gap = float(""-inf"")

        for i in nums:
            max_gap = max(max_gap, i - pre)
            pre = i
        return max_gap",O(nlogn)
"class Solution(object):
    def fillCups(self, amount):
        return max(max(amount), (sum(amount)+1)//2)",O(1)
"class Solution2(object):
    def fillCups(self, amount):
        mx, total = max(amount), sum(amount)
        return mx if sum(amount)-mx <= mx else (total+1)//2",O(1)
"import collections


class Solution(object):
    def characterReplacement(self, s, k):
        result, max_count = 0, 0
        count = collections.Counter()
        for i in range(len(s)):
            count[s[i]] += 1
            max_count = max(max_count, count[s[i]])
            if result - max_count >= k:
                count[s[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2

            if nums[mid] == target:
                return mid
            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \
                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):
                right = mid - 1
            else:
                left = mid + 1

        return -1",O(logn)
"import collections



class Solution(object):
    def minCost(self, nums):
        dp = collections.defaultdict(lambda: float(""inf""))
        dp[nums[0]] = 0
        for i in range(1, len(nums)-1, 2):
            new_dp = collections.defaultdict(lambda: float(""inf""))
            x, y = nums[i], nums[i+1]
            for z, c in dp.items():
                v = sorted([x, y, z])
                new_dp[v[0]] = min(new_dp[v[0]], c+v[2])
                new_dp[v[2]] = min(new_dp[v[2]], c+v[1])
            dp = new_dp
        last = nums[-1] if len(nums)%2 == 0 else 0
        return min(c+max(x, last) for x, c in dp.items())",other
"class Solution(object):
    def numberOfSteps (self, num):
        result = 0
        while num:
            result += 2 if num%2 else 1
            num //= 2
        return max(result-1, 0)",O(logn)
"
import bisect


class Solution(object):
    def increasingTriplet(self, nums):
        min_num, a, b = float(""inf""), float(""inf""), float(""inf"")
        for c in nums:
            if min_num >= c:
                min_num = c
            elif b >= c:
                a, b = min_num, c
            else: 
                return True
        return False

",O(n)
"
class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x < y]
",O(n)
"class Solution(object):
    def maximumCoins(self, coins, k):
        def max_amount():
            coins.sort()
            result = curr = left = 0
            for right in range(len(coins)):
                curr += (coins[right][1]-coins[right][0]+1)*coins[right][2]
                while coins[right][1]-coins[left][1]+1 > k:
                    curr -= (coins[left][1]-coins[left][0]+1)*coins[left][2]
                    left += 1
                result = max(result, curr-max((coins[right][1]-coins[left][0]+1)-k, 0)*coins[left][2])
            return result
    
        result = max_amount()
        for i, (l, r, w) in enumerate(coins):
            coins[i][:] = [-r, -l, w]
        result = max(result, max_amount())
        return result",O(nlogn)
"class Solution(object):
    def maximumTotalCost(self, nums):
        dp = [nums[0], float(""-inf"")]
        for i in range(1, len(nums)):
            dp[:] = [max(dp)+nums[i], dp[0]-nums[i]]
        return max(dp)",O(n)
"import collections


class Solution(object):
    def longestPalindrome(self, s):
        odds = 0
        for k, v in collections.Counter(s).items():
            odds += v & 1
        return len(s) - odds + int(odds > 0)

    def longestPalindrome2(self, s):
        odd = sum([x & 1 for x in list(collections.Counter(s).values())])
        return len(s) - odd + int(odd > 0)",O(n)
"class Solution(object):
    def minimumOperationsToWriteY(self, grid):
        cnt = [[0]*3 for _ in range(2)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1
        return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in range(3) for j in range(3) if i != j)",O(n ^ 2)
"class Solution(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt = 1 if len(nums) == 1 or cmp(nums[0], nums[1]) == 0 else 2
        for i in range(2, len(nums)):
            cnt = 1 if cmp(nums[i-1], nums[i]) == 0 else cnt+1 if cmp(nums[i-2], nums[i-1]) == cmp(nums[i-1], nums[i]) else 2
            result = max(result, cnt)
        return result",O(n)
"class Solution2(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt1 = cnt2 = 1
        for i in range(1, len(nums)):
            cnt1 = cnt1+1 if nums[i-1] < nums[i] else 1
            cnt2 = cnt2+1 if nums[i-1] > nums[i] else 1
            result = max(result, cnt1, cnt2)
        return result",O(n)
"class Solution3(object):
    def longestMonotonicSubarray(self, nums):
        def f(compare):
            result = l = 0
            for i in range(len(nums)):
                l += 1
                if i+1 == len(nums) or not compare(nums[i], nums[i+1]):
                    result = max(result, l)
                    l = 0
            return result

        return max(f(lambda x, y: x < y), f(lambda x, y: x > y))",O(n)
"
class Solution(object):
    def defangIPaddr(self, address):
        result = []
        for c in address:
            if c == '.':
                result.append(""[.]"")
            else:
                result.append(c)
        return """".join(result)
",O(n)
"class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        sl = SortedList()
        for i, x in enumerate(nums):
            v = max(query(sl, (x-i)+1), 0)+x
            update(sl, x-i, v)
        return sl[-1][1]",O(nlogn)
"class Solution2(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        bit = BIT(len(val_to_idx), default=NEG_INF, fn=max)
        for i, x in enumerate(nums):
            v = max(bit.query(val_to_idx[x-i]), 0)+x
            bit.update(val_to_idx[x-i], v)
        return bit.query(len(val_to_idx)-1)",O(nlogn)
"class Solution3(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        st = SegmentTree(len(val_to_idx))
        for i, x in enumerate(nums):
            v = max(st.query(0, val_to_idx[x-i]), 0)+x
            st.update(val_to_idx[x-i], v)
        return st.query(0, len(val_to_idx)-1)",O(nlogn)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(nums)%k
",O(n)
"class Solution(object):
    def sumBase(self, n, k):
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result",O(logn)
"class Solution(object):
    def maximumLength(self, nums):
        k = 2
        result = 0
        for i in range(k):
            dp = [0]*k
            for x in nums:
                dp[x%k] = dp[(i-x)%k]+1
            result = max(result, max(dp))
        return result",O(n)
"class Solution2(object):
    def maximumLength(self, nums):
        return max(sum(x%2 == 0 for x in nums),
                   sum(x%2 == 1 for x in nums),
                   sum(nums[i]%2 != nums[i+1]%2 for i in range(len(nums)-1))+1)",O(n)
"class Solution(object):
    def numberOfWays(self, n):
        MOD = 10**9+7












        return (1+((n//2)+1)*(n//2)//2)%MOD",O(1)
"class Solution2(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        def count_1_2_6(n):
            return (n//2+1)*((n//6)-0+1)-3*((n//6)+0)*((n//6)-0+1)//2

        return reduce(lambda x, y: (x+count_1_2_6(n-4*y))%MOD, (i for i in range(min(n//4, 2)+1)), 0)",O(1)
"class Solution3(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        def count_1_2(n):
            return n//2+1
    
        def count_1_2_6(n):
            return sum(count_1_2(n-6*i) for i in range((n//6)+1))

        return reduce(lambda x, y: (x+count_1_2_6(n-4*y))%MOD, (i for i in range(min(n//4, 2)+1)), 0)",other
"class Solution4(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        dp = [0]*(n+1)
        dp[0] = 1
        for i in (1, 2, 6):
            for j in range(i, n+1):
                dp[j] += dp[j-i]
        return reduce(lambda x, y: (x+dp[n-4*y])%MOD, (i for i in range(min(n//4, 2)+1)), 0)",O(n)
"import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        MOD = 10**9 + 7
        result, s_sum = 0, 0
        min_heap = []
        for e, s in sorted(zip(efficiency, speed), reverse=True):
            s_sum += s
            heapq.heappush(min_heap, s)
            if len(min_heap) > k:
                s_sum -= heapq.heappop(min_heap)
            result = max(result, s_sum*e)
        return result % MOD",O(nlogn)
"class Solution(object):
    def minOperations(self, k):
        def isqrt(n):
            a, b = n, (n+1)//2
            while b < a:
                a, b = b, (b+n//b)//2
            return a

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        x = isqrt(k)
        return (x-1)+(ceil_divide(k, x)-1)",O(logn)
"

class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))
",O(n)
"class Solution(object):
    def calculateTax(self, brackets, income):
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result",O(n)
"class Solution(object):
    def lastNonEmptyString(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        mx = max(cnt)
        result = []
        for x in reversed(s):
            if cnt[ord(x)-ord('a')] != mx:
                continue
            cnt[ord(x)-ord('a')] -= 1
            result.append(x)
        return """".join(reversed(result))",O(n)
"class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result",O(nlogn)
"import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        result = 0
        cnt = collections.Counter()
        for c in s:
            cnt[c] += 1
            result += cnt[c]
        return result",O(n)
"import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        return sum(v*(v+1)//2 for v in collections.Counter(s).values())",O(n)
"import random


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def kthLargestLevelSum(self, root, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        arr = []
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
            arr.append(sum(x.val for x in q))
            q = new_q
        if k-1 >= len(arr):
            return -1
        nth_element(arr, k-1, compare=lambda a, b: a > b)
        return arr[k-1]",O(n)
"class Solution(object):
    def minSubArrayLen(self, s, nums):
        start = 0
        sum = 0
        min_size = float(""inf"")
        for i in range(len(nums)):
            sum += nums[i]
            while sum >= s:
                min_size = min(min_size, i - start + 1)
                sum -= nums[start]
                start += 1

        return min_size if min_size != float(""inf"") else 0",O(n)
"class Solution2(object):
    def minSubArrayLen(self, s, nums):
        min_size = float(""inf"")
        sum_from_start = [n for n in nums]
        for i in range(len(sum_from_start) - 1):
            sum_from_start[i + 1] += sum_from_start[i]
        for i in range(len(sum_from_start)):
            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \
                                    i, len(sum_from_start), \
                                    sum_from_start[i] - nums[i] + s)
            if end < len(sum_from_start):
                min_size = min(min_size, end - i + 1)

        return min_size if min_size != float(""inf"") else 0

    def binarySearch(self, compare, A, start, end, target):
        while start < end:
            mid = start + (end - start) / 2
            if compare(target, A[mid]):
                end = mid
            else:
                start = mid + 1
        return start",O(nlogn)
"class Solution(object):
    def stoneGameVIII(self, stones):
        for i in range(len(stones)-1):
            stones[i+1] += stones[i]
        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(range(1, len(stones)-1)), stones[-1])",O(n)
"class Solution(object):
    def minIncrementOperations(self, nums, k):
        W = 3
        dp = [0]*W
        for i, x in enumerate(nums):
            dp[i%W] = min(dp[j%W] for j in range(i-W, i))+max(k-x, 0)
        return min(dp)",O(n)
"MOD = 10**9+7
MAX_N = 1000
fact = [0]*(2*MAX_N-1+1)
inv = [0]*(2*MAX_N-1+1)
inv_fact = [0]*(2*MAX_N-1+1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in range(2, len(fact)):
    fact[i] = fact[i-1]*i % MOD
    inv[i] = inv[MOD%i]*(MOD-MOD//i) % MOD 
    inv_fact[i] = inv_fact[i-1]*inv[i] % MOD

class Solution(object):
    def numberOfSets(self, n, k):
        def nCr(n, k, mod):
            return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod
        return nCr(n+k-1, 2*k, MOD)",O(1)
"class Solution(object):
    def minimumMoves(self, s):
        result = i = 0
        while i < len(s):
            if s[i] == 'X':
                result += 1
                i += 3
            else:
                i += 1
        return result",O(n)
"class Solution(object):
    def threeEqualParts(self, A):
        total = sum(A)
        if total % 3 != 0:
            return [-1, -1]
        if total == 0:
            return [0, len(A)-1]

        count = total//3
        nums = [0]*3
        c = 0
        for i in range(len(A)):
            if A[i] == 1:
                if c % count == 0:
                    nums[c//count] = i
                c += 1

        while nums[2] != len(A):
            if not A[nums[0]] == A[nums[1]] == A[nums[2]]:
                return [-1, -1]
            nums[0] += 1
            nums[1] += 1
            nums[2] += 1
        return [nums[0]-1, nums[1]]",O(n)
"class Solution(object):
    def numberOfPairs(self, nums):
        cnt = [0]*(max(nums)+1)
        pair_cnt = 0
        for x in nums:
            cnt[x] ^= 1
            if not cnt[x]:
                pair_cnt += 1
        return [pair_cnt, len(nums)-2*pair_cnt]",O(n)
"import collections



class Solution2(object):
    def numberOfPairs(self, nums):
        cnt = collections.Counter(nums)
        pair_cnt = sum(x//2 for x in cnt.values())
        return [pair_cnt, len(nums)-2*pair_cnt]",O(n)
"class Solution(object):
    def candy(self, ratings):
        candies = [1 for _ in range(len(ratings))]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1

        for i in reversed(range(1, len(ratings))):
            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:
                candies[i - 1] = candies[i] + 1

        return sum(candies)",O(n)
"import collections



class Solution(object):
    def countPalindromePaths(self, parent, s):
        def iter_dfs():
            result = 0
            cnt = collections.defaultdict(int)
            cnt[0] = 1
            stk = [(0, 0)]
            while stk:
                u, mask = stk.pop()
                if u:
                    mask ^= 1<<(ord(s[u])-ord('a'))
                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                    cnt[mask] += 1
                for v in reversed(adj[u]):
                    stk.append((v, mask))
            return result

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        return iter_dfs()",O(n)
"import collections



class Solution2(object):
    def countPalindromePaths(self, parent, s):
        def dfs(u, mask):
            result = 0
            if u:
                mask ^= 1<<(ord(s[u])-ord('a'))
                result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                cnt[mask] += 1
            return result+sum(dfs(v, mask) for v in adj[u])

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        cnt = collections.defaultdict(int)
        cnt[0] = 1
        return dfs(0, 0)",O(n)
"class Solution(object):
    def missingInteger(self, nums):
        total = nums[0]
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]+1:
                break
            total += nums[i]
        lookup = set(nums)
        while total in lookup:
            total += 1
        return total",O(n)
"import collections


class Solution(object):
    def checkAlmostEquivalent(self, word1, word2):
        k = 3
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)
        return all(abs(cnt1[c]-cnt2[c]) <= k for c in set(list(cnt1.keys())+list(cnt2.keys())))",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def recoverFromPreorder(self, S):
        i = 0
        stack = []
        while i < len(S):
            level = 0
            while i < len(S) and S[i] == '-':
                level += 1
                i += 1
            while len(stack) > level:
                stack.pop()
            val = []
            while i < len(S) and S[i] != '-':
                val.append(S[i])
                i += 1
            node = TreeNode(int("""".join(val)))
            if stack:
                if stack[-1].left is None:
                    stack[-1].left = node
                else:
                    stack[-1].right = node
            stack.append(node)
        return stack[0]",O(n)
"class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])",O(n)
"class Solution(object):
    def maxConsecutive(self, bottom, top, special):
        special.sort()
        result = max(special[0]-bottom, top-special[-1])
        for i in range(1, len(special)):
            result = max(result, special[i]-special[i-1]-1)
        return result",O(nlogn)
"class Solution(object):
    def minimumRecolors(self, blocks, k):
        result = k
        curr = 0
        for i, x in enumerate(blocks):
            curr += int(blocks[i] == 'W')
            if i+1-k < 0:
                continue
            result = min(result, curr)
            curr -= int(blocks[i+1-k] == 'W')
        return result",O(n)
"class Solution(object):
    def numberOfSubstrings(self, s):
        result, left = 0, [-1]*3
        for right, c in enumerate(s):
            left[ord(c)-ord('a')] = right
            result += min(left)+1
        return result",O(n)
"class Solution2(object):
    def numberOfSubstrings(self, s):
        result, left, count = 0, 0, [0]*3
        for right, c in enumerate(s):
            count[ord(s[right])-ord('a')] += 1
            while all(count):
                count[ord(s[left])-ord('a')] -= 1
                left += 1
            result += left
        return result",O(n)
"class Solution3(object):
    def numberOfSubstrings(self, s):
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right < len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result",O(n)
"
class Node(object):
    def __init__(self, val, left, right):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def treeToDoublyList(self, root):
        if not root:
            return None
        left_head, left_tail, right_head, right_tail = root, root, root, root
        if root.left:
            left_head = self.treeToDoublyList(root.left)
            left_tail = left_head.left
        if root.right:
            right_head = self.treeToDoublyList(root.right)
            right_tail = right_head.left
        left_tail.right, right_head.left = root, root
        root.left, root.right = left_tail, right_head
        left_head.left, right_tail.right = right_tail, left_head
        return left_head

",O(n)
"import collections


class Solution(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        lookup = collections.defaultdict(lambda: [False]*3)
        for r, c in reservedSeats:
            if 2 <= c <= 5:
                lookup[r][0] = True
            if 4 <= c <= 7:
                lookup[r][1] = True
            if 6 <= c <= 9:
                lookup[r][2] = True
        result = 2*n
        for a, b, c in lookup.values():
            if not a and not c:
                continue
            if not a or not b or not c:
                result -= 1
                continue
            result -= 2
        return result",O(n)
"class Solution2(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        reservedSeats.sort()
        result, i = 2*n, 0
        while i < len(reservedSeats):
            reserved = [False]*3
            curr = reservedSeats[i][0]
            while i < len(reservedSeats) and reservedSeats[i][0] == curr:
                _, c  = reservedSeats[i]
                if 2 <= c <= 5:
                    reserved[0] = True
                if 4 <= c <= 7:
                    reserved[1] = True
                if 6 <= c <= 9:
                    reserved[2] = True
                i += 1
            if not reserved[0] and not reserved[2]:
                continue
            if not all(reserved):
                result -= 1
                continue
            result -= 2
        return result",O(nlogn)
"class Solution(object):
    def nthUglyNumber(self, n, a, b, c):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def lcm(x, y):
            return x//gcd(x, y)*y

        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c

        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

        left, right = 1, 2*10**9
        while left <= right:
            mid = left + (right-left)//2
            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"class Solution(object):
    def possibleStringCount(self, word):
        return len(word)-sum(word[i] != word[i+1] for i in range(len(word)-1))",O(n)
"class Solution2(object):
    def possibleStringCount(self, word):
        result = 1
        curr = 0
        for i in range(len(word)):
            curr += 1
            if i+1 == len(word) or word[i+1] != word[i]:
                result += curr-1
                curr = 0
        return result",O(n)
"class Solution(object):
    def validUtf8(self, data):
        count = 0
        for c in data:
            if count == 0:
                if (c >> 5) == 0b110:
                    count = 1
                elif (c >> 4) == 0b1110:
                    count = 2
                elif (c >> 3) == 0b11110:
                    count = 3
                elif (c >> 7):
                    return False
            else:
                if (c >> 6) != 0b10:
                    return False
                count -= 1
        return count == 0",O(n)
"class Solution(object):
    def maxDiff(self, num):
        digits = str(num)
        for b in digits:
            if b < '9':
                break
        if digits[0] != '1':
            a = digits[0]
        else:
            for a in digits:
                if a > '1':
                    break
        return int(digits.replace(b, '9')) - \
               int(digits.replace(a, '1' if digits[0] != '1' else '0'))",O(logn)
"
import bisect


class Solution(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left = bisect.bisect_left(LIS, target)
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target
    
        for num in nums:
            insert(num)
        return len(LIS)


",O(nlogn)
"class Solution2(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left, right = 0, len(LIS) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if LIS[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target

        for num in nums:
            insert(num)

        return len(LIS)",O(nlogn)
"class Solution3(object):
    def lengthOfLIS(self, nums):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
    
        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}
        bit = BIT(len(lookup), fn=max)
        for x in nums:
            bit.update(lookup[x], bit.query(lookup[x]-1)+1)
        return bit.query(len(lookup)-1)



class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution4(object):
    def lengthOfLIS(self, nums):
        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}
        st = SegmentTree(len(val_to_idx))
        for x in nums:
            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)
        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0",O(nlogn)
"class Solution5(object):
    def lengthOfLIS(self, nums):
        dp = [] 
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp) if dp else 0",O(n ^ 2)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True



class Solution(object):
    def maximumSafenessFactor(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs():
            dist = [[0 if grid[r][c] == 1 else -1 for c in range(len(grid[0]))] for r in range(len(grid))]
            q = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]]
            d = 0
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):
                            continue
                        dist[nr][nc] = d+1
                        new_q.append((nr, nc))
                q = new_q
                d += 1
            return dist

        dist = bfs()
        buckets = [[] for _ in range((len(grid)-1)+(len(grid[0])-1)+1)]
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                buckets[dist[r][c]].append((r, c))
        lookup = [[False]*len(grid[0]) for _ in range(len(grid))]
        uf = UnionFind(len(grid)*len(grid[0]))
        for d in reversed(range(len(buckets))):
            for r, c in buckets[d]:
                for dr, dc in DIRECTIONS:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and lookup[nr][nc] == True):
                        continue
                    uf.union_set(nr*len(grid[0])+nc, r*len(grid[0])+c)
                lookup[r][c] = True
            if uf.find_set(0*len(grid[0])+0) == uf.find_set((len(grid)-1)*len(grid[0])+(len(grid[0])-1)):
                break
        return d",O(n ^ 2)
"class Solution(object):
    def checkXMatrix(self, grid):
        return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in range(len(grid)) for j in range(len(grid[0])))",O(n ^ 2)
"class Solution(object):
    def maxSumAfterOperation(self, nums):
        prev_with_square = prev_without_square = 0
        result = 0
        for num in nums:
            without_square = max(num, num+prev_without_square)
            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)
            result = max(result, with_square)
            prev_with_square, prev_without_square = with_square, without_square
        return result",O(n)
"
import threading


class Solution(object):
    def __init__(self):
        self.__cv = threading.Condition()
        self.__has_first = False
        self.__has_second = False

    def first(self, printFirst):
        with self.__cv:
            printFirst()            
            self.__has_first = True
            self.__cv.notifyAll()

    def second(self, printSecond):
        with self.__cv:
            while not self.__has_first:
                self.__cv.wait()
            printSecond()
            self.__has_second = True
            self.__cv.notifyAll()
              
    def third(self, printThird):
        with self.__cv:
            while not self.__has_second:
                self.__cv.wait()
            printThird()
            self.__cv.notifyAll()
        
",O(1)
"class Solution(object):
    def maxScore(self, a, b):
        dp = [float(""-inf"")]*(len(a)+1)
        dp[0] = 0
        for x in b:
            for i in reversed(range(1, len(dp))):
                dp[i] = max(dp[i], dp[i-1]+x*a[i-1])
        return dp[-1]",other
"class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'",O(nlogn)
"class Solution3(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        result = 0
        for i in range(len(nums)):
            lookup = set()
            for j in reversed(range(i+1)):
                lookup.add(nums[j])
                result = (result+len(lookup)**2) % MOD
        return result",O(n ^ 2)
"import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def longestZigZag(self, root):
        def dfs(node, result):
            if not node:
                return [-1, -1]
            left, right = dfs(node.left, result), dfs(node.right, result)
            result[0] = max(result[0], left[1]+1, right[0]+1)
            return [left[1]+1, right[0]+1]

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"class Solution(object):
    def partitionDisjoint(self, A):
        B = A[:]
        for i in reversed(range(len(A)-1)):
            B[i] = min(B[i], B[i+1])
        p_max = 0
        for i in range(1, len(A)):
            p_max = max(p_max, A[i-1])
            if p_max <= B[i]:
                return i",O(n)
"class Solution(object):
    def twoSumLessThanK(self, A, K):
        A.sort()
        result = -1
        left, right = 0, len(A)-1
        while left < right:
            if A[left]+A[right] >= K:
                right -= 1
            else:
                result = max(result, A[left]+A[right])
                left += 1
        return result",O(nlogn)
"import collections


class Solution(object):
    def findLHS(self, nums):
        lookup = collections.defaultdict(int)
        result = 0
        for num in nums:
            lookup[num] += 1
            for diff in [-1, 1]:
                if (num + diff) in lookup:
                    result = max(result, lookup[num] + lookup[num + diff])
        return result",O(n)
"class Solution(object):
    def validateStackSequences(self, pushed, popped):
        i = 0
        s = []
        for v in pushed:
            s.append(v)
            while s and i < len(popped) and s[-1] == popped[i]:
                s.pop()
                i += 1
        return i == len(popped)",O(n)
"class Solution(object):
    def tictactoe(self, moves):
        row, col = [[0]*3 for _ in range(2)], [[0]*3 for _ in range(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return ""AB""[p]
            p ^= 1
        return ""Draw"" if len(moves) == 9 else ""Pending""",O(1)
"class Solution(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        count = [0]*(MAX_NUM+1)
        for num in nums:
            count[num] += 1
        n = len(nums)
        for i in range(len(count)):
            if i == n:
                return i
            n -= count[i]
        return -1",O(n)
"class Solution2(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        inplace_counting_sort(nums, reverse=True)
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"class Solution3(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums): 
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums: 
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True) 
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"class Solution4(object):
    def specialArray(self, nums):
        nums.sort(reverse=True) 
        for i in range(len(nums)): 
            if nums[i] <= i:
                break
        else:
            i += 1
        return -1 if i < len(nums) and nums[i] == i else i",O(nlogn)
"import itertools


class Solution(object):
    def areAlmostEqual(self, s1, s2):
        diff = []
        for a, b in zip(s1, s2):
            if a == b:
                continue
            if len(diff) == 2:
                return False
            diff.append([a, b] if not diff else [b, a])
        return not diff or (len(diff) == 2 and diff[0] == diff[1])",O(n)
"class Solution(object):
    def isTransformable(self, s, t):
        idxs = [[] for _ in range(10)]
        for i in reversed(range(len(s))):
            idxs[int(s[i])].append(i)
        for c in t:
            d = int(c)
            if not idxs[d]:
                return False
            for k in range(d): 
                if idxs[k] and idxs[k][-1] < idxs[d][-1]:
                    return False
            idxs[d].pop()
        return True",O(n)
"class Solution(object):
    def maxDistance(self, arrays):
        result, min_val, max_val = 0,  arrays[0][0], arrays[0][-1]
        for i in range(1, len(arrays)):
            result = max(result, \
                         max(max_val - arrays[i][0], \
                             arrays[i][-1] - min_val))
            min_val = min(min_val, arrays[i][0])
            max_val = max(max_val, arrays[i][-1])
        return result",O(n)
"class Solution(object):
    def find132pattern(self, nums):
        ak = float(""-inf"")
        stk = []
        for i in reversed(range(len(nums))):
            if nums[i] < ak:
                return True
            while stk and stk[-1] < nums[i]:
                ak = stk.pop()
            stk.append(nums[i])
        return False",O(n)
"class Solution_TLE(object):
    def find132pattern(self, nums):
        for k in range(len(nums)):
            valid = False
            for j in range(k):
                if nums[j] < nums[k]:
                    valid = True
                elif nums[j] > nums[k]:
                    if valid:
                        return True
        return False",O(n ^ 2)
"class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        def floydWarshall(n, graph): 
            reachable = set([x[0]*n+x[1] for x in graph]) 
            for k in range(n): 
                for i in range(n): 
                    for j in range(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]",O(n ^ 3)
"
import math


class Solution(object):
    def bulbSwitch(self, n):
        return int(math.sqrt(n))

",O(1)
"class Solution(object):
    def reductionOperations(self, nums):
        nums.sort()
        result = curr = 0
        for i in range(1, len(nums)): 
            if nums[i-1] < nums[i]:
                curr += 1
            result += curr
        return result",O(nlogn)
"class Solution(object):
    def minChanges(self, s):
        return sum(s[i] != s[i+1] for i in range(0, len(s), 2))",O(n)
"class Solution(object):
    def minOperations(self, nums, k):
        def popcount(x):
            return bin(x).count('1')
    
        return popcount(reduce(lambda x, y: x^y, nums, k))",O(n)
"class Solution(object):
    def maximizeWin(self, prizePositions, k):
        dp = [0]*(len(prizePositions)+1)
        result = left = 0
        for right in range(len(prizePositions)):
            while prizePositions[right]-prizePositions[left] > k:
                left += 1
            dp[right+1] = max(dp[right], right-left+1)
            result = max(result, dp[left]+(right-left+1))
        return result",O(n)
"class Solution(object):
    def pathInZigZagTree(self, label):
        count = 2**label.bit_length()
        result = []
        while label >= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result",O(logn)
"class Solution(object):
    def breakPalindrome(self, palindrome):
        for i in range(len(palindrome)//2):
            if palindrome[i] != 'a':
                return palindrome[:i] + 'a' + palindrome[i+1:]
        return palindrome[:-1] + 'b' if len(palindrome) >= 2 else """"",O(n)
"class Solution(object):
    def numRookCaptures(self, board):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        r, c = None, None
        for i in range(8):
            if r is not None:
                break
            for j in range(8):
                if board[i][j] == 'R':
                    r, c = i, j
                    break

        result = 0
        for d in directions:
            nr, nc = r+d[0], c+d[1]
            while 0 <= nr < 8 and 0 <= nc < 8:
                if board[nr][nc] == 'p':
                    result += 1
                if board[nr][nc] != '.':
                    break
                nr, nc= nr+d[0], nc+d[1]
        return result",O(1)
"class Solution(object):
    def maximalRectangle(self, matrix):
        def largestRectangleArea(heights):
            stk, result, i = [-1], 0, 0
            for i in range(len(heights)+1):
                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
                stk.append(i) 
            return result

        if not matrix:
            return 0
        result = 0
        heights = [0]*len(matrix[0])
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0
            result = max(result, largestRectangleArea(heights))
        return result",O(n ^ 2)
"class Solution2(object):
    def maximalRectangle(self, matrix):
        if not matrix:
            return 0

        result = 0
        m = len(matrix)
        n = len(matrix[0])
        L = [0 for _ in range(n)]
        H = [0 for _ in range(n)]
        R = [n for _ in range(n)]

        for i in range(m):
            left = 0
            for j in range(n):
                if matrix[i][j] == '1':
                    L[j] = max(L[j], left)
                    H[j] += 1
                else:
                    L[j] = 0
                    H[j] = 0
                    R[j] = n
                    left = j + 1

            right = n
            for j in reversed(range(n)):
                if matrix[i][j] == '1':
                    R[j] = min(R[j], right)
                    result = max(result, H[j] * (R[j] - L[j]))
                else:
                    right = j

        return result",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def balanceBST(self, root):
        def inorderTraversal(root):
            result, stk = [], [(root, False)]
            while stk:
                node, is_visited = stk.pop()
                if node is None:
                    continue
                if is_visited:
                    result.append(node.val)
                else:
                    stk.append((node.right, False))
                    stk.append((node, True))
                    stk.append((node.left, False))
            return result
    
        def sortedArrayToBst(arr):
            ROOT, LEFT, RIGHT = list(range(3))
            result = [None]
            stk = [(0, len(arr), ROOT, result)]
            while stk:
                i, j, update, ret = stk.pop()
                if i >= j:
                    continue
                mid = i + (j-i)//2
                node = TreeNode(arr[mid])
                if update == ROOT:
                    ret[0] = node
                elif update == LEFT:
                    ret[0].left = node
                else:
                    ret[0].right = node
                stk.append((mid+1, j, RIGHT, [node]))
                stk.append((i, mid, LEFT, [node]))
            return result[0]
        
        return sortedArrayToBst(inorderTraversal(root))",O(n)
"class Solution2(object):
    def balanceBST(self, root):
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i >= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))",O(n)
"
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child


class Solution(object):
    def flatten(self, head):
        curr = head
        while curr:
            if curr.child:
                curr_next = curr.__next__
                curr.child.prev = curr
                curr.next = curr.child
                last_child = curr
                while last_child.__next__:
                    last_child = last_child.__next__
                if curr_next:
                    last_child.next = curr_next
                    curr_next.prev = last_child
                curr.child = None
            curr = curr.__next__
        return head

",O(n)
"class Solution(object):
    def minimumReplacement(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = 0
        curr = nums[-1]
        for x in reversed(nums):
            cnt = ceil_divide(x, curr)
            result += cnt-1
            curr = x//cnt
        return result",O(n)
"class Solution(object):
    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):
        def cost(m, s):
            if not (0 <= m <= 99 and s <= 99):
                return float(""inf"")
            result = 0
            curr = startAt
            for x in map(int, list(str(m*100 + s))):
                result += (moveCost if x != curr else 0)+pushCost
                curr = x
            return result

        m, s = divmod(targetSeconds, 60)
        return min(cost(m, s), cost(m-1, s+60))",O(1)
"class Solution(object):
    def isValidSerialization(self, preorder):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]

        if not preorder:
            return False

        depth, cnt = 0, preorder.count(',') + 1
        for tok in split_iter(preorder, ','):
            cnt -= 1
            if tok == 
                depth -= 1
                if depth < 0:
                    break
            else:
                depth += 1
        return cnt == 0 and depth < 0",O(n)
"class Solution(object):
    def maxJump(self, stones):
        return stones[1]-stones[0] if len(stones) == 2 else max(stones[i+2]-stones[i] for i in range(len(stones)-2))",O(n)
"import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):
        result, lookup = 'a', collections.Counter()
        for i, c in enumerate(keysPressed):
            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))
            if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:
                result = c
        return result",O(n)
"class Solution(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in reversed(range(2, len(nums))):
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] > nums[i]:
                    result += right-left
                    right -= 1
                else:
                    left += 1
        return result",O(n ^ 2)
"class Solution2(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in range(len(nums)-2):
            if nums[i] == 0:
                continue
            k = i+2
            for j in range(i+1, len(nums)-1):
                while k < len(nums) and nums[i] + nums[j] > nums[k]:
                    k += 1
                result += k-j-1
        return result",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def upsideDownBinaryTree(self, root):
        p, parent, parent_right = root, None, None

        while p:
            left = p.left
            p.left = parent_right
            parent_right = p.right
            p.right = parent
            parent = p
            p = left

        return parent


",O(n)
"class Solution2(object):
    def upsideDownBinaryTree(self, root):
        return self.upsideDownBinaryTreeRecu(root, None)

    def upsideDownBinaryTreeRecu(self, p, parent):
        if p is None:
            return parent

        root = self.upsideDownBinaryTreeRecu(p.left, p)
        if parent:
            p.left = parent.right
        else:
            p.left = None
        p.right = parent

        return root",O(n)
"class Solution(object):
    def totalNumbers(self, digits):
        cnt = [0]*10
        for x in digits:
            cnt[x] += 1
        even = sum(cnt[i] != 0 for i in range(0, len(cnt), 2))
        odd = sum(cnt[i] != 0 for i in range(1, len(cnt), 2))
        result = 0
        for i in range(2, len(cnt), 2):
            if cnt[i] >= 3:
                result += 1 
        result += even*(odd+even-1)*(odd+even-2) 
        if cnt[0]:
            result -= 1*(even-1)*(odd+even-2) 
        for i in range(len(cnt)):
            if cnt[i] < 2:
                continue
            if i == 0:
                result += (odd+even)-1 
            elif i%2:
                result += even 
            else:
                result += 3*(even-1)-int(cnt[0] != 0) 
                result += 2*odd 
        return result",O(n)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k):
        result = cnt = left = 0
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
        return result",O(n)
"class Solution(object):
    def maxAdjacentDistance(self, nums):
        return max(abs(nums[i]-nums[i-1]) for i in range(len(nums)))",O(n)
"class Solution(object):
    def createTargetArray(self, nums, index):
        for i in range(len(nums)):
            for j in range(i):
                if index[j] >= index[i]:
                    index[j] += 1
        result = [0]*(len(nums))
        for i in range(len(nums)):
            result[index[i]] = nums[i]
        return result",O(n ^ 2)
"import itertools


class Solution2(object):
    def createTargetArray(self, nums, index):
        result = []
        for i, x in zip(index, nums):
            result.insert(i, x)
        return result",O(n ^ 2)
"import heapq


class Solution(object):
    def findSecondMinimumValue(self, root):
        def findSecondMinimumValueHelper(root, max_heap, lookup):
            if not root:
                return
            if root.val not in lookup:
                heapq.heappush(max_heap, -root.val)
                lookup.add(root.val)
                if len(max_heap) > 2:
                    lookup.remove(-heapq.heappop(max_heap))
            findSecondMinimumValueHelper(root.left, max_heap, lookup)
            findSecondMinimumValueHelper(root.right, max_heap, lookup)

        max_heap, lookup = [], set()
        findSecondMinimumValueHelper(root, max_heap, lookup)
        if len(max_heap) < 2:
            return -1
        return -max_heap[0]",O(n)
"class Solution(object):
    def maxScore(self, nums, x):
        dp = [float(""-inf"")]*2
        dp[nums[0]%2] = nums[0]
        for i in range(1, len(nums)):
            dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i]
        return max(dp)",O(n)
"class Solution(object):
    def countDays(self, days, meetings):
        meetings.sort()
        result = curr = 0
        for s, e in meetings:
            result += max((s-1)-curr, 0)
            curr = max(curr, e)
        result += days-curr
        return result",O(nlogn)
"class Solution(object):

    def __init__(self, A):
        self.__A = A
        self.__i = 0
        self.__cnt = 0

    def next(self, n):
        while self.__i < len(self.__A):
            if  n > self.__A[self.__i] - self.__cnt:
                n -= self.__A[self.__i] - self.__cnt
                self.__cnt = 0
                self.__i += 2
            else:
                self.__cnt += n
                return self.__A[self.__i+1]
        return -1",O(n)
"class Solution(object):
    def minTimeToType(self, word):
        return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + \
               sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1
                   for i in range(1, len(word)))",O(n)
"class Solution(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[1]-x[0]) 
        result = 0
        for a, m in tasks: 
            result = max(result+a, m)
        return result",O(nlogn)
"class Solution2(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[0]-x[1]) 
        result = curr = 0
        for a, m in tasks: 
            result += max(m-curr, 0)
            curr = max(curr, m)-a
        return result",O(nlogn)
"import collections


class Solution(object):
    def tupleSameProduct(self, nums):
        result = 0
        count = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                result += count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return 8*result",O(n ^ 2)
"class Solution(object):
    def removeTrailingZeros(self, num):
        return num[:next(i for i in reversed(range(len(num))) if num[i] != '0')+1]",O(n)
"import collections
import itertools


class Solution(object):
    def findSecretWord(self, wordlist, master):
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            count = [collections.Counter(w[i] for w in wordlist) for i in range(6)]
            guess = max(possible, key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x])))
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if sum(a == b for a, b in zip(wordlist[guess], wordlist[j])) == n]",other
"class Solution2(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = max(groups, key=len)
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]",O(n ^ 2)
"class Solution3(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = groups[0]
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]",O(n ^ 2)
"class Solution(object):
    def transformArray(self, arr):
        def is_changable(arr):
            return any(arr[i-1] > arr[i] < arr[i+1] or 
                       arr[i-1] < arr[i] > arr[i+1]
                       for i in range(1, len(arr)-1))
        
        while is_changable(arr):
            new_arr = arr[:]
            for i in range(1, len(arr)-1):
                new_arr[i] += arr[i-1] > arr[i] < arr[i+1]
                new_arr[i] -= arr[i-1] < arr[i] > arr[i+1]
            arr = new_arr
        return arr",O(n ^ 2)
"import bisect


class Solution(object):
    def sortedSquares(self, A):
        right = bisect.bisect_left(A, 0)
        left = right-1
        result = []
        while 0 <= left or right < len(A):
            if right == len(A) or \
               (0 <= left and A[left]**2 < A[right]**2):
                result.append(A[left]**2)
                left -= 1
            else:
                result.append(A[right]**2)
                right += 1
        return result",O(n)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        for i in range(maxLength+1):
            dp[i%w] = 1 if i == 0 else 0
            if i-oneGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD
            if i-zeroGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD
            if i >= minLength:
                result = (result+dp[i%w])%MOD
        return result",O(n)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        dp[0] = 1
        for i in range(maxLength+1):
            if i >= minLength:
                result = (result+dp[i%w])%MOD
            if i+oneGroup <= maxLength:
                dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD
            if i+zeroGroup <= maxLength:
                dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD
            dp[i%w] = 0
        return result",O(n)
"class Solution(object):
    def maxCoins(self, lane1, lane2):
        result = dp1 = dp12 = dp121 = float(""-inf"")
        for i in range(len(lane1)):
            dp1 = max(dp1, 0)+lane1[i]
            dp12 = max(max(dp12, 0)+lane2[i], dp1)
            dp121 = max(max(dp121, 0)+lane1[i], dp12)
            result = max(result, dp1, dp121)
        return result",O(n)
"import collections



class Solution(object):
    def checkStrings(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"class Solution(object):
    def waysToMakeFair(self, nums):
        prefix = [0]*2
        suffix = [sum(nums[i] for i in range(k, len(nums), 2)) for k in range(2)]
        result = 0
        for i, num in enumerate(nums):
            suffix[i%2] -= num
            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])
            prefix[i%2] += num
        return result",O(n)
"class Solution(object):
    def pivotInteger(self, n):
        x = int(((n+1)*n//2)**0.5+0.5)
        return x if x**2 == (n+1)*n//2 else -1",O(1)
"
import fractions


class Solution(object):
    def findGCD(self, nums):
        return fractions.gcd(min(nums), max(nums))
",other
"class Solution(object):
    def minimumCost(self, cost):
        cost.sort(reverse=True)
        return sum(x for i, x in enumerate(cost) if i%3 != 2)",O(nlogn)
"import collections


class Solution(object):
    def canArrange(self, arr, k):
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in range(1, k) if i in count)",O(n)
"class Solution(object):
    def maxProduct(self, nums):
        m1 = m2 = 0
        for num in nums:
            if num > m1:
                m1, m2 = num, m1
            elif num > m2:
                m2 = num
        return (m1-1)*(m2-1)",O(n)
"class Solution(object):
    def stableMountains(self, height, threshold):
        return [i for i in range(1, len(height)) if height[i-1] > threshold]",O(n)
"class Solution(object):
    def simulationResult(self, windows, queries):
        lookup = [False]*len(windows)
        result = []
        for x in reversed(queries):
            if lookup[x-1]:
                continue
            lookup[x-1] = True
            result.append(x)
        result.extend(x for x in windows if not lookup[x-1])
        return result",O(n)
"import collections



class Solution(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        dq = collections.deque()
        j = 0
        for i in range(len(prices)):
            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:
                dq.pop()
            dq.append(i)
            while j+(j+1) < i:
                assert(len(dq) != 0)
                if dq[0] == j:
                    dq.popleft()
                j += 1
            dp[i+1] = dp[dq[0]]+prices[dq[0]]
        return dp[-1]",O(n)
"from sortedcontainers import SortedList


class Solution2(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        sl = SortedList()
        j = 0
        for i in range(len(prices)):
            sl.add((dp[i]+prices[i], i))
            while j+(j+1) < i:
                sl.remove(((dp[j]+prices[j], j)))
                j += 1
            dp[i+1] = sl[0][0]
        return dp[-1]",O(nlogn)
"class Solution3(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        for i in range(len(prices)):
            for j in range(i//2, i+1):
                dp[i+1] = min(dp[i+1], dp[j]+prices[j])
        return dp[-1]",O(n ^ 2)
"

class Solution(object):
    def isStrictlyPalindromic(self, n):
        return False
",O(1)
"class Solution(object):
    def deleteString(self, s):
        if all(x == s[0] for x in s):
            return len(s)
        dp2 = [[0]*(len(s)+1) for i in range(2)] 
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(i+1, len(s)):
                dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0
                if dp2[i%2][j] >= j-i:
                    dp[i] = max(dp[i], dp[j]+1)
        return dp[0]",O(n ^ 2)
"class Solution2(object):
    def deleteString(self, s):
        def getPrefix(pattern, start):
            prefix = [-1]*(len(pattern)-start)
            j = -1
            for i in range(1, len(pattern)-start):
                while j != -1 and pattern[start+j+1] != pattern[start+i]:
                    j = prefix[j]
                if pattern[start+j+1] == pattern[start+i]:
                    j += 1
                prefix[i] = j
            return prefix

        if all(x == s[0] for x in s):
            return len(s)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            prefix = getPrefix(s, i) 
            for j in range(1, len(prefix), 2):
                if 2*(prefix[j]+1) == j+1:
                    dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1)
        return dp[0]",O(n ^ 2)
"class Solution3(object):
    def deleteString(self, s):
        MOD, P = 10**9+7, (113, 109)
        def hash(i, j):
            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in range(len(P))]

        if all(x == s[0] for x in s):
            return len(s)

        power = [[1] for _ in range(len(P))]
        prefix = [[0] for _ in range(len(P))]
        for x in s:
            for idx, p in enumerate(P):
                power[idx].append((power[idx][-1]*p)%MOD)
                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(1, (len(s)-i)//2+1):
                if hash(i, i+j-1) == hash(i+j, i+2*j-1):
                    dp[i] = max(dp[i], dp[i+j]+1)
        return dp[0]",O(n ^ 2)
"import collections


class Solution(object):
    def maxOperations(self, nums, k):
        count = collections.Counter()
        result = 0
        for x in nums:
            if k-x in count and count[k-x]:
                count[k-x] -= 1
                result += 1
            else:
                count[x] += 1
        return result",O(n)
"class Solution(object):
    def countAlternatingSubarrays(self, nums):
        result = curr = 0
        for i in range(len(nums)):
            if i-1 >= 0 and nums[i-1] == nums[i]:
                curr = 0
            curr += 1
            result += curr
        return result",O(n)
"class Solution(object):
    def findDifference(self, nums1, nums2):
        lookup = [set(nums1), set(nums2)]
        return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])]",O(n)
"class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 < len(word1) and arr_idx2 < len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)",O(n)
"

class Solution(object):
    def getEncryptedString(self, s, k):
        return """".join(s[(i+k)%len(s)] for i in range(len(s)))
",O(n)
"class Solution(object):
    def generate(self, numRows):
        result = []
        for i in range(numRows):
            result.append([])
            for j in range(i + 1):
                if j in (0, i):
                    result[i].append(1)
                else:
                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])
        return result

    def generate2(self, numRows):
        if not numRows: return []
        res = [[1]]
        for i in range(1, numRows):
            res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
        return res[:numRows]

    def generate3(self, numRows):
        if numRows == 0: return []
        if numRows == 1: return [[1]]
        res = [[1], [1, 1]]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while len(res) < numRows:
            res.extend([add(res[-1])])
        return res",O(n ^ 2)
"class Solution(object):
    def findLatestStep(self, arr, m):
        if m == len(arr):
            return m
        length = [0]*(len(arr)+2)
        result = -1
        for i, x in enumerate(arr):
            left, right = length[x-1], length[x+1]
            if left == m or right == m:
                result = i
            length[x-left] = length[x+right] = left+right+1
        return result",O(n)
"class Solution(object):
    def numKLenSubstrNoRepeats(self, S, K):
        result, i = 0, 0
        lookup = set()
        for j in range(len(S)):
            while S[j] in lookup:
                lookup.remove(S[i])
                i += 1
            lookup.add(S[j])
            result += j-i+1 >= K
        return result",O(n)
"class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left",O(n)
"
import pandas as pd



def Solution(weather: pd.DataFrame) -> pd.DataFrame:
    return weather.pivot(index=""month"", columns=""city"", values=""temperature"")
",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def hasPathSum(self, root, sum):
        if root is None:
            return False

        if root.left is None and root.right is None and root.val == sum:
            return True

        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)

",O(n)
"class Solution(object):
    def minMoves(self, nums, k):
        def moves(i, j):
            return prefix[j+1]-prefix[i]

        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        for i in range(len(idxs)-k+1):
            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1)) 
        result -= (k//2)*((k+1)//2) 
        return result",O(n)
"import operator
from functools import reduce



class Solution(object):
    def xorAllNums(self, nums1, nums2):
        return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ \
               (reduce(operator.xor, nums2) if len(nums1)%2 else 0)",O(n)
"import collections


class Solution(object):
    def subarraysDivByK(self, A, K):
        count = collections.defaultdict(int)
        count[0] = 1
        result, prefix = 0, 0
        for a in A:
            prefix = (prefix+a) % K
            result += count[prefix]
            count[prefix] += 1
        return result",O(n)
"class Solution(object):
    def findLengthOfShortestSubarray(self, arr):
        j = -1
        for j in reversed(range(1, len(arr))):
            if arr[j-1] > arr[j]:
                break
        else:
            return 0
        result = j
        for i in range(j):
            if i and arr[i] < arr[i-1]:
                break
            while j < len(arr) and arr[i] > arr[j]:
                j += 1
            result = min(result, (j-i+1)-2)
        return result",O(n)
"class Solution2(object):
    def findLengthOfShortestSubarray(self, arr):
        result = 0
        for i in range(1, len(arr)):
            if arr[i-1] <= arr[i]:
                continue
            j = len(arr)-1
            while j > i and (j == len(arr)-1 or arr[j] <= arr[j+1]) and arr[i-1] <= arr[j]:
                j -= 1
            result = j-i+1
            break
        for j in reversed(range(len(arr)-1)):
            if arr[j] <= arr[j+1]:
                continue
            i = 0
            while i < j and (i == 0 or arr[i-1] <= arr[i]) and arr[i] <= arr[j+1]:
                i += 1
            result = min(result, j-i+1)
            break
        return result",O(n)
"class Solution(object):
    def findContentChildren(self, g, s):
        g.sort()
        s.sort()

        result, i = 0, 0
        for j in range(len(s)):
            if i == len(g):
                break
            if s[j] >= g[i]:
                result += 1
                i += 1
        return result",O(nlogn)
"class Solution(object):
    def countNumbers(self, l, r, b):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        def count(x):
            digits_base = []
            while x:
                x, r = divmod(x, b)
                digits_base.append(r)
            digits_base.reverse()
            if not digits_base:
                digits_base.append(0)
            result = 0
            for i in range(len(digits_base)):
                if i-1 >= 0 and digits_base[i-1] > digits_base[i]:
                    break
                for j in range(digits_base[i-1] if i-1 >= 0 else 0, digits_base[i]):
                    result = (result + nHr((b-1)-j+1, len(digits_base)-(i+1))) % MOD
            else:
                result = (result+1)%MOD
            return result

        return (count(int(r)) - count(int(l)-1)) % MOD",other
"class Solution2(object):
    def countNumbers(self, l, r, b):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        def decrease(digits):
            for i in reversed(range(len(digits))):
                if digits[i]:
                    digits[i] -= 1
                    break
                digits[i] = 9

        def divide(digits, base):
            result = []
            r = 0
            for d in digits:
                q, r = divmod(r*10+d, base)
                if result or q:
                    result.append(q)
            return result, r

        def to_base(digits, base):
            result = []
            while digits:
                digits, r = divide(digits, base)
                result.append(r)
            result.reverse()
            return result

        def count(digits):
            digits_base = to_base(digits, b)
            result = 0
            for i in range(len(digits_base)):
                if i-1 >= 0 and digits_base[i-1] > digits_base[i]:
                    break
                for j in range(digits_base[i-1] if i-1 >= 0 else 0, digits_base[i]):
                    result = (result + nHr((b-1)-j+1, len(digits_base)-(i+1))) % MOD
            else:
                result = (result+1)%MOD
            return result

        digits_l = list(map(int, l))
        decrease(digits_l)
        digits_r = list(map(int, r))
        return (count(digits_r) - count(digits_l)) % MOD",other
"class Solution(object):
    def numberGame(self, nums):
        nums.sort()
        for i in range(0, len(nums), 2):
            nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def lcaDeepestLeaves(self, root):
        def lcaDeepestLeavesHelper(root):
            if not root:
                return 0, None
            d1, lca1 = lcaDeepestLeavesHelper(root.left)
            d2, lca2 = lcaDeepestLeavesHelper(root.right)
            if d1 > d2:
                return d1+1, lca1
            if d1 < d2:
                return d2+1, lca2
            return d1+1, root

        return lcaDeepestLeavesHelper(root)[1]",O(n)
"class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):
        result, lookup = -1, {}
        for i, c in enumerate(s):
            result = max(result, i-lookup.setdefault(c, i)-1)
        return result",O(n)
"class Solution(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            while left+1 < len(stk) and stk[left+1][0] <= prefix:
                left += 1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
            left = min(left, len(stk)-1)
        return dp",O(n)
"import collections



class Solution2(object):
    def findMaximumLength(self, nums):
        dp = prefix = prev_prefix = prev_dp = 0
        dq = collections.deque()
        for right in range(len(nums)):
            prefix += nums[right]
            while dq and dq[0][0] <= prefix:
                _, prev_prefix, prev_dp = dq.popleft()
            last, dp = prefix-prev_prefix, prev_dp+1
            while dq and dq[-1][0] >= last+prefix:
                dq.pop()
            dq.append((last+prefix, prefix, dp))
        return dp",O(n)
"import bisect



class Solution3(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            left = bisect.bisect_left(stk, (prefix+1, 0, 0))-1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
        return dp",O(nlogn)
"import bisect



class Solution4(object):
    def findMaximumLength(self, nums):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        prev = [-1]*(len(nums)+1)
        left = -1
        for right in range(len(nums)):
            left = max(left, prev[right])
            dp[right+1] = dp[left+1]+1
            next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1
            prev[next_right] = right
        return dp[-1]",O(nlogn)
"import collections
import itertools


class Solution(object):
    def threeSumMulti(self, A, target):
        count = collections.Counter(A)
        result = 0
        for i, j in itertools.combinations_with_replacement(count, 2):
            k = target - i - j
            if i == j == k:
                result += count[i] * (count[i]-1) * (count[i]-2) // 6
            elif i == j != k:
                result += count[i] * (count[i]-1) // 2 * count[k]
            elif max(i, j) < k:
                result += count[i] * count[j] * count[k]
        return result % (10**9 + 7)",O(n ^ 2)
"class Solution(object):
    def maximumScore(self, a, b, c):
        return min((a+b+c)//2, a+b+c - max(a, b, c))",O(1)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        initial_set = set(initial)
        clean = [i for i in range(len(graph)) if i not in initial_set]
        union_find = UnionFind(len(graph))
        for i in range(len(clean)):
            for j in range(i+1, len(clean)):
                if graph[clean[i]][clean[j]] == 1:
                    union_find.union_set(clean[i], clean[j])
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        
        shared_union = collections.defaultdict(set)
        for i in initial:
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    shared_union[x].add(i)

        result, total = float(""inf""), float(""-inf"")
        for i in initial:
            lookup = set()
            curr = 0
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    if len(shared_union[x]) == 1 and \
                       x not in lookup:
                        curr += union_size[x]
                        lookup.add(x)
            if curr > total or \
               (curr == total and i < result):
                total = curr
                result = i
        return result",O(n ^ 2)
"class Solution(object):
    def subsequenceSumOr(self, nums):
        result = prefix = 0
        for x in nums:
            prefix += x
            result |= x|prefix
        return result",O(n)
"class Solution2(object):
    def subsequenceSumOr(self, nums):
        result = cnt = 0
        for i in range(64):
            cnt >>= 1
            for x in nums:
                cnt += (x>>i)&1
            if cnt:
                result |= 1<<i
        return result",O(nlogn)
"class Solution(object):
    def longestOnes(self, A, K):
        result, i = 0, 0
        for j in range(len(A)):
            K -= int(A[j] == 0)
            while K < 0:
                K += int(A[i] == 0)
                i += 1
            result = max(result, j-i+1)
        return result",O(n)
"import collections



class Solution(object):
    def countAnagrams(self, s):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def lazy_init(n):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)

        def factorial(n):
            lazy_init(n)
            return fact[n]

        def inv_factorial(n):
            lazy_init(n)
            return inv_fact[n]

        def count(j, i):
            result = 1
            cnt = collections.Counter()
            for k in  range(j, i+1):
                cnt[s[k]] += 1
            result = factorial(sum(cnt.values()))
            for c in cnt.values():
                result = (result*inv_factorial(c))%MOD
            return result

        result = 1
        j = 0
        for i in range(len(s)):
            if i+1 != len(s) and s[i+1] != ' ':
                continue
            result = (result*count(j, i))%MOD
            j = i+2
        return result",O(n)
"class Solution(object):
    def convertTemperature(self, celsius):
        return [celsius+273.15, celsius*1.80+32.00]",O(1)
"class Solution(object):
    def addNegabinary(self, arr1, arr2):
        result = []
        carry = 0
        while arr1 or arr2 or carry:
            if arr1:
                carry += arr1.pop()
            if arr2:
                carry += arr2.pop()
            result.append(carry & 1)
            carry = -(carry >> 1)
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        result.reverse()
        return result",O(n)
"class Solution(object):
    def sumOfThree(self, num):
        return [num//3-1, num//3, num//3+1] if num%3 == 0 else []",O(1)
"class Solution(object):
    def minKnightMoves(self, x, y):
        x, y = abs(x), abs(y)
        if x < y:
            x, y = y, x
        lookup = {(1, 0):3, (2, 2):4} 
        if (x, y) in lookup:
            return lookup[(x, y)]
        k = x-y
        if y > k:
            return k - 2*((k-y)//3)
        return k - 2*((k-y)//4)",O(1)
"class Solution2(object):
    def __init__(self):
        self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3} 

    def minKnightMoves(self, x, y):
        def dp(x, y):
            x, y = abs(x), abs(y)
            if x < y:
                x, y = y, x
            if (x, y) not in self.__lookup: 
                self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1
            return self.__lookup[(x, y)]
        return dp(x, y)",O(n ^ 2)
"class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result",O(n)
"class Solution(object):
    def minNumberOperations(self, target):
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))",O(n)
"import collections



class Solution(object):
    def minSteps(self, s, t):
        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)
        return sum((cnt1-cnt2).values())+sum((cnt2-cnt1).values())",O(n)
"import collections


class Solution(object):

    def __init__(self):
        _trie = lambda: collections.defaultdict(_trie)
        self.__root = _trie()


    def insert(self, key, val):
        curr = self.__root
        for c in key:
            curr = curr[c]
        delta = val
        if ""_end"" in curr:
            delta -= curr[""_end""]

        curr = self.__root
        for c in key:
            curr = curr[c]
            if ""_count"" in curr:
                curr[""_count""] += delta
            else:
                curr[""_count""] = delta
        curr[""_end""] = val


    def sum(self, prefix):
        curr = self.__root
        for c in prefix:
            if c not in curr:
                return 0
            curr = curr[c]
        return curr[""_count""]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        result = 0
        while head: 
            result = result*2 + head.val 
            head = head.__next__ 
        return result",O(n)
"class Solution(object):
    def totalMoney(self, n):
        def arithmetic_sequence_sum(a, d, n):
            return (2*a + (n-1)*d) * n //2

        cost, day = 1, 7
        first_week_cost = arithmetic_sequence_sum(cost, cost, day)
        week, remain_day = divmod(n, day)
        return arithmetic_sequence_sum(first_week_cost, cost*day, week) + \
               arithmetic_sequence_sum(cost*(week+1), cost, remain_day)",O(1)
"class Solution(object):
    def finalValueAfterOperations(self, operations):
        return sum(1 if '+' == op[1] else -1 for op in operations)",O(n)
"class Solution(object):
    def findShortestCycle(self, n, edges):
        INF = float(""inf"")
        def bfs(u):
            result = INF
            dist = [float(""inf"")]*len(adj)
            dist[u] = 0
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != INF:
                            assert(abs(dist[v]-dist[u]) <= 1)
                            if dist[v] != dist[u]-1:
                                result = min(result, 1+dist[u]+dist[v]) 
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                if result != INF: 
                    break
                q = new_q
            return result

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = min(bfs(u) for u in range(n))
        return result if result != INF else -1",other
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    students.dropna(subset=[""name""], inplace=True)
    return students
",O(n)
"
import collections


class Solution(object):
    def frequencySort(self, nums):
        count = collections.Counter(nums)
        return sorted(nums, key=lambda x: (count[x], -x))
",O(nlogn)
"class Solution(object):
    def longestConsecutive(self, num):
        result, lengths = 1, {key: 0 for key in num}
        for i in num:
            if lengths[i] == 0:
                lengths[i] = 1
                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)
                length = 1 + left + right
                result, lengths[i - left], lengths[i + right] = max(result, length), length, length
        return result",O(n)
"import collections
import itertools



class Solution2(object):
    def maxArea(self, height, positions, directions):
        diff = collections.defaultdict(int)
        for d, i in zip(directions, positions):
            if d == 'U':
                diff[height-i] -= 1
                diff[(height-i)+height] += 1
            else:
                diff[i] += 1
                diff[i+height] -= 1
        result = total = sum(positions)
        cnt = directions.count('U')
        prev = 0
        for t, d in sorted(diff.items()):
            total += (t-prev)*(-(len(directions)-cnt)+cnt)
            result = max(result, total)
            cnt += d
            prev = t
        return result",O(nlogn)
"class Solution(object):
    def frequenciesOfElements(self, head):
        curr = dummy = ListNode(0)
        cnt = 0
        while head:
            cnt += 1
            if not head.__next__ or head.next.val != head.val:
                curr.next = ListNode(cnt)
                curr = curr.__next__
                cnt = 0
            head = head.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def sumZero(self, n):
        return [i for i in range(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)]",O(n)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def goodTriplets(self, nums1, nums2):
        lookup = [0]*len(nums1)
        for i, x in enumerate(nums1):
            lookup[x] = i
        result = 0
        bit = BIT(len(nums1))
        for i, x in enumerate(nums2):
            smaller = bit.query(lookup[x]-1)
            larger = (len(nums1)-(lookup[x]+1))-(i-smaller)
            result += smaller*larger
            bit.add(lookup[x], 1)
        return result",O(nlogn)
"class Solution(object):
    def countHomogenous(self, s):
        MOD = 10**9+7
        result = cnt = 0
        for i in range(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result",O(n)
"import collections



class Solution(object):
    def findWinners(self, matches):
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in range(2)]",O(nlogn)
"import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result",O(n)
"class Solution2(object):
    def subarrayLCM(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        result = 0
        for i in range(len(nums)):
            l = 1
            for j in range(i, len(nums)):
                if k%nums[j]:
                    break
                l = lcm(l, nums[j])
                result += int(l == k)
        return result",O(n ^ 2)
"class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[1])
        result, right = 0, float(""-inf"")
        for l, r in intervals:
            if l < right:
                result += 1
            else:
                right = r
        return result",O(nlogn)
"class Solution2(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[0])
        result, prev = 0, 0
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[prev][1]:
                if intervals[i][1] < intervals[prev][1]:
                    prev = i
                result += 1
            else:
                prev = i
        return result",O(nlogn)
"class Solution(object):
    def twoSum(self, nums, target):
        start, end = 0, len(nums) - 1

        while start != end:
            sum = nums[start] + nums[end]
            if sum > target:
                end -= 1
            elif sum < target:
                start += 1
            else:
                return [start + 1, end + 1]",O(n)
"class Solution(object):
    def unhappyFriends(self, n, preferences, pairs):
        friends = [[0]*n for _ in range(n)]
        for i in range(len(preferences)):
            for j in range(len(preferences[i])):
                friends[i][preferences[i][j]] = j
        pairing = [0]*n
        for i, j in pairs:
            pairing[i], pairing[j] = j, i
        return sum(any(friends[i][j] < friends[i][pairing[i]] and friends[j][i] < friends[j][pairing[j]]
                       for j in range(len(friends[i])) if j != i and j != pairing[i])
                   for i in range(len(friends)))",O(n ^ 2)
"
import operator
from functools import reduce


class Solution(object):
    def singleNumber(self, A):
        return reduce(operator.xor, A)

",O(n)
"class Solution(object):
    def reverseParentheses(self, s):
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i < len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return """".join(result)",O(n)
"class Solution2(object):
    def reverseParentheses(self, s):
        stk = [[]]
        for c in s:
            if c == '(':
                stk.append([])
            elif c == ')':
                end = stk.pop()
                end.reverse()
                stk[-1].extend(end)
            else:
                stk[-1].append(c)
        return """".join(stk.pop())",O(n ^ 2)
"class Solution(object):
    def countWays(self, nums):
        cnt = [0]*(len(nums)+1)
        for x in nums:
            cnt[x] += 1
        result = prefix = 0
        for i in range(len(nums)+1):
            if prefix == i and cnt[i] == 0:
                result += 1
            prefix += cnt[i]
        return result",O(n)
"class Solution2(object):
    def countWays(self, nums):
        nums.sort()
        return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in range(len(nums)+1))",O(nlogn)
"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result >= k",O(n)
"class Solution(object):
    def maximumLengthOfRanges(self, nums):
        result = [0]*len(nums)
        stk = [-1]
        nums.append(float(""inf""))
        for i, x in enumerate(nums):
            while stk[-1] != -1 and nums[stk[-1]] < x:
                j = stk.pop()
                result[j] = (i-1)-stk[-1]
            stk.append(i)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getDirections(self, root, startValue, destValue):
        def iter_dfs(root, val):
            path = []
            stk = [(1, (root,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node = args[0]
                    if node.val == val:
                        path.reverse()
                        return path
                    for i, child in enumerate((node.left, node.right)):
                        if not child:
                            continue
                        stk.append((3, None))
                        stk.append((1, (child,)))
                        stk.append((2, (""LR""[i],)))
                elif step == 2:
                    path.append(args[0])
                elif step == 3:
                    path.pop()
            return []
    
        src = iter_dfs(root, startValue)
        dst = iter_dfs(root, destValue)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)",O(n)
"class Solution2(object):
    def getDirections(self, root, startValue, destValue):
        def dfs(node, val, path):
            if node.val == val:
                return True
            if node.left and dfs(node.left, val, path):
                path.append('L')
            elif node.right and dfs(node.right, val, path):
                path.append('R')
            return path

        src, dst = [], []
        dfs(root, startValue, src)
        dfs(root, destValue, dst)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)",O(n)
"class Solution(object):
    def findSolution(self, customfunction, z):
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) < z:
            y += 1
        while y > 0:
            while y > 0 and customfunction.f(x, y) > z:
                y -= 1
            if y > 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result",O(n)
"import collections


class Solution(object):
    def kthDistinct(self, arr, k):
        count = collections.Counter(arr)
        arr = [x for x in arr if count[x] == 1]
        return arr[k-1] if k-1 < len(arr) else """"",O(n)
"class Solution(object):
    def minimumPossibleSum(self, n, target):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(target//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b)",O(1)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        intersect = reduce(set.intersection, list(map(set, [arr2, arr3])))
        return [x for x in arr1 if x in intersect]",O(n)
"class Solution(object):
    def minimumDistance(self, points):
        def max_distance(exclude):
            max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), 
                       (max_diff[0]-min_diff[0], max_diff[1], min_diff[1]))
        
        _, i, j = max_distance(-1)
        return min(max_distance(i)[0], max_distance(j)[0])",O(n)
"class Solution(object):
    def beautySum(self, s):
        result = 0 
        for i in range(len(s)):
            lookup = [0]*26
            for j in range(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result",O(n ^ 2)
"class Solution2(object):
    def countCompleteDayPairs(self, hours):
        return sum((hours[i]+hours[j])%24 == 0 for i in range(len(hours)-1) for j in range(i+1, len(hours)))",O(n ^ 2)
"class Solution(object):
    def toHex(self, num):
        if not num:
            return ""0""

        result = []
        while num and len(result) != 8:
            h = num & 15
            if h < 10:
                result.append(str(chr(ord('0') + h)))
            else:
                result.append(str(chr(ord('a') + h-10)))
            num >>= 4
        result.reverse()

        return """".join(result)",O(logn)
"class Solution(object):
    def partitionLabels(self, S):
        lookup = {c: i for i, c in enumerate(S)}
        first, last = 0, 0
        result = []
        for i, c in enumerate(S):
            last = max(last, lookup[c])
            if i == last:
                result.append(i-first+1)
                first = i+1
        return result",O(n)
"
class Solution(object):
    def checkString(self, s):
        return ""ba"" not in s
",O(n)
"class Solution(object):
    def canMakeSubsequence(self, str1, str2):
        i = 0
        for c in str1:
            if (ord(str2[i])-ord(c))%26 > 1:
                continue
            i += 1
            if i == len(str2):
                return True
        return False",O(n)
"class Solution(object):
    def minIncrementForUnique(self, A):
        A.sort()
        A.append(float(""inf""))
        result, duplicate = 0, 0
        for i in range(1, len(A)):
            if A[i-1] == A[i]:
                duplicate += 1
                result -= A[i]
            else:
                move = min(duplicate, A[i]-A[i-1]-1)
                duplicate -= move
                result += move*A[i-1] + move*(move+1)//2
        return result",O(nlogn)
"from collections import defaultdict

class Solution(object):
    def firstUniqChar(self, s):
        lookup = defaultdict(int)
        candidtates = set()
        for i, c in enumerate(s):
            if lookup[c]:
                candidtates.discard(lookup[c])
            else:
                lookup[c] = i+1
                candidtates.add(i+1)

        return min(candidtates)-1 if candidtates else -1",O(n)
"import collections



class Solution(object):
    def divideArray(self, nums):
        return all(cnt%2 == 0 for cnt in collections.Counter(nums).values())",O(n)
"import bisect


class Solution(object):
    def findRightInterval(self, intervals):
        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))
        result = []
        for interval in intervals:
            idx = bisect.bisect_left(sorted_intervals, (interval.end,))
            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)
        return result",O(nlogn)
"
class Solution(object):
    def findMaxAverage(self, nums, k):
        result = total = sum(nums[:k])
        for i in range(k, len(nums)):
            total += nums[i] - nums[i-k]
            result = max(result, total)
        return float(result) / k

",O(n)
"class Solution(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return (num-parity(num))//2",O(logn)
"class Solution2(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return sum(parity(x) == 0 for x in range(1, num+1))",O(nlogn)
"class Solution3(object):
    def countEven(self, num):
        return sum(sum(map(int, str(x)))%2 == 0 for x in range(1, num+1))",O(nlogn)
"class Solution(object):
    def returnToBoundaryCount(self, nums):
        result = curr = 0
        for x in nums:
            curr += x
            if curr == 0:
                result += 1
        return result",O(n)
"class Solution(object):
    def findLatestTime(self, s):
        result = list(s)
        if result[0] == '?': 
            result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0'
        if result[1] == '?': 
            result[1] = '1' if result[0] == '1' else '9'
        if result[3] == '?':
            result[3] = '5'
        if result[4] == '?':
            result[4] = '9'
        return """".join(result)",O(1)
"import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) >= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return """".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return """".join(result)",O(n)
"class Solution2(object):
    def longestDiverseString(self, a, b, c):
        choices = [[a, 'a'], [b, 'b'], [c, 'c']]
        result = []
        for _ in range(a+b+c):
            choices.sort(reverse=True)
            for i, (x, c) in enumerate(choices):
                if x and result[-2:] != [c, c]:
                    result.append(c)
                    choices[i][0] -= 1
                    break
            else:
                break
        return """".join(result)",other
"class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        result = left = 0
        right = [-1]*2
        for i, x in enumerate(nums):
            if not (minK <= x <= maxK):
                left = i+1
                continue
            if x == minK:
                right[0] = i
            if x == maxK:
                right[1] = i
            result += max(min(right)-left+1, 0)
        return result",O(n)
"class Solution(object):
    def romanToInt(self, s):
        numeral_map = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"":100, ""D"": 500, ""M"": 1000}
        decimal = 0
        for i in range(len(s)):
            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:
                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]
            else:
                decimal += numeral_map[s[i]]
        return decimal",O(n)
"class Solution(object):
    def findPairs(self, nums, k):
        if k < 0: return 0
        result, lookup = set(), set()
        for num in nums:
            if num-k in lookup:
                result.add(num-k)
            if num+k in lookup:
                result.add(num)
            lookup.add(num)
        return len(result)",O(n)
"import collections



class Solution(object):
    def maxSubarrayLength(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while not (cnt[nums[right]] <= k):
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"
class Solution(object):
    def toLowerCase(self, str):
        return """".join([chr(ord('a')+ord(c)-ord('A')) 
                        if 'A' <= c <= 'Z' else c for c in str])

",O(n)
"import collections


class Solution(object):
    def checkInclusion(self, s1, s2):
        counts = collections.Counter(s1)
        l = len(s1)
        for i in range(len(s2)):
            if counts[s2[i]] > 0:
                l -= 1
            counts[s2[i]] -= 1
            if l == 0:
                return True
            start = i + 1 - len(s1)
            if start >= 0:
                counts[s2[start]] += 1
                if counts[s2[start]] > 0:
                    l += 1
        return False",O(n)
"class Solution(object):
    def maximumSwap(self, num):
        digits = list(str(num))
        left, right = 0, 0
        max_idx = len(digits)-1
        for i in reversed(range(len(digits))):
            if digits[i] > digits[max_idx]:
                max_idx = i
            elif digits[max_idx] > digits[i]:
                left, right = i, max_idx
        digits[left], digits[right] = digits[right], digits[left]
        return int("""".join(digits))",O(logn)
"class Solution(object):
    def longestConsecutive(self, root):
        def longestConsecutiveHelper(root):
            if not root:
                return 0, 0
            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)
            cur_inc_len, cur_dec_len = 1, 1
            if root.left:
                if root.left.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, left_len[0] + 1)
                elif root.left.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, left_len[1] + 1)
            if root.right:
                if root.right.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, right_len[0] + 1)
                elif root.right.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, right_len[1] + 1)
            self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)
            return cur_inc_len, cur_dec_len

        self.max_len = 0
        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"
import collections



class Solution(object):
    def maxScore(self, prices):
        cnt = collections.Counter()
        for i, x in enumerate(prices):
            cnt[x-i] += x
        return max(cnt.values())
",O(n)
"class Solution(object):
    def modifyString(self, s):
        s = list(s)
        for i in range(len(s)):
            if s[i] != '?':
                continue
            for c in ('a', 'b', 'c'):
                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):
                    break
            s[i] = c
        return """".join(s)",O(n)
"import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in zip(sorted_x, sorted_x[1:])] + [0])",O(nlogn)
"class Solution(object):
    def verifyPreorder(self, preorder):
        low, i = float(""-inf""), -1
        for p in preorder:
            if p < low:
                return False
            while i >= 0 and p > preorder[i]:
                low = preorder[i]
                i -= 1
            i += 1
            preorder[i] = p
        return True",O(n)
"class Solution2(object):
    def verifyPreorder(self, preorder):
        low = float(""-inf"")
        path = []
        for p in preorder:
            if p < low:
                return False
            while path and p > path[-1]:
                low = path[-1]
                path.pop()
            path.append(p)
        return True",O(n)
"class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2
        buy[0] = -prices[0]
        for i in range(1, len(prices)):
            buy[i % 2] = max(buy[(i - 1) % 2],
                             coolDown[(i - 1) % 2] - prices[i])
            sell[i % 2] = buy[(i - 1) % 2] + prices[i]
            coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])
        return max(coolDown[(len(prices) - 1) % 2],
                   sell[(len(prices) - 1) % 2])",O(n)
"import re


class Solution(object):

    def __init__(self, compressedString):
        self.__result = re.findall(r""([a-zA-Z])(\d+)"", compressedString)
        self.__index, self.__num, self.__ch = 0, 0, ' '

    def __next__(self):
        if not self.hasNext():
            return ' '
        if self.__num == 0:
            self.__ch = self.__result[self.__index][0]
            self.__num = int(self.__result[self.__index][1])
            self.__index += 1
        self.__num -= 1
        return self.__ch


    def hasNext(self):
        return self.__index != len(self.__result) or self.__num != 0",O(1)
"class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):
        lookup = {tuple(mine) for mine in mines}
        dp = [[0] * N for _ in range(N)]
        result = 0
        for i in range(N):
            l = 0
            for j in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = l
            l = 0
            for j in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)

        for j in range(N):
            l = 0
            for i in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
            l = 0
            for i in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
                result = max(result, dp[i][j])
        return result",O(n ^ 2)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def findCriticalAndPseudoCriticalEdges(self, n, edges):
        def MST(n, edges, unused=None, used=None):
            union_find = UnionFind(n)
            weight = 0
            if used is not None:
                u, v, w, _ = edges[used]
                if union_find.union_set(u, v):
                    weight += w
            for i, (u, v, w, _) in enumerate(edges):
                if i == unused:
                    continue
                if union_find.union_set(u, v):
                    weight += w
            return weight if union_find.count == 1 else float(""inf"")
        
        for i, edge in enumerate(edges):
            edge.append(i)
        edges.sort(key=lambda x: x[2])
        mst = MST(n, edges)
        result = [[], []]
        for i, edge in enumerate(edges):
            if mst < MST(n, edges, unused=i):
                result[0].append(edge[3])
            elif mst == MST(n, edges, used=i):
                result[1].append(edge[3])
        return result",other
"class Solution(object):
    def sumOfBeauties(self, nums):
        right = [nums[-1]]*len(nums)
        for i in reversed(range(2, len(nums)-1)):
            right[i] = min(right[i+1], nums[i])
        result, left = 0, nums[0]
        for i in range(1, len(nums)-1):
            if left < nums[i] < right[i+1]:
                result += 2
            elif nums[i-1] < nums[i] < nums[i+1]:
                result += 1
            left = max(left, nums[i])
        return result",O(n)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []



class Solution(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
            stk = [(1, [node, None, False])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, is_ancestor = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return is_ancestor
                    stk.append((2, [node, is_ancestor, reversed(node.children)]))
                else:
                    node, is_ancestor, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, is_ancestor, it]))
                    stk.append((1, [child, node, is_ancestor or node == p]))
            assert(False)
            return False

        lookup = {}
        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"class Solution_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, is_ancestor, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True, is_ancestor
            for child in node.children:
                found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup)
                if found:
                    return True, new_is_ancestor
            return False, False

        lookup = {}
        is_ancestor = find_parents(root, None, p, q, False, lookup)[1]
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"class Solution2(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, lookup):
            stk = [(1, [node, None])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return
                    stk.append((2, [node, reversed(node.children)]))
                else:
                    node, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, it]))
                    stk.append((1, [child, node]))

        def iter_is_ancestor(node, q):
            stk = [(1, [node])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node = params[0]
                    stk.append((2, [reversed(node.children)]))
                else:
                    it = params[0]
                    child = next(it, None)
                    if not child:
                        continue
                    if child == q:
                        return True
                    stk.append((2, [it]))
                    stk.append((1, [child]))
            return False

        lookup = {}
        iter_find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not iter_is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"class Solution2_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True
            for child in node.children:
                if find_parents(child, node, p, q, lookup):
                    return True
            return False

        def is_ancestor(node, q):
            for child in node.children:
                if node == q or is_ancestor(child, q):
                    return True
            return False

        lookup = {}
        find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"
class Solution(object):
    def simplifyPath(self, path):
        stack, tokens = [], path.split(""/"")
        for token in tokens:
            if token == "".."" and stack:
                stack.pop()
            elif token != "".."" and token != ""."" and token:
                stack.append(token)
        return ""/"" + ""/"".join(stack)

",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructMaximumBinaryTree(self, nums):
        nodeStack = []
        for num in nums:
            node = TreeNode(num)
            while nodeStack and num > nodeStack[-1].val:
                node.left = nodeStack.pop()
            if nodeStack:
                nodeStack[-1].right = node
            nodeStack.append(node)
        return nodeStack[0]",O(n)
"class Solution(object):
    def countQuadruples(self, firstString, secondString):
        lookup1 = [-1]*26
        for i in reversed(range(len(firstString))):
            lookup1[ord(firstString[i])-ord('a')] = i
        lookup2 = [-1]*26
        for i in range(len(secondString)):
            lookup2[ord(secondString[i])-ord('a')] = i
        result, diff = 0, float(""inf"")
        for i in range(26):
            if lookup1[i] == -1 or lookup2[i] == -1:
                continue
            if lookup1[i]-lookup2[i] < diff:
                diff = lookup1[i]-lookup2[i]
                result = 0
            result += int(lookup1[i]-lookup2[i] == diff)
        return result",O(n)
"
import bisect



class Solution(object):
    def minOperations(self, nums):
        def longest_non_increasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, -x)
                if right == len(result):
                    result.append(-x)
                else:
                    result[right] = -x
            return len(result)
        
        return longest_non_increasing_subsequence(nums)
",O(nlogn)
"class Solution(object):
    def applyOperations(self, nums):
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                nums[i], nums[i+1] = 2*nums[i], 0
        i = 0
        for x in nums:
            if not x:
                continue
            nums[i] = x
            i += 1
        for i in range(i, len(nums)):
            nums[i] = 0
        return nums",O(n)
"class Solution(object):
    def sumOfMultiples(self, n):
        def f(d):
            return d*((1+(n//d))*(n//d)//2)
        
        return (f(3)+f(5)+f(7))-(f(3*5)+f(5*7)+f(7*3))+f(3*5*7)",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right



class Solution(object):
    def isValidSequence(self, root, arr):
        q = [root]
        for depth in range(len(arr)):
            new_q = []
            while q:
                node = q.pop()
                if not node or node.val != arr[depth]:
                    continue
                if depth+1 == len(arr) and node.left == node.right:
                    return True
                new_q.extend(child for child in (node.left, node.right))
            q = new_q
        return False",O(n)
"class Solution2(object):
    def isValidSequence(self, root, arr):
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False",O(n)
"class Solution3(object):
    def isValidSequence(self, root, arr):
        def dfs(node, arr, depth):
            if not node or depth == len(arr) or node.val != arr[depth]:
                return False
            if depth+1 == len(arr) and node.left == node.right:
                return True
            return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1)

        return dfs(root, arr, 0)",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def replaceValueInTree(self, root):
        q = [(root, root.val)]
        while q:
            new_q = []
            total = sum(node.val for node, _ in q)
            for node, x in q:
                node.val = total-x
                x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
                if node.left:
                    new_q.append((node.left, x))
                if node.right:
                    new_q.append((node.right, x))
            q = new_q
        return root",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def correctBinaryTree(self, root):
        q = {root:None}
        while q:
            new_q = {}
            for node, parent in q.items():
                if node.right in q:
                    if parent.left == node:
                        parent.left = None
                    else:
                        parent.right = None
                    return root
                if node.left:
                    new_q[node.left] = node
                if node.right:
                    new_q[node.right] = node
            q = new_q",O(n)
"class Solution(object):
    def decodeString(self, s):
        n, curr, nums, strs = 0, [], [], []
        for c in s:
            if c.isdigit():
                n = n*10 + ord(c)-ord('0')
            elif c.isalpha():
                curr.append(c)
            elif c == '[':
                nums.append(n)
                strs.append(curr)
                n, curr = 0, []
            elif c == ']':
                strs[-1].extend(curr*nums.pop())
                curr = strs.pop()
        return """".join(curr)",O(n)
"class Solution(object):
    def cherryPickup(self, grid):
        n = len(grid)
        dp = [[-1 for _ in range(n)] for _ in range(n)]
        dp[0][0] = grid[0][0]
        max_len = 2 * (n-1)
        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]
        for k in range(1, max_len+1):
            for i in reversed(range(max(0, k-n+1), min(k+1, n))): 
                for j in reversed(range(i, min(k+1, n))):         
                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:
                        dp[i][j] = -1
                        continue
                    cnt = grid[i][k-i]
                    if i != j:
                        cnt += grid[j][k-j]
                    max_cnt = -1
                    for direction in directions:
                        ii, jj = i+direction[0], j+direction[1]
                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:
                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)
                    dp[i][j] = max_cnt
        return max(dp[n-1][n-1], 0)",O(n ^ 3)
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):
        union_find = UnionFind(len(s))
        for x,y in pairs: 
            union_find.union_set(x, y)
        components = collections.defaultdict(list)
        for i in range(len(s)): 
            components[union_find.find_set(i)].append(s[i])
        for i in components.keys(): 
            components[i].sort(reverse=True)
        result = []
        for i in range(len(s)): 
            result.append(components[union_find.find_set(i)].pop())
        return """".join(result)


",O(nlogn)
"import itertools
class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):
        def dfs(i, adj, lookup, component):
            lookup.add(i)
            component.append(i)
            for j in adj[i]:
                if j in lookup:
                    continue
                dfs(j, adj, lookup, component)
            
        adj = collections.defaultdict(list)
        for i, j in pairs:
            adj[i].append(j)
            adj[j].append(i)
        lookup = set()
        result = list(s)
        for i in range(len(s)):
            if i in lookup:
                continue
            component = []
            dfs(i, adj, lookup, component)
            component.sort()
            chars = sorted(result[k] for k in component)
            for comp, char in zip(component, chars):
                result[comp] = char
        return """".join(result)",O(nlogn)
"class Solution(object):
    def maxSubarraySumCircular(self, A):
        total, max_sum, cur_max, min_sum, cur_min = 0, -float(""inf""), 0, float(""inf""), 0
        for a in A:
            cur_max = max(cur_max+a, a)
            max_sum = max(max_sum, cur_max)
            cur_min = min(cur_min+a, a)
            min_sum = min(min_sum, cur_min)
            total += a
        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum",O(n)
"class Solution(object):
    def optimalDivision(self, nums):
        if len(nums) == 1:
            return str(nums[0])
        if len(nums) == 2:
            return str(nums[0]) + ""/"" + str(nums[1])
        result = [str(nums[0]) + ""/("" + str(nums[1])]
        for i in range(2, len(nums)):
            result += ""/"" + str(nums[i])
        result += "")""
        return """".join(result)",O(n)
"

class Solution(object):
    def minimumOperations(self, nums):
        return len({x for x in nums if x})
",O(n)
"class Solution(object):
    def mergeTrees(self, t1, t2):
        if t1 is None:
            return t2
        if t2 is None:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1",O(n)
"class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result",O(n)
"import collections
import itertools


class Solution(object):
    def alertNames(self, keyName, keyTime):
        THRESHOLD = 3
        name_to_times = collections.defaultdict(list)
        for name, hour_minute in zip(keyName, keyTime):
            hour, minute = list(map(int, hour_minute.split(':')))
            name_to_times[name].append(hour*60 + minute)
        names = []    
        for name, times in name_to_times.items():
            times.sort()
            left = 0
            for right, time in enumerate(times):
                while time-times[left] > 60:
                    left += 1
                if right-left+1 >= THRESHOLD:
                    names.append(name)
                    break
        names.sort()
        return names",O(nlogn)
"class Solution(object):
    def findValidPair(self, s):
        cnt = [0]*9
        for x in s:
            cnt[ord(x)-ord('1')] += 1
        for i in range(len(s)-1):
            if s[i] != s[i+1] and cnt[ord(s[i])-ord('1')] == ord(s[i])-ord('0') and cnt[ord(s[i+1])-ord('1')] == ord(s[i+1])-ord('0'):
                return s[i:i+2]
        return """"",O(n)
"import collections


class Solution(object):
    def canConstruct(self, s, k):
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.values())
        return odd <= k <= len(s)",O(n)
"class Solution(object):
    def removeDuplicates(self, s, k):
        stk = [['^', 0]]
        for c in s:
            if stk[-1][0] == c:
                stk[-1][1] += 1
                if stk[-1][1] == k:
                    stk.pop()
            else:
                stk.append([c, 1])
        return """".join(c*k for c, k in stk)",O(n)
"class Solution(object):
    def minimumChairs(self, s):
        result = curr = 0
        for x in s:
            curr += +1 if x == ""E"" else -1
            result = max(result, curr)
        return result",O(n)
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def intersect(self, quadTree1, quadTree2):
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        elif quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)
        bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if topLeftNode.isLeaf and topRightNode.isLeaf and \
           bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
           topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
            return Node(topLeftNode.val, True, None, None, None, None)
        return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)",O(n)
"import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result",O(n)
"class Solution(object):
    def __init__(self):
        self.min = None
        self.stack = []

    def push(self, x):
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self):
        x = self.stack.pop()
        if x < 0:
            self.min = self.min - x

    def top(self):
        x = self.stack[-1]
        if x > 0:
            return x + self.min
        else:
            return self.min

    def getMin(self):
        return self.min",O(1)
"class Solution2(object):
    def __init__(self):
        self.stack, self.minStack = [], []
    def push(self, x):
        self.stack.append(x)
        if len(self.minStack):
            if x < self.minStack[-1][0]:
                self.minStack.append([x, 1])
            elif x == self.minStack[-1][0]:
                self.minStack[-1][1] += 1
        else:
            self.minStack.append([x, 1])

    def pop(self):
        x = self.stack.pop()
        if x == self.minStack[-1][0]:
            self.minStack[-1][1] -= 1
            if self.minStack[-1][1] == 0:
                self.minStack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.minStack[-1][0]",O(1)
"class Solution3(object):

    def __init__(self):
        self.stack = []

    def push(self, x):
        if self.stack:
            current_min = min(x, self.stack[-1][0])
            self.stack.append((current_min, x))
        else:
            self.stack.append((x, x))

    def pop(self):
        return self.stack.pop()[1]

    def top(self):
        return self.stack[-1][1]

    def getMin(self):
        return self.stack[-1][0]",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def addOneRow(self, root, v, d):
        if d in (0, 1):
            node = TreeNode(v)
            if d == 1:
                node.left = root
            else:
                node.right = root
            return node
        if root and d >= 2:
            root.left = self.addOneRow(root.left,  v, d-1 if d > 2 else 1)
            root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0)
        return root",O(n)
"from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.lookup = defaultdict(int)



    def add(self, number):
        self.lookup[number] += 1


    def find(self, value):
        for key in self.lookup:
            num = value - key
            if num in self.lookup and (num != key or self.lookup[key] > 1):
                return True
        return False",O(n)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors):
        k = 3
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"class Solution2(object):
    def numberOfAlternatingGroups(self, colors):
        return sum(colors[i] != colors[(i+1)%len(colors)] != colors[(i+2)%len(colors)] for i in range(len(colors)))",O(n)
"import collections



class Solution(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
        return right-left+1",O(n)
"import collections



class Solution2(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
            result = max(result, right-left+1)            
        return result",O(n)
"class Solution(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        return min(n, d1+d2+c)",O(n)
"class Solution2(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        r1, r2 = n//2-d1, n//2-d2
        return d1+d2+min(r1+r2, c)",O(n)
"
class Solution(object):

    def __init__(self):
        self.__overlaps = []
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__overlaps:
            if start < j and end > i:
                return False
        for i, j in self.__calendar:
            if start < j and end > i:
                self.__overlaps.append((max(start, i), min(end, j)))
        self.__calendar.append((start, end))
        return True



",O(n ^ 2)
"import heapq


class Solution(object):
    def findMaximizedCapital(self, k, W, Profits, Capital):
        curr = []
        future = sorted(zip(Capital, Profits), reverse=True)
        for _ in range(k):
            while future and future[-1][0] <= W:
                heapq.heappush(curr, -future.pop()[1])
            if curr:
                W -= heapq.heappop(curr)
        return W",O(nlogn)
"class Solution(object):
    def smallestString(self, s):
        result = list(s)
        i = next((i for i in range(len(s)) if s[i] != 'a'), len(s))
        if i == len(s):
            result[-1] = 'z'
        else:
            for i in range(i, len(s)):
                if result[i] == 'a':
                    break
                result[i] = chr(ord(result[i])-1)
        return """".join(result)",O(n)
"
from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):
        _trie = lambda: defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            reduce(getitem, word, trie)[""_end""] = i

        stack = list(trie.values())
        result = """"
        while stack:
            curr = stack.pop()
            if ""_end"" in curr:
                word = words[curr[""_end""]]
                if len(word) > len(result) or (len(word) == len(result) and word < result):
                    result = word
                stack += [curr[letter] for letter in curr if letter != ""_end""]
        return result

",O(n)
"class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > k:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > k:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length",O(n)
"
class UndirectedGraphNode(object):
    def __init__(self, x):
        self.label = x
        self.neighbors = []

class Solution(object):
    def cloneGraph(self, node):
        if node is None:
            return None
        cloned_node = UndirectedGraphNode(node.label)
        cloned, queue = {node:cloned_node}, [node]

        while queue:
            current = queue.pop()
            for neighbor in current.neighbors:
                if neighbor not in cloned:
                    queue.append(neighbor)
                    cloned_neighbor = UndirectedGraphNode(neighbor.label)
                    cloned[neighbor] = cloned_neighbor
                cloned[current].neighbors.append(cloned[neighbor])
        return cloned[node]

",O(n)
"class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        result = 0
        for x in batteryPercentages:
            if x > result:
                result += 1
        return result",O(n)
"class Solution(object):
    def minEnd(self, n, x):
        n -= 1
        base_n = base_x = 1
        while base_n <= n:
            if (x&base_x) == 0:
                if n&base_n:
                    x |= base_x
                base_n <<= 1
            base_x <<= 1
        return x",O(logn)
"class Solution(object):
    def atMostNGivenDigitSet(self, D, N):
        str_N = str(N)
        set_D = set(D)
        result = sum(len(D)**i for i in range(1, len(str_N)))
        i = 0
        while i < len(str_N):
            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))
            if str_N[i] not in set_D:
                break
            i += 1
        return result + int(i == len(str_N))",O(logn)
"class Solution(object):
    def maxNumberOfApples(self, arr):
        LIMIT = 5000
        arr.sort()
        result, total = 0, 0
        for x in arr:
            if total+x > LIMIT:
                break
            total += x
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def findChampion(self, grid):
        return next(u for u in range(len(grid)) if sum(grid[u]) == len(grid)-1)",O(n ^ 2)
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        dp = [[[0]*26 for _ in range(len(s))] for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if i == j-1:
                    if s[j] == s[i]:
                        dp[i%2][j][ord(s[i])-ord('a')] = 2
                else:
                    for k in range(26):
                        if s[j] == s[i] and ord(s[j])-ord('a') != k:
                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2)
                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])
        return max(dp[0][-1])",O(n ^ 2)
"class Solution(object):
    def probabilityOfHeads(self, prob, target):
        dp = [0.0]*(target+1)
        dp[0] = 1.0
        for p in prob:
            for i in reversed(range(target+1)):
                dp[i] = (dp[i-1] if i >= 1 else 0.0)*p + dp[i]*(1-p)
        return dp[target]",O(n ^ 2)
"import collections
from functools import reduce



class Solution(object):
    def countWinningSequences(self, s):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(""FWE"")}
        dp = [collections.defaultdict(int) for _ in range(3)]
        for i, c in enumerate(s):
            new_dp = [collections.defaultdict(int) for _ in range(3)]
            x = lookup[c]
            for j in range(3):
                diff = (j-x+1)%3-1
                if i == 0:
                    new_dp[j][diff] = 1
                    continue
                for k in range(3):
                    if k == j:
                        continue
                    for v, c in dp[k].items():
                        new_dp[j][v+diff] = (new_dp[j][v+diff]+c)%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, (c for j in range(3) for v, c in dp[j].items() if v >= 1), 0)",O(n)
"import collections


class Solution(object):
    def sumOfUnique(self, nums):
        return sum(x for x, c in collections.Counter(nums).items() if c == 1)",O(n)
"class Solution(object):
    def minimumLevels(self, possible):
        prefix = [0]*(len(possible)+1)
        for i in range(len(possible)):
            prefix[i+1] = prefix[i]+(+1 if possible[i] else -1)
        return next((i+1 for i in range(len(possible)-1) if prefix[i+1] > prefix[-1]-prefix[i+1]), -1)",O(n)
"class Solution(object):
    def getSmallestString(self, s, k):
        result = [ord(x)-ord('a') for x in s]
        for i in range(len(result)):
            d = min(result[i]-0, 26-result[i])
            result[i] = 0 if d <= k else result[i]-k
            k -= min(d, k)
            if k == 0:
                break
        return """".join([chr(x+ord('a')) for x in result])",O(n)
"class Solution(object):
    def cleanRoom(self, robot):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def goBack(robot):
            robot.turnLeft()
            robot.turnLeft()
            robot.move()
            robot.turnRight()
            robot.turnRight()

        def dfs(pos, robot, d, lookup):
            robot.clean()
            for _ in directions:
                new_pos = (pos[0]+directions[d][0],
                           pos[1]+directions[d][1])
                if new_pos not in lookup:
                    lookup.add(new_pos)
                    if robot.move():
                        dfs(new_pos, robot, d, lookup)
                        goBack(robot)
                robot.turnRight()
                d = (d+1) % len(directions)
        
        dfs((0, 0), robot, 0, set())",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(-1)
        dummy.next = head
        slow, fast = dummy, dummy

        for i in range(n):
            fast = fast.__next__

        while fast.__next__:
            slow, fast = slow.__next__, fast.__next__

        slow.next = slow.next.__next__

        return dummy.__next__",O(n)
"class Solution(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + 
        return s[getPrefix(A)[-1]+1:][::-1] + s",O(n)
"class Solution2(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + s[::-1]
        prefix = getPrefix(A)
        i = prefix[-1]
        while i >= len(s):
            i = prefix[i]
        return s[i+1:][::-1] + s",O(n)
"class Solution3(object):
    def shortestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            string = ['^']
            for c in s:
                string +=  [
            string += [
            return string

        string = preProcess(s)
        palindrome = [0] * len(string)
        center, right = 0, 0
        for i in range(1, len(string) - 1):
            i_mirror = 2 * center - i
            if right > i:
                palindrome[i] = min(right - i, palindrome[i_mirror])
            else:
                palindrome[i] = 0

            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:
                palindrome[i] += 1

            if i + palindrome[i] > right:
                center, right = i, i + palindrome[i]

        max_len = 0
        for i in range(1, len(string) - 1):
            if i - palindrome[i] == 1:
                max_len = palindrome[i]
        return s[len(s)-1:max_len-1:-1] + s",O(n)
"class Solution(object):
    def validSquare(self, p1, p2, p3, p4):
        def dist(p1, p2):
            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

        lookup = set([dist(p1, p2), dist(p1, p3),\
                      dist(p1, p4), dist(p2, p3),\
                      dist(p2, p4), dist(p3, p4)])
        return 0 not in lookup and len(lookup) == 2",O(1)
"class Solution(object):
    def maxActiveSectionsAfterTrade(self, s):
        curr = prev = mx = cnt1 = 0
        for x in s:
            if x == '0':
                curr += 1
            else:
                if curr:
                    prev = curr
                    curr = 0
                cnt1 += 1
            mx = max(mx, prev+curr)
        return cnt1 if mx in (prev, curr) else mx+cnt1",O(n)
"class Solution(object):
    def canMeasureWater(self, x, y, z):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))",O(logn)
"class Solution(object):
    def maxSubarrays(self, nums):
        result = curr = 0
        for x in nums:
            curr = curr&x if curr else x
            if not curr:
                result += 1
        return max(result, 1)",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def pairSum(self, head):
        def reverseList(head):
            dummy = ListNode()
            while head:
                dummy.next, head.next, head = head, dummy.next, head.next
            return dummy.__next__

        dummy = ListNode(next=head)
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        result = 0
        head2 = reverseList(slow)
        while head:
            result = max(result, head.val+head2.val)
            head, head2 = head.__next__, head2.__next__
        return result",O(n)
"class Solution(object):
    def countTime(self, time):
        result = 1
        if time[4] == '?':
            result *= 10
        if time[3] == '?':
            result *= 6
        if time[1] == time[0] == '?':
            result *= 24
        elif time[1] == '?':
            result *= 10 if time[0] != '2' else 4
        elif time[0] == '?':
            result *= 3 if time[1] < '4' else 2
        return result",O(1)
"class Solution(object):
    def intersectionSizeTwo(self, intervals):
        intervals.sort(key = lambda s_e: (s_e[0], -s_e[1]))
        cnts = [2] * len(intervals)
        result = 0
        while intervals:
            (start, _), cnt = intervals.pop(), cnts.pop()
            for s in range(start, start+cnt):
                for i in range(len(intervals)):
                    if cnts[i] and s <= intervals[i][1]:
                        cnts[i] -= 1
            result += cnt
        return result",O(n ^ 2)
"class Solution(object):
    def maxRectangleArea(self, points):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points.sort()
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(y for _, y in points)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"class Solution2(object):
    def maxRectangleArea(self, points):
        result = -1
        points.sort()
        for i in range(len(points)-3):
            if points[i][0] != points[i+1][0]:
                continue
            j = next((j for j in range(i+2, len(points)-1) if points[i][1] <= points[j][1] <= points[i+1][1]), len(points)-1)
            if j == len(points)-1 or not (points[j][0] == points[j+1][0] and points[i][1] == points[j][1] and points[i+1][1] == points[j+1][1]):
                continue
            result = max(result, (points[i+1][1]-points[i][1])*(points[j][0]-points[i][0]))
        return result",O(n ^ 2)
"class Solution(object):
    def distinctAverages(self, nums):
        lookup = set()
        nums.sort()
        left, right = 0, len(nums)-1
        while left < right:
            lookup.add(nums[left]+nums[right])
            left, right = left+1, right-1
        return len(lookup)",O(nlogn)
"import collections


class Solution(object):
    def numRabbits(self, answers):
        count = collections.Counter(answers)
        return sum((((k+1)+v-1)//(k+1))*(k+1) for k, v in count.items())",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def swimInWater(self, grid):
        n = len(grid)
        positions = [None] * (n**2)
        for i in range(n):
            for j in range(n):
                positions[grid[i][j]] = (i, j)
        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

        union_find = UnionFind(n**2)
        for elevation in range(n**2):
            i, j = positions[elevation]
            for direction in directions:
                x, y = i+direction[0], j+direction[1]
                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:
                    union_find.union_set(i*n+j, x*n+y)
                    if union_find.find_set(0) == union_find.find_set(n**2-1):
                        return elevation
        return n**2-1",O(n ^ 2)
"from fractions import Fraction


class Solution(object):
    def isRationalEqual(self, S, T):
        def frac(S):
            if '.' not in S:
                return Fraction(int(S), 1)

            i = S.index('.')
            result = Fraction(int(S[:i]), 1)
            non_int_part = S[i+1:]
            if '(' not in non_int_part:
                if non_int_part:
                    result += Fraction(int(non_int_part), 10**len(non_int_part))
                return result

            i = non_int_part.index('(')
            if i:
                result += Fraction(int(non_int_part[:i]), 10**i)
            repeat_part = non_int_part[i+1:-1]
            result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1))
            return result

        return frac(S) == frac(T)",O(1)
"class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in range(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 > maxBoxes or \
                  curr > maxWeight or \
                  (left+1 < right+1 and dp[left+1] == dp[left]): 
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]",O(n)
"class Solution(object):
    def numWays(self, s):
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD",O(n)
"import operator

class Solution(object):
    def evalRPN(self, tokens):
        numerals, operators = [], {""+"": operator.add, ""-"": operator.sub, ""*"": operator.mul, ""/"": operator.div}
        for token in tokens:
            if token not in operators:
                numerals.append(int(token))
            else:
                y, x = numerals.pop(), numerals.pop()
                numerals.append(int(operators[token](x * 1.0, y)))
        return numerals.pop()",O(n)
"class Solution(object):
    def maxDistToClosest(self, seats):
        prev, result = -1, 1
        for i in range(len(seats)):
            if seats[i]:
                if prev < 0:
                    result = i
                else:
                    result = max(result, (i-prev)//2)
                prev = i
        return max(result, len(seats)-1-prev)",O(n)
"class Solution(object):
    def wiggleSort(self, nums):
        for i in range(1, len(nums)):
            if ((i % 2) and nums[i - 1] > nums[i]) or \
                (not (i % 2) and nums[i - 1] < nums[i]):
                nums[i - 1], nums[i] = nums[i], nums[i - 1]",O(n)
"class Solution2(object):
    def wiggleSort(self, nums):
        nums.sort()
        med = (len(nums) - 1) // 2
        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]",O(nlogn)
"class Solution(object):
    def makeFancyString(self, s):
        s = list(s)
        cnt = j = 0
        for i, c in enumerate(s):
            cnt = cnt+1 if i >= 1 and c == s[i-1] else 1
            if cnt < 3:
                s[j] = c
                j += 1
        s[:] = s[:j]
        return """".join(s)",O(n)
"class Solution(object):
    def sortString(self, s):
        result, count = [], [0]*26
        for c in s:
            count[ord(c)-ord('a')] += 1
        while len(result) != len(s):
            for c in range(len(count)):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
            for c in reversed(range(len(count))):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
        return """".join(result)",O(n)
"import collections


class Solution2(object):
    def sortString(self, s):
        result, count, desc = [], collections.Counter(s), False
        while count:
            for c in sorted(list(count.keys()), reverse=desc):
                result.append(c)
                count[c] -= 1
                if not count[c]:
                    del count[c]
            desc = not desc
        return """".join(result)",other
"import string


class Solution(object):
    def validIPAddress(self, IP):
        blocks = IP.split('.')
        if len(blocks) == 4:
            for i in range(len(blocks)):
                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \
                   (blocks[i][0] == '0' and len(blocks[i]) > 1):
                    return ""Neither""
            return ""IPv4""

        blocks = IP.split(':')
        if len(blocks) == 8:
            for i in range(len(blocks)):
                if not (1 <= len(blocks[i]) <= 4) or \
                   not all(c in string.hexdigits for c in blocks[i]):
                    return ""Neither""
            return ""IPv6""
        return ""Neither""",O(1)
"

class Solution:
    def toArray(self, node):
        while node.prev:
            node = node.prev
        result = []
        while node:
            result.append(node.val)
            node = node.__next__
        return result
",O(n)
"class Solution(object):
    def checkOnesSegment(self, s):
        return ""01"" not in s",O(n)
"class Solution(object):
    def isPalindrome(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1
            if s[i].lower() != s[j].lower():
                return False
            i, j = i + 1, j - 1
        return True",O(n)
"import collections



class Solution(object):
    def isPossibleToSplit(self, nums):
        return all(v <= 2 for v in collections.Counter(nums).values())",O(n)
"class Solution(object):
    def numberOfWays(self, n, x):
        MOD = 10**9+7

        dp = [0]*(n+1)
        dp[0] = 1
        for i in range(1, n+1):
            i_pow_x = i**x
            if i_pow_x > n:
                break
            for j in reversed(range(i_pow_x, n+1)):
                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD
        return dp[-1]",O(n ^ 2)
"class Solution(object):
    def sortArrayByParity(self, A):
        i = 0
        for j in range(len(A)):
            if A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 1
        return A",O(n)
"class Solution(object):
    def baseUnitConversions(self, conversions):
        MOD = 10**9+7
        adj = [[] for _ in range(len(conversions)+1)]
        for u, v, w in conversions:
            adj[u].append((v, w))
        result = [0]*len(adj)
        result[0] = 1
        q = [0]
        while q:
            new_q = []
            for u in q:
                for v, w in adj[u]:
                    result[v] = (result[u]*w)%MOD
                    new_q.append(v)
            q = new_q
        return result",other
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def minCameraCover(self, root):
        UNCOVERED, COVERED, CAMERA = list(range(3))
        def dfs(root, result):
            left = dfs(root.left, result) if root.left else COVERED
            right = dfs(root.right, result) if root.right else COVERED
            if left == UNCOVERED or right == UNCOVERED:
                result[0] += 1
                return CAMERA
            if left == CAMERA or right == CAMERA:
                return COVERED
            return UNCOVERED
        
        result = [0]
        if dfs(root, result) == UNCOVERED:
            result[0] += 1
        return result[0]",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def canMerge(self, trees):
        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):
            for root in trees:
                val_to_root[root.val] = root
                q = [root]
                while q:
                    new_q = []
                    for node in q:
                        if node.left is None and node.right is None:
                            if node is not root:
                                leaf_vals_set.add(node.val)
                            continue
                        if node.left:
                            new_q.append(node.left)
                        if node.right:
                            new_q.append(node.right)
                    q = new_q

        def find_root(trees, left_vals_set, val_to_root):
            root = None
            for node in trees:
                if node.val in leaf_vals_set:
                    continue
                if root: 
                    return None
                root = node
            return root

        def merge_bsts(root, left_vals_set, val_to_root):
            if not root:
                return None
            del val_to_root[root.val]
            q = [(root, float(""-inf""), float(""inf""))]
            while q:
                new_q = []
                for node, left, right in q:
                    if not (left < node.val < right):
                        return None
                    if node.left:
                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:
                            node.left = val_to_root[node.left.val]
                            del val_to_root[node.left.val]
                        new_q.append((node.left, left, node.val))
                    if node.right:
                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:
                            node.right = val_to_root[node.right.val]
                            del val_to_root[node.right.val]
                        new_q.append((node.right, node.val, right))
                q = new_q
            return root if not val_to_root else None

        leaf_vals_set, val_to_root = set(), {}
        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    
        root = find_root(trees, leaf_vals_set, val_to_root)
        return merge_bsts(root, leaf_vals_set, val_to_root)",O(n)
"class Solution(object):
    def shuffle(self, nums, n):
        def index(i):
            return 2*i if i < n else 2*(i-n)+1
    
        for i in range(len(nums)):
            j = i
            while nums[i] >= 0:
                j = index(j)
                nums[i], nums[j] = nums[j], ~nums[i] 
        for i in range(len(nums)):
            nums[i] = ~nums[i]
        return nums",O(n)
"class Solution(object):
    def leftRigthDifference(self, nums):
        total = sum(nums)
        result = []
        curr = 0
        for x in nums:
            curr += x
            result.append(abs((curr-x)-(total-curr)))
        return result",O(n)
"

class Solution(object):
    def removeStars(self, s):
        result = []
        for c in s:
            if c == '*':
                result.pop()
            else:
                result.append(c)
        return """".join(result)
",O(n)
"import collections
from functools import reduce



class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        MOD = 10**9+7
        dp = collections.defaultdict(int)
        cnt = collections.defaultdict(int)
        for x in nums:
            c = cnt[x-1]+cnt[x+1]+1
            cnt[x] = (cnt[x]+c)%MOD
            dp[x] = (dp[x]+(dp[x-1]+dp[x+1]+x*c))%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, iter(dp.values()))",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, ret1[0]+ret2[0])
                    ret[0] = 1+max(ret1[0], ret2[0])
            return result
        
        return iter_dfs(root)",O(n)
"class Solution2(object):
    def diameterOfBinaryTree(self, root):
        def dfs(root):
            if not root: 
                return 0, 0
            left_d, left_h = dfs(root.left)
            right_d, right_h = dfs(root.right)
            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)
 
        return dfs(root)[0]",O(n)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i






class Solution(object):
    def __init__(self):
        self.__buf4 = [''] * 4
        self.__i4 = 0
        self.__n4 = 0

    def read(self, buf, n):
        i = 0
        while i < n:
            if self.__i4 < self.__n4: 
                buf[i] = self.__buf4[self.__i4]
                i += 1
                self.__i4 += 1
            else:
                self.__n4 = read4(self.__buf4) 
                if self.__n4:
                    self.__i4 = 0
                else: 
                    break

        return i",O(n)
"class Solution(object):
    def addBinary(self, a, b):
        result, carry, val = """", 0, 0
        for i in range(max(len(a), len(b))):
            val = carry
            if i < len(a):
                val += int(a[-(i + 1)])
            if i < len(b):
                val += int(b[-(i + 1)])
            carry, val = divmod(val, 2)
            result += str(val)
        if carry:
            result += str(carry)
        return result[::-1]",O(n)
"from itertools import zip_longest


class Solution2(object):
    def addBinary(self, a, b):
        result = """"
        carry = 0
        for x, y in zip_longest(reversed(a), reversed(b), fillvalue=""0""):
            carry, remainder = divmod(int(x)+int(y)+carry, 2)
            result += str(remainder)
        
        if carry:
            result += str(carry)
        
        return result[::-1]",O(n)
"class Solution(object):
    def maxSumOfThreeSubarrays(self, nums, k):
        n = len(nums)
        accu = [0]
        for num in nums:
            accu.append(accu[-1]+num)

        left_pos = [0] * n
        total = accu[k]-accu[0]
        for i in range(k, n):
            if accu[i+1]-accu[i+1-k] > total:
                left_pos[i] = i+1-k
                total = accu[i+1]-accu[i+1-k]
            else:
                left_pos[i] = left_pos[i-1]

        right_pos = [n-k] * n
        total = accu[n]-accu[n-k]
        for i in reversed(range(n-k)):
            if accu[i+k]-accu[i] > total:
                right_pos[i] = i
                total = accu[i+k]-accu[i]
            else:
                right_pos[i] = right_pos[i+1]

        result, max_sum = [], 0
        for i in range(k, n-2*k+1):
            left, right = left_pos[i-1], right_pos[i+k]
            total = (accu[i+k]-accu[i]) + \
                    (accu[left+k]-accu[left]) + \
                    (accu[right+k]-accu[right])
            if total > max_sum:
                max_sum = total
                result = [left, i, right]
        return result",O(n)
"class Solution(object):
    def isSelfCrossing(self, x):
        if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:
            return True

        for i in range(3, len(x)):
            if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:
                return True
            elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \
                            x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:
                return True
        return False",O(n)
"class Solution(object):
    def maxSubarraySum(self, nums, k):
        dp = [float(""inf"")]*k
        dp[-1] = 0
        curr = 0
        result = float(""-inf"")
        for i, x in enumerate(nums):
            curr += x
            result = max(result, curr-dp[i%k])
            dp[i%k] = min(dp[i%k], curr)
        return result",O(n)
"class Solution(object):
    def arrayRankTransform(self, arr):
        return list(map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr))",O(nlogn)
"import collections

        
class Solution(object):
    def minSetSize(self, arr):
        counting_sort = [0]*len(arr)
        count = collections.Counter(arr)
        for c in count.values():
            counting_sort[c-1] += 1
        result, total = 0, 0
        for c in reversed(range(len(arr))):
            if not counting_sort[c]:
                continue
            count = min(counting_sort[c],
                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)
            result += count
            total += count*(c+1)
            if total >= (len(arr)+1)//2:
                break
        return result",O(n)
"

class Solution(object):
    def doesAliceWin(self, s):
        return any(x in ""aeiou"" for x in s)
",O(n)
"class Solution(object):
    def findMaxK(self, nums):
        lookup = set(nums)
        return max([x for x in lookup if x > 0 and -x in lookup] or [-1])",O(n)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def insertFront(self, value):
        if self.isFull():
            return False
        self.__start = (self.__start-1) % len(self.__buffer)
        self.__buffer[self.__start] = value
        self.__size += 1
        return True

    def insertLast(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deleteFront(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def deleteLast(self):
        if self.isEmpty():
            return False
        self.__size -= 1
        return True

    def getFront(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def getRear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"class Solution(object):
    def maximumDifference(self, nums):
        result, prefix = 0, float(""inf"")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1",O(n)
"import collections



class Solution(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            new_stk = []
            while stk:
                t, node, parent, choices = stk.pop()
                if not t or not (len(G[node])-(parent != 0)):
                    if node == target:
                        return 1.0/choices
                    continue
                for child in G[node]:
                    if child == parent:
                        continue
                    new_stk.append((t-1, child, node,
                                    choices*(len(G[node])-(parent != 0))))
            stk = new_stk
        return 0.0",O(n)
"class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0",O(n)
"class Solution3(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return int(node == target)
            result = 0
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result*(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        choices = dfs(G, target, t, 1, 0)
        return 1.0/choices if choices else 0.0",O(n)
"class Solution4(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return float(node == target)
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result/(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        return dfs(G, target, t, 1, 0)",O(n)
"class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        arr.sort()
        result = 1
        for i in range(1, len(arr)):
            result = min(result+1, arr[i])
        return result",O(nlogn)
"class Solution(object):

    def __init__(self, big, medium, small):
        self.__space = [0, big, medium, small]

    def addCar(self, carType):
        if self.__space[carType] > 0:
            self.__space[carType] -= 1
            return True
        return False",O(1)
"class Solution(object):
    def maxSumDivThree(self, nums):
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]",O(n)
"class Solution(object):
    def solveQueries(self, nums, queries):
        dist = [len(nums)]*len(nums)
        left = {}
        for i in range(2*len(nums)-1):
            x = nums[i%len(nums)]
            if x in left:
                dist[i%len(dist)] = min(dist[i%len(dist)], i-left[x])
            left[x] = i
        right = {}
        for i in reversed(range(2*len(nums)-1)):
            x = nums[i%len(nums)]
            if x in right:
                dist[i%len(dist)] = min(dist[i%len(dist)], right[x]-i)
            right[x] = i
        result = [-1]*len(queries)
        for i, x in enumerate(queries):
            if dist[x] < len(nums):
                result[i] = dist[x]
        return result",O(n)
"class Solution(object):
    def minimumMoves(self, grid):
        level, q, lookup = 0, [(0, 0, False)], set()
        while q:
            next_q = []
            for r, c, is_vertical in q:
                if (r, c, is_vertical) in lookup:
                    continue
                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):
                    return level
                lookup.add((r, c, is_vertical))
                if not is_vertical:
                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:
                        next_q.append((r, c+1, is_vertical))
                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r+1, c, is_vertical))
                        next_q.append((r, c, not is_vertical))
                else:
                    if r+2 != len(grid) and grid[r+2][c] == 0:
                        next_q.append((r+1, c, is_vertical))
                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r, c+1, is_vertical))
                        next_q.append((r, c, not is_vertical))
            q = next_q
            level += 1
        return -1",O(n ^ 2)
"class Solution(object):
    def countGoodTriplets(self, arr, a, b, c):
        return sum(abs(arr[i]-arr[j]) <= a and
                   abs(arr[j]-arr[k]) <= b and
                   abs(arr[k]-arr[i]) <= c 
                   for i in range(len(arr)-2)
                       for j in range(i+1, len(arr)-1)
                           for k in range(j+1, len(arr)))",O(n ^ 3)
"class Solution(object):
    def averageHeightOfBuildings(self, buildings):
        points = []
        for x, y, h in buildings:
            points.append((x, 1, h))
            points.append((y, -1, h))
        points.sort()
        result = []
        total = cnt = 0
        prev = -1
        for curr, c, h in points:
            if cnt and curr != prev:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h*c
            cnt += c
            prev = curr
        return result",O(nlogn)
"import collections


class Solution2(object):
    def averageHeightOfBuildings(self, buildings):
        count = collections.defaultdict(lambda: (0, 0))
        for x, y, h in buildings:
            count[x] = (count[x][0]+1, count[x][1]+h)
            count[y] = (count[y][0]-1, count[y][1]-h)
        result = []
        total = cnt = 0
        prev = -1
        for curr, (c, h) in sorted(count.items()):
            if cnt:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h
            cnt += c
            prev = curr
        return result",O(nlogn)
"
import collections


class Solution(object):
    def predictPartyVictory(self, senate):
        n = len(senate)
        radiant, dire = collections.deque(), collections.deque()
        for i, c in enumerate(senate):
            if c == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        while radiant and dire:
            r_idx, d_idx = radiant.popleft(), dire.popleft()
            if r_idx < d_idx:
                radiant.append(r_idx+n)
            else:
                dire.append(d_idx+n)
        return ""Radiant"" if len(radiant) > len(dire) else ""Dire""

",O(n)
"class Solution(object):
    def maximumPossibleSize(self, nums):
        result = prev = 0
        for x in nums:
            if prev <= x:
                prev = x
                result += 1
        return result",O(n)
"class Solution(object):
    def wiggleMaxLength(self, nums):
        if len(nums) < 2:
            return len(nums)

        length, up = 1, None

        for i in range(1, len(nums)):
            if nums[i - 1] < nums[i] and (up is None or up is False):
                length += 1
                up = True
            elif nums[i - 1] > nums[i] and (up is None or up is True):
                length += 1
                up = False

        return length",O(n)
"class Solution(object):
    def checkValidCuts(self, n, rectangles):
        def check(idx):
            cnt = 0
            curr = rectangles[0][idx+2]
            for x in rectangles:
                cnt += int(curr <= x[idx])
                curr = max(curr, x[idx+2])
            return cnt >= 2
    
        for idx in range(2):
            rectangles.sort(key=lambda x: x[idx])
            if check(idx):
                return True
        return False",O(nlogn)
"class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        start, total_sum, current_sum = 0, 0, 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            current_sum += diff
            total_sum += diff
            if current_sum < 0:
                start = i + 1
                current_sum = 0
        if total_sum >= 0:
            return start

        return -1",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):
        curr = [root]
        while curr:
            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]
        return sum(node.val for node in prev)
",O(n)
"class Solution(object):
    def countElements(self, arr):
        lookup = set(arr)
        return sum(1 for x in arr if x+1 in lookup)",O(n)
"class Solution(object):
    def countElements(self, arr):
        arr.sort()
        result, l = 0, 1
        for i in range(len(arr)-1):
            if arr[i] == arr[i+1]:
                l += 1
                continue
            if arr[i]+1 == arr[i+1]:
                result += l
            l = 1
        return result",O(nlogn)
"class Solution(object):
    def tree2str(self, t):
        if not t: return """"
        s = str(t.val)
        if t.left or t.right:
            s += ""("" + self.tree2str(t.left) + "")""
        if t.right:
            s += ""("" + self.tree2str(t.right) + "")""
        return s",O(n)
"class Solution(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range((len(nums)+1)//2, len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return left*2",O(nlogn)
"class Solution2(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return min(left, len(nums)//2)*2",O(nlogn)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):
        result = [None]
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret[0] = Node(node.val)
                for child in reversed(node.children):
                    ret1 = [None]
                    stk.append((2, (ret1, ret)))
                    stk.append((1, (child, ret1)))
            else:
                ret1, ret = params
                ret[0].children.append(ret1[0])
        return result[0]",O(n)
"class Solution2(object):
    def cloneTree(self, root):
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)",O(n)
"class Solution(object):
    def threeConsecutiveOdds(self, arr):
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False",O(n)
"class Solution(object):
    def longestConsecutive(self, root):
        self.max_len = 0

        def longestConsecutiveHelper(root):
            if not root:
                return 0

            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)

            cur_len = 1
            if root.left and root.left.val == root.val + 1:
                cur_len = max(cur_len, left_len + 1)
            if root.right and root.right.val == root.val + 1:
                cur_len = max(cur_len, right_len + 1)

            self.max_len = max(self.max_len, cur_len)

            return cur_len

        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack",O(n)
"class Solution(object):
    def minTaps(self, n, ranges):
        def jump_game(A):
            jump_count, reachable, curr_reachable = 0, 0, 0
            for i, length in enumerate(A):
                if i > reachable:
                    return -1
                if i > curr_reachable:
                    curr_reachable = reachable
                    jump_count += 1
                reachable = max(reachable, i+length)
            return jump_count
    
        max_range = [0]*(n+1)
        for i, r in enumerate(ranges):
            left, right = max(i-r, 0), min(i+r, n)
            max_range[left] = max(max_range[left], right-left)
        return jump_game(max_range)",O(n)
"class Solution2(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b

        for i in range(k, len(word), k):
            if all(word[i+j] == word[j] for j in range(len(word)-i)):
                return i//k
        return ceil_divide(len(word), k)",O(n ^ 2)
"class Solution(object):
    def countTexts(self, pressedKeys):
        MOD = 10**9+7
        dp = [1]*5
        for i in range(1, len(pressedKeys)+1):
            dp[i%5] = 0
            for j in reversed(range(max(i-(4 if pressedKeys[i-1] in ""79"" else 3), 0), i)):
                if pressedKeys[j] != pressedKeys[i-1]:
                    break
                dp[i%5] = (dp[i%5]+dp[j%5])%MOD
        return dp[len(pressedKeys)%5]",O(n)
"class Solution(object):
    def findNonMinOrMax(self, nums):
        mx, mn = float(""-inf""), float(""inf"")
        result = -1
        for x in nums:
            if mn < x < mx:
                return x
            if x < mn:
                result = mn
                mn = x
            if x > mx:
                result = mx
                mx = x
        return result if mn < result < mx else -1",O(n)
"class Solution2(object):
    def findNonMinOrMax(self, nums):
        mx, mn = max(nums), min(nums)
        return next((x for x in nums if x not in (mx, mn)), -1)",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def earliestAcq(self, logs, N):
        logs.sort()
        union_find = UnionFind(N)
        for t, a, b in logs:
            union_find.union_set(a, b)
            if union_find.count == 1:
                return t
        return -1",O(nlogn)
"import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):
        heapq.heapify(blocks)
        while len(blocks) != 1:
            x, y = heapq.heappop(blocks), heapq.heappop(blocks)
            heapq.heappush(blocks, y+split)
        return heapq.heappop(blocks)",O(nlogn)
"class Solution(object):
    def thousandSeparator(self, n):
        result = []
        s = str(n)
        for i, c in enumerate(str(n)):
            if i and (len(s)-i)%3 == 0:
                result.append(""."")
            result.append(c)
        return """".join(result)",O(n)
"class Solution(object):
    def isSubsequence(self, s, t):
        if not s:
            return True

        i = 0
        for c in t:
            if c == s[i]:
                i += 1
            if i == len(s):
                break
        return i == len(s)",O(n)
"class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize > box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result",O(nlogn)
"class Solution(object):
    def minimumMoves(self, nums, k, maxChanges):
        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        cnt = max(k-maxChanges, 0)
        for l in range(cnt, min(cnt+3, k, len(idxs))+1):
            cnt1 = (k-l)*2
            for i in range(len(idxs)-l+1):
                cnt2 = (prefix[(i+l-1)+1]-prefix[(i+l-1)-(l//2-1)])-(prefix[(i+(l//2-1))+1]-prefix[i])
                result = min(result, cnt2+cnt1)
        return result",other
"import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students[students[""student_id""] == 101][[""name"", ""age""]]",O(n)
"
class Solution(object):
    def getConcatenation(self, nums):
        nums.extend(nums)
        return nums


",O(n)
"class Solution2(object):
    def getConcatenation(self, nums):
        return nums+nums",O(n)
"class Solution3(object):
    def getConcatenation(self, nums):
        return nums*2",O(n)
"import collections



class Solution(object):
    def countPairs(self, nums, low, high):
        def count(nums, x):
            result = 0
            dp = collections.Counter(nums)
            while x:
                if x&1:
                    result += sum(dp[(x^1)^k]*dp[k] for k in dp.keys())//2 
                dp = collections.Counter({k>>1: dp[k]+dp[k^1] for k in dp.keys()})
                x >>= 1
            return result
    
        return count(nums, high+1)-count(nums, low)",other
"class Trie(object):
    def __init__(self):
        self.__root = {}
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {""_count"":0}
            node = node[curr]
            node[""_count""] += 1
                
    def query(self, num, limit):
        node, result = self.__root, 0
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            bit = (limit>>i) & 1
            if bit:
                if curr in node:
                    result += node[0^curr][""_count""] 
            if bit^curr not in node:
                break
            node = node[bit^curr]
        return result


class Solution2(object):
    def countPairs(self, nums, low, high):
        result = 0
        trie = Trie()
        for x in nums:
            result += trie.query(x, high+1)-trie.query(x, low)
            trie.insert(x)
        return result",O(n)
"class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD 
            else:
                ends0 = (ends0+ends1)%MOD 
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD",O(n)
"class Solution(object):
    def smallestEvenMultiple(self, n):
        return n<<(n&1)",O(1)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reverseKGroup(self, head, k):
        dummy = ListNode(-1)
        dummy.next = head

        cur, cur_dummy = head, dummy
        length = 0

        while cur:
            next_cur = cur.__next__
            length = (length + 1) % k

            if length == 0:
                next_dummy = cur_dummy.__next__
                self.reverse(cur_dummy, cur.__next__)
                cur_dummy = next_dummy

            cur = next_cur

        return dummy.__next__

    def reverse(self, begin, end):
            first = begin.__next__
            cur = first.__next__

            while cur != end:
                first.next = cur.__next__
                cur.next = begin.__next__
                begin.next = cur
                cur = first.__next__",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):
        if not root:
            return None
        if not root.left and not root.right:
            return None if root.val < limit else root
        root.left = self.sufficientSubset(root.left, limit-root.val)
        root.right = self.sufficientSubset(root.right, limit-root.val)
        if not root.left and not root.right:
            return None
        return root
",O(n)
"class Solution(object):
    def maximumBeauty(self, flowers):
        lookup = {}
        prefix = [0]
        result = float(""-inf"")
        for i, f in enumerate(flowers):
            prefix.append(prefix[-1]+f if f > 0 else prefix[-1])
            if not f in lookup:
                lookup[f] = i
                continue
            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]])
        return result",O(n)
"class Solution(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        def inv(x, m): 
            return pow(x, m-2, m) 

        def nCr(n, k, m):
            if n-k < k:
                return nCr(n, n-k, m)
            result = 1
            for i in range(1, k+1):
                result = result*(n-k+i)*inv(i, m)%m
            return result

        n = num_people//2
        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD",O(n)
"class Solution2(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        dp = [0]*(num_people//2+1)
        dp[0] = 1
        for k in range(1, num_people//2+1):
            for i in range(k):
                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD
        return dp[num_people//2]",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def postorderTraversal(self, root):
        dummy = TreeNode(0)
        dummy.left = root
        result, cur = [], dummy
        while cur:
            if cur.left is None:
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    result += self.traceBack(cur.left, node)
                    node.right = None
                    cur = cur.right

        return result

    def traceBack(self, frm, to):
        result, cur = [], frm
        while cur is not to:
            result.append(cur.val)
            cur = cur.right
        result.append(to.val)
        result.reverse()
        return result",O(n)
"class Solution2(object):
    def postorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root, True))
                stack.append((root.right, False))
                stack.append((root.left, False))
        return result",O(n)
"class Solution(object):
    def countPalindromicSubsequence(self, s):
        first, last = [len(s)]*26, [-1]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        return sum(len(set(s[i] for i in range(first[c]+1, last[c]))) for c in range(26))",O(n)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"import collections



class Solution(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        self.__key_to_freq = {}

    def get(self, key):
        if key not in self.__key_to_freq:
            return -1
        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_freq and self.__size == self.__capa:
            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]
            if not self.__freq_to_nodes[self.__min_freq]:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_freq:
            freq = self.__key_to_freq[key]
            del self.__freq_to_nodes[freq][key]
            if not self.__freq_to_nodes[freq]:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_freq[key] = freq
        self.__freq_to_nodes[freq][key] = value
        self.__size += 1",O(1)
"import collections


class ListNode(object):
    def __init__(self, key, value, freq):
        self.key = key
        self.val = value
        self.freq = freq
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 


class Solution2(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(LinkedList)
        self.__key_to_node = {}

    def get(self, key):
        if key not in self.__key_to_node:
            return -1
        value = self.__key_to_node[key].val
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_node and self.__size == self.__capa:
            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]
            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)
            if not self.__freq_to_nodes[self.__min_freq].head:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_node:
            old_node = self.__key_to_node[key]
            freq = old_node.freq
            self.__freq_to_nodes[freq].delete(old_node)
            if not self.__freq_to_nodes[freq].head:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_node[key] = ListNode(key, value, freq)
        self.__freq_to_nodes[freq].append(self.__key_to_node[key])
        self.__size += 1",O(1)
"import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):
        counter = collections.Counter((min(x), max(x)) for x in dominoes)
        return sum(v*(v-1)//2 for v in counter.values())",O(n)
"class Solution(object):
    def shiftingLetters(self, S, shifts):
        result = []
        times = sum(shifts) % 26
        for i, c in enumerate(S):
            index = ord(c) - ord('a')
            result.append(chr(ord('a') + (index+times) % 26))
            times = (times-shifts[i]) % 26
        return """".join(result)",O(n)
"class Solution(object):
    def surfaceArea(self, grid):
        result = 0
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 2 + grid[i][j]*4
                if i:
                    result -= min(grid[i][j], grid[i-1][j])*2
                if j:
                    result -= min(grid[i][j], grid[i][j-1])*2
        return result",O(n ^ 2)
"import heapq



class Solution(object):
    def minOperations(self, nums, k):
        result = 0
        heapq.heapify(nums)
        while nums:
            if nums[0] >= k:
                break
            mn1 = heapq.heappop(nums)
            mn2 = heapq.heappop(nums)
            heapq.heappush(nums, 2*mn1+mn2)
            result += 1
        return result",O(nlogn)
"import collections


class Solution(object):
    def closeStrings(self, word1, word2):
        if len(word1) != len(word2):
            return False 
        
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)  
        return set(cnt1.keys()) == set(cnt2.keys()) and \
               collections.Counter(iter(cnt1.values())) == collections.Counter(iter(cnt2.values()))",O(n)
"class Solution(object):
    def insert(self, intervals, newInterval):
        result = []
        i = 0
        while i < len(intervals) and newInterval[0] > intervals[i][1]:
            result += intervals[i],
            i += 1
        while i < len(intervals) and newInterval[1] >= intervals[i][0]:
            newInterval = [min(newInterval[0], intervals[i][0]),
                           max(newInterval[1], intervals[i][1])]
            i += 1
        result.append(newInterval)
        result.extend(intervals[i:])
        return result",O(n)
"class Solution(object):
    def checkPossibility(self, nums):
        modified, prev = False, nums[0]
        for i in range(1, len(nums)):
            if prev > nums[i]:
                if modified:
                    return False
                if i-2 < 0 or nums[i-2] <= nums[i]:
                    prev = nums[i]   


                modified = True
            else:
                prev = nums[i]
        return True",O(n)
"

class Solution(object):
    def repeatedCharacter(self, s):
        lookup = set()
        for c in s:
            if c in lookup:
                break
            lookup.add(c)
        return c
",O(n)
"class Solution(object):
    def findNumber(self):
        return reduce(lambda accu, x: accu|x, (1<<i for i in range(30) if commonSetBits(1<<i)))",O(logn)
"
class Node(object):
    def __init__(self, val, next):
        self.val = val
        self.next = next


class Solution(object):
    def insert(self, head, insertVal):
        def insertAfter(node, val):
            node.next = Node(val, node.next)
        
        if not head:
            node = Node(insertVal, None)
            node.next = node
            return node

        curr = head
        while True:
            if curr.val < curr.next.val:
                if curr.val <= insertVal and \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            elif curr.val > curr.next.val:
                if curr.val <= insertVal or \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            else:
                if curr.__next__ == head:
                    insertAfter(curr, insertVal)
                    break
            curr = curr.__next__
        return head

",O(n)
"class Solution(object):
    def minArrayLength(self, nums, k):
        if 0 in nums:
            return 1
        result = len(nums)
        curr = nums[0]
        for i in range(1, len(nums)):
            if curr*nums[i] > k:
                curr = nums[i]
            else:
                curr *= nums[i]
                result -= 1
        return result",O(n)
"import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)",O(n)
"class Solution(object):
    def splitBST(self, root, V):
        if not root:
            return None, None
        elif root.val <= V:
            result = self.splitBST(root.right, V)
            root.right = result[0]
            return root, result[1]
        else:
            result = self.splitBST(root.left, V)
            root.left = result[1]
            return result[0], root",O(n)
"class Solution(object):
    def countSubTrees(self, n, edges, labels):
        def iter_dfs(labels, adj, node, parent, result):
            stk = [(1, (node, parent, [0]*26))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, ret = params
                    stk.append((4, (node, ret)))
                    stk.append((2, (node, parent, reversed(adj[node]), ret)))
                elif step == 2:
                    node, parent, it, ret = params
                    child = next(it, None)
                    if not child or child == parent:
                        continue
                    ret2 = [0]*26
                    stk.append((2, (node, parent, it, ret)))
                    stk.append((3, (ret2, ret)))
                    stk.append((1, (child, node, ret2)))
                elif step == 3:
                    ret2, ret = params
                    for k in range(len(ret2)):
                        ret[k] += ret2[k]
                else:
                    node, ret = params
                    ret[ord(labels[node]) - ord('a')] += 1
                    result[node] += ret[ord(labels[node]) - ord('a')]
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        iter_dfs(labels, adj, 0, -1, result)
        return result",O(n)
"import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):
        def dfs(labels, adj, node, parent, result):
            count = [0]*26
            for child in adj[node]:
                if child == parent:
                    continue
                new_count = dfs(labels, adj, child, node, result)
                for k in range(len(new_count)):
                    count[k] += new_count[k]
            count[ord(labels[node]) - ord('a')] += 1
            result[node] = count[ord(labels[node]) - ord('a')]
            return count
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        dfs(labels, adj, 0, -1, result)
        return result",O(n)
"class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))",O(nlogn)
"class Solution(object):
    def findPrimePairs(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf 

        spf = linear_sieve_of_eratosthenes(n)
        return [[i, n-i] for i in range(2, n//2+1) if spf[i] == i and spf[n-i] == n-i]",O(n)
"class Solution(object):
    def minimumSwaps(self, nums):
        min_idx = min(range(len(nums)), key=nums.__getitem__)
        max_idx = max(reversed(range(len(nums))), key=nums.__getitem__)
        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def zigzagLevelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            result.append(vals[::-1] if len(result) % 2 else vals)
            current = next_level
        return result",O(n)
"import collections


class Solution(object):
    def countKDifference(self, nums, k):
        lookup = collections.defaultdict(int)
        result = 0
        for x in nums:
            if x-k in lookup:
                result += lookup[x-k]
            if x+k in lookup:
                result += lookup[x+k]
            lookup[x] += 1            
        return result",O(n)
"class Solution(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[0, m-1, n-1,           0],
             [1, m-2,   0,         n-1],
             [1,   0, n-2,         m-1],
             [0,   1,   1, (n-2)+(m-2)]]
        dp = [0]*4 
        if source == dest:
            dp[0] = 1
        elif source[0] == dest[0]:
            dp[1] = 1
        elif source[1] == dest[1]:
            dp[2] = 1
        else:
            dp[3] = 1
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return dp[0]",O(logn)
"class Solution2(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        both_same = row_same = col_same = no_same = 0
        if source == dest:
            both_same = 1
        elif source[0] == dest[0]:
            row_same = 1
        elif source[1] == dest[1]:
            col_same = 1
        else:
            no_same = 1
        for _ in range(k):
            both_same, row_same, col_same, no_same = (row_same+col_same)%MOD, (both_same*(m-1)+row_same*(m-2)+no_same)%MOD, (both_same*(n-1)+col_same*(n-2)+no_same)%MOD, (row_same*(n-1)+col_same*(m-1)+no_same*((n-2)+(m-2)))%MOD
        return both_same",other
"class Solution(object):
    def minScoreTriangulation(self, A):
        dp = [[0 for _ in range(len(A))] for _ in range(len(A))]
        for p in range(3, len(A)+1):
            for i in range(len(A)-p+1):
                j = i+p-1
                dp[i][j] = float(""inf"")
                for k in range(i+1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k])
        return dp[0][-1]",O(n ^ 3)
"class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        S = ""croak""
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1",O(n)
"class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        left, right = 0, len(warehouse)-1
        for h in boxes:
            if h <= warehouse[left]:
                left += 1
            elif h <= warehouse[right]:
                right -= 1
            if left > right:
                break
        return left + (len(warehouse)-1-right)",O(nlogn)
"class Solution(object):
    def isWinner(self, player1, player2):
        k = 2
        def f(arr):
            result = cnt = 0
            for i in range(len(arr)):
                result += 2*arr[i] if cnt else arr[i]
                cnt += (arr[i] == 10)
                if i-k >= 0:
                    cnt -= (arr[i-k] == 10)
            return result

        a, b = f(player1), f(player2)
        return 1 if a > b else 2 if a < b else 0",O(n)
"class Solution(object):
    def circularArrayLoop(self, nums):
        def next_index(nums, i):
            return (i + nums[i]) % len(nums)

        for i in range(len(nums)):
            if nums[i] == 0:
                continue

            slow, fast = i, i
            while nums[next_index(nums, slow)] * nums[i] > 0 and \
                  nums[next_index(nums, fast)] * nums[i] > 0 and \
                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:
                slow = next_index(nums, slow)
                fast = next_index(nums, next_index(nums, fast))
                if slow == fast:
                    if slow == next_index(nums, slow):
                        break
                    return True

            slow, val = i, nums[i]
            while nums[slow] * val > 0:
                tmp = next_index(nums, slow)
                nums[slow] = 0
                slow = tmp

        return False",O(n)
"class Solution(object):
    def largest1BorderedSquare(self, grid):
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-l+1):
                for j in range(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) >= l:
                        return l*l
        return 0",O(n ^ 3)
"class Solution(object):
    def findMaximumScore(self, nums):
        result = mx = 0
        for x in nums:
            result += mx
            mx = max(mx, x)
        return result",O(n)
"import random
import collections



class Solution(object):
    def minCost(self, basket1, basket2):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        cnt = collections.Counter()
        for x in basket1:
            cnt[x] += 1
        for x in basket2:
            cnt[x] -= 1
        mn = min(cnt.keys())
        swaps = []
        for k, v in cnt.items():
            if v%2:
                return -1
            swaps.extend(k for _ in range(abs(v)//2))
        nth_element(swaps, len(swaps)//2)
        return sum(min(swaps[i], mn*2) for i in range(len(swaps)//2))",O(n)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def isAdditiveNumber(self, num):
        def add(a, b):
            res, carry, val = """", 0, 0
            for i in range(max(len(a), len(b))):
                val = carry
                if i < len(a):
                    val += int(a[-(i + 1)])
                if i < len(b):
                    val += int(b[-(i + 1)])
                carry, val = val / 10, val % 10
                res += str(val)
            if carry:
                res += str(carry)
            return res[::-1]

        for i in range(1, len(num)):
            for j in range(i + 1, len(num)):
                s1, s2 = num[0:i], num[i:j]
                if (len(s1) > 1 and s1[0] == '0') or \
                   (len(s2) > 1 and s2[0] == '0'):
                    continue

                expected = add(s1, s2)
                cur = s1 + s2 + expected
                while len(cur) < len(num):
                    s1, s2, expected = s2, expected, add(s2, expected)
                    cur += expected
                if cur == num:
                    return True
        return False",O(n ^ 3)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.head(3)",O(1)
"class Solution(object):
    def maxProfit(self, prices):
        hold1, hold2 = float(""-inf""), float(""-inf"")
        release1, release2 = 0, 0
        for i in prices:
            hold1 = max(hold1, -i)
            release1 = max(release1, hold1 + i)
            hold2 = max(hold2, release1 - i)
            release2 = max(release2, hold2 + i)
        return release2",O(n)
"class Solution3(object):
    def maxProfit(self, prices):
        min_price, max_profit_from_left, max_profits_from_left = \
            float(""inf""), 0, []
        for price in prices:
            min_price = min(min_price, price)
            max_profit_from_left = max(max_profit_from_left, price - min_price)
            max_profits_from_left.append(max_profit_from_left)

        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []
        for i in reversed(list(range(len(prices)))):
            max_price = max(max_price, prices[i])
            max_profit_from_right = max(max_profit_from_right,
                                        max_price - prices[i])
            max_profits_from_right.insert(0, max_profit_from_right)

        max_profit = 0
        for i in range(len(prices)):
            max_profit = max(max_profit,
                             max_profits_from_left[i] +
                             max_profits_from_right[i])

        return max_profit",O(n)
"import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):
        count = collections.Counter(arr)
        result, count_count = len(count), collections.Counter(iter(count.values()))
        for c in range(1, len(arr)+1): 
            if k < c*count_count[c]:
                result -= k//c
                break
            k -= c*count_count[c]
            result -= count_count[c]                
        return result",O(n)
"class Solution(object):
    def threeSum(self, nums):
        result = []
        nums.sort()
        for i in reversed(list(range(2, len(nums)))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            target = -nums[i]
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] < target:
                    left += 1
                elif nums[left]+nums[right] > target:
                    right -= 1
                else:
                    result.append([nums[left], nums[right], nums[i]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        return result",O(n ^ 2)
"class Solution2(object):
    def threeSum(self, nums):
        nums, result, i = sorted(nums), [], 0
        while i < len(nums) - 2:
            if i == 0 or nums[i] != nums[i - 1]:
                j, k = i + 1, len(nums) - 1
                while j < k:
                    if nums[i] + nums[j] + nums[k] < 0:
                        j += 1
                    elif nums[i] + nums[j] + nums[k] > 0:
                        k -= 1
                    else:
                        result.append([nums[i], nums[j], nums[k]])
                        j, k = j + 1, k - 1
                        while j < k and nums[j] == nums[j - 1]:
                            j += 1
                        while j < k and nums[k] == nums[k + 1]:
                            k -= 1
            i += 1
        return result",O(n ^ 2)
"class Solution(object):
    def longestSubarray(self, nums):
        count, left = 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            if count >= 2:
                count -= (nums[left] == 0)
                left += 1
        return (right-left+1)-1",O(n)
"class Solution2(object):
    def longestSubarray(self, nums):
        result, count, left = 0, 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            while count >= 2:
                count -= (nums[left] == 0)
                left += 1
            result = max(result, right-left+1)
        return result-1",O(n)
"class Solution(object):
    def mctFromLeafValues(self, arr):
        result = 0
        stk = [float(""inf"")]
        for x in arr:
            while stk[-1] <= x:
                result += stk.pop() * min(stk[-1], x)
            stk.append(x)
        while len(stk) > 2:
            result += stk.pop() * stk[-1]
        return result",O(n)
"class Solution(object):
    def strongPasswordCheckerII(self, password):
        SPECIAL = set(""!
        return (len(password) >= 8 and
                any(c.islower() for c in password) and
                any(c.isupper() for c in password) and
                any(c.isdigit() for c in password) and
                any(c in SPECIAL for c in password) and
                all(password[i] != password[i+1] for i in range(len(password)-1)))",O(n)
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        if s == s[::-1]: 
            return len(s)

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return dp[0][-1]",O(n ^ 2)
"class Solution(object):
    def ipToCIDR(self, ip, n):
        def ipToInt(ip):
            result = 0
            for i in ip.split('.'):
                result = 256 * result + int(i)
            return result

        def intToIP(n):
            return ""."".join(str((n >> i) % 256) \
                            for i in (24, 16, 8, 0))

        start = ipToInt(ip)
        result = []
        while n:
            mask = max(33-(start & ~(start-1)).bit_length(), \
                       33-n.bit_length())
            result.append(intToIP(start) + '/' + str(mask))
            start += 1 << (32-mask)
            n -= 1 << (32-mask)
        return result",O(n)
"class Solution(object):
    def largestRectangleArea(self, heights):
        stk, result = [-1], 0
        for i in range(len(heights)+1):
            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
            stk.append(i) 
        return result",O(n)
"class Solution(object):
    def relativeSortArray(self, arr1, arr2):
        lookup = {v: i for i, v in enumerate(arr2)}
        return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i))",O(nlogn)
"class Solution(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [n, 0]
        n -= self.__w-1
        if n < self.__h:
            return [self.__w-1, n]
        n -= self.__h-1
        if n < self.__w:
            return [(self.__w-1)-n, self.__h-1]
        n -= self.__w-1
        return [0, (self.__h-1)-n]

    def getDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return ""South"" if n == 0 and self.__curr else ""East""
        n -= self.__w-1
        if n < self.__h:
            return ""North""
        n -= self.__h-1
        if n < self.__w:
            return ""West""
        n -= self.__w-1
        return ""South""",O(1)
"class Solution2(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        return self.__getPosDir()[0] 

    def getDir(self):
        return self.__getPosDir()[1]

    def __getPosDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [[n, 0], ""South"" if n == 0 and self.__curr else ""East""]
        n -= self.__w-1
        if n < self.__h:
            return [[self.__w-1, n], ""North""]
        n -= self.__h-1
        if n < self.__w:
            return [[(self.__w-1)-n, self.__h-1], ""West""]
        n -= self.__w-1
        return [[0, (self.__h-1)-n], ""South""]",O(1)
"class Solution(object):
    def getLastMoment(self, n, left, right):
        return max(max(left or [0]), n-min(right or [n]))",O(n)
"from random import randint


class Solution(object):
    def minMoves2(self, nums):
        def kthElement(nums, k):
            def PartitionAroundPivot(left, right, pivot_idx, nums):
                pivot_value = nums[pivot_idx]
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if nums[i] > pivot_value:
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
                if new_pivot_idx == k:
                    return nums[new_pivot_idx]
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1

        median = kthElement(nums, len(nums)//2)
        return sum(abs(num - median) for num in nums)

    def minMoves22(self, nums):
        median = sorted(nums)[len(nums) / 2]
        return sum(abs(num - median) for num in nums)",O(n)
"
import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):
        A_B_sum = collections.Counter(a+b for a in A for b in B)
        return sum(A_B_sum[-c-d] for c in C for d in D)

",O(n ^ 2)
"class Solution(object):
    def findMaximums(self, nums):
        def find_bound(nums, direction, init):
            result = [0]*len(nums)
            stk = [init]
            for i in direction(range(len(nums))):
                while stk[-1] != init and nums[stk[-1]] >= nums[i]:
                    stk.pop()
                result[i] = stk[-1]
                stk.append(i)
            return result

        left = find_bound(nums, lambda x: x, -1)
        right = find_bound(nums, reversed, len(nums))
        result = [-1]*len(nums)
        for i, v in enumerate(nums):
            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)
        for i in reversed(range(len(nums)-1)):
            result[i] = max(result[i], result[i+1])
        return result",O(n)
"class Solution(object):
    def largestOddNumber(self, num):
        for i in reversed(range(len(num))):
            if int(num[i])%2:
                return num[:i+1]
        return """"",O(n)
"class Solution(object):
    def wateringPlants(self, plants, capacity):
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can < x:
                result += 2*i
                can = capacity
            can -= x
        return result",O(n)
"from collections import deque


class Solution(object):

    def __init__(self, vec2d):
        self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def __next__(self):
        length, iterator = self.stack.popleft()
        if length > 1:
            self.stack.appendleft((length-1, iterator))
        return next(iterator)

    def hasNext(self):
        return bool(self.stack)",O(1)
"class Solution(object):
    def stoneGameVII(self, stones):
        def score(i, j):
            return prefix[j+1]-prefix[i]

        prefix = [0]
        for stone in stones:
            prefix.append(prefix[-1]+stone)
        dp = [[0 for _ in range(len(stones))] for _ in range(2)]
        for i in reversed(range(len(stones))):
            for j in range(i+1, len(stones)):
                dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1])
        return dp[0][-1]",O(n ^ 2)
"class Solution(object):
    def minSwap(self, A, B):
        dp_no_swap, dp_swap = [0]*2, [1]*2
        for i in range(1, len(A)):
            dp_no_swap[i%2], dp_swap[i%2] = float(""inf""), float(""inf"")
            if A[i-1] < A[i] and B[i-1] < B[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1)
            if A[i-1] < B[i] and B[i-1] < A[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1)
        return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2])",O(n)
"class Solution(object):
    def numDistinct(self, S, T):
        ways = [0 for _ in range(len(T) + 1)]
        ways[0] = 1
        for S_char in S:
            for j, T_char in reversed(list(enumerate(T))):
                if S_char == T_char:
                    ways[j + 1] += ways[j]
        return ways[len(T)]",O(n ^ 2)
"class Solution(object):
    def findDelayedArrivalTime(self, arrivalTime, delayedTime):
        return (arrivalTime + delayedTime)%24",O(1)
"class Solution(object):
    def monkeyMove(self, n):
        MOD = 10**9+7
        return (pow(2, n, MOD)-2)%MOD",O(logn)
"import collections


class Solution(object):
    def smallestSubsequence(self, text):
        count = collections.Counter(text)

        lookup, stk = set(), []
        for c in text:
            if c not in lookup:
                while stk and stk[-1] > c and count[stk[-1]]:
                    lookup.remove(stk.pop())
                stk += c
                lookup.add(c)
            count[c] -= 1
        return """".join(stk)",O(n)
"class Solution(object):
    def myAtoi(self, str):
        INT_MAX =  2147483647
        INT_MIN = -2147483648
        result = 0

        if not str:
            return result

        i = 0
        while i < len(str) and str[i].isspace():
            i += 1

        if len(str) == i:
            return result

        sign = 1
        if str[i] == ""+"":
            i += 1
        elif str[i] == ""-"":
            sign = -1
            i += 1

        while i < len(str) and '0' <= str[i] <= '9':
            if result > (INT_MAX - int(str[i])) / 10:
                return INT_MAX if sign > 0 else INT_MIN
            result = result * 10 + int(str[i])
            i += 1

        return sign * result",O(n)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(bonus=2*employees[""salary""])",O(n)
"import collections
import functools


class Solution(object):
    def minimumLengthEncoding(self, words):
        words = list(set(words))
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()

        nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]

        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)",O(n)
"class Solution(object):
    def carFleet(self, target, position, speed):
        times = [float(target-p)/s for p, s in sorted(zip(position, speed))]
        result, curr = 0, 0
        for t in reversed(times):
            if t > curr:
                result += 1
                curr = t
        return result",O(nlogn)
"import collections


class Solution(object):
    def countPoints(self, rings):
        bits = {'R':0b001, 'G':0b010, 'B':0b100}
        rods = collections.defaultdict(int)
        for i in range(0, len(rings), 2):
            rods[int(rings[i+1])] |= bits[rings[i]]
        return sum(x == 0b111 for x in rods.values())",O(n)
"class Solution(object):
    def findBottomLeftValue(self, root):
        def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):
            if not root:
                return max_depth, bottom_left_value
            if not root.left and not root.right and curr_depth+1 > max_depth:
                return curr_depth+1, root.val
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value)
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value)
            return max_depth, bottom_left_value

        result, max_depth = 0, 0
        return findBottomLeftValueHelper(root, 0, max_depth, result)[1]",O(n)
"import collections


class Solution2(object):
    def findBottomLeftValue(self, root):
        last_node, q = None, collections.deque([root])
        while q:
            last_node = q.popleft()
            q.extend([n for n in [last_node.right, last_node.left] if n])
        return last_node.val",O(n)
"import collections


class Solution(object):
    def brightestPosition(self, lights):
        count = collections.Counter()
        for i, r in lights:
            count[i-r] += 1
            count[i+r+1] -= 1
        result = None
        max_cnt = cnt = 0
        for i, c in sorted(count.items()):
            cnt += c
            if cnt > max_cnt:
                max_cnt, result = cnt, i
        return result",O(nlogn)
"import heapq



class Solution(object):
    def findMaxSum(self, nums1, nums2, k):
        result = [0]*len(nums1)
        min_heap = []
        idxs = list(range(len(nums1)))
        idxs.sort(key=lambda x: nums1[x])
        total = j = 0
        for i in range(len(idxs)):
            while nums1[idxs[j]] < nums1[idxs[i]]:
                total += nums2[idxs[j]]
                heapq.heappush(min_heap, nums2[idxs[j]])
                if len(min_heap) == k+1:
                    total -= heapq.heappop(min_heap)
                j += 1
            result[idxs[i]] = total            
        return result",O(nlogn)
"class Solution(object):
    def splitString(self, s):
        def backtracking(s, i, num, cnt):
            if i == len(s):
                return cnt >= 2
            new_num = 0
            for j in range(i, len(s)):
                new_num = new_num*10 + int(s[j])
                if new_num >= num >= 0:
                    break
                if (num == -1 or num-1 == new_num) and backtracking(s, j+1, new_num, cnt+1):
                    return True
            return False
            
        return backtracking(s, 0, -1, 0)",other
"class Solution(object):
    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):
        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefix = [0]*(len(NUMS)+1)
        for i in range(len(NUMS)):
            prefix[i+1] += prefix[i]+NUMS[i]
    
        def day(date):
            return prefix[int(date[:2])-1]+int(date[3:])

        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)",O(1)
"class Solution(object):
    def countPairs(self, nums, target):
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left < right:
            if nums[left]+nums[right] < target:
                result += right-left
                left += 1
            else:
                right -= 1
        return result",O(nlogn)
"class Solution(object):
    def checkPowersOfThree(self, n):
        while n > 0:
            if n%3 == 2:
                return False
            n //= 3
        return True",O(logn)
"class Solution(object):
    def maximumBinaryString(self, binary):
        result = list(binary)
        zeros = ones = 0
        for i, c in enumerate(result):
            if c == '0':
                zeros += 1
            elif zeros == 0:
                ones += 1
            result[i] = '1'
        if ones != len(result):
            result[zeros+ones-1] = '0'
        return """".join(result)",O(n)
"class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result",O(n)
"class Solution(object):

    def __init__(self):
        self.__s = []

    def next(self, price):
        result = 1
        while self.__s and self.__s[-1][0] <= price:
            result += self.__s.pop()[1]
        self.__s.append([price, result])
        return result",O(1)
"class Solution(object):
    def goodIndices(self, nums, k):
        left = [1]*len(nums)
        for i in range(1, len(nums)-1):
            if nums[i] <= nums[i-1]:
                left[i] = left[i-1]+1
        right = [1]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            if nums[i] <= nums[i+1]:
                right[i] = right[i+1]+1
        return [i for i in range(k, len(nums)-k) if min(left[i-1], right[i+1]) >= k]",O(n)
"class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result",O(n)
"class Solution(object):
    def smallestSubsequence(self, s, k, letter, repetition):
        stk = []
        suffix = [0]*(len(s)+1)
        for i in reversed(range(len(suffix)-1)):
            suffix[i] = suffix[i+1]+(s[i] == letter)
        for i, c in enumerate(s): 
            while stk and stk[-1] > c and len(stk)+(len(s)-i) > k and (stk[-1] != letter or repetition+1 <= suffix[i]):
                repetition += (stk.pop() == letter)
            if len(stk) < min(k-(repetition-(c == letter)), k):
                repetition -= (c == letter)
                stk.append(c)
        return """".join(stk)",O(n)
"class Solution(object):
    def magnificentSets(self, n, edges):
        def iter_dfs(u):
            group = []
            stk = [u]
            lookup[u] = 0
            while stk:
                u = stk.pop()
                group.append(u)
                for v in adj[u]:
                    if lookup[v] != -1:
                        if lookup[v] == lookup[u]: 
                            return []
                        continue
                    lookup[v] = lookup[u]^1
                    stk.append(v)
            return group

        def bfs(u):
            result = 0
            lookup = [False]*n
            q = [u]
            lookup[u] = True
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
                result += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        result = 0
        lookup = [-1]*n
        for u in range(n):
            if lookup[u] != -1:
                continue
            group = iter_dfs(u)
            if not group:
                return -1
            result += max(bfs(u) for u in group)
        return result",other
"class Solution2(object):
    def magnificentSets(self, n, edges):
        def bfs(u):
            group = []
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    group.append(u)
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
            return group
    
        def bfs2(u):
            result = 0
            lookup = [False]*n
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    for v in adj[u]:
                        if v in q:
                            return 0
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
                result += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        result = 0
        lookup = [0]*n
        for u in range(n):
            if lookup[u]:
                continue
            group = bfs(u)
            mx = 0
            for u in group:
                d = bfs2(u)
                if d == 0:
                    return -1
                mx = max(mx, d)
            result += mx
        return result",O(n ^ 2)
"import math


class Solution(object):
    def reachNumber(self, target):
        target = abs(target)
        k = int(math.ceil((-1+math.sqrt(1+8*target))/2))
        target -= k*(k+1)/2
        return k if target%2 == 0 else k+1+k%2",O(1)
"class Solution(object):
    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):
        return min(numOnes, k)-max(k-numOnes-numZeros, 0)",O(1)
"import collections


class Solution(object):
    def findFrequentTreeSum(self, root):
        def countSubtreeSumHelper(root, counts):
            if not root:
                return 0
            total = root.val + \
                    countSubtreeSumHelper(root.left, counts) + \
                    countSubtreeSumHelper(root.right, counts)
            counts[total] += 1
            return total

        counts = collections.defaultdict(int)
        countSubtreeSumHelper(root, counts)
        max_count = max(counts.values()) if counts else 0
        return [total for total, count in counts.items() if count == max_count]",O(n)
"class Solution(object):
    def generateTheString(self, n):
        result = ['a']*(n-1)
        result.append('a' if n%2 else 'b')
        return """".join(result)",O(n)
"class Solution(object):
    def checkZeroOnes(self, s):
        max_cnt = [0]*2
        cnt = 0
        for i in range(len(s)+1):
            if i == len(s) or (i >= 1 and s[i] != s[i-1]):
                max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt)
                cnt = 0
            cnt += 1
        return max_cnt[0] < max_cnt[1]",O(n)
"class Node(object):
    def __init__(self, value):
        self.val = value
        self.next = self.prev = None


class Solution(object):

    def __init__(self):
        self.__head = self.__tail = Node(-1)
        self.__head.next = self.__tail
        self.__tail.prev = self.__head
        self.__size = 0

    def get(self, index):
        if 0 <= index <= self.__size // 2:
            return self.__forward(0, index, self.__head.__next__).val
        elif self.__size // 2 < index < self.__size:
            return self.__backward(self.__size, index, self.__tail).val
        return -1

    def addAtHead(self, val):
        self.__add(self.__head, val)

    def addAtTail(self, val):
        self.__add(self.__tail.prev, val)

    def addAtIndex(self, index, val):
        if 0 <= index <= self.__size // 2:
            self.__add(self.__forward(0, index, self.__head.__next__).prev, val)
        elif self.__size // 2 < index <= self.__size:
            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)

    def deleteAtIndex(self, index):
        if 0 <= index <= self.__size // 2:
            self.__remove(self.__forward(0, index, self.__head.__next__))
        elif self.__size // 2 < index < self.__size:
            self.__remove(self.__backward(self.__size, index, self.__tail))

    def __add(self, preNode, val):
        node = Node(val)
        node.prev = preNode
        node.next = preNode.__next__
        node.prev.next = node.next.prev = node
        self.__size += 1
        
    def __remove(self, node):
        node.prev.next = node.__next__
        node.next.prev = node.prev
        self.__size -= 1
        
    def __forward(self, start, end, curr):
        while start != end:
            start += 1
            curr = curr.__next__
        return curr
    
    def __backward(self, start, end, curr):
        while start != end:
            start -= 1
            curr = curr.prev
        return curr",O(n)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def enQueue(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deQueue(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def Front(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def Rear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"class Solution(object):
    def captureForts(self, forts):
        result = left = 0
        for right in range(len(forts)):
            if not forts[right]:
                continue
            if forts[right] == -forts[left]:
                result = max(result, right-left-1)
            left = right
        return result",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def resultArray(self, nums):
        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            cnt1 = len(sl1)-sl1.bisect_right(nums[i])
            cnt2 = len(sl2)-sl2.bisect_right(nums[i])
            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):
                sl1.add(nums[i])
                a.append(nums[i])
            else:
                sl2.add(nums[i])
                b.append(nums[i])
        return a+b",O(nlogn)
"class Solution(object):
    def maxSubarrayLength(self, nums):
        stk = []
        for i in reversed(range(len(nums))):
            if not stk or nums[stk[-1]] > nums[i]:
                stk.append(i)
        result = 0
        for left in range(len(nums)):
            while stk and nums[stk[-1]] < nums[left]:
                result = max(result, stk.pop()-left+1)
        return result",O(n)
"class Solution2(object):
    def maxSubarrayLength(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x], reverse=True)
        result = 0
        for left in range(len(nums)):
            while idxs and nums[idxs[-1]] < nums[left]:
                result = max(result, idxs.pop()-left+1)
        return result",O(nlogn)
"class Solution(object):
    def isBalanced(self, num):
        return sum(ord(num[i])-ord('0') for i in range(0, len(num), 2)) == sum(ord(num[i])-ord('0') for i in range(1, len(num), 2))",O(n)
"class Solution(object):
    def minimumOperations(self, nums, target):
        for i in range(len(target)):
            target[i] -= nums[i]
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))",O(n)
"class Solution(object):
    def smallestRangeII(self, A, K):
        A.sort()
        result = A[-1]-A[0]
        for i in range(len(A)-1):
            result = min(result,
                         max(A[-1]-K, A[i]+K) -
                         min(A[0]+K, A[i+1]-K))
        return result",O(nlogn)
"import collections


class Solution(object):

    def __init__(self):
        _trie = lambda: collections.defaultdict(_trie)
        self.trie = _trie()


    def buildDict(self, dictionary):
        for word in dictionary:
            reduce(dict.__getitem__, word, self.trie).setdefault(""_end"")


    def search(self, word):
        def find(word, curr, i, mistakeAllowed):
            if i == len(word):
                return ""_end"" in curr and not mistakeAllowed

            if word[i] not in curr:
                return any(find(word, curr[c], i+1, False) for c in curr if c != ""_end"") \
                           if mistakeAllowed else False

            if mistakeAllowed:
                return find(word, curr[word[i]], i+1, True) or \
                       any(find(word, curr[c], i+1, False) \
                           for c in curr if c not in (""_end"", word[i]))
            return find(word, curr[word[i]], i+1, False)

        return find(word, self.trie, 0, True)",other
"class Solution(object):
    def peakIndexInMountainArray(self, arr):
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1]:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"class Solution(object):
    def minCost(self, s, cost):
        result = accu = max_cost = 0
        for i in range(len(s)):
            if i and s[i] != s[i-1]:
                result += accu-max_cost
                accu = max_cost = 0
            accu += cost[i]
            max_cost = max(max_cost, cost[i])
        result += accu-max_cost
        return result",O(n)
"class Solution(object):
    def numSpecial(self, mat):
        rows, cols = [0]*len(mat), [0]*len(mat[0])
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j] == rows[i] == cols[j] == 1:
                    result += 1
        return result",O(n ^ 2)
"class Solution(object):
    def colorRed(self, n):
        result = [[1, 1]]
        for i in range(2, n+1):
            if i%2 == n%2:
                result.extend([i, j] for j in range((1 if i%4 == n%4 else 3), 2*i, 2))
            else:
                result.append([i, (2 if i%4 == (n-1)%4 else 1)])
        return result",O(n ^ 2)
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        count = [0] * (n + 1)
        for x in citations:
            if x >= n:
                count[n] += 1
            else:
                count[x] += 1

        h = 0
        for i in reversed(range(0, n + 1)):
            h += count[i]
            if h >= i:
                return i
        return h",O(n)
"class Solution2(object):
    def hIndex(self, citations):
        citations.sort(reverse=True)
        h = 0
        for x in citations:
            if x >= h + 1:
                h += 1
            else:
                break
        return h",O(nlogn)
"class Solution3(object):
    def hIndex(self, citations):
        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))",O(nlogn)
"class Solution(object):
    def canBeValid(self, s, locked):
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(range(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal < 0:
                        return False
        return True",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructFromPrePost(self, pre, post):
        stack = [TreeNode(pre[0])]
        j = 0
        for i in range(1, len(pre)):
            node = TreeNode(pre[i])
            while stack[-1].val == post[j]:
                stack.pop()
                j += 1
            if not stack[-1].left:
                stack[-1].left = node
            else:
                stack[-1].right = node
            stack.append(node)
        return stack[0]",O(n)
"class Solution2(object):
    def constructFromPrePost(self, pre, post):
        def constructFromPrePostHelper(pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map):
            if pre_s >= pre_e or post_s >= post_e:
                return None
            node = TreeNode(pre[pre_s])
            if pre_e-pre_s > 1:
                left_tree_size = post_entry_idx_map[pre[pre_s+1]]-post_s+1
                node.left = constructFromPrePostHelper(pre, pre_s+1, pre_s+1+left_tree_size, 
                                                       post, post_s, post_s+left_tree_size,
                                                       post_entry_idx_map)
                node.right = constructFromPrePostHelper(pre, pre_s+1+left_tree_size, pre_e,
                                                        post, post_s+left_tree_size, post_e-1,
                                                        post_entry_idx_map)
            return node

        post_entry_idx_map = {}
        for i, val in enumerate(post):
            post_entry_idx_map[val] = i
        return constructFromPrePostHelper(pre, 0, len(pre), post, 0, len(post), post_entry_idx_map)",O(n)
"import itertools




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])



class Solution(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEFT] = result[RIGHT] = y
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            return result

        def query(x, y):
            return x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.tree[1][MAX_LEN])
        return result",O(nlogn)
"import itertools




class SegmentTree2(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return None
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution2(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            result[LEFT] = result[RIGHT] = y
            return result

        def query(x, y):
            return y if x is None else x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.query(0, len(s)-1)[MAX_LEN])
        return result",O(nlogn)
"class Solution(object):
    def numDifferentIntegers(self, word):
        result, num = set(), None
        for i in range(len(word)+1):
            c = word[i] if i < len(word) else ' '
            if c.isdigit():
                num = 10*num+int(c) if num is not None else int(c)
            elif num is not None:
                result.add(num)
                num = None
        return len(result)",O(n)
"class Solution(object):
    def hasAlternatingBits(self, n):
        n, curr = divmod(n, 2)
        while n > 0:
            if curr == n % 2:
                return False
            n, curr = divmod(n, 2)
        return True",O(1)
"class Solution(object):
    def PredictTheWinner(self, nums):
        if len(nums) % 2 == 0 or len(nums) == 1:
            return True

        dp = [0] * len(nums)
        for i in reversed(range(len(nums))):
            dp[i] = nums[i]
            for j in range(i+1, len(nums)):
                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])

        return dp[-1] >= 0",O(n ^ 2)
"class Solution(object):
    def isPreorder(self, nodes):
        stk = [nodes[0][0]]
        for i in range(1, len(nodes)):
            while stk and stk[-1] != nodes[i][1]:
                stk.pop()                
            if not stk:
                return False            
            stk.append(nodes[i][0])            
        return True",O(n)
"class Solution(object):
    def containsPattern(self, arr, m, k):
        cnt = 0
        for i in range(len(arr)-m):
            if arr[i] != arr[i+m]:
                cnt = 0
                continue
            cnt += 1
            if cnt == (k-1)*m:
                return True
        return False",O(n)
"class Solution(object):
    def numberOfCuts(self, n):
        return 0 if n == 1 else n if n%2 else n//2",O(1)
"import collections


class Solution(object):
    def checkEqualTree(self, root):
        def getSumHelper(node, lookup):
            if not node:
                return 0
            total = node.val + \
                    getSumHelper(node.left, lookup) + \
                    getSumHelper(node.right, lookup)
            lookup[total] += 1
            return total

        lookup = collections.defaultdict(int)
        total = getSumHelper(root, lookup)
        if total == 0:
            return lookup[total] > 1
        return total%2 == 0 and (total/2) in lookup",O(n)
"class Solution(object):
    def minProcessingTime(self, processorTime, tasks):
        K = 4
        processorTime.sort()
        tasks.sort(reverse=True)
        result = 0
        for i in range(len(processorTime)):
            for j in range(K):
                result = max(result, processorTime[i]+tasks[i*K+j])
        return result",O(nlogn)
"class Solution(object):
    def canBeTypedWords(self, text, brokenLetters):
        lookup = set(brokenLetters)
        result, broken = 0, False
        for c in text:
            if c == ' ':
                result += int(broken == False)
                broken = False
            elif c in lookup:
                broken = True
        return result + int(broken == False)",O(n)
"class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        n = len(grid)
        a_xor_b = 0
        for i in range(n**2):
            r, c = divmod(i, n)
            a_xor_b ^= grid[r][c]^(i+1)
        base = a_xor_b&-a_xor_b
        result = [0]*2
        for i in range(n**2):
            r, c = divmod(i, len(grid[0]))
            result[1 if (i+1)&base != 0 else 0] ^= i+1
            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]
        if any(x == result[1] for row in grid for x in row):
            result[0], result[1] = result[1], result[0]
        return result",O(n ^ 2)
"import collections



class Solution2(object):
    def findMissingAndRepeatedValues(self, grid):
        cnt = collections.Counter(x for row in grid for x in row)
        return [next(k for k, v in cnt.items() if v == 2), next(x for x in range(1, len(grid)**2+1) if x not in cnt)]",O(n ^ 2)
"import collections


class Solution(object):
    def reformat(self, s):
        def char_gen(start, end, count):
            for c in range(ord(start), ord(end)+1):
                c = chr(c)
                for i in range(count[c]):
                    yield c
            yield ''
    
        count = collections.defaultdict(int)
        alpha_cnt = 0
        for c in s:
            count[c] += 1
            if c.isalpha():
                alpha_cnt += 1
        if abs(len(s)-2*alpha_cnt) > 1:
            return """"

        result = []
        it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count)
        if alpha_cnt < len(s)-alpha_cnt:
            it1, it2 = it2, it1
        while len(result) < len(s):
            result.append(next(it1))
            result.append(next(it2))
        return """".join(result)",O(n)
"import collections


class Solution(object):
    def checkWays(self, pairs):
        adj = collections.defaultdict(set)
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
        n, mul = len(adj), False
        lookup = set()
        for node in sorted(iter(adj.keys()), key=lambda i: len(adj[i]), reverse=True):
            lookup.add(node)
            parent = 0
            for x in adj[node]:
                if x not in lookup:
                    continue
                if parent == 0 or len(adj[x]) < len(adj[parent]):
                    parent = x
            if parent:
                if any(True for x in adj[node] if x != parent and x not in adj[parent]):
                    return 0
                mul |= len(adj[parent]) == len(adj[node])
            elif len(adj[node]) != n-1:
                return 0
        return 1 + mul",O(nlogn)
"class Solution(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i, h in enumerate(heights):
            while stk and heights[stk[-1]] < h:
                result[stk.pop()] += 1
            if stk:
                result[stk[-1]] += 1
            if stk and heights[stk[-1]] == h:
                stk.pop()
            stk.append(i)
        return result",O(n)
"class Solution2(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i in reversed(range(len(heights))):
            cnt = 0
            while stk and heights[stk[-1]] < heights[i]:
                stk.pop()
                cnt += 1
            result[i] = cnt+1 if stk else cnt
            if stk and heights[stk[-1]] == heights[i]:
                stk.pop()
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def minimumPartition(self, s, k):
        result = 1
        curr = 0
        for c in s:
            if int(c) > k:
                return -1
            if curr*10+int(c) > k:
                result += 1
                curr = 0
            curr = curr*10+int(c)
        return result",O(n)
"class Solution(object):
    def hasTrailingZeros(self, nums):
        return sum(x%2 == 0 for x in nums) >= 2",O(n)
"class Solution(object):
    def removeCoveredIntervals(self, intervals):
        intervals.sort(key=lambda x: [x[0], -x[1]])
        result, max_right = 0, 0
        for left, right in intervals:
            result += int(right > max_right)
            max_right = max(max_right, right)
        return result",O(nlogn)
"class Solution(object):
    def guessNumber(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if guess(mid) <= 0:
                right = mid - 1
            else:
                left = mid + 1
        return left",O(logn)
"import pandas as pd



def Solution(products: pd.DataFrame) -> pd.DataFrame:
    products[""quantity""].fillna(0, inplace=True)
    return products",O(n)
"class Solution(object):
    def search(self, reader, target):
        left, right = 0, 19999
        while left <= right:
            mid = left + (right-left)//2
            response = reader.get(mid)
            if response > target:
                right = mid-1
            elif response < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"class Solution(object):
    def canChoose(self, groups, nums):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(start, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True",O(n)
"import itertools
from functools import reduce



class Solution(object):
    def getSneakyNumbers(self, nums):
        def f(check):
            return reduce(lambda accu, x: accu^x, (x for x in itertools.chain(nums, range(n)) if check(x)), 0)

        n = len(nums)-2
        x_xor_y = f(lambda _: True)
        bit = x_xor_y&-x_xor_y
        return [f(lambda x: x&bit == 0), f(lambda x: x&bit != 0)]",O(n)
"class Solution(object):
    def isPerfectSquare(self, num):
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) / 2
            if mid >= num / mid:
                right = mid - 1
            else:
                left = mid + 1
        return left == num / left and num % left == 0",O(logn)
"class Solution(object):
    def minimizeSum(self, nums):
        nums.sort()
        return min(nums[-3+i]-nums[i] for i in range(3))",O(nlogn)
"class Solution(object):
    def missingNumber(self, arr):
        def check(arr, d, x):
            return arr[x] != arr[0] + d*x

        d = (arr[-1]-arr[0])//len(arr)
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(arr, d, mid):
                right = mid-1
            else:
                left = mid+1
        return arr[0] + d*left",O(logn)
"class Solution2(object):
    def missingNumber(self, arr):
        return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr)",O(n)
"class Solution(object):
    def findMiddleIndex(self, nums):
        total = sum(nums)
        accu = 0
        for i, x in enumerate(nums):
            if accu*2 == total-x:
                return i
            accu += x
        return -1",O(n)
"
import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        return collections.Counter(target) == collections.Counter(arr)


",O(n)
"class Solution2(object):
    def canBeEqual(self, target, arr):
        target.sort(), arr.sort()
        return target == arr",O(nlogn)
"import collections


class Solution(object):

    def __init__(self):
        self.__q = collections.deque()

    def ping(self, t):
        self.__q.append(t)
        while self.__q[0] < t-3000:
            self.__q.popleft()
        return len(self.__q)",O(1)
"class Solution(object):
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left",O(logn)
"import collections


class Solution(object):
    def findLucky(self, arr):
        count = collections.Counter(arr)
        result = -1
        for k, v in count.items():
            if k == v:
                result = max(result, k)
        return result",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reorderList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            fast, slow, prev = fast.next.__next__, slow.__next__, slow
        current, prev.next, prev = slow, None, None

        while current != None:
            current.next, prev, current = prev, current, current.next

        l1, l2 = head, prev
        dummy = ListNode(0)
        current = dummy

        while l1 != None and l2 != None:
            current.next, current, l1 = l1, l1, l1.__next__
            current.next, current, l2 = l2, l2, l2.__next__

        return dummy.__next__",O(n)
"class Solution(object):
    def minOperations(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return popcount(n^(n*0b11))",O(logn)
"class Solution2(object):
    def minOperations(self, n):
        result = 0
        while n:
            if n&1:
                n >>= 1
                n += n&1
                result += 1
            n >>= 1
        return result",O(logn)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumSumSubarray(self, nums, l, r):
        INF = float(""inf"")
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = INF
        sl = SortedList()
        for i in range(len(nums)):
            if i-l+1 >= 0:
                sl.add(prefix[i-l+1])
            if i-r >= 0:
                sl.remove(prefix[i-r])
            idx = sl.bisect_left(prefix[i+1])-1
            if idx >= 0:
                result = min(result, prefix[i+1]-sl[idx])
        return result if result != INF else -1",O(nlogn)
"class Solution(object):
    def countAsterisks(self, s):
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result",O(n)
"class Solution(object):
    def countTriples(self, n):
        lookup = set()
        for i in range(1, n+1):
            lookup.add(i**2)
        result = 0
        for i in range(1, n+1):
            for j in range(1, n+1):
                result += int(i**2+j**2 in lookup)
        return result",O(n ^ 2)
"class Solution(object):
    def findPermutation(self, s):
        result = []
        for i in range(len(s)+1):
            if i == len(s) or s[i] == 'I':
                result += list(range(i+1, len(result), -1))
        return result",O(n)
"
import itertools



class Solution(object):
    def maxUpgrades(self, count, upgrade, sell, money):
        return [min(c+(m-c*u)//(u+s), c) for c, u, s, m in zip(count, upgrade, sell, money)]
",O(n)
"class Solution(object):
    def maxSatisfaction(self, satisfaction):
        satisfaction.sort(reverse=True)
        result, curr = 0, 0
        for x in satisfaction:
            curr += x
            if curr <= 0:
                break
            result += curr
        return result",O(nlogn)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"class Solution(object):
    def numSteps(self, s):
        result, carry = 0, 0
        for i in reversed(range(1, len(s))):
            if int(s[i]) + carry == 1:
                carry = 1 
                result += 2
            else:
                result += 1
        return result+carry",O(n)
"class Solution(object):
    def maxDistinctElements(self, nums, k):
        result = 0
        nums.sort()
        curr = float(""-inf"")
        for x in nums:
            if curr > x+k:
                continue
            curr = max(curr, x-k)+1
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)
            
    def dayOfYear(self, date):
        Y, M, D = list(map(int, date.split(""-"")))
        leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
        return self.__lookup[M-1]+D+leap",O(1)
"class Solution2(object):
    def dayOfYear(self, date):
        def numberOfDays(Y, M):
            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
            return (28+leap if (M == 2) else 31-(M-1)%7%2)

        Y, M, result = list(map(int, date.split(""-"")))
        for i in range(1, M):
            result += numberOfDays(Y, i)
        return result",O(1)
"class Solution(object):
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x: x[1])
        cnt, i = 0, 0
        for j in range(len(pairs)):
            if j == 0 or pairs[i][1] < pairs[j][0]:
                cnt += 1
                i = j
        return cnt",O(nlogn)
"import heapq
from functools import reduce


class Solution(object):
    def getNumberOfBacklogOrders(self, orders):
        MOD = 10**9 + 7
        buy, sell  = [], [] 
        for p, a, t in orders:
            if t == 0:
                heapq.heappush(buy, [-p, a])
            else:
                heapq.heappush(sell, [p, a])
            while sell and buy and sell[0][0] <= -buy[0][0]:
                k = min(buy[0][1], sell[0][1])
                tmp = heapq.heappop(buy)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(buy, tmp)
                tmp = heapq.heappop(sell)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(sell, tmp)
        return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell))",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def reverseOddLevels(self, root):
        q = [root]
        parity = 0
        while q:
            if parity:
                left, right = 0, len(q)-1
                while left < right:
                    q[left].val, q[right].val = q[right].val, q[left].val
                    left += 1
                    right -= 1
            if not q[0].left:
                break
            new_q = []
            for node in q:
                new_q.append(node.left)
                new_q.append(node.right)
            q = new_q       
            parity ^= 1
        return root",O(n)
"class Solution(object):
    def intToRoman(self, num):
        numeral_map = {1: ""I"", 4: ""IV"", 5: ""V"", 9: ""IX"", \
                       10: ""X"", 40: ""XL"", 50: ""L"", 90: ""XC"", \
                       100: ""C"", 400: ""CD"", 500: ""D"", 900: ""CM"", \
                       1000: ""M""}
        keyset, result = sorted(numeral_map.keys()), []

        while num > 0:
            for key in reversed(keyset):
                while num / key > 0:
                    num -= key
                    result += numeral_map[key]

        return """".join(result)",O(1)
"class Solution(object):
    def findIntegers(self, num):
        dp = [0] * 32
        dp[0], dp[1] = 1, 2
        for i in range(2, len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        result, prev_bit = 0, 0
        for i in reversed(range(31)):
            if (num & (1 << i)) != 0:
                result += dp[i]
                if prev_bit == 1:
                    result -= 1
                    break
                prev_bit = 1
            else:
                prev_bit = 0
        return result + 1",O(1)
"class Solution(object):
    def countArrays(self, original, bounds):
        left, right = bounds[0]
        result = right-left+1
        for i in range(1, len(original)):
            diff = original[i]-original[i-1]
            left = max(left+diff, bounds[i][0])
            right = min(right+diff, bounds[i][1])
            result = min(result, max(right-left+1, 0))
        return result",O(n)
"
import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):
        TARGET = ""balloon""
        source_count = collections.Counter(text)
        target_count = collections.Counter(TARGET)
        return min(source_count[c]//target_count[c] for c in target_count.keys())
",O(n)
"class Solution(object):
    def minimizeConcatenatedLength(self, words):
        dp = [[float(""-inf"")]*26 for _ in range(2)]
        dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0
        for i in range(1, len(words)):
            new_dp = [[float(""-inf"")]*26 for _ in range(2)]
            for right in range(2):
                for c in range(26):
                    if dp[right][c] == float(""-inf""):
                        continue
                    l = c if right else ord(words[i-1][0])-ord('a')
                    r = c if not right else ord(words[i-1][-1])-ord('a')
                    new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l))
                    new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a')))
            dp = new_dp
        return sum(len(w) for w in words)-max(dp[right][c] for right in range(2) for c in range(26))",O(n)
"class Solution(object):
    def largestGoodInteger(self, num):
        result = ''
        cnt = 0
        for i, x in enumerate(num):
            cnt += 1
            if i+1 < len(num) and num[i] == num[i+1]:
                continue
            if cnt >= 3:
                result = max(result, num[i])
            cnt = 0
        return result*3",O(n)
"class Solution2(object):
    def largestGoodInteger(self, num):
        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in range(len(num)-2))*3",O(n)
"class Solution(object):
    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0]+energyDrinkA[i], dp[1]), max(dp[1]+energyDrinkB[i], dp[0])]
        return max(dp)",O(n)
"import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):
        if len(nums) % 2:
            if nums[len(nums)//2] != target:
                return False
        else:
            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):
                return False

        left = bisect.bisect_left(nums, target)
        right= bisect.bisect_right(nums, target)
        return (right-left)*2 > len(nums)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)",O(n)
"class Solution(object):
    def maxFrequency(self, nums, k):
        left = 0
        nums.sort()
        for right in range(len(nums)):
            k += nums[right]
            if k < nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1",O(nlogn)
"import collections



class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicatesUnsorted(self, head):
        count = collections.defaultdict(int)
        curr = head
        while curr:
            count[curr.val] += 1
            curr = curr.__next__
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if count[curr.next.val] == 1:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"import abc 
from abc import ABCMeta, abstractmethod 


class Node(metaclass=ABCMeta):
    @abstractmethod
    def evaluate(self):
        pass


import operator


class Solution(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None
    
    def evaluate(self):
        result = [0]
        stk = [(1, (self, result))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                node, ret = args
                if node.val.isdigit():
                    ret[0] = int(node.val)
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = args
                ret[0] = Solution.ops[node.val](ret1[0], ret2[0])
        return result[0]


class TreeBuilder(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution(c))
            else:
                node = Solution(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)                
        return stk.pop()",O(n)
"class Solution2(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return Solution2.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution2(c))
            else:
                node = Solution2(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()",O(n)
"class Solution(object):
    def appealSum(self, s):
        result = curr = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)
            lookup[ord(c)-ord('a')] = i
        return result",O(n)
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"import collections



class Solution(object):
    def dividePlayers(self, skill):
        target = sum(skill)//(len(skill)//2)
        cnt = collections.Counter(skill)
        result = 0
        for k, v in cnt.items():
            if target-k not in cnt or cnt[target-k] != cnt[k]:
                return -1
            result += k*(target-k)*v
        return result//2",O(n)
"class Solution(object):
    def numberOfSubarrays(self, nums):
        result = 0
        stk = []
        for x in nums:
            while stk and stk[-1][0] < x:
                stk.pop()
            if not stk or stk[-1][0] != x:
                stk.append([x, 0])
            stk[-1][1] += 1
            result += stk[-1][1]
        return result",O(n)
"class Solution(object):
    def reverseStr(self, s, k):
        s = list(s)
        for i in range(0, len(s), 2*k):
            s[i:i+k] = reversed(s[i:i+k])
        return """".join(s)",O(n)
"class Solution(object):
    def countGoodStrings(self, low, high, zero, one):
        MOD = 10**9+7
        result = 0
        dp = [0]*(high+1)
        dp[0] = 1
        for i in range(1, high+1):
            if i >= zero:
                dp[i] = (dp[i]+dp[i-zero])%MOD
            if i >= one:
                dp[i] = (dp[i]+dp[i-one])%MOD
            if i >= low:
                result = (result+dp[i])%MOD
        return result",O(n)
"class Solution(object):
    def findClosest(self, x, y, z):
        return list(range(3))[cmp(abs(y-z), abs(x-z))]",O(1)
"class Solution(object):
    def sum(self, num1, num2):
        return num1+num2",O(1)
"
class Solution(object):
    def maxSubArray(self, nums):
        result, curr = float(""-inf""), float(""-inf"")
        for x in nums:
            curr = max(curr+x, x)
            result = max(result, curr)
        return result
",O(n)
"class Solution(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [-1]*26
        for right in range(len(s)):
            if lookup[ord(s[right])-ord('a')] >= left:
                left = lookup[ord(s[right])-ord('a')]+1
            lookup[ord(s[right])-ord('a')] = right
            result += (right-left+1)
        return result",O(n)
"class Solution2(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [False]*26
        for right in range(len(s)):
            while lookup[ord(s[right])-ord('a')]:
                lookup[ord(s[left])-ord('a')] = False
                left += 1
            lookup[ord(s[right])-ord('a')] = True
            result += (right-left+1)
        return result",O(n)
"class Solution(object):
    def secondGreaterElement(self, nums):
        result, stk1, stk2 = [-1]*len(nums), [], []
        for i, x in enumerate(nums):
            while stk2 and nums[stk2[-1]] < x:
                result[stk2.pop()] = x
            tmp = []
            while stk1 and nums[stk1[-1]] < x:
                tmp.append(stk1.pop())
            stk1.append(i)
            for x in reversed(tmp):
                stk2.append(x)
        return result",O(n)
"class Solution(object):
    def jump(self, A):
        jump_count = 0
        reachable = 0
        curr_reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                return -1
            if i > curr_reachable:
                curr_reachable = reachable
                jump_count += 1
            reachable = max(reachable, i + length)
        return jump_count",O(n)
"class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left, right = 1, x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x / mid:
                right = mid - 1
            else:
                left = mid + 1

        return left - 1",O(logn)
"class Solution(object):
    def checkTwoChessboards(self, coordinate1, coordinate2):
        def parity(a):
            return reduce(lambda accu, x: (accu+x)%2, (ord(x) for x in a), 0)
        
        return parity(coordinate1) == parity(coordinate2)",O(1)
"import heapq


class Solution(object):
    def getOrder(self, tasks):
        idx = list(range(len(tasks)))
        idx.sort(key=lambda x: tasks[x][0])
        result, min_heap = [], []
        i, time = 0, tasks[idx[0]][0]
        while i < len(idx) or min_heap:
            while i < len(idx) and tasks[idx[i]][0] <= time:
                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))
                i += 1
            if not min_heap:
                time = tasks[idx[i]][0]
                continue
            t, j = heapq.heappop(min_heap)
            time += t
            result.append(j)
        return result",O(nlogn)
"class Solution(object):
    def minOperations(self, logs):
        result = 0
        for log in logs:
            if log == ""../"":
                if result > 0:
                    result -= 1
            elif log != ""./"":
                result += 1
        return result",O(n)
"import collections



class Solution(object):
    def minLengthAfterRemovals(self, nums):
        mx = max(collections.Counter(nums).values())
        return mx-(len(nums)-mx) if mx > (len(nums)-mx) else len(nums)%2",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        current, carry = dummy, 0

        while l1 or l2:
            val = carry
            if l1:
                val += l1.val
                l1 = l1.__next__
            if l2:
                val += l2.val
                l2 = l2.__next__
            carry, val = divmod(val, 10)
            current.next = ListNode(val)
            current = current.__next__

        if carry == 1:
            current.next = ListNode(1)

        return dummy.__next__",O(n)
"class Solution(object):
    def removePalindromeSub(self, s):
        def is_palindrome(s):
            for i in range(len(s)//2):
                if s[i] != s[-1-i]:
                    return False
            return True
        
        return 2 - is_palindrome(s) - (s == """")",O(n)
"class Solution(object):
    def findCelebrity(self, n):
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i): 
                candidate = i       
        for i in range(n):
            candidate_knows_i = knows(candidate, i)
            i_knows_candidate = knows(i, candidate)
            if i != candidate and (candidate_knows_i or
                                   not i_knows_candidate):
                return -1
        return candidate",O(n)
"class Solution(object):
    def incremovableSubarrayCount(self, nums):
        for j in reversed(range(1, len(nums))):
            if not nums[j-1] < nums[j]:
                break
        else:
            return (len(nums)+1)*len(nums)//2
        result = len(nums)-j+1
        for i in range(len(nums)-1):
            while j < len(nums) and not (nums[i] < nums[j]):
                j += 1
            result += len(nums)-j+1
            if not (nums[i] < nums[i+1]):
                break
        return result",O(n)
"class Solution2(object):
    def incremovableSubarrayCount(self, nums):
        return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and
                   all(nums[i] < nums[i+1] for i in range(left-1)) and
                   all(nums[i] < nums[i+1] for i in range(right+1, len(nums)-1))
                   for left in range(len(nums)) for right in range(left, len(nums)))",O(n ^ 3)
"class Solution(object):
    def minimumDeletions(self, s):
        result = b_cnt = 0
        for c in s:
            if c == 'b':
                b_cnt += 1
            elif b_cnt:
                b_cnt -= 1
                result += 1
        return result",O(n)
"class Solution(object):
    def maximumSubsequenceCount(self, text, pattern):
        result = cnt1 = cnt2 = 0
        for c in text:
            if c == pattern[1]:
                result += cnt1
                cnt2 += 1
            if c == pattern[0]:
                cnt1 += 1
        return result + max(cnt1, cnt2)",O(n)
"import operator
import collections
from functools import reduce


class Solution(object):
    def findTheDifference(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s)), 0) ^ reduce(operator.xor, list(map(ord, t)), 0))

    def findTheDifference2(self, s, t):
        t = list(t)
        s = list(s)
        for i in s:
            t.remove(i)
        return t[0]

    def findTheDifference3(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s + t))))

    def findTheDifference4(self, s, t):
        return list((collections.Counter(t) - collections.Counter(s)))[0]

    def findTheDifference5(self, s, t):
        s, t = sorted(s), sorted(t)
        return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0]",O(n)
"class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0",O(n)
"class Solution(object):
    def prisonAfterNDays(self, cells, N):
        N -= max(N-1, 0) // 14 * 14 
        for i in range(N):
            cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1, 7)] + [0]
        return cells",O(1)
"class Solution2(object):
    def prisonAfterNDays(self, cells, N):
        cells = tuple(cells)
        lookup = {}
        while N:
            lookup[cells] = N
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
            if cells in lookup:
                assert(lookup[cells] - N in (1, 7, 14))
                N %= lookup[cells] - N
                break

        while N:
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
        return list(cells)",O(1)
"class Solution(object):
    def modifiedList(self, nums, head):
        lookup = set(nums)
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if curr.next.val not in lookup:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def depthSum(self, nestedList):
        def depthSumHelper(nestedList, depth):
            res = 0
            for l in nestedList:
                if l.isInteger():
                    res += l.getInteger() * depth
                else:
                    res += depthSumHelper(l.getList(), depth + 1)
            return res
        return depthSumHelper(nestedList, 1)",O(n)
"
import collections


class Solution(object):
    def subdomainVisits(self, cpdomains):
        result = collections.defaultdict(int)
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            frags = domain.split('.')
            curr = []
            for i in reversed(range(len(frags))):
                curr.append(frags[i])
                result[""."".join(reversed(curr))] += count

        return [""{} {}"".format(count, domain) \
                for domain, count in result.items()]

",O(n)
"class Solution(object):
    def mostPoints(self, questions):
        dp = [0]*(len(questions)+1)
        for i in reversed(range(len(dp)-1)):
            dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(dp) else 0))
        return dp[0]",O(n)
"class Solution(object):
    def licenseKeyFormatting(self, S, K):
        result = []
        for i in reversed(range(len(S))):
            if S[i] == '-':
                continue
            if len(result) % (K + 1) == K:
                result += '-'
            result += S[i].upper()
        return """".join(reversed(result))",O(n)
"class Solution(object):
    def validPartition(self, nums):
        dp = [False]*4
        dp[0] = True
        for i in range(len(nums)):
            dp[(i+1)%4] = False
            if i-1 >= 0 and nums[i] == nums[i-1]:
                dp[(i+1)%4] |= dp[((i+1)-2)%4]
            if i-2 >= 0 and (nums[i] == nums[i-1] == nums[i-2] or
                             nums[i] == nums[i-1]+1 == nums[i-2]+2):
                dp[(i+1)%4] |= dp[((i+1)-3)%4]
        return dp[len(nums)%4]",O(n)
"class Solution(object):
    def longestCommonPrefix(self, s, t):
        result = i = j = 0
        removed = False
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                result += 1
                i += 1
                j += 1
            elif not removed:
                removed = True
                i += 1
            else:
                break
        return result",O(n)
"class Solution(object):
    def pivotArray(self, nums, pivot):
        result = [pivot]*len(nums)
        left, right = 0, len(nums)-sum(x > pivot for x in nums)
        for x in nums:
            if x < pivot:
                result[left] = x
                left += 1
            elif x > pivot:
                result[right] = x
                right += 1
        return result",O(n)
"class Solution(object):
    def smallestSubarrays(self, nums):
        result = [0]*len(nums)
        lookup = [-1]*max(max(nums).bit_length(), 1)
        for i in reversed(range(len(nums))):
            for bit in range(len(lookup)):
                if nums[i]&(1<<bit):
                    lookup[bit] = i
            result[i] = max(max(lookup)-i+1, 1)
        return result",O(n)
"import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):
        parse = re.findall(r""([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)"", formula)
        stk = [collections.Counter()]
        for name, m1, left_open, right_open, m2 in parse:
            if name:
              stk[-1][name] += int(m1 or 1)
            if left_open:
              stk.append(collections.Counter())
            if right_open:
                top = stk.pop()
                for k, v in top.items():
                  stk[-1][k] += v * int(m2 or 1)

        return """".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \
                       for name in sorted(stk[-1]))",O(n)
"import collections


class Solution(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0, 0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                ret[:] = [0, int(hasApple[node])]
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0, 0]
                    s.append((2, (new_ret, ret)))
                    s.append((1, (node, nei, new_ret)))
            else:
                new_ret, ret = params
                ret[0] += new_ret[0]+new_ret[1]
                ret[1] |= bool(new_ret[0]+new_ret[1])
        return 2*result[0]",O(n)
"class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]",O(n)
"class Solution2(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                tmp = [int(hasApple[node])]
                s.append((3, (tmp, ret)))
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0]
                    s.append((2, (new_ret, tmp, ret)))
                    s.append((1, (node, nei, new_ret)))
            elif step == 2:
                new_ret, tmp, ret = params
                ret[0] += new_ret[0]
                tmp[0] |= bool(new_ret[0])
            else:
                tmp, ret = params
                ret[0] += tmp[0]
        return 2*max(result[0]-1, 0)",O(n)
"class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, has_subtree):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count = dfs(graph, node, nei, hasApple)
                result += count
                extra |= bool(count)
            return result+extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)",O(n)
"class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)",O(n)
"class Solution2(object):
    def numTrees(self, n):
        counts = [1, 1]
        for i in range(2, n + 1):
            count = 0
            for j in range(i):
                count += counts[j] * counts[i - j - 1]
            counts.append(count)
        return counts[-1]",O(n ^ 2)
"import heapq


class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):
        max_heap = []
        stations.append((target, float(""inf"")))

        result = prev = 0
        for location, capacity in stations:
            startFuel -= location - prev
            while max_heap and startFuel < 0:
                startFuel += -heapq.heappop(max_heap)
                result += 1
            if startFuel < 0:
                return -1
            heapq.heappush(max_heap, -capacity)
            prev = location

        return result",O(nlogn)
"import collections
import string

class Solution(object):
    def minDeletions(self, s):
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(range(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result",O(n)
"class Solution(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result += left
        return result",O(n)
"class Solution2(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = (len(nums)+1)*len(nums)//2
        left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result -= right-left+1
        return result",O(n)
"class Solution(object):
    def maximum69Number (self, num):
        curr, base, change = num, 3, 0
        while curr:
            if curr%10 == 6:
                change = base
            base *= 10
            curr //= 10
        return num+change",O(logn)
"class Solution2(object):
    def maximum69Number (self, num):
        return int(str(num).replace('6', '9', 1))",O(logn)
"class Solution(object):
    def findMinimumTime(self, strength, K):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"class Solution(object):
    def makeStringsEqual(self, s, target):
        return ('1' in s) == ('1' in target)",O(n)
"import collections


class Solution(object):
    def countStudents(self, students, sandwiches):
        count = collections.Counter(students)
        for i, s in enumerate(sandwiches):
            if not count[s]:
                break
            count[s] -= 1
        else:
            i = len(sandwiches)
        return len(sandwiches)-i",O(n)
"class Solution(object):
    def buttonWithLongestTime(self, events):
        return -max((events[i][1]-(events[i-1][1] if i-1 >= 0 else 0), -events[i][0])for i in range(len(events)))[1]",O(n)
"class Solution(object):
    def numberOfChild(self, n, k):
        q, r = divmod(k, n-1)
        return r if q&1 == 0 else (n-1)-r",O(1)
"class Solution2(object):
    def numberOfChild(self, n, k):
        r = k%(2*(n-1))
        return r if r <= n-1 else (n-1)-(r-(n-1))",O(1)
"class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]",O(1)
"import itertools


class Solution(object):
    def widestPairOfIndices(self, nums1, nums2):
        lookup = {0:-1}
        result = total = 0
        for i, (n1, n2) in enumerate(zip(nums1, nums2)):
            total += n1-n2
            if total not in lookup:
                lookup[total] = i
            result = max(result, i-lookup[total])
        return result",O(n)
"import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))",O(n)
"
import collections


class Solution(object):
    def deckRevealedIncreasing(self, deck):
        d = collections.deque()
        deck.sort(reverse=True)
        for i in deck:
            if d:
                d.appendleft(d.pop())
            d.appendleft(i)
        return list(d)
",O(n)
"class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result",O(n)
"import math


class Solution(object):
    def constructRectangle(self, area):
        w = int(math.sqrt(area))
        while area % w:
            w -= 1
        return [area // w, w]",other
"import collections


class Solution(object):
    def totalFruit(self, tree):
        count = collections.defaultdict(int)
        result, i = 0, 0
        for j, v in enumerate(tree):
            count[v] += 1
            while len(count) > 2:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            result = max(result, j-i+1)
        return result",O(n)
"class Solution(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            lookup = [False]*len(nums)
            result = len(nums)
            for i in range(len(nums)):
                if lookup[nums[i]]:
                    continue
                l = 0
                while not lookup[nums[i]]:
                    lookup[nums[i]] = True
                    l += 1
                    i = index(nums[i])
                result -= 1
                if l >= 2:
                    result += 2
            return result-2*int(nums[d*(len(nums)-1)] != 0)

        return min(min_moves(0), min_moves(1))",O(n)
"class Solution2(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            a = nums[:]
            result = 0
            for i in range(len(a)):
                l, has_zero = 1, (a[i] == 0)
                while index(a[i]) != i:
                    j = index(a[i])
                    a[i], a[j] = a[j], a[i]
                    l += 1
                    has_zero |= (a[i] == 0)
                if l >= 2:
                    result += l-1 if has_zero else l+1
            return result

        return min(min_moves(0), min_moves(1))",other
"import collections



class Solution(object):
    def equalDigitFrequency(self, s):
        MOD = 10**9+7
        D = 27
        lookup = set()
        for i in range(len(s)):
            cnt = collections.Counter()
            h = max_cnt = 0
            for j in range(i, len(s)):
                d = ord(s[j])-ord('0')+1
                h = (h*D+d)%MOD
                cnt[d] += 1
                max_cnt = max(max_cnt, cnt[d])
                if len(cnt)*max_cnt == j-i+1:
                    lookup.add(h)
        return len(lookup)",O(n ^ 2)
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",O(n)
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        def compare(i1, i2):
            return arr[i1]-arr[i2] if arr[i1] != arr[i2] else i1-i2

        idxs = [i for i in range(len(arr))]
        result, max_i = 0, 0
        for i, v in enumerate(sorted(idxs, cmp=compare)):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):
        w = [[c, 0, i] for i, c in enumerate(wells, 1)]
        p = [[c, i, j] for i, j, c in pipes]
        result = 0
        union_find = UnionFind(n+1)
        for c, x, y in sorted(w+p):
            if not union_find.union_set(x, y):
                continue
            result += c
            if union_find.count == 1:
                break
        return result",O(nlogn)
"import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True",O(n)
"class Solution2(object):
    def isAnagram(self, s, t):
        return collections.Counter(s) == collections.Counter(t)",O(n)
"class Solution3(object):
    def isAnagram(self, s, t):
        return sorted(s) == sorted(t)",O(nlogn)
"class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def preorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    result.append(curr.val)
                    node.right = curr
                    curr = curr.left
                else:
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"class Solution2(object):
    def preorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root.left, False))
                stack.append((root, True))
        return result",O(n)
"import itertools


class Solution(object):
    def climbStairs(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]",O(logn)
"class Solution2(object):
    def climbStairs(self, n):
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current,
        return current",O(n)
"class Solution(object):
    def minSkips(self, dist, speed, hoursBefore):
        def ceil(a, b):
            return (a+b-1)//b

        dp = [0]*((len(dist)-1)+1) 
        for i, d in enumerate(dist):
            for j in reversed(range(len(dp))):
                dp[j] = ceil(dp[j]+d, speed)*speed if i < len(dist)-1 else dp[j]+d
                if j-1 >= 0:
                    dp[j] = min(dp[j], dp[j-1]+d)
        target = hoursBefore*speed
        for i in range(len(dist)):
            if dp[i] <= target:
                return i
        return -1",O(n ^ 2)
"class Solution(object):
    def encode(self, num):
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return """".join(reversed(result))",O(logn)
"class Solution(object):
    def chalkReplacer(self, chalk, k):
        k %= sum(chalk)
        for i, x in enumerate(chalk):
            if k < x:
                return i
            k -= x
        return -1",O(n)
"class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        result = left = prev = 0
        for right in range(len(s)):
            if right-1 >= 0 and s[right-1] == s[right]:
                left, prev = prev, right
            result = max(result, right-left+1)
        return result",O(n)
"class Solution(object):
    def edgeScore(self, edges):
        score = [0]*len(edges)
        for u, v in enumerate(edges):
            score[v] += u
        return max(range(len(edges)), key=lambda x:score[x])",O(n)
"class Solution(object):
    def minMaxDifference(self, num):
        def f(dst):
            result = 0
            base = 1
            while base <= num:
                base *= 10
            base //= 10
            src = -1
            while base:
                d = num//base%10
                if src == -1 and d != dst:
                    src = d
                result += base*(dst if d == src else d)
                base //= 10
            return result
    
        return f(9)-f(0)",O(logn)
"
class Solution(object):
    def reverseWords(self, s):
        return ' '.join(reversed(s.split()))

",O(n)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(x < k for x in nums)
",O(n)
"class Solution(object):
    def maxScore(self, s):
        result, zeros, ones = 0, 0, 0
        for i in range(1, len(s)-1):
            if s[i] == '0':
                zeros += 1
            else:
                ones += 1
            result = max(result, zeros-ones)
        return result + ones + (s[0] == '0') + (s[-1] == '1')",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__",O(n)
"class Solution(object):
    def lastSubstring(self, s):
        left, right, l = 0, 1, 0
        while right+l < len(s):
            if s[left+l] == s[right+l]:
                l += 1
                continue
            if s[left+l] > s[right+l]:
                right += l+1
            else:
                left = max(right, left+l+1)
                right = left+1
            l = 0
        return s[left:]",O(n)
"import collections


class Solution2(object):
    def lastSubstring(self, s):
        count = collections.defaultdict(list)
        for i in range(len(s)):
            count[s[i]].append(i)

        max_c = max(count.keys())
        starts = {}
        for i in count[max_c]:
            starts[i] = i+1
        while len(starts)-1 > 0:
            lookup = set()
            next_count = collections.defaultdict(list)
            for start, end in starts.items():
                if end == len(s): 
                    lookup.add(start)
                    continue
                next_count[s[end]].append(start)				
                if end in starts: 
                    lookup.add(end)			
            next_starts = {}
            max_c = max(next_count.keys())
            for start in next_count[max_c]:
                if start not in lookup:
                    next_starts[start] = starts[start]+1
            starts = next_starts
        return s[next(iter(starts.keys())):]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current",O(n)
"import collections


class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        directions = [(-1, -1), (-1, 0), (-1, 1), \
                      ( 0, -1), ( 0, 1), \
                      ( 1, -1), ( 1, 0), ( 1, 1)]
        result = 0
        q = collections.deque([(0, 0)])
        while q:
            result += 1
            next_depth = collections.deque()
            while q:
                i, j = q.popleft()
                if 0 <= i < len(grid) and \
                   0 <= j < len(grid[0]) and \
                    not grid[i][j]:
                    grid[i][j] = 1
                    if i == len(grid)-1 and j == len(grid)-1:
                        return result
                    for d in directions:
                        next_depth.append((i+d[0], j+d[1]))
            q = next_depth
        return -1",O(n ^ 2)
"import collections


class Solution(object):
    def canPermutePalindrome(self, s):
        return sum(v % 2 for v in list(collections.Counter(s).values())) < 2",O(n)
"import collections


class Solution(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            q = [i for i in adj.keys() if i in result]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in result:
                            continue
                        result.add(v)
                        new_q.append(v)
                q = new_q
            adj = collections.defaultdict(list)
        return list(result)",O(nlogn)
"import collections


class Solution2(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            stk = [i for i in adj.keys() if i in result]
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in result:
                        continue
                    result.add(v)
                    stk.append(v)
            adj = collections.defaultdict(list)
        return list(result)",O(nlogn)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def reset(self, x):
        self.set[x] = x
        self.rank[x] = 0


class Solution3(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        uf = UnionFind(n)
        uf.union_set(0, firstPerson)
        group = set()
        for i, (x, y, _) in enumerate(meetings):
            group.add(x)
            group.add(y)
            uf.union_set(x, y)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            while group:
                x = group.pop()
                if uf.find_set(x) != uf.find_set(0):
                    uf.reset(x)
        return [i for i in range(n) if uf.find_set(i) == uf.find_set(0)]",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCousins(self, root, x, y):
        def dfs(root, x, depth, parent):
            if not root:
                return False
            if root.val == x:
                return True
            depth[0] += 1
            prev_parent, parent[0] = parent[0], root
            if dfs(root.left, x, depth, parent):
                return True
            parent[0] = root
            if dfs(root.right, x, depth, parent):
                return True
            parent[0] = prev_parent
            depth[0] -= 1
            return False
        
        depth_x, depth_y = [0], [0]
        parent_x, parent_y = [None], [None]
        return dfs(root, x, depth_x, parent_x) and \
               dfs(root, y, depth_y, parent_y) and \
               depth_x[0] == depth_y[0] and \
               parent_x[0] != parent_y[0]",O(n)
"import collections



class Solution(object):
    def minimumSeconds(self, nums):
        lookup = collections.defaultdict(int)
        dist = collections.defaultdict(int)
        for i in range(2*len(nums)):
            x = nums[i%len(nums)]
            dist[x] = max(dist[x], i-lookup[x])
            lookup[x] = i
        return min(dist.values())//2",O(n)
"class Solution(object):
    def minCut(self, s):
        lookup = [[False for j in range(len(s))] for i in range(len(s))]
        mincut = [len(s) - 1 - i for i in range(len(s) + 1)]

        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):
                    lookup[i][j] = True
                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)

        return mincut[0]",O(n ^ 2)
"import bisect


class Solution(object):
    def nextGreatestLetter(self, letters, target):
        i = bisect.bisect_right(letters, target)
        return letters[0] if i == len(letters) else letters[i]",O(logn)
"class Solution(object):
    def sumGame(self, num):
        cnt = total = 0
        for i in range(len(num)):
            if num[i] == '?':
                cnt += (-1 if i < len(num)//2 else 1)
            else:
                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9",O(n)
"import itertools


class Solution(object):
    def canConvert(self, str1, str2):
        if str1 == str2:
            return True
        lookup = {}
        for i, j in zip(str1, str2):
            if lookup.setdefault(i, j) != j:
                return False
        return len(set(str2)) < 26",O(n)
"class Solution(object):
    def findMinimumTime(self, strength):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        K = 1
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"class Solution(object):
    def removeAlmostEqualCharacters(self, word):
        result = 0
        for i in range(len(word)-1):
            if (i+1)+result >= len(word):
                break
            if abs(ord(word[(i+1)+result])-ord(word[i+result])) <= 1:
                result += 1
        return result",O(n)
"class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R) for r in range(R+1))",O(1)
"class Solution(object):
    def minimumSum(self, n, k):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(k//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)",O(1)
"class Solution(object):
    def reformatNumber(self, number):
        number = list(number)
        src_len = 0
        for c in number: 
            if c.isdigit():
                number[src_len] = c
                src_len += 1
        dst_len = src_len + (src_len-1)//3
        if dst_len > len(number): 
            number.extend([0]*(dst_len-len(number)))
        while dst_len < len(number):
            number.pop()
        curr = dst_len-1
        for l, i in enumerate(reversed(range(src_len)), (3-src_len%3)%3):
            if l and l%3 == 0: 
                number[curr] = '-'
                curr -= 1
            number[curr] = number[i]
            curr -= 1
        if dst_len >= 3 and number[dst_len-2] == '-': 
            number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3]            
        return """".join(number)",O(n)
"class Solution(object):
    def countUnivalSubtrees(self, root):
        [is_uni, count] = self.isUnivalSubtrees(root, 0)
        return count

    def isUnivalSubtrees(self, root, count):
        if not root:
            return [True, count]

        [left, count] = self.isUnivalSubtrees(root.left, count)
        [right, count] = self.isUnivalSubtrees(root.right, count)
        if self.isSame(root, root.left, left) and \
           self.isSame(root, root.right, right):
                count += 1
                return [True, count]

        return [False, count]

    def isSame(self, root, child, is_uni):
        return not child or (is_uni and root.val == child.val)",O(n)
"class Solution(object):
    def countBinarySubstrings(self, s):
        result, prev, curr = 0, 0, 1
        for i in range(1, len(s)):
            if s[i-1] != s[i]:
                result += min(prev, curr)
                prev, curr = curr, 1
            else:
                curr += 1
        result += min(prev, curr)
        return result",O(n)
"class Solution(object):
    def minimizeArrayValue(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = curr = 0
        for i, x in enumerate(nums):
            curr += x
            result = max(result, ceil_divide(curr, i+1))
        return result",O(n)
"class Solution(object):
    def badSensor(self, sensor1, sensor2):
        for i in range(len(sensor1)-1):
            if sensor1[i] == sensor2[i]:
                continue
            while i+1 < len(sensor2) and sensor2[i+1] == sensor1[i]:
                i += 1
            return 1 if i+1 == len(sensor2) else 2
        return -1",O(n)
"import collections



class Solution(object):
    def finalString(self, s):
        dq = collections.deque()
        parity = 0
        for x in s:
            if x == 'i':
                parity ^= 1
            else:
                dq.appendleft(x) if parity else dq.append(x)
        if parity:
            dq.reverse()
        return """".join(dq)",O(n)
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = False
        self.__cv = threading.Condition()

    def foo(self, printFoo):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != False:
                    self.__cv.wait()
                self.__curr = not self.__curr
                printFoo()
                self.__cv.notify()

    def bar(self, printBar):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != True:
                        self.__cv.wait()
                self.__curr = not self.__curr
                printBar()
                self.__cv.notify()
",O(n)
"import collections




class Solution(object):
    def countTriplets(self, A):
        def FWT(A, v):
            B = A[:]
            d = 1
            while d < len(B):
                for i in range(0, len(B), d << 1):
                    for j in range(d):
                        B[i+j] += B[i+j+d] * v
                d <<= 1
            return B

        k = 3
        n, max_A = 1, max(A)
        while n <= max_A:
            n *= 2
        count = collections.Counter(A)
        B = [count[i] for i in range(n)]
        C = FWT([x**k for x in FWT(B, 1)], -1)
        return C[0]",O(nlogn)
"import collections


class Solution2(object):
    def countTriplets(self, A):
        count = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(len(A)):
                count[A[i]&A[j]] += 1
        result = 0
        for k in range(len(A)):
            for v in count:
                if A[k]&v == 0:
                    result += count[v]
        return result",O(n ^ 3)
"class Solution(object):
    def minOperations(self, nums, k):
        lookup = [False]*k
        for i in reversed(range(len(nums))):
            if nums[i] > len(lookup) or lookup[nums[i]-1]:
                continue
            lookup[nums[i]-1] = True
            k -= 1
            if not k:
                break
        return len(nums)-i",O(n)
"class Solution(object):
    def minRemoveToMakeValid(self, s):
        result = list(s)
        count = 0
        for i, v in enumerate(result):
            if v == '(':
                count += 1
            elif v == ')':
                if count:
                    count -= 1
                else:
                    result[i] = """"
        if count:
            for i in reversed(range(len(result))):
                if result[i] == '(':
                    result[i] = """"
                    count -= 1
                    if not count:
                        break
        return """".join(result)",O(n)
"class Solution(object):
    def circularGameLosers(self, n, k):
        lookup = [False]*n
        idx = 0
        for i in range(n):
            if lookup[idx]:
                break
            lookup[idx] = True
            idx = (idx+(i+1)*k)%n
        return [i+1 for i in range(n) if not lookup[i]]",O(n)
"class Solution(object):
    def maxOperations(self, nums):
        result = 1
        target = nums[0]+nums[1]
        for i in range(2, len(nums)-1, 2):
            if nums[i]+nums[i+1] != target:
                break
            result += 1
        return result",O(n)
"class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0",O(n ^ 2)
"class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \
                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):
                flowerbed[i] = 1
                n -= 1
            if n <= 0:
                return True
        return False",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumOperations(self, root):
        result = 0
        q = [root]
        while q:
            new_q = []
            for node in q:
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            idx = list(range(len(q)))
            idx.sort(key=lambda x: q[x].val)
            for i in range(len(q)):
                while idx[i] != i:
                    idx[idx[i]], idx[i] = idx[i], idx[idx[i]]
                    result += 1
            q = new_q
        return result",O(nlogn)
"class Solution(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [price[0], 0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, ret, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [price[v], 0] 
                    stk.append((3, (u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, new_ret, ret = args
                    result = max(result, ret[0]+new_ret[1], ret[1]+new_ret[0])
                    ret[0] = max(ret[0], new_ret[0]+price[u])
                    ret[1] = max(ret[1], new_ret[1]+price[u])
            return result
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution2(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp = [price[u], 0] 
            for v in adj[u]:
                if v == p:
                    continue
                new_dp = dfs(v, u)
                result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0])
                dp[0] = max(dp[0], new_dp[0]+price[u])
                dp[1] = max(dp[1], new_dp[1]+price[u])
            return dp
        
        result = [0]
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        return result[0]",O(n)
"class Solution3(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            dp = [0]*n 
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    dp[u] = price[u]
                    for v in adj[u]:
                        if v == p:
                            continue
                        dp[u] = max(dp[u], dp[v]+price[u])
            return dp
        
        def iter_dfs2():
            result = 0
            stk = [(0, -1, 0)]
            while stk:
                u, p, curr = stk.pop()
                result = max(result, curr, dp[u]-price[u])
                top2 = [[curr, p], [0, -1]]
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = [dp[v], v]
                    for i in range(len(top2)):
                        if curr > top2[i]:
                            top2[i], curr = curr, top2[i]
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs()
        return iter_dfs2()",O(n)
"class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]",O(n)
"import collections


class Solution(object):
    def longestPalindrome(self, words):
        cnt = collections.Counter(words)
        result = remain = 0
        for x, c in cnt.items():
            if x == x[::-1]:
                result += c//2
                remain |= c%2
            elif x < x[::-1] and x[::-1] in cnt:
                result += min(c, cnt[x[::-1]])
        return result*4+remain*2",O(n)
"class Solution(object):
    def maximumImportance(self, n, roads):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        inplace_counting_sort(degree)
        return sum(i*x for i, x in enumerate(degree, 1))",O(n)
"class Solution2(object):
    def maximumImportance(self, n, roads):
        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        degree.sort()
        return sum(i*x for i, x in enumerate(degree, 1))",O(nlogn)
"class Solution(object):
    def getFactors(self, n):
        result = []
        factors = []
        self.getResult(n, result, factors)
        return result

    def getResult(self, n, result, factors):
        i = 2 if not factors else factors[-1]
        while i <= n / i:
            if n % i == 0:
                factors.append(i)
                factors.append(n / i)
                result.append(list(factors))
                factors.pop()
                self.getResult(n / i, result, factors)
                factors.pop()
            i += 1",other
"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        result, left = 0, 0
        lookup = {}
        for right in range(len(s)):
            if s[right] in lookup:
                left = max(left, lookup[s[right]]+1)
            lookup[s[right]] = right
            result = max(result, right-left+1)
        return result",O(n)
"class Solution(object):
    def smallestEqual(self, nums):
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)",O(n)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def encode(self, root):
        def encodeHelper(root, parent, index):
            if not root:
                return None
            node = TreeNode(root.val)
            if index+1 < len(parent.children):
                node.left = encodeHelper(parent.children[index+1], parent, index+1)
            if root.children:
                node.right = encodeHelper(root.children[0], root, 0)
            return node

        if not root:
            return None
        node = TreeNode(root.val)
        if root.children:
            node.right = encodeHelper(root.children[0], root, 0)
        return node

    def decode(self, data):
        def decodeHelper(root, parent):
            if not root:
                return
            children = []
            node = Node(root.val, children)
            decodeHelper(root.right, node)
            parent.children.append(node)
            decodeHelper(root.left, parent)

        if not data:
            return None
        children = []
        node = Node(data.val, children)
        decodeHelper(data.right, node)
        return node",O(n)
"class Solution(object):
    def minimumScore(self, s, t):
        right = [-1]*len(s) 
        j = len(t)-1
        for i in reversed(range(len(s))):
            if j >= 0 and t[j] == s[i]:
                j -= 1
            right[i] = j
        result = j+1
        left = 0 
        for i in range(len(s)):
            result = max(min(result, right[i]-left+1), 0)
            if left < len(t) and t[left] == s[i]:
                left += 1
        result = min(result, len(t)-left)
        return result",O(n)
"class Solution(object):
    def constructGridLayout(self, n, edges):
        def bfs(u):
            dist = [0]*n
            dist[u] = 1
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        mn = min(len(x) for x in adj)
        corners = [u for u in range(n) if len(adj[u]) == mn]
        dist1 = bfs(corners[0])
        corners.sort(key=lambda x: dist1[x])
        dist2 = bfs(corners[1])
        c = dist1[corners[1]]
        r = n//c
        result = [[0]*c for _ in range(r)]
        for u in range(n):
            i = ((dist1[u]+dist2[u])-(1+c))//2
            j = (dist1[u]-1)-i
            result[i][j] = u
        return result",O(n)
"import collections


class Solution(object):
    def numIdenticalPairs(self, nums):
        return sum(c*(c-1)//2 for c in collections.Counter(nums).values())",O(n)
"class Solution(object):
    def longestNiceSubarray(self, nums):
        result = left = curr = 0
        for right in range(len(nums)):
            while curr&nums[right]:
                curr ^= nums[left]
                left += 1
            curr |= nums[right]
            result = max(result, right-left+1)
        return result",O(n)
"import math


class Solution(object):
    def getPermutation(self, n, k):
        seq, k, fact = """", k - 1, math.factorial(n - 1)
        perm = [i for i in range(1, n + 1)]
        for i in reversed(range(n)):
            curr = perm[k / fact]
            seq += str(curr)
            perm.remove(curr)
            if i > 0:
                k %= fact
                fact /= i
        return seq",O(n ^ 2)
"class Solution(object):
    def findRelativeRanks(self, nums):
        sorted_nums = sorted(nums)[::-1]
        ranks = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""] + list(map(str, list(range(4, len(nums) + 1))))
        return list(map(dict(list(zip(sorted_nums, ranks))).get, nums))",O(nlogn)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.astype({""grade"" : int})
",O(n)
"class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result",O(nlogn)
"from collections import Counter
from heapq import heapify, heappop


class Solution(object):
    def isNStraightHand(self, hand, W):
        if len(hand) % W:
            return False

        counts = Counter(hand)
        min_heap = list(hand)
        heapify(min_heap)
        for _ in range(len(min_heap)//W):
            while counts[min_heap[0]] == 0:
                heappop(min_heap)
            start = heappop(min_heap)
            for _ in range(W):
                counts[start] -= 1
                if counts[start] < 0:
                    return False
                start += 1
        return True",O(nlogn)
"class Solution(object):
    def minBitFlips(self, start, goal):
        return bin(start^goal).count('1')",O(logn)
"from collections import Counter


class Solution(object):
    def leastInterval(self, tasks, n):
        counter = Counter(tasks)
        _, max_count = counter.most_common(1)[0]
        return max((max_count-1) * (n+1) + list(counter.values()).count(max_count), len(tasks))",O(n)
"import collections



class Solution(object):
    def countGood(self, nums, k):
        result = curr = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            curr += cnt[nums[right]]
            cnt[nums[right]] += 1
            while curr >= k:
                cnt[nums[left]] -= 1
                curr -= cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"class Solution(object):
    def maximumEnergy(self, energy, k):
        result = float(""-inf"")
        for i in range(k):
            curr = 0
            for j in reversed(range(((len(energy)-i)-1)%k, len(energy)-i, k)): 
                curr += energy[j]
                result = max(result, curr)
        return result",O(n)
"

class Solution(object):
    def buyChoco(self, prices, money):
        i = min(range(len(prices)), key=lambda x: prices[x])
        j = min((j for j in range(len(prices)) if j != i), key=lambda x: prices[x])
        return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money
",O(n)
"class Solution(object):
    def searchRange(self, nums, target):
        def binarySearch(n, check): 
            left, right = 0, n-1 
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left 

        def binarySearch2(n, check): 
            left, right = 0, n 
            while left < right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid+1
            return left 

        def binarySearch3(n, check): 
            left, right = -1, n-1 
            while left < right:
                mid = right - (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid
            return left+1 

        def binarySearch4(n, check): 
            left, right = -1, n 
            while right-left >= 2:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid
            return left+1 

        left = binarySearch(len(nums), lambda i: nums[i] >= target)
        if left == len(nums) or nums[left] != target:
            return [-1, -1]
        right = binarySearch(len(nums), lambda i: nums[i] > target)
        return [left, right-1]",O(logn)
"class Solution(object):
    def countVowels(self, word):
        VOWELS = set(""aeiou"")
        return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS)",O(n)
"class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):
        def KMP(text, pattern):
            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix
    
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        if sentence.startswith(searchWord):
            return 1
        p = KMP(sentence, ' ' + searchWord)
        if p == -1:
            return -1
        return 1+sum(sentence[i] == ' ' for i in range(p+1))",O(n)
"class Solution(object):
    def prefixesDivBy5(self, A):
        for i in range(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]",O(n)
"import collections
import fractions


class Solution(object):
    def interchangeableRectangles(self, rectangles):
        count = collections.defaultdict(int)
        for w, h in rectangles:
            g = fractions.gcd(w, h) 
            count[(w//g, h//g)] += 1
        return sum(c*(c-1)//2 for c in count.values())",O(n)
"class Solution(object):
    def countMatches(self, items, ruleKey, ruleValue):
        rule = {""type"":0, ""color"":1, ""name"":2}
        return sum(item[rule[ruleKey]] == ruleValue for item in items)",O(n)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]",O(n)
"class Solution(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total-1 

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len({c for c in centers.keys() if c != '0'})
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if i != 0 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += 0 < int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)",O(logn)
"class Solution2(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len(centers)
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if len(s) != 2 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def f(n): 
            return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)

        return f(n) - f(0)",O(logn)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors, k):
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"import collections



class Solution(object):
    def robotWithString(self, s):
        cnt = collections.Counter(s)
        result, stk = [], []
        mn = 'a'
        for c in s:
            stk.append(c)
            cnt[c] -= 1
            while mn < 'z' and cnt[mn] == 0:
                mn = chr(ord(mn)+1)
            while stk and stk[-1] <= mn:
                result.append(stk.pop())
        return """".join(result)",O(n)
"class Solution(object):
    def nextClosestTime(self, time):
        h, m = time.split("":"")
        curr = int(h) * 60 + int(m)
        result = None
        for i in range(curr+1, curr+1441):
            t = i % 1440
            h, m = t // 60, t % 60
            result = ""%02d:%02d"" % (h, m)
            if set(result) <= set(time):
                break
        return result",O(1)
"import collections



class Solution(object):
    def minimumRounds(self, tasks):
        cnt = collections.Counter(tasks)
        return sum((x+2)//3 for x in cnt.values()) if 1 not in iter(cnt.values()) else -1",O(n)
"class Solution(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3))",O(1)
"class Solution2(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        if q > children:
            return children-1
        if q == children:
            return q-int(r != 0)
        if q == children-1:
            return q-int(r == 3)
        return q",O(1)
"import math


class Solution(object):
    def arrangeCoins(self, n):
        return int((math.sqrt(8*n+1)-1) / 2)",O(1)
"class Solution2(object):
    def arrangeCoins(self, n):
        def check(mid, n):
            return mid*(mid+1) <= 2*n

        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid, n):
                right = mid-1
            else:
                left = mid+1
        return right",O(logn)
"class Solution(object):
    def widthOfBinaryTree(self, root):
        def dfs(node, i, depth, leftmosts):
            if not node:
                return 0
            if depth >= len(leftmosts):
                leftmosts.append(i)
            return max(i-leftmosts[depth]+1, \
                       dfs(node.left, i*2, depth+1, leftmosts), \
                       dfs(node.right, i*2+1, depth+1, leftmosts))

        leftmosts = []
        return dfs(root, 1, 0, leftmosts)",O(n)
"class Solution(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def iter_dfs(u):
            cnt = 0
            curr = []
            lookup = [None]*len(adj)
            stk = [(1, (0,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u = args[0]
                    stk.append((2, (u, cnt)))
                    for v in reversed(adj[u]):
                        stk.append((1, (v,)))
                elif step == 2:
                    u, left = args
                    curr.append(s[u])
                    lookup[u] = (left, cnt)
                    cnt += 1
            return curr, lookup

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        curr, lookup = iter_dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]",O(n)
"class Solution2(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def dfs(u):
            left = cnt[0]
            for v in adj[u]:
                dfs(v)
            curr.append(s[u])
            lookup[u] = (left, cnt[0])
            cnt[0] += 1

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        cnt = [0]
        curr = []
        lookup = [None]*len(adj)
        dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]",O(n)
"import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Solution(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num < num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Solution.P_DENOMINATOR) <= Solution.P_NUMERATOR and \
              level < Solution.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])",O(logn)
"import collections


class Solution(object):
    def numberOfBoomerangs(self, points):
        result = 0

        for i in range(len(points)):
            group = collections.defaultdict(int)
            for j in range(len(points)):
                if j == i:
                    continue
                dx, dy =  points[i][0] - points[j][0], points[i][1] - points[j][1]
                group[dx**2 + dy**2] += 1

            for _, v in group.items():
                if v > 1:
                    result += v * (v-1)

        return result

    def numberOfBoomerangs2(self, points):
        cnt = 0
        for a, i in enumerate(points):
            dis_list = []
            for b, k in enumerate(points[:a] + points[a + 1:]):
                dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)
            for z in list(collections.Counter(dis_list).values()):
                if z > 1:
                    cnt += z * (z - 1)
        return cnt",O(n ^ 2)
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i < j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)",O(n)
"import collections


class Solution(object):
    def shortestCompletingWord(self, licensePlate, words):
        def contains(counter1, w2):
            c2 = collections.Counter(w2.lower())
            c2.subtract(counter1)
            return all([x >= 0 for x in list(c2.values())])

        result = None
        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())
        for word in words:
            if (result is None or (len(word) < len(result))) and \
               contains(counter, word):
                result = word
        return result",O(n)
"class Solution(object):
    def coloredCells(self, n):
        return n**2+(n-1)**2",O(1)
"class Solution2(object):
    def coloredCells(self, n):
        return (1+(1+2*(n-1)))*n//2*2-(2*n-1)",O(1)
"import collections



class Solution(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter()
        for x in nums:
            if cnt[x] == len(result):
                result.append([])
            result[cnt[x]].append(x)
            cnt[x] += 1
        return result",O(n)
"import collections



class Solution2(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter(nums)
        while cnt:
            result.append(list(cnt.keys()))
            cnt = {k:v-1 for k, v in cnt.items() if v-1}
        return result",O(n)
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        def intersect(p_left, p_right, q_left, q_right):
            return max(p_left, q_left) < min(p_right, q_right)

        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and
                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))",O(1)
"class Solution(object):
    def minimumSwap(self, s1, s2):
        x1, y1 = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2: 
            return -1
        return (x1//2 + y1//2) + (x1%2 + y1%2)",O(n)
"class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        return max((l**2+w**2, l*w) for l, w in dimensions)[1]",O(n)
"class Solution(object):
    def countSteppingNumbers(self, low, high):
        MOD = 10**9+7
        def f(s):
            dp = [[0]*10 for _ in range(2)]
            for j in range(1, ord(s[0])-ord('0')+1):
                dp[0][j] = 1
            prefix = True
            for i in range(1, len(s)):
                for j in range(10):
                    dp[i%2][j] = int(j != 0)
                    if j-1 >= 0:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD
                    if j+1 < 10:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD
                if abs(ord(s[i])-ord(s[i-1])) != 1:
                    prefix = False
            return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2])

        return (f(high)-f(str(int(low)-1)))%MOD",O(n)
"class Solution(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        buckets = [[] for _ in range(len(nums)+1)]
        for i, count in counts.items():
            buckets[count].append(i)

        result = []
        for i in reversed(range(len(buckets))):
            for j in range(len(buckets[i])):
                result.append(buckets[i][j])
                if len(result) == k:
                    return result
        return result",O(n)
"class Solution2(object):
    def fallingSquares(self, positions):
        index = set()
        for left, size in positions:
            index.add(left)
            index.add(left+size-1)
        index = sorted(list(index))
        tree = SegmentTree(len(index), max, max, 0)
        max_height = 0
        result = []
        for left, size in positions:
            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)
            h = tree.query(L, R) + size
            tree.update(L, R, h)
            max_height = max(max_height, h)
            result.append(max_height)
        return result",O(nlogn)
"class Solution4(object):
    def fallingSquares(self, positions):
        heights = [0] * len(positions)
        for i in range(len(positions)):
            left_i, size_i = positions[i]
            right_i = left_i + size_i
            heights[i] += size_i
            for j in range(i+1, len(positions)):
                left_j, size_j = positions[j]
                right_j = left_j + size_j
                if left_j < right_i and left_i < right_j: 
                    heights[j] = max(heights[j], heights[i])

        result = []
        for height in heights:
            result.append(max(result[-1], height) if result else height)
        return result",O(n ^ 2)
"class Solution(object):
    def longestPath(self, parent, s):
        def topological_sort(s, adj, in_degree):
            result = 1
            top2 = collections.defaultdict(lambda:[0]*2)
            q =  [(i, 1) for i, d in enumerate(in_degree) if not d]
            while q:
                new_q = []
                for (u, l) in q:
                    for v in adj[u]:
                        if s[v] != s[u]:
                            if l > top2[v][0]:
                                top2[v][0], top2[v][1] = l, top2[v][0]
                            elif l > top2[v][1]:
                                top2[v][1] = l
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append((v, top2[v][0]+1))
                        result = max(result, top2[v][0]+top2[v][1]+1)
                        del top2[v]
                q = new_q
            return result

        adj = [[] for _ in range(len(s))]
        in_degree = [0]*len(s)
        for i in range(1, len(parent)):
            adj[i].append(parent[i])
            in_degree[parent[i]] += 1
        return topological_sort(s, adj, in_degree)",O(n)
"class Solution2(object):
    def longestPath(self, parent, s):
        def iter_dfs(s, adj):
            result = 0
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, ret = args
                    top2 = [0]*2
                    stk.append((4, (top2, ret)))
                    stk.append((2, (u, 0, top2, ret)))
                elif step == 2:
                    u, i, top2, ret = args
                    if i == len(adj[u]):
                        continue
                    ret2 = [0]
                    stk.append((3, (u, i, top2, ret2)))
                    stk.append((1, (adj[u][i], ret2))) 
                elif step == 3:
                    u, i, top2, ret2 = args
                    if s[adj[u][i]] != s[u]:
                        if ret2[0] > top2[0]:
                            top2[0], top2[1] = ret2[0], top2[0]
                        elif ret2[0] > top2[1]:
                            top2[1] = ret2[0]
                    stk.append((2, (u, i+1, top2, ret)))
                elif step == 4:
                    top2, ret = args
                    result = max(result, top2[0]+top2[1]+1)
                    ret[0] = top2[0]+1
            return result
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        return iter_dfs(s, adj)",O(n)
"class Solution3(object):
    def longestPath(self, parent, s):
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l > top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l > top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]",O(n)
"class Solution(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        dp = {}
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            stk = []
            while x not in dp and x in cnt and cnt[x] >= 2:
                stk.append(x)
                x *= x
            if x not in dp:
                if x not in cnt:
                    x = stk.pop()
                dp[x] = 1
            l = dp[x]
            while stk:
                l += 2
                dp[stk.pop()] = l
            result = max(result, l)
        return result 
    
    
import collections",O(n)
"class Solution2(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            l = 0
            while x in cnt and cnt[x] >= 2:
                l += 2
                x *= x
            l += 1 if x in cnt else -1
            result = max(result, l)
        return result",O(n)
"class Solution(object):
    def singleNumber(self, A):
        one, two = 0, 0
        for x in A:
            one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one)
        return one",O(n)
"class Solution2(object):
    def singleNumber(self, A):
        one, two, carry = 0, 0, 0
        for x in A:
            two |= one & x
            one ^= x
            carry = one & two
            one &= ~carry
            two &= ~carry
        return one",O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return list((collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys())[0]",O(n)
"class Solution4(object):
    def singleNumber(self, nums):
        return (sum(set(nums)) * 3 - sum(nums)) / 2",O(n)
"class Solution5(object):
    def singleNumber(self, A):
        one, two, three = 0, 0, 0
        for x in A:
            one, two, three = (~x & one) | (x & ~one & ~two & ~three), (~x & two) | (x & one), (~x & three) | (x & two)
        return two",O(n)
"class Solution(object):
    def tribonacci(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1, 0],
             [1, 0, 1],
             [1, 0, 0]]
        return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1]",O(logn)
"class Solution2(object):
    def tribonacci(self, n):
        a, b, c = 0, 1, 1
        for _ in range(n):
            a, b, c = b, c, a+b+c
        return a",O(logn)
"class Solution(object):
    def maxIntersectionCount(self, y):
        val_to_idx = {x:i for i, x in enumerate(sorted(set(y)))}
        cnts = [0]*(2*len(val_to_idx)+1)
        for i in range(len(y)-1):
            left, right = 2*val_to_idx[y[i]], 2*val_to_idx[y[i+1]]+(-1 if y[i] < y[i+1] else +1)
            cnts[min(left, right)] += 1
            cnts[max(left, right)+1] -= 1
        cnts[2*val_to_idx[y[-1]]] += 1
        cnts[2*val_to_idx[y[-1]]+1] -= 1
        result = cnt = 0
        for c in cnts:
            cnt += c
            result = max(result, cnt)
        return result",O(nlogn)
"class Solution2(object):
    def maxIntersectionCount(self, y):
        events = []
        for i in range(len(y)-1):
            left, right = 2*y[i], 2*y[i+1]+(-1 if y[i] < y[i+1] else +1)
            events.append((min(left, right), +1))
            events.append((max(left, right)+1, -1))
        events.append((2*y[-1], +1))
        events.append((2*y[-1]+1, -1))
        events.sort()
        result = cnt = 0
        for _, c in events:
            cnt += c
            result = max(result, cnt)
        return result",O(nlogn)
"class Solution(object):
    def maxScore(self, edges):
        def iter_dfs():
            result = [(0, 0) for _ in range(len(adj))]
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    if not adj[u]:
                        continue
                    stk.append((2, u))
                    for v, _ in adj[u]:
                        stk.append((1, v))
                elif step == 2:
                    without_u = sum(max(result[v]) for v, w in adj[u])
                    with_u = max(without_u-max(result[v])+(result[v][1]+w) for v, w in adj[u])
                    result[u] = (with_u, without_u)
            return max(result[0])
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return iter_dfs()",O(n)
"class Solution2(object):
    def maxScore(self, edges):
        def dfs(u):
            if not adj[u]:
                return (0, 0)
            children = [dfs(v) for v, _ in adj[u]]
            without_u = sum(max(with_v, without_v) for with_v, without_v in children)
            with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children))
            return (with_u, without_u)
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return max(dfs(0))",O(n)
"class Solution(object):
    def preorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in reversed(node.children):
                if child:
                    stack.append(child)
        return result

",O(n)
"class Solution2(object):
    def preorder(self, root):
        def dfs(root, result):
            result.append(root.val)
            for child in root.children:
                if child:
                    dfs(child, result)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"class Solution(object):
    def minimizeResult(self, expression):
        def stoi(s, i, j):
            result = 0
            for k in range(i, j):
                result = result*10+(ord(s[k])-ord('0'))
            return result

        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression))
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join(itertools.chain((expression[i] for i in range(best[0])),
                                       '(', (expression[i] for i in range(best[0], best[1]+1)), ')',
                                       (expression[i] for i in range(best[1]+1, len(expression)))))",O(n ^ 2)
"class Solution2(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = int(expression[0:pos]), int(expression[pos+1:]) 
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"class Solution3(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        for i in range(pos):
            for j in range(pos+1, len(expression)):
                val = (int(expression[:i] or ""1"")*
                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*
                       int(expression[j+1:] or ""1"")) 
                if val < min_val:
                    min_val = val
                    best = (i, j)
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

import collections",O(n)
"class Solution2(object):
    def arithmeticTriplets(self, nums, diff):
        result = 0
        cnt1 = collections.Counter()
        cnt2 = collections.Counter()
        for x in nums:
            result += cnt2[x-diff]
            cnt2[x] += cnt1[x-diff]
            cnt1[x] += 1
        return result",O(n)
"class Solution(object):

    def serialize(self, root):
        def serializeHelper(node):
            if not node:
                vals.append(
                return
            vals.append(str(node.val))
            serializeHelper(node.left)
            serializeHelper(node.right)
        vals = []
        serializeHelper(root)
        return ' '.join(vals)


    def deserialize(self, data):
        def deserializeHelper():
            val = next(vals)
            if val == 
                return None
            node = TreeNode(int(val))
            node.left = deserializeHelper()
            node.right = deserializeHelper()
            return node
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
        vals = iter(isplit(data, ' '))
        return deserializeHelper()",O(n)
"class Solution(object):
    def maxIncreasingGroups(self, usageLimits):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        usageLimits = [min(x, len(usageLimits)) for x in usageLimits]
        inplace_counting_sort(usageLimits)
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result",O(n)
"class Solution2(object):
    def maxIncreasingGroups(self, usageLimits):
        usageLimits.sort()
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result",O(nlogn)
"class Solution3(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            curr = 0
            for i in range(l):
                curr += usageLimits[~i]-(l-i)
                curr = min(curr, 0)
            for i in range(len(usageLimits)-l):
                curr += usageLimits[i]
            return curr >= 0

        usageLimits.sort()
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution4(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in range(1, l+1))

        usageLimits.sort()
        prefix = [0]*(len(usageLimits)+1)
        for i in range(len(usageLimits)):
            prefix[i+1] = prefix[i]+usageLimits[i]
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution(object):
    def isSymmetric(self, root):
        if root is None:
            return True
        stack = []
        stack.append(root.left)
        stack.append(root.right)

        while stack:
            p, q = stack.pop(), stack.pop()

            if p is None and q is None:
                continue

            if p is None or q is None or p.val != q.val:
                return False

            stack.append(p.left)
            stack.append(q.right)

            stack.append(p.right)
            stack.append(q.left)

        return True


",O(n)
"class Solution2(object):
    def isSymmetric(self, root):
        if root is None:
            return True

        return self.isSymmetricRecu(root.left, root.right)

    def isSymmetricRecu(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None or left.val != right.val:
            return False
        return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left)",O(n)
"class Solution(object):
    def __init__(self):
        self.__max_log3 = int(math.log(0x7fffffff) / math.log(3))
        self.__max_pow3 = 3 ** self.__max_log3

    def isPowerOfThree(self, n):
        return n > 0 and self.__max_pow3 % n == 0",O(1)
"class Solution2(object):
    def isPowerOfThree(self, n):
        return n > 0 and (math.log10(n)/math.log10(3)).is_integer()",O(1)
"class Solution3(object):
    def countPairs(self, nums, k):
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.values() for i in range(len(idx)) for j in range(i+1, len(idx)))",O(n ^ 2)
"class Solution(object):
    def findComplement(self, num):
        return 2 ** (len(bin(num)) - 2) - 1 - num",O(1)
"class Solution2(object):
    def findComplement(self, num):
        i = 1
        while i <= num:
            i <<= 1
        return (i - 1) ^ num",O(1)
"class Solution3(object):
    def findComplement(self, num):
        bits = '{0:b}'.format(num)
        complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits)
        return int(complement_bits, 2)",O(1)
"class Solution(object):
    def pseudoPalindromicPaths (self, root):
        result = 0
        stk = [(root, 0)]
        while stk:
            node, count = stk.pop()
            if not node:
                continue
            count ^= 1 << (node.val-1)
            result += int(node.left == node.right and count&(count-1) == 0)
            stk.append((node.right, count))
            stk.append((node.left, count))
        return result",O(n)
"class Solution2(object):
    def pseudoPalindromicPaths (self, root):
        def dfs(node, count):
            if not root:
                return 0
            count ^= 1 << (node.val-1)
            return int(node.left == node.right and count&(count-1) == 0) + \
                   dfs(node.left, count) + dfs(node.right, count)
        return dfs(root, 0)",O(n)
"class Solution(object):
    def countDistinct(self, nums, k, p):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for i in range(len(nums)):
            cnt = 0
            curr = trie
            for j in range(i, len(nums)):
                cnt += (nums[j]%p == 0)
                if cnt > k:
                    break
                if nums[j] not in curr:
                    result += 1
                curr = curr[nums[j]]
        return result",O(n ^ 2)
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",O(n ^ 2)
"class Solution(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        mn = min((cnt[i], i) for i in range(value))[1]
        return value*cnt[mn]+mn
import collections",O(n)
"class Solution2(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        for i in range(len(nums)+1):
            if not cnt[i%value]:
                return i
            cnt[i%value] -= 1",O(n)
"class Solution(object):
    def maxRepOpt1(self, text):
        K = 1
        result = 0
        total_count, count = collections.Counter(), collections.Counter()
        left, max_count = 0, 0
        for i in range(len(text)):
            total_count[text[i]] += 1
            count[text[i]] += 1
            max_count = max(max_count, count[text[i]])
            if i-left+1 - max_count > K:
                count[text[left]] -= 1
                left += 1
            result = max(result, min(i-left+1, total_count[text[i]]))
        return result


import itertools",O(n)
"class Solution2(object):
    def maxRepOpt1(self, text):
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in range(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result",O(n)
"class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result",O(n)
"class Solution2(object):
    def triangularSum(self, nums):
        result = 0
        nCr = 1
        for i in range(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result",O(n)
"class Solution3(object):
    def triangularSum(self, nums):
        for i in reversed(range(len(nums))):
            for j in range(i):
                nums[j] = (nums[j]+nums[j+1])%10
        return nums[0]",O(n ^ 2)
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))",O(n)
"class Solution2(object):
    def rotate(self, nums, k):
        def apply_cycle_permutation(k, offset, cycle_len, nums):
            tmp = nums[offset]
            for i in range(1, cycle_len):
                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]
            nums[offset] = tmp

        k %= len(nums)
        num_cycles = gcd(len(nums), k)
        cycle_len = len(nums) / num_cycles
        for i in range(num_cycles):
            apply_cycle_permutation(k, i, cycle_len, nums)",O(n)
"class Solution3(object):
    def rotate(self, nums, k):
        count = 0
        start = 0
        while count < len(nums):
            curr = start
            prev = nums[curr]
            while True:
                idx = (curr + k) % len(nums)
                nums[idx], prev = prev, nums[idx]
                curr = idx
                count += 1
                if start == curr:
                    break
            start += 1",O(n)
"class Solution4(object):
    def rotate(self, nums, k):
        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]",O(n)
"class Solution5(object):
    def rotate(self, nums, k):
        while k > 0:
            nums.insert(0, nums.pop())
            k -= 1",O(n)
"class Solution(object):
    def numOfSubarrays(self, arr, k, threshold):
        result, curr = 0, sum(itertools.islice(arr, 0, k-1))
        for i in range(k-1, len(arr)):
            curr += arr[i]-(arr[i-k] if i-k >= 0 else 0)
            result += int(curr >= threshold*k)
        return result",O(n)
"class Solution2(object):
    def numOfSubarrays(self, arr, k, threshold):
        accu = [0]
        for x in arr:
            accu.append(accu[-1]+x)
        result = 0
        for i in range(len(accu)-k):
            if accu[i+k]-accu[i] >= threshold*k:
                result += 1
        return result",O(n)
"class Solution(object):
    def firstPalindrome(self, words):
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return """"",O(n)
"class Solution2(object):
    def firstPalindrome(self, words):
        return next((x for x in words if x == x[::-1]), """")",O(n)
"class Solution2(object):
    def minReverseOperations(self, n, p, banned, k):
        lookup = [False]*n
        for i in banned:
            lookup[i] = True
        d = 0
        result = [-1]*n
        result[p] = d
        sl = [SortedList(i for i in range(0, n, 2)), SortedList(i for i in range(1, n, 2))]
        sl[p%2].remove(p)
        q = [p]
        d += 1
        while q:
            new_q = []
            for p in q:
                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p
                for p in list(sl[left%2].irange(left, right)):
                    if not lookup[p]:
                        result[p] = d
                        new_q.append(p)
                    sl[left%2].remove(p)
            q = new_q
            d += 1
        return result",O(nlogn)
"class Solution(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[1, 1],
             [1, 0]]
        return pow(matrix_mult([[2, 1]], matrix_expo(T, n-1))[0][0], 2, MOD)",O(logn)
"class Solution2(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        prev, curr = 1, 2
        for _ in range(n-1):
            prev, curr = curr, (prev+curr)%MOD
        return pow(curr, 2, MOD)",O(logn)
"class Solution(object):
    def maximumSumScore(self, nums):
        prefix = suffix = 0
        result = float(""-inf"")
        right = len(nums)-1
        for left in range(len(nums)):
            prefix += nums[left]
            suffix += nums[right]
            right -= 1
            result = max(result, prefix, suffix)
        return result",O(n)
"class Solution2(object):
    def maximumSumScore(self, nums):
        total = sum(nums)
        prefix = 0
        result = float(""-inf"")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result",O(n)
"class Solution(object):
    def maxAbsValExpr(self, arr1, arr2):
        result = 0
        for c1 in [1, -1]:
            for c2 in [1, -1]:
                min_prev = float(""inf"")
                for i in range(len(arr1)):
                    curr = c1*arr1[i] + c2*arr2[i] + i
                    result = max(result, curr-min_prev)
                    min_prev = min(min_prev, curr)
        return result",O(n)
"class Solution2(object):
    def maxAbsValExpr(self, arr1, arr2):
        return max(max(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1))) -
                   min(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1)))
                   for c1 in [1, -1] for c2 in [1, -1])",O(n)
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD",O(logn)
"class Solution(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        result = ''
        while num:
            result = str(num % 7) + result
            num //= 7
        return result if result else '0'",O(1)
"class Solution2(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        if num < 7:
            return str(num)
        return self.convertToBase7(num // 7) + str(num % 7)",O(1)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        while m < n:
            n &= n - 1
        return n",O(1)
"class Solution2(object):
    def rangeBitwiseAnd(self, m, n):
        i, diff = 0, n-m
        while diff:
            diff >>= 1
            i += 1
        return n & m >> i << i",O(1)
"class Solution_Wrong_Greedy_SortedList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = sortedcontainers.SortedList(iter(count.keys()))
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in ordered_set:
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(x)
                    freq_to_nodes.pop(len(stks)-curr)
                to_remove = []
                direction = (lambda x:x) if not is_reversed else reversed
                for x in direction(ordered_set):
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        to_remove.append(x)
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
                for x in to_remove:
                    ordered_set.remove(x) 
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float(""-inf""), cmp=lambda x, y: x > y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(list(count.keys()), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it) 
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)",O(logn)
"class Solution2(object):
    def rotatedDigits(self, N):
        INVALID, SAME, DIFF = 0, 1, 2
        same, diff = [0, 1, 8], [2, 5, 6, 9]
        dp = [0] * (N+1)
        dp[0] = SAME
        for i in range(N//10+1):
            if dp[i] != INVALID:
                for j in same:
                    if i*10+j <= N:
                        dp[i*10+j] = max(SAME, dp[i])
                for j in diff:
                    if i*10+j <= N:
                        dp[i*10+j] = DIFF
        return dp.count(DIFF)",O(n)
"class Solution(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x)
            global_max = max(global_max, local_max)
        return global_max",O(n)
"class Solution2(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max = max(1, local_max)
            if x > 0:
                local_max, local_min = local_max * x, local_min * x
            else:
                local_max, local_min = local_min * x, local_max * x
            global_max = max(global_max, local_max)
        return global_max",O(n)
"class Solution(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[pos] = nums[pos], nums[i]
                pos += 1

    def moveZeroes2(self, nums):
        nums.sort(cmp=lambda a, b: 0 if b else -1)",O(n)
"class Solution2(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[pos] = nums[i]
                pos += 1

        for i in range(pos, len(nums)):
            nums[i] = 0",O(n)
"class Solution(object):
    def findDifferentBinaryString(self, nums):
        return """".join(""01""[nums[i][i] == '0'] for i in range(len(nums)))",O(n)
"class Solution(object):
    def maxLevelSum(self, root):
        def dfs(node, i, level_sums):
            if not node:
                return
            if i == len(level_sums):
                level_sums.append(0)
            level_sums[i] += node.val
            dfs(node.left, i+1, level_sums)
            dfs(node.right, i+1, level_sums)

        level_sums = []
        dfs(root, 0, level_sums)
        return level_sums.index(max(level_sums))+1",O(n)
"class Solution2(object):
    def maxLevelSum(self, root):
        result, level, max_total = 0, 1, float(""-inf"")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total > max_total:
                result, max_total = level, total
            level += 1
        return result",O(n)
"class Solution(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        result = 0
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(i+1):
                    new_dp[0][i] = max(new_dp[0][i], (prefix[i]-prefix[k])+dp[0][k])
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                for k in range(i+1, len(grid)+1):
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+(new_prefix[k]-new_prefix[i]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"class Solution2(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(len(grid)+1):
                    new_dp[0][i] = max(new_dp[0][i], max(prefix[i]-prefix[k], 0)+dp[0][k])
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+max(new_prefix[k]-new_prefix[i], 0))
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"class Solution2(object):
    def minimumSubarrayLength(self, nums, k):
        result = float(""inf"")
        for left in range(len(nums)):
            curr = 0
            for right in range(left, len(nums)):
                curr |= nums[right]
                if curr < k:
                    continue
                result = min(result, right-left+1)
                break
        return result if result != float(""inf"") else -1",O(n ^ 2)
"class Solution2(object):
    def sumOfNumberAndReverse(self, num):
        def reverse(n):
            result = 0
            while n:
                result = result*10 + n%10
                n //= 10            
            return result

        return any(x+reverse(x) == num for x in range(num//2, num+1))",O(nlogn)
"class Solution3(object):
    def sumOfNumberAndReverse(self, num):
        return any(x+int(str(x)[::-1]) == num for x in range(num//2, num+1))",O(nlogn)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8",O(n)
"class Solution2(object):
    def isNumber(self, s):
        import re
        return bool(re.match(""^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$"", s))",O(n)
"class Solution(object):
    def mirrorReflection(self, p, q):
        return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1",O(1)
"class Solution(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def iter_dfs(root, result):
            ret = collections.defaultdict(lambda: INF)
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        ret[None] = 0
                        continue
                    if node.left == node.right:
                        ret[True] = node.val^1
                        ret[False] = node.val^0
                        continue
                    ret1 = collections.defaultdict(lambda: INF)
                    ret2 = collections.defaultdict(lambda: INF)
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    for k1, v1 in ret1.items():
                        for k2, v2 in ret2.items():
                            ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2)
            return ret[result]

        return iter_dfs(root, result)


import collections",O(n)
"class Solution2(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0} 
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.items():
                for k2, v2 in right.items():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]",O(n)
"class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) // 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        s, i = list(s), 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1
        return """".join(s)",O(n)
"class Solution2(object):
    def reverseWords(self, s):
        reversed_words = [word[::-1] for word in s.split(' ')]
        return ' '.join(reversed_words)",O(n)
"class Solution(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        color = collections.defaultdict(int)
        q = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q.append((HOLE, i, CAT, MOUSE))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q.append((i, i, t, CAT))
        while q:
            i, j, t, c = q.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if nt == c:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
        return color[MOUSE_START, CAT_START, MOUSE]

import collections",O(n ^ 3)
"class Solution2(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        color = collections.defaultdict(int)
        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        q1 = collections.deque()
        q2 = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q1.append((HOLE, i, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q2.append((i, i, t))
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        while q2:
            i, j, t = q2.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == MOUSE:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE]",O(n ^ 3)
"class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)

        result = 0
        stk = [(headID, 0)]
        while stk:
            node, curr = stk.pop()
            curr += informTime[node]
            result = max(result, curr)
            if node not in children:
                continue
            for c in children[node]:
                stk.append((c, curr))
        return result",O(n)
"class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)",O(n)
"class Solution(object):
    def buildTree(self, preorder, inorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))

    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(preorder[pre_start])
        i = lookup[preorder[pre_start]]
        node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i)
        node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)
        return node",O(n)
"class Solution(object):
    def countQuadruplets(self, nums):
        result = 0
        lookup = collections.defaultdict(int)
        lookup[nums[-1]] = 1
        for c in reversed(range(2, len(nums)-1)):
            for b in range(1, c):
                for a in range(b):
                    if nums[a]+nums[b]+nums[c] in lookup:
                        result += lookup[nums[a]+nums[b]+nums[c]]
            lookup[nums[c]] += 1
        return result


import collections",O(n ^ 3)
"class Solution2(object):
    def countQuadruplets(self, nums):
        lookup = collections.defaultdict(list)
        for d in range(3, len(nums)):
            for c in range(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in range(1, len(nums)-2) for a in range(b))",O(n ^ 3)
"class Solution(object):
    def findWords(self, words):
        rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']),
                set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']),
                set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])]

        result = []
        for word in words:
            k = 0
            for i in range(len(rows)):
                if word[0].lower() in rows[i]:
                    k = i
                    break
            for c in word:
                if c.lower() not in rows[k]:
                    break
            else:
                result.append(word)
        return result",O(n)
"class Solution2(object):
    def findWords(self, words):
        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
        single_row_words = []
        for word in words:
            for row in keyboard_rows:
                if all(letter in row for letter in word.lower()):
                    single_row_words.append(word)
        return single_row_words",O(n)
"class Solution(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"class Solution2(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def dfs(u, p):
            left[u] = cnt[0]
            cnt[0] += 1
            for v in adj[u]:
                if v == p:
                    continue
                dfs(v, u)
                nums[u] ^= nums[v]
            right[u] = cnt[0]
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        cnt = [0]
        left = [0]*len(nums)
        right = [0]*len(nums)
        dfs(0, -1)
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"class Solution3(object):
    def minimumScore(self, nums, edges):
        def dfs(u, p, result):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total ^= dfs(v, u, result)
            result.append(total)
            return total
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            left = []
            dfs(u, v, left)
            right = []
            dfs(v, u, right)
            for candidates in (left, right):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"class Solution4(object):
    def minimumScore(self, nums, edges):
        def iter_dfs(nums, adj, u, p):
            result = []
            stk = [(1, (u, p, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    new_rets = []
                    stk.append((2, (u, new_rets, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_rets.append([0])
                        stk.append((1, (v, u, new_rets[-1])))
                elif step == 2:
                    u, new_rets, ret = args
                    ret[0] = nums[u]
                    for x in new_rets:
                        ret[0] ^= x[0]
                    result.append(ret[0])
            return result
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"class Solution4(object):
    def maximumStrongPairXor(self, nums):
        return max(nums[i]^nums[j] for i in range(len(nums)) for j in range(i, len(nums)) if abs(nums[i]-nums[j]) <= min(nums[i], nums[j]))",O(n ^ 2)
"class Solution(object):
    def copyRandomList(self, head):
        current = head
        while current:
            copied = Node(current.val)
            copied.next = current.__next__
            current.next = copied
            current = copied.__next__

        current = head
        while current:
            if current.random:
                current.next.random = current.random.__next__
            current = current.next.__next__

        dummy = Node(0)
        copied_current, current = dummy, head
        while current:
            copied_current.next = current.__next__
            current.next = current.next.__next__
            copied_current, current = copied_current.__next__, current.__next__
        return dummy.__next__",O(n)
"class Solution2(object):
    def copyRandomList(self, head):
        dummy = Node(0)
        current, prev, copies = head, dummy, {}

        while current:
            copied = Node(current.val)
            copies[current] = copied
            prev.next = copied
            prev, current = prev.__next__, current.__next__

        current = head
        while current:
            if current.random:
                copies[current].random = copies[current.random]
            current = current.__next__

        return dummy.__next__",O(n)
"class Solution(object):
    def minimumPerimeter(self, neededApples):
        a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples)
        p = (3*a*c-b**2)/(3*a**2) 
        q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3) 
        assert((q/2)**2+(p/3)**3 > 0) 
        x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + \
            (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3)
        return 8*int(math.ceil(x - b/(3*a)))",O(1)
"class Solution2(object):
    def minimumPerimeter(self, neededApples):
        x = int((2*neededApples)**(1.0/3))
        x -= x%2
        assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3)
        x += 2
        if (x-2)*(x-1)*x < 2*neededApples:
            x += 2
        return 8*(x-2)//2",O(1)
"class Solution3(object):
    def minimumPerimeter(self, neededApples):
        def check(neededApples, x):
            return r*(2*r+1)*(2*r+2) >= neededApples

        left, right = 1, int((neededApples/4.0)**(1.0/3))
        while left <= right:
            mid = left + (right-left)//2
            if check(neededApples, mid):
                right = mid-1
            else:
                left = mid+1
        return 8*left",O(logn)
"class Solution_TLE(object):
    def countPrimes(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes
    
        return len(linear_sieve_of_eratosthenes(n-1))",O(n)
"class Solution(object):
    def findDistance(self, root, p, q):
        def iter_dfs(root, p, q):
            result = 0
            dist = [-1]
            stk = [(1, [root, dist])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [-1], [-1]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    if node.val in (p, q):
                        if ret1[0] == ret2[0] == -1:
                            ret[0] = 0
                        else:
                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1
                    elif ret1[0] != -1 and ret2[0] != -1:
                        result = ret1[0]+ret2[0]+2
                    elif ret1[0] != -1:
                        ret[0] = ret1[0]+1
                    elif ret2[0] != -1:
                        ret[0] = ret2[0]+1
            return result
        
        return iter_dfs(root, p, q)",O(n)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"class Solution(object):
    def flatten(self, root):
        self.flattenRecu(root, None)

    def flattenRecu(self, root, list_head):
        if root:
            list_head = self.flattenRecu(root.right, list_head)
            list_head = self.flattenRecu(root.left, list_head)
            root.right = list_head
            root.left = None
            return root
        else:
            return list_head

",O(n)
"class Solution2(object):
    list_head = None
    def flatten(self, root):
        if root:
            self.flatten(root.right)
            self.flatten(root.left)
            root.right = self.list_head
            root.left = None
            self.list_head = root",O(n)
"class Solution(object):
    def countQuadruplets(self, nums):
        dp = [0]*len(nums) 
        result = 0
        for l in range(len(nums)):
            cnt = 0
            for j in range(l):
                if nums[j] < nums[l]:
                    cnt += 1
                    result += dp[j]
                elif nums[j] > nums[l]:
                    dp[j] += cnt
        return result",O(n ^ 2)
"class Solution2(object):
    def countQuadruplets(self, nums):
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            left = 0
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left*right[j][k+1]
                left += int(nums[k] > nums[j])
        return result",O(n ^ 2)
"class Solution3(object):
    def countQuadruplets(self, nums):
        left = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in range(j):
                left[j][i+1] = left[j][i] + int(nums[i] < nums[j])
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left[k][j]*right[j][k+1]
        return result",O(n ^ 2)
"class Solution(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sl = SortedList()
        result = 0
        for x, y in zip(nums1, nums2):
            result += sl.bisect_right((x-y)+diff)
            sl.add(x-y)
        return result

import itertools
import bisect


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret",O(nlogn)
"class Solution2(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sorted_nums = sorted(set(x-y for x, y in zip(nums1, nums2)))
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        result = 0
        bit = BIT(len(num_to_idx))
        for x, y in zip(nums1, nums2):
            result += bit.query(bisect.bisect_right(sorted_nums, (x-y)+diff)-1)
            bit.add(num_to_idx[x-y], 1)
        return result",O(nlogn)
"class Solution3(object):
    def numberOfPairs(self, nums1, nums2, diff):
        def merge_sort(nums, left, right, result):
            if left == right:
                return
            mid = left+(right-left)//2
            merge_sort(nums, left, mid, result)
            merge_sort(nums, mid+1, right, result)
            r = mid+1
            for l in range(left, mid+1):
                while r < right+1 and nums[l]-nums[r] > diff:
                    r += 1
                result[0] += right-r+1
            tmp = []
            l, r = left, mid+1
            while l < mid+1 or r < right+1:
                if r >= right+1 or (l < mid+1 and nums[l] <= nums[r]):
                    tmp.append(nums[l])
                    l += 1
                else:
                    tmp.append(nums[r])
                    r += 1
            nums[left:right+1] = tmp

        nums = [x-y for x, y in zip(nums1, nums2)]
        result = [0]
        merge_sort(nums, 0, len(nums)-1, result)
        return result[0]",O(nlogn)
"class Solution(object):
    def minSideJumps(self, obstacles):
        result, lanes = 0, set([2])
        for i in range(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in range(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result",O(n)
"class Solution2(object):
    def minSideJumps(self, obstacles):
        dp = [1, 0, 1]        
        for i in obstacles:
            if i:
                dp[i-1] = float(""inf"")
            for j in range(3):
                if j+1 != i:
                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))
        return min(dp)",O(n)
"class Solution(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= id(node)
            for child in node.children:
                root ^= id(child)
        for node in tree:
            if id(node) == root:
                return node
        return None",O(n)
"class Solution2(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= node.val
            for child in node.children:
                root ^= child.val
        for node in tree:
            if node.val == root:
                return node
        return None",O(n)
"class Solution3(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root += node.val-sum(child.val for child in node.children)
        for node in tree:
            if node.val == root:
                return node
        return None",O(n)
"class Solution(object):
    def missingNumber(self, nums):
        return reduce(operator.xor, nums,
                      reduce(operator.xor, range(len(nums) + 1)))",O(n)
"class Solution2(object):
    def missingNumber(self, nums):
        return sum(range(len(nums)+1)) - sum(nums)",O(n)
"class Solution(object):
    def maximizeGreatness(self, nums):
        return len(nums)-max(collections.Counter(nums).values())
    
    
",O(n)
"class Solution2(object):
    def maximizeGreatness(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] > nums[left]:
                left += 1
        return left",O(n)
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, max_i = 0, 0
        for i, v in enumerate(arr):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result",O(n)
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",O(n)
"class Solution(object):
    def largestMultipleOfThree(self, digits):
        lookup = {0: [],
                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}
        count = collections.Counter(digits)
        for deletes in lookup[sum(digits)%3]:
            delete_count = collections.Counter(deletes)
            if all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"class Solution2(object):
    def largestMultipleOfThree(self, digits):
        def candidates_gen(r):
            if r == 0:
                return
            for i in range(10):
                yield [i]
            for i in range(10):
                for j in range(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"class Solution2(object):

    def __init__(self):
        self.__books = []


    def book(self, start, end):
        i = bisect.bisect_left(self.__books, (start, 1))
        if i < len(self.__books) and self.__books[i][0] == start:
            self.__books[i] = (self.__books[i][0], self.__books[i][1]+1)
        else:
            self.__books.insert(i, (start, 1))

        j = bisect.bisect_left(self.__books, (end, 1))
        if j < len(self.__books) and self.__books[j][0] == end:
            self.__books[j] = (self.__books[j][0], self.__books[j][1]-1)
        else:
            self.__books.insert(j, (end, -1))

        result, cnt = 0, 0
        for book in self.__books:
            cnt += book[1]
            result = max(result, cnt)
        return result",O(n ^ 2)
"class Solution(object):
    def alienOrder(self, words):
        result, in_degree, out_degree = [], {}, {}
        zero_in_degree_queue = collections.deque()
        nodes = set()
        for word in words:
            for c in word:
                nodes.add(c)

        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], in_degree, out_degree)

        for node in nodes:
            if node not in in_degree:
                zero_in_degree_queue.append(node)

        while zero_in_degree_queue:
            precedence = zero_in_degree_queue.popleft()
            result.append(precedence)

            if precedence in out_degree:
                for c in out_degree[precedence]:
                    in_degree[c].discard(precedence)
                    if not in_degree[c]:
                        zero_in_degree_queue.append(c)

                del out_degree[precedence]

        if out_degree:
            return """"

        return """".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
        str_len = min(len(word1), len(word2))
        for i in range(str_len):
            if word1[i] != word2[i]:
                if word2[i] not in in_degree:
                    in_degree[word2[i]] = set()
                if word1[i] not in out_degree:
                    out_degree[word1[i]] = set()
                in_degree[word2[i]].add(word1[i])
                out_degree[word1[i]].add(word2[i])
                break",O(n)
"class Solution2(object):
    def alienOrder(self, words):
        nodes, ancestors = set(), {}
        for i in range(len(words)):
            for c in words[i]:
                nodes.add(c)
        for node in nodes:
            ancestors[node] = []
        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], ancestors)

        result = []
        visited = {}
        for node in nodes:
            if self.topSortDFS(node, node, ancestors, visited, result):
                return """"

        return """".join(result)

    def findEdges(self, word1, word2, ancestors):
        min_len = min(len(word1), len(word2))
        for i in range(min_len):
            if word1[i] != word2[i]:
                ancestors[word2[i]].append(word1[i])
                break

    def topSortDFS(self, root, node, ancestors, visited, result):
        if node not in visited:
            visited[node] = root
            for ancestor in ancestors[node]:
                if self.topSortDFS(root, ancestor, ancestors, visited, result):
                    return True
            result.append(node)
        elif visited[node] == root:
            return True
        return False",O(n)
"class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 1: 
                return 0
            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid, end, lower, upper)
            j, k, r = mid, mid, mid
            tmp = []
            for i in range(start, mid):
                while k < end and sums[k] - sums[i] < lower:
                    k += 1
                while j < end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r < end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])
            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums), lower, upper)",O(nlogn)
"class Solution2(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid + 1, end, lower, upper)
            j, k, r = mid + 1, mid + 1, mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while k <= end and sums[k] - sums[i] < lower:
                    k += 1
                while j <= end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r <= end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])

            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)",O(nlogn)
"class Solution(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def BellmanFord(dist, pairs, rates):
            for _ in range(len(pairs)):
                for i in range(len(pairs)):
                    dist[pairs[i][1]] = max(dist[pairs[i][1]], dist[pairs[i][0]]*rates[i])
                    dist[pairs[i][0]] = max(dist[pairs[i][0]], dist[pairs[i][1]]*(1/rates[i]))
        
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        BellmanFord(dist, pairs1, rates1)
        BellmanFord(dist, pairs2, rates2)
        return dist[initialCurrency]
import collections",O(n ^ 2)
"class Solution2(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def find_adj(pairs, rates):
            adj = collections.defaultdict(list)
            for i in range(len(pairs)):
                adj[pairs[i][0]].append((pairs[i][1], rates[i]))
                adj[pairs[i][1]].append((pairs[i][0], 1/rates[i]))
            return adj

        def bfs(dist, adj):
            q = list(dist.keys())
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u]:
                        if not w*dist[u] > dist[v]:
                            continue
                        dist[v] = w*dist[u]
                        new_q.append(v)
                q = new_q
            return dist
    
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        adj1 = find_adj(pairs1, rates1)
        bfs(dist, adj1) 
        adj2 = find_adj(pairs2, rates2)
        bfs(dist, adj2) 
        return dist[initialCurrency]",O(n ^ 2)
"class Solution2(object):
    def countExcellentPairs(self, nums, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        sorted_cnts = sorted(popcount(x) for x in set(nums))
        result = 0
        left, right = 0, len(sorted_cnts)-1
        while left <= right:
            if sorted_cnts[left]+sorted_cnts[right] < k:
                left += 1
            else:
                result += 1+2*((right-1)-left+1)
                right -= 1
        return result",O(nlogn)
"class Solution(object):
    def maxFrequency(self, nums, k, numOperations):
        nums.sort()
        result = 0
        left, right = 0, -1
        cnt = collections.defaultdict(int)
        for i in range(len(nums)):
            while right+1 < len(nums) and nums[right+1]-nums[i] <= k:
                cnt[nums[right+1]] += 1 
                right += 1
            while nums[i]-nums[left] > k:
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, cnt[nums[i]]+min((right-left+1)-cnt[nums[i]], numOperations))
        left = 0
        for right in range(len(nums)):
            while nums[left]+k < nums[right]-k:
                left += 1
            result = max(result, min(right-left+1, numOperations))
        return result
    
import collections",O(nlogn)
"class Solution2(object):
    def maxFrequency(self, nums, k, numOperations):
        cnt = collections.defaultdict(int) 
        for x in nums:
            cnt[x] += 1
        diff = defaultdict(int)
        for x in nums:
            diff[x] += 0
            diff[x-k] += 1
            diff[x+k+1] -= 1
        result = curr = 0
        for x, c in sorted(diff.items()):
            curr += c
            result = max(result, cnt[x]+min(curr-cnt[x], numOperations))
        return result",O(nlogn)
"class Solution(object):
    def isUnivalTree(self, root):
        s = [root]
        while s:
            node = s.pop()
            if not node:
                continue
            if node.val != root.val:
                return False
            s.append(node.left)
            s.append(node.right)
        return True
    ",O(n)
"class Solution2(object):
    def isUnivalTree(self, root):
        return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and \
               (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right)))",O(n)
"class Solution(object):
    def fourSum(self, nums, target):
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                total = target - nums[i] - nums[j]
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[left] + nums[right] == total:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        right -= 1
                        left += 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif nums[left] + nums[right] > total:
                        right -= 1
                    else:
                        left += 1
        return result",O(n ^ 3)
"class Solution(object):
    def getHint(self, secret, guess):
        A, B = 0, 0
        lookup = defaultdict(int)
        for s, g in zip(secret, guess):
            if s == g:
                A += 1
            else:
                B += int(lookup[s] < 0) + int(lookup[g] > 0)
                lookup[s] += 1
                lookup[g] -= 1
        return ""%dA%dB"" % (A, B)",O(n)
"class Solution2(object):
    def getHint(self, secret, guess):
        A = sum(map(operator.eq, secret, guess))
        B = sum((Counter(secret) & Counter(guess)).values()) - A
        return ""%dA%dB"" % (A, B)",O(n)
"class Solution(object):
    def minEdgeReversals(self, n, edges):
        def iter_dfs1():
            result = 0
            stk = [(0, -1)]
            while stk:
                u, p = stk.pop()
                for v in adj[u].keys():
                    if v == p:
                        continue
                    result += adj[u][v]
                    stk.append((v, u))
            return result

        def iter_dfs2(curr):
            result = [-1]*n
            stk = [(0, curr)]
            while stk:
                u, curr = stk.pop()
                result[u] = curr
                for v in adj[u].keys():
                    if result[v] == -1:
                        stk.append((v, curr-adj[u][v]+adj[v][u]))
            return result
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        return iter_dfs2(iter_dfs1())",O(n)
"class Solution2(object):
    def minEdgeReversals(self, n, edges):
        def dfs1(u, p):
            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)

        def dfs2(u, curr):
            result[u] = curr
            for v in adj[u]:
                if result[v] == -1:
                    dfs2(v, curr-adj[u][v]+adj[v][u])
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        result = [-1]*n
        dfs2(0, dfs1(0, -1))
        return result",O(n)
"class Solution(object):
    def __init__(self):
        self.__random_length = 6
        self.__tiny_url = ""http://tinyurl.com/""
        self.__alphabet = ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
        self.__lookup = {}

    def encode(self, longUrl):
        def getRand():
            rand = []
            for _ in range(self.__random_length):
                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]
            return """".join(rand)

        key = getRand()
        while key in self.__lookup:
            key = getRand()
        self.__lookup[key] = longUrl
        return self.__tiny_url + key

    def decode(self, shortUrl):
        return self.__lookup[shortUrl[len(self.__tiny_url):]]


from hashlib import sha256",O(1)
"class Solution2(object):

    def __init__(self):
        self._cache = {}
        self.url = 'http://tinyurl.com/'

    def encode(self, long_url):
        key = sha256(long_url.encode()).hexdigest()[:6]
        self._cache[key] = long_url
        return self.url + key

    def decode(self, short_url):
        key = short_url.replace(self.url, '')
        return self._cache[key]",O(1)
"class Solution(object):
    def checkIfCanBreak(self, s1, s2):
        def is_break(count1, count2):
            curr1, curr2 = 0, 0
            for c in string.ascii_lowercase:
                curr1 += count1[c]
                curr2 += count2[c]
                if curr1 < curr2:
                    return False
            return True

        count1, count2 = collections.Counter(s1), collections.Counter(s2)
        return is_break(count1, count2) or is_break(count2, count1)
import itertools",O(n)
"class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in zip(sorted(s1), sorted(s2))))",O(n)
"class Solution3(object):
    def checkIfCanBreak(self, s1, s2):
        s1, s2 = sorted(s1), sorted(s2)
        return all(a >= b for a, b in zip(s1, s2)) or \
               all(a <= b for a, b in zip(s1, s2))",O(nlogn)
"class Solution(object):
    def lemonadeChange(self, bills):
        coins = [20, 10, 5]
        counts = collections.defaultdict(int)
        for bill in bills:
            counts[bill] += 1
            change = bill - coins[-1]
            for coin in coins:
                if change == 0:
                    break
                if change >= coin:
                    count = min(counts[coin], change//coin)
                    counts[coin] -= count
                    change -= coin * count
            if change != 0:
                return False
        return True",O(n)
"class Solution2(object):
    def lemonadeChange(self, bills):
        five, ten = 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            elif bill == 10:
                if not five:
                    return False
                five -= 1
                ten += 1
            else:
                if ten and five:
                    ten -= 1
                    five -= 1
                elif five >= 3:
                    five -= 3
                else:
                    return False
        return True",O(n)
"class Solution(object):
    def isDecomposable(self, s):
        if len(s)%3 != 2:
            return False
        for left in range(0, len(s), 3):
            if any(s[i] != s[i-1] for i in range(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(range(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(range(max(right-2, left), right))):
                break
        return right-left == 1",O(n)
"class Solution2(object):
    def isDecomposable(self, s):
        found, i = False, 0
        while i < len(s):
            l = 1
            for j in range(i+1, min(i+3, len(s))):
                if s[j] != s[i]:
                    break
                l += 1
            if l < 2:
                return False
            if l == 2:
                if found:
                    return False
                found = True
            i += l  
        return found",O(n)
"class Solution3(object):
    def isDecomposable(self, s):
        found, l = False, 0
        for i, c in enumerate(s):
            if not l or c != s[i-1]:
                if l:
                    return False
                l = 1
                continue
            l += 1
            if l == 2:
                if i == len(s)-1 or s[i] != s[i+1]:
                    if found:
                        return False
                    found, l = True, 0
            elif l == 3:
                 l =  0
        return found",O(n)
"class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in range(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in range(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result",O(n)
"class Solution(object):
    def wiggleSort(self, nums):
        nums.sort()
        mid = (len(nums) - 1) / 2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]",O(nlogn)
"class Solution(object):
    def isSubstringPresent(self, s):
        lookup = [[False]*26 for _ in range(26)]
        for i in range(len(s)-1):
            lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True
        return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')]  for i in range(len(s)-1))
import collections",O(n)
"class Solution2(object):
    def isSubstringPresent(self, s):
        lookup = collections.defaultdict(set)
        for i in range(len(s)-1):
            lookup[s[i]].add(s[i+1])
        return any(s[i] in lookup[s[i+1]] for i in range(len(s)-1))",O(n)
"class Solution(object):
    def singleNumber(self, nums):
        x_xor_y = reduce(operator.xor, nums)
        bit =  x_xor_y & -x_xor_y
        result = [0, 0]
        for i in nums:
            result[bool(i & bit)] ^= i
        return result",O(n)
"class Solution2(object):
    def singleNumber(self, nums):
        x_xor_y = 0
        for i in nums:
            x_xor_y ^= i

        bit = x_xor_y & ~(x_xor_y - 1)

        x = 0
        for i in nums:
            if i & bit:
                x ^= i

        return [x, x ^ x_xor_y]",O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return [x[0] for x in sorted(list(collections.Counter(nums).items()), key=lambda i: i[1], reverse=False)[:2]]",O(n)
"class Solution(object):
    def numberOfWeakCharacters(self, properties):
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d < max_d:
                result += 1
            max_d = max(max_d, d)
        return result

import collections",O(nlogn)
"class Solution2(object):
    def numberOfWeakCharacters(self, properties):
        lookup = collections.defaultdict(list)
        for a, d in properties:
            lookup[a].append(d)
        result = max_d = 0
        for a in sorted(iter(lookup.keys()), reverse=True):
            result += sum(d < max_d for d in lookup[a])
            max_d = max(max_d, max(lookup[a]))
        return result",O(nlogn)
"class Solution(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in reversed(range(len(nums)-1)):
            if nums[i] < nums[i+1]:
                k = i
                break
        else:
            nums.reverse()
            return

        for i in reversed(range(k+1, len(nums))):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",O(n)
"class Solution2(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                k = i

        if k == -1:
            nums.reverse()
            return

        for i in range(k+1, len(nums)):
            if nums[i] > nums[k]:
                l = i
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",O(n)
"class Solution(object):
    def nthUglyNumber(self, n):
        ugly_number = 0

        heap = []
        heapq.heappush(heap, 1)
        for _ in range(n):
            ugly_number = heapq.heappop(heap)
            if ugly_number % 2 == 0:
                heapq.heappush(heap, ugly_number * 2)
            elif ugly_number % 3 == 0:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
            else:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
                heapq.heappush(heap, ugly_number * 5)

        return ugly_number

    def nthUglyNumber2(self, n):
        ugly = [1]
        i2 = i3 = i5 = 0
        while len(ugly) < n:
            while ugly[i2] * 2 <= ugly[-1]: i2 += 1
            while ugly[i3] * 3 <= ugly[-1]: i3 += 1
            while ugly[i5] * 5 <= ugly[-1]: i5 += 1
            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
        return ugly[-1]

    def nthUglyNumber3(self, n):
        q2, q3, q5 = [2], [3], [5]
        ugly = 1
        for u in heapq.merge(q2, q3, q5):
            if n == 1:
                return ugly
            if u > ugly:
                ugly = u
                n -= 1
                q2 += 2 * u,
                q3 += 3 * u,
                q5 += 5 * u,",O(n)
"class Solution2(object):
    ugly = sorted(2**a * 3**b * 5**c
                  for a in range(32) for b in range(20) for c in range(14))

    def nthUglyNumber(self, n):
        return self.ugly[n-1]",O(n)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)",O(n)
"class Solution2(object):
    def discountPrices(self, sentence, discount):
        def format(discount, x):
            return ""${:d}.{:02d}"".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x

        return "" "".join(format(discount, x) for x in sentence.split())",O(n)
"class Solution(object):
    def minCostConnectPoints(self, points):
        result, u = 0, 0 
        dist = [float(""inf"")]*len(points)
        lookup = set()
        for _ in range(len(points)-1):
            x0, y0 = points[u]
            lookup.add(u)
            for v, (x, y) in enumerate(points):
                if v in lookup:
                    continue
                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))
            val, u = min((val, v) for v, val in enumerate(dist)) 
            dist[u] = float(""inf"") 
            result += val
        return result",O(n ^ 2)
"class Solution2(object):

    def __init__(self):
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__calendar:
            if start < j and end > i:
                return False
        self.__calendar.append((start, end))
        return True",O(n ^ 2)
"class Solution(object):
    def judgeCircle(self, moves):
        count = collections.Counter(moves)
        return count['L'] == count['R'] and count['U'] == count['D']
",O(n)
"class Solution(object):
    def judgeCircle(self, moves):
        v, h = 0, 0
        for move in moves:
            if move == 'U':
                v += 1
            elif move == 'D':
                v -= 1
            elif move == 'R':
                h += 1
            elif move == 'L':
                h -= 1
        return v == 0 and h == 0",O(n)
"class Solution2(object):
    def rearrangeArray(self, nums):
        nums.sort()
        mid = (len(nums)-1)//2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]
        return nums",O(nlogn)
"class Solution2(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        slots1.sort(key = lambda x: x[0])
        slots2.sort(key = lambda x: x[0])
        i, j = 0, 0
        while i < len(slots1) and j < len(slots2):
            left = max(slots1[i][0], slots2[j][0])
            right = min(slots1[i][1], slots2[j][1])
            if left+duration <= right:
                return [left, left+duration]
            if slots1[i][1] < slots2[j][1]:
                i += 1
            else:
                j += 1
        return []",O(nlogn)
"class Solution(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        min_heap = []
        lookup = [False]*len(paint)
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            while min_heap and lookup[min_heap[0]]:
                heapq.heappop(min_heap)
            if min_heap:
                result[min_heap[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    heapq.heappush(min_heap, i)
                else:
                    lookup[i] = True
        return result
from sortedcontainers import SortedList",O(nlogn)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result",O(nlogn)
"class Solution(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        mn, mx = float(""inf""), float(""-inf"")
        for right in range(len(nums)):
            if mn <= nums[right] <= mx:
                mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2)
            else:
                mn, mx = nums[right]-2, nums[right]+2
                for left in reversed(range(right)):
                    if not mn <= nums[left] <= mx:
                        break
                    mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2)
                else:
                    left = -1
                left += 1
            result += right-left+1
        return result
import collections",O(n)
"class Solution2(object):
    def continuousSubarrays(self, nums):
        mn, mx = collections.deque(), collections.deque()
        result = left = 0
        for right in range(len(nums)):
            while mn and nums[mn[-1]] > nums[right]:
                mn.pop()
            mn.append(right)
            while mx and nums[mx[-1]] < nums[right]:
                mx.pop()
            mx.append(right)
            while not nums[right]-nums[mn[0]] <= 2:
                left = max(left, mn.popleft()+1)
            while not nums[mx[0]]-nums[right] <= 2:
                left = max(left, mx.popleft()+1)
            result += right-left+1
        return result",O(n)
"class Solution3(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        lookup = SortedDict()
        for right in range(len(nums)):
            lookup[nums[right]] = right
            to_del = []
            for x, i in list(lookup.items()):
                if nums[right]-x <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x)
            for x, i in reversed(list(lookup.items())):
                if x-nums[right] <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x) 
            for x in to_del:
                del lookup[x]
            result += right-left+1
        return result",O(nlogn)
"class Solution2(object):
    def integerBreak(self, n):
        if n < 4:
            return n - 1

        res = [0, 1, 2, 3]
        for i in range(4, n + 1):
            res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)
        return res[n % 4]",O(n)
"class Solution(object):
    def countSmaller(self, nums):
        def countAndMergeSort(num_idxs, start, end, counts):
            if end - start <= 0: 
                return

            mid = start + (end - start) // 2
            countAndMergeSort(num_idxs, start, mid, counts)
            countAndMergeSort(num_idxs, mid + 1, end, counts)
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and num_idxs[r][0] < num_idxs[i][0]:
                    tmp.append(num_idxs[r])
                    r += 1
                tmp.append(num_idxs[i])
                counts[num_idxs[i][1]] += r - (mid + 1)

            num_idxs[start:start+len(tmp)] = tmp

        num_idxs = []
        counts = [0] * len(nums)
        for i, num in enumerate(nums):
            num_idxs.append((num, i))
        countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)
        return counts",O(nlogn)
"class Solution2(object):
    def countSmaller(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        sorted_nums = sorted(zip(nums, list(range(len(nums)))))
        lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)}

        result, bit = [0]*len(nums), BIT(len(nums))
        for i in reversed(range(len(nums))):
            result[i] = bit.query(lookup[i]-1)
            bit.add(lookup[i], 1)
        return result",O(nlogn)
"class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & (n - 1)) == 0",O(1)
"class Solution2(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & ~-n) == 0",O(1)
"class Solution(object):
    def isPowerOfFour(self, num):
        return num > 0 and (num & (num - 1)) == 0 and \
               ((num & 0b01010101010101010101010101010101) == num)",O(1)
"class Solution2(object):
    def isPowerOfFour(self, num):
        while num and not (num & 0b11):
            num >>= 2
        return (num == 1)",O(1)
"class Solution3(object):
    def isPowerOfFour(self, num):
        num = bin(num)
        return True if num[2:].startswith('1') and len(num[2:]) == num.count('0') and num.count('0') % 2 and '-' not in num else False",O(1)
"class Solution5(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][0]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][0])
            result = max(result, dp[i])
        return result",O(n ^ 2)
"class Solution6(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(ages, scores))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][1]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][1])
            result = max(result, dp[i])
        return result",O(n ^ 2)
"class Solution(object):
    def twoEggDrop(self, n):
        return int(math.ceil((-1+(1+8*n)**0.5)/2))",O(1)
"class Solution2(object):
    def twoEggDrop(self, n):
        K = 2
        dp = [[float(""inf"") for j in range(n+1)] for _ in range(2)]
        dp[1] = [j for j in range(n+1)]
        for i in range(2, K+1):
            dp[i%2][0] = 0
            for j in range(1, n+1):
                for k in range(1, j+1):
                    dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k]))
        return dp[K%2][n]",O(1)
"class Solution(object):
    def printLinkedListInReverse(self, head):
        def print_nodes(head, count):
            nodes = []
            while head and len(nodes) != count:
                nodes.append(head)
                head = head.getNext()
            for node in reversed(nodes):
                node.printValue()
                   
        count = 0
        curr = head
        while curr:
            curr = curr.getNext()
            count += 1
        bucket_count = int(math.ceil(count**0.5))
        
        buckets = []
        count = 0
        curr = head
        while curr:
            if count % bucket_count == 0:
                buckets.append(curr)
            curr = curr.getNext()
            count += 1
        for node in reversed(buckets):
            print_nodes(node, bucket_count)",O(n)
"class Solution2(object):
    def printLinkedListInReverse(self, head):
        nodes = []
        while head:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()",O(n)
"class Solution3(object):
    def printLinkedListInReverse(self, head):
        tail = None
        while head != tail:
            curr = head
            while curr.getNext() != tail:
                curr = curr.getNext()
            curr.printValue()
            tail = curr",O(n ^ 2)
"class Solution(object):
    def postorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in node.children:
                if child:
                    stack.append(child)
        return result[::-1]",O(n)
"class Solution2(object):
    def postorder(self, root):
        def dfs(root, result):
            for child in root.children:
                if child:
                    dfs(child, result)
            result.append(root.val)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"class Solution2(object):
    def largestSumAfterKNegations(self, A, K):
        A.sort()
        remain = K
        for i in range(K):
            if A[i] >= 0:
                break
            A[i] = -A[i]
            remain -= 1
        return sum(A) - (remain%2)*min(A)*2",O(nlogn)
"class Solution(object):
    def findMin(self, nums):
        left, right = 0, len(nums)
        target = nums[-1]

        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] <= target:
                right = mid
            else:
                left = mid + 1

        return nums[left]",O(logn)
"class Solution2(object):
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right and nums[left] >= nums[right]:
            mid = left + (right - left) / 2

            if nums[mid] < nums[left]:
                right = mid
            else:
                left = mid + 1

        return nums[left]",O(logn)
