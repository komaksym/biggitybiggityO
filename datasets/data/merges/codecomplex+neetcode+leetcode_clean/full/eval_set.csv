code,complexity
"def solve():
    l, r = map(int, input().split())

    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()
",O(logn)
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))",np
"l,r=map(int,input().split())
x=l^r
a=2
if(l==r):
    print(0)
else:
    while(a<=x):
        a=a*2

    print(a-1)",O(logn)
"a, b = input().split()
a = int(a)
b = int(b)
s = a ^ b
cnt = 0
while s != 0:
    s = int(s / 2)
    cnt = cnt + 1
print((2 ** cnt) - 1)",O(logn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n = int(z())
arr = set(zz())

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]

    for i in arr:
        return [i]

lst = solve()

print(len(lst))
for i in lst:
    output(i,' ')",O(nlogn)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        res = []
        for num in range(n + 1):
            one = 0
            for i in range(32):
                if num & (1 << i):
                    one += 1
            res.append(one)
        return res
",O(n)
"import math


class Solution(object):
    def getPermutation(self, n, k):
        seq, k, fact = """", k - 1, math.factorial(n - 1)
        perm = [i for i in range(1, n + 1)]
        for i in reversed(range(n)):
            curr = perm[k / fact]
            seq += str(curr)
            perm.remove(curr)
            if i > 0:
                k %= fact
                fact /= i
        return seq",O(n ^ 2)
"import sys

def get_new_edges(graph):
    n = len(graph)
    far_vertex = []
    pi = [None]*n
    visit = [False]*n
    visit[0]
    queue = [[0,0]]
    i = 0
    while True:
        if i >= len(queue): break
        current, d = queue[i]
        i += 1
        visit[current] = True
        for v in graph[current]:
            if not visit[v]:
                u = [v, d+1]
                pi[v] = current
                queue.append(u)
                if d+1 > 2:
                    far_vertex.append(u)

    far_vertex.sort(key=lambda x: -x[1])

    pos = [None]*n
    for i, e in enumerate(far_vertex):
        pos[e[0]] = i

    count = 0
    for i in range(len(far_vertex)):
        if not far_vertex[i]: continue
        vertex, depth = far_vertex[i]
        father = pi[vertex]
        count += 1
        if pos[father]:
            far_vertex[pos[father]] = None
        for u in graph[father]:
            if pos[u]:
                far_vertex[pos[u]] = None

    return count

def read_int_line():
    return map(int, sys.stdin.readline().split())

vertex_count = int(input())
graph = [[] for _ in range(vertex_count)]

for i in range(vertex_count - 1):
    v1, v2 = read_int_line()
    v1 -= 1
    v2 -= 1
    graph[v1].append(v2)
    graph[v2].append(v1)

print(get_new_edges(graph))
",O(n)
"class Solution2(object):
    def minOperationsToFlip(self, expression):
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else: 
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])",O(n)
"class Solution2(object):
    def integerBreak(self, n):
        if n < 4:
            return n - 1

        res = [0, 1, 2, 3]
        for i in range(4, n + 1):
            res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)
        return res[n % 4]",O(n)
"arra = []
arrb = []
arr = []
s = """"
temp = 1
value = ans = n = 0

def fill(myList = [], *args):
    for i in range(n):
        arra.insert(0,0)

def check():
    for i,j in zip(arra,arrb):
        if i == j:
            return 1
        else:
            return 0

def Engine1(num):
    if num > 1:
        Engine1(num // 2)
    arra.append( num%2 )
def Engine2(num):
    if num > 1:
        Engine2(num // 2)
    arrb.append( num%2 )

a,b = map(int,input().split())
Engine1(a)
Engine2(b)

n = abs(len(arra)-len(arrb))
if(len(arra)>len(arrb)):
    fill(arrb)
if(len(arra)<len(arrb)):
    fill(arra)

for i in range(len(arra)):
    if(check() == 0):
        break
    check()
    arra.pop(0)
    arrb.pop(0)

for i in range(len(arra)):
    ans += temp
    temp *= 2
print(ans)",O(logn)
"import sys

from bisect import bisect_left as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

for _ in range (1) :
    n = ii()

    x = 1
    i = 0

    while (x <= n) :
        x += (9*(i+1)*(10**i))
        i += 1

    x -= 9*i*(10**(i-1))

    y = str(10**(i-1) + (n-x)//i)

    print(y[(n-x)%i])
",O(logn)
"class Solution(object):
    def gameResult(self, head):
        cnt = 0
        while head:
            cnt += cmp(head.val, head.next.val)
            head = head.next.__next__
        return ""Tie"" if cnt == 0 else ""Odd"" if cnt < 0 else ""Even""",O(n)
"class Solution(object):
    def minimizeXor(self, num1, num2):
        def popcount(x):
            return bin(x)[2:].count('1')
        
        cnt1, cnt2 = popcount(num1), popcount(num2)
        result = num1
        cnt = abs(cnt1-cnt2)
        expect = 1 if cnt1 >= cnt2 else 0
        i = 0
        while cnt:
            if ((num1>>i)&1) == expect:
                cnt -= 1
                result ^= 1<<i
            i += 1
        return result",O(logn)
"class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize > box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result",O(nlogn)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        maxArea = 0
        stack = []

        for i in range(n + 1):
            while stack and (i == n  or heights[stack[-1]] >= heights[i]):
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                maxArea = max(maxArea, height * width)
            stack.append(i)
        return maxArea
",O(n)
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]",O(n)
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))

if __name__ == '__main__':
    main()
",np
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n=int(input())
l=list(map(int,input().split()))
fi=[""even"",""odd""]
q=defaultdict(int)
e=[0]*(n+1)
s=SegmentTree(e)
ans=0
for j in range(n):
    ans+=s.query(l[j]+1,n)
    s.__setitem__(l[j],1)
fi1=ans
for i in range(int(input())):
    a,b=map(int,input().split())
    a-=1
    b-=1
    fi1+=((b-a+1)*(b-a))//2
    print(fi[fi1%2])",O(n ^ 2)
"x, y, z, t1, t2, t3 = map(int, input().split())
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
stairs = t1 * abs(x - y)
if lift <= stairs:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import sys as _sys

_sys.setrecursionlimit(2**14)

_cache = dict()

class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)

def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)

def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []

    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]

    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]

    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area

def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])

def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)

        for i in range(len(nums)):
            res += i - nums[i]
        return res
",O(n)
"n=input()
ans=0
r,c=0,0
for i in range(len(n)):
    r+=int(n[i])
    c+=1
    if int(n[i])%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",O(n)
"import collections
from functools import cmp_to_key

import sys
def getIntList():
    return list(map(int, input().split()))

n,a,b = getIntList()
a0 = a
b0 = b
if a0>b0:
    a0,b0 = b,a
if n==2 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if n==3 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if a>1 and b>1:
    print('NO')
    sys.exit()

mat = [['0' for y in range(n)]for x in range(n)]
mat1 = [['1' for y in range(n)]for x in range(n)]
if b==1:
    for x in range(n-a):
        mat[x][x+1] = '1'
        mat[x+1][x] = '1'
else:
    mat = mat1
    for x in range(n):
        mat[x][x] = '0'
    for x in range(n-b):
        mat[x][x+1] = '0'
        mat[x+1][x] = '0'

print('YES')
for x in range(n):
    print(''.join(mat[x]))
",O(n ^ 2)
"x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",O(logn)
"class Solution3(object):
    def minimumAddedInteger(self, nums1, nums2):
        nums1.sort()
        nums2.sort()
        for i in range(3):
            d = nums2[-1]-nums1[~i]
            cnt = 0
            for j in range(len(nums2)):
                while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]:
                    cnt += 1
            if cnt <= 2:
                return d
        return -1",O(nlogn)
"for _ in range(int(input())):
    n, k = [int(x) for x in input().split()]
    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) // 3):
        print('NO')
    else:
        cn = n - 1
        ck = k - 1
        l = 1
        while cn * ck != 0 and ck >= 4 * l - 1:
            ck -= 4 * l - 1
            cn -= 1
            l *= 2
        print('YES', cn)",O(logn)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"stones = list(map(int,input().split()))
initial_sum = 0

def even_sum(arr):
    temp_sum = 0
    for each in arr:
        if(each%2 == 0):
            temp_sum += each

    return temp_sum

initial_sum = even_sum(stones)
dup_sum = initial_sum

for i in range(14):
    duplicate = list(stones)
    temp = stones[i]
    duplicate[i] = 0
    j = i

    for each in range(14):
        duplicate[each] += temp//14
    temp = temp%14
    while temp > 0 :
        if( j == 13):
            j = -1
        j += 1
        duplicate[j] += 1
        temp -= 1

    ts = even_sum(duplicate)
    if(ts > initial_sum ):
        initial_sum = ts

print(initial_sum)
",O(1)
"x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
E = set()
T = set()
F = {('x', x), ('y', y), ('z', z)}
prv = (set(), set(), set())
fam = 2 ** 8
tmpl = '
ans = [tmpl] * fam
def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:
            ans[e[1]] = e[0]
    return set((j, i) for i, j in enumerate(ans) if j != tmpl)
while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add(('!' + f[0], ~f[1] & (fam - 1)))
        T.add(f)
        for t in prv[1]:
            T.add((t[0] + '&' + f[0], t[1] & f[1]))
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add(('(' + e[0] + ')', e[1]))
        for t in prv[1]:
            E.add((e[0] + '|' + t[0], e[1] | t[1]))
    E, T, F = cmpr(E), cmpr(T), cmpr(F)
cmpr(E)
n = int(input())
for i in range(n):
	print(ans[int(input(), 2)])",O(n ^ 2)
"class Solution3(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        st = SegmentTree(len(val_to_idx))
        for i, x in enumerate(nums):
            v = max(st.query(0, val_to_idx[x-i]), 0)+x
            st.update(val_to_idx[x-i], v)
        return st.query(0, len(val_to_idx)-1)",O(nlogn)
"n = int(input())
a = [ int(x) for x in input().split() ]

dp = [ [-1] * (n+1) for _ in range(n+1) ]
for i in range(n):
    dp[i][i+1] = a[i]

for leng in range(2, n+1):
    for l in range(n+1):
        if l + leng > n: continue
        r = l + leng
        for mid in range(l+1, n+1):
            if dp[l][mid] != -1 and dp[l][mid] == dp[mid][r]:
                dp[l][r] = dp[l][mid] + 1

dp2 = [ float(""inf"") for _ in range(n+1) ]
for i in range(n+1):
    dp2[i] = i
    for j in range(i):
        if dp[j][i] != -1:
            dp2[i] = min(dp2[i], dp2[j] + 1)

print(dp2[n])
",O(n ^ 3)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
A.sort()

from collections import Counter
C=Counter(A)
dou=0

for c in C:
    dou+=C[c]-1

    if C[c]>=2 and C[c-1]!=0:
        print(""cslnb"")
        sys.exit()

if dou>=2:
    print(""cslnb"")
    sys.exit()

ANS=0
for i in range(n):
    if A[i]<i:
        print(""cslnb"")
        sys.exit()
    ANS+=(A[i]-i)%2

if ANS%2==0:
    print(""cslnb"")
    sys.exit()
else:
    print(""sjfnb"")
    sys.exit()
",O(nlogn)
"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
n,k=map(int,input().split())
c=0
for i in range(len(l)-1):
    if(l[i]+l[i+1]+1 in l and l[i]+l[i+1]+1<=n):
        c+=1
if(c>=k):
    print('YES')
else:
    print('NO')
",O(n)
"n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
hh = a[0][1]
wahh = max(-1, a[0][2])
for i in range(1, n):
    if a[i][1] >= hh:
        print(a[i][2], wahh)
        exit()
    else:
        hh = a[i][1]
        wahh = a[i][2]
print(-1, -1)
",O(nlogn)
"n = int(input())
s = list(str(input()))
t = list(str(input()))

from collections import Counter
cs = Counter(s)
ct = Counter(t)
if cs != ct:
    print(-1)
    exit()

xs = [[] for _ in range(26)]
xt = [[] for _ in range(26)]
for i in range(n):
    j = ord(s[i])-ord('a')
    xs[j].append(i)

for i in range(n):
    j = ord(t[i])-ord('a')
    xt[j].append(i)

x = [-1]*n
for i in range(26):
    for j, k in zip(xs[i], xt[i]):
        x[j] = k

ans = []
for i in range(n):
    for j in reversed(range(i+1, n)):
        if x[j-1] > x[j]:
            x[j-1], x[j] = x[j], x[j-1]
            ans.append(j)
print(len(ans))
print(*ans)",O(n ^ 2)
"class Solution(object):
    def orderlyQueue(self, S, K):
        if K == 1:
            return min(S[i:] + S[:i] for i in range(len(S)))
        return """".join(sorted(S))",O(n ^ 2)
"def main():
    n = int(input())
    piles = list(map(int,input().split()))
    piles.sort()
    num = piles[0]
    count = 1
    two = 0
    two_num = 0
    for i in range(1,n):
        if piles[i] == num:
            count += 1
        else:

            if count > 2:
                print('cslnb')
                return
            elif count == 2:
                two_num = num
                two += 1
            num = piles[i]
            count = 1

    if count == 2:
        two_num = num
        two += 1
    if count > 2:
        print('cslnb')
        return
    if two > 1:
        print('cslnb')
        return

    if two == 1:
        if (two_num-1) in piles:
            print('cslnb')
            return

    if n >= 2:
        if piles[0] == piles[1] and piles[0] == 0:
            print('cslnb')
            return
    moves = 0
    curr = 0
    for i in range(n):
        if piles[i] >= curr:
            moves += piles[i]-curr
            piles[i] = curr
            curr += 1

    for i in piles:
        if i > 0:
            moves += 1
            break

    if n == 1:
        moves += 1
    if moves%2 != 0:
        print('cslnb')
    else:
        print('sjfnb')

main()
",O(nlogn)
"n, s = map(int, input().split())

def binsearch(n, s):
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        digits = sum([int(i) for i in list(str(mid))])
        if mid - digits >= s:
            right = mid - 1
        else:
            left = mid + 1

    return right

print(max(0, n - binsearch(n, s)))
",O(logn)
"class Solution3(object):
    def minimumScore(self, nums, edges):
        def dfs(u, p, result):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total ^= dfs(v, u, result)
            result.append(total)
            return total
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            left = []
            dfs(u, v, left)
            right = []
            dfs(v, u, right)
            for candidates in (left, right):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"n, s = map(int, input().split())
res = 0
for i in range(n, 0, -1):
    res += s//i
    s = s % i
print(res)",O(n)
"def  getc():
    f = [[0]*500 for i in range(500)]
    for i in range(500):
        f[i][0] = 1
    f[1][0] = 1
    f[1][1] = 1
    for i in range(2,411):
        for j in range(1, i+1):
            f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod
    return f
n, mod = map(int, input().split())
f = [[0]*500 for i in range(500)]
c = getc()
mi_2 = [0]*500
mi_2[0] = 1
for i in range(1, 500):
    mi_2[i] = mi_2[i-1]*2%mod
for i in range(1, n+1):
    for j in range(0, i//2+1):
        if j == 0:
            f[i][j] = mi_2[i-1]
        else:
            for k in range(2, i):
                f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod
ans = 0
for i in range(0,n+1):
    ans = (ans + f[n][i])%mod
print(ans)
",O(n ^ 3)
"n = int(input())

dt = input()
s = dt.split()
a = [int(x) for x in s]
sortm = [int(x) for x in s]

sortm.sort()

cnt = 0

for i in range(n):
	if a[i] != sortm[i]:
		cnt += 1

if cnt <= 2:
	print(""YES"")
else:
	print(""NO"")
",O(nlogn)
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",O(n)
"class Solution(object):
    def visibleMountains(self, peaks):
        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1]))) 
        result = mx = 0
        for i in range(len(peaks)):
            if peaks[i][0]+peaks[i][1] <= mx:
                continue
            mx = peaks[i][0]+peaks[i][1]
            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:
                result += 1
        return result",O(nlogn)
"from collections import deque
from sys import stdin, stderr
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def signum(n):
    return 1 if n > 0 else 0 if n == 0 else -1

def range_includes(i, j):
    s = signum(j - i)
    return range(i, j + s, s)

def main():

    first = ints()
    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))
    minX = min(aCoord[0] for aCoord in aCoords)
    minY = min(aCoord[1] for aCoord in aCoords)
    maxX = max(aCoord[0] for aCoord in aCoords)
    maxY = max(aCoord[1] for aCoord in aCoords)
    def inFirst(x, y):
        return x >= minX and x <= maxX and y >= minY and y <= maxY

    second = ints()
    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))
    minSum = min(sum(bCoord) for bCoord in bCoords)
    maxSum = max(sum(bCoord) for bCoord in bCoords)
    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)
    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)
    def inSecond(x, y):
        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff

    for aCoord in aCoords:
        if inSecond(*aCoord):
            return True
    for i in range(-1, 3):
        c1 = bCoords[i]
        c2 = bCoords[i + 1]
        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):
            if inFirst(x, y):
                return True
    return False

if __name__ == '__main__':
    print(""YES"" if main() else ""NO"")
",O(1)
"import sys
input = sys.stdin.readline

def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def cint(c):
    return ord(c) - 96

def find_min_weight(n, k, stages):
    n = len(stages)
    min_weight = float('inf')

    def backtrack(s, w, t):
        nonlocal min_weight

        if t >= k:
            min_weight = min(min_weight, w)
            return

        if s >= n - 1:
            return

        for i in range(s+1, n, 1):
            if stages[i] - stages[s] > 1:
                backtrack(i, w+stages[i], t+1)

    backtrack(0, stages[0], 1)

    if min_weight == float('inf'):
        return -1

    return min_weight

n, k = inlt()
stages = list(set(map(cint, insr())))
stages.sort()
print(find_min_weight(n, k, stages))
",O(n)
"class Solution(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[1]-x[0]) 
        result = 0
        for a, m in tasks: 
            result = max(result+a, m)
        return result",O(nlogn)
"n, values, wrong = int(input()), [int(i) for i in input().split()], 0
sorted_values = list(sorted(values))
for i in range(n):
    if values[i] != sorted_values[i]:
        wrong += 1
if wrong > 2:
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"class Solution(object):
    def maxPartitionsAfterOperations(self, s, k):
        def popcount(n):
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
            return n

        left = [0]*(len(s)+1)
        left_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in range(len(s)):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            left[i+1] = cnt
            left_mask[i+1] = mask
        right = [0]*(len(s)+1)
        right_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in reversed(range(len(s))):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            right[i] = cnt
            right_mask[i] = mask

        result = 0
        for i in range(len(s)):
            curr = left[i]+right[i+1]
            mask = left_mask[i]|right_mask[i+1]
            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:
                curr += 3
            elif popcount(mask)+int(popcount(mask) != 26) > k: 
                curr += 2
            else:
                curr += 1
            result = max(result, curr)
        return result",O(n)
"n, m = map(int, input().split())
a = 0
while m:
    a += n//m
    n, m = m, n % m
print(a)
",O(1)
"n = int(input())

arr = [int(z) for z in list(input())]
ans = 0

if n == 2:
    if arr[0] == arr[1]:
        print(""YES"")
    else:
        print(""NO"")
    exit()

for l in range(1, n-1):
    s = sum(arr[:l])
    i = l
    v = [s]
    curr = 0
    while i < n:
        curr += arr[i]
        if i == n-1:
            if curr > s:
                curr -= arr[i]
                v.append(curr)
                curr = arr[i]
            v.append(curr)
        elif curr > s:
            curr -= arr[i]
            v.append(curr)
            curr = arr[i]
        i += 1

    if len(set(v)) == 1:
        print(""YES"")

        ans = 1
        exit()

if not ans:
    print(""NO"")
",O(n ^ 2)
"class Solution5(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][0]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][0])
            result = max(result, dp[i])
        return result",O(n ^ 2)
"class Solution(object):
    def subsequenceSumOr(self, nums):
        result = prefix = 0
        for x in nums:
            prefix += x
            result |= x|prefix
        return result",O(n)
"from sys import exit
N, M = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
B.sort()
mB = B[-1]
m2B = B[-2]
mG = min(G)
if mB > mG:
    print(-1)
    exit()
if mB == mG:
    print(sum(B)*M + sum(G) - mB * M)
    exit()
print(sum(B)*M + sum(G) - mB * M + mB - m2B)",O(nlogn)
"class Solution:
    def maxArea(self, heights: List[int]) -> int:
        res = 0
        for i in range(len(heights)):
            for j in range(i + 1, len(heights)):
                res = max(res, min(heights[i], heights[j]) * (j - i))
        return res
",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for x in nums:
            if x^(result&1):
                continue
            result += 1
        return result",O(n)
"def ints():
 return list(map(int,input().split()))
n,k=ints()
a,t=ints(),ints()
ans=sum(a[ii] for ii in range(n) if t[ii])
bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]
ll=0
rr=k
tmp=sws=sum(bb[:k])
while rr<n:
 sws-=bb[ll]
 sws+=bb[rr]
 ll+=1
 rr+=1
 tmp=max(tmp,sws)
ans+=tmp
print(ans)
",O(n)
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)
",O(n)
"import sys
import math

n, k = list(map(int, sys.stdin.readline().strip().split()))
a = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) // 2
print(int(a))",O(1)
"import sys
from collections import deque
import bisect
def chk(l,r,total):
    b = len(l)
    prev = 0
    i = 0
    f = 1
    cnt = 0
    while i < b:
        prev = prev+l[i]
        if cnt == total and prev == r:
            i = i+1
            continue

        if prev == r:
            cnt += 1
            if cnt != total:
                prev = 0

        i = i+1

    if cnt < total or i != b:
        f = 0

    return f

for _ in range(1):
    n = int(input())
    s = input()
    l = []
    som = 0
    for i in s:
        l.append(int(i))
        som += int(i)

    flag = 0
    for i in range(2,n+1):
        if som%i == 0:
            r = som//i
            if chk(l,r,i):
                flag = 1
                break

        if flag:
            break

    if flag:
        print(""YES"")

    else:
        print(""NO"")
",O(n ^ 2)
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())
        a = list(map(int, input().strip().split()))
        h = Counter()
        for ai in a:
            h[ai] = h[ai] + 1 if ai in h else 1
        days = 0
        while True:
            tot = 0
            for key, cnt in h.items():
                tot += cnt // (days + 1)
            if tot < n:
                print(days)
                return
            days += 1

solver()()",O(nlogn)
"N, K = input().split()
N, K = int(N), int(K)
P = [int(x) for x in input().split()]
A = [None]*256
A[0] = 0
for i in range(N):
    pn = P[i]
    if A[pn] is None:
        for j in range(K-1, -1, -1):
            if pn < j: continue
            if A[pn-j] is None:
                A[pn-j] = pn-j
                break
            else:
                if A[pn-j] + K - 1 >= pn:
                    break
        for jj in range(j, -1, -1):
            A[pn-jj] = A[pn-j]
print(*[A[P[i]] for i in range(N)])
",O(n ^ 2)
"class NextStringIndex:
    def __init__(self, string):
        self.INF = 10 ** 9
        self.alph = ""abcdefghijklmnopqrstuvwxyz""
        self.kind = len(self.alph)
        self.to_ind = {char: ind for ind, char in enumerate(self.alph)}

        self.string = string
        self.len_s = len(string)
        self.next_ = self.make_next()

    def __getitem__(self, tup):
        ind, char = tup
        return self.next_[ind][self.to_ind[char]]

    def make_next(self):
        dp = [[self.INF] * self.kind for i in range(self.len_s + 1)]
        for i in range(len_s)[::-1]:
            for j, char in enumerate(self.alph):
                if s[i] == char:
                    dp[i][j] = i + 1
                else:
                    dp[i][j] = dp[i + 1][j]
        return dp

def solve(t1, t2, len_s):
    INF = 10 ** 9
    len_t1 = len(t1)
    len_t2 = len(t2)
    dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)]
    dp[0][0] = 0

    for i in range(len_t1 + 1):
        for j in range(len_t2 + 1):
            length = dp[i][j]
            if length > len_s:
                continue
            if i < len_t1 and s_next[length, t1[i]] < INF:
                dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]])
            if j < len_t2 and s_next[length, t2[j]] < INF:
                dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]])

    return dp[-1][-1] < INF

query = int(input())
for _ in range(query):
    s = input()
    t = input()
    len_s = len(s)
    len_t = len(t)

    s_next = NextStringIndex(s)

    flag = False
    for i in range(len_t + 1):
        flag |= solve(t[0:i], t[i:], len_s)
    if flag:
        print(""YES"")
    else:
        print(""NO"")",O(n ^ 3)
"k = int(input())
n = 0
i = 0
while (k > n):
    n += pow(10, i) * 9 * (i + 1)
    i = i + 1
n -= pow(10, i - 1) * 9 * i
k -= n
t = (k - 1) / i
r = k % i
if (r == 0):
    r = i
m = pow(10, i - 1) + t
m = int(m)
ans = int(m / pow(10,i - r)) % 10
print(ans)

def pow(i):
    n = 1
    for x in range(0,i):
        n*=10
    return n
",O(logn)
"def matches(pos, c, case):
    if case==0:
        return pos%3==""RGB"".index(c)
    elif case==1:
        return pos%3==""GBR"".index(c)
    else:
        return pos%3==""BRG"".index(c)

q = int(input())
for _ in range(q):
    n, k = map(int, input().split())

    s = input()

    mglobal = k

    r=g=b=0

    for i, c in enumerate(s[:k]):

        r += not matches(i, c, 0)
        g += not matches(i, c, 1)
        b += not matches(i, c, 2)

    mglobal = min([mglobal, r, g, b])
    for i, c in enumerate(s[k:]):
        i+=k
        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))
        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))
        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))

        mglobal = min([mglobal, r, g, b])

    print(mglobal)
",O(n)
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",O(n ^ 3)
"class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]",O(1)
"class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(list(range(lo, hi+1)), key=power_value)[k-1]",O(nlogn)
"import math

l1 = input().split()

l1 = [int(i) for i in l1]

l2 = l1[1]
l1 = l1[0]

x=l1^l2;
y=1;
while(y<=x):
  y=y*2;

print(y-1);
",O(logn)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)
",O(nlogn)
"def solve():
    num_pixels, max_group_size = (int(x) for x in input().split())
    pixels = [int(x) for x in input().split()]
    groups = [None for _ in range(256)]

    for pixel in pixels:
        if groups[pixel] is None:
            smallest_of_group = pixel
            while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None:
                smallest_of_group -= 1

            if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size:
                group_color = groups[smallest_of_group]
            else:
                group_color = smallest_of_group + 1
            smallest_of_group += 1
            for color in range(smallest_of_group, pixel + 1):
                groups[color] = group_color

    print(*(groups[pixel] for pixel in pixels))

solve()
",O(n ^ 2)
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort()
    dic={}
    for a in arr:
        if a/k not in dic:
            dic[a]=1

    print(len(dic))

main()",O(nlogn)
"class Solution(object):
    def makeTheIntegerZero(self, num1, num2):
        def popcount(x):
            result = 0
            while x:
                x &= (x-1)
                result += 1
            return result

        for i in range(1, 60+1):
            if num1-i*num2 < 0:
                break
            if popcount(num1-i*num2) <= i <= num1-i*num2:
                return i
        return -1",O(1)
"n = int(input())
print(n, 0, 0)",O(1)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')
",O(n ^ 2)
"a,b,c = map(int,input().split())
arr = list(map(int,input().split()))

arr.sort()
p = 0
a-=1
while(a>=0 and c<b):
    c-=1
    p+=1
    c+=arr[a]
    a-=1
if(c<b):
    print(-1)
else:
    print(p)",O(nlogn)
"import sys

n, s = map(int, input().split())

ok, ng = 10**18+100, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    if mid - sum(map(int, str(mid))) >= s:
        ok = mid
    else:
        ng = mid

print(max(0, n - ok + 1))
",O(logn)
"from collections import defaultdict

class Solution(object):
    def firstUniqChar(self, s):
        lookup = defaultdict(int)
        candidtates = set()
        for i, c in enumerate(s):
            if lookup[c]:
                candidtates.discard(lookup[c])
            else:
                lookup[c] = i+1
                candidtates.add(i+1)

        return min(candidtates)-1 if candidtates else -1",O(n)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)

order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])

if len(order) == 0:    print(0); exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False
",O(nlogn)
"class Solution(object):
    def maximumDifference(self, nums):
        result, prefix = 0, float(""inf"")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1",O(n)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]
        curMin, curMax = 1, 1

        for num in nums:
            tmp = curMax * num
            curMax = max(num * curMax, num * curMin, num)
            curMin = min(tmp, num * curMin, num)
            res = max(res, curMax)
        return res
",O(n)
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))
        return op[r][g][b]

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]

print(f(l,r,g,b,op))
",O(n ^ 3)
"if __name__ == '__main__':
    cin = input
    n = int(cin())
    s, t = [*cin()], cin()
    i, r = 0, list()

    if sorted(s) != sorted(t):
        print(-1)
    else:
        while i < n:
            j = i
            while j < n and s[j] != t[i]:
                j += 1
            s[i:j + 1] = s[j:j + 1] + s[i:j]
            r.extend(range(j, i, -1))
            i += 1
        print(len(r))
        print(*r)",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    if a[i]>=0:
        a[i] = -a[i]-1
x = min(a)

if len(a)%2==1:
    for i in range(n):
        if a[i]==x:
            a[i] = -a[i]-1
            break
print(*a)",O(n)
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k
                pos=diff%c
                diff=int(diff/c)
                diff=decimal-diff
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                now = larr[pos][i:n]+larr[pos][0:i]
                nex = [max(now[j], lst[j]) for j in range(n)]
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)

if __name__ == ""__main__"":
    main()
",np
"class Solution2(object):
    def maximum69Number (self, num):
        return int(str(num).replace('6', '9', 1))",O(logn)
"import sys

def is_prime(x):
    return all(x%i for i in range(2, int(x**.5)+1))

t = int(sys.stdin.read().strip())
for i in range(4, t//2+1):
    if not is_prime(i) and not is_prime(t-i):
        print(i, t-i, sep=' ')
        break
",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))

def main():
    a,b = getints()
    print(result(a,b))

def result(a,b):
    if a==0 or b==0:
        return 0
    if a>b:
        return a//b+result(a%b,b)
    else:
        return b//a+result(b%a,a)

if __name__ == ""__main__"":
    main()",O(1)
"import os, sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
from math import ceil
mod = 10 ** 9 + 7

def get_original_pieces(x):
    common = (pow(x, 2) - 1) // 2
    first_piece = ""10""*common + '1'
    second_piece = '0' + ""10""*common
    return [first_piece, second_piece]

for _ in range(1):
    n = int(input())
    pieces = ["""" for _ in range(4)]
    original_pieces = get_original_pieces(n)
    i = 0
    for _ in range(3 + (n*4)):
        s = input()
        if s:
            pieces[i] += s
        else:
            i += 1

    till = pow(n, 2)
    fp = [[0,i] for i in range(4)]
    sp = [[0,i] for i in range(4)]
    for i in range(4):
        fpc, spc = 0, 0
        for j in range(till):
            if pieces[i][j] != original_pieces[0][j]:
                fpc += 1
            if pieces[i][j] != original_pieces[1][j]:
                spc += 1
        fp[i][0] = fpc
        sp[i][0] = spc
    fp.sort()
    sp.sort()
    ans1 = fp[0][0] + fp[1][0]
    ans2 = sp[0][0] + sp[1][0]
    for i in range(4):
        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]
        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]
    ans = min(ans1, ans2)
    print(ans)",O(n ^ 2)
"l, r = map(int, input().split())
target, final = l ^ r, 1
while target:
    target >>= 1
    final <<= 1
print(final - 1)
",O(logn)
"n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",O(n ^ 2)
"class Solution4(object):
    def rotate(self, nums, k):
        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]",O(n)
"n=int(input())
a=[0,0]+[int(x) for x in input().split()]
ans=[0]*(n+1)
for i in range(n,1,-1):
    if ans[i]==0:
        ans[i]=1
    ans[a[i]]+=ans[i]
if n==1:
    ans[1]=1
ans=ans[1:]
ans.sort()
print(*ans)",O(nlogn)
"l, r = (int(x) for x in input().split())
limit = l ^ r

if limit != 0:
  limit = len(bin(limit)) - 2
  maxXor = '1' * limit
  print(int(maxXor, 2))
else:
  print(0)
",O(logn)
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)",O(1)
"import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Solution(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num < num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Solution.P_DENOMINATOR) <= Solution.P_NUMERATOR and \
              level < Solution.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])",O(logn)
"n,k = map(int,input().split())
print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)
",O(1)
"class Solution(object):
    def beautySum(self, s):
        result = 0 
        for i in range(len(s)):
            lookup = [0]*26
            for j in range(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result",O(n ^ 2)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=arr.copy()
    ans.sort(reverse=True)
    ans=ans[:k]
    c=k
    print(sum(ans))
    j = 0
    for i in range(n):
        if (arr[i] in ans and c != 1):
            print(i + 1 - j, end=' ')
            j = i + 1
            ans.remove(arr[i])
            c -= 1
        if (c == 1):
            print(n - j)
            break",O(nlogn)
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x
print(""!"",a,b)
",O(1)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop,heapify
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

from itertools import accumulate
from functools import lru_cache

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]

a = val()
b = val()

n = len(str(a))

a = [int(i) for i in str(a)]
a.sort()
if len(str(b)) > n:

    print(*sorted(a, reverse = 1), sep = '')
    exit()

b = str(b)
b = [int(i) for i in b]

def makenum(s):return int(''.join(str(e) for e in s))

def givemax(a, b):
    if len(a) > len(b):return a
    elif len(b) > len(a):return b
    else:
        for j in range(len(a)):
            if a[j] > b[j]:return a
            elif b[j] > a[j]:return b
        return a

@lru_cache(None)
def dp(l, equal = 1):

    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])
    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))
    ans = ''
    l = list(l)
    curr = b[n - len(l)]
    for i in range(len(l)):
        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))
        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))

    return str(ans)

print(dp(tuple(a), 1))",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,m,k=map(int,input().split())
    if (k%2==0):
        DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k//2)]
        A=[]
        B=[]
        for i in range(n):
            L=list(map(int,input().split()))
            A.append(L)
            for j in range(m-1):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i][j+1]=min(L[j],DP[0][i][j+1])

        for i in range(n-1):
            L=list(map(int,input().split()))
            B.append(L)
            for j in range(m):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i+1][j]=min(DP[0][i+1][j],L[j])

        for k1 in range(1,k//2):
            for i in range(n):
                for j in range(m):
                    if (i>0):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j])
                    if (j>0):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1])
                    if (i<(n-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j])
                    if (j<(m-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1])

        for val in DP[(k//2)-1]:
            ans=[i*2 for i in val]
            print(*ans)

    else:
        for i in range(n):
            L=list(map(int,input().split()))

        for i in range(n-1):
            L=list(map(int,input().split()))

        for i in range(n):
            ans=[-1]*m
            print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",O(nlogn)
"class Solution(object):
    def zeroFilledSubarray(self, nums):
        result = 0
        prev = -1
        for i in range(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result",O(n)
"def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans

def main():
    n,q=map(int,input().split())
    arr=list(map(int,input().split()))
    brr=list(map(int,input().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()",O(nlogn)
"def naiveSolve():

    return

def main():

    t=int(input())
    allans=[]
    for _ in range(t):
        n,m=readIntArr()
        grid=[]
        for __ in range(n):
            grid.append(readIntArr())
        columns=[]
        for col in range(m):
            temp=[grid[i][col] for i in range(n)]
            columns.append(temp)

        valCol=[]
        for i in range(n):
            for j in range(m):
                valCol.append((grid[i][j],j))
        valCol.sort(reverse=True)

        topCols=set()
        for val,col in valCol:
            topCols.add(col)
            if len(topCols)==n:
                break

        m2=len(topCols)
        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]
        topColsList=list(topCols)
        for j in range(m2):
            col=topColsList[j]
            for i in range(n):
                grid2[i][j]=grid[i][col]
        ans=-inf
        for mask in range(n**m2):
            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]
            for col in range(m2):
                shift=mask%n
                for row in range(n):
                    grid3[row][col]=grid2[(shift+row)%n][col]
                mask//=n
            tempAns=0
            for row in range(n):
                maxx=-inf
                for col in range(m2):
                    maxx=max(maxx,grid3[row][col])
                tempAns+=maxx
            ans=max(ans,tempAns)
        allans.append(ans)

    multiLineArrayPrint(allans)

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(r):
    print('? {}'.format(r))
    sys.stdout.flush()
    return readIntArr()

def answerInteractive(adj,n):
    print('!')
    for u in range(1,n+1):
        for v in adj[u]:
            if v>u:
                print('{} {}'.format(u,v))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()",np
"n = int(input())
ans = 1+n//2
print(ans)
",O(1)
"class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n=int(input())
    s=list(input().strip())
    t=list(input().strip())
    res=True
    ans=[]
    for i in range(n):
        if s[i]==t[i]:
            continue
        else:
            ind=-1
            for j in range(i+1,n):
                if t[i]==s[j]:
                    ind=j
                    break
            if ind==-1:
                res=False
                break
            for j in range(ind-1,i-1,-1):
                ans.append(j+1)
                s[j],s[j+1]=s[j+1],s[j]
    if res:
        print(len(ans))
        print(*ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result",O(n)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *

n, a, b = map(int, input().split())
s = [int(x) for x in input().split()]
s.sort()
if s[b-1] == s[b]:
    print(0)
else:
    print(s[b] - s[b-1])",O(nlogn)
"N = 1030
MOD = int(1e9+7)
c = [[0] * N for i in range(N)]
for i in range(N):
    c[i][0] = 1
for i in range(1, N):
    for j in range(1, N):
        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD

arr = list(map(int, list(input())))
cnt = int(input())
if cnt == 0:
    print(1)
    exit()

dp = [0] * N
for i in range(2, N):
    dp[i] = dp[bin(i).count('1')] + 1
res = 0
for i in range(1, N):
    if dp[i] != cnt - 1:
        continue
    n, k = len(arr)-1, i
    for pos in range(len(arr)):
        if arr[pos] == 1:
            res = (res + c[n][k]) % MOD
            k -= 1
        n -= 1
    if n == -1 and k == 0:
        res += 1
if cnt == 1:
    res -= 1
print(res)",O(n)
"def cic(my_string):
	my_hash=set();
	max_v=-1<<256;
	for i in range(len(my_string)):
		empty=my_string[i]+''
		if empty in my_hash:
			max_v=max(max_v,len(empty))
		else:
			my_hash.add(empty)
		for j in range(i+1,len(my_string)):
			empty+=my_string[j]
			if empty not in my_hash:
				my_hash.add(empty)
			else:
				max_v=max(max_v,len(empty))
	return 0 if max_v<0 else max_v

def main():
	my_string=input()
	print(cic(my_string))

if __name__=='__main__':
	main()
",O(n ^ 3)
"from collections import defaultdict

n,k=[int(i) for i in input().strip().split()]
l=[int(i) for i in input().strip().split()]
if(k==1):
    print(n)
else:
    l.sort()
    ndict=defaultdict(list)
    for x in l:
        i=x
        while(i%k==0):
            i=i/k
        ndict[i].append(x)
    ans=0
    for i in ndict.values():
        count=0
        while(count<len(i)):
            if(count==len(i)-1):
                ans+=1
                break
            if(i[count]*k!=i[count+1]):
                ans+=1
                count+=1
            else:
                ans+=1
                count+=2
    print(ans)",O(nlogn)
"import itertools



class Solution(object):
    def makeSimilar(self, nums, target):
        nums.sort(key=lambda x: (x%2, x))
        target.sort(key=lambda x: (x%2, x))
        return sum(abs(x-y)//2 for x, y in zip(nums, target))//2",O(nlogn)
"n = int(input())

l = []
for i in range(n):
    c = list(map(int, input().split()))
    l.append(sum(c))

m = l[0]
l.sort(reverse=True)
for i in range(len(l)):
    if m == l[i]:
        print(i+1)
        break
",O(n)
"n=int(input())
S=[]
for i in range(n):
    A=[int(i) for i in input().split()]
    S.append(sum(A))
if S[0]==max(S):
    print(""1"")
    exit()
thomas=S[0]
rank=1
S.sort(reverse=True)
for i in S:
    if i == thomas:
        print(rank)
        exit()
    else:
        rank+=1",O(n)
"k = int(input())

if k <= 9:
	print(k)

else:
	s = 9
	n = 1

	while s < k:
		n += 1
		prev_s = s
		s += (10**n - 10**(n-1)) * n

	digit_pos = k - (prev_s + 1)
	number = 10**(n-1) + digit_pos // n

	if digit_pos / n != digit_pos // n:
		digit_pos = digit_pos - (digit_pos // n) * n

	else:
		digit_pos = 0

	print(str(number)[digit_pos])",O(logn)
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",O(n)
"def bin(a):
    if a <= 1:
        return a
    else:
        return 10*bin(a//2)+a%2

def convBin(a):
    k,i = 0,0
    while a!=0:
        k += (a%10)*int((2**i))
        a //= 10
        i += 1
    return k

def maxi(a,b):
    if a == b:
        return 0
    elif a+1 == b:
        return a^b
    elif a+2 == b:
        x = a^(a+1)
        y = a^(a+2)
        z = (a+1)^(a+2)
        return max(max(x,y),z)
    else:
        x = str(bin(a^b))
        y = '1'*len(x)
        return convBin(int(y))
a = list(map(int,input().split()))
print(maxi(a[0],a[1]))
",O(logn)
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",O(logn)
"n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)",O(n)
"
class Node(object):
    def __init__(self, val, next):
        self.val = val
        self.next = next


class Solution(object):
    def insert(self, head, insertVal):
        def insertAfter(node, val):
            node.next = Node(val, node.next)
        
        if not head:
            node = Node(insertVal, None)
            node.next = node
            return node

        curr = head
        while True:
            if curr.val < curr.next.val:
                if curr.val <= insertVal and \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            elif curr.val > curr.next.val:
                if curr.val <= insertVal or \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            else:
                if curr.__next__ == head:
                    insertAfter(curr, insertVal)
                    break
            curr = curr.__next__
        return head

",O(n)
"MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")
",O(n)
"import math

def sequence_split_up(sequence):
    ans=[0,0,0]
    for i in sequence:
        if i=='+':
            ans[0]+=1
        elif i=='-':
            ans[1]+=1
        elif i=='?':
            ans[2]+=1
    return ans

def probability():
    actual_sequence=sequence_split_up(drazil_send)
    sequence_received=sequence_split_up(dreamoon_received)
    total_len=sum(actual_sequence)
    actual_ans=actual_sequence[0]-actual_sequence[1]
    ans_received=sequence_received[0]-sequence_received[1]
    difference=actual_ans-ans_received
    no_of_blanks=sequence_received[2]
    if no_of_blanks==0:
        if actual_ans!=ans_received:
            return 0
        return 1
    if abs(difference)>no_of_blanks:
        return 0
    ans_set=[0,0]
    if difference>0:
        ans_set[0]+=difference
    elif difference<0:
        ans_set[1]+=abs(difference)
    blanks_left=no_of_blanks-abs(difference)
    ans_set[0]=ans_set[0]+blanks_left//2
    ans_set[1]=ans_set[1]+blanks_left//2
    x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks)
    return x

drazil_send=input()
dreamoon_received=input()
print(""%.12f""%probability())
",np
"import os,sys
from io import BytesIO,IOBase
from collections import Counter

def main():
    n,k = map(int,input().split())
    a = input().split()
    a1 = list(map(int,a))
    dct = [Counter() for _ in range(11)]
    for i in range(n):
        dct[len(a[i])][a1[i]%k] += 1
    ans = 0
    for i in range(n):
        x = a1[i]
        for j in range(1,11):
            x = (x*10)%k
            if x:
                ans += dct[j][k-x]
            else:
                ans += dct[j][0]
        if not (a1[i]*(pow(10,len(a[i]),k)+1))%k:
            ans -= 1
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(nlogn)
"m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))

ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0
        for j in range(n):
            if a[i][j]>=tang:

                temp+=(1<<j)

        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1

        tocheck = mask ^ temp

        if tocheck in dic:
            return dic[tocheck],i,True

    return -1,-1,False

while ina<mo-1:

    tang=(ina+mo)//2

    temppos1,temppos2,status=check(tang)

    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
",np
"class Solution4(object):
    def trap(self, height):
        result = 0
        stk = []
        for i in range(len(height)):
            prev = 0
            while stk and height[stk[-1]] <= height[i]:
                j = stk.pop()
                result += (height[j] - prev) * (i - j - 1)
                prev = height[j]
            if stk:
                result += (height[i] - prev) * (i - stk[-1] - 1)
            stk.append(i)
        return result",O(n)
"import collections



class Solution(object):
    def countGood(self, nums, k):
        result = curr = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            curr += cnt[nums[right]]
            cnt[nums[right]] += 1
            while curr >= k:
                cnt[nums[left]] -= 1
                curr -= cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"n=int(input())
arr=list(map(int,input().split()))
arr.sort()
ans=0
mark=0
for i in range(len(arr)-2):
	if(arr[i]==arr[i+1]==arr[i+2]):
		print('cslnb')
		exit(0)
	elif(arr[i+1]==arr[i+2] and arr[i]+1==arr[i+1]):
		print('cslnb')
		exit(0)

countcopy=0
for i in range(len(arr)-1):
	if(arr[i]==arr[i+1] and arr[i]==0):
		print('cslnb')
		exit(0)
	if(arr[i]==arr[i+1]):
		countcopy+=1
if(countcopy>1):
	print('cslnb')
	exit(0)

for i in range(len(arr)):
	if(arr[i]>=mark):
		ans+=(arr[i]-mark)
		mark+=1

if(ans%2==0):
	print('cslnb')
else:
	print('sjfnb')
",O(nlogn)
"import sys,os,io
import math,bisect,operator
inf,mod = float('inf'),10**9+7

from itertools import groupby,accumulate
from heapq import heapify,heappop,heappush
from collections import deque,Counter,defaultdict
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
Neo = lambda : list(map(int,input().split()))

A = sorted(Neo())
B = [0]*100
for i in A:
    j = 0
    for c in range(100):
        if B[c] == 0:
            j = c
            break

    while j < 100:
        B[j] = 1
        j += i
if B.count(0) == 0:
    print('YES')
else:
    print('NO')
",O(1)
"class Solution(object):
    def makeIntegerBeautiful(self, n, target):
        total, m = 0, n
        while m:
            total += m%10
            m //= 10
        m, l = n, 0
        while total > target:
            while True:
                total -= m%10
                m //= 10
                l += 1
                if m%10 != 9:
                    break
            total += 1
            m += 1
        return m*10**l-n",O(logn)
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",O(n ^ 3)
"import math
a = str(input())
b = str(input())
posa = a.count('+') - a.count('-')
posb = b.count('+') - b.count('-')
q = b.count('?')
dist = (posa - posb)
ones = (abs(dist) + q) / 2
if q < abs(dist) or ((dist+q) % 2):
    ans = 0
else:
    ans = float(math.factorial(q)/(math.factorial(ones)*math.factorial(q-ones)))
    ans /= pow(2, q)
print(f'{ans:.9f}')
",np
"n,m=map(int,input().split())
a=0
while m:a+=n//m;n,m=m,n%m
print(a)",O(1)
"n = int(input())
arr = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = arr[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans += (mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",O(nlogn)
"class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \
                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):
                flowerbed[i] = 1
                n -= 1
            if n <= 0:
                return True
        return False",O(n)
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n,s=rinput()
maxi=s
for i in range(n):
    f,t=rinput()
    maxi=max(maxi,f+t)

print(maxi)",O(n)
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):

        if grid[i - 1][j] == '
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):

    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)
        self.__vals = []
        self.__pos = -1

    def hasNext(self):
        return self.__pos+1 != len(self.__vals) or self.__stk

    def __next__(self):
        self.__pos += 1
        if self.__pos == len(self.__vals):
            node = self.__stk.pop()
            self.__traversalLeft(node.right)
            self.__vals.append(node.val)
        return self.__vals[self.__pos]
        
    def hasPrev(self):
        return self.__pos-1 >= 0

    def prev(self):
        self.__pos -= 1
        return self.__vals[self.__pos]
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left",O(1)
"import string


class Solution(object):
    def validIPAddress(self, IP):
        blocks = IP.split('.')
        if len(blocks) == 4:
            for i in range(len(blocks)):
                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \
                   (blocks[i][0] == '0' and len(blocks[i]) > 1):
                    return ""Neither""
            return ""IPv4""

        blocks = IP.split(':')
        if len(blocks) == 8:
            for i in range(len(blocks)):
                if not (1 <= len(blocks[i]) <= 4) or \
                   not all(c in string.hexdigits for c in blocks[i]):
                    return ""Neither""
            return ""IPv6""
        return ""Neither""",O(1)
"
import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):
        row_maxes = [max(row) for row in grid]
        col_maxes = [max(col) for col in zip(*grid)]

        return sum(min(row_maxes[r], col_maxes[c])-val \
                   for r, row in enumerate(grid) \
                   for c, val in enumerate(row))

",O(n ^ 2)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        mp = defaultdict(int)
        for i in intervals:
            mp[i.start] += 1
            mp[i.end] -= 1
        prev = 0
        res = 0
        for i in sorted(mp.keys()):
            prev += mp[i]
            res = max(res, prev)
        return res
",O(nlogn)
"from queue import Queue
n = int(input())
g = [set() for i in range(n+1)]
for i in range(n-1):
    u, v = map(int, input().split())
    g[u].add(v)
    g[v].add(u)

a = list(map(int, input().split()))
if a[0] != 1:
    print(""No"")
    exit()
ptr = 0
i = 1

while i < n:
    par = a[ptr]
    while len(g[par]) != 0:
        if a[i] not in g[par]:
            print(""No"")
            exit()
        else:
            g[par].remove(a[i])
            g[a[i]].remove(par)
        i += 1
    ptr += 1
print(""Yes"")
",O(n ^ 2)
"k1, k2, k3  = sorted(map(int, input().split()))

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",O(1)
"n, k = map( int, input().split() )

d = n - k
d = d // 2

l = []

while n > 0:
    i = min(n,d)
    while i>0:
        l.append('1')
        i -= 1
        n -= 1
    if n > 0:
        l.append('0')
        n -= 1

print( """".join( l ) )",O(n ^ 2)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x: x[1])
        n = len(intervals)
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]

            res = 1
            for j in range(i + 1, n):
                if intervals[i][1] <= intervals[j][0]:
                    res = max(res, 1 + dfs(j))
            memo[i] = res
            return res

        return n - dfs(0)
",O(n ^ 2)
"from collections import defaultdict as dd, deque
import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,q = map(int,input().split())
S = [int(x) for x in input().split()]
Q = deque(S)

n = len(Q)
res = []
for i in range(n):
    a = Q.popleft()
    b = Q.popleft()
    Q.appendleft(max(a,b))
    Q.append(min(a,b))
    res.append((a,b))

A = list(Q)

def solve(t):
    if t < len(res):
        return res[t-1]
    t -= len(res) + 1
    t %= n-1
    return A[0],A[t+1]

for _ in range(q):
    t = int(input())
    print(*solve(t))
",O(n)
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]

INF = 10000

def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"class Solution2(object):
    def findChampion(self, n, edges):
        lookup = {v for _, v in edges}
        return next(u for u in range(n) if u not in lookup) if len(lookup) == n-1 else -1",O(n)
"a,b,c=list(map(int,input().split()))
R=list(map(int,input().split()))
G=list(map(int,input().split()))
B=list(map(int,input().split()))
dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]

R.sort()
G.sort()
B.sort()
for i in range(len(R)+1):
    for j in range(len(G)+1):
        for k in range(len(B)+1):
            if(i and j):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if(j and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if(i and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
print(dp[len(R)][len(G)][len(B)])",O(n ^ 3)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])",O(n ^ 2)
"n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",O(n ^ 3)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False
",O(n)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )

def main():
    n, m, k = map(int, input().split())
    a = list(map(float, input().split()))
    add = [[0] * n for _ in range(n + 1)]
    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):
        add[xi - 1][yi - 1] = float(ci)

    minf = float('-inf')
    dp = [[minf] * (2**n) for _ in range(n + 1)]
    dp[n][0] = 0.0

    for bitset in range(2**n):
        if bin(bitset).count('1') >= m:
            continue

        for i in range(n + 1):
            if dp[i][bitset] == minf:
                continue
            for j in range(n):
                if (1 << j) & bitset:
                    continue
                dp[j][bitset | (1 << j)] = max(
                    dp[j][bitset | (1 << j)],
                    dp[i][bitset] + a[j] + add[i][j]
                )

    print(int(max(max(_dp) for _dp in dp) + 1e-7))

if __name__ == '__main__':
    main()
",np
"class Solution(object):
    def mincostTickets(self, days, costs):
        durations = [1, 7, 30]
        W = durations[-1]
        dp = [float(""inf"") for i in range(W)]
        dp[0] = 0
        last_buy_days = [0, 0, 0]
        for i in range(1,len(days)+1):
            dp[i%W] = float(""inf"")
            for j in range(len(durations)):
                while i-1 < len(days) and \
                      days[i-1] > days[last_buy_days[j]]+durations[j]-1:
                    last_buy_days[j] += 1 
                dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j])
        return dp[len(days)%W]",O(n)
"import sys,os,io
from math import log, gcd
from collections import defaultdict, deque
from heapq import heappush, heappop

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

t = 1
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    l1.sort()
    pos = []
    for i in range(n):
        if (l1[i]!=l[i]):
            pos.append(i)
    if (len(pos)==0) or (len(pos)==2 and l[pos[0]]==l1[pos[1]] and l[pos[1]]==l1[pos[0]]):
        print(""YES"")
    else:
        print(""NO"")
",O(nlogn)
"N, K = map(int, input().split())
A = [int(a) for a in input().split()]
D = sorted([A[i+1]-A[i] for i in range(N-1)])
print(A[-1]-A[0]-(sum(D[-K+1:]) if K-1 else 0))
",O(nlogn)
"import bisect



class Solution4(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for right, (_, r) in enumerate(tiles):
            l = r-carpetLen+1
            left = bisect.bisect_right(tiles, [l])
            if left-1 >= 0 and tiles[left-1][1]+1 >= l:
                left -= 1
            extra = max(l-tiles[left][0], 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result",O(nlogn)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
q={0}
e=0
l=[]
for i in range(n):
    if a[i] not in q:
        e+=1
        q.add(a[i])
    if e==k:
        e=0
        q={0}
        l+=[i]
w=10**5
t=0
for i in l:
    e=0
    q={0}
    for j in range(i,-1,-1):
        if a[j] not in q:
            e+=1
            q.add(a[j])
        if e==k:
            if w>len(q):
                w=j+1
                t=i+1
            break
if len(set(a))>=k:print(w,t)
else:print(-1,-1)
",O(n)
"import sys
import math
def rec(i,n,l):

    if i == n:
        return []

    else:
        x = l2[i]
        flag = 0
        o = []
        p = []
        mi = -1
        for j in l:
            if j < x:
                if j > mi:
                    if i == 0 and j == 0:
                        o.append(j)
                        p.append(j)
                        continue

                    mi = j

            if x == j:
                flag = 1

            o.append(j)
            p.append(j)

        if flag:
            o.remove(x)

        if mi == -1 and flag == 0:
            return []

        ans1 = []
        if flag:

            ans1 = [x]+rec(i+1,n,o)

        if mi != -1:
            p.remove(mi)

        p.sort(reverse = True)
        ans2 = [mi]+p
        if len(ans1) == n-i:
            return ans1

        else:
            return ans2

for _ in range(1):
    a = int(input())
    b = int(input())
    e1 = str(a)
    e2 = str(b)
    l1 = []
    l2 = []
    for i in e1:
        l1.append(int(i))

    for i in e2:
        l2.append(int(i))

    if len(l1) < len(l2):
        l1.sort(reverse = True)
        o = []
        for i in l1:
            o.append(str(i))

        print("""".join(o))

    else:
        n = len(l2)
        ans = rec(0,n,l1)
        w = []
        for i in ans:
            w.append(str(i))

        print("""".join(w))",O(n ^ 3)
"class Solution3(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        H, W = 0, 1
        table = [[[0, 0] for j in range(len(matrix[0]))] \
                         for i in range(len(matrix))]
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == '1':
                    h, w = 1, 1
                    if i + 1 < len(matrix):
                        h = table[i + 1][j][H] + 1
                    if j + 1 < len(matrix[i]):
                        w = table[i][j + 1][W] + 1
                    table[i][j] = [h, w]

        s = [[0 for j in range(len(matrix[0]))] \
                for i in range(len(matrix))]
        max_square_area = 0
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                side = min(table[i][j][H], table[i][j][W])
                if matrix[i][j] == '1':
                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                        side = min(s[i + 1][j + 1] + 1, side)
                    s[i][j] = side
                    max_square_area = max(max_square_area, side * side)

        return max_square_area",O(n ^ 2)
"import sys, os.path
if(os.path.exists('input.txt')):
	sys.stdin = open(""input.txt"",""r"")

t = int(input())
last = []
current = []

for i in range(t):
	last.append(str(input()))
for i in range(t):
	current.append(str(input()))

for i in range(len(last)):
	if last[i] in current:
		current[current.index(last[i])] = ""*""
		last[i] = ""*""

last.sort()
current.sort()

total = 0
for i in range(len(last)):
	if last[i] == current[i]:
		continue
	else:
		total+=1

print(total)
",O(n)
"class Solution(object):
    def canAttendMeetings(self, intervals):
        intervals.sort(key=lambda x: x[0])

        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i-1][1]:
                return False
        return True",O(nlogn)
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",O(n ^ 3)
"def next(A,n, x):
    l = 0
    r = n-1
    p = -1
    while l <= r:
        m = (l+r)//2

        if A[m] <= x:
            l = m+1
        else:
            p = m
            r = m-1
    return p

N, Q = map(int, input().split())

A = list(map(int, input().split()))
B = list(map(int, input().split()))

P = []
P.append(A[0])

for i in range(1, N):
    P.append(P[i-1] + A[i])

soldiers = P[-1]
arrows = 0

for q in range(Q):

    arrows += B[q]
    if arrows >= soldiers:
        arrows = 0
        print(N)
    else:
        ind = next(P, N, arrows)
        print(N- ind)
",O(nlogn)
"import itertools

kol1 = {'+': 0, '-': 0, '?': 0}
kol2 = {'+': 0, '-': 0, '?': 0}

s1 = input()
s2 = input()

for s in s1:
    kol1[s] += 1

for s in s2:
    kol2[s] += 1

if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):
    print('1.0')
    exit()

mod1 = kol1['+'] - kol1['-']
mod2 = kol2['+'] - kol2['-']
mod3 = abs(mod2-mod1)
if (mod3>kol2['?']):
    print(0.0)
    exit()

list_comb = [1, -1]
sum_pos = 0
col = 0

for comb in itertools.product(list_comb, repeat=kol2['?']):
    if sum(comb)==mod3:
        sum_pos += 1
    col+=1

print(sum_pos/col)",np
"class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in range(R+1))",O(1)
"class Solution(object):
    def maxSubarrayLength(self, nums):
        stk = []
        for i in reversed(range(len(nums))):
            if not stk or nums[stk[-1]] > nums[i]:
                stk.append(i)
        result = 0
        for left in range(len(nums)):
            while stk and nums[stk[-1]] < nums[left]:
                result = max(result, stk.pop()-left+1)
        return result",O(n)
"import os,sys
from io import BytesIO, IOBase

def main():
    a,b,c,n = map(int,input().split())
    if a+b-c > n-1 or min(a,b) < c:
        print(-1)
    else:
        print(n-(a+b-c))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(1)
"class Solution_TLE(object):
    def find132pattern(self, nums):
        for k in range(len(nums)):
            valid = False
            for j in range(k):
                if nums[j] < nums[k]:
                    valid = True
                elif nums[j] > nums[k]:
                    if valid:
                        return True
        return False",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",O(nlogn)
"class Solution2(object):
    def countSubarrays(self, nums):
        result = left = 0
        for right in range(len(nums)):
            if not (right-1 >= 0 and nums[right-1] < nums[right]):
                left = right
            result += right-left+1
        return result",O(n)
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",O(n ^ 2)
"def tonum(count):
    return (count - 1) // 3

def check(n, k, logdivl):
    divl = 2**logdivl

    min_k = 2**(logdivl+1) - 2 - logdivl

    max_k = tonum(divl * divl + (divl * divl - (2*divl - 1)) * ((2**(n-logdivl))**2 - 1))

    return min_k <= k <= max_k

def main(n, k):
    if k == 1:
        return n - 1

    if n > 100:
        return n - 1

    if ((2 ** (n-1)) ** 2 - 1) // 3 + 1 >= k:
        return n -1

    for logdivl in range(1, n+1):
        if check(n, k, logdivl):
            return n - logdivl

    return None

t = int(input())
for i in range(t):
    n, k  = list(map(int, input().split()))
    ans = main(n, k)
    if ans is not None:
        print(""YES {}"".format(ans))
    else:
        print(""NO"")
",O(logn)
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007

z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",O(logn)
"import itertools



class Solution(object):
    def isAcronym(self, words, s):
        return len(words) == len(s) and all(w[0] == c for w, c in zip(words, s))",O(n)
"import collections



class Solution2(object):
    def treeQueries(self, root, queries):
        def dfs(curr, d):
            if not curr:
                return 0
            h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1))
            if h > top[d][0]:
                top[d][0], top[d][1] = h, top[d][0]
            elif h > top[d][1]:
                top[d][1] = h
            depth[curr.val], height[curr.val] = d, h
            return h
        
        top = collections.defaultdict(lambda: [0]*2)
        depth, height = {}, {}
        dfs(root, 0)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))",O(n)
"class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result",O(n)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
if l[0]!=0 or r[n-1]!=0:
    print(""NO"")
    exit(0)
s=[(l[i]+r[i]) for i in range(n)]
m=max(s)+1
k=[]
for i in s:
    k.append(m-i)
l1=[]
r1=[]

for i in range(n):
    c=0
    d=0
    for j in range(0,i):
        if k[j]>k[i]:
            c+=1
    l1.append(c)
    for j in range(i+1,n):
        if k[j]>k[i]:
            d+=1
    r1.append(d)
if l1!=l or r1!=r:
    print(""NO"")
else:
    print(""YES"")
    print(*k)
",O(n ^ 2)
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
",O(logn)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)
        stack = []
        for p, s in pair:
            stack.append((target - p) / s)
            if len(stack) >= 2 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)
",O(nlogn)
"def detect_cycle(n,edges):
        visited = [False]*n
        stack = []
        color = [0]*n
        for v in range(n):
            if not visited[v]:
                if dfs_visit(v,edges,visited,stack,color):
                    return stack
        return None

def dfs_visit(v,edges,visited,stack,color):
        visited[v] = True
        stack.append(v)
        color[v] = 1
        for u in edges[v]:
            if not visited[u]:
               if dfs_visit(u,edges,visited,stack,color):
                   return True

            elif color[u] == 1:
                stack.append(u)
                return True

        color[v] = 2
        stack.pop(stack.index(v))
        return False

if __name__ == '__main__':
        n,m = map(int,input().split())
        edges = [[] for i in range(n)]
        for _ in range(m):
            u,v  = map(int,input().split())
            edges[u - 1].append(v - 1)

        inCycle = detect_cycle(n,edges)
        if inCycle:
            possible = False
            index = inCycle.index(inCycle[-1])
            inCycle = inCycle[index:]
            for v in range(len(inCycle) - 1):
                edges[inCycle[v]].remove(inCycle[v + 1])
                if detect_cycle(n,edges) is None:
                    possible = True
                    break
                else:
                    edges[inCycle[v]].append(inCycle[v + 1])
        else: possible = True
print('YES' if possible else 'NO')
",O(n ^ 2)
"n = int(input())

if n>=2:
    print(25)
",O(1)
"def go():
    n = int(input())
    for i in range(n):
        a, b, d = [int(i) for i in input().split(' ')]
        if a > d or b > d:
            print(-1)
        elif a % 2 == b % 2:
            if a % 2 == d % 2:
                print(d)
            else:
                print(d - 2)
        else:
            if a % 2 == b % 2:
                if d % 2 == a % 2:
                    print(d)
                else:
                    print(d - 2)
            else:
                print(d - 1)
go()
",O(1)
"n,m = map(int,input().split())
print(n*""8"")
print((n-1)*""1""+""2"")",O(1)
"import itertools


class Solution(object):
    def gridGame(self, grid):
        result = float(""inf"")
        left, right = 0, sum(grid[0])
        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result",O(n)
"n, l, r, x = map(int, input().split())
C = sorted(list(map(int, input().split())))
ANS = 0
for i in range(2 ** n):
    s = bin(i)[2:]
    s = '0' * (n - len(s)) + s
    L = []
    for j in range(n):
        if s[j] == '1':
            L.append(C[j])
    if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x:
        continue
    ANS += 1
print(ANS)
",np
"class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result",O(n ^ 2)
"m=[x for x in input().split()]
tiles=[[0 for i in range(9)] for j in range(3)]
for i in range(len(m)):
    g=int(m[i][0])-1
    h=(m[i][1])
    if h==""m"":
        tiles[0][g]+=1
    elif h==""p"":
        tiles[1][g]+=1
    else:
        tiles[2][g]+=1
if m[0]==m[1] and m[1]==m[2]:
    print(0)
elif m[0]==m[1]:
    print(1)
elif m[0]==m[2]:
    print(1)
elif m[1]==m[2]:
    print(1)
else:
    n=False
    for i in range(3):
        for j in range(9):
            if tiles[i][j]!=0:
                if j!=8 and tiles[i][j+1]!=0:
                    if j!=7 and tiles[i][j+2]!=0:
                        print(0)
                        n=True
                        break
                    else:
                        print(1)
                        n=True
                        break
                elif j!=7 and j!=8 and tiles[i][j+2]!=0:
                    print(1)
                    n=True
                    break
    if n==False:
        print(2)",O(n)
"import sys

def rl(proc=None):
    if proc is not None:
        return proc(sys.stdin.readline())
    else:
        return sys.stdin.readline().rstrip()

def srl(proc=None):
    if proc is not None:
        return list(map(proc, rl().split()))
    else:
        return rl().split()

def main():
    rl()
    a = srl(int)
    a.sort()
    cnt = 0
    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            a[i] -= 1
            cnt += 1
            break
    if a[0] < 0:
        print('cslnb')
        return

    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            print('cslnb')
            return

    for i, x in enumerate(a):
        cnt += x - i

    print('sjfnb' if (cnt & 1) else 'cslnb')

if __name__ == '__main__':
    main()
",O(n)
"n,m = map(int,input().split())

a = list(map(int,input().split()))
b = list(map(int,input().split()))

r = []

for i in a:
    if i in b:
        r.append(i)
print(' '.join(map(str, r)))
",O(n ^ 2)
"class Solution3(object):
    def countPairs(self, nums, k):
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.values() for i in range(len(idx)) for j in range(i+1, len(idx)))",O(n ^ 2)
"MOD=1000000007
def pow2(n):
    if n==0:
        return 1
    t=pow2(n//2)%MOD
    m=(t*t)%MOD
    if n%2==1:
        m=(m*2)%MOD
    return m
x,k=map(int,input().split())
if x==0:
    print(0)
    exit()
t=pow2(k)*(2*x-1)%MOD
print((t+1)%MOD)
",O(logn)
"import math
n=int(input())
columns=list(map(int, input().rstrip().split()))

modcolumns=[i%2 for i in columns]

test=0

previouslist=[]

for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])

    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()

    else:
        previouslist.append(modcolumns[i])

if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"n,m = list(map(int,input().split()))
l = []
for i in range(n) :
    s = input()
    l.append(s)
x1=0
x2=0
y1=0
y2=0
for i in range (n) :
    for j in range(m) :
        if l[i][j]=='B' :
            if x1==0 and y1==0 :
                x1,y1 = [i+1,j+1]
            else :
                x2,y2 = [i+1,j+1]
res = []
x=0
y=0
if x2!=0 :
    x = (x2 - x1) // 2
    y = (y2 - y1) // 2
res.append(x1+x)
res.append(y1+y)
print(*res)",O(n ^ 2)
"class Solution2(object):
    def isCompleteTree(self, root):
        prev_level, current = [], [(root, 1)]
        count = 0
        while current:
            count += len(current)
            next_level = []
            for node, v in current:
                if not node:
                    continue
                next_level.append((node.left, 2*v))
                next_level.append((node.right, 2*v+1))
            prev_level, current = current, next_level
        return prev_level[-1][1] == count",O(n)
"import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

from math import sqrt,ceil

max_n=10**7+1
spf = [i for i in range(max_n)]

for i in range(4,max_n,2):
    spf[i]=2

for i in range(3,ceil(sqrt(max_n))):
    if (spf[i]==i):
        for j in range(i*i,max_n,i):
            if(spf[j]==j):
                spf[j]=i

from collections import Counter,defaultdict
from bisect import insort

def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x]
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)

t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)]
    recent=[n for i in range(k+1)]
    closest=defaultdict(lambda: -1)
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i
    dp=[[i for j in range(k+1)] for i in range(n+1)]

    dp[0]=[0 for j in range(k+1)]
    for i in range(n):
        for x in range(k+1):
            end=dp_depth[i][x]

            for y in range(k-x+1):
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1)
    print(dp[n][k])
",O(n ^ 3)
"class Solution(object):
    def countSeniors(self, details):
        return sum(x[-4:-2] > ""60"" for x in details)",O(n)
"n=int(raw_input())

l=list(map(int,raw_input().split()))

index = []
ans=[]
for i in range(n):
	index.append(i+1)
	ans.append(0)

l1,index1 = zip(*sorted(zip(l, index),reverse=True))

for i in range(n):

	k=1
	flag=False
	while (index1[i]-k*l1[i])>0:
		if l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:
			if ans[index1[i]-k*l1[i]-1]==""B"":
				ans[index1[i]-1]=""A""
				flag=True
				break
		k+=1

	k=1
	if flag==False:
		while (index1[i]+k*l1[i])<=n:
			if l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:
				if ans[index1[i]+k*l1[i]-1]==""B"":
					ans[index1[i]-1]=""A""
					flag=True
					break
			k+=1

	if flag==False:
		ans[index1[i]-1]=""B""

print(''.join(ans))
",O(nlogn)
"k,n,s,p=map(int,input().split(' '))
if (1*n)%s==0:
    need=(1*n)//s
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)
else:
    need=((1*n)//s)+1
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)",O(1)
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)
",np
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",O(1)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):

    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev

    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end

while cur > 0:
    prev = pp[cur]

    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"import math
n = int(input())
m = 0
for i in range(min(100,n)):
	for ii in range(min(100,n)):
		for iii in range(min(100,n)):
			i1 = n-i
			ii1 = n-ii
			iii1 = n-iii
			r1 = (i1*ii1)//math.gcd(i1,ii1)
			r2 = (r1*iii1)//math.gcd(iii1,r1)
			m = max(m,r2)
print(m)",O(1)
"import io
import os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

endpoints = []

for x in range(n):
    p, w = map(int, input().split())
    endpoints.append([p-w, p+w])

endpoints.sort(key=lambda sublist: sublist[1])

res = 0

bottom = 10**18 * -1

for pt in range(len(endpoints)):
    if endpoints[pt][0] >= bottom:
        res += 1
        bottom = endpoints[pt][1]

print(res)
",O(nlogn)
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",O(logn)
"import bisect



class Solution(object):
    def maxPathLength(self, coordinates, k):
        def longest_increasing_subsequence(arr):
            result = []
            for x in arr:
                i = bisect.bisect_left(result, x)
                if i == len(result):
                    result.append(x)
                else:
                    result[i] = x
            return len(result)

        target = coordinates[k]
        coordinates.sort(key=lambda x: (x[0], -x[1]))
        left, right = [], []
        for x, y in coordinates:
            if x < target[0] and y < target[1]:
                left.append(y)
            elif x > target[0] and y > target[1]:
                right.append(y)
        return longest_increasing_subsequence(left)+1+longest_increasing_subsequence(right)",O(nlogn)
"class Solution(object):
    def pivotInteger(self, n):
        x = int(((n+1)*n//2)**0.5+0.5)
        return x if x**2 == (n+1)*n//2 else -1",O(1)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
def pos(n):
    t=0
    for k,v in d.items():
        if v>=n:t+=v//n
    return t>=p
for _ in range(1):
    p,n=lst()
    d=Counter(lst())
    ans=0
    for sel in range(1,n+1):
         if pos(sel):ans=max(ans,sel)
    print(ans)",O(nlogn)
"a = int(input())
print(25)",O(1)
"class Solution(object):
    def numberOfWeakCharacters(self, properties):
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d < max_d:
                result += 1
            max_d = max(max_d, d)
        return result

import collections",O(nlogn)
"class Solution(object):
    def maxSum(self, nums):
        mx = max(nums)
        return mx if mx < 0 else sum(x for x in set(nums) if x >= 0)",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    a = int(input())
    b = int(input())
    a = list(str(a))
    a.sort()
    ans = []
    while a:
        for i in range(len(a) - 1, -1, -1):
            c = ans + [a[i]] + a[:i] + a[i+1:]
            if int(''.join(c)) <= b:
                ans.append(a[i])
                a.pop(i)
                break
    print(''.join(ans))

main()",O(n ^ 3)
"n = int(input())

print(0, 0, n)
",O(1)
"class Solution2(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + s[::-1]
        prefix = getPrefix(A)
        i = prefix[-1]
        while i >= len(s):
            i = prefix[i]
        return s[i+1:][::-1] + s",O(n)
"import collections



class Solution(object):
    def isPossibleToSplit(self, nums):
        return all(v <= 2 for v in collections.Counter(nums).values())",O(n)
"class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def recoverFromPreorder(self, S):
        i = 0
        stack = []
        while i < len(S):
            level = 0
            while i < len(S) and S[i] == '-':
                level += 1
                i += 1
            while len(stack) > level:
                stack.pop()
            val = []
            while i < len(S) and S[i] != '-':
                val.append(S[i])
                i += 1
            node = TreeNode(int("""".join(val)))
            if stack:
                if stack[-1].left is None:
                    stack[-1].left = node
                else:
                    stack[-1].right = node
            stack.append(node)
        return stack[0]",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)
",O(logn)
"class Solution2(object):
    def countNumbersWithUniqueDigits(self, n):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]

        return 1+9*sum(nPr(9, i) for i in range(n))",O(n)
"class Solution5(object):
    def rotate(self, nums, k):
        while k > 0:
            nums.insert(0, nums.pop())
            k -= 1",O(n)
"class Solution(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        dp = {}
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            stk = []
            while x not in dp and x in cnt and cnt[x] >= 2:
                stk.append(x)
                x *= x
            if x not in dp:
                if x not in cnt:
                    x = stk.pop()
                dp[x] = 1
            l = dp[x]
            while stk:
                l += 2
                dp[stk.pop()] = l
            result = max(result, l)
        return result 
    
    
import collections",O(n)
"class Solution(object):
    def sumRemoteness(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            total, cnt = grid[i][j], 1
            grid[i][j] = -1
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):
                            continue
                        total += grid[ni][nj]
                        cnt += 1
                        grid[ni][nj] = -1
                        new_q.append((ni, nj))
                q = new_q
            return total, cnt
    
        groups = [bfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] != -1]
        total = sum(t for t, _ in groups)
        return sum((total-t)*c for t, c in groups)",O(n ^ 2)
"l = []
n = []
sum = 0
multiply = 9
for i in range(1,12):
    s = '9' * i
    n.append(int(s))
    sum+=i*multiply
    multiply *= 10
    l.append(sum)
k = int(input())
if(k<9):
    print(k)
else:
    t = 0
    for i in range(len(l)):
        if(k < l[i]):
            t=i
            break
    temp = k-l[t-1]
    offset = temp%(t+1)
    value = temp//(t+1)
    number = n[t-1]+value
    if(offset == 0):
        print(number%10)
    else:
        number += 1
        offset -= 1
        print(str(number)[offset])",O(logn)
"def prime(n):
    if n < 2:
        return False
    elif n % 2 == 0 and n != 2:
        return False
    for j in range(3, int(pow(n, 0.5) + 1), 2):
        if n % j == 0:
            return False
    return True
n = int(input())
for j in range(2, int(n / 2) + 1):
    if prime(j) == False and prime(n - j) == False:
        print(j, n - j)
        break
",O(1)
"class Solution2(object):
    def maxScore(self, nums):
        dp = [0]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j]+(i-j)*nums[i])
        return dp[-1]",O(n ^ 2)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []

        for i, h in enumerate(heights):
            start = i
            while stack and stack[-1][1] > h:
                index, height = stack.pop()
                maxArea = max(maxArea, height * (i - index))
                start = index
            stack.append((start, h))

        for i, h in stack:
            maxArea = max(maxArea, h * (len(heights) - i))
        return maxArea
",O(n)
"n=int(input())
dict1={}
dict2={}
for i in range(n):
    s=input()
    s=s.split('/')
    c=int(s[1])
    s=s[0].strip('(').strip(')').split('+')
    a=int(s[0])
    b=int(s[1])
    ans=(a+b)/c
    try:
        dict2[ans] += 1
    except:
        dict2[ans] = 1
    dict1[i] = ans
for i in range(n):
    print(dict2[dict1[i]],end=' ')
",O(n)
"class Solution(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[0, m-1, n-1,           0],
             [1, m-2,   0,         n-1],
             [1,   0, n-2,         m-1],
             [0,   1,   1, (n-2)+(m-2)]]
        dp = [0]*4 
        if source == dest:
            dp[0] = 1
        elif source[0] == dest[0]:
            dp[1] = 1
        elif source[1] == dest[1]:
            dp[2] = 1
        else:
            dp[3] = 1
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return dp[0]",O(logn)
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(map(xor, a[-1][:-1], a[-1][1:]))

for i in range(n - 1):
    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",O(n ^ 2)
"class Solution(object):
    def fourSum(self, nums, target):
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                total = target - nums[i] - nums[j]
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[left] + nums[right] == total:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        right -= 1
                        left += 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif nums[left] + nums[right] > total:
                        right -= 1
                    else:
                        left += 1
        return result",O(n ^ 3)
"class Solution5(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if n%i:
                    continue
                yield i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"import collections


class Solution(object):
    def balancedString(self, s):
        count = collections.Counter(s)
        result = len(s) 
        left = 0
        for right in range(len(s)):
            count[s[right]] -= 1
            while left < len(s) and \
                  all(v <= len(s)//4 for v in count.values()):
                result = min(result, right-left+1)
                count[s[left]] += 1
                left += 1
        return result",O(n)
"class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))",O(n)
"import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):
        counts = collections.defaultdict(int)
        val_labs = list(zip(values,labels))
        val_labs.sort(reverse=True)
        result = 0
        for val, lab in val_labs:
            if counts[lab] >= use_limit:
                continue
            result += val
            counts[lab] += 1
            num_wanted -= 1
            if num_wanted == 0:
                break
        return result",O(nlogn)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
while cur > 0:
    prev = pp[cur]
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def inv_cnt(b):
    c = 0
    visited = set()
    for i in range(len(b)):
        if i + 1 in visited:
            pass
        else:
            visited.add(i)
            path = [i + 1]
            while b[path[-1] - 1] != path[0]:
                visited.add(b[path[-1] - 1])
                path.append(b[path[-1] - 1])
            c += len(path) - 1
    return c % 2

def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    x = inv_cnt(a)
    m = int(input())
    for query in range(m):
        l, r = [int(x) for x in input().split(' ')]
        x = (x + (r - l + 1) // 2) % 2
        if x:
            print(""odd"")
        else:
            print(""even"")

solve()
",O(n ^ 2)
"import collections



class Point(object):
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b

class Solution(object):
    def maxPoints(self, points):
        max_points = 0
        for i, start in enumerate(points):
            slope_count, same = collections.defaultdict(int), 1
            for j in range(i + 1, len(points)):
                end = points[j]
                if start.x == end.x and start.y == end.y:
                    same += 1
                else:
                    slope = float(""inf"")
                    if start.x - end.x != 0:
                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)
                    slope_count[slope] += 1

            current_max = same
            for slope in slope_count:
                current_max = max(current_max, slope_count[slope] + same)

            max_points = max(max_points, current_max)

        return max_points",O(n ^ 2)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]",O(n)
"a=sorted(input())

b=int(input())

a=a[::-1]

p=""""

while a:

	for i, z in enumerate(a):

		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))

		if int(n)<=b:

			p+=z

			a.pop(i)

			break

print(p)
",O(n ^ 3)
"def f_pow(a, n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    if n % 2 == 0:
        return f_pow(a * a, n // 2)
    else:
        return a * f_pow(a, n - 1)

def get_c(n):
    if(n > 68):
        return int(1e40)
    return (f_pow(4, n) - 4) // 12

def get_cc(n):
    if(n > 51):
        return int(1e30)
    return (f_pow(4, n) - 4) // 12

def ans(n, k):
    side = n - 1
    way = 4
    cnt_all = get_c(n + 1)
    c = 2
    op = 1
    while (True):
        if k < op or side < 0:
            break
        way_blocks = way - 1
        if(get_cc(side - 1) > k):
            return side
        per_block = get_cc(side + 1)
        kk = k - op
        if cnt_all - way_blocks * per_block - op >= kk:
            return side

        side -= 1
        op += (1 << c) - 1
        c += 1
        way *= 2
    return -1

def read():
    return [int(i) for i in input().split()]

t = int(input())

for i in range(t):
    n, k = read()
    a = ans(n, k)
    if(a == -1):
        print(""NO"")
    else:
        print(""YES {}"".format(a))",O(logn)
"class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result",O(n)
"class Trie(object):
    def __init__(self):
        self.__root = {}
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {""_count"":0}
            node = node[curr]
            node[""_count""] += 1
                
    def query(self, num, limit):
        node, result = self.__root, 0
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            bit = (limit>>i) & 1
            if bit:
                if curr in node:
                    result += node[0^curr][""_count""] 
            if bit^curr not in node:
                break
            node = node[bit^curr]
        return result


class Solution2(object):
    def countPairs(self, nums, low, high):
        result = 0
        trie = Trie()
        for x in nums:
            result += trie.query(x, high+1)-trie.query(x, low)
            trie.insert(x)
        return result",O(n)
print(int(input()) // 2 + 1),O(1)
"import itertools
import heapq



class Solution(object):
    def maxScore(self, nums1, nums2, k):
        result = curr = 0
        min_heap = []
        for a, b in sorted(zip(nums1, nums2), key=lambda x: x[1],  reverse=True):
            curr += a
            heapq.heappush(min_heap, a)
            if len(min_heap) > k:
                curr -= heapq.heappop(min_heap)
            if len(min_heap) == k:
                result = max(result, curr*b)
        return result",O(nlogn)
"class Solution(object):
    def longestSubsequence(self, s, k):
        result, base = 0, 1
        for i in reversed(range(len(s))):
            if s[i] == '0':
                result += 1
            elif base <= k:
                k -= base
                result += 1
            if base <= k:
                base <<= 1
        return result",O(n)
"import sys
input = sys.stdin.readline

def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order

n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]

memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:
    print(""YES"")
    print(*[i + 1 for i in res])
else:
    print(""NO"")",np
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None

        l1 = head
        while l1:
            l2 = Node(l1.val)
            l2.next = l1.random
            l1.random = l2
            l1 = l1.next

        newHead = head.random

        l1 = head
        while l1:
            l2 = l1.random
            l2.random = l2.next.random if l2.next else None
            l1 = l1.next

        l1 = head
        while l1 is not None:
            l2 = l1.random
            l1.random = l2.next
            l2.next = l1.next.random if l1.next else None
            l1 = l1.next

        return newHead
",O(n)
"def norm(x):
    return (x % 998244353 + 998244353) % 998244353

n, k = map(int, input().split())

dp1 = [0]
dp2 = [0]

for i in range(n):
    l = [1]
    cur = 0
    for j in range(n + 1):
        cur += l[j]
        if(j > i):
            cur -= l[j - i - 1]
        cur = norm(cur)
        l.append(cur)
    dp1.append(l[n])
    dp2.append(norm(dp1[i + 1] - dp1[i]))

ans = 0
for i in range(n + 1):
    for j in range(n + 1):
        if(i * j < k):
            ans = norm(ans + dp2[i] * dp2[j])

ans = norm(ans * 2)

print(ans)",O(n ^ 2)
"def sm(n):
    return int(int(n*(n+1))/int(2));
def summ(en, st):
    if(st <= 1):
        return sm(en);
    return sm(en) - sm(st-1);

def bs(n, k):
    st = 1;
    en = k;
    while (st < en):
        md = int(int((st+en)) /int(2));
        s = summ(k,md);
        if(s == n):
            return k - md + 1;
        elif (s>n):
            st = md + 1;
        else :
            en = md;
    return k - st + 2;
n, k = input().split();
n = int(n);
k = int(k);

if(n == 1):
    print(0);
elif (n <= k):
    print(1);
else:
    n -= 1;
    k -= 1;
    if(sm(k) < n ):
        print(-1);
    else:
        print(int(bs(n,k)));
",O(logn)
"inf=10000000000
n,m,k=(int(i) for i in input().split())
h=[[int(i) for i in input().split()]for i in range(n)]
z=[[int(i) for i in input().split()]for i in range(n-1)]
dh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf
dz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf
dp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)]
ddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf
if k%2!=0:
    for i in dp[0]:
        for j in i:
            print(-1,end=' ')
        print()
else:
    for kk in range(int(k/2)):
        for i in range(n):
            for j in range(m):
                dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j))
        dp.reverse()
    for i in dp[0]:
        for j in i:
            print(2*j,end=' ')
        print()
",O(n ^ 3)
"n, pos, l, r = map(int, input().split())
result = abs(pos - l) + r - l + 2
if (l == 1):
    if (abs(pos - r) + 1 < result):
        result = abs(pos - r) + 1
if (r == n):
    if (abs(pos - l) + 1 < result):
        result = abs(pos - l) + 1
if (l == 1 and r == n):
    result = 0
if (abs(pos - r) + r - l + 2 < result):
    result = abs(pos - r) + r - l + 2
print(result)",O(1)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i

class Solution(object):
    def read(self, buf, n):
        read_bytes = 0
        buffer = [''] * 4
        for i in range((n+4-1)//4):
            size = min(read4(buffer), n-read_bytes)
            buf[read_bytes:read_bytes+size] = buffer[:size]
            read_bytes += size
        return read_bytes",O(n)
"import math

class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))

def solve():
    n, k = Read.list_int()
    s = input()

    sf = 'RGB' * (k + 2)

    max_s = 0
    for i in range(n - k + 1):
        for j in range(3):
            count = 0
            for b in range(k):
                if sf[j + b] == s[i + b]:
                    count += 1
            if count > max_s:
                max_s = count

    print(k - max_s)

query_count = Read.int()
for j in range(query_count):
    solve()
",O(n ^ 2)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)

if __name__ == '__main__':
    main()",O(n)
"n,k=map(int,input().split())
for i in range(10**5):
  if (i*(i+1))//2-(n-i)==k:
    print(n-i)",O(1)
"import collections

import sys

N = int(input())
p = [int(x) for x in input().split()]

G = collections.defaultdict(list)

for i, v in enumerate(p):
    u = i + 2
    G[u].append(v)
    G[v].append(u)

root = 1

colors = [0] * (N + 1)
counts = [0] * (N + 1)

q = [root]
parents = [0] * (N+1)
vis = [0] * (N+1)
while q:
    u = q.pop()
    if vis[u]:
        colors[parents[u]] += colors[u]
        continue
    children = [v for v in G[u] if v != parents[u]]
    for v in children:
        parents[v] = u

    if children:
        vis[u] = True
        q.append(u)
        q.extend(children)
    else:
        vis[u] = True
        colors[u] = 1
        colors[parents[u]] += 1

colors.sort()
print(' '.join(map(str, colors)))
",O(n ^ 2)
"class Solution2(object):
    def cloneTree(self, root):
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)",O(n)
"a = list(map(int, input().split()))

ans = 0
for i in range(len(a)):
    x = a[i]
    b = [j for j in a]
    b[i] = 0
    for j in range(len(a)):
        b[j] += x // 14

    for j in range(1, x % 14 + 1):
        b[(i + j) % 14] += 1

    ans_now = 0
    for j in b:
        if j % 2 == 0:
            ans_now += j
    ans = max(ans_now, ans)
print(ans)",O(1)
"from math import inf

n, m, k = map(int, input().split())
horizontal_costs = []
vertical_costs = []
for _ in range(n):
    horizontal_costs.append(list(map(int, input().split())))
for _ in range(n-1):
    vertical_costs.append(list(map(int, input().split())))

dp = [[[inf] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]

def find_cost(a, b, c):
    global dp
    if a < 0 or a > n-1 or b < 0 or b > m-1:
        return inf

    if c == 0:
        return 0

    if dp[a][b][c] != inf:
        return dp[a][b][c]

    if a < n-1:
        dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b]
    if b < m-1:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b])
    if b > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1])
    if a > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b])

    return dp[a][b][c]

ans = [[inf] * m for _ in range(n)]
if k % 2 == 1:
    for i in range(n):
        for j in range(m):
            ans[i][j] = -1
else:
    for i in range(n):
        for j in range(m):
            ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k//2))

for row in ans:
    print(*row)",O(n ^ 3)
"n,m,a,b=map(int, input().split())
print(min(n%m*b, (m-n%m)*a))",O(n)
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))
",O(n)
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)
",np
"import collections


class Solution(object):
    def canPermutePalindrome(self, s):
        return sum(v % 2 for v in list(collections.Counter(s).values())) < 2",O(n)
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')

else:
    print('YES')
    print(*ans, sep=' ')",O(n ^ 2)
"n,k=map(int,input().strip().split())
v = []
for i in range(2,n+1):
	if all(i%j!=0 for j in v):
		v.append(i)
c = 0
for i in range(len(v)-1):
	if 1+v[i]+v[i+1] in v:
		c += 1
if c >= k:
	print(""YES"")
else:
	print(""NO"")",O(n)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
diameter = 2*k

for i,level in enumerate(d):
    if level == diameter:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

if center == -1:
    print(""NO"")
    exit()

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"def main():

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",O(n ^ 2)
"import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))",O(n)
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

        return res
",O(n ^ 2)
"import itertools

n = int(input())
a = []
for i in range(4):
    a.append([input() for _ in range(n)])
    if i < 3:
        assert input() == ''

best = 4*n*n
for p in itertools.permutations(a):
    for s in range(2):
        count = 0
        for i in range(4):
            for r in range(n):
                for c in range(n):
                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):
                        count += 1
        best = min(best, count)
print(best)
",O(n ^ 2)
"from collections import Counter
ts=Counter(''.join(reversed(t)) for t in input().split())
t0 = None
run = 0
ans = 3
for t, c in sorted(ts.items()):
    if t0 is None or t[0] != t0[0] or int(t[1]) != int(t0[1])+1:
        run = 0
    t0 = t
    run += 1
    ans = min(ans, 3-max(c,run))
for s in 'spm':
    for r in range(1, 10):
        if s+str(r-1) in ts and s+str(r+1) in ts:
            ans = min(ans, 1)
print(ans)
",O(nlogn)
"class Solution(object):
    def modifiedList(self, nums, head):
        lookup = set(nums)
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if curr.next.val not in lookup:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__",O(n)
"n,k = map(int,input().split())
s = input()
c=0
for i in range(len(s)):
	if s[:i]==s[-i:]:
		c=i
print(s+s[c:]*(k-1))",O(n ^ 2)
"def permuteDigits(a, b):

    n = len(a)
    if len(a) < len(b):
        return a

    i = 0
    c = 0
    t = a[0]
    flag = 0
    lastind = []
    while i<len(a) and i< len(b) and a[i] >= b[i] :

        if c == n:
            i = i - 1
            t = a[i]
            a = a[:i] + a[i+1:]
            a.insert(lastind.pop(),t)
            flag = 1
            c = i
        elif (flag == 0 and a[c] == b[i]) or a[c] < b[i]:
            lastind.append(c)
            t = a[c]
            a = a[:c] + a[c+1:]

            a.insert(i,t)

        else:
            c = c + 1

        if a[i] < b[i]:
            break
        elif flag == 0 and a[i] == b[i]:
            i = i + 1
            c = i

    return a

aa = input()
bb = input()

a=[]
b=[]
for i in aa:
    a.append(int(i))
for i in bb:
    b.append(int(i))

a.sort(reverse=True)

ans = permuteDigits(a, b)
s = """"
for i in ans:
    s = s + str(i)
print(int(s))",O(n ^ 3)
"class Solution(object):
    def numberOfChild(self, n, k):
        q, r = divmod(k, n-1)
        return r if q&1 == 0 else (n-1)-r",O(1)
"from collections import defaultdict

class Solution(object):
    def isRectangleCover(self, rectangles):
        left = min(rec[0] for rec in rectangles)
        bottom = min(rec[1] for rec in rectangles)
        right = max(rec[2] for rec in rectangles)
        top = max(rec[3] for rec in rectangles)

        points = defaultdict(int)
        for l, b, r, t in rectangles:
            for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):
                if points[p] & q:
                    return False
                points[p] |= q

        for px, py in points:
            if left < px < right or bottom < py < top:
                if points[(px, py)] not in (3, 5, 10, 12, 15):
                    return False

        return True",O(n)
"import random



class Solution(object):
    def minimumCost(self, nums):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, 1+(2-1), 1)
        return nums[0]+nums[1]+nums[2]",O(n)
"from collections import Counter
a = input()
b = input()
if len(a) < len(b):
    print(''.join(sorted(a)[::-1]))
    exit()
n = len(a)
cnt = Counter(a)
def f(i = 0, check = False):
    if i == n: return []
    for j in sorted(cnt)[::-1]:
        if (check or j <= b[i]) and cnt[j]:
            cnt[j] -= 1
            res = f(i + 1, check or j < b[i])
            if len(res) + i + 1 == n:
                res.append(j)
                return res
            cnt[j] += 1
    return []
print(''.join(f()[::-1]))",O(n ^ 3)
"n, v = map(int, input().split())
cur = 0
total = 0
for i in range(n):
    while cur < n - i - 1:
        cur += 1
        total += (i + 1)
        if cur == v:
            break
    cur -= 1
print(total)",O(n ^ 2)
"n,k = input().split()
n,k = int(n),int(k)

ini,fin = 1,k-1
if n == 1:
	print(""0"")
	exit(0)

if 1 + (k*(k-1) )//2 < n:
	print(""-1"")
	exit(0)

while ini < fin:
	mid = (ini+fin)//2
	s = 1 + (k-1)*mid - (mid*(mid-1))//2
	if s>=n:
		fin = mid
	else:
		ini = mid+1

print(ini)",O(logn)
"def l(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a-2**(c-1))

def r(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a+2**(c-1))

def u(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==d-1:
        return -1
    else:
        if b[d-1-c-1]==""0"":
            return a+(2**c)
        else:
            return a-(2**c)

n,q=list(map(int,input().split()))
e=len(bin(n)[2:])
for i in range(q):
    a=int(input())
    b=input()
    for i in range(len(b)):
        if b[i]==""U"":
            c=u(a)
            if c!=-1:
                a=c
        elif b[i]==""R"":
            c=r(a)
            if c!=-1:
                a=c
        elif b[i]==""L"":
            c=l(a)
            if c!=-1:
                a=c
    print(a)",np
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"n, m = int(input()), int(input())
print(m % (2 ** n) if n < 30 else m)",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)",O(n)
"n = int(input())
print(n//2+1)",O(1)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)",O(n)
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))

if __name__ == '__main__':
    main()",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

def get(l, r):
    if l > r:
        return 0

    if l & 1:
        return (-l - r) * (r - l + 2) // 4
    else:
        return (l + r) * (r - l + 2) // 4

def solution(l, r):
    l1, l2, r1, r2 = l, l, r, r

    if l & 1:
        l2 += 1
    else:
        l1 += 1

    if r & 1:
        r2 -= 1
    else:
        r1 -= 1

    return get(l1, r1) + get(l2, r2)

q = int(stdin.readline())
for i in range(q):
    l, r = map(int, stdin.readline().split())
    stdout.write(str(solution(l, r)) + '\n')",O(1)
"n = int(input())
if n==0:
    print(*[0,0,0])
elif n==1:
    print(*[0,0,1])
else:
    prev2 = 0
    prev1 = 1
    prev = 1
    while prev!=n:
        curr = prev+prev1
        prev2 = prev1
        prev1 = prev
        prev = curr
    print(*[0,prev2,prev1])
",O(1)
"class Solution(object):
    def minStartValue(self, nums):
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix",O(n)
"n,m=map(int,input().split())
c=0;ans=str()
for i in range(n):
  ans+=str(c^1)
  c=c^1
print(ans)
",O(n)
"n=int(input())
x=list(map(int,input().split()))
x.sort()
count,count2=0,0
ans=1
for i in range(n):
    count+=x[i]-i
    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0
    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0
    if i>=1 and x[i]==x[i-1]: count2+=1
if n>=3 and x[0]==x[1]==0: ans=0
for i in range(n):
    if x[i]>0: break
    if i==n-1: ans=0
if ans==0 or count%2==0 or count2>1: print(""cslnb"")
else: print(""sjfnb"")",O(nlogn)
"class Solution2(object):
    def permute(self, n, k):
        result = []
        fact = [1]*(((n-1)+1)//2+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        lookup = [False]*n
        for i in range(n):
            cnt = fact[(n-1-i)//2]*fact[((n-1-i)+1)//2]
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt:
                    break
                k -= cnt
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"__author__ = 'ruckus'

n = int(input())
s = input()
t = input()
dif = {}
hem = 0
for i in range(n):
    if s[i] != t[i]:
        dif[i] = [s[i], t[i]]
        hem += 1

change = []
probed = []
k = 0
for i in dif.keys():
    if dif[i] in probed:
        continue
    probed.append(dif[i])
    k += 1
    for j in list(dif.keys())[k:]:
        if dif[i] == dif[j][::-1]:
            print(hem - 2)
            print(i + 1, j + 1)
            quit()
        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):
            change = [i, j]

if change:
    print(hem - 1)
    print(change[0] + 1, change[1] + 1)
else:
    print(hem)
    print('-1 -1')",O(n)
"import math
from collections import defaultdict

def main():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    fav = list(map(int, input().split()))

    h = [0] + list(map(int, input().split()))

    cards_cnt = defaultdict(int)
    for val in cards:
        cards_cnt[val] += 1

    players_fav_cnt = defaultdict(int)
    for val in fav:
        players_fav_cnt[val] += 1

    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]
    for p in range(n):
        for c in range(k*n+1):
            for hand in range(k+1):
                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])

    res = 0
    for f in players_fav_cnt:
        res += dp[players_fav_cnt[f]][cards_cnt[f]]

    print(res)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors):
        k = 3
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"a , b = input(), input()
ans = 0

ones = [0 for i in range(len(b)+1)]
zeros = [0 for i in range(len(b)+1)]

for i in range(len(b)):
    ones[i] = ones[i-1] + int(b[i])
    zeros[i] = i + 1 - ones[i]

for i in range(len(a)):
    if a[i] == '1':
        ans += zeros[len(b)-len(a)+i] - zeros[i-1]

    else:
        ans += ones[len(b)-len(a)+i] - ones[i-1]

print(ans)
",O(n)
"n=int(input())
d={""purple"":""Power"",""green"":""Time"",""blue"":""Space"",""orange"":""Soul"",""red"":""Reality"",""yellow"":""Mind""}
l=[]
for i in range(n):
    s=input()
    l.append(s)
print(6-n)
for i in d:
    if i not in l:
        print(d[i])",O(1)
"a,b,c,n=map(int, input().split())
p=n-(a+b-c)
if c>a or c>b or p<=0:
    print(-1)
    exit()
if p<1:
    print(-1)
else:
    print(p)",O(1)
"a=list(input())
b=list(input())
num=int(''.join(b))
a.sort()
a.reverse()
al=len(a)
ans=[]
if(len(a)==len(b) and len(a)!=1):
	c=[]
	count=0
	hogya=0
	for i in range(al):
		if(hogya==1):
			o.reverse()
			f=list(c+o)
			ans.append(''.join(f))
			count+=1
			break
		t=len(a)
		j=0
		mittal=t
		abhinhi=0
		while(t):

			if(j>len(a)-1):
				break
			if(int(a[j])<=int(b[i])):
				c.append(a[j])
				temp=a[j]
				a.remove(a[j])
				o=a.copy()
				o.sort()
				f=list(c+o)

				if(temp<b[i]):

					hogya=1
					break
				if(int(''.join(f))<=num):
					ans.append(''.join(f))
					count+=1
					break
				else:
					a.append(temp)
					c=c[:len(c)-1]

				t-=1
			else:
				j+=1
				t-=1
		if(mittal==len(a)):

			break

	print(ans[count-1])
elif(len(a)==1):
	print(''.join(a))
else:
	print(''.join(a))
",O(n ^ 3)
"n , k = map(int, input().split())
l = list(map(int,input().split()))
l.sort()
a = 0
i = 0
while i<(n-1):
    j = i+1
    while j<n and l[j]==l[i]:
        j+=1
    if j==n:
        break
    else:
        if l[j]<=l[i]+k:
            a+=(j-i)
    i = j
print(n-a)",O(nlogn)
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []

if num <= bb:
    print(num)
    exit(0)

for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    f.append(mx)
    mark[idx] = 1
    index.append(idx)

    if mx < b[i] and mx != '-1':
        break

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()
for i in rem:
    f.append(i)

print(get(f))",O(n ^ 3)
"n,k = [int(x) for x in input().split()]
a = []
for _ in range(n):
    a.append([int(x) for x in input().split()])

a.sort(key = lambda x: x[1])
a.sort(reverse=True,key=lambda x: x[0])
b=a[k-1]
print(a.count(b))",O(nlogn)
"class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result",O(n)
"from sys import stdin

n, m = map(int, stdin.readline().split())
ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))
num, cur, i = 1, 0, 0

while i < len(p) and m > 0 and num <= n:
    cur += p[i]
    if cur >= m:
        m -= (cur - p[i])
        cur = 0
        ans.append(num)
        all.discard(num)
    num += 1
    i += 1

print(' '.join(map(str, ans + sorted(all)[::-1])))
",np
"n,k = map(int, input().split())
d = (n-k)//2+1
ans = ['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(ans))
",O(n)
"import collections



class Solution(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            new_stk = []
            while stk:
                t, node, parent, choices = stk.pop()
                if not t or not (len(G[node])-(parent != 0)):
                    if node == target:
                        return 1.0/choices
                    continue
                for child in G[node]:
                    if child == parent:
                        continue
                    new_stk.append((t-1, child, node,
                                    choices*(len(G[node])-(parent != 0))))
            stk = new_stk
        return 0.0",O(n)
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"class Solution2(object):
    def minimumCost(self, nums):
        def topk(a, k):
            result = [float(""inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x < result[i]:
                        result[i], x = x, result[i]
            return result

        return nums[0]+sum(topk((nums[i] for i in range(1, len(nums))), 2))",O(n)
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
DP = [0] * ((R+1) * (G+1) * (B+1))

def idx(r, g, b):
  return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
  for g in range(G+1):
    for b in range(B+1):
      best = 0
      if r:
        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
      if g and b:
        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
      DP[idx(r, g, b)] = best
print(max(DP))
",O(n ^ 3)
"class Solution(object):
    def longestSquareStreak(self, nums):
        sorted_nums = sorted(set(nums))
        squares = {x for x in sorted_nums if x%2 < 2} 
        result = 0
        for x in sorted_nums:
            square, cnt = x**2, 1
            while square in squares:
                squares.remove(square)
                cnt += 1
                square *= square
            result = max(result, cnt)
        return result if result != 1 else -1",O(nlogn)
"n = int(input(""""))
if n==1 or n==2:
    print(n)
elif n&1:
    print((n)*(n-1)*(n-2))
else:
    if n%3==0:
        print((n-2)*(n-1)*(n-3))
    else :
         print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))/2))",O(1)
"class Solution2(object):
    def average(self, salary):
        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)",O(n)
"class Solution(object):
    def maximumPossibleSize(self, nums):
        result = prev = 0
        for x in nums:
            if prev <= x:
                prev = x
                result += 1
        return result",O(n)
"def inp():
    return map(int, input().split())

def sum_range(n):
    return (n * (n + 1)) // 2

def bs(st, en):
    while (st < en):
        mid = st + (en - st) // 2
        s1 = s - sum_range(mid - 1)

        if s1 == n:
            return (k - mid) + 1
        elif s1 > n:
            st = mid + 1
        else:
            en = mid
    return (k - st) + 2

n, k = inp()
n -= 1
k -= 1
s = sum_range(k)

if n+1 == 1:
    print(0)
elif n <= k:
    exit(print(1))
elif n > s:
    print(-1)
else:
    print(bs(1, k))
",O(logn)
"class Solution2(object):
    def largestSquareArea(self, bottomLeft, topRight):
        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in range(len(bottomLeft)) for j in range(i+1, len(bottomLeft))), 0)**2",O(n ^ 2)
"import sys

from bisect import bisect_right as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

n,s = il()

l = s
h = n
ans = n+1

while (l<=h) :
    m = (l+h)//2

    t = 0

    for i in str(m) :
        t += int(i)

    if (m-t >= s) :
        ans = m
        h = m-1
    else :
        l = m+1

print(n-ans+1)
",O(logn)
"s = input()
l = list(map(int,input().split()))
l.sort(reverse = True)
s = sum(l)
x = 0
c = 0
for i in l:
    if x <= s:
        c+=1
        x+=i
        s-=i
    else:
        break
print(c)",O(nlogn)
"class Solution(object):
    def wiggleMaxLength(self, nums):
        if len(nums) < 2:
            return len(nums)

        length, up = 1, None

        for i in range(1, len(nums)):
            if nums[i - 1] < nums[i] and (up is None or up is False):
                length += 1
                up = True
            elif nums[i - 1] > nums[i] and (up is None or up is True):
                length += 1
                up = False

        return length",O(n)
"t = int(input())
def maxsa(A):
    ans = 0

    for i in range(n):
        cur_maxx = 0
        for j in range(4):
            cur_maxx = max(cur_maxx, A[j][i])
        ans+= cur_maxx
    return ans

def fu(A):
    answer = 0
    for j in range(n):
        A[0] = A[0][1:] + A[0][:1]
        for i in range(n):
            A[1] = A[1][1:] + A[1][:1]
            for k in range(n):
                A[2] = A[2][1:] + A[2][:1]
                for l in range(n):
                    A[3] = A[3][1:] + A[3][:1]

                    cur_ans = maxsa(A)
                    answer = max(answer, cur_ans)
    return answer

for j in range(t):
    n,m = map(int,input().split())
    A = [0] * n
    inds = [-1,-1,-1,-1]
    maxs  =[ 0,0,0,0]
    for j in range(n):
        A[j] = list(map(int,input().split()))
    for j in range(m):
        cur_maxs = 0
        for i in range(n):
            cur_maxs = max(cur_maxs, A[i][j])
        maxs.append(cur_maxs)
        inds.append(j)
        ind  = 4

        while ind !=0 and maxs[ind] > maxs[ind-1]:
            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]
            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]
            ind-=1
        maxs.pop()
        inds.pop()

    S = [0] * 4
    for j in range(4):
        if inds[j] != -1:

            S[j] = [s[inds[j]] for s in A]

        else:
            S[j] = [0] * n

    print(fu(S))",np
"n = int(input())
a = [list(map(int,input().split())) for i in range(n)]
for t in range(n):
    a[t].append(t+1)
a.sort()
for i in range(n-1):
    if a[i][1] >= a[i+1][1]:
        print(a[i+1][2],a[i][2])
        exit()
    if a[i][0] == a[i+1][0] and a[i][1] <= a[i+1][1]:
        print(a[i][2],a[i+1][2])
        exit()
print(-1,-1)",O(nlogn)
"from collections import Counter

def solve(n, ribbons):
	L = len(ribbons[0])
	a = [Counter(r).most_common(1)[0][1] for r in ribbons]

	r = sorted([(x, i) for i, x in enumerate(a)], reverse=True)

	if n == 1:
		c = Counter(a)
		if c[L - 1] == 1:
			for i in range(3):
				if a[i] == L - 1: return i
		if c[L - 1] > 1:
			return 3
		if c[L] + c[L - 2] == 1:
			for i in range(3):
				if a[i] == L or a[i] == L-2:
					return i
		if c[L] + c[L - 2] > 1:
			return 3

	if r[1][0] == r[0][0]:
		return 3
	if r[1][0] + n >= L:
		return 3
	return r[0][1]

	print(a)

def main():
	n = int(input())
	cats = ('Kuro', 'Shiro', 'Katie', 'Draw')

	ribbons = [input().strip() for _ in range(3)]

	k = solve(n, ribbons)
	print(cats[k])

if __name__ == '__main__':
	main()",O(n)
"n, k = (int(x) for x in input().split())

if k > n * 2 or k < 3:
    print(0)
elif n >= k-1:
    print(k - k//2 - 1)
else:
    print(n - k//2)",O(1)
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break
",np
"import heapq



class Solution(object):
    def halveArray(self, nums):
        target = sum(nums)/2.0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        result = 1
        while max_heap:
            x = -heapq.heappop(max_heap)/2.0
            target -= x
            if target <= 0.0:
                break
            heapq.heappush(max_heap, -x)
            result += 1
        return result",O(nlogn)
"n, k, A = map(int, input().rstrip().split())
senators = []
mx_bribe = 0

for i in range(n):
    lvl, loy = map(int, input().rstrip().split())
    senators.append((lvl, loy))
    mx_bribe += (100 - loy) // 10

bribe = [0] * n

def calc(votes):
    bsum, cnt, p = 0, 0, 1.0
    for i, s in enumerate(senators):
        if votes & (1 << i):
            p *= (s[1] + bribe[i]) / 100
            cnt += 1
        else:
            p *= (100 - s[1] - bribe[i]) / 100
            bsum += s[0]

    if cnt > (n / 2):
        return p
    else:
        return p * A / (A + bsum)

def dfs(cur, rk):
    if cur >= n:
        if rk > 0:
            return 0.0
        sm = 0.0
        for i in range(1 << n):
            sm += calc(i)

        return sm

    mx = 0.0
    for i in range(rk + 1):
        if i * 10 + senators[cur][1] > 100:
            break
        bribe[cur] = i * 10
        tmp = dfs(cur+1, rk-i)
        mx = max(tmp, mx)
    return mx

print(dfs(0, min(k, mx_bribe)))
",np
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j

        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:

            k &= state
            d[k] = i
            k -= 1
        need = mask^state

        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)

    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)

    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)
",np
"n=int(input())
l=list(map(int,input().split(' ')))
l.sort(reverse=True)

coin=0
total_sum=sum(l)
current_sum=0
for i in range(len(l)):
    coin+=1
    current_sum=current_sum+l[i]
    remaining_sum=total_sum-current_sum
    if current_sum>remaining_sum:
        break
print(coin)",O(nlogn)
"n,a,b = list( map(int, input().split()))

if min(a,b) >1:
    print('NO')
    exit()

m = max(a,b)

if m == 1:
    if n == 1:
        print('YES')
        print(0)
        exit()
    elif n < 4:
        print('NO')
        exit()
    else:
        print('YES')
        for row in range(n):
            line = ['0']*n
            if row >0:
                line[row-1] = '1'
            if row <n-1:
                line[row+1] = '1'
            print(''.join(line))
    exit()

print('YES')

if a == 1:
    c = '1'
    d = '0'
else:
    c = '0'
    d = '1'
for row in range(n):
    if row < m-1:
        line = [c]*n
    else:
        line = [c]*(m-1)+ [d]*(n-m+1)
    line[row] = '0'

    print(''.join(line))
",O(n ^ 2)
"a,b,c,n= [int(c) for c in input().split()]
u=a+b-c
if a<c or b<c:
	print(-1)
else:
	if n-u>=1:
		print(n-u)
	else:
		print(-1)
",O(1)
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))

p=max(lst)
ind=lst.index(p)
if p==1:
    lst[ind]=2
else:
    lst[ind]=1
lst.sort()
for j in range(n):
    print(lst[j],end="" "")",O(nlogn)
"a=int(input())
z=list(map(int,input().split()))
ans=[]
k=len(z)
for i in range(len(z)):
    if((z[i]-i)%len(z)==0):
        ans.append((z[i]-i)//k)
    else:
        ans.append((z[i]-i)//k)
        ans[-1]+=1
t=min(ans)
print(ans.index(t)+1)
",O(n)
"class Solution(object):
    def canBeTypedWords(self, text, brokenLetters):
        lookup = set(brokenLetters)
        result, broken = 0, False
        for c in text:
            if c == ' ':
                result += int(broken == False)
                broken = False
            elif c in lookup:
                broken = True
        return result + int(broken == False)",O(n)
"def f():
    n = int(input())
    A = [int(s) for s in input().split()]
    memo = [[None for j in range(n+1)] for i in range(n+1)]
    for i in range(n):
        memo[i][i] = [A[i],A[i],1]
    for l in range(2,n+1):
        for left in range(0,n-l+1):
            right = left + l - 1
            minLen = l
            shortestMid = right
            for mid in range(left+1,right+1):
                pre = memo[left][mid-1]
                post = memo[mid][right]
                combLen = pre[2] + post[2]
                if pre[1]==post[0]:
                    combLen -= 1
                if combLen < minLen:
                    minLen = combLen
                    shortestMid = mid
            pre = memo[left][shortestMid - 1]
            post = memo[shortestMid][right]
            startEle = pre[0]
            endEle = post[1]
            if pre[2] == 1:
                if pre[0] == post[0]:
                    startEle = pre[0] + 1
            if post[2] == 1:
                if pre[1] == post[0]:
                    endEle = post[0] + 1
            memo[left][right] = [startEle, endEle, minLen]

    print(memo[0][n-1][2])

f()",O(n ^ 3)
"class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from typing import List

n,k = map(int,input().split())
t = []
for _ in [0]*n:
    t.append(list(map(int,input().split())))
t.sort(key=lambda x:(-x[0],x[1]))

pt = t[k-1]

print(t.count(pt))
",O(nlogn)
"class Solution:
    def maxArea(self, heights: List[int]) -> int:
        l, r = 0, len(heights) - 1
        res = 0

        while l < r:
            area = min(heights[l], heights[r]) * (r - l)
            res = max(res, area)
            if heights[l] <= heights[r]:
                l += 1
            else:
                r -= 1
        return res
",O(n)
"import sys

def num_ops(low, high):
    if high % low == 0:
        return high // low
    else:
        return (high // low) + num_ops(high % low, low)

def main():
    n = int(sys.stdin.readline().strip())
    for _ in range(n):
        low, high = [int(i) for i in sys.stdin.readline().strip().split()]
        print(num_ops(low, high))

if __name__ == '__main__':
    main()",O(1)
"class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize != 0:
            return False
        count = Counter(hand)
        for num in hand:
            start = num
            while count[start - 1]:
                start -= 1
            while start <= num:
                while count[start]:
                    for i in range(start, start + groupSize):
                        if not count[i]:
                            return False
                        count[i] -= 1
                start += 1
        return True
",O(n)
"import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):
        def dfs(curr, path, result):
            if ""_end"" in curr:
                result.append(""/"" + ""/"".join(path))
                return
            for c in curr:
                if c == ""_end"":
                    continue
                path.append(c)
                dfs(curr[c], path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for f in folder:
            f_list = f.split(""/"")
            reduce(dict.__getitem__,
                   itertools.islice(f_list, 1, len(f_list)),
                   trie).setdefault(""_end"")
        result = []
        dfs(trie, [], result)
        return result",O(n)
"a , b , c , d , e , f = map(int,input().split())
n , n1 = 1 , a * b + c * d + e * f
while n ** 2 < n1 :
    n += 1
if n ** 2 > n1 :
    print(-1)
    exit()
l = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1] :
        print(-1)
        exit()
    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np
"if __name__ == '__main__':
    n, s = map(int, input().split())
    a = []
    for _ in range(n):
        h, m = map(int, input().split())
        a.append(h * 60 + m)
    if a[0] != 0 and a[0] > s:
        print(0, 0)
    else:
        a.append(a[n - 1] + 2 * s + 3)
        for i in range(1, n + 1):
            if a[i] - (a[i - 1] + 2 + s) >= s:
                print((a[i - 1] + s + 1)//60, (a[i - 1] + s + 1)%60)
                break
",O(n)
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",O(1)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))
    @staticmethod
    def calc(sep = '', k = ''):
        count = 0
        for i in range(sep):
            j = sep - i
            sum = ((i + 1)* i) / 2
            if (sum - j == k):
                return j
        return count

def main():
    n, k = Read.list_int()
    print(Read.calc(n, k))

main()",O(logn)
"class Solution(object):
    def largestSubarray(self, nums, k):
        left, right, l = 0, 1, 0
        while right+k-1 < len(nums) and right+l < len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] > nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]",O(n)
"class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]",O(n)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(l, r):
            if l > r:
                return float(""-inf"")

            m = (l + r) >> 1
            leftSum = rightSum = curSum = 0
            for i in range(m - 1, l - 1, -1):
                curSum += nums[i]
                leftSum = max(leftSum, curSum)

            curSum = 0
            for i in range(m + 1, r + 1):
                curSum += nums[i]
                rightSum = max(rightSum, curSum)

            return (max(dfs(l, m - 1),
                        dfs(m + 1, r),
                        leftSum + nums[m] + rightSum))

        return dfs(0, len(nums) - 1)
",O(nlogn)
"tot, choc = [int(i) for i in input().split()]

bg = 1
end = tot

while True:
    mid = (bg + end) / 2
    add = (mid * (mid + 1)) / 2
    sub = tot - mid
    if add - sub == choc:
        print(int(sub))
        break
    if add - sub < choc:
        bg = mid + 1
    else:
        end = mid - 1
",O(logn)
"n = int(input())

a = map(int, input().split())
mp = {}
s = 0
ans = 0
i = 0
for x in a:
    i += 1
    s += x

    if x not in mp:
        mp[x] = 0

    if x+1 not in mp:
        mp[x+1] = 0

    if x-1 not in mp:
        mp[x-1] = 0
    mp[x] += 1

    adj = mp[x] + mp[x+1] + mp[x-1];
    c = s;
    c -= mp[x]*x;
    c -= mp[x+1] * (x+1);
    c -= mp[x-1] * (x-1);

    valid = i-adj

    ans += (valid*x)-c

print(ans)",O(nlogn)
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",O(n ^ 3)
"from math import factorial
s1,s2=input(),input()
a=s1.count('+')-s2.count('+')
b=s1.count('-')-s2.count('-')
if(a<0 or b<0):
    print(0)
    exit(0)
ans=factorial(a+b)/factorial(a)/factorial(b)
ans/=(2**(a+b))
print(""%.10f""%ans)
",np
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"import os
from io import BytesIO, IOBase
import sys

def main():
    n = int(input())
    a = list(map(int,input().split()))
    a = set(a)
    a = list(sorted(list(a)))
    if len(a) == 1:
        print(""NO"")
    else:
        print(a[1])
    return

BUFSIZE = 1048576

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",O(nlogn)
"class Solution2(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        return self.__getPosDir()[0] 

    def getDir(self):
        return self.__getPosDir()[1]

    def __getPosDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [[n, 0], ""South"" if n == 0 and self.__curr else ""East""]
        n -= self.__w-1
        if n < self.__h:
            return [[self.__w-1, n], ""North""]
        n -= self.__h-1
        if n < self.__w:
            return [[(self.__w-1)-n, self.__h-1], ""West""]
        n -= self.__w-1
        return [[0, (self.__h-1)-n], ""South""]",O(1)
"def balance(x1, y1, x2, y2):
    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)

def get_lr():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

def get_ud():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

n = int(input())
lr = get_lr()
ud = get_ud()
rr = [lr[0], lr[1]]
ll = [lr[2], lr[3]]
uu = [ud[0], ud[1]]
dd = [ud[2], ud[3]]
for r1 in rr:
    r2 = rr[0] if rr[0] != r1 else rr[1]
    for l1 in ll:
        l2 = ll[0] if ll[0] != l1 else ll[1]
        for u1 in uu:
            u2 = uu[0] if uu[0] != u1 else uu[1]
            for d1 in dd:
                d2 = dd[0] if dd[0] != d1 else dd[1]
                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:
                    continue
                print('?', l1, d1, r1, u1)
                res1 = int(input())
                print('?', l2, d2, r2, u2)
                res2 = int(input())
                if res1 == res2 == 1:
                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)
                    __import__('sys').exit(0)
",O(logn)
"import sys

n=int(input())
A=list(map(int,input().split()))

if sum(A)<2*n-2:
    print(""NO"")
    sys.exit()

ONES=A.count(1)
print(""YES"",min(n-1,n-ONES+1))

NOONE=[]
for i in range(n):
    if A[i]!=1:
        NOONE.append([A[i],i+1])

ANS=[]
for i in range(1,len(NOONE)):
    ANS.append((NOONE[i-1][1],NOONE[i][1]))
    NOONE[i-1][0]-=1
    NOONE[i][0]-=1

NOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]]

LENNO=len(NOONE)

j=0
for i in range(n):
    while j<LENNO and NOONE[j][0]==0:
        j+=1
    if A[i]!=1:
        continue
    ANS.append((i+1,NOONE[j][1]))
    NOONE[j][0]-=1

print(len(ANS))
for a,b in ANS:
    print(a,b)
",O(n)
"class Solution(object):
    def smallestEvenMultiple(self, n):
        return n<<(n&1)",O(1)
"import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))",O(n)
"M = {}

N = int(input())
S = input().strip()

s = set()
for c in S:
    s.add(c)
    M[c] = 0

i = 0; j = -1; aux = 0; ans = 1e10
while j < N - 1:
    j += 1

    M[S[j]] += 1
    if M[S[j]] == 1:
        aux += 1
    while M[S[i]] > 1:
        M[S[i]] -= 1
        i += 1

    if aux == len(s):
        ans = min(ans, j - i + 1)

print(ans)
",O(n)
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

class SG:
    def __init__(self, n, v=None):
        self._n = n
        self.geta = 0
        x = 0
        while (1 << x) < n:
            x += 1
        self._log = x
        self._size = 1 << self._log
        self._d = [ninf] * (2 * self._size)
        if v is not None:
            for i in range(self._n):
                self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)
    def _update(self, k):
        self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def update(self, p, x):
        assert 0 <= p < self._n

        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):

            k = p>>i
            self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def get(self, p):
        assert 0 <= p < self._n
        return self._d[p + self._size]
    def check(self):
        return [self.get(p) for p in range(self._n)]
    def query(self, left, right):

        assert 0 <= left <= right <= self._n
        sml = ninf
        smr = ninf
        left += self._size
        right += self._size

        while left < right:
            if left & 1:
                sml = op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = op(self._d[right], smr)
            left >>= 1
            right >>= 1
        return op(sml, smr)

    def query_all(self):
        return self._d[1]
    def max_right(self, left, f):

        if left == self._n:
            return self._n
        left += self._size
        sm = ninf
        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(op(sm, self._d[left])):
                        sm = op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = op(sm, self._d[left])
            left += 1
        return self._n
    def min_left(self, right, f):

        if right == 0:
            return 0
        right += self._size
        sm = ninf
        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(op(self._d[right], sm)):
                        sm = op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = op(self._d[right], sm)
        return 0
op = max
ninf = 0

n = int(input())
a = list(map(int, input().split()))
vs = [[0]*(n-i) for i in range(n)]
vs[0] = a
for i in range(1,n):
    for j in range(n-i):
        vs[i][j] = vs[i-1][j]^vs[i-1][j+1]
def f(l,r):
    return vs[r-l][l]
ms = [[0]*n for _ in range(n)]
for l in range(n):
    ms[l][l] = f(l,l)
    for r in range(l+1,n):
        ms[l][r] = max(ms[l][r-1], f(l,r))
sgs = []
for r in range(n):
    l = [ms[l][r] for l in range(r+1)]
    sg = SG(len(l), l)
    sgs.append(sg)
q = int(input())
ans = []
for _ in range(q):
    l,r = map(int, input().split())
    l -= 1
    r -= 1
    val = sgs[r].query(l,r+1)
    ans.append(val)

write(""\n"".join(map(str, ans)))",O(n ^ 2)
"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        result, left = 0, 0
        lookup = {}
        for right in range(len(s)):
            if s[right] in lookup:
                left = max(left, lookup[s[right]]+1)
            lookup[s[right]] = right
            result = max(result, right-left+1)
        return result",O(n)
"class Solution(object):
    def largestPalindrome(self, n, k):
        def inv(x, p):
            return pow(x, p-2, p)

        def f(l):
            p = 7
            result = ['9']*l
            if l:                
                curr = reduce(lambda accu, x: (accu*10+(ord(x)-ord('0')))%p, result, 0)
                i = 9-(curr*inv(11 if l%2 == 0 else 1, p)*inv(pow(10, l//2-int(l%2 == 0), p), p))%p
                if i <= 2:
                    i += p
                result[l//2] = result[l//2-int(l%2 == 0)] = str(i)
            return """".join(result)

        if k in (1, 3, 9):
            return '9'*n
        if k in (2, 4, 8):
            k = min(k, 6)
            if n <= k:
                return '8'*n
            l = k//2
            return '8'*l+'9'*(n-k)+'8'*l
        if k == 5:
            if n <= 2:
                return '5'*n
            return '5'+'9'*(n-2)+'5'
        if k == 6:
            if n <= 2:
                return '6'*n
            if n%2:
                l = n//2-1
                return '8'+'9'*l+'8'+'9'*l+'8'
            l = n//2-2
            return '8'+'9'*l+""77""+'9'*l+'8'
        l, r = divmod(n, 12)
        return ""999999""*l+f(r)+""999999""*l",O(n)
"class Solution(object):
    def replaceElements(self, arr):
        curr_max = -1
        for i in reversed(range(len(arr))):
            arr[i], curr_max = curr_max, max(curr_max, arr[i])
        return arr",O(n)
"import collections


class Solution(object):
    def shareCandies(self, candies, k):
        cnt = collections.Counter(candies[i] for i in range(k, len(candies)))
        result = curr = len(cnt)
        for i in range(k, len(candies)):
            cnt[candies[i]] -= 1
            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)
            cnt[candies[i-k]] += 1
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = mx = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            if mx > min(nums[i] for i in range(left, right+1)):
                return False
            mx = max(nums[i] for i in range(left, right+1))
            left = right+1
        return True",O(n)
"n = int(input())
s = input()
want = len(set(s))
d = {}
j = 0
count = 0
ans = float(""inf"")
for i in range(n):
    if s[i] not in d:
        d[s[i]] = 0
        count+=1
    d[s[i]]+=1
    if count==want:
        while d[s[j]]>1:
            d[s[j]]-=1
            j+=1
        ans = min(ans,i-j+1)
print(ans)",O(n)
"class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False",O(n)
"class Solution(object):
    def __init__(self):
        self.__random_length = 6
        self.__tiny_url = ""http://tinyurl.com/""
        self.__alphabet = ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
        self.__lookup = {}

    def encode(self, longUrl):
        def getRand():
            rand = []
            for _ in range(self.__random_length):
                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]
            return """".join(rand)

        key = getRand()
        while key in self.__lookup:
            key = getRand()
        self.__lookup[key] = longUrl
        return self.__tiny_url + key

    def decode(self, shortUrl):
        return self.__lookup[shortUrl[len(self.__tiny_url):]]


from hashlib import sha256",O(1)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",O(n ^ 2)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

MOD = 998244353

N,K = ilele()
if K == 1 or K == 2*N:
    print(2)
    exit(0)
dp = list3d(N+1,4,K+1,0)
dp[1][0][1] = 1
dp[1][3][1] = 1
dp[1][1][2] = 1
dp[1][2][2] = 1

for n in range(2,N+1):
    for k in range(1,K+1):
        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD
        if k > 1:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        else:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD

print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)
",np
"class Solution(object):
    def maximumPopulation(self, logs):
        MIN_YEAR, MAX_YEAR = 1950, 2050
        years = [0]*(MAX_YEAR-MIN_YEAR+1)
        for s, e in logs:
            years[s-MIN_YEAR] += 1
            years[e-MIN_YEAR] -= 1
        result = 0
        for i in range(len(years)):
            if i:
                years[i] += years[i-1]
            if years[i] > years[result]:
                result = i
        return result+MIN_YEAR",O(n)
"class Solution(object):
    def findScore(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: (nums[x], x))
        lookup = [False]*len(nums)
        result = 0
        for i in idxs:
            if lookup[i]:
                continue
            lookup[i] = True
            if i-1 >= 0:
                lookup[i-1] = True
            if i+1 < len(lookup):
                lookup[i+1] = True
            result += nums[i]
        return result",O(nlogn)
"class Solution(object):
    def maxAbsoluteSum(self, nums):
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn",O(n)
"class Solution(object):
    def rob(self, nums):
        last, now = 0, 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now",O(n)
"class Solution(object):
    def convertToTitle(self, n):
        result = []
        while n:
            result += chr((n-1)%26 + ord('A'))
            n = (n-1)//26
        result.reverse()
        return """".join(result)",O(logn)
"class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):
        if width < height:
            width, height = height, width


        R, r = divmod(height, sideLength)
        C, c = divmod(width, sideLength)
        assert(R <= C)
        area_counts = [(r*c, (R+1)*(C+1)), \
                       (r*(sideLength-c), (R+1)*C), \
                       ((sideLength-r)*c, R*(C+1)), \
                       ((sideLength-r)*(sideLength-c), R*C)]
        result = 0
        for area, count in area_counts:
            area = min(maxOnes, area)
            result += count*area
            maxOnes -= area
            if not maxOnes:
                break
        return result",O(1)
"a=[[],[],[]]

s=input().split("" "")

for i in range(len(s)):
	if(s[i][1]=='m'):
		a[0].append(int(s[i][0]))
	elif(s[i][1]=='p'):
		a[1].append(int(s[i][0]))
	else:
		a[2].append(int(s[i][0]))

ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

ans=ko
ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]+1):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	elif(len(a[i])>1 and (a[i][0]+2==a[i][1])):
		ko=min(ko,1)
	elif(len(a[i])>2 and (a[i][1]+2==a[i][2])):
		ko=min(ko,1)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

print(min(ans,ko))
",O(nlogn)
"rnd_mod = 1234567890133
rnd_x = 987654321098
def rnd():
    global rnd_x
    rnd_x = rnd_x**2 % rnd_mod
    return (rnd_x>>5) % (1<<20)
def randrange(a):
    return rnd() % a

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    X = []
    for __ in range(N):
        X.append([int(a) for a in input().split()])
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(577):
        for i in range(M):
            a = randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",O(logn)
"class Solution(object):
    def cherryPickup(self, grid):
        n = len(grid)
        dp = [[-1 for _ in range(n)] for _ in range(n)]
        dp[0][0] = grid[0][0]
        max_len = 2 * (n-1)
        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]
        for k in range(1, max_len+1):
            for i in reversed(range(max(0, k-n+1), min(k+1, n))): 
                for j in reversed(range(i, min(k+1, n))):         
                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:
                        dp[i][j] = -1
                        continue
                    cnt = grid[i][k-i]
                    if i != j:
                        cnt += grid[j][k-j]
                    max_cnt = -1
                    for direction in directions:
                        ii, jj = i+direction[0], j+direction[1]
                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:
                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)
                    dp[i][j] = max_cnt
        return max(dp[n-1][n-1], 0)",O(n ^ 3)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

n=int(input())
a=list(map(int,input().split()))
if n==1:
    print(1)
    sys.exit(0)
dp=[[-1 for j in range (5)] for i in range (n)]
for i in range (1,min(2,n)):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j:
                    ch=k
            dp[i][j]=ch
for i in range (2,n):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch

ind=-1
for i in range (5):
    if dp[-1][i]!=-1:
        ind=i
if ind==-1:
    print(ind)
    sys.exit(0)
res=[ind+1]
for i in range (n-1,0,-1):
    res.append(dp[i][ind]+1)
    ind=dp[i][ind]
print(*res[::-1])",O(n)
"import bisect
n,q=map(int,input().split())
strength=list(map(int,input().split()))
arrows=list(map(int,input().split()))
for i in range(1,n):
    strength[i]+=strength[i-1]
No_arrows=0
n-=1
for i in range(q):
    No_arrows+=arrows[i]
    if(No_arrows>=strength[-1]):
        No_arrows=0
        print(n+1)
    else:
        it=bisect.bisect_left(strength,No_arrows)
        if(strength[it]==No_arrows):
            print(n-it)
        else:
            print(n-it+1)
",O(nlogn)
"class Solution3(object):
    def lengthOfLIS(self, nums):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
    
        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}
        bit = BIT(len(lookup), fn=max)
        for x in nums:
            bit.update(lookup[x], bit.query(lookup[x]-1)+1)
        return bit.query(len(lookup)-1)



class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution3(object):
    def singleNumber(self, nums):
        return [x[0] for x in sorted(list(collections.Counter(nums).items()), key=lambda i: i[1], reverse=False)[:2]]",O(n)
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime=[]
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        if (primes[p] == True):
            prime.append(p)
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    return prime
def factors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac

a = input()
b = a.count('1')
a = a.replace('1','')
c = a.find('2')
if c==-1:
    a = (a+ '1'*b)
else:
    a = a[:c]+ '1'*b + a[c:]
print(a)
",O(n)
"class Solution(object):
    def intToRoman(self, num):
        numeral_map = {1: ""I"", 4: ""IV"", 5: ""V"", 9: ""IX"", \
                       10: ""X"", 40: ""XL"", 50: ""L"", 90: ""XC"", \
                       100: ""C"", 400: ""CD"", 500: ""D"", 900: ""CM"", \
                       1000: ""M""}
        keyset, result = sorted(numeral_map.keys()), []

        while num > 0:
            for key in reversed(keyset):
                while num / key > 0:
                    num -= key
                    result += numeral_map[key]

        return """".join(result)",O(1)
"n,l,r,x = map(int,input().split())
nums = sorted(list(map(int,input().split())))
ans = 0
def recurse(i,sum, dif, cnt):
    global ans
    if i == n:
        if not cnt:
            return
        if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x:
            ans += 1
        return
    recurse(i+1,sum,dif,cnt[:])
    cnt.append(nums[i])
    recurse(i+1,sum+nums[i],dif,cnt[:])
recurse(0,0,0,[])
print(ans)",np
"from heapq import heappush, heappop
n = int(input())
L = list(map(int, input().split()))
T = input()

ans = sum(L)

Q = []

for l, t in zip(L, T):
    if t == 'G':
        heappush(Q, (2, 2 * l))
        heappush(Q, (5, float('inf')))
    elif t == 'W':
        heappush(Q, (1, 2 * l))
        heappush(Q, (3, float('inf')))

    need_stamina = l
    while need_stamina > 0:
        cost, quantity = heappop(Q)
        if need_stamina > quantity:
            ans += quantity * cost
            need_stamina -= quantity
        else:
            ans += need_stamina * cost
            heappush(Q, (cost, quantity - need_stamina))
            need_stamina = 0

print(ans)
",O(nlogn)
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k):
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1:
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))

print(dp(nr-1,ng-1,nb-1))",O(n ^ 3)
"class Solution(object):
    def minMaxGame(self, nums):
        n = len(nums)
        while n != 1:
            new_q = []
            for i in range(n//2):
                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]",O(n)
"import sys
input=sys.stdin.readline
def getsum(BITTree,i):
    i=i+1
    s = 0
    while i > 0:
        s += BITTree[i]
        i -= i & (-i)
    return(s)
def updatebit(BITTree , n , i ,v):
    i=i+1
    while i <= n:
        BITTree[i] += v
        i += i & (-i)

n=int(input())
lista=[int(i) for i in input().split()]
invercount=0
bitTree=[0]*(n+2)
for k in reversed(lista):
        updatebit(bitTree,n+1,k,1)
        counter=getsum(bitTree,k-1)
        invercount+=counter
m=int(input())
for i in range(m):
    l,r=map(int,input().split())
    summa=((r-l+1)*(r-l))/2
    if (invercount+summa)%2:
        print('odd')
        invercount=1
    else:
        print('even')
        invercount=0
",O(n ^ 2)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2002)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2002):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"for t in range(int(input())):
	n, k = map(int, input().split())
	lev = 1
	b = False
	if n >= 60:
		all_moves = 0
		b = True
	else:
		all_moves = (4 ** n - 1) // 3

	cnt = 1
	step = 0
	prev_need = 0
	while True:
		need = 2 * cnt - 1

		if k >= need and step < n:
			k -= need
			all_moves -= need
			cnt *= 2
			step += 1
			prev_need = need
		else:
			if b:
				print('YES', n - step)
				break
			if all_moves < k:
				print('NO')
				break

			all_moves -= (4 ** (n - step)) // 3 * need
			if all_moves >= k or b:
				print('YES', n - step)
				break
			else:
				print('NO')
				break",O(logn)
"n = int(input())
game = list(map(int, input().split()))
game.append(-1)
game.sort()
bitSum = game[1] % 2
rep = False
for i in range(1, n):
    bitSum += game[i + 1] % 2
    if game[i] == game[i + 1]:
        if rep:
            print('cslnb')
            exit(0)
        else:
            if game[i - 1] == game[i] - 1:
                print('cslnb')
                exit(0)
            rep = True
Goal = ((n * (n - 1)) / 2) % 2
if (bitSum + Goal) % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')",O(nlogn)
"class Solution(object):
    def maxVowels(self, s, k):
        VOWELS = set(""aeiou"")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i >= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result",O(n)
"n,m=map(int,raw_input().split())
arr=[]
arr1=[]
for i in range(n):
	arr2=str(raw_input())
	arr.append(arr2)
	x1=[0]*m
	arr1.append(x1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]=='
			if(arr[i][j+1]=='
				arr1[i][j]=1
				arr1[i+1][j]=1
				arr1[i+2][j]=1
				arr1[i+2][j+1]=1
				arr1[i+2][j+2]=1
				arr1[i+1][j+2]=1
				arr1[i][j+1]=1
				arr1[i][j+2]=1
flag=0

for i in range(n):
	for j in range(m):
		if(arr[i][j]==""
			flag=1
			break
	if(flag==1):
		break
if(flag==1):
	print(""NO"")
else:
	print(""YES"")",O(n ^ 2)
"dict={""Power"":""purple"",
      ""Time"":""green"",
      ""Space"":""blue"",
      ""Soul"":""orange"",
      ""Reality"":""red"",
      ""Mind"":""yellow""}
dict1={}
n=(int(input()))
while n:
    str=input()
    if str==""purple"":
        dict1[""Power""]=str
    elif str==""green"":
        dict1[""Time""]=str
    elif str==""blue"":
        dict1[""Space""]=str
    elif str==""orange"":
        dict1[""Soul""]=str
    elif str==""red"":
        dict1[""Reality""]=str
    elif str==""yellow"":
        dict1[""Mind""]=str
    n-=1

val=list(dict.keys())
val_list=list(dict1.keys())
l=[key for key in val if key not in val_list]
print(len(l))
for i in range(len(l)):
    print(l[i])",O(1)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def insertFront(self, value):
        if self.isFull():
            return False
        self.__start = (self.__start-1) % len(self.__buffer)
        self.__buffer[self.__start] = value
        self.__size += 1
        return True

    def insertLast(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deleteFront(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def deleteLast(self):
        if self.isEmpty():
            return False
        self.__size -= 1
        return True

    def getFront(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def getRear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"n = int(input())
s = list(input())
t = input()
if sorted(s) != sorted(t):
    print(-1)
else:
    lst = [0] * n
    for i in range(n):
        for j in range(n):
            if s[j] == t[i]:
                lst[j] = i + 1
                s[j] = "".""
                break
    ans = 0
    a = []
    for i in range(n):
        for j in range(n - 1):
            if i != j:
                if lst[j] > lst[j + 1]:
                    ans += 1
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
                    a.append(j+1)
    print(ans)
    print(*a)",O(n ^ 2)
"def f(ar):
	mx = ar.index(max(ar))
	cmark = 0
	ans = 0
	big = [0] * (len(ar))
	for i in range(len(ar) - 1, -1, -1):

		cmark = max(cmark - 1, ar[i] + 1, 0)
		big[i] = cmark
	cmark = 0
	t=[0]*(len(ar))
	for i in range(len(ar)):
		cmark = max(cmark, big[i])
		t[i]=cmark
	ans=0
	for i in range(len(ar)):
		t[i]=t[i]-ar[i]-1
	return (sum(t))

a = input()
print(f([*map(int, input().strip().split())]))
",O(n)
"n, m, k = map(int, input().split())
A = list(map(int, input().split()))
glans = 0
for s in range(m):
    B = []
    f = s
    su = 0
    sus = 0
    for i in range(s, n):
        su += A[i]
        sus = max(sus, su)
        if (i + 1) % m == s:
            B.append(sus - k)
            B.append(su - sus)
            su = 0
            sus = 0
            f = i + 1
    dob = 0
    klol = 0
    for j in range(f, n):
        dob += A[j]
        klol = max(klol, dob - k)
    B = [0] + B + [klol]
    for i in range(1, len(B)):
        B[i] += B[i - 1]
    cnt = -10 ** 10
    ans = [0, 0]
    minsum = 10 ** 10
    candidat = 0
    for i in range(len(B)):
        if B[i] - minsum > cnt:
            cnt = B[i] - minsum
            ans[1] = i
            ans[0] = candidat
        if B[i] <= minsum:
            minsum = B[i]
            candidat = i
    glans = max(glans, B[ans[1]] - B[ans[0]])
print(glans)",O(n ^ 2)
"class Solution(object):
    def removeKdigits(self, num, k):
        result = []
        for d in num:
            while k and result and result[-1] > d:
                result.pop()
                k -= 1
            result.append(d)
        return ''.join(result).lstrip('0')[:-k or None] or '0'",O(n)
"import math
import sys

def minPut(n):
    return math.ceil((-1 + math.sqrt(1-4*(-n*2))) / 2)
def nCandies(n):
    return int(n*(n+1)/2)

actions, candies = map(int, sys.stdin.readline().split())

put = minPut(candies)
putCandies = nCandies(put)

eat = putCandies - candies

while put + eat < actions:
    eat += put + 1
    put += 1

print(eat)",O(logn)
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",O(n)
"n,m=[int(x) for x in input().split(' ')]
print((n-1)*'4'+'5')
print(n*'5')
",O(1)
"import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result",O(n)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)",O(n)
"n=int(input())
if n==1:
    print(1)
else:
    p=list(map(int,input().split()))
    children=[]
    for i in range(n):
        children.append([])
    for i in range(n-1):
        children[p[i]-1].append(i+1)
    layers=[1]+[0]*(n-1)
    layer=[0]
    num=2
    bylayer=[]
    while len(layer)>0:
        bylayer.append(layer)
        newlayer=[]
        for vert in layer:
            for child in children[vert]:
                layers[child]=num
                newlayer.append(child)
        layer=newlayer
        num+=1
    bylayer=bylayer[::-1]
    count=[0]*n
    for layer in bylayer:
        for vert in layer:
            if children[vert]==[]:
                count[vert]=1
            else:
                count[vert]=sum(count[v] for v in children[vert])
    count.sort()
    out=""""
    for guy in count:
        out+=str(guy)+"" ""
    print(out)",O(n ^ 2)
"from sys import stdin, stdout
n=int(input())
s=list(map(int,stdin.readline().strip().split()))
dp=[[-1 for i in range(n+1)]for j in range(n+1)]
for i in range(n):
    dp[0][i]=s[i]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])
q=int(input())
ans=""""
for i in range(q):
    l,r=map(int,stdin.readline().strip().split())
    print(dp[r-l][l-1])
",O(n ^ 2)
"actual = input()
processed = input()

def factorial(num: int):
    res = 1
    while num >= 1:
        res *= num
        num -= 1
    return res

actualPos = actual.count('+')
actualNeg = actual.count('-')
processedPos = processed.count('+')
processedNeg = processed.count('-')

if processedPos > actualPos or processedNeg > actualNeg:
    print(0)
elif processedPos == actualPos and processedNeg == actualNeg:
    print(1)
else:
    remainPos = actualPos - processedPos
    remainNeg = actualNeg - processedNeg

    print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** (
            remainPos + remainNeg))
",np
"arr = []
d = {}
for _ in range(int(input())):
    s = input()
    a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split(""."")))
    x = (a+b)/c
    arr.append(x)
    if x not in d:
        d[x] = 0
    d[x] += 1

for i in arr:
    print(d[i], end = "" "")",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():

    n=int(input())
    a=[]
    for i in range(n):
        a.append(list(map(int, input().split())))
    d={}
    if n==1:
        print('YES')
        return
    vis=[0]*n
    for i in range(1,n):
        num=abs(a[i][1]-a[0][1])
        den=abs(a[i][0]-a[0][0])
        k=1
        k=gcd(num, den)
        num//=k
        den//=k
        if ((a[i][1]-a[0][1])*(a[i][0]-a[0][0]))<0:
            num*=-1
        if (num, den) in d:
            d[(num, den)].append(i)
        else:
            d[(num, den)]=[i]
    maxx=0

    for i in d.keys():
        if len(d[i])>maxx:
            maxx=len(d[i])
            ki=i
    vis[0]=1
    for i in d[ki]:
        vis[i]=1
    t=[]
    for i in range(n):
        if not vis[i]:
            t.append(i)
    f=1
    if len(t)>1:
        num=abs(a[t[0]][1]-a[t[1]][1])
        den=abs(a[t[0]][0]-a[t[1]][0])
        k = 1
        k=gcd(num, den)
        num//=k
        den//=k
        if (a[t[0]][1]-a[t[1]][1])*(a[t[0]][0]-a[t[1]][0])<0:
            num*=-1
        m=(num, den)
        for i in range(2, len(t)):
            num = abs(a[t[i]][1] - a[t[0]][1])
            den = abs(a[t[i]][0] - a[t[0]][0])
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                num *= -1
            if (num,den)!=m:
                f=0
    if f:
        print('YES')
    else:
        d = {}
        if n == 1:
            print('YES')
            return
        vis = [0] * n
        a[0], a[1]=a[1], a[0]
        for i in range(1, n):
            num = abs(a[i][1] - a[0][1])
            den = abs(a[i][0] - a[0][0])
            k = 1
            k = gcd(num, den)
            num //= k
            den //= k
            if ((a[i][1] - a[0][1]) * (a[i][0] - a[0][0])) < 0:
                num *= -1
            if (num, den) in d:
                d[(num, den)].append(i)
            else:
                d[(num, den)] = [i]
        maxx = 0

        for i in d.keys():
            if len(d[i]) > maxx:
                maxx = len(d[i])
                ki = i
        vis[0] = 1
        for i in d[ki]:
            vis[i] = 1
        t = []
        for i in range(n):
            if not vis[i]:
                t.append(i)
        f = 1
        if len(t) > 1:
            num = abs(a[t[0]][1] - a[t[1]][1])
            den = abs(a[t[0]][0] - a[t[1]][0])
            k = 1
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[1]][1]) * (a[t[0]][0] - a[t[1]][0]) < 0:
                num *= -1
            m = (num, den)
            for i in range(2, len(t)):
                num = abs(a[t[i]][1] - a[t[0]][1])
                den = abs(a[t[i]][0] - a[t[0]][0])
                k = 1
                k=gcd(num, den)
                num //= k
                den //= k
                if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                    num *= -1
                if (num, den) != m:
                    f = 0
        if f:
            print('YES')
        else:
            print('NO')

    return

if __name__ == ""__main__"":
    main()",O(nlogn)
"import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):
        heapq.heapify(blocks)
        while len(blocks) != 1:
            x, y = heapq.heappop(blocks), heapq.heappop(blocks)
            heapq.heappush(blocks, y+split)
        return heapq.heappop(blocks)",O(nlogn)
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",np
"class Solution3(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        for i in range(pos):
            for j in range(pos+1, len(expression)):
                val = (int(expression[:i] or ""1"")*
                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*
                       int(expression[j+1:] or ""1"")) 
                if val < min_val:
                    min_val = val
                    best = (i, j)
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"import collections



class Solution(object):
    def countNonDecreasingSubarrays(self, nums, k):
        result = cnt = 0
        dq = collections.deque()
        right = len(nums)-1
        for left in reversed(range(len(nums))):
            while dq and nums[dq[-1]] < nums[left]:
                l = dq.pop()
                r = dq[-1]-1 if dq else right
                cnt += (r-l+1)*(nums[left]-nums[l])
            dq.append(left)
            while cnt > k:
                cnt -= nums[dq[0]]-nums[right]
                if dq[0] == right:
                    dq.popleft()
                right -= 1
            result += right-left+1
        return result",O(n)
"from sys import stdin
from bisect import bisect_right as br

from collections import deque
n,m,k=map(int,stdin.readline().strip().split())
s=deque(map(int,stdin.readline().strip().split()))
lim=k
ans=0
while len(s)!=0:
    x=br(s,lim)
    for i in range(x):
        s.popleft()
    if x!=0:
        ans+=1
        lim+=x
    else:
        if len(s)>0:
            x=s[0]-lim
            if x%k==0:
                x=x//k
            else:
                x=(x//k)+1
            lim+=x*k

print(ans)
",O(n)
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np
"from sys import stdout
m = 30
a, b = 0, 0
fle = 1
for i in range(m):
    if fle:
        print('? {} {}'.format(a, b))
        stdout.flush()
        resp1 = int(raw_input())
        fle = 0
    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))
    stdout.flush()
    resp2 = int(raw_input())

    if resp1 == -1 and resp2 == 1:
        b += 2**(m-1-i)
        fle = 1
    elif resp1 == 1 and resp2 == -1:
        a += 2**(m-1-i)
        fle = 1
    else:
        fle = 0
        print('? {} {}'.format(a + 2**(m-1-i), b))
        stdout.flush()
        resp3 = int(raw_input())
        if resp3 == -1:
            b += 2**(m-1-i)
            a += 2**(m-1-i)

print('! {} {}'.format(a,b))
stdout.flush()",O(1)
"import sys, math, queue

MOD = 10**9+7
sys.setrecursionlimit(1000000)

def hgt(x):
    if x == 0: return -1
    h = 0
    while x&1 != 1:
        h += 1
        x = x>>1
    return h

def up(x):
    h = hgt(x)
    g = x + (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    g = x - (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    return x

def left(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x - (1<<(h-1))
    if g > 0:
        return g
    return x

def right(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x + (1<<(h-1))
    if g < N:
        return g
    return x

N, q = map(int, input().split())
N += 1
for _ in range(q):
    p = int(input())
    for c in input():
        if c == 'U':
            p = up(p)
        elif c == 'R':
            p = right(p)
        else:
            p = left(p)
    print(p)",np
"a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
b=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
print(a)
print(b)
",O(1)
"n,m=map(int,input().split())
arr=[]
for i in range(m):
  arr.append(list(map(int,input().split())))
k=0;ans=str()
for i in range(n):
  ans+=str(k^1)
  k=k^1
print(ans)
",O(n)
"class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'",O(nlogn)
"import sys
import math
import itertools
import functools
import collections
import operator

def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

n, k = mi()
t = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)
print(n - t)
",O(logn)
"class Solution(object):
    def threeConsecutiveOdds(self, arr):
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False",O(n)
"n = int(input())
a = [int(i) for i in input().split()]

total = sum(a)
final = n * (n-1) // 2
repeated = []
count = {}

for i in a:
    try:
        count[i] += 1
        repeated.append(i)
    except KeyError:
        count[i] = 1

moves = total - final

if len(repeated) > 1:
    print('cslnb')

elif 0 in repeated:
    print('cslnb')

elif len(repeated) == 1 and repeated[0] - 1 in a:
    print('cslnb')

else:
    if moves % 2 == 0 or moves <= 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"from itertools import combinations
n, mn, mx, diff = map(int, input().split())
arr = list(map(int, input().split()))
print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))
",np
"class Solution2(object):
    def dayOfYear(self, date):
        def numberOfDays(Y, M):
            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
            return (28+leap if (M == 2) else 31-(M-1)%7%2)

        Y, M, result = list(map(int, date.split(""-"")))
        for i in range(1, M):
            result += numberOfDays(Y, i)
        return result",O(1)
"class Solution(object):
    def minimumDistance(self, points):
        def max_distance(exclude):
            max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), 
                       (max_diff[0]-min_diff[0], max_diff[1], min_diff[1]))
        
        _, i, j = max_distance(-1)
        return min(max_distance(i)[0], max_distance(j)[0])",O(n)
"import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        K = 3

        result = 0
        count = collections.Counter()
        for i in range(len(s)):
            if i >= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result",O(n)
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
print(max((0,2*x+y-a))+max((0,3*z+y-b)))",O(1)
"a,b = list(input()),int(input())
ans = """"
a.sort(reverse=True)
while len(a)>0:
    for i in range(len(a)):
        num = ans+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if int(num)<=b:
            ans += a[i]
            a = a[:i]+a[i+1:]
            break
print(ans)",O(n ^ 3)
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break
if p == True:
    print(""YES"")
else:
    print(""NO"")",O(1)
"class Solution(object):
    def countDigitOne(self, n):
        DIGIT = 1
        is_zero = int(DIGIT == 0)
        result = is_zero
        base = 1
        while n >= base:
            result += (n//(10*base)-is_zero)*base + \
                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))
            base *= 10
        return result",O(logn)
"class Solution(object):
    def kLengthApart(self, nums, k):
        prev = -k-1
        for i in range(len(nums)):
            if not nums[i]:
                continue
            if i-prev <= k:
                return False
            prev = i
        return True",O(n)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:
        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()
    i += 1",O(nlogn)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""}
s = set()
n = int(input())
for _ in range(n):
	w = input()
	s.add(w)
print(6 - n)
for (key, value) in d.items():
	if key not in s:
		print(value)",O(1)
"def rotate(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        for y in range (0,n):
            newli[x][y] = li[n-1-y][x]
    return newli

def flipV(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()
    newli.reverse()
    return newli

def flipH(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        newli[x].reverse()
    return newli

n = int(input())

li1, li2, li3, templi = [], [], [], []

for x in range (0,n):
    li1.append([])
    li2.append([])
    li3.append([])
    templi.append([])
    li1[x]=list(input())

for x in range (0,n):
    li2[x]=list(input())

if ( li1 ==li2 ):
    print('Yes')
    exit()

templi = flipH(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = flipV(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = flipH(li2)
templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

print('No')
",O(n ^ 2)
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",O(n)
"from collections import Counter
class Solution3(object):
    def findDuplicates(self, nums):
        return [elem for elem, count in list(Counter(nums).items()) if count == 2]",O(n)
"class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result",O(n)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        xorr = n
        for i in range(n):
            xorr ^= i ^ nums[i]
        return xorr
",O(n)
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K
	return res

c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)
",O(n ^ 3)
"class Solution(object):
    def findMinimumTime(self, strength):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        K = 1
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"def func(mid,s):
    p=0
    q=mid
    while (mid>0):
        p+=mid%10
        mid=mid//10

    if (q-p)>=s:
        return True
    else:
        return False
n,s=map(int,input().split())
do=1
up=10**18
an=n+1
while (up>=do):
    mid=(up+do)//2
    if func(mid,s):
        up=mid-1
        an=mid
    else:
        do=mid+1
if an>n:
    print(0)
else:
    print(n-an+1)",O(logn)
"n,k=map(int,input().split())
if(k%2==0):
    print(""YES"")
    print('.'*n)
    print('.'+'
    print('.'+'
    print('.'*n)
else:
    print(""YES"")
    print('.'*n)
    if(k<=n-2):
        print('.'*((n-k)//2)+'
        print('.'*n)
    else:
        print('.'+'
        print('.'+'
    print('.'*n)
",O(n)
"def main():
    n, d, k = map(int, input().split())
    _min = d+1

    if n < _min:
        print('NO')
    else:
        res = []
        deg = [0] * (n+1)
        dist = [0] * (n+1)

        stack = []
        deg[1] = 1
        for i in range(1, d+1):
            res.append((i, i+1))
            if i > 1:
                deg[i] += 2
            dist[i] = max(i-1, d+1-i)
        dist[d+1] = d
        deg[d+1] = 1

        for i in range(2, d+1):
            stack.append(i)

        next = d+2
        while stack:
            if next > n:
                break
            v = stack.pop()
            if dist[v] < d:
                while next <= n and deg[v] < k:
                    res.append((v, next))
                    deg[v] += 1
                    deg[next] += 1
                    dist[next] = dist[v] + 1
                    if dist[next] < d:
                        stack.append(next)
                    next += 1

        ok = next > n
        ok &= all(deg[i] <= k for i in range(1, n+1))
        ok &= all(dist[i] <= d for i in range(1, n+1))

        if not ok:
            print('NO')
        else:
            print('YES')
            for e in res:
                print(*e)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import collections
import random
from functools import reduce



class Solution(object):
    def countKSubsequencesWithMaxBeauty(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        cnt = collections.Counter(s)
        if len(cnt) < k:
            return 0
        freqs = list(cnt.values())
        nth_element(freqs, k-1, lambda a, b: a > b)
        n = freqs.count(freqs[k-1])
        r = sum(freqs[i] == freqs[k-1] for i in range(k))
        return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in range(k)), 1)*nCr(n, r)%MOD",O(n)
"from math import gcd
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    print(d[i],end="" "")
",O(n)
"class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        dp = [[-1 for _ in range(len(colors))] for _ in range(3)]
        dp[colors[0]-1][0] = 0
        for i in range(1, len(colors)):
            for color in range(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(range(len(colors)-1)):
            for color in range(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]",O(n)
"class Solution(object):
    def maximumGroups(self, grades):
        return int(((1+8*len(grades))**0.5-1)/2.0)",O(1)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n=int(input())
    prob=[]
    for _ in range(n):
        prob.append(list(map(float,input().split())))

    dp=[-1 for _ in range(1<<n)]

    ans=[0 for _ in range(n)]

    def move(mask,die):

        total=bin(mask).count('1')

        z=0

        for i in range(n):
            if mask & (1<<i):
                z+=prob[i][die]

        return z/((total*(total-1))>>1)

    def solve(mask):

        if mask==(1<<n)-1:
            return 1

        if dp[mask]!=-1:
            return dp[mask]

        ans=0
        for i in range(n):
            if not (mask & (1<<i)):
                prev=solve(mask ^ (1<<i))

                ans+=prev*move(mask ^ (1<<i),i)

        dp[mask]=ans
        return ans

    for i in range(n):
        ans[i]='%.6f'%solve(1<<i)

    print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",np
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))",O(n)
"from collections import Counter

def mx(f):
    res = []
    for k in sorted(f.keys(), reverse=True):
        for _ in range(f[k]):
            res.append(k)
    return res

def solve(n, a, b):
    res = None
    for k in range(n + 1):
        aa = Counter(a)
        cur = []
        for i in range(k):
            if aa[b[i]] == 0:
                return res
            cur.append(b[i])
            aa[b[i]] -= 1
        if k < n:
            for e in range(b[k] - 1, -1, -1):
                if aa[e] > 0:
                    cur.append(e)
                    aa[e] -= 1
                    cur.extend(mx(aa))
                    break
            if len(cur) < n:
                continue
        res = cur
    return res

a = Counter(map(int, input()))
b = list(map(int, input()))
if sum(a.values()) < len(b):
    res = mx(a)
else:
    res = solve(len(b), a, b)
print(''.join(map(str, res)))",O(n ^ 3)
"n,s=map(int,input().split())
x=s//n
if x*n<s:
    x+=1
print(x)",O(1)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
b.sort()
g.sort()
if b[-1] > g[0]:
    print(-1)
    import sys
    sys.exit(0)
a = 0
a += sum(g) - g[0]
if g[0] == b[-1]:
    a += g[0]
    a += m * sum(b[:-1])
    print(a)
else:
    a += g[0]
    a += m * sum(b[:-2]) + (m - 1) * b[-2] + b[-1]
    print(a)
",O(nlogn)
"import sys
input = sys.stdin.readline
def multi_input():
    return map(int, input().split())

def sum(n,r):
    return n*(2*r - (n-1))//2

def function(total, l, r):
    left = l
    right = r

    while left<=right:
        mid = (right + left) // 2
        result = sum(r-mid+1, r)
        if result==total:
            return r-mid+1
        elif result > total:
            left = mid + 1
        else:
            if sum(r-mid+2,r) > total:
                return r-mid + 2
            else:
                right = mid - 1
    return -1

n, m = multi_input()

n = n-1
m = m-1
if n==0:
    print(0)
elif sum(m,m)<n:
    print(-1)
elif m<n:
    print(function(n, 1, m))
else:
    print(1)
",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxPathSum(self, root):
        def iter_dfs(node):
            result = float(""-inf"")
            max_sum = [0]
            stk = [(1, [node, max_sum])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))
                    ret[0] = node.val+max(ret1[0], ret2[0], 0)
            return result
        
        return iter_dfs(root)",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

def get_ans(x):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo)
    print(""{} {}"".format(i+1,j+1))
",np
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result",O(n)
"class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]",O(1)
"from math import sqrt
n, k = map(int, input().split())
a = 1
b = -1 * (2*n + 3)
c = n * (n + 1) - 2 * k

res = (-1 * b) - sqrt((b * b) - 4 * a * c)
res = res / 2
res = int(res)
print(res)
",O(logn)
"a = [int(i) for i in list(input())]
b = [int(i) for i in list(input())]

if (len(a)<len(b)):
	a.sort(reverse=True)
	ans = 0
	for i in range(len(a)):
		ans = ans*10+a[i]
	print(ans)
else:

	ans = 0
	n = len(a)
	count = [0]*10
	for i in range(n):
		count[a[i]] += 1
	i = 0
	while (i<n):
		x = b[i]
		if (count[x]>0):
			ans = ans*10+x
			count[x] -= 1
			i += 1
		else:
			break
	if (i==n):
		print(ans)
		exit(0)
	x = b[i]
	flag = False
	for j in range(x-1,-1,-1):
		if (count[j]>0):
			ans = ans*10+j
			count[j] -= 1
			flag = True
			break
	if (flag) :
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	else:
		while (not flag):
			t = ans%10
			ans = ans//10
			count[t] += 1
			for i in range(t-1,-1,-1):
				if (count[i]>0):
					count[i] -= 1
					flag = True
					ans = ans*10 + i
					break
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	print(ans)
",O(n ^ 3)
"class Solution(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(2)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i % 2][0] = 1
            else:
                size[i % 2][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i % 2][j] = min(size[i % 2][j - 1], \
                                         size[(i - 1) % 2][j], \
                                         size[(i - 1) % 2][j - 1]) + 1
                    max_size = max(max_size, size[i % 2][j])
                else:
                    size[i % 2][j] = 0

        return max_size * max_size",O(n ^ 2)
"import math
n=int(input())

a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p

ans=10**(i-1) - 1 + math.ceil(k/(i))

if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",O(1)
"class Solution(object):
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left",O(logn)
"l,r=map(int,input().split())
print(2**(l^r).bit_length()-1)",O(logn)
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"n, m = map(int, input().split())
buf = []
for i in range(n//2):
    for j in range(m):
        buf.append(f'{i + 1} {j + 1}\n')
        buf.append(f'{n - i} {m - j}\n')

if n % 2 == 1:
    for j in range(m // 2):
        buf.append(f'{n // 2 + 1} {j + 1}\n')
        buf.append(f'{n // 2 + 1} {m - j}\n')
    if m % 2 == 1:
        buf.append(f'{n//2 + 1} {m//2 + 1}\n')
print(*buf, sep='')",O(n ^ 2)
"from sys import stdin,stdout
from math import gcd, ceil, sqrt
from itertools import combinations
from collections import Counter
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
mod = 1000000007

n, l, r, x = iia()
arr = iia()
count = 0
for i in range(2, n + 1):
    t = combinations(arr, i)
    for j in t:
        if sum(j) >= l and sum(j) <= r \
            and max(j) - min(j) >= x:
            count += 1
print(count)
",np
"class Solution(object):
    def canCross(self, stones):
        if stones[1] != 1:
            return False

        last_jump_units = {s: set() for s in stones}
        last_jump_units[1].add(1)
        for s in stones[:-1]:
            for j in last_jump_units[s]:
                for k in (j-1, j, j+1):
                    if k > 0 and s+k in last_jump_units:
                        last_jump_units[s+k].add(k)
        return bool(last_jump_units[stones[-1]])",O(n ^ 2)
"def wzor(n):
    return (n*(n+1))/2

def mafia():
    pom = [int(x) for x in input().split()]
    n = pom[0]
    c = pom[1]

    po = 1
    ko = n
    sr = (po + ko)//2
    while po != ko:
        if wzor(sr)-(n-sr) >= c:
            ko = sr
        else:
            po = sr+1
        sr = (po+ko)//2

    print(int(wzor(po)-c))

mafia()
",O(logn)
"n = int(input())
i = 0
s = 0
while True:
	temp = (i+1)*9*(10**i)
	if s + temp <= n:
		s += temp
		i += 1
	else:
		break
tc = n - s

nd = tc//(i+1) - 1
tc -= (nd+1)*(i+1)
f = 10**i + nd
if tc != 0:
	print(str(10**i+nd+1)[tc-1])
else:
	print(str(10**i+nd)[-1])
",O(logn)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"import collections



class Solution(object):
    def mostFrequent(self, nums, key):
        return collections.Counter(nums[i+1] for i in range(len(nums)-1) if nums[i] == key).most_common(1)[0][0]",O(n)
"import random



class Solution(object):
    def minOperationsToMakeMedianK(self, nums, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        nth_element(nums, len(nums)//2)
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)

    def hasNext(self):
        return self.__stk

    def __next__(self):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        return node.val
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",O(1)
"import bisect



class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"def solve():
    n = int(input())
    a_dicts = [{}, {}]
    for j in range(2):
        for i in range(n):
            x = input()
            if x in a_dicts[j]:
                a_dicts[j][x] += 1
            else:
                a_dicts[j][x] = 1
            if x not in a_dicts[1 - j]:
                a_dicts[1 - j][x] = 0
    c = 0
    for k in a_dicts[0]:
        c += abs(a_dicts[0][k] - a_dicts[1][k])
    return c // 2

print(solve())",O(n)
"class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result",O(nlogn)
"import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        result = 0
        dq = collections.deque([-1])
        for i in range(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) > k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result",O(n)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"class Solution:
    def reverse(self, x: int) -> int:
        org = x
        x = abs(x)
        res = int(str(x)[::-1])
        if org < 0:
            res *= -1
        if res < -(1 << 31) or res > (1 << 31) - 1:
            return 0
        return res
",O(1)
"import io, sys, atexit, os
import math as ma
from sys import exit
from decimal import Decimal as dec
from itertools import permutations
from itertools import combinations

def li ():
	return list (map (int, input ().split ()))

def num ():
	return map (int, input ().split ())

def nu ():
	return int (input ())

def find_gcd ( x, y ):
	while (y):
		x, y = y, x % y
	return x

def lcm ( x, y ):
	gg = find_gcd (x, y)
	return (x * y // gg)

mm = 1000000007
yp = 0

def isPrime ( n ):

	if (n <= 1):
		return False
	if (n <= 3):
		return True

	if (n % 2 == 0 or n % 3 == 0):
		return False

	i = 5
	while (i * i <= n):
		if (n % i == 0 or n % (i + 2) == 0):
			return False
		i = i + 6

	return True

def solve ():
	t = 1
	for tt in range (t):
		n,k=num()
		d=ma.sqrt(9+8*(n+k))
		gp=(-3+d)/2
		print(int(n-gp))

if __name__ == ""__main__"":
	solve ()",O(logn)
"class Solution2(object):
    def maxRepOpt1(self, text):
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in range(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result",O(n)
"import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root",O(n)
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    arr = get_array()
    arr.sort()
    tmp = [-1] * n
    c = 1
    for i in range(n):
        if tmp[i] != -1:
            continue
        x = arr[i]
        for j in range(i, n):
            if arr[j] % x == 0:
                tmp[j] = c
        c += 1

    print(c - 1)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array():
    return list(map(int, sys.stdin.readline().split()))

def get_ints():
    return map(int, sys.stdin.readline().split())

def input():
    return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=1
    for _ in range(tc):

        s=2*rs()+""333""
        le=(len(s)-3)//2
        a=[]
        for i in s:
            if i=='b':
                a.append(0)
            if i=='w':
                a.append(1)
            if i=='3':
                a.append(3)
        pehla=[0,1]*len(s)

        doosra=[1,0]*len(s)

        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==pehla[i]:
                k[i]=1
        ans=0
        t=0
        for i in k:
            if i==1:
                t+=1

            else:
                ans=max(t,ans)
                t=0

        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==doosra[i]:
                k[i]=1

        t=0
        for i in k:
            if i==1:
                t+=1

            else:
                ans=max(t,ans)
                t=0

        print(min(le,ans))

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"class SegTree:
    def __init__(self, init_val, ide_ele, segfunc):
        self.n = len(init_val)
        self.num = 2**(self.n-1).bit_length()
        self.ide_ele = ide_ele
        self.segfunc = segfunc
        self.seg = [ide_ele]*2*self.num

        for i in range(self.n):
            self.seg[i+self.num] = init_val[i]

        for i in range(self.num-1, 0, -1):
            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])

    def update(self, k, x):
        k += self.num
        self.seg[k] = x
        while k:
            k = k >> 1
            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])

    def query(self, l, r):
        if r <= l:
            return self.ide_ele
        l += self.num
        r += self.num
        lres = self.ide_ele
        rres = self.ide_ele
        while l < r:
            if r & 1:
                r -= 1
                rres = self.segfunc(self.seg[r], rres)
            if l & 1:
                lres = self.segfunc(lres, self.seg[l])
                l += 1
            l = l >> 1
            r = r >> 1
        res = self.segfunc(lres, rres)
        return res

    def __str__(self):
        arr = [self.query(i,i+1) for i in range(self.n)]
        return str(arr)

n = int(input())
S = list(map(int, input().split()))
C = list(map(int, input().split()))
SA = list(set(S))
SA = sorted(SA)
d = {}
for i, s in enumerate(SA):
    d[s] = i
S = [d[s] for s in S]
L = [0]*n
R = [0]*n
INF = 10**18
N = len(d)
seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[0], C[0])
for i in range(1, n-1):
    s = S[i]
    L[i] = seg.query(0, s)
    seg.update(s, C[i])

seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[-1], C[-1])
for i in reversed(range(1, n-1)):
    s = S[i]
    R[i] = seg.query(s+1, seg.n)
    seg.update(s, C[i])

ans = INF
for i in range(1, n-1):
    ans = min(ans, L[i]+C[i]+R[i])
if ans >= INF:
    print(-1)
else:
    print(ans)
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
u = [0] * (n+1)
for i in range(n):
    if u[i] == 0:
        ans+=1
    for j in range(i, n):
        if a[j] % a[i] == 0:
            u[j] = 1
print(ans)",O(n ^ 2)
"import bisect


class Solution(object):
    def findRightInterval(self, intervals):
        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))
        result = []
        for interval in intervals:
            idx = bisect.bisect_left(sorted_intervals, (interval.end,))
            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)
        return result",O(nlogn)
"import sys

n, m, k = map(int, input().split())
table = [input() for _ in range(n)]

dp = [0]*(k+1)

for a in table:
    one = []
    for i in range(m):
        if a[i] == '1':
            one.append(i)

    if not one:
        continue

    ni = len(one)
    subdp = [10**9] * (ni+1)
    subdp[-1] = 0

    for i in range(ni):
        for j in range(i, ni):
            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)

    next_dp = [10**9]*(k+1)
    for i in range(k, -1, -1):
        for j in range(ni+1):
            if i+j > k:
                break
            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])
    dp = next_dp

print(min(dp))
",O(n ^ 3)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    b=sorted(a)
    op=0
    for i in range(n):
        if a[i]==b[i]:continue
        op+=1
    if op==0 or op==2:print('YES')
    else:print('NO')",O(nlogn)
"from itertools import*

moves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]

def ac(l,x):
	if l==0: return 0
	return l[x] if 0<=x<len(l) else 0

def work():
	x=1
	while x:
		x=0
		for r in range(len(a)):
			for c in range(len(a[0])):
				if not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:
					a[r][c]=1
					x=1

for n in [int(input())]:

	cand=set()

	for i in range(1000):
		for x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):
			if x==0 or x%3!=1:
				if n==len(cand): break
				cand.add((x,y))

	assert len(cand)==n

	for x,y in cand: print(x,y)
",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
for t in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    l1=dd(int)
    a=0
    for j in l:
        l1[j]+=1
        if l1[j]==4:
            a=j
    if a:
        print(a,a,a,a)
    else:
        c=0
        x=0
        l2=[]
        for j in l1:
            if l1[j]>=2:
                l2.append(j)
        l2.sort()
        for j in l2:
                c+=1
                if c==1:
                    a=j
                elif c==2:
                    b=j
                else:
                    if x/j+j/x<a/b+b/a:
                        a,b=x,j
                x=j
        print(a,a,b,b)
",O(nlogn)
"from math import log
k=int(input())
r=k
l=1
t=log(10)
while 1:
	m=(l+r)//2
	x=int(log(m)/t)
	d=((1-10**(x+1))//9) + (m+1)*(x+1)
	if 0<=(k-d)<=13:
		break
	elif d>k:
		r=m-1
	else:
		l=m+1
if m==1000:
	d+=1
if d==k:
	print(str(m)[-1])
	exit()
st=""""
v=k-d
m+=1
for i in range(13):
	st+=str(m)
	m+=1
print(st[v-1])
",O(logn)
"class Solution2(object):
    def longestValidParentheses(self, s):
        longest, last, indices = 0, -1, []
        for i in range(len(s)):
            if s[i] == '(':
                indices.append(i)
            elif not indices:
                last = i
            else:
                indices.pop()
                if not indices:
                    longest = max(longest, i - last)
                else:
                    longest = max(longest, i - indices[-1])
        return longest",O(n)
"def search(arr,power):
    lo=0
    hi=len(arr)-1
    ans=-1
    while lo<=hi:
        mid=(lo+hi)//2
        if arr[mid]<=power:
            ans=mid
            lo=mid+1
        else:
            hi=mid-1
    return ans

n,q = list(map(int, input().split()))
a = list(map(int, input().split()))
k = list(map(int, input().split()))
for i in range(1,n):
    a[i]+=a[i-1]
power = 0
for i in range(q):
    power+=k[i]
    pos = search(a,power)
    if pos==n-1:
        print(n)
        power=0
    elif pos==-1:
        print(n)
    else:
        print(n-pos-1)",O(nlogn)
"class Solution:
    def lengthOfLIS(self, nums):
        n = len(nums)
        memo = [[-1] * (n + 1) for _ in range(n)]

        def dfs(i, j):
            if i == n:
                return 0
            if memo[i][j + 1] != -1:
                return memo[i][j + 1]

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            memo[i][j + 1] = LIS
            return LIS

        return dfs(0, -1)
",O(n ^ 2)
"class Solution2(object):
    def isSymmetric(self, root):
        if root is None:
            return True

        return self.isSymmetricRecu(root.left, root.right)

    def isSymmetricRecu(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None or left.val != right.val:
            return False
        return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left)",O(n)
"from sys import stdin,stdout

mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",O(n)
"class Solution(object):
    def sumBase(self, n, k):
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result",O(logn)
"from math import log2
n = int(input())
if n == 1:
    print(1)
    exit()
elif n == 3:
    print(1, 1, 3)
    exit()
l = [1] * (n // 2)
if n % 2 == 1:
    l.append(1)

xn = int(log2(n))
tmp = n - len(l)
for i in range(2, xn+1):
    fn = tmp // 2
    if tmp % 2 == 1:
        fn += 1
    tmp -= fn
    l += ([pow(2, i-1)] * fn)
l.append((n // pow(2, xn - 1)) * pow(2, xn - 1))
print(' '.join(str(i) for i in l))",O(n)
"n = int(input())
l = []
for i in range(n):
    x, y = map(int, input().split())
    l += [(x + y, x - y)]
l.sort()
r = -2000000000
a = 0
for u in l:
    if u[1] >= r:
        a += 1
        r = u[0]
print(a)
",O(nlogn)
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
t=True
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            t=False
            break
    else:
        c+=aux
        c1+=1
        continue
    break
if t:
    print(""Yes"")
",O(nlogn)
"n,m,k=map(int,input().split())

MOD=1000000009

x=m-(n//k*(k-1)+(n%k))

if (x<=0):exit(print(m%MOD))

print(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)",O(logn)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * (n + 1) for _ in range(n + 1)]
        dp[n][0] = True

        for i in range(n - 1, -1, -1):
            for open in range(n):
                res = False
                if s[i] == '*':
                    res |= dp[i + 1][open + 1]
                    if open > 0:
                        res |= dp[i + 1][open - 1]
                    res |= dp[i + 1][open]
                else:
                    if s[i] == '(':
                        res |= dp[i + 1][open + 1]
                    elif open > 0:
                        res |= dp[i + 1][open - 1]
                dp[i][open] = res

        return dp[0][0]
",O(n ^ 2)
"a = list(map(int, input().split()))
b = list(map(int, input().split()))
a1 = min(a[::2])
b1 = max(a[::2])
c1 = min(a[1::2])
d1 = max(a[1::2])
g  = sum(b[::2]) / 4
h  = sum(b[1::2]) / 4
r  = abs(b[0] - g) + abs(b[1] - h)
for i in range(a1, b1+1) :
    for j in range(c1, d1+1) :
        if abs(i-g) + abs(j-h) <= r:
            print(""YES"")
            exit()
print(""NO"")
",O(1)
"def check(s,a):
    st=''
    for i in range(len(s)):
        st+=s[i]
    st=int(st)
    if (st>a):
        return False
    else:
        return True
a = input()
b = input()
s=[]
ans=''
for i in range(len(a)):
    s.append(a[i])
s.sort()
if (len(b)>len(a)):
    for i in range(len(s)):
        print(s[len(s)-i-1],end='')
else:
    for i in range(len(a)):
        j=0
        temp2=-1
        while ((j<len(s)-1) and (s[j+1]<=b[i])):
            j+=1
            if (s[j]!=s[j-1]):
                temp2=j-1
        temp=s[j]
        s.remove(s[j])
        if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]):
            ans+=temp
            if (ans[i]<b[i]):
                for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        else:
            s.append(temp)
            s.sort()
            temp2=s[temp2]
            ans+=temp2
            s.remove(temp2)
            for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        if (len(ans)==len(a)):
            break
print(ans)
",O(n ^ 3)
"x,k=map(int,input().split())
if x==0:print(""0"")
else:
    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)
    print(ans)
",O(logn)
"class Solution(object):
    def maxDistToClosest(self, seats):
        prev, result = -1, 1
        for i in range(len(seats)):
            if seats[i]:
                if prev < 0:
                    result = i
                else:
                    result = max(result, (i-prev)//2)
                prev = i
        return max(result, len(seats)-1-prev)",O(n)
"n = int(input())
print(n//2+n)",O(1)
"class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        intersect = reduce(set.intersection, list(map(set, [arr2, arr3])))
        return [x for x in arr1 if x in intersect]",O(n)
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1

    cnt += n * (n - 1) // 2
    cnt &= 1

    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",O(n ^ 2)
"import sys

def solve(n, m, grid):
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                continue
            must = cell == 1
            if i >= n - 2 or j >= m - 2:
                if must:
                    return 'NO'
                continue
            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                if grid[i + di][j + dj] == 0:
                    if must:
                        return 'NO'
                    break
            else:
                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                    grid[i + di][j + dj] = 2
                grid[i][j] = 2
    return 'YES'

n, m = list(map(int, input().split()))
grid = [['.
print(solve(n, m, grid))
",O(n ^ 2)
"class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result",O(n)
"class Solution(object):
    def minOperations(self, boxes):
        result = [0]*len(boxes)
        for direction in (lambda x:x, reversed):
            cnt = accu = 0
            for i in direction(range(len(boxes))):
                result[i] += accu
                if boxes[i] == '1':
                    cnt += 1
                accu += cnt
        return result",O(n)
"a, b = sorted(input()), int(input())
for i in range(len(a)):
	for j in range(i+1, len(a)):
		c = int(str.join('', a))
		a[i], a[j] = a[j], a[i]
		d = int(str.join('', a))
		if c <= d <= b:
		    continue
		else:
		    a[i], a[j] = a[j], a[i]
print(str.join('', a))",O(n ^ 3)
"import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)

        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]

        def prod(l, r):
            assert 0 <= l <= r <= _n

            if l == r:
                return _e

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)

            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1

            return _op(sml, smr)

        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)

            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2

            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)

        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])

        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])

        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id

        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)

        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply

MIL = 1 << 20

def makeNode(total, count):

    return (total * MIL) + count

def getTotal(node):
    return math.floor(node / MIL)

def getCount(node):
    return node - getTotal(node) * MIL

nodeIdentity = makeNode(0.0, 0.0)

def nodeOp(node1, node2):
    return node1 + node2

    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )

identityMapping = -1

def mapping(tag, node):
    if tag == identityMapping:
        return node

    count = getCount(node)
    return makeNode(tag * count, count)

def composition(mapping1, mapping2):

    return mapping1 if mapping1 != identityMapping else mapping2

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1

dp = [[0 for i in range(520*12)] for j in range(520)]

for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:

	ss+=dp[d2[i]][d1[i]]
print(ss)",O(n ^ 3)
"class Solution2(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(len(grid)+1):
                    new_dp[0][i] = max(new_dp[0][i], max(prefix[i]-prefix[k], 0)+dp[0][k])
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+max(new_prefix[k]-new_prefix[i], 0))
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"n,k=map(int, input().split())
a = list(map(int, input().split()))

c = a[-1] - a[0]

d = [a[i]-a[i-1] for i in range(1, n)]
d = sorted(d)[::-1]
c -= sum(d[:k-1])
print(c)
",O(nlogn)
"n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2 == 1:
    for i in range(n):
        print(*[-1]*m)
    exit()
k //= 2

INF = 10**18
dp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]

for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for v in range(1, k+1):
    for i in range(n):
        for j in range(m):
            now_h, now_w = i, j
            if i > 0:
                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])
            if i < n-1:
                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])
            if j > 0:
                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])
            if j < m-1:
                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])

for i in range(n):
    v = []
    for j in range(m):
        v.append(dp[i][j][k]*2)
    print(*v)
",O(n ^ 3)
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out

    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()
",np
"class Solution(object):
    def repeatedNTimes(self, A):
        for i in range(2, len(A)):
            if A[i-1] == A[i] or A[i-2] == A[i]:
                return A[i]
        return A[0]",O(n)
"from io import BytesIO, IOBase
import sys
import math
import os
from collections import defaultdict
from math import ceil
from bisect import bisect_left, bisect_left

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())

def solve():
    n, m, k = mint()
    horizontal = [list(mint()) for i in range(n)]
    vertical = [list(mint()) for i in range(n-1)]
    if k%2 or max(n, m)==1:
        for i in range(n):
            print(*[-1]*m)
        return

    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
    for length in range(1, k//2+1):
        for i in range(n):
            for j in range(m):

                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k//2]*2, end=' ')
        print()

def main():

    t = 1
    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        left = [n]*n
        right = [-1]*n
        up = [-1]*n
        down = [n]*n
        for x, y in buildings:
            x -= 1
            y -= 1
            left[y] = min(left[y], x)
            right[y] = max(right[y], x)
            up[x] = max(up[x], y)
            down[x] = min(down[x], y) 
        return sum(left[y-1] < x-1 < right[y-1] and down[x-1] < y-1 < up[x-1] for x, y in buildings)",O(n)
"k=int(input())

s=0
i=1
while  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :
    s +=  i * (9 * pow(10, i - 1))
    i+=1
else:
    i-=1

k=k-s-1
x= k // (i+1)
y= k %(i+1)
x= pow(10,i)+x
ss=str(x)
print(ss[y])
",O(logn)
"def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret

def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):

        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m

    for i in range(-100, 100):
        t = m + i

        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)

if __name__ == '__main__':
    main()
",O(logn)
"class Solution(object):
    def minOperations(self, nums):
        def popcount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        result, max_len = 0, 1
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + (max_len-1)",O(nlogn)
"from math import ceil

k, n, s, p = map(int, input().split())
n_sheets = ceil(n / s)* k
n_p = ceil(n_sheets / p)
print(n_p)",O(1)
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",O(logn)
"n, k = map(int, input().split())
a = [int(x) for x in input().split()]
rda = []
for j in range(12):
    rd = dict()
    x = pow(10, j)
    for i in range(n):
        r = (a[i]*x)%k
        rd[r] = rd.setdefault(r, 0) + 1
    rda.append(rd)
ans = 0
for i in range(n):
    r = a[i]%k
    ln = len(str(a[i]))
    x = pow(10, ln)
    if r == 0: r = k
    if k-r in rda[ln]:
        ans += rda[ln][k-r]
        if (a[i]*x)%k == k-r:
            ans -= 1
print(ans)
",O(nlogn)
"class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result",O(n)
"n = int(input())
arr = set(map(int,input().split()))

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]

    for i in arr:
        return [i]

lst = solve()

print(len(lst))
print(*lst)
",O(nlogn)
"import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()
    def zero(self, printNumber):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr % 2 != 0:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(0)
                self.__cv.notifyAll()
        
    def even(self, printNumber):
        for i in range(2, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
        
    def odd(self, printNumber):
        for i in range(1, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()",O(n)
"n=int(input())
print(int(n**2+(n-1)**2))",O(1)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))
",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):
        def inorder_gen(root, asc=True):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    if asc:
                        stack.append((root.right, False))
                        stack.append((root, True))
                        stack.append((root.left, False))
                    else:
                        stack.append((root.left, False))
                        stack.append((root, True))
                        stack.append((root.right, False))
        
        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
        left, right = next(left_gen), next(right_gen)
        while left is not None and right is not None:
            if left + right < target:
                left = next(left_gen)
            elif left + right > target:
                right = next(right_gen)
            else:
                return True
        return False",O(n)
"class MinIdx_Segtree:
    def __init__(self, N, A):
        self.n = N
        self.INF = int(1e9)
        self.A = A
        while (self.n & (self.n - 1)) != 0:
            self.A.append(self.INF)
            self.n += 1
        self.tree = [0] * (2 * self.n)
        self.build()

    def build(self):
        for i in range(self.n):
            self.tree[self.n + i] = i
        for j in range(self.n - 1, 0, -1):
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b

    def update(self, i, val):
        self.A[i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b
            j >>= 1

    def query(self, ql, qh):
        return self._query(1, 0, self.n - 1, ql, qh)

    def _query(self, node, l, h, ql, qh):
        if ql > h or qh < l:
            return self.INF
        if l >= ql and h <= qh:
            return self.tree[node]
        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)
        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)
        if a == self.INF:
            return b
        if b == self.INF:
            return a
        return a if self.A[a] <= self.A[b] else b

class Solution:
    def getMaxArea(self, heights, l, r, st):
        if l > r:
            return 0
        if l == r:
            return heights[l]
        minIdx = st.query(l, r)
        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),
                       self.getMaxArea(heights, minIdx + 1, r, st)),
                   (r - l + 1) * heights[minIdx])

    def largestRectangleArea(self, heights):
        n = len(heights)
        st = MinIdx_Segtree(n, heights)
        return self.getMaxArea(heights, 0, n - 1, st)
",O(nlogn)
"class Solution(object):
    def buildTree(self, preorder, inorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))

    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(preorder[pre_start])
        i = lookup[preorder[pre_start]]
        node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i)
        node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)
        return node",O(n)
"class Solution(object):
    def numWays(self, s):
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD",O(n)
"class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)",O(n)
"from itertools import*
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
N, T = [int(x) for x in raw_input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in raw_input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np
"def process(S):
    n = len(S)
    h_count = 0
    answer = float('inf')
    for c in S:
        if c=='H':
            h_count+=1
    current = 0
    for i in range(h_count):
        if S[i]=='H':
            current+=1
    answer = min(answer, h_count-current)
    for i in range(h_count, n+h_count):
        if i > n-1:
            i1 = i-n
        else:
            i1 = i
        i2 = i-h_count
        if S[i1]=='H':
            current+=1
        if S[i2]=='H':
            current-=1
        answer = min(answer, h_count-current)
    return answer

n = int(input())
S = input()
print(process(S))",O(n)
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0

ans=sum(dp[k])
ans%=mod
print(ans)
",np
"n = int(input())
chess = []
for w in range(3):
    chess.append([input() for i in range(n)])
    input()
chess.append([input() for i in range(n)])

issue = {0:0, 1:0, 2:0, 3:0}
reversed_issue = {0:0, 1:0, 3:0}

for w in range(4):
    chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]]
    for s in range(2 * n):
        chessdesk[0][s] += chessdesk[1][s]
    chessdesk.pop(1)
    chessdesk = chessdesk[0]
    colour = chessdesk[0][0]

    for i in range(2 * n):
        for j in range(2 * n):
            if (i + j) % 2 == 0:
                if chessdesk[i][j] != colour:
                    issue[w] += 1
            else:
                if chessdesk[i][j] == colour:
                    issue[w] += 1

    reversed_issue[w] = 4 * n**2 - issue[w]
    if w == 0:
        chess[0], chess[3] = chess[3], chess[0]
    elif w == 1:
        chess[1], chess[3] = chess[3], chess[1]
    elif w == 2:
        chess[1], chess[2] = chess[2], chess[1]

print(min(min(issue.values()), min(reversed_issue.values())))",O(n ^ 2)
"from bisect import *
from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)

    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return prime

def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(n):
        if ind[i]==0:
            q.append(i)
            res.append(i+1)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v+1)
    return res

@bootstrap
def gdfs(r,p):
    if len(g[r])==1 and p!=-1:
        yield None
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

def match(pat,cur):
    for i in range(k):
        if pat[i]!='_' and pat[i]!=cur[i]:

            return False
    return True

def pos(cur):
    res=list(cur)

    pa=[]
    dfs(0,pa,res)
    return pa

def dfs(i,pa,res):

    global k
    if i==k:

        pa.append(''.join(res))
        return
    dfs(i+1,pa,res)

    tmp=res[i]
    res[i]='_'
    dfs(i+1,pa,res)
    res[i]=tmp

t=1
for i in range(t):
    n,m,k=RLL()
    p=[]
    d={}
    for i in range(n):
        cur=input()
        p.append(cur)
        d[cur]=i
    res=[]
    ans=True
    ind=[0]*n

    g=[[] for i in range(n)]
    for i in range(m):
        cur,x=input().split()
        x=int(x)
        if ans:

            if not match(p[x-1],cur):
                ans=False
            else:

                for al in pos(cur):
                    if al in d and d[al]!=x-1:
                        g[x-1].append(d[al])
                        ind[d[al]]+=1
    if not ans:
        print(""NO"")
    else:

        ans=topo(n)
        if len(ans)!=n:
            print(""NO"")
        else:
            print(""YES"")
            print(*ans)
",np
"dul = 0
n, k = map(int,input().split())
sum1 = 0
if k == 0:
    for i in range (n-1,-1,-1):
        sum1 = sum1 + 1
        dul = dul + sum1
        if dul == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        sum1 = sum1 + 1
        dul = dul + sum1
        if dul - i == k:
            print(i)
            break
",O(logn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",O(n ^ 3)
"t=int(input())
for l in range(t):
	n=int(input())
	arr=list(map(int,input().split()))
	arr.sort()
	a=arr[-2]
	print(min(a-1,n-2))
",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import math as M
import itertools as ITR
from collections import defaultdict as D
from collections import Counter as C
from collections import deque as Q
import threading
from functools import lru_cache, reduce
from functools import cmp_to_key as CMP
from bisect import bisect_left as BL
from bisect import bisect_right as BR
import random as R
import string
import cmath, time

enum = enumerate
start_time = time.time()

MOD = 1_00_00_00_007
MA = float(""inf"")
MI = float(""-inf"")

di8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))

di4 = ((1, 0), (0, 1), (-1, 0), (0, -1))

def increase_stack():
    sys.setrecursionlimit(2 ** 32 // 2 - 1)
    threading.stack_size(1 << 27)

def binary(n):
    return bin(n)[2:]

def decimal(s):
    return int(s, 2)

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return p

def maxfactor(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
    if q:
        return q[-1]

def factors(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
            q.append(n // i)
    return list(sorted(list(set(q))))

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    l.sort()
    return l

def isPrime(n):
    if n == 1:
        return False
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if n % i == 0:
                return False
        return True

def seive(n):
    a = []
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p] == True:
            for i in range(p ** 2, n + 1, p):
                prime[i] = False
        p = p + 1
    for p in range(2, n + 1):
        if prime[p]:
            a.append(p)
    prime[0] = prime[1] = False
    return a, prime

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countchar(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if s[i] == ch:
            c += 1
        else:
            break
    return c

def str_counter(a):
    q = [0] * 26
    for i in range(len(a)):
        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1
    return q

def lis(arr):
    n = len(arr)
    lis = [1] * n
    maximum = 0

    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
                maximum = max(maximum, lis[i])
    return maximum

def lcm(arr):
    a = arr[0]
    val = arr[0]

    for i in range(1, len(arr)):

        gcd = gcd(a, arr[i])
        a = arr[i]
        val *= arr[i]

    return val // gcd

def ncr(n, r):
    return M.factorial(n) // (M.factorial(n - r) * M.factorial(r))

def npr(n, r):
    return M.factorial(n) // M.factorial(n - r)

def IF(c, t, f):
    return t if c else f

def YES(c):
    print(IF(c, ""YES"", ""NO""))

def Yes(c):
    print(IF(c, ""Yes"", ""No""))

def yes(c):
    print(IF(c, ""yes"", ""no""))

def JA(a, sep="" ""):
    print(sep.join(map(str, a)))

def JAA(a, s=""\n"", t="" ""):
    return s.join(t.join(map(str, b)) for b in a)

def PS(a, s="" ""):
    print(str(a), end=s)

def I():
    return int(inp())

def F():
    return float(inp())

def LI():
    return list(map(int, inp().split()))

def LF():
    return list(map(float, inp().split()))

def MATI(n):
    return [LI() for i in range(n)]

def MATS(n):
    return [list(inp()) for i in range(n)]

def IV():
    return map(int, inp().split())

def FV():
    return map(float, inp().split())

def LS():
    return list(inp())

def S():
    return inp()

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
inp = lambda: sys.stdin.readline().rstrip(""\r\n"")

TestCases = 0

def solve():
    a, b = IV()

    if b - a + 1 < 3:
        print(""-1"")

    elif a % 2 == 0:
        print(a, a + 1, a + 2)

    elif b - a + 1 > 3:
        print(a + 1, a + 2, a + 3)
    else:
        print(-1)

def main():
    flag = 1

    try:
        sys.stdin = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/input.txt"",
            ""r"",
        )
        sys.stdout = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/output.txt"",
            ""w"",
        )
    except:
        flag = 0

    t = 1
    if TestCases:
        t = I()
    for _ in range(1, t + 1):
        solve()

    if flag:
        print(""Time: %.4f sec"" % (time.time() - start_time))
        localtime = time.asctime(time.localtime(time.time()))
        print(localtime)
        sys.stdout.close()

if __name__ == ""__main__"":

    main()",O(1)
"def path(x1,y1,x2,y2,hor):
    out=[]
    if hor:
        for i in range(x2-x1):
            out.append((x1+i,y1))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x2,y1+i))
        else:
            for i in range(y1-y2):
                out.append((x2,y1-i))
    else:
        for i in range(x2-x1):
            out.append((x2-i,y2))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x1,y2-i))
        else:
            for i in range(y1-y2):
                out.append((x1,y2+i))
    return out[1:]
a,b=map(int,input().split())
c,d=map(int,input().split())
e,f=map(int,input().split())
if a>c:
    a,b,c,d=c,d,a,b
if c>e:
    c,d,e,f=e,f,c,d
if a>c:
    a,b,c,d=c,d,a,b
if c==e and abs(f-b)<abs(d-b):
    c,d,e,f=e,f,c,d
g1=path(a,b,c,d,True)
if d>b:
    if f<b:
        g2=path(c,b,e,f,True)
    elif f<d:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,d,e,f,True)
else:
    if f<d:
        g2=path(c,d,e,f,True)
    elif f<b:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,b,e,f,True)
print(len(g1)+len(g2)+3)
print(a,b)
print(c,d)
print(e,f)
for x,y in g1:
    print(x,y)
for x,y in g2:
    print(x,y)",O(1)
"class Solution(object):
    def canBeIncreasing(self, nums):
        deleted = False
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                continue
            if deleted:
                return False
            deleted = True
            if i >= 2 and nums[i-2] > nums[i]: 
                nums[i] = nums[i-1]
        return True",O(n)
"import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        result = 0
        count = collections.Counter()
        freq = [0 for _ in range(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i < len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result",O(n)
"n=int(input())
if n%2==0:
    print(4,n-4)
else:
    print(9,n-9)
",O(1)
"class Solution2(object):
    def maximalRectangle(self, matrix):
        if not matrix:
            return 0

        result = 0
        m = len(matrix)
        n = len(matrix[0])
        L = [0 for _ in range(n)]
        H = [0 for _ in range(n)]
        R = [n for _ in range(n)]

        for i in range(m):
            left = 0
            for j in range(n):
                if matrix[i][j] == '1':
                    L[j] = max(L[j], left)
                    H[j] += 1
                else:
                    L[j] = 0
                    H[j] = 0
                    R[j] = n
                    left = j + 1

            right = n
            for j in reversed(range(n)):
                if matrix[i][j] == '1':
                    R[j] = min(R[j], right)
                    result = max(result, H[j] * (R[j] - L[j]))
                else:
                    right = j

        return result",O(n ^ 2)
"k,n,s,p=map(int,input().split())
a=n//s
if(n%s!=0):
    a+=1
q=k*a
m=q//p
if(q%p!=0):
    m+=1
print(m)
",O(1)
"n = int(input())
m = int(input())
r = 1
for power in range(n):
    r *= 2
    if r > m:
        print(m)
        break
else:
    if r == m:
        print(0)
    else:
        print(m % r)
",O(1)
"class Solution(object):
    def minCostClimbingStairs(self, cost):
        dp = [0] * 3
        for i in reversed(range(len(cost))):
            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])
        return min(dp[0], dp[1])",O(n)
"class Solution(object):
    def mostWordsFound(self, sentences):
        return 1+max(s.count(' ') for s in sentences)",O(n)
"class Solution(object):
    def maxIceCream(self, costs, coins):
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins < 0:
                return i
        return len(costs)",O(nlogn)
"from math import*
n,k=map(int,input().split())
s=1
dob=2
for i in range(1,n):
    s+=dob
    dob+=1
    if s-(n-i-1)==k:
        print(n-i-1)
        exit()
print(0)
",O(n)
"class Solution(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + 
        return s[getPrefix(A)[-1]+1:][::-1] + s",O(n)
"from sys import stdin,stdout

final_ans=0

R,G,B = map(int,stdin.readline().strip().split(' '))
Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)

dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
dparr[1][1][0]=Ra[0]*Ga[0]
dparr[1][0][1]=Ra[0]*Ba[0]
dparr[0][1][1]=Ga[0]*Ba[0]
final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])

def add_ns(t1):
	global queue,Ra,Ga,Ba,dparr
	x,y,z=t1
	if x+1<=R:
		if y+1<=G:
			if dparr[x+1][y+1][z]==-1:
				queue.append((x+1,y+1,z))
				dparr[x+1][y+1][z]=0

		if z+1<=B:
			if dparr[x+1][y][z+1]==-1:
				queue.append((x+1,y,z+1))
				dparr[x+1][y][z+1]=0
	if y+1<=G and z+1<=B:
		if dparr[x][y+1][z+1]==-1:
			queue.append((x,y+1,z+1))
			dparr[x][y+1][z+1]=0

def store_ans(t1):
	global final_ans,dparr,Ra,Ga,Ba
	x,y,z=t1
	if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
	if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
	if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])

	final_ans=max(final_ans,dparr[x][y][z])

queue=[(1,1,0),(1,0,1),(0,1,1)]
add_ns(queue[0])
add_ns(queue[1])
add_ns(queue[2])
ptr=3

while ptr<len(queue):

	store_ans(queue[ptr])

	add_ns(queue[ptr])

	ptr+=1

stdout.write(str(final_ans)+""\n"")",O(n ^ 3)
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase

def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)

def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res

def inar():
    return [int(k) for k in input().split()]

def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp

    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"n = int(input())
u = list(map(int, input().split()))
u.sort()
ans = 0
k = 1
ok = False
for i in range(1, n):
    if u[i] == u[i - 1]:
        k += 1
        if k == 3:
            print('cslnb')
            exit()
        if k == 2:
            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:
                print('cslnb')
                exit()
            ok = True
    else:
        k = 1
for i in range(n):
    ans += u[i] - i
if ans % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')
",O(nlogn)
"def req(a, b, c, d):

    print(f""? {a} {b} {c} {d}"")
    return int(input())

def bin(l, r, down, left, up, right, tp, tar):
    while r - l > 1:
        m = (r + l) // 2

        if tp == 0:
            down = m
        if tp == 1:
            left = m
        if tp == 2:
            up = m
        if tp == 3:
            right = m

        if req(down, left, up, right) == tar:
            l = m
        else:
            r = m
    return [l, r]

def find_rec(x1, y1, x2, y2) -> list:
    up_ = bin(x1 - 1, x2 + 1, x1, y1, -2, y2, 2, 0)[1]
    down_ = bin(x1 - 1, x2 + 1, -2, y1, x2, y2, 0, 1)[0]
    left_ = bin(y1 - 1, y2 + 1, x1, -2, x2, y2, 1, 1)[0]
    right_ = bin(left_ - 1, y2 + 1, x1, y1, x2, -2, 3, 0)[1]
    return [down_, left_, up_, right_]

n = int(input())

l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if req(1, 1, m, n) == 0:
        l = m
    else:
        r = m

rec = []

if r != n and req(r + 1, 1, n, n) == 1:
    rec.append(find_rec(1, 1, r, n))
    rec.append(find_rec(r + 1, 1, n, n))
else:
    l = 0
    r = n + 1
    while r - l > 1:
        m = (l + r) // 2
        if req(1, 1, n, m) == 0:
            l = m
        else:
            r = m
    rec.append(find_rec(1, 1, n, r))
    rec.append(find_rec(1, r + 1, n, n))
print('!', *rec[0], *rec[1])
",O(logn)
"n = int(input())

lst = []
for x in range(n):
    (a, b) = map(int, input().split())
    lst.append((a, b))

def scal(x1, y1, x2, y2, x3, y3):
    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:
        return True
    return False

def check():
    for x in range(n - 2):
        if len(s2) >= 3:
            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
                return False
        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):
            s1.append(x + 2)
        else:
            s2.append(x + 2)
    if len(s2) >= 3:
        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
            return False
    return True

flag = True

if n >= 5:
    s1 = []
    s2 = []
    if not check():
        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]
        x = s2[0]
        s1 = []
        s2 = []
        if not check():
            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]
            s1 = []
            s2 = []
            if not check():
                flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"ints=[int(x) for x in input().split()]
n=ints[0]
m=ints[1]
k=ints[2]
special=[int(x) for x in input().split()]
numOn=0
numOps=0
while numOn<m:
    numOps+=1
    op=((special[numOn]-numOn-1)//(k))*k+k+numOn+1
    while numOn<m and special[numOn]<op:
        numOn+=1
print(numOps)",O(n)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)
",O(1)
"n = int(input())
a = [int(i) for i in input().split()]
c = 0
for i in range(n):
    if a[i] > c:
        print(i+1)
        break
    else:
        c = max(a[i]+1, c)
else:
    print(-1)
",O(n)
"class Solution(object):
    def minOperations(self, nums, k):
        mn = min(nums)
        return len(set(nums))-int(mn == k) if mn >= k else -1",O(n)
"class Solution2(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & ~-n) == 0",O(1)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(1)
"class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda pair: pair[0])
        output = [intervals[0]]

        for start, end in intervals:
            lastEnd = output[-1][1]

            if start <= lastEnd:
                output[-1][1] = max(lastEnd, end)
            else:
                output.append([start, end])
        return output
",O(nlogn)
"class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        return max((l**2+w**2, l*w) for l, w in dimensions)[1]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        if root.left and root.right:
            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
        else:
            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
n,m=map(int,input().split())
l1=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
l=0
h=10**9
c=2**m-1
x,y=1,2
while l<=h:
    mid=(l+h)//2
    d=dd(int)
    d1=dd(int)
    for i in range(n):
        s=[]
        for j in range(m):
            if l1[i][j]>=mid:
                s.append('1')
            else:
                s.append('0')
        s=int(''.join(s),2)
        d[s]+=1
        d1[s]=i+1
    f=0
    for i in d:
        for j in d:
            if i|j==c:
                f=1
                x=d1[i]
                y=d1[j]
                break
        if f:
            break
    if f:
        if l==h:
            break
        l=mid+1
    else:
        if l==h:
            break
        h=mid
print(x,y)
",np
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
for t in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    l1=dd(int)
    a=0
    for j in l:
        l1[j]+=1
        if l1[j]==4:
            a=j
    if a:
        print(a,a,a,a)
    else:
        c=0
        x=0
        l2=[]
        for j in l1:
            if l1[j]>=2:
                l2.append(j)
        l2.sort()
        for j in l2:
                c+=1
                if c==1:
                    a=j
                elif c==2:
                    b=j
                else:
                    if x/j+j/x<a/b+b/a:
                        a,b=x,j
                x=j
        print(a,a,b,b)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import time
start_time = time.time()

import collections as col
import math, string
from functools import reduce

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def solve():
    L, R = getInts()
    if L == R:
        return 0
    l = len(bin(L)[2:])
    r = len(bin(R)[2:])
    while l == r:
        L -= pow(2,r-1)
        R -= pow(2,r-1)
        l = len(bin(L)[2:])
        r = len(bin(R)[2:])
    return pow(2,r)-1

print(solve())
",O(logn)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(logn)
"class Solution2(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i in reversed(range(len(heights))):
            cnt = 0
            while stk and heights[stk[-1]] < heights[i]:
                stk.pop()
                cnt += 1
            result[i] = cnt+1 if stk else cnt
            if stk and heights[stk[-1]] == heights[i]:
                stk.pop()
            stk.append(i)
        return result",O(n)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b.copy()

if 1 not in a: a[1] = -1
print(a[1])
",np
"n=int(input())
s=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    i=input()
    if(i=='purple'):
        s.remove('Power')
    elif(i=='green'):
        s.remove('Time')
    elif(i=='blue'):
        s.remove('Space')
    elif(i=='orange'):
        s.remove('Soul')
    elif(i=='red'):
        s.remove('Reality')
    elif(i=='yellow'):
        s.remove('Mind')
print(len(s))
for i in range(len(s)):
    print(s[i])
",O(1)
"import collections


class Solution(object):
    def numberOfBoomerangs(self, points):
        result = 0

        for i in range(len(points)):
            group = collections.defaultdict(int)
            for j in range(len(points)):
                if j == i:
                    continue
                dx, dy =  points[i][0] - points[j][0], points[i][1] - points[j][1]
                group[dx**2 + dy**2] += 1

            for _, v in group.items():
                if v > 1:
                    result += v * (v-1)

        return result

    def numberOfBoomerangs2(self, points):
        cnt = 0
        for a, i in enumerate(points):
            dis_list = []
            for b, k in enumerate(points[:a] + points[a + 1:]):
                dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)
            for z in list(collections.Counter(dis_list).values()):
                if z > 1:
                    cnt += z * (z - 1)
        return cnt",O(n ^ 2)
"class Solution(object):
    def longestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            T = ['^']
            for c in s:
                T +=  [
            T += [
            return T

        T = preProcess(s)
        P = [0] * len(T)
        center, right = 0, 0
        for i in range(1, len(T) - 1):
            i_mirror = 2 * center - i
            if right > i:
                P[i] = min(right - i, P[i_mirror])
            else:
                P[i] = 0

            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1

            if i + P[i] > right:
                center, right = i, i + P[i]

        max_i = 0
        for i in range(1, len(T) - 1):
            if P[i] > P[max_i]:
                max_i = i
        start = (max_i - 1 - P[max_i]) // 2
        return s[start : start + P[max_i]]",O(n)
"class Solution(object):
    def maxFreeTime(self, eventTime, k, startTime, endTime):
        startTime.append(eventTime)
        endTime.insert(0, 0)
        result = curr = 0
        for i in range(len(startTime)):
            curr += startTime[i]-endTime[i]
            result = max(result, curr)
            if i-k >= 0:
                curr -= startTime[i-k]-endTime[i-k]
        return result",O(n)
"class Solution(object):
    def maskPII(self, S):
        if '@' in S:
            first, after = S.split('@')
            return ""{}*****{}@{}"".format(first[0], first[-1], after).lower()

        digits = [x for x in S if x.isdigit()]
        local = ""***-***-{}"".format(digits[-4:])
        if len(digits) == 10:
            return local
        return ""+{}-{}"".format('*' * (len(digits) - 10), local)",O(n)
"n = int(input())
a = list(map(int, input().split()))
w = sum(a[i] == i + 1 for i in range(n))
print(""Petr"") if w >= n // 1000 else print(""Um_nik"")
",O(nlogn)
"def almost_difference():
    n = int(input())
    if n == 1:
        return 0

    dict_equal = dict()
    array = [int(el) for el in input().split()]
    ad_sum = 0
    prev_sum = 0
    for i in range(n):
        if not array[i] in dict_equal.keys():
            dict_equal[array[i]] = 0
        if not array[i]-1 in dict_equal.keys():
            dict_equal[array[i]-1] = 0
        if not array[i]+1 in dict_equal.keys():
            dict_equal[array[i]+1] = 0

        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]
        dict_equal[array[i]] += 1
        prev_sum += array[i]

    return ad_sum

print(almost_difference())
",O(nlogn)
"t=int(input())
l=list(map(int,input().split()))
b_sum=0
l.sort()
for i in l:
  b_sum += i

m_sum=0
c=0
for i in l[::-1]:
  m_sum += i
  c += 1
  if m_sum > (b_sum/2):
    break
print(c)",O(nlogn)
"n,k = map(int,input().split())
l = [int(x) for x in input().split()]
maps = []
for _ in range(256):
	maps.append(['empty',0])
output = []
for innum in l:
	if maps[innum][0] == 'chosen':
		outnum = maps[innum][1]
	elif maps[innum][0] == 'potential':
		outnum = maps[innum][1]
		i = innum
		while i >= 0 and maps[i][0] == 'potential':
			maps[i] = ['chosen',outnum]
			i -= 1
	else:
		i = innum
		while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':
			i -= 1
		i += 1
		outnum = i
		for j in range(outnum,innum+1):
			maps[j] = ['chosen',outnum]
		if innum < 255:
			for j in range(innum+1,min(256,outnum+k)):
				if maps[j][0] != 'chosen':
					maps[j] = ['potential',outnum]
	output.append(str(outnum))
print(' '.join(output))
",O(n ^ 2)
"x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):

    if b == 0:
        return 1
    if b == 1:
        return a % m

    result = int(modulus(a, b // 2, m))

    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)

def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",O(logn)
"l,r=map(int,input().split())
ls=str(bin(l))[2:]
rs=str(bin(r))[2:]
llog=len(ls)
rlog=len(rs)
ans=0
if llog<rlog:
    z=rlog-1
    while z>-1:
        ans+=2**z
        z-=1
else:
    ct=0
    stringa=""""
    for i in range(len(ls)):
        if ls[i]==rs[i] and ct==0:
            stringa+=ls[i]
        if ls[i]==""0"" and rs[i]==""1"":
            ct+=1
            stringa+=ls[i]
        if ls[i]==""1"" and rs[i]==""0"":
            stringa+=ls[i]
        if ls[i]==rs[i] and ct>0:
            stringa+=str((int(rs[i])+1)%2)
    ans=(int(stringa,2)^r)
print(ans)",O(logn)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd
from collections import deque

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

n,m = stdmap()
arr =  stdarr()

if(n > m):
    print(0)
else:
    c = Counter(arr)
    d1 = list(sorted(c.values()))

    days = 0
    for i in range(1, 101):
        br = False
        d = d1.copy()

        people = 0
        done = False

        while(1):
            if(people >= n):

                days = i
                done = True
                break
            else:
                if(len(d) == 0):
                    break
                curr = d[-1]//i

                d.pop()

                people += curr

        if(done):
            days = i

    print(days)",O(nlogn)
"n = int(input())
arr = list(map(int, input().split()))

for i in range(n):
    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)
print(arr.index(min(arr))+1)
",O(n)
"string = input()
l, r = string.split()
l = int(l)
r = int(r)
p = l ^ r
x = 1
while x <= p:
    x = x << 1
print(x-1)
",O(logn)
"import collections
import fractions


class Solution(object):
    def interchangeableRectangles(self, rectangles):
        count = collections.defaultdict(int)
        for w, h in rectangles:
            g = fractions.gcd(w, h) 
            count[(w//g, h//g)] += 1
        return sum(c*(c-1)//2 for c in count.values())",O(n)
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))
",O(n ^ 3)
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))

n,k=zzz()

arr1=zzz()
arr2=zzz()
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1

print(mx+ans)
",O(n)
"import collections


class Solution2(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            stk = [i for i in adj.keys() if i in result]
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in result:
                        continue
                    result.add(v)
                    stk.append(v)
            adj = collections.defaultdict(list)
        return list(result)",O(nlogn)
"import sys
from collections import defaultdict

exist_num,new_width = map(int,sys.stdin.readline().strip().split())
buildings = []
for _ in range(exist_num):
    center, width = map(int,sys.stdin.readline().strip().split())
    buildings.append((center-width/2,center+width/2))
buildings.sort()
possible_loc = 2
for left,right in zip(buildings,buildings[1:]):
    gap=right[0] - left[1]
    if gap == new_width:
        possible_loc += 1
    elif gap > new_width:
        possible_loc += 2

print(possible_loc)
",O(nlogn)
"def my_pow(a, n, m):
	if (n == 0) : return 1
	ans = my_pow(a, n // 2, m)
	if (n % 2 == 0):
		return ans * ans % m
	else:
		return (ans * ans * a) % m

x, k = map(int, input().split())
if (x == 0):
	print(0)
else:
	mod = 10**9 + 7
	x *= 2
	ans = (x - 1) * my_pow(2, k, mod) + 1
	ans %= mod
	ans += 2 * mod
	print(ans % mod)",O(logn)
"x,k = map(int, input().split())
mod = 1000000007
flag = True
if x==0:
    flag=False
if flag:
    print((pow(2,k+1,mod)*x-pow(2,k,mod)+1+mod)%mod)
else:
    print(0)
",O(logn)
"n = int(input())
a = list(map(int, input()))
b = list(map(int, input()))

ans = sum(q != w for q, w in zip(a, b))
i = 1
while i < n:
    aii = a[i - 1]
    ai = a[i]
    bii = b[i - 1]
    bi = b[i]
    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:
        ans -= 1
        i += 1
    i += 1

print(ans)
",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def preorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    result.append(curr.val)
                    node.right = curr
                    curr = curr.left
                else:
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"n,s = map(int,input().split())
t=[[0,0]]
for j in range(n):

    a,b = map(int,input().split())

    total = a*60+b

    last = t[-1][0]*60+t[-1][1]+1

    t.append([a,b])

    if j==0:
        if total>= s+1:
            print(0,0)
            break
    if total-last > 2*s:
        u = last+s
        print(u//60, u%60)
        break

    if j==n-1:
        x = t[-1][0]*60+t[-1][1]
        print((x+s+1)//60 ,(x+s+1)%60 )
        break
",O(n)
"def flipH(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[i][N-j-1]
    return B

def flipV(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[N-i-1][j]
    return B

def rotate90(A):
    ans = zip(*A[::-1])
    ans=list(map(list,ans))
    return ans

def check(A,B,N):
    for i in range(N):
        for j in range(N):
            if A[i][j]!=B[i][j]:
                return False
    return True

N=int(input())
A=[]
X=[]
for i in range(N):
    A.append(list(input()))
for i in range(N):
    X.append(list(input()))
B=flipH(A,N)
C=flipV(A,N)
flag=False
for i in range(4):
    if check(A,X,N) or check(B,X,N) or check(C,X,N):
        flag=True
        break
    else:
        A=rotate90(A)
        B=rotate90(B)
        C=rotate90(C)
if flag:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def fun(a,b):
    return (2*(a+b))**2/(a*b)

for i in range (int(input())):
    n = int(input())
    a = [int(i) for i in input().split()]
    a.sort()
    b = []
    i=0
    while(i<n-1):
        if i<n-1 and a[i]==a[i+1]:
            b.append(a[i])
            i+=2
        else:
            i+=1
    m = 10**14
    mi = -1
    for i in range (len(b)-1):
        curr = fun(b[i],b[i+1])
        if curr<m:
            m = curr
            mi = i
    print(b[mi],b[mi],b[mi+1],b[mi+1])",O(nlogn)
"lis = list(map(int,input().split()))
if lis[2] <= lis[0] and lis[2] <= lis[1]:
	if ((lis[0]+lis[1]) - lis[2]) < lis[3]:
		print(lis[3] - ((lis[0]+lis[1]) - lis[2]))
	elif sum(lis) == 0:
		print(-1)
	elif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :
		print(lis[3])
	else:
		print(-1)
else:
	print(-1)
",O(1)
"class Solution(object):
    def longestConsecutive(self, root):
        def longestConsecutiveHelper(root):
            if not root:
                return 0, 0
            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)
            cur_inc_len, cur_dec_len = 1, 1
            if root.left:
                if root.left.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, left_len[0] + 1)
                elif root.left.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, left_len[1] + 1)
            if root.right:
                if root.right.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, right_len[0] + 1)
                elif root.right.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, right_len[1] + 1)
            self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)
            return cur_inc_len, cur_dec_len

        self.max_len = 0
        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"n,k=map(int,input().split())
print(max(min(n,k-1)-k//2,0))",O(1)
"n,d,k=map(int,input().split())
if n==1:
  print(""NO"")
  exit()
if k==1:
  if n==2 and d==1:
    print(""YES"")
    print(1,2)
  else:
    print(""NO"")
  exit()
if n<d+1:
  print(""NO"")
  exit()
co=1
ans=[]
for i in range(1,d+1):
  ans.append((i,i+1))
  co+=1
def dfs(r,dist,co):
  if 2<=r<=d:
    t=k-2
  else:
    t=k-1
  if co==n:
    return co
  for _ in range(t):
    if dist==d:
      return co
    if co==n:
      return co
    co+=1
    ans.append((r,co))
    co=dfs(co,dist+1,co)
  return co
for i in range(2,d+1):
  co=dfs(i,max(i-1,d-i+1),co)
if co==n:
  print(""YES"")
  for j in ans:
    print(*j)
else:
  print(""NO"")",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def main():
    n, k = RL()
    cds = RLL()
    fn = RLL()
    sc = [0]+RLL()

    rec = set(fn)
    uses = 0
    dic = defaultdict(int)
    for i in cds:
        if i in rec:
            dic[i]+=1
            uses+=1

    dp = [[0]*(n*k+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, n*k+1):
            for l in range(k+1):
                if l>j: break
                val = sc[l]
                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)
    res = 0

    for i, v in Counter(fn).items():
        res+=dp[v][dic[i]]

    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def largestGoodInteger(self, num):
        result = ''
        cnt = 0
        for i, x in enumerate(num):
            cnt += 1
            if i+1 < len(num) and num[i] == num[i+1]:
                continue
            if cnt >= 3:
                result = max(result, num[i])
            cnt = 0
        return result*3",O(n)
"n = int(input())
x = 1
n -= 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = (8 + 2) ** (x - 1)
a += n // x
print(str(a)[n % x])",O(logn)
"class Solution(object):
    def findSolution(self, customfunction, z):
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) < z:
            y += 1
        while y > 0:
            while y > 0 and customfunction.f(x, y) > z:
                y -= 1
            if y > 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result",O(n)
"import sys

class ADIYWoodenLadder:
    def solve(self):
        t = int(input())
        for _ in range(t):
            n = int(input())
            a = [int(_) for _ in input().split()]
            a.sort()
            print(min(a[-2] - 1, n - 2))

solver = ADIYWoodenLadder()
input = sys.stdin.readline

solver.solve()
",O(nlogn)
"class Solution(object):
    def findLengthOfLCIS(self, nums):
        result, count = 0, 0
        for i in range(len(nums)):
            if i == 0 or nums[i-1] < nums[i]:
                count += 1
                result = max(result, count)
            else:
                count = 1
        return result",O(n)
"n = int(input())
a = list(map(int, input().split()))

a.sort()
ans = 0
while a:
	m = a[0]
	b = []
	for x in a[1:]:
		if x % m != 0:
			b.append(x)
	a = b
	ans += 1
print(ans)",O(n ^ 2)
"class Solution(object):
    def toHex(self, num):
        if not num:
            return ""0""

        result = []
        while num and len(result) != 8:
            h = num & 15
            if h < 10:
                result.append(str(chr(ord('0') + h)))
            else:
                result.append(str(chr(ord('a') + h-10)))
            num >>= 4
        result.reverse()

        return """".join(result)",O(logn)
"import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"a='4'*(300)+'5'
b='5'*(301)
print(a);print(b)
",O(1)
"r,g,b = map(int,input().split())
rs = list(map(int,input().split()))
gs = list(map(int,input().split()))
bs = list(map(int,input().split()))
rs.sort()
gs.sort()
bs.sort()
rs.reverse()
gs.reverse()
bs.reverse()
dp = [[[0]*201 for x in range(201)] for y in range(201)]
for i in range(min(r,g)+1):
    for j in range(min(g,b)+1):
        for k in range(min(b,r)+1):
            options = []

            if i == 0:
                pass
            elif i+k-1 < r and i+j-1 < g:
                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])
            else:
                options.append(dp[i-1][j][k])
            if j == 0:
                pass
            elif i+j-1 < g and j+k-1 < b:
                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])
            else:
                options.append(dp[i][j-1][k])
            if k == 0:
                pass
            elif j+k-1 < b and i+k-1 < r:
                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])
            else:
                options.append(dp[i][j][k-1])
            if len(options) == 0:
                continue
            dp[i][j][k] = max(options)
print(dp[min(r,g)][min(g,b)][min(r,b)])
",O(n ^ 3)
"class Solution(object):
    def nextGreaterElements(self, nums):
        result, stk = [0] * len(nums), []
        for i in reversed(range(2*len(nums))):
            while stk and stk[-1] <= nums[i % len(nums)]:
                stk.pop()
            result[i % len(nums)] = stk[-1] if stk else -1
            stk.append(nums[i % len(nums)])
        return result",O(n)
"class Solution3(object):
    def findErrorNums(self, nums):
        N = len(nums)
        x_minus_y = sum(nums) - N*(N+1)//2
        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y
        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2",O(n)
"def wins(mem, l, pos):

	if mem[pos] != 0:
		return mem[pos] == 1

	val = l[pos]

	lo = pos - val
	while lo >= 0:
		if l[lo] > val and not wins(mem, l, lo):
			mem[pos] = 1
			return True
		lo -= val

	hi = pos + val
	while hi < len(l):
		if l[hi] > val and not wins(mem, l, hi):
			mem[pos] = 1
			return True
		hi += val

	mem[pos] = 2
	return False

n = int(input())
l = list(map(int, raw_input().split()))

mem = [0 for i in range(n)]
ans = """"
for i in range(n):
	ans += ""A"" if wins(mem, l, i) else ""B""

print(ans)
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])

ans=[[inf]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if k%2:
            ans[i][j]=-1
            continue
        ans[i][j]=2*dp[i][j][k//2]
for i in ans:
    print(*i)
",O(n ^ 3)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

def datainput():
    return map(int, input().split())
def listinput():
    return list(map(int, input().split()))

n=int(input())
ans={}
while n:
    n-=1
    a,x =datainput()
    ans[a]=x
m=int(input())
while m:
    m-=1
    b,y =datainput()
    if b in ans:
        if ans[b] < y:
            ans[b]=y
    else:
        ans[b]=y
print(sum(list(ans.values())))
",O(nlogn)
"class Solution(object):

    def __init__(self, value, k):
        self.__value = value
        self.__k = k
        self.__cnt = 0

    def consec(self, num):
        if num == self.__value:
            self.__cnt += 1
        else:
            self.__cnt = 0
        return self.__cnt >= self.__k",O(1)
"class Solution(object):
    def removeCoveredIntervals(self, intervals):
        intervals.sort(key=lambda x: [x[0], -x[1]])
        result, max_right = 0, 0
        for left, right in intervals:
            result += int(right > max_right)
            max_right = max(max_right, right)
        return result",O(nlogn)
"n = int(input())
L = [int(i) for i in input().split()]
R = [int(i) for i in input().split()]
E = []
otv = [0] * n
for i in range(n):
    sum_ = L[i] + R[i]
    E.append([sum_, i])
E.sort()
for i in range(n):
    x = R[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] > i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break

    if (x > 0):
        print(""NO"")
        exit()

    x = L[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] < i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break

    if (x > 0):
        print(""NO"")
        exit()

for i in range(n):
    r = 0
    l = 0
    for j in range(i + 1, n):
        if (otv[j] > otv[i]):
            r += 1
    for z in range(i - 1, -1, -1):
        if (otv[z] > otv[i]):
            l += 1
    if (r != R[i]) or (l != L[i]):
        print(""NO"")
        exit()

print(""YES"")
for i in range(n):
    print(otv[i] + 1, end = ' ')
",O(n ^ 2)
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))
",np
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = {len(s): 1}
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp[i] += dp[i + 2]
        return dp[0]
",O(n)
"s = input()
ans = 2
s1 = s[0:2]
s2 = s[3:5]
s3 = s[6:8]
def func(inp):
    ans = 2
    num = int(inp[0])
    c = inp[1]
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))
    ans = min( ans, 3 - s.count(inp))
    return ans
ans = min(ans,func(s1))
ans = min(ans,func(s2))
ans = min(ans,func(s3))
print(ans)
",O(n)
"for TT in range(1, int(input()) + 1):
    n = int(input())
    l = sorted(map(int, input().split()))
    k = max(0, min(n - 2, l[-2] - 1))
    print(k)",O(nlogn)
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))",O(n ^ 2)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

DP=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
    DP[i][i]=A[i]

for mid in range(1,n):
    for i in range(n):
        j=i+mid
        if j==n:
            break
        for k in range(i,j+1):
            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:
                DP[i][j]=DP[i][k]+1

ANS=[2000]*(n+1)
ANS.append(0)
for i in range(n):
    ANS[i]=min(ANS[i],ANS[i-1]+1)
    for j in range(i,n):
        if DP[i][j]!=-1:
            ANS[j]=min(ANS[j],ANS[i-1]+1)

print(ANS[n-1])
",O(n ^ 3)
"from sys import stdin
n=int(stdin.readline().strip())
s=list(map(int,stdin.readline().strip().split()))
s.sort()
f=False
z=s.count(0)
p=0
for i in range(2,n):
    if s[i]==s[i-1] and s[i-1]==s[i-2]:
        f=True
for i in range(1,n):
    if s[i]==s[i-1]:
        p+=1
        if i-2>=0 and s[i-2]==s[i-1]-1:
            f=True
y=sum(s)
t=(n)*(n-1)//2
r=y-t
if r%2==0 or f or y==0 or z>=2 or p>=2:
    print(""cslnb"")
else:
    print(""sjfnb"")
",O(nlogn)
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()

		if s1[-1] - s1[0] >= d:

			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):

			if suma_o_resta(x, i) > 0:

				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))
",np
"n,m,a,b = map(int,input().split())
if n%m!=0:
    mn = n//m * m
    mx = n//m * m + m
    print(min(((n - mn) * b),((mx - n) * a)))
else:print(0)",O(n)
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))",O(n ^ 3)
"class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0",O(n)
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",O(n)
"class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(range(cols)):
            for j in reversed(range(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return """".join(result)",O(n)
"class Solution(object):
    def longestCycle(self, edges):
        result = -1
        lookup = [-1]*len(edges)
        idx = 0
        for i in range(len(edges)):
            if lookup[i] != -1:
                continue
            start = idx
            while i != -1:
                if lookup[i] != -1:
                    break
                lookup[i] = idx
                idx += 1
                i = edges[i]
            if i != -1 and lookup[i] >= start:
                result = max(result, idx-lookup[i])
        return result",O(n)
"import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result",O(n)
"class Solution(object):
    def convertBST(self, root):
        def convertBSTHelper(root, cur_sum):
            if not root:
                return cur_sum

            if root.right:
                cur_sum = convertBSTHelper(root.right, cur_sum)
            cur_sum += root.val
            root.val = cur_sum
            if root.left:
                cur_sum = convertBSTHelper(root.left, cur_sum)
            return cur_sum

        convertBSTHelper(root, 0)
        return root",O(n)
"class Solution(object):
    def minOperations(self, n):
        return (n//2)*((n+1)//2)",O(1)
"n,s=int(input()),input()
p,q,r=len(set(s)),{},10**6
for i in range(n):
    q[s[i]]=i
    if len(q)==p:r=min(r,max(q.values())-min(q.values()))
print(r+1)",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])

endtime = time.time()
",O(nlogn)
"class Solution(object):
    def numberOfWays(self, corridor):
        MOD = 10**9+7
        result, cnt, j = 1, 0, -1
        for i, x in enumerate(corridor):
            if x != 'S':
                continue
            cnt += 1
            if cnt >= 3 and cnt%2:
                result = result*(i-j)%MOD
            j = i
        return result if cnt and cnt%2 == 0 else 0",O(n)
"from math import *
import sys

input = sys.stdin.readline

def bin_search(arr, n):

	pos = -1

	for i in range(35, -1, -1):
		jump = (1 << i)

		if (pos + jump) >= len(arr):
			continue

		if arr[pos + jump] <= n-1:
			pos += jump

	return len(arr) - pos - 1

def main():
	n, m = [int(x) for x in input().split(' ')]

	vert = []
	for i in range(n):
		vert.append(int(input()))

	hor = []
	for i in range(m):
		col1, col2, row = [int(x) for x in input().split(' ')]

		if col1 != 1:
			continue

		hor.append((col2))

	vert.append(1000000000)

	vert = sorted(vert)
	hor = sorted(hor)

	best = int(1e10)

	for i in range(len(vert)):
		cur_ans = bin_search(hor, vert[i]) + i
		best = min(best, cur_ans)

	print(best)

if __name__ == ""__main__"":
	main()",O(nlogn)
"class Solution(object):

    def __init__(self, A):
        self.__A = A
        self.__i = 0
        self.__cnt = 0

    def next(self, n):
        while self.__i < len(self.__A):
            if  n > self.__A[self.__i] - self.__cnt:
                n -= self.__A[self.__i] - self.__cnt
                self.__cnt = 0
                self.__i += 2
            else:
                self.__cnt += n
                return self.__A[self.__i+1]
        return -1",O(n)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])

print(ans)
",O(n)
"s = input()
trgt = 0
for c in s:
    trgt += (1 if c == '+' else -1)

cmd = input()

queue = [[0, 0]]
dests = []

while queue:
    nextqueue = []
    for pos, cmdi in queue:
        if cmdi == len(cmd):
            dests.append(pos)
            continue
        nextcmd = cmd[cmdi]
        if nextcmd == '+':
            nextqueue.append([pos+1, cmdi+1])
        elif nextcmd == '-':
            nextqueue.append([pos-1, cmdi+1])
        else:
            nextqueue.append([pos + 1, cmdi + 1])
            nextqueue.append([pos - 1, cmdi + 1])
    queue = nextqueue

occurs = 0
for x in dests:
    if x == trgt:
        occurs+=1
print(occurs / len(dests))",np
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

new_arr = []
for i in range(n - 1):
	new_arr.append(arr[i + 1] - arr[i])

new_arr.sort()
print(sum(new_arr[:n - k]))
",O(nlogn)
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )

def testcase():
    n, M = get_intmap()
    a = [0] + list(get_intmap()) + [M]
    ontime = [0] * (n + 1)
    tmp = 0
    for ind in range(n, -1, -1):
        if ind %2 == 0:
            tmp += a[ind + 1] - a[ind]
        ontime[ind] = tmp
    mx = ontime[0]

    for ind in range(n + 1):
        l,r = a[ind], a[ind+1]
        if r - l <= 1: continue
        for x in (l+1, r-1):
            newtime = ontime[0] - ontime[ind]
            if ind % 2 == 0:
                newtime += x - l
            else:
                newtime += r - x
            newtime += (M - r) - ontime[ind]
            mx = max(mx, newtime)
    print(mx)

testcase();quit()
for t in range(int(input())):
    testcase()
",O(n)
"import sys
def ints():
    return list(map(int, sys.stdin.readline().strip().split()))
tc = 1
while tc:
    tc-=1
    n, k = map(int, input().split())
    l = -1
    r = n+1
    while r-l > 1:
        m = (r+l)//2
        if (n-m)*(n-m+1)//2 - m > k:
            l = m
        else:
            r = m
    print(r)",O(logn)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        stack = []

        leftMost = [-1] * n
        for i in range(n):
            while stack and heights[stack[-1]] >= heights[i]:
                stack.pop()
            if stack:
                leftMost[i] = stack[-1]
            stack.append(i)

        stack = []
        rightMost = [n] * n
        for i in range(n - 1, -1, -1):
            while stack and heights[stack[-1]] >= heights[i]:
                stack.pop()
            if stack:
                rightMost[i] = stack[-1]
            stack.append(i)

        maxArea = 0
        for i in range(n):
            leftMost[i] += 1
            rightMost[i] -= 1
            maxArea = max(maxArea, heights[i] * (rightMost[i] - leftMost[i] + 1))
        return maxArea
",O(n)
"n = int(input())
fst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]
cnt = 0

def add(u, v) :
	global cnt
	cnt += 1
	if fst[u] == 0 :
		fst[u] = cnt
	else :
		nxt[lst[u]] = cnt
	lst[u], des[cnt] = cnt, v

for i in range(1, n) :
	u, v = map(int, input().split())

	add(u, v)
	add(v, u)

a = list(map(int, input().split()))
deep = [0 for i in range(n + 1)]
deep[1] = 1
now, res = 1, 1
Ans = 0

for i in range(0, n) :
	if deep[a[i]] == 0 :
		Ans = 1
		break
	elif deep[a[i]] < now :
		Ans = 1
		break
	else :
		b = fst[a[i]]
		res += 1
		while b > 0 :
			if deep[des[b]] == 0 :
				deep[des[b]] = res
			b = nxt[b]
		now = deep[a[i]]

if Ans == 0 :
	print(""Yes"")
else :
	print(""No"")
",O(nlogn)
