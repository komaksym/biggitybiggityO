code,complexity
"import copy

def rotate90(n, f):
    return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]

def fliphor(n, f):
    return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]

def flipver(n, f):
    return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]

def eq(n, f, g):
    for i in range(n):
        for j in range(n):
            if f[i][j] != g[i][j]:
                return False
    return True

n = int(input())
f = [list(input()) for i in range(n)]
g = [list(input()) for i in range(n)]

for doflipv in range(2):
    for dofliph in range(2):
        for nrot in range(4):
            h = copy.deepcopy(f)
            if dofliph == 1:
                h = fliphor(n, h)
            if doflipv == 1:
                h = flipver(n, h)
            for i in range(nrot):
                h = rotate90(n, h)
            if eq(n, h, g):
                print(""Yes"")
                exit(0)

print(""No"")",O(n ^ 2)
"def ii():
    return int(input())
def mi():
    return map(int,input().split())
def li():
    return list(map(int,input().split()))

mod = 10**9 + 7

x,k = mi()
if(x == 0):
    print(0)
elif(k == 0):
    print((2*x)%mod)
else:
    to = pow(2,k,mod)
    pre = (to * x)%mod
    prev = pow(2,k-1,mod)
    first = (pre - prev + 1)%mod
    sec = (pre - prev)%mod
    ans = (first + sec)%mod
    print((ans+mod)%mod)",O(logn)
"import heapq

def doxor(a, b):
    cnt = 0
    for i in range(len(a)):
        for j in range(len(a[0])):
            cnt += a[i][j] ^ b[i][j]
    return cnt

n = int(input())

a, b = [], []
for i in range(n):
    ai, bi = [], []
    for j in range(n):
        if i % 2 == 0:
            ai.append(j % 2)
            bi.append((j % 2) ^ 1)
        else:
            ai.append((j % 2) ^ 1)
            bi.append(j % 2)
    a.append(ai)
    b.append(bi)

board = []
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])

a_cnts = []
b_cnts = []
for b0 in board:
    heapq.heappush(a_cnts, doxor(b0, a))
    heapq.heappush(b_cnts, doxor(b0, b))

print(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) +
      heapq.heappop(b_cnts) + heapq.heappop(b_cnts))
",O(n ^ 2)
"from math import pi, sin
from decimal import Decimal

n, r = map(int, input().split())
alpha = Decimal(pi)/Decimal(n)
a = Decimal(sin(alpha))
R = Decimal((r * a) / (1 - a))
print(R)",O(1)
"class Solution:
    def reverseBits(self, n: int) -> int:
        binary = """"
        for i in range(32):
            if n & (1 << i):
                binary += ""1""
            else:
                binary += ""0""

        res = 0
        for i, bit in enumerate(binary[::-1]):
            if bit == ""1"":
                res |= (1 << i)

        return res
",O(1)
"n = int(input())
li1 = []
s=""""
li2 = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}
for i in range(n):
    s = input()
    li1.append(s)
print(6-n)
for key in li2:
    if key in li1:
        continue
    else:
        li1.append(key)
        print(li2[key])",O(1)
"class Solution(object):
    def minOperations(self, nums):
        return sum(nums[i] != nums[i+1] for i in range(len(nums)-1))",O(n)
"import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):

    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import bisect

def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return bisect.bisect_left(p, p[-1] / 2)

print(solve())",O(n)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))
a.sort()

if n == 1:
    if a[0] % 2 == 1:
        v = True
    else:
        v = False
else:
    v = True
    c = 0
    for i in range (0, n-1):
        if a[i] == a[i + 1]:
            c = c + 1
            j = i
    if c > 1:
        v = False
    elif c == 1:
        if a[j] == 0:
            v = False
        if j > 0:
            if a[j-1] + 1 == a[j]:
                v = False
    if (sum(a) - (n * (n - 1)) // 2) % 2 == 0:
        v = False

if v == True:
    print(""sjfnb"")
else:
    print(""cslnb"")
",O(nlogn)
"def go():
    n = int(input())
    x, y = [int(i) for i in input().split(' ')]
    a = 1 + 1
    b = n + n
    c = x + y
    distance_w = c - a
    distance_b = b - c
    if distance_w == distance_b:
        return 'White'
    if distance_w < distance_b:
        return 'White'
    return 'Black'

print(go())
",O(1)
"import collections



class Solution2(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                left = right
                while dq and not check(nums[dq[-1][0]], nums[right]):
                    i, left = dq.pop()
                    total -= (i-left+1)*nums[i]
                dq.append([right, left])
                total += (right-left+1)*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0][0]]
                    if dq[0][0] == right-(k-1):
                        dq.popleft()
                    else:
                        assert(dq[0][1] == right-(k-1))
                        dq[0][1] += 1
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)",O(n)
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):

        if grid[i - 1][j] == '
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",O(n ^ 2)
"n = int(input())
A = [int(a) for a in input().split()]
B = A.copy()
B.sort()
c = 0
for i in range(n):
    c = c + 1 if A[i] != B[i] else c
print(""YES"" if c <= 2 else ""NO"")",O(nlogn)
"import sys
input_file = sys.stdin

[n,m] = list(int(x) for x in input_file.readline().split())
stacks = list(int(x) for x in input_file.readline().split())
stacks.sort()

ans = 0
cur_stack = 0
cur_h = 0

while cur_stack < n:
    ans += 1
    if stacks[cur_stack] >= cur_h + 1:
        cur_h += 1
    cur_stack += 1
ans += stacks[-1] - cur_h

print(sum(stacks) - ans)
",O(nlogn)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []
    for v in l:
        if v in powers:            continue
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()
    other = [];    out = [extra]
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1;lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2: out += lis[:-1];  need -= (len(lis) - 1);   assert need == 2
    else: out += lis[:need]; need = 0
assert need + len(out) == k;assert need >= 0;assert need == 0 or len(out) == count
for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
if need == 0:    print(' '.join(map(str,out)));    exit()
else:    print(0)",np
"s, l= list(map(int,input().split()))
sig = []
utp = []
if s == 0 or l ==0:
    print('NO')
    quit()
for i in range(s):
    sig.append(list(map(int,input())))
for i in range(0,l):
    out = 0
    for x in range(0,s):
        out+=sig[x][i]
    utp.append(out)
sig = sorted(sig,key = sum)
for i in range(0,s):
    res1=0
    for x in range(0,l):
        if utp[x]-sig[i][x] <=0:
            break
        else:
            res1+=1
    if res1 == l:
        print('YES')
        quit()

print('NO')
",O(n ^ 2)
"n,k = map(int,input().split())
M = 1000000007
if(n == 0):
    print(0)
else:
    ans = 2*n - 1
    x  =  pow(2,k,M)
    print((((ans * x) % M) + 1) % M)",O(logn)
"class Solution:

    def rob(self, nums: List[int]) -> int:
        return max(nums[0], self.helper(nums[1:]),
                            self.helper(nums[:-1]))

    def helper(self, nums):
        rob1, rob2 = 0, 0

        for num in nums:
            newRob = max(rob1 + num, rob2)
            rob1 = rob2
            rob2 = newRob
        return rob2
",O(n)
"n = int(input())
a = list(map(int, input().split()))
s = sorted(a)
q = a.index(max(a))
q1, q = min(len(a)-1, q+1), max(0, q-1)
for q2 in range(len(a)-2, -1, -1):
    if a[q] == s[q2]:
        q = max(0, q-1)
    elif a[q1] == s[q2]:
        q1 = min(len(a)-1, q1+1)
    else:
        print(""NO"")
        break
else:
    print(""YES"")
",O(nlogn)
"from math import factorial as fc
def per(a,b):
    return fc(a+b)/(fc(a)*fc(b))
import sys
s=input()
s1=input()
x=s.count(""+"")
y=s.count(""-"")
x1=s1.count(""+"")
y1=s1.count(""-"")
p=x-y
p1=x1-y1
q=s1.count(""?"")
dif=p-p1
if q<abs(p1-p) or dif>q:
    print(0.0)
    sys.exit()
m=abs(y-y1)
pl=abs(x-x1)
print(per(m,pl)/(2**(m+pl)))
",np
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return r+1

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()
",O(logn)
"class Solution(object):
    def maximumLength(self, nums):
        k = 2
        result = 0
        for i in range(k):
            dp = [0]*k
            for x in nums:
                dp[x%k] = dp[(i-x)%k]+1
            result = max(result, max(dp))
        return result",O(n)
"class Solution2(object):
    def mostProfitablePath(self, edges, bob, amount):
        def dfs(u, ah):
            lookup[u] = True
            result = 0 if len(adj[u])+(u == 0) == 1 else float(""-inf"")
            bh = 0 if u == bob else float(""inf"")
            for v in adj[u]:
                if lookup[v]:
                    continue
                r, h = dfs(v, ah+1)
                result = max(result, r)
                bh = min(bh, h)
            if ah == bh:
                result += amount[u]//2
            elif ah < bh:
                result += amount[u]
            return result, bh+1

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(0, 0)[0]",O(n)
"import sys

MOD = 10**9 + 7

x,k = list(map(int,sys.stdin.readline().strip().split(' ')))

a = x*pow(2,k+1,MOD) % MOD
b = (a - pow(2,k,MOD) + 1) % MOD
print(b if x != 0 else 0)",O(logn)
"
import itertools


class Solution(object):
    def printVertically(self, s):
        return ["""".join(c).rstrip() for c in itertools.zip_longest(*s.split(), fillvalue=' ')]
",O(n)
"import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        R, C = 10**6, 10**6
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(blocks, source, target):
            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2
            lookup = set([source])
            if len(lookup) > max_area_surrounded_by_blocks:
                return True
            q = collections.deque([source])
            while q:
                source = q.popleft()
                if source == target:
                    return True
                for direction in directions:
                    nr, nc = source[0]+direction[0], source[1]+direction[1]
                    if not ((0 <= nr < R) and
                            (0 <= nc < C) and 
                            (nr, nc) not in lookup and
                            (nr, nc) not in blocks):
                        continue
                    lookup.add((nr, nc))
                    if len(lookup) > max_area_surrounded_by_blocks:
                        return True
                    q.append((nr, nc))
            return False
        
        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \
               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))",O(n ^ 2)
"class Solution(object):
    def minKnightMoves(self, x, y):
        x, y = abs(x), abs(y)
        if x < y:
            x, y = y, x
        lookup = {(1, 0):3, (2, 2):4} 
        if (x, y) in lookup:
            return lookup[(x, y)]
        k = x-y
        if y > k:
            return k - 2*((k-y)//3)
        return k - 2*((k-y)//4)",O(1)
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
t=True
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            t=False
            break
    else:
        c+=aux
        c1+=1
        continue
    break
if t:
    print(""Yes"")
",O(nlogn)
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",O(logn)
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    ax, ay = map(int, next(cin).split())
    bx, by = map(int, next(cin).split())
    cx, cy = map(int, next(cin).split())

    if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
        print('YES')
    else:
        print('NO')
",O(1)
"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        res = 0

        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])

            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)

        return res
",O(n)
"n, m = map(int, input().split())
s = input()
t = input()
if ""*"" in s:
    front, back = s.split(""*"")
    if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back):
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""YES"" if s == t else ""NO"")
",O(n)
"import sys,os,io,time,copy,math
from functools import lru_cache
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

def main():
    n,k=map(int,input().split())
    arr=[]
    for i in range(n):
        x,y=map(int,input().split())
        arr.append((x,y))
        arr.sort(key=lambda x:(x[0],-x[1]),reverse=True)
    req=arr[k-1]
    count=0
    for a in arr:
        if a==req:
            count+=1
    print(count)

main()
",O(nlogn)
"n, m = map(int, input().split())
print(m // n + (1 if m % n else 0))
",O(1)
"import collections



class Solution(object):
    def minSteps(self, s, t):
        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)
        return sum((cnt1-cnt2).values())+sum((cnt2-cnt1).values())",O(n)
"class Solution(object):
    def minTaps(self, n, ranges):
        def jump_game(A):
            jump_count, reachable, curr_reachable = 0, 0, 0
            for i, length in enumerate(A):
                if i > reachable:
                    return -1
                if i > curr_reachable:
                    curr_reachable = reachable
                    jump_count += 1
                reachable = max(reachable, i+length)
            return jump_count
    
        max_range = [0]*(n+1)
        for i, r in enumerate(ranges):
            left, right = max(i-r, 0), min(i+r, n)
            max_range[left] = max(max_range[left], right-left)
        return jump_game(max_range)",O(n)
"for _ in range(1):
    i=0
    ans=[]
    while(i<32):
        ans.append(2**i)
        i+=1

    n=int(input())
    l=list(map(int,input().split()))
    d={}
    for i in l:
        if i not in d:
            d[i]=1
        else:
            d[i]+=1

    c=0
    for i in d.keys():

        for j in ans:

            if j-i in d and (j-i!=i or d[j-i]>1):

                break
        else:
            c+=d[i]
    print(c)
",O(nlogn)
"n,m=map(int,input().strip().split())
v=[0]*51
left=1
right=n
for i in range(1,n+1):
	if(n-i-1<=0):
		pw=1
	else:
		pw=(1<<(n-i-1))

	if(m<=pw):
		v[left]=i
		left+=1
	else:
		v[right]=i
		right-=1
		m-=pw
for i in range(1,n):
	print(v[i], end=' ')
print(v[n])
",np
"from collections import Counter
class Solution3(object):
    def findDuplicates(self, nums):
        return [elem for elem, count in list(Counter(nums).items()) if count == 2]",O(n)
"n = int(input())+1
print(0 if not (n-1) else n//2 if not n&1 else n)",O(1)
"def binary(n,k):
    lower=1
    upper=n
    while(lower<upper):
        mid=(lower+upper)//2
        total=(mid*(mid+1))//2
        if n-mid==total-k:
            print(n-mid)
            break
        else:
            if n-mid>total-k:
                lower=mid+1
            else:
                upper=mid

n,k=map(int,input().split())
if n==1 and k==1:
    print(0)
else:
    binary(n,k)
",O(logn)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
",O(n)
"class Solution(object):
    def findDifferentBinaryString(self, nums):
        return """".join(""01""[nums[i][i] == '0'] for i in range(len(nums)))",O(n)
"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        seen = set()
        cur = head
        while cur:
            if cur in seen:
                return True
            seen.add(cur)
            cur = cur.next
        return False
",O(n)
"from sys import stdin, stdout
import bisect
input = stdin.readline
t = 1
for _ in range(t):
    n,q=map(int,input().split())
    a=[int(x) for x in input().split()]
    pre=[]
    s=0
    for i in a:
        s+=i
        pre.append(s)
    lost=0
    val_lost=0
    ans=[]
    qu=[int(x) for x in input().split()]
    for i in qu:
        val=i+val_lost
        b=bisect.bisect_left(pre,val,lost,n)
        val_lost=min(val,pre[-1])
        if b==n:
            lost = 0
            val_lost = 0
            ans.append(n)
            continue
        if pre[b]==val:
            lost=b+1
        else:
            lost=b
        if lost==n:
            lost = 0
            val_lost = 0
        ans.append(n-lost)
    for i in ans:
        print(i)",O(nlogn)
"from sys import stdin
input=stdin.readline

def count(n):

    value=0
    while(n):
        n &= (n-1)
        value+=1

    return value

def nc2(n):
    return (n*(n - 1))//2

def answer():

    dp=[0]*(1 << n)

    dp[(1 << n) - 1]=1

    for mask in range((1 << n) - 1,0,-1):

        m=count(mask)
        if(m==1):continue

        p=1/(nc2(m))

        for i in range(n):
            for j in range(n):
                if(i==j):continue

                if((mask >> i & 1) and (mask >> j & 1)):

                    next_mask=mask ^ (1 << j)
                    dp[next_mask]+=(dp[mask]*p*a[i][j])

    for i in range(n):

        print(dp[1 << i],end=' ')

n=int(input())
a=[list(map(float,input().split())) for i in range(n)]

answer()
print()
",np
"n, q = map(int,input().split())
par = n // 2 + 1
par = len(list(bin(par)[2:]))
for i in range(q):
    ui = int(input())
    si = input()
    temp = bin(ui)[2:]
    now = len(temp)
    num = list((par - now) * ""0"" + temp)
    now = par - now
    for i in range(len(num)):
        if str(num[i]) == '1':
            now = i
    for i in si:
        if i == ""U"":
            if now == 0:
                continue
            num[now] = 0
            now -= 1
            num[now] = 1
        elif i == ""L"":
            if str(num[-1]) == '1':
                continue
            num[now] = 0
            now += 1
            num[now] = 1
        else:
            if str(num[-1]) == '1':
                continue
            now += 1
            num[now] = 1
    for i in range(par):
        num[i] = str(num[i])
    print(int("""".join(num),2))
",np
"class Solution(object):
    def collectTheCoins(self, coins, edges):
        DISTANCE = 2

        adj = [set() for _ in range(len(coins))]
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        n = len(coins)
        q = []
        for u in range(len(coins)):
            while len(adj[u]) == 1 and not coins[u]:
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                u = v
        q = [u for u in range(len(coins)) if len(adj[u]) == 1]
        for _ in range(DISTANCE):
            new_q = []
            for u in q:
                if not adj[u]:
                    assert(n == 1)
                    break
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                if len(adj[v]) == 1:
                    new_q.append(v)
            q = new_q
        return (n-1)*2",O(n)
"import sys
readline = sys.stdin.readline

def main():
    N = int(input())
    itvs = []
    for _ in range(N):
        x, w = map(int, input().split())
        itvs.append((x - w, x + w))
    itvs.sort(key=lambda x: x[1])

    ans = 0
    end = -(10**9 + 1)
    for l, r in itvs:
        if end <= l:
            ans += 1
            end = r
    print(ans)

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n + 1)]

        for i in range(n - 1, -1, -1):
            for buying in [True, False]:
                if buying:
                    buy = dp[i + 1][False] - prices[i] if i + 1 < n else -prices[i]
                    cooldown = dp[i + 1][True] if i + 1 < n else 0
                    dp[i][1] = max(buy, cooldown)
                else:
                    sell = dp[i + 2][True] + prices[i] if i + 2 < n else prices[i]
                    cooldown = dp[i + 1][False] if i + 1 < n else 0
                    dp[i][0] = max(sell, cooldown)

        return dp[0][1]
",O(n)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])
        return res
",O(n)
"l, r = map(int, input().split())
if r - l + 1 < 3:
    print(-1)
    exit()
if l % 2 == 0:
    print(l, l+1, l+2)
    exit()
if r - l + 1 > 3:
    print(l+1, l+2, l+3)
    exit()
print(-1)
",O(1)
"import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))",O(n)
"MAX_N = 1000
MOD = 10**9+7
dp = [[0]*MAX_N for _ in range(MAX_N)]
for i in range(len(dp)):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%MOD


class Solution(object):
    def numOfWays(self, nums):
        def iter_dfs(nums):
            result = [0]
            stk = [[1, [nums, result]]]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    nums, ret = params
                    if len(nums) <= 2:
                        ret[0] = 1
                        continue
                    left = [v for v in nums if v < nums[0]]
                    right = [v for v in nums if v > nums[0]]
                    ret[0] = dp[len(left)+len(right)][len(left)]
                    ret1, ret2 = [0], [0]
                    stk.append([2, [ret1, ret2, ret]])
                    stk.append([1, [right, ret2]])
                    stk.append([1, [left, ret1]])
                elif step == 2:
                    ret1, ret2, ret = params
                    ret[0] = ret[0]*ret1[0] % MOD
                    ret[0] = ret[0]*ret2[0] % MOD
            return result[0]

        return (iter_dfs(nums)-1)%MOD",O(n ^ 2)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        if r==self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N,K = mi()
S = input()
S = [ord(S[i])-ord(""a"") for i in range(N)]

pow_2 = [pow(2,i) for i in range(K)]
k = K

def cond(n):
    cnt = [0 for i in range(k)]
    v = 0
    for i in range(n):
        if not  0<= S[i] < k:
            continue
        if cnt[S[i]]==0:
            v += 1
        cnt[S[i]] += 1

    str_range = [[N for j in range(N)] for i in range(k)]
    if v==1:
        for i in range(k):
            if cnt[i]:
                str_range[i][0] = 0
    elif v==0:
        for i in range(k):
            str_range[i][0] = 0

    for i in range(n,N):
        if 0 <= S[i-n] < k:
            cnt[S[i-n]] -= 1
            if cnt[S[i-n]] == 0:
                v -= 1
        if 0 <= S[i] < k:
            cnt[S[i]] += 1
            if cnt[S[i]] == 1:
                v += 1

        if v==1:
            for j in range(k):
                if cnt[j]:
                    for l in range(i-n+1,-1,-1):
                        if str_range[j][l] == N:
                            str_range[j][l] = i - n + 1
                        else:
                            break
                    break
        elif v==0:
            for j in range(k):
                for l in range(i-n+1,-1,-1):
                    if str_range[j][l] == N:
                        str_range[j][l] = i - n + 1
                    else:
                        break

    INF = N + 1
    dp = [INF for bit in range(1<<k)]
    dp[0] = 0

    for bit in range(1<<k):
        if dp[bit]>=N:
            continue
        idx = dp[bit]
        for i in range(k):
            if not bit >> i & 1:
                nv = bit|pow_2[i]
                tmp = str_range[i][idx] + n
                dp[nv] = min(dp[nv],tmp)

    return dp[-1]!=INF

ok = 0
ng = N+1
while ng-ok>1:
    mid = (ok+ng)//2
    if cond(mid):
        ok = mid
    else:
        ng = mid

print(ok)
",np
"import sys, string

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
st = []
for i in arr:
    if not st:
        st.append(i)
    else:
        while st:
            if 0 < abs(st[-1] - i) <= k:
                st.pop()
            else:
                break
        st.append(i)
print(len(st))",O(nlogn)
"class Solution(object):
    def maximumProcessableQueries(self, nums, queries):
        dp = [[float(""-inf"")]*len(nums) for _ in range(len(nums))]
        dp[0][-1] = 0
        for l in reversed(range(1, len(nums))):
            for i in range(len(nums)-(l-1)):
                j = i+(l-1)
                if i-1 >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0))
                if j+1 < len(nums):
                    dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0))
                if dp[i][j] == len(queries):
                    return len(queries)
        return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in range(len(nums)))",O(n ^ 2)
"import math

n_r = list(map(int, input().split()))

n = n_r[0]
radii = n_r[1]

x_list = list(map(int, input().split()))

temp_arr = []
for i in range(n):
    temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j]
                    for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii])
                    )

for i in temp_arr:
    print(i, end= "" "")
",O(n ^ 2)
"class Solution3(object):
    def trap(self, height):
        right = [0]*len(height)
        mx = 0
        for i in reversed(range(len(height))):
            right[i] = mx
            mx = max(mx, height[i])
        result = left = 0
        for i in range(len(height)):
            left = max(left, height[i])
            result += max(min(left, right[i])-height[i], 0)
        return result",O(n)
"def main():
    mod=1000000007

    tc=1
    for _ in range(tc):
        a=list(rs())
        b=list(rs())

        if len(a)<len(b):
            ws(''.join(sorted(a)[::-1]))
        else:
            a=sorted(a)
            ans=[]
            sa=SortedList(a)
            for i in range(len(a)-1):
                for j in range(len(sa)-1,-1,-1):
                    temp=ans+[sa[j]]
                    sa.discard(sa[j])
                    for k in sa:
                        temp.append(k)

                    if temp<=b:
                        ans.append(temp[i])
                        break
                    else:
                        sa.add(temp[i])
            ans.append(sa[-1])
            ws("""".join(ans))

def rant():

    return ""AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH""

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def memodict(f):

    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret

    return memodict().__getitem__

def pollard_rho(n):

    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3

    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n

@memodict
def prime_factors(n):

    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)

def distinct_factors(n):

    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors

def all_factors(n):

    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

class DisjointSetUnion:
    def __init__(self, n):
        self.parent = [*range(n+1)]
        self.size = [1]*(n+1)
        self.min, self.max = [*range(n+1)], [*range(n+1)]
        self.count = n

    def get(self, a):

        if self.parent[a] == a:
            return a
        x = a
        while a != self.parent[a]:
            a = self.parent[a]
        while x != self.parent[x]:
            self.parent[x], x = a, self.parent[x]
        return a

    def union(self, a, b):

        a, b = self.get(a), self.get(b)
        if a != b:
            if self.size[a] > self.size[b]:
                a, b = b, a
            self.parent[a] = b
            self.size[b] += self.size[a]
            self.min[b] = min(self.min[a], self.min[b])
            self.max[b] = max(self.max[a], self.max[b])
            self.count -= 1

    def count_sets(self):

        return self.count

class SegmentTree:

    def __init__(self, data, default=0, func=max):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):

        stop+=1
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SparseTable:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, start, stop):

        depth = (stop + 1 - start).bit_length() - 1
        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])

    def __getitem__(self, idx):
        return self._data[0][idx]

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from math import log2
from bisect import bisect_left,bisect_right
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    main()
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")
",O(n ^ 3)
"import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = True
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = False
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T])
    else:
        print('NO')

main()",np
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

k = inpl(); k.sort()
if k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:
    print('YES')
else:
    print('NO')",O(1)
"R = lambda: map(int, input().split())
n, k = R()
if n == 1:
    print(0)
    exit(0)
if 1 + k * (k - 1) // 2 < n:
    print(-1)
    exit(0)
l, r = 0, k - 1
while l < r:
    m = (l + r + 1) // 2
    if 1 + (m + k - 1) * (k - 1 - m + 1) // 2 >= n:
        l = m
    else:
        r = m - 1
if 1 + (l + k - 1) * ((k - 1) - l + 1) // 2 < n:
    print(k - 1 - l + 2)
else:
    print(k - 1 - l + 1)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstToGst(self, root):
        def bstToGstHelper(root, prev):
            if not root:
                return root
            bstToGstHelper(root.right, prev)
            root.val += prev[0]
            prev[0] = root.val
            bstToGstHelper(root.left, prev)
            return root
        
        prev = [0]
        return bstToGstHelper(root, prev)",O(n)
"def rr(): return input().rstrip()
def rri(): return int(rr())
def rrm(): return list(map(int, rr().split()))
from collections import defaultdict
def mus(d=0): return defaultdict(defaultdict(d))
def ms(x, y, d=0): return [[d]*y for i in range(x)]
def ar(x, d=0): return [d]*x
def ppm(m, n=0, x=0, y=0): print(""\n"".join((""\t"".join((str(m[j][i]) for j in range(y or n))) for i in range(x or n))))
def ppa(a, n): print(""\t"".join(map(str, a[0:n])))
def ppl(): print(""\n+""+""- -""*20+""+\n"")
INF = float(""inf"")

def fake_input():
    return ...

dp = ms(501, 501)
dp2 = ar(501, INF)

def read():
    n = rri()
    global arr
    arr = rrm()
    return arr, n

def calc_dp(l, r):
    assert l < r

    if l+1 == r:
        dp[l][r] = arr[l]
        return dp[l][r]
    if dp[l][r] != 0:
        return dp[l][r]

    dp[l][r] = -1

    for i in range(l+1, r):
        lf = calc_dp(l, i)
        rg = calc_dp(i, r)
        if (lf > 0 and lf == rg):
            dp[l][r] = lf + 1
            return dp[l][r]

    return dp[l][r]

def solve(arr, n):
    dp2[0] = 0

    for i in range(n):
        for j in range(i+1, n+1):
            v = calc_dp(i, j)

            if (v > 0):
                dp2[j] = min(dp2[j], dp2[i]+1)

    ans = dp2[n]
    return ans

if __name__ == ""__main__"":

    input_data = read()

    result = solve(*input_data)
    print(result)
",O(n ^ 3)
"import collections



class Solution(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        lookup = {}
        def powmod(n, p):
            if (n, p) not in lookup:
                lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD 
            return lookup[n, p]

        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD
            if cnt[nums[i]]:
               curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD
            cnt[nums[i]] += 1
            curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"import sys
from collections import defaultdict

def main():
    n, k = map(int, input().split())
    cand = 0
    tot = 0
    p = 0
    while tot < k or tot-(n-p) != k:
        cand += 1
        tot += cand
        p += 1

    print(tot-k)

if __name__ == '__main__':
    main()
",O(logn)
"def mul(a, b, md) :
    if(b == 1) :
        return a
    if(b % 2 == 0) :
        t = mul(a, b // 2, md)
        return (2 * t) % md
    return (mul(a, b - 1, md) + a) % md;

def pows(a, b, md) :
    if(b == 0) :
        return 1
    if(b % 2 == 0) :
        t = pows(a, b // 2, md)
        return mul(t, t, md) % md
    return (mul(pows(a, b - 1, md) , a, md)) % md;

x, k = map(int, input().split())
ch = pows(2, k, 1000000007)
ans = pows(2, k + 1, 1000000007) * x - ch + 1
ans = ans % (1000000007)
if(x == 0) :
    ans = 0
print(ans)",O(logn)
"import sys
import collections
import math
import heapq
import bisect
from operator import itemgetter

def getint():
    return int(input())

def getints():
    return [int(x) for x in input().split(' ')]

n, m = getints()
b = getints()
g = getints()

result = 0

bMax, bMax2, bSum = -1, -1, 0
for i, bb in enumerate(b):
    bSum += bb
    if bb > bMax:
        bMax2, bMax = bMax, bb
    elif bb > bMax2:
        bMax2 = bb

gMin, gSum = float('inf'), 0
for j, gg in enumerate(g):
    gSum += gg
    if gg < gMin:
        gMin = gg

if bMax > gMin:
    result = -1
else:
    result = bSum * m
    result += gSum
    result -= bMax * m
    if gMin > bMax:
        result += bMax - bMax2

print(str(result))",O(n)
"n = int(input())
i = 0
s = 0
while True:
	temp = (i+1)*9*(10**i)
	if s + temp <= n:
		s += temp
		i += 1
	else:
		break
tc = n - s

nd = tc//(i+1) - 1
tc -= (nd+1)*(i+1)
f = 10**i + nd
if tc != 0:
	print(str(10**i+nd+1)[tc-1])
else:
	print(str(10**i+nd)[-1])
",O(logn)
"if __name__ == '__main__':
    n, m, k = map(int, input().split())
    aa = list(map(int,input().split()))
    ans = 0
    for start in range(m):
        ac = aa[:]
        for i in range(start, n, m):
            ac[i] -= k
        cur = 0
        for i in range(start, n):
            if i%m == start:
                cur = max(ac[i] + cur, ac[i])
            else:
                cur += ac[i]
            ans = max(cur, ans)
    print(ans)
",O(n ^ 2)
"class Solution(object):
    def repeatedSubstringPattern(self, str):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(str)
        return prefix[-1] != -1 and \
               (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0

    def repeatedSubstringPattern2(self, str):
        if not str:
            return False

        ss = (str + str)[1:-1]
        return ss.find(str) != -1",O(n)
"import sys
input = sys.stdin.readline
from math import ceil, floor, factorial;

def swaparr(arr, a,b):
    temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp

def gcd(a,b):
    if a == 0:
        return b
    return gcd(b%a, a)

def nCr(n, k):
    if(k > n - k):
        k = n - k
    res = 1
    for i in range(k):
        res = res * (n - i)
        res = res / (i + 1)
    return int(res)

def upper_bound(a, x, lo=0):
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x:
            lo = mid+1
        else:
            hi = mid
    return lo

def primefs(n):

    primes = {}
    while(n%2 == 0):
        primes[2] = primes.get(2, 0) + 1
        n = n//2
    for i in range(3, int(n**0.5)+2, 2):
        while(n%i == 0):
            primes[i] = primes.get(i, 0) + 1
            n = n//i
    if n > 2:
        primes[n] = primes.get(n, 0) + 1

    return primes

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0) :
        return 0
    while (y > 0) :
        if ((y & 1) == 1) :
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def swap(a,b):
    temp = a
    a = b
    b = temp
    return a,b

def find(x, link):
    p = x;
    while( p != link[p]):
        p = link[p];

    while( x != p):
        nex = link[x];
        link[x] = p;
        x = nex;
    return p;

def union(x, y, link, size):
    x = find(x, link)
    y = find(y, link)
    if size[x] < size[y]:
        x,y = swap(x,y)
    if x != y:
        size[x] += size[y]
        link[y] = x

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

MAXN = int(1e6 + 5)
def spf_sieve():
    spf[1] = 1;
    for i in range(2, MAXN):
        spf[i] = i;
    for i in range(4, MAXN, 2):
        spf[i] = 2;
    for i in range(3, ceil(MAXN ** 0.5), 2):
        if spf[i] == i:
            for j in range(i*i, MAXN, i):
                if spf[j] == j:
                    spf[j] = i;

def factoriazation(x):
    ret = {};
    while x != 1:
        ret[spf[x]] = ret.get(spf[x], 0) + 1;
        x = x//spf[x]
    return ret

def int_array():
    return list(map(int, input().strip().split()))

def str_array():
    return input().strip().split();

MOD = int(1e9)+7;
CMOD = 998244353;
INF = float('inf'); NINF = -float('inf');

n, l, r, x = int_array(); a = sorted(int_array());
ans = 0;
for mask in range( 1 << n):
    mx = NINF; mn = INF; sub = 0;
    for i in range(n):
        if (1 << i) & mask:
            sub += a[i];
            mx = max(mx, a[i]);
            mn = min(mn, a[i]);
    if sub >= l and sub <= r:
        if mx - mn >= x:
            ans += 1;
print(ans);",np
"import sys

def rl(proc=None):
    if proc is not None:
        return proc(sys.stdin.readline())
    else:
        return sys.stdin.readline().rstrip()

def srl(proc=None):
    if proc is not None:
        return list(map(proc, rl().split()))
    else:
        return rl().split()

def main():
    rl()
    a = srl(int)
    a.sort()
    cnt = 0
    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            a[i] -= 1
            cnt += 1
            break
    if a[0] < 0:
        print('cslnb')
        return

    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            print('cslnb')
            return

    for i, x in enumerate(a):
        cnt += x - i

    print('sjfnb' if (cnt & 1) else 'cslnb')

if __name__ == '__main__':
    main()
",O(n)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
candies=[]
for i in range(n):
    candies.append(n-l[i]-r[i])
left=[]
for i in range(n):
    guys=0
    for j in range(i):
        if candies[j]>candies[i]:
            guys+=1
    left.append(guys)
right=[]
for i in range(n):
    guys=0
    for j in range(i,n):
        if candies[j]>candies[i]:
            guys+=1
    right.append(guys)
if left==l and right==r:
    print(""YES"")
    candiesstr=""""
    for i in range(n):
        candiesstr+=str(candies[i])+"" ""
    print(candiesstr[:len(candiesstr)-1])
else:
    print(""NO"")",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
ans = float('inf')
for i in range(n):
    ans = min(ans, a[i] // max(i,  n - i - 1))
print(ans)",O(n)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1

input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def fun(A):
    for i in range(len(A)):
        if A[i] == 0:
            return i
    return 1

dp = [0]*10
A = aj();A.sort()
k1,k2,k3 = A
for i in range(0,10,k1):
    dp[i] = 1
for i in range(fun(dp),10,k2):
    dp[i] = 1
for i in range(fun(dp),10,k3):
    dp[i] = 1
Y(0 not in dp)
",O(1)
"class Solution(object):
    def findBottomLeftValue(self, root):
        def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):
            if not root:
                return max_depth, bottom_left_value
            if not root.left and not root.right and curr_depth+1 > max_depth:
                return curr_depth+1, root.val
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value)
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value)
            return max_depth, bottom_left_value

        result, max_depth = 0, 0
        return findBottomLeftValueHelper(root, 0, max_depth, result)[1]",O(n)
"class Solution2(object):
    def getLonelyNodes(self, root):
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result",O(n)
"from sys import stdin, stdout
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

a, b = mp()
c = 0
x = 0
while not (c>=b and c-b+x==a):
    x += 1
    c += x
print(a-x)",O(logn)
"class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):
        result, max_extra, extra = 0, 0, 0
        for i in range(len(customers)):
            result += 0 if grumpy[i] else customers[i]
            extra += customers[i] if grumpy[i] else 0
            if i >= X:
                extra -= customers[i-X] if grumpy[i-X] else 0
            max_extra = max(max_extra, extra)
        return result + max_extra",O(n)
"from collections import defaultdict,deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, itertools, math
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float, input().split()))
def LI_(): return list(map(lambda x: int(x)-1, input().split()))
def II(): return int(input())
def IF(): return float(input())
def S(): return input().rstrip()
def LS(): return S().split()
def IR(n):
    res = [None] * n
    for i in range(n):
        res[i] = II()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI()
    return res
def FR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR_(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI_()
    return res
def SR(n):
    res = [None] * n
    for i in range(n):
        res[i] = S()
    return res
def LSR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LS()
    return res
mod = 1000000007
inf = float('INF')

def solve():
    n = II()
    a = LI()
    dp = [[None for i in range(n + 1)] for i in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = [a[i], a[i], 1]
        dp[i + 1][i] = [a[i], a[i], 1]
    for i in range(2, n + 1):
        for l in range(n - i + 1):
            tmp = [-inf, inf, inf]
            r = l + i
            dpl = dp[l]
            dpr = dp[r]
            for m in range(l + 1, r):
                lm = dpl[m]
                mr = dpr[m]
                lr = lm[2] + mr[2] - (lm[1] == mr[0])
                if lr < tmp[2]:
                    tmp[2] = lr
                    if lm[1] == mr[0]:
                        if lm[2] == 1:
                            tmp[0] = lm[0] + 1
                        else:
                            tmp[0] = lm[0]
                        if mr[2] == 1:
                            tmp[1] = mr[1] + 1
                        else:
                            tmp[1] = mr[1]
                    else:
                        tmp[0] = lm[0]
                        tmp[1] = mr[1]
            dp[l][r] = tmp
            dp[r][l] = tmp
    print(dp[0][n][2])
    return

if __name__ == '__main__':
    solve()
",O(n ^ 3)
"n = int(input())

a = list(map(lambda i: int(i), input().split(sep=' ')))
a.sort()
a_count = len(a)

b = list(filter(lambda i: i > 0, a))
b_count = len(b)

def resh():
    idx = 1
    while idx < a_count:
        if a[idx] == a[idx - 1] and (a[idx] - 1) in a:
            return 'cslnb'
        idx += 1

    b_sum = sum(b)
    v_sum = sum(range(1, b_count if a_count == b_count else b_count + 1))
    t = max(b_sum - v_sum, 0)
    return 'cslnb' if t % 2 == 0 else 'sjfnb'

if b_count == 0 or  b_count - len(set(b)) > 1 or a_count - b_count > 1:
    print('cslnb')
else:
    print(resh())
",O(nlogn)
"class Solution(object):
    def minMoves(self, target, maxDoubles):
        result = 0
        while target > 1 and maxDoubles:
            result += 1+target%2
            target //= 2
            maxDoubles -= 1
        return result+(target-1)",O(logn)
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)
    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]
for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx
for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:print(""NO"");exit()

    graph[idx] += [idx_to for idx_to in idxs if idx != idx_to]
flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np
"n = int(input())
print(n if n < 3 else ((n - 1) * (n * (n - 2) if n & 1 else (n - 3) * (n if n % 3 else n - 2))))",O(1)
"s = input()
sLen, ans = len(s), 0

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)",O(n ^ 3)
"class Solution(object):
    def addRungs(self, rungs, dist):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        result = prev = 0
        for curr in rungs:
            result += ceil_divide(curr-prev, dist)-1
            prev = curr
        return result",O(n)
"n, k = map(int, input().split())
q = 2 * n + 1
p = k // n
if k % n:
    print(p + 1)
else:
    print(p)",O(1)
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",O(n)
"from sys import stdin,stdout
def main():
	n=int(stdin.readline())
	s=stdin.readline()
	sum=0
	a=[]
	for v in s:
		if v!='0' and v!='\n':
			a.append(v)
	if not a and n>1:
		return 'YES'
	n=len(a)
	s=a
	for i in range(n-1):
		sum+=int(s[i])
		j=i+1
		check=1
		while j<n:
			temp=int(s[j])
			j+=1
			while j<n:
				if temp>=sum:
					break
				temp+=int(s[j])
				j+=1
			if sum!=temp:
				check=1
				break
		if sum!=temp:
			check=0
		if check:
			return 'YES'
	return 'NO'
print(main())
",O(n ^ 2)
"a=input()
n=len(a)
for l in range(n,0,-1):
  for i in range(n-l+1):
    if a[i:i+l] in a[i+1:]:
      print(l)
      exit(0)
print(0)",O(n ^ 3)
"class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 1: 
                return 0
            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid, end, lower, upper)
            j, k, r = mid, mid, mid
            tmp = []
            for i in range(start, mid):
                while k < end and sums[k] - sums[i] < lower:
                    k += 1
                while j < end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r < end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])
            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums), lower, upper)",O(nlogn)
"n, k = map(int, input().split())
l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if m * (m + 1) // 2 - (n - m) > k:
        r = m
    else:
        l = m
print(n - l)",O(logn)
"class Solution(object):
    def sortTransformedArray(self, nums, a, b, c):
        f = lambda x, a, b, c : a * x * x + b * x + c

        result = []
        if not nums:
            return result

        left, right = 0, len(nums) - 1
        d = -1 if a > 0 else 1
        while left <= right:
            if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c):
                result.append(f(nums[left], a, b, c))
                left += 1
            else:
                result.append(f(nums[right], a, b, c))
                right -= 1

        return result[::d]",O(n)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=sorted([lst() for _ in range(n)],key=lambda x:(-x[0],x[1]))
    p,t=-1,-1;ans=0
    if k<=n:p,t=a[k-1]
    for x,y in a:
        if x==p and y==t:ans+=1
    print(ans)",O(nlogn)
"

class Solution(object):
    def buyChoco(self, prices, money):
        i = min(range(len(prices)), key=lambda x: prices[x])
        j = min((j for j in range(len(prices)) if j != i), key=lambda x: prices[x])
        return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money
",O(n)
"from collections import deque

m, k = list(map(int, input().split()))

G = [set() for _ in range(m + 1)]

q, nq = deque(), deque()

for _ in range(m - 1):
    u, v = list(map(int, input().split()))
    G[u].add(v)
    G[v].add(u)

for u in range(1, m + 1):
    if len(G[u]) == 1:
        q.append(u)

step = 0
removed = 0
ok = True

while removed < m - 1:
    each = {}
    for u in q:
        nxt = G[u].pop()
        G[nxt].remove(u)
        each[nxt] = each.get(nxt, 0) + 1
        removed += 1
        if len(G[nxt]) == 0:
            break
        if len(G[nxt]) == 1:
            nq.append(nxt)
    if any(v < 3 for k,v in each.items()):
        ok = False
        break
    q, nq = nq, deque()
    step += 1

if ok and step == k and removed == m - 1:
    print('Yes')
else:
    print('No')
",O(nlogn)
"def main():
    a = sorted(input(), reverse=True)
    b = int(input())
    k = """"
    while len(a) > 0:
        for i in range(len(a)):
            num = k + a[i] + """".join(sorted(a[:i] + a[i + 1:]))
            if int(num) <= b:
                k += a[i]
                a = a[:i] + a[i + 1:]
                break
    print(k)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n, m = RL()
    arr = []
    for _ in range(n):  arr.append(RLL())
    res = []
    def c(num):
        nonlocal res
        dic = {}
        for i in range(n):
            now = 0
            for j in range(m):

                if arr[i][j]>=num:
                    now|=1<<j
            dic[now] = i+1

        for k, v in dic.items():
            for kk, vv in dic.items():
                if k|kk==(1<<m)-1:
                    res = v, vv
                    return True

        return False

    l, r = 0, 10**9

    while l<=r:
        mp = (l+r+1)//2
        now = c(mp)
        if now:
            l = mp+1
        else:
            r = mp-1

    print(*res)

if __name__ == ""__main__"":
    main()
",np
"import sys
input=lambda:sys.stdin.readline().rstrip()

h,w=map(int,input().split())
s=[list("".""*(w+2))]+[list("".""+input()+""."") for _ in range(h)]+[list("".""*(w+2))]
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i in range(1,h+2):
  for j in range(1,w+2):
    if s[i][j]==""*"":
      b[i][j]=b[i-1][j]+1
      c[i][j]=c[i][j-1]+1
for i in range(h,-1,-1):
  for j in range(w,-1,-1):
    if s[i][j]==""*"":
      b[i][j]=min(b[i][j],b[i+1][j]+1)
      c[i][j]=min(c[i][j],c[i][j+1]+1)
ans=[]
for i in range(1,h+1):
  for j in range(1,w+1):
    t=min(b[i][j],c[i][j])-1
    if t>0:
      ans.append((i,j,t))
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i,j,t in ans:
  b[i-t][j]+=1
  b[i+t+1][j]-=1
  c[i][j-t]+=1
  c[i][j+t+1]-=1
for i in range(h+1):
  for j in range(w+1):
    b[i+1][j]+=b[i][j]
    c[i][j+1]+=c[i][j]
    if i!=0 and j!=0:
      if (b[i][j]+c[i][j]>0)!=(s[i][j]==""*""):
        print(-1)
        exit()

print(len(ans))
for i in ans:print(*i)",O(n ^ 2)
"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:
    if len(problemSet) >= 2:
        total = sum(problemSet)
        myDelta = max(problemSet) - min(problemSet)
        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:
            return True
    return False

def countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:

    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:
        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):
            validSubsets.append(currentSubset)
        for i in range(nextElementIndex, len(problems)):
            currentSubset.append(problems[i])
            subsetBuilder(problems, currentSubset, i+1)
            currentSubset.pop(-1)

    index = 0
    currentSubset = []
    validSubsets = []

    subsetBuilder(problems, currentSubset, index)
    return len(validSubsets)

n, l, r, x = input().split()
n = int(n)
l = int(l)
r = int(r)
x = int(x)

probs = [int(prob) for prob in input().split()]

print(countValidSubsets(probs, l, r, x))
",np
"numeros = [int(i) for i in input().split(' ')]

l = bin(numeros[0])
r = bin(numeros[1])

p = -1

if (len(r) == len(l)):
    for i in range (len(l)):
        if (l[i] != r[i]):
            p = i
            break
    if(numeros[0] != numeros[1]):

        saida = 2**(len(r) - p) - 1
        print(saida)
    else:
        print(0)

else:
    if(numeros[0] != numeros[1]):
        saida = 2**(len(r) - 2) - 1

        print(saida)
    else:
        print(0)
",O(logn)
"import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result",O(n)
"def if_Spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1, n + 1):
        if m[i] == 0:
            d[l[i]] += 1
    for i in range(1, n + 1):
        if m[i] > 0 and d[i] < 3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_Spruce(n,l,m))
",O(n)
"a=int(input())
arr=list(map(int,input().split()))
d=dict()
summ=[0]
brr=arr
nd=dict()
mimpp=dict()
mimpn=dict()
for i in arr:
    summ.append(i+summ[len(summ)-1])
    if(i in d):
        d[i]=d[i]+1
    else:
        d[i]=1
for i in range(0,len(brr)):
    if(brr[i] in nd):
        nd[brr[i]]=nd[brr[i]]+1
    else:
        nd[brr[i]]=1
    mimpn[i]=0
    mimpp[i]=0
    if(brr[i]-1 in d):
        mimpn[i]=mimpn[i]+d[brr[i]-1]
    if(brr[i]+1 in d):
        mimpp[i]=mimpp[i]+d[brr[i]+1]
    if(brr[i]-1 in nd):
        mimpn[i]=mimpn[i]-nd[brr[i]-1]
    if(brr[i]+1 in nd):
        mimpp[i]=mimpp[i]-nd[brr[i]+1]

ans=0
ind=0
su=sum(arr)
for i in range(0,len(arr)):
    ans=ans+su-summ[ind]-(a-ind)*arr[i]
    ans=ans+mimpn[i]
    ans=ans-mimpp[i]
    ind=ind+1
print(ans)
",O(nlogn)
"def func(n,i):
        if n==3:
                return (str(1*i)+' ')+(str(1*i)+' ')+(str(3*i))
        if n%2==0:
                odd=n//2
        else:
                odd=n//2+1
        q=1*i
        s= (str(q)+' ')*odd
        return s

from math import log
n=int(input())
if n==3:
        s='1 1 3'
else:
        s=''
        z=1
        while(n>0):
                s=s+func(n,z)
                z=z*2
                if n==3:
                        break
                if n%2==0:
                        odd=n//2
                else:
                        odd=n//2+1
                n=n-odd
print(s)
",O(logn)
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):

        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):

                tmp = dp[j]

                if dp[j] != -1 and i+dp[j] < N and t[i+dp[j]] == c:
                    tmp = dp[j]+1

                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")
",O(n ^ 3)
print('4'*1131+'\n'+'5'*1130+'6'),O(1)
"[n, l, r, x] = list(map(int, input().strip().split()))
Cs = list(sorted(map(int, input().strip().split())))
probs = 0

for i in range(1, 2**n):
    currsub = [ Cs[j] for j in range(n) if (i & (1 << j))]
    probs += (len(currsub) > 1 and l <= sum(currsub) <= r and currsub[-1] - currsub[0] >= x)

print(probs)",np
"s = input()
one = s.count('1')
zero = 0
ind = -1
for i in range(len(s)):
    if s[i]=='2':
        ind=i
        break
    if s[i]=='0':
        zero+=1
d = """"
if ind==-1:
    print(""0""*zero+""1""*one)
    exit()
d =  d + ""0""*zero+""1""*one
for i in s[ind:]:
    if i!='1':
        d+=i
print(d)
",O(n)
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2

n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])

cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0

for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2

print((n*(n+1))//2 - cnt1)
",O(n)
"M = 998244353
n = int(input())
l = sorted(map(int, input().split()))[::-1]
out = [0] * n
big = 0
if l[0] >= 2 * l[1]:
    out[1] = 1
    big = 1
for i in range(2, n):
    new = [0] * n
    bigN = 0
    for j in range(i):
        if l[j] >= 2 * l[i]:
            big += out[j]
        else:
            new[j] += out[j] * (i - 1)
            new[j] %= M

    new[i] = big
    bigN = (i * big) % M

    out = new
    big = bigN
print((big + sum(out))%M)",O(n ^ 3)
"class Solution2(object):
    def minimumOneBitOperations(self, n):
        result = 0
        while n:
            result = -result - (n^(n-1)) 
            n &= n-1
        return abs(result)",O(logn)
"n, s = input().split()

n = int(n)
s = int(s)

def get_decimal_value_digits(number):
    count = 0
    digits = 0
    number = str(number)
    for digit in number:
        count += int(digit)
        digits += 1
    return count

def is_big_num(number, s):
    if (number - get_decimal_value_digits(number)) >= s:
        return True
    return False

start = s
end = n
count = 0
digits = 0
half = (n + s) // 2

while (end - start) >= 0:
    half = (start + end) // 2

    if is_big_num(half, s):
        end = half - 1
    else:
        start = half + 1

if not is_big_num(start+1, s):
    print(0)
else:
    print(n - start + 1)
",O(logn)
"import itertools


class Solution(object):
    def areAlmostEqual(self, s1, s2):
        diff = []
        for a, b in zip(s1, s2):
            if a == b:
                continue
            if len(diff) == 2:
                return False
            diff.append([a, b] if not diff else [b, a])
        return not diff or (len(diff) == 2 and diff[0] == diff[1])",O(n)
"import sys
import math

fileoperation=0
if(fileoperation):
    orig_stdout = sys.stdout
    orig_stdin = sys.stdin
    inputfile = open('W:/Competitive Programming/input.txt', 'r')
    outputfile = open('W:/Competitive Programming/output.txt', 'w')
    sys.stdin = inputfile
    sys.stdout = outputfile

mod=1000000007

def nospace(l):
    ans=''.join(str(i) for i in l)
    return ans

t=1
for tt in range(t):

    n,k= map(int, sys.stdin.readline().split(' '))
    a=list(map(int,sys.stdin.readline().split(' ')))
    a.sort()

    ans=0
    c=1

    for i in range(n):
    	if(c>a[n-1] or c>a[i]):
    		ans+=a[i]-1
    		continue
    	if(i!=n-1):
    		ans+=a[i]-1
    		c+=1
    	else:
    		ans+=c-1
    print(ans)

if(fileoperation):
    sys.stdout = orig_stdout
    sys.stdin = orig_stdin
    inputfile.close()
    outputfile.close()
",O(nlogn)
"import sys,math
a,b=map(int,input().split())
l=list(map(int,input().split()))
t=[[-1,0] for i in range(100001)]
for i in range(a):
    if t[l[i]][0]!=-1:print(0);sys.exit()
    t[l[i]][0]=3
s=math.inf
for i in range(a):
    if t[l[i]&b][0]!=-1:

        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:
            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]

    else:t[l[i]&b]=[2,1]

for i in range(a):
    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])
if s==math.inf:
    print(-1)
else:
    print(s)
",O(n)
"n=int(input())
li=list(map(int,input().split()))
lis=[x%2 for x in li]
if lis.count(0)>lis.count(1):
    print(lis.index(1)+1)
else:
    print(lis.index(0)+1)",O(n)
"l,r=map(int,input().split())
if(l%2==0 and r-l>1):
    print(l,l+1,l+2,end="" "")
elif(l%2!=0 and r-l>2):
    print(l+1,l+2,l+3,end="" "")
else:
    print(""-1"")",O(1)
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",O(1)
"import math
g=0
n=int(input())
b=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=dict()
dp[0]=0
s=set([0])
for i in range(n):
    for j in s:
        g=math.gcd(j,b[i])
        if g in dp:
            dp[g]=min(dp[g],dp[j]+c[i])
        else:
            dp[g]=dp[j]+c[i]

    s=set(dp.keys())

if 1 in dp.keys():
    print(dp[1])
else:
    print(-1)",np
"class Solution2(object):
    def countQuadruplets(self, nums):
        lookup = collections.defaultdict(list)
        for d in range(3, len(nums)):
            for c in range(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in range(1, len(nums)-2) for a in range(b))",O(n ^ 3)
"def countall(string, substring):
    total = 0
    for i in range(len(string)-len(substring)+1):
        if string[i:i+len(substring)] == substring:
            total += 1
    return total

n = input()
allvalues = []
for i in range(len(n)):
    for j in range(len(n)-1, i-1, -1):
        if countall(n, n[i:j+1]) > 1:
            allvalues.append(j-i+1)
            break

try:
    print(max(allvalues))
except:
    print(0)",O(n ^ 3)
"import sys
import bisect
import heapq

from collections import defaultdict as dd
from collections import deque
from collections import Counter as c
from itertools import combinations as comb
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353
def data(): return sys.stdin.readline().strip()

def out(var): sys.stdout.write(var)

def l(): return list(map(int, data().split()))

def sl(): return list(map(str, data().split()))

def sp(): return map(int, data().split())

def ssp(): return map(str, data().split())

def l1d(n, val=0): return [val for i in range(n)]

def l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]

n = int(data())
arr = l()
dp = [[0 for j in range(500)] for i in range(500)]
dp2 = [0 for i in range(501)]
for i in range(n):
    dp[i][i] = arr[i]
i = n-2
while ~i:
    j = i+1
    while j < n:
        dp[i][j] = -1
        for k in range(i, j):
            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:
                dp[i][j] = dp[i][k]+1
        j += 1
    i -= 1
for i in range(1, n+1):
    dp2[i] = pow(10, 9)
    for j in range(i):
        if ~dp[j][i-1]:
            dp2[i] = min(dp2[i], dp2[j]+1)
out(str(dp2[n]))
",O(n ^ 3)
"n = int(input())

b = list(map(int, input().split()))
a1 = [0]
a2 = [b[0]]

for x in b[1:]:
	new_a = a1[-1]
	if x - new_a > a2[-1]:
		new_a = x - a2[-1]
	new_a2 = x - new_a
	a1.append(new_a)
	a2.append(new_a2)
print(*(a1+a2[::-1]))",O(n)
"class Solution(object):
    def canSplitArray(self, nums, m):
        return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in range(len(nums)-1))",O(n)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            n &= n - 1
            res += 1
        return res
",O(1)
"n,m=(int(x) for x in input().split())
sequence=input().split()[:n]
fingerprint=input().split()[:m]
print("" "".join(i for i in sequence if i in fingerprint))",O(n ^ 2)
"n = int(input())

first = list(input())
second = list(input())

swap = list()
can = True

for i in range(n):
    if first[i] != second[i]:
        cont = -1
        for j in range(i,n):
            if first[j] == second[i]:
                cont = j
                break

        if cont != -1:
            for j in range(cont, i, -1 ):
                first[j], first[j-1] = first[j-1], first[j]
                swap.append(j)
        else:
            can = False

if can:
    print(len(swap))
    print(*swap, end=' ')

else:
    print(-1)",O(n ^ 2)
"import sys
if __name__=='__main__':

    numCases = int(sys.stdin.readline())
    for i in range(numCases):
        a, b = sys.stdin.readline().split()
        a = int(a)
        b = int(b)
        total = 0
        largerNum = max(a,b)
        smallerNum = min(a,b)
        while True:
            div = int(largerNum/smallerNum)
            total += div
            rem = int(largerNum%(smallerNum*div))
            if rem == 0:
                break
            else:
                largerNum = smallerNum
                smallerNum = rem

        print(total)
",O(1)
"import collections


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def minInteger(self, num, k):
        lookup = collections.defaultdict(list)
        bit = BIT(len(num)+1)
        for i in reversed(range(len(num))):
            bit.add(i+1, 1)
            lookup[int(num[i])].append(i+1)
        result = []
        for _ in range(len(num)):
            for d in range(10):
                if lookup[d] and bit.sum(lookup[d][-1]-1) <= k:
                    k -= bit.sum(lookup[d][-1]-1)
                    bit.add(lookup[d].pop(), -1)
                    result.append(d)
                    break
        return """".join(map(str, result))",O(nlogn)
"def read_nums():
    return [int(x) for x in input().split()]

def main():
    n, v = read_nums()
    res = 0
    cur_tank = 0
    for c in range(1, n+1):
        need_to_by = min(v - cur_tank, n - c - cur_tank)
        res += need_to_by * c
        cur_tank += need_to_by
        cur_tank -= 1
    print(res)

if __name__ == '__main__':
    main()
",O(n)
"class Solution(object):
    def lastSubstring(self, s):
        left, right, l = 0, 1, 0
        while right+l < len(s):
            if s[left+l] == s[right+l]:
                l += 1
                continue
            if s[left+l] > s[right+l]:
                right += l+1
            else:
                left = max(right, left+l+1)
                right = left+1
            l = 0
        return s[left:]",O(n)
"class Solution(object):
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
        return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] \
               if tomatoSlices%2 == 0 and 2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices \
               else []",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1

    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                new[j][l] += dp[j][l]
                if l==0 or l==3:
                    new[j][l]+=dp[j-1][l^3]
                    new[j][l]+=(dp[j][1]+dp[j][2])
                elif l==1 or l==2:
                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])
                    if j-2>=0: new[j][l]+=dp[j-2][l^3]
                new[j][l] = new[j][l]%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()
",np
"n, m = [int(_) for _ in input().split()]
a = [0] * (n + 1)
l, r = 1, n

for i in range(1, n + 1):
    if m <= 1 << max((n - i - 1), 0):
        a[l] = i
        l += 1
    else:
        a[r] = i
        r -= 1
        m -= 1 << max((n - i - 1), 0)

a.pop(0)
print("" "".join(map(str, a)))",np
"import bisect
from itertools import accumulate, count
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:

        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    primes[1]=False
    primes[0]=False
    return primes
def primefactors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
def factors(n):
    fac=set()
    fac.add(1)
    fac.add(n)
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            fac.add(i)
            fac.add(n//i)
    return list(fac)
def NcR(n, r):

    p = 1
    k = 1
    if (n - r < r):
        r = n - r

    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m

            n -= 1
            r -= 1
    else:
        p = 1
    return p
def Log2(x):
    if x == 0:
        return False;

    return (math.log10(x) /
            math.log10(2));
def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) ==
            math.floor(Log2(n)));

n, r = map(int, input().split())
x = [int(i) for i in input().split()]
c = []

for i in range(n):
    k = r
    for x1, j in c:
        d = abs(x[i] - x1)
        if d <= 2 * r:
            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)
    c.append([x[i], k])
    print(k)
",O(n ^ 2)
"class Solution(object):
    def maxProfit(self, prices):
        max_profit, min_price = 0, float(""inf"")
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit",O(n)
"n, m = (int(x) for x in input().split())
boys_out = sorted([int(x) for x in input().split()], reverse=True)
girls_in = sorted([int(x) for x in input().split()])
max_boy = max(boys_out)
ans = 0
for boy in boys_out:
    ans += boy * m

count = 0
i = 0
for girl in girls_in:
    if girl < max_boy:
        print(-1)
        quit()

    if girl > max_boy:
        if count == m - 1:
            count = 0
            i += 1
        if i >= n:
            print(-1)
            quit()
        ans += girl - boys_out[i]
        count += 1

print(ans)",O(nlogn)
"n=int(input())
arr=[]
for i in range(n):
    arr.append(input())

arr.sort(key=lambda x: len(x))
flag=False
for i in range(n-2,-1,-1):
    if arr[i] not in arr[i+1]:
        flag=True
        break

if flag:
    print(""NO"")
else:
    print(""YES"")
    for i in arr:
        print(i)",O(nlogn)
"import sys, copy

n, m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = [0] * (max(arr) + 1)
for i in arr:
    res[i] += 1
ans = 0
for d in range(1, m + 1):
    temp = copy.deepcopy(res)
    cnt = 0
    for i in range(len(temp)):
        while temp[i] >= d:
            temp[i] -= d
            cnt += 1
    if cnt >= n:
        ans = max(ans, d)
print(ans)",O(nlogn)
"k={}
s=0

for i in range(int(input())):
	a,x=map(int,input().split())
	k[a]=x

for j in range(int(input())):
	b,y=map(int,input().split())
	if b in k:
		k[b]=max(k[b],y)

	else:
		k[b]=y
s=0
for h in k.values():

	s+=h
print(s)
",O(nlogn)
"import sys
input = sys.stdin.readline

from heapq import heapify, heappush, heappop

n, k = map(int, input().split())
plst = list(map(int, input().split()))
clst = list(map(int, input().split()))

if k == 0:
    print(*clst)
    sys.exit()

pc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))
res = [0] * n
pq = []
pq_sum = 0
pq_size = 0

for p, c, i in pc:
    if i > 0 and plst[i] == plst[i-1]:
        res[i] = res[i-1]
    else:
        res[i] = pq_sum + c

    if pq_size < k:
        heappush(pq, c)
        pq_sum += c
        pq_size += 1
    else:
        alt = heappop(pq)
        if alt < c:
            heappush(pq, c)
            pq_sum += c - alt
        else:
            heappush(pq, alt)

print(*res)
",O(nlogn)
"from sys import stdin,stdout

final_ans=0

R,G,B = map(int,stdin.readline().strip().split(' '))
Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)

dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
dparr[1][1][0]=Ra[0]*Ga[0]
dparr[1][0][1]=Ra[0]*Ba[0]
dparr[0][1][1]=Ga[0]*Ba[0]
final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])

def add_ns(t1):
	global queue,Ra,Ga,Ba,dparr
	x,y,z=t1
	if x+1<=R:
		if y+1<=G:
			if dparr[x+1][y+1][z]==-1:
				queue.append((x+1,y+1,z))
				dparr[x+1][y+1][z]=0

		if z+1<=B:
			if dparr[x+1][y][z+1]==-1:
				queue.append((x+1,y,z+1))
				dparr[x+1][y][z+1]=0
	if y+1<=G and z+1<=B:
		if dparr[x][y+1][z+1]==-1:
			queue.append((x,y+1,z+1))
			dparr[x][y+1][z+1]=0

def store_ans(t1):
	global final_ans,dparr,Ra,Ga,Ba
	x,y,z=t1
	if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
	if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
	if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:

		dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])

	final_ans=max(final_ans,dparr[x][y][z])

queue=[(1,1,0),(1,0,1),(0,1,1)]
add_ns(queue[0])
add_ns(queue[1])
add_ns(queue[2])
ptr=3

while ptr<len(queue):

	store_ans(queue[ptr])

	add_ns(queue[ptr])

	ptr+=1

stdout.write(str(final_ans)+""\n"")",O(n ^ 3)
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]

f()",O(n)
"s = input()
pb = 0
lenght = len(s)-1
w = []
while(lenght!=0):
    ss = s[pb:pb+lenght]
    w.append(ss)
    if pb+lenght==len(s):
        pb = 0
        lenght -= 1
    else:
        pb+=1
for i in range(0,len(w)-1):
    for j in range(i+1,len(w)):
        if (w[i]==w[j]):
            print(len(w[i]))
            exit(0)
print(0)
",O(n ^ 3)
"import sys
from collections import defaultdict

input = sys.stdin.readline

n, m = map(int, input().split())

vals = set()
locs = defaultdict(list)
for i in range(n):
    inp = map(int, input().split())
    for pos, v in enumerate(inp):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,m=nninp()
ans=0
cnt=f=0
for i in range(n):
    s=ssinp()
    r=stl(s)
    cnt=0
    for c in range(len(r)):
        if(r[c]==""W"" and f==0):
            pass
        elif(r[c]==""B"" and f==0):
            cnt+=1
            f=1
        elif(r[c]==""B"" and f==1):
            cnt+=1
        elif(r[c]==""W"" and f==1):
            f=0
            if(cnt%2==1):
                print(i+1+(cnt//2),c-(cnt//2))
                exit()
    if(cnt%2==1):
        print(i+1+cnt//2,c+1-cnt//2)
        exit()
",O(n ^ 2)
"x, k = [int(v) for v in input().split()]
mod = 10**9 + 7

if x == 0:
    print(0)
else:
    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)
",O(logn)
"class Solution(object):
    def makeGood(self, s):
        stk = []
        for ch in s:
            counter_ch = ch.upper() if ch.islower() else ch.lower()
            if stk and stk[-1] == counter_ch:
                stk.pop()
            else:
                stk.append(ch)
        return """".join(stk)",O(n)
"class Solution3(object):
    def findComplement(self, num):
        bits = '{0:b}'.format(num)
        complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits)
        return int(complement_bits, 2)",O(1)
"t=int(input())
for i in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    if(n<=2):
        print(0)
        continue
    ar=sorted(ar)[::-1]
    ans=0
    for i in range(1,n-1):
        if(ar[0]>i and ar[1]>i):
            ans=i
    print(ans)
",O(nlogn)
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, k = mi()
ans = None
for x in range(1, n + 1):
    if x * (x + 3) == 2 * (k + n):
        ans = n - x
        break
print(ans)",O(n)
"class Solution:
    def isValid(self, s: str) -> bool:
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return s == ''
",O(n ^ 2)
"import math
import collections
import bisect
import heapq
import time
import itertools
import sys

T = int(input())

def interact(rect1, rect2):
    x1, y1, x2, y2 = rect1
    x3, y3, x4, y4 = rect2

    ans = (-1, -1, -1, -1)
    if x2 < x3 or x4 < x1:
        return 0, ans
    if y2 < y3 or y4 < y1:
        return 0, ans

    ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))

    return area(ans), ans

def area(rect):
    return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)

def winrect(rect):
    a = area(rect)
    if a % 2 == 0:
        return a // 2

    x1, y1, x2, y2 = rect
    e1, e2 = x1 % 2 == 0, y1 % 2 == 0
    ow = (e1 and e2) or (not e1 and not e2)
    return a // 2 + 1 if ow else a // 2

ans = []
for ti in range(T):
    N, M = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())

    w = winrect((1, 1, N, M))
    a, b = (x1, y1, x2, y2), (x3, y3, x4, y4)
    s, c = interact(a, b)
    if s == 0:
        w -= winrect(a) + winrect(b)
        w += area(a)
    elif s == area(a):
        w -= winrect(b)
    elif s == area(b):
        w -= winrect(b)
        w += area(a) - area(b) - (winrect(a) - winrect(b))
    else:
        w += area(a) - winrect(a)
        w -= winrect(b)
        w -= area(c) - winrect(c)

    ans.append((w, N*M-w))

print('\n'.join(['{} {}'.format(a, b) for a, b in ans]))",O(1)
"n = int(input())
a = list(map(int, input().split()))
w = sum(a[i] == i + 1 for i in range(n))
print(""Petr"") if w >= n // 1000 else print(""Um_nik"")
",O(nlogn)
"n=input()
if int(n)>0:
	print(n)
elif -9<=int(n)<=0:
	print(0)
else:
	a=(-int(n))//10
	b=((-int(n))//100)*10+int(n[-1])
	print(max(-a,-b))",O(1)
"n = int(input())
x, y = list(map(int, input().strip().split()))

if n-x + n-y >= x-1 + y-1:
	print(""White"")
else:
	print(""Black"")",O(1)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)
",O(1)
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	(n, k, count) = total_count(n, k)
	if n:
		print(count+2)
	else:
		print(count+1)",O(logn)
"class Solution2(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            curr = 0
            for j in reversed(range(i+1)):
                curr += int(s[j])<<(i-j)
                if s[j] == '1' and max_pow_5%curr == 0:
                    dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1",O(n ^ 2)
"import collections


class Solution(object):
    def shortestCompletingWord(self, licensePlate, words):
        def contains(counter1, w2):
            c2 = collections.Counter(w2.lower())
            c2.subtract(counter1)
            return all([x >= 0 for x in list(c2.values())])

        result = None
        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())
        for word in words:
            if (result is None or (len(word) < len(result))) and \
               contains(counter, word):
                result = word
        return result",O(n)
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod = 10 ** 9 + 7

R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],
                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],
                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            elif i>0 and j>0:
                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]
            elif i>0 and k>0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]
                ans = max(ans, dp[i][j][k])
            elif j>0 and k>0:
                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]
            ans=max(ans,dp[i][j][k])

print(ans)
",O(n ^ 3)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

s=S()
ans = s.replace('1','')+'2'
t =  ans.find('2')

print(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n)
"n, t = map(int, input().split())
arr = []
for i in range(n):
    a, b = map(int, input().split())
    arr.append((a-(b / 2), a+ (b / 2)))

arr.sort()
ans = 0
for i in range(1, n):
    if abs(arr[i][0] - arr[i - 1][1]) == t:
        ans += 1
    elif abs(arr[i][0] - arr[i - 1][1]) > t:
        ans += 2
print(ans + 2)",O(nlogn)
"class Solution(object):
    def countSubTrees(self, n, edges, labels):
        def iter_dfs(labels, adj, node, parent, result):
            stk = [(1, (node, parent, [0]*26))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, ret = params
                    stk.append((4, (node, ret)))
                    stk.append((2, (node, parent, reversed(adj[node]), ret)))
                elif step == 2:
                    node, parent, it, ret = params
                    child = next(it, None)
                    if not child or child == parent:
                        continue
                    ret2 = [0]*26
                    stk.append((2, (node, parent, it, ret)))
                    stk.append((3, (ret2, ret)))
                    stk.append((1, (child, node, ret2)))
                elif step == 3:
                    ret2, ret = params
                    for k in range(len(ret2)):
                        ret[k] += ret2[k]
                else:
                    node, ret = params
                    ret[ord(labels[node]) - ord('a')] += 1
                    result[node] += ret[ord(labels[node]) - ord('a')]
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        iter_dfs(labels, adj, 0, -1, result)
        return result",O(n)
"tt=int(input())
for _ in range(tt):
    s=input()
    t=input()
    flag='NO'
    j=0
    ptr=0
    while(j<len(s) and ptr<len(t)):
        if(s[j]==t[ptr]):
            ptr+=1
            j+=1
        else:
            j+=1
    if(ptr==len(t)):
        flag='YES'
    else:
        pos=[0]*26
        for i in range(len(s)):
            pos[ord(s[i])-97]+=1
        for i in range(0,len(t)):
            h=[]
            for j in range(0,len(pos)):
                h.append(pos[j])
            j=0
            ptr=0
            temp1=0
            while(ptr<=i and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==i+1):
                temp1=1

            j=0
            ptr=i+1
            temp2=0
            while(ptr<len(t) and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==len(t)):
                temp2=1

            if(temp1==1 and temp2==1):
                flag='YES'
                break
    if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')):
        flag='NO'
    print(flag)
",O(n ^ 3)
"a=[[],[],[]]

s=input().split("" "")

for i in range(len(s)):
	if(s[i][1]=='m'):
		a[0].append(int(s[i][0]))
	elif(s[i][1]=='p'):
		a[1].append(int(s[i][0]))
	else:
		a[2].append(int(s[i][0]))

ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

ans=ko
ko=10

for i in range(len(a)):
	a[i]=sorted(a[i])
	c=0

	for j in range(1,len(a[i])):
		if(a[i][j]==a[i][j-1]+1):
			c+=1
	if(c==1):
		ko=min(ko,1)
	elif(c==2):
		ko=min(ko,0)
	elif(len(a[i])>1 and (a[i][0]+2==a[i][1])):
		ko=min(ko,1)
	elif(len(a[i])>2 and (a[i][1]+2==a[i][2])):
		ko=min(ko,1)
	else:
		if(len(a[i])>0):
			ko=min(ko,2)

print(min(ans,ko))
",O(nlogn)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False
",O(nlogn)
"n, a, b, c, T = map(int, input().split())
ts = list(map(int, input().split()))
ts.sort()
ans = 0
for t in ts:
    temp = -10**18
    for u in range(t, T+1):
        temp = max(temp, c*(u-t)+a-b*(u-t))

    ans += temp
print(ans)
",O(n)
"n = int(input())
arr = list(map(int, input().split()))
res = float('inf')
for i in range(1, n):
    res = min(res, min(arr[i], arr[0]) // i)
for i in range(n - 1):
    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))
print(res)
",O(n)
"class Solution(object):
    def getWinner(self, arr, k):
        result = arr[0]
        count = 0
        for i in range(1, len(arr)):
            if arr[i] > result:
                result = arr[i]
                count = 0
            count += 1
            if (count == k):
                break
        return result",O(n)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=arr.copy()
    ans.sort(reverse=True)
    ans=ans[:k]
    c=k
    print(sum(ans))
    j = 0
    for i in range(n):
        if (arr[i] in ans and c != 1):
            print(i + 1 - j, end=' ')
            j = i + 1
            ans.remove(arr[i])
            c -= 1
        if (c == 1):
            print(n - j)
            break",O(nlogn)
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))",O(n ^ 2)
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break
",np
"import collections


class Solution(object):

    def __init__(self, v1, v2):
        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def __next__(self):
        len, iter = self.q.popleft()
        if len > 1:
            self.q.append((len-1, iter))
        return next(iter)

    def hasNext(self):
        return bool(self.q)",O(1)
"import sys
input=sys.stdin.readline

def count_bits(x):
    cnt=0
    for i in range(n):
        if((1<<i)&x):
            cnt+=1
    return(cnt)

n=int(input())
a=[list(map(float,input().split())) for i in range(n)]
dp=[0 for i in range(1<<n)]
dp[-1]=1

for mask in range((1<<n)-1,-1,-1):
    val=count_bits(mask)
    total=val*(val-1)//2
    for i in range(n):
        if(mask&(1<<i)==0):
            continue
        for j in range(n):
            if(mask&(1<<j)==0 or i==j):
                continue
            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total
for i in range(n):
    print(dp[1<<i])
",np
"import bisect


class Solution(object):
    def minAbsoluteSumDiff(self, nums1, nums2):
        MOD = 10**9+7

        sorted_nums1 = sorted(nums1)
        result = max_change = 0
        for i in range(len(nums2)):
            diff = abs(nums1[i]-nums2[i])
            result = (result+diff)%MOD
            if diff < max_change:
                continue
            j = bisect.bisect_left(sorted_nums1, nums2[i])
            if j != len(sorted_nums1):
                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))
            if j != 0:
                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))
        return (result-max_change)%MOD",O(nlogn)
"for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    dp = [[0] * (1<<N) for _ in range(M+1)]
    for j in range(M):
        for mask in range(1<<N):
            maskpre = mask
            while maskpre >= 0:
                maskpre &= mask
                ma = 0
                for k in range(N):
                    s = 0
                    for i in range(N):
                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:
                            s += X[i-k][j]
                    ma = max(ma, s)
                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)

                maskpre -= 1
    print(dp[-1][-1])
",np
"import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

def bisearch_max(mn, mx, func):

    ok = mn
    ng = mx
    while ok+1 < ng:
        mid = (ok+ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok

def check(m):
    ok = [0] * N
    S = set()
    for i in range(N):
        for j in range(M):
            if A[i][j] >= m:
                ok[i] |= 1<<j
        S.add(ok[i])
    full = (1<<M) - 1
    for bit1 in range(1<<M):
        for bit2 in range(bit1, 1<<M):
            if bit1 in S and bit2 in S:
                if bit1 | bit2 == full:
                    return True
    return False

N, M = MAP()
A = [None] * N
for i in range(N):
    A[i] = LIST()

res = bisearch_max(0, 10**9+1, check)
ok = [0] * N
S = set()
D = {}
for i in range(N):
    for j in range(M):
        if A[i][j] >= res:
            ok[i] |= 1<<j
    S.add(ok[i])
    D[ok[i]] = i + 1
full = (1<<M) - 1
for bit1 in range(1<<M):
    for bit2 in range(bit1, 1<<M):
        if bit1 in S and bit2 in S:
            if bit1 | bit2 == full:
                print(D[bit1], D[bit2])
                exit()
",np
"class Solution2(object):
    def findTheWinner(self, n, k):
        def f(idx, n, k):
            if n == 1:
                return 0
            return (k+f((idx+k)%n, n-1, k))%n
        
        return f(0, n, k)+1",O(n)
"class Solution2(object):
    def uniqueXorTriplets(self, nums):
        cnt2, cnt3 = set([0]), set(),  
        max_cnt = 1<<max(nums).bit_length()
        for x in nums:
            for y in cnt2:
                cnt3.add(x^y)
            for y in nums:
                cnt2.add(x^y)
            if len(cnt3) == max_cnt:
                break
        return len(cnt3)",O(n ^ 2)
"import itertools



class Solution3(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]) and len(dp[j]) > len(dp[i]):
                    dp[i] = dp[j]
            dp[i] = dp[i]+[i]
        return [words[x] for x in max(dp, key=lambda x: len(x))]",O(n ^ 2)
"

class Solution(object):
    def createBinaryTree(self, descriptions):
        nodes = {}
        children = set()
        for p, c, l in descriptions:
            parent = nodes.setdefault(p, TreeNode(p))
            child = nodes.setdefault(c, TreeNode(c))
            if l:
                parent.left = child
            else:
                parent.right = child
            children.add(c)
        return nodes[next(p for p in nodes.keys() if p not in children)]
",O(n)
"class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort()
        prefix = sum(nums)
        for i in reversed(range(2, len(nums))):
            prefix -= nums[i]
            if prefix > nums[i]:
                return prefix+nums[i]
        return -1",O(nlogn)
"class Solution(object):
    def numberOfWeeks(self, milestones):
        total, max_num = sum(milestones), max(milestones)
        other_total = (total-max_num)
        return other_total+min(other_total+1, max_num)",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):
        if not root:
            return None
        if not root.left and not root.right:
            return None if root.val < limit else root
        root.left = self.sufficientSubset(root.left, limit-root.val)
        root.right = self.sufficientSubset(root.right, limit-root.val)
        if not root.left and not root.right:
            return None
        return root
",O(n)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def ok(a,b,c):

    n = a[0][-1]
    ans = []
    for i in range(a[0][0]): ans.append([a[1]]*n)

    l = n
    r = n - a[0][0]

    for i in range(2):
        for j in range(2):

            l1,r1 = b[0]
            l2,r2 = c[0]

            if(i): l1,r1 = r1,l1
            if(j): l2,r2 = r2,l2

            if(l1 == l):
                if(l2 != l or r1 + r2 != r): continue

                for k in range(r1): ans.append([b[1]]*n)
                for k in range(r2): ans.append([c[1]]*n)
                return ans

            if(l1 == r):
                if(l2 != r or r1 + r2 != l): continue

                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)
                return ans

    return False

l1,r1,l2,r2,l3,r3 = value()

a = [sorted((l1,r1)),'A']
b = [sorted((l2,r2)),'B']
c = [sorted((l3,r3)),'C']

A = ok(a,b,c)
B = ok(b,a,c)
C = ok(c,a,b)

if(A):
    print(len(A))
    for i in A: print(*i,sep="""")
elif(B):
    print(len(B))
    for i in B: print(*i,sep="""")
elif(C):
    print(len(C))
    for i in C: print(*i,sep="""")
else:
    print(-1)
",np
"

class Solution(object):
    def insertGreatestCommonDivisors(self, head):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        curr = head
        while curr.__next__:
            curr.next = ListNode(gcd(curr.val, curr.next.val), curr.next)
            curr = curr.next.__next__
        return head
",O(n)
"import itertools



class Solution2(object):
    def minOperations(self, nums1, nums2):
        INF = float(""inf"")
        def count(mx1, mx2):
            return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in zip(nums1, nums2) if not (x <= mx1 and y <= mx2))

        result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1]))
        return result if result != INF else -1",O(n)
"n, s = map(int, input().split())
if s % n == 0:
    print(s // n)
else:
    print(s // n + 1)
",O(1)
"m, n = map(int, input().split())
a = [int(input()) for q in range(m)]
a.append(10**9)
s = []
for q in range(n):
    f, g, d = map(int, input().split())
    if f == 1:
        s.append(g)
a.sort()
s.sort()
q1 = 0
min1 = float('inf')
for q2 in range(len(a)):
    while q1 < len(s) and a[q2] > s[q1]:
        q1 += 1
    if min1 > q2+len(s)-q1:
        min1 = q2+len(s)-q1
    if q1 == len(s):
        break
print(min1)
",O(nlogn)
"from sys import stdin

def iinput(): return int(stdin.readline())
def minput(): return map(int, stdin.readline().split())
def linput(): return list(map(int, stdin.readline().split()))

n, k = minput()
l, r = 0, n
while l<r:
    mid = (l+r)//2
    if ((n-mid)*(n-mid+1))//2 - mid == k:
        print(mid)
        break
    elif ((n-mid)*(n-mid+1))//2 - mid > k:
        l = mid
    else:
        r = mid
",O(logn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j] = 0

for k1 in range(1, k // 2 + 1):
    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],
                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])

    mem = mem0

[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"n,k =  map(int,input().split())

def tonny(i) :
	return (ord(i)-96)
a= sorted(input())
a=list(map(tonny,a))
a=sorted(list(set(a)))
ans=[a.pop(0)]
k-=1
for j in a :
	if j-ans[-1] >1 and k>0 :
		k-=1
		ans.append(j)
	if k==0 :
		break
if k!=0 :
	print(-1)
else:
	print(sum(ans))
",O(n)
"tmp = input().split()
n = int(tmp[0])
m = int(tmp[1])

a = list()
b = list()
diff = list()
for i in range(n):
    tmp = input().split()
    a.append(int(tmp[0]))
    b.append(int(tmp[1]))
    diff.append(a[i] - b[i])

diff.sort(reverse=True)

sum_a = sum(a)
i = 0
while sum_a > m and i < n:
    sum_a = sum_a - diff[i]
    i = i + 1

if i >= n and sum_a > m:
    print(-1)
else:
    print(i)",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def longestZigZag(self, root):
        def dfs(node, result):
            if not node:
                return [-1, -1]
            left, right = dfs(node.left, result), dfs(node.right, result)
            result[0] = max(result[0], left[1]+1, right[0]+1)
            return [left[1]+1, right[0]+1]

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"from collections import defaultdict as dd, deque
import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,q = map(int,input().split())
S = [int(x) for x in input().split()]
Q = deque(S)

n = len(Q)
res = []
for i in range(n):
    a = Q.popleft()
    b = Q.popleft()
    Q.appendleft(max(a,b))
    Q.append(min(a,b))
    res.append((a,b))

A = list(Q)

def solve(t):
    if t < len(res):
        return res[t-1]
    t -= len(res) + 1
    t %= n-1
    return A[0],A[t+1]

for _ in range(q):
    t = int(input())
    print(*solve(t))
",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            print('even')
        else:
            print('odd')

main()",O(n ^ 2)
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])
",O(logn)
"class Solution(object):
    def countSpecialNumbers(self, n):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(n+1)))
        result = sum(P(9, 1)*P(9, i-1) for i in range(1, len(digits)))
        lookup = set()
        for i, x in enumerate(digits):
            for y in range(int(i == 0), x):
                if y in lookup:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in lookup:
                break
            lookup.add(x)
        return result",O(logn)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k = tup()
s , i = S() , 1
while s[i:] != s[:-i] :i+=1
print(s[:i]*k + s[i:])

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    cost = n
    ind = 0
    while ind < len(table):
        cost = min(cost, n - ind - 1 + table[ind])
        ind += 1

    return cost

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"class Solution(object):
    def minCostToEqualizeArray(self, nums, cost1, cost2):
        MOD = 10**9+7

        n = len(nums)
        mx = max(nums)
        total = mx*n-sum(nums)

        if n <= 2 or cost1*2 <= cost2:
            return total*cost1%MOD
    
        result = float(""inf"")
        mn = min(nums)
        cnt1 = max((mx-mn)-(total-(mx-mn)), 0)
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + cnt2//2*cost2)

        x, cnt1 = divmod(cnt1, (n-2))
        total += n*x
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + (cnt2//2)*cost2)

        for _ in range(2): 
            total += n
            result = min(result, total%2*cost1 + total//2*cost2)
        return result%MOD",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumPairRemoval(self, nums):
        def add(i):
            if 0 <= i < right[i] < len(nums):
                sl.add([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] += 1

        def remove(i):
            if 0 <= i < right[i] < len(nums):
                sl.remove([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] -= 1

        left = list(range(-1, (len(nums)+1)-1))
        right = list(range(1, len(nums)+1))
        cnt = [sum(nums[i] > nums[i+1] for i in range(len(nums)-1))]
        sl = SortedList([nums[i]+nums[i+1], i] for i in range(len(nums)-1))
        result = 0
        while cnt[0]:
            _, i = sl[0]
            remove(left[i])
            remove(i)
            remove(right[i])
            nums[i] += nums[right[i]]
            left[right[right[i]]] = i
            right[i] = right[right[i]]
            add(left[i])
            add(i)
            result += 1
        return result",O(nlogn)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",O(n ^ 3)
"from sys import stdin,stdout
def main():
	n,k=map(int,stdin.readline().split( ))
	s=stdin.readline()
	start=-1
	i=0;j=1;prev=1
	while i<n-1:
		while j<n:
			if s[i]==s[j]:
				if start==-1:
					start=j
					prev=j
				i+=1
				j+=1
			else:
				i=0
				j=prev+1
				prev=j
				start=-1
		break
	if start==-1:
		stdout.write(""%s\n""%(s[:n]*k))
	else:
		j = n - start
		stdout.write(""%s\n""%(s[:n]+s[j:n]*(k-1)))
main()
",O(n ^ 2)
"mod = 10**9 + 7
x, k = list(map(int, input().split()))
if x == 0:
    print(0)
    exit()
ans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod
print(ans)
",O(logn)
"N = int(input())
s1 = [list(input()) for i in range(N)]
s2 = [list(input()) for i in range(N)]

def rotate(s):
    ret = [[None for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            ret[i][j] = s[j][N-1-i]
    return ret

def v_mirror(s):
    return list(reversed(s))

def h_mirror(s):
    return [list(reversed(row)) for row in s]

def solve():
    global s1
    for i in range(4):
        if s1 == s2: return True
        if v_mirror(s1) == s2: return True
        if h_mirror(s1) == s2: return True
        if v_mirror(h_mirror(s1)) == s2: return True
        s1 = rotate(s1)
    return False

print('Yes' if solve() else 'No')
",O(n ^ 2)
"import sys
input = sys.stdin.readline

t=int(input())
for testcases in range(t):
    n,m=map(int,input().split())
    A=[list(map(int,input().split())) for i in range(n)]

    B=[]
    for j in range(m):
        B.append([A[i][j] for i in range(n)])

    B.sort(key=lambda x:max(x),reverse=True)

    B=B[:n]

    LEN=len(B)

    if LEN==1:
        print(sum(B[0]))

    elif LEN==2:
        ANS=0
        for i in range(n):
            A=0
            for k in range(n):
                A+=max(B[0][k],B[1][(i+k)%n])

            ANS=max(ANS,A)

        print(ANS)

    elif LEN==3:

        ANS=0
        for i in range(n):
            for j in range(n):

                A=0
                for k in range(n):
                    A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n])

                ANS=max(ANS,A)

        print(ANS)

    elif LEN==4:

        ANS=0
        for i in range(n):
            for j in range(n):
                for l in range(n):

                    A=0
                    for k in range(n):
                        A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n])

                    ANS=max(ANS,A)

        print(ANS)
",np
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '*' or s[i] == '/':
                operators.append(s[i])
            elif s[i] == '+' or s[i] == '-':
                while operators and \
                      (operators[-1] == '*' or operators[-1] == '/'):
                    self.compute(operands, operators)
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)
        elif op == '*':
            operands.append(left * right)
        elif op == '/':
            operands.append(left / right)",O(n)
"import sys

def sol(a,b):
	for square in [a,b]:
		for i1 in range(4):
			i2 = (i1 + 1)%4
			p1,p2 = square[i1],square[i2]

			norm = (p2[1]-p1[1],p1[0]-p2[0])

			minA = maxA = minB = maxB = None
			for p in a:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minA == None or proj < minA:
					minA = proj
				if maxA == None or proj > maxA:
					maxA = proj
			for p in b:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minB == None or proj < minB:
					minB = proj
				if maxB == None or proj > maxB:
					maxB = proj

			if maxA < minB or maxB < minA:
				return False
	return True

x11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))
x21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))

a = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]
b = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]

print([""NO"",""YES""][sol(a,b)])",O(1)
"class Solution(object):
    def modifiedList(self, nums, head):
        lookup = set(nums)
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if curr.next.val not in lookup:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__",O(n)
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1

    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])
",O(1)
"o=int(input())
uk=[]
gh=0
uo=0
for i in range(o):
    yu=input()
    if(len(yu)>gh):
        gh=len(yu)
        uo=i
    uk.append(yu)

yk=0
yj={}

td=0
uk.sort()
for i in range(len(uk)-1):
    for j in range(i+1,len(uk)):
        if(len(uk[j])<len(uk[i])):
            t=uk[j]
            uk[j]=uk[i]
            uk[i]=t
for i in range(1,len(uk)):
    j=i
    while(j>=0):
        if(uk[i].count(uk[j])==0):
            td=1
        j=j-1
if(td==0):
    print('YES')
    for i in uk:
        print(i)
else:
    print('NO')
",O(nlogn)
"M = 10**9+7
x,k=[int(i) for i in input().split()]
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%M)
else:
    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1
    print(top_sum%M)
",O(logn)
"import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:[*map(int,Z().split())]
n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]
if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit()
d=[0]*n*m
for _ in range(k//2):
    nd=[0]*n*m
    for x in range(n):
        for y in range(m):
            v=x*m+y;w=[]
            if x:w.append(d[v-m]+V[x-1][y])
            if y:w.append(d[v-1]+H[x][y-1])
            if x<n-1:w.append(d[v+m]+V[x][y])
            if y<m-1:w.append(d[v+1]+H[x][y])
            nd[v]=min(w)
    d=nd
print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",O(n ^ 3)
"k=int(input())
x=0
c=0
while(x<k):
    x+=9*(10**c)*(c+1)
    c+=1
p=(x-k)%c
k=((10**c)-int(((x-k)/c))-1)
k=str(k)
print(k[len(k)-(p)-1])",O(1)
"def onseg(p,q,r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \
           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p,q,r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - \
          (q[0] - p[0]) * (r[1] - q[1])

    if (val == 0): return 0
    return 1 if val > 0 else 2

def doint(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and onseg(p1, p2, q1): return True
    if o2 == 0 and onseg(p1, q2, q1): return True
    if o3 == 0 and onseg(p2, p1, q2): return True
    if o4 == 0 and onseg(p2, q1, q2): return True

    return False

x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())
x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())

A = x0,y0
B = x1,y1
C = x2,y2
D = x3,y3
a = x4,y4
b = x5,y5
c = x6,y6
d = x7,y7

if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \
   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \
   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \
   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \
   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \
   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):
    print('YES')
else:
    print('NO')
",O(1)
"class Solution(object):
    def circularGameLosers(self, n, k):
        lookup = [False]*n
        idx = 0
        for i in range(n):
            if lookup[idx]:
                break
            lookup[idx] = True
            idx = (idx+(i+1)*k)%n
        return [i+1 for i in range(n) if not lookup[i]]",O(n)
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            p=0
            for i in range(len(h)):
                if h[p]>h[i]:
                    p=i
            sm-=h.pop(p)
        ans[ind]=sm
        h+=[cns]
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",O(nlogn)
"d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
for _ in[0]*int(input()):d.pop(input())
print(len(d),*d.values(),sep='\n')",O(1)
"for _ in range(int(input())):
    a,b = map(int, input().split())
    c = 0
    while (a!=0 and b!=0):
        if (a>b) :
            c+= a//b
            a = a%b
        elif (b>a):
            c+= b//a
            b = b%a
        else :
            c+=1
            break
    print(c)",O(1)
"class Solution(object):
    def findMinimumTime(self, strength):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        K = 1
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"import sys
import math
input = sys.stdin.readline
for _ in range(1):
    n,pos,l,r = map(int,input().split())
    if l == 1 and r == n:
        print(0)
        continue

    if l != 1 and r != n:
        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)

    else:
        if l == 1:
            ans = abs(pos-r)+1

        else:
            ans = abs(pos-l)+1

    print(ans)",O(1)
"import collections



class Solution(object):
    def maximumTotalDamage(self, power):
        DIST = 2
        power.sort()
        dp = collections.deque()
        mx = 0
        for x in power:
            if dp and dp[-1][0] == x:
                dp[-1][1] += x
                continue
            while dp and dp[0][0]+DIST < x:
                mx = max(mx, dp.popleft()[1])
            dp.append([x, mx+x])
        return max(x for _, x in dp)",O(nlogn)
"from math import gcd
import sys

def input():
    return sys.stdin.readline().rstrip()

DXY = [(0, -1), (1, 0), (0, 1), (-1, 0)]

def on_one_line(Points):
    n = len(Points)
    s = set([])
    for i in range(1,n):
        x,y = Points[i][0] - Points[0][0],Points[i][1] - Points[0][1]
        g = gcd(x,y)
        x //= g
        y //= g
        if (x < 0):
            x *= -1;y *= -1
        if (x == 0):
            y = abs(y)
        s.add((x,y))
    return len(s) == 1

def main():
    n = int(input())
    Ps = [tuple(map(int, input().split())) for i in range(n)]
    if n <= 2:
        print(""YES"")
        return 0
    if on_one_line(Ps):
        print(""YES"")
        return 0

    p,q = Ps[1][0] - Ps[0][0],Ps[1][1] - Ps[0][1]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)

    not_same = []
    for i in range(2,n):
        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    p,q = not_same[0][0] - Ps[0][0],not_same[0][1] - Ps[0][1]
    P,Q = not_same[0]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)
    not_same = []

    for i in range(n):
        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]
        if (x == 0 and y == 0):continue
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    p,q = P - Ps[1][0],Q - Ps[1][1]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)

    not_same = []
    for i in range(n):
        x,y = Ps[i][0] - Ps[1][0],Ps[i][1] - Ps[1][1]
        if (x == 0 and y == 0):continue
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    print(""NO"")
    return 0

if __name__ == ""__main__"":
    main()
",O(nlogn)
"n,k = map(int,input().split())
s = input()
a = (n-k)//2
s1 = s.replace('(','',a)
s2 = s1.replace(')','',a)
print(s2)",O(n)
"class Solution(object):
    def validateStackSequences(self, pushed, popped):
        i = 0
        s = []
        for v in pushed:
            s.append(v)
            while s and i < len(popped) and s[-1] == popped[i]:
                s.pop()
                i += 1
        return i == len(popped)",O(n)
"(x, y, z, t1, t2, t3) = map(int, input().split())

if 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import math

q = int(input())

for i in range(q):
    x, y, k = map(int, input().split())
    if x > k or y > k:
        print(-1)
    else:
        if (x+y)%2 == 0:
            if (k-max(x,y)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            if (k-max(x,y)) % 2 == 0:
                print(k-1)
            else:
                print(k-1)",O(1)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",O(n ^ 3)
"class Solution(object):
    def shuffle(self, nums, n):
        def index(i):
            return 2*i if i < n else 2*(i-n)+1
    
        for i in range(len(nums)):
            j = i
            while nums[i] >= 0:
                j = index(j)
                nums[i], nums[j] = nums[j], ~nums[i] 
        for i in range(len(nums)):
            nums[i] = ~nums[i]
        return nums",O(n)
"def main():
    c,r,o,e=0,0,[0]*300000,[0]*300000
    for _ in range(int(input())):
        s=input()
        l,n=0,0
        for i in s:
            if i=='(':
                l+=1
            else:
                if l!=0:
                    l-=1
                else:
                    n+=1
        if l==0 and n==0:
            c+=1
        elif l!=0 and n!=0:
            pass
        elif l!=0:
            o[l]+=1
        else:
            e[n]+=1
    for i in range(300000):
        if e[i] and o[i]:
            r+=e[i]*o[i]
    print(pow(c,2)+r)
if __name__=='__main__':
    main()",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass

n=L()[0]
if n<6:
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(5,n+1):
        print(2,i)
for i in range(1,n):
    print(i,i+1)

endtime = time.time()
",O(n)
"import collections
import itertools



class Solution2(object):
    def maxArea(self, height, positions, directions):
        diff = collections.defaultdict(int)
        for d, i in zip(directions, positions):
            if d == 'U':
                diff[height-i] -= 1
                diff[(height-i)+height] += 1
            else:
                diff[i] += 1
                diff[i+height] -= 1
        result = total = sum(positions)
        cnt = directions.count('U')
        prev = 0
        for t, d in sorted(diff.items()):
            total += (t-prev)*(-(len(directions)-cnt)+cnt)
            result = max(result, total)
            cnt += d
            prev = t
        return result",O(nlogn)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(g, e)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=99999999999999999999999999999999

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n=ri()
        s=ria()
        c=ria()
        ans=INF
        for i in range(n):
            mid=s[i]
            mcl=INF
            mrl=INF
            for j in range(i-1,-1,-1):
                if s[j]<mid:
                    mcl=min(mcl,c[j])
            for j in range(i+1,n):
                if s[j]>mid:
                    mrl=min(mrl,c[j])
            ans=min(ans,c[i]+mcl+mrl)
        if ans==INF:
            wi(-1)
        else:
            wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n ^ 2)
"class Solution2(object):
    def inorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root, True))
                stack.append((root.left, False))
        return result",O(n)
"class Solution(object):

    def __init__(self, n):
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i < len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result",O(1)
"class Solution2(object):
    def maximizeGreatness(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] > nums[left]:
                left += 1
        return left",O(n)
"class MinStack:
    def __init__(self):
        self.min = float('inf')
        self.stack = []

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self) -> None:
        if not self.stack:
            return

        pop = self.stack.pop()

        if pop < 0:
            self.min = self.min - pop

    def top(self) -> int:
        top = self.stack[-1]
        if top > 0:
            return top + self.min
        else:
            return self.min

    def getMin(self) -> int:
        return self.min
",O(1)
"print('?', 0, 0, flush=True)
t = int(input())
s = [0]*31
if t == 1:
    s[30] = 1
else:
    s[30] = -1

a = 0
b = 0
for i in range(30, 0, -1):
    c = (1 << (i-1)) + a
    d = b
    print('?', c, d, flush=True)
    ans1 = int(input())
    c = a
    d = (1 << (i-1)) + b
    print('?', c, d, flush=True)
    ans2 = int(input())
    if ans1 == -1 and ans2 == 1:
        a += 1 << (i-1)
        b += 1 << (i-1)
        s[i-1] = s[i]
    elif ans1 == 1 and ans2 == -1:
        a += 0 << (i-1)
        b += 0 << (i-1)
        s[i-1] = s[i]
    else:
        s[i-1] = ans1
        if s[i] == 1:
            a += 1 << (i-1)
            b += 0 << (i-1)
        else:
            a += 0 << (i-1)
            b += 1 << (i-1)
print('!', a, b)
",O(logn)
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')
",O(n ^ 2)
"import math
a, b = map(int, input().split())
if a % b == 0:
    print(int(a/b))
else:
    c = 0
    while b:
        c += a//b
        temp = a
        a = b
        b = temp % b
    print(c)
",O(1)
"import sys
input = lambda: sys.stdin.readline().strip()

nxt = {'R':'G', 'G':'B', 'B':'R'}

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    s = input()
    res = []
    for start in ['R', 'G', 'B']:
        mis = []
        cur = start
        for j in range(k):
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
        res.append(sum(mis))
        for j in range(k, n):
            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
    print(min(res))
",O(n)
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = SortedList(nums[i] for i in range(1, len(nums)))
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            right.remove(nums[i])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[-1] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[-1])
        return result",O(nlogn)
"class Solution(object):
    def movesToMakeZigzag(self, nums):
        result = [0, 0]
        for i in range(len(nums)):
            left = nums[i-1] if i-1 >= 0 else float(""inf"")
            right = nums[i+1] if i+1 < len(nums) else float(""inf"")
            result[i%2] += max(nums[i] - min(left, right) + 1, 0)
        return min(result)",O(n)
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)
",O(n)
"class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & (n - 1)) == 0",O(1)
"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        points.sort(key=lambda p: p[0]**2 + p[1]**2)
        return points[:k]
",O(nlogn)
"n=int(input())
a=[]
for i in range(n+1):
    a.append(((n+1)-i)*i)
print(max(a))",O(n)
"class Solution(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""""]
        right = float(""inf"")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left > right:
                result.append("""")
            right = new_right
            result[-1] = s[left:right+1]
        return result",O(n)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            arr.append(node.val)
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        arr.sort()
        return arr[k - 1]
",O(nlogn)
"class Solution(object):
    def numberOfArrays(self, differences, lower, upper):
        total = mn = mx = 0
        for x in differences:
            total += x
            mn = min(mn, total)
            mx = max(mx, total)
        return max((upper-lower)-(mx-mn)+1, 0)",O(n)
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n, m = read_int_array()
    bmin = read_int_array()
    gmax = read_int_array()

    bmin.sort()
    gmax.sort()

    max_boy = bmin[-1]
    min_girl = gmax[0]
    if max_boy > min_girl:
        write(-1)
    elif max_boy == min_girl:
        bmin.pop()
        out = sum(gmax) + sum(x * m for x in bmin)
        write(out)
    else:
        bmin.pop()
        out = sum(gmax) - min_girl + max_boy
        out += min_girl + bmin[-1] * (m-1)
        bmin.pop()
        out += sum(x * m for x in bmin)
        write(out)

main()
",O(nlogn)
"n,k=list(map(int,input().split()))
a=list(map(int,input().split()))
b=[]
for i in range(11):
    c={}
    for j in range(n):
        d=(a[j]*(10**i))%k
        if d in c.keys():
            c[d]+=1
        else:
            c[d]=1
    b.append(c)

s=0
for i in range(n):
    c=a[i]%k
    d=(k-c)%k
    if d in b[len(str(a[i]))]:
        s+=b[len(str(a[i]))][d]
    if (a[i]*(10**len(str(a[i]))))%k==d:
        s-=1
print(s)",O(nlogn)
"import sys

input = sys.stdin.readline

def main():

	a = input().split("" "")
	n = int(a[0])
	d = int(a[1])
	k = int(a[2])

	if d > n - 1:
		sys.stdout.write(""NO\n"")
		return

	par = [-1 for i in range(n)]
	prevlevel = [0]
	bad = [False for i in range(n)]
	clevel = []
	cdep = 1
	callow = k
	cnode = 1
	firstchild = 1

	for i in range(1, n):

		if len(clevel) == callow:
			prevlevel = clevel
			clevel = []
			cdep += 1
			callow *= (k - 1)
			firstchild *= (k - 1)

		cdiv = k
		if cdep > 1:
			cdiv -= 1
		if cdiv == 0:
			sys.stdout.write(""NO\n"")
			return

		par[cnode] = prevlevel[len(clevel) // cdiv]
		clevel.append(cnode)

		cnode += 1

	mdep = d // 2

	if cdep > mdep + 1:
		sys.stdout.write(""NO\n"")
		return

	if cdep == mdep + 1 and ((d % 2 == 0)):
		sys.stdout.write(""NO\n"")
		return

	if cdep == mdep + 1 and len(clevel) > firstchild:
		sys.stdout.write(""NO\n"")
		return

	attach1 = -1
	attach2 = -1

	d1 = cdep
	d2 = cdep

	attach1 = clevel[0]
	if len(clevel) > firstchild:
		attach2 = clevel[-1]
	else:
		attach2 = prevlevel[-1]
		d2 -= 1

	te = attach1
	while te != -1:
		bad[te] = True
		te = par[te]
	te = attach2
	while te != -1:
		bad[te] = True
		te = par[te]

	cptr = n - 1
	while d1 + d2 < d:
		if bad[cptr]:
			cptr -= 1
			continue

		if d2 < d1:
			par[cptr] = attach2
			attach2 = cptr
			d2 += 1
		else:
			par[cptr] = attach1
			attach1 = cptr
			d1 += 1

		cptr -= 1

	sys.stdout.write(""YES\n"")
	for i in range(1, n):
		sys.stdout.write(str(i + 1) + "" "" + str(par[i] + 1) + ""\n"")

main()",O(n ^ 2)
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        resIdx = 0
        resLen = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                if (r - l + 1) > resLen:
                    resIdx = l
                    resLen = r - l + 1
                l -= 1
                r += 1

        return s[resIdx : resIdx + resLen]
",O(n ^ 2)
"from sys import stdin, exit
from typing import List, Tuple, Dict
from itertools import product

def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):
    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])

def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):
    shorthest_path = float('inf')
    for outbreak in outbreaks:
        if shorthest_path < min_dst:
            break
        shorthest_path = min(shorthest_path, distance(tree, outbreak))
    return shorthest_path

input_f = open('input.txt', 'r')
output_f = open('output.txt', 'w')

N, M = [int(v) for v in input_f.readline().rstrip().split()]
input_f.readline()
outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]
outbreaks = []
input_f.close()

for i in range(0, len(outbreaks_line) - 1, 2):
    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))

last_tree = (1, 1)
best_dst = 0
for x, y in product(range(1, N + 1), range(1, M + 1)):
    path_len = shorthest_path((x, y), outbreaks, best_dst)
    if path_len > best_dst:
        last_tree = (x, y)
        best_dst = path_len

output_f.write(' '.join(map(str, last_tree)))

output_f.close()
",O(n ^ 3)
"n,r=list(map(int,input().split()))
x=list(map(int,input().split()))
y=[r]*n
for i in range(1,n):
    for j in range(i):
        d=abs(x[i]-x[j])
        if d<=2*r:
            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))
print(*y)",O(n ^ 2)
"class Solution(object):
    def makeStringsEqual(self, s, target):
        return ('1' in s) == ('1' in target)",O(n)
"import sys

n, k = map(int, next(sys.stdin).rstrip().split())

xs = list(map(int, next(sys.stdin).rstrip().split()))

mapka = {}
lengths = {}

result = []

for x in xs:

    if x in mapka:
        result.append(mapka[x])
    else:
        left = max(0, x - k + 1)
        range_potential = x - left
        for i in range(range_potential, -1, -1):
            potential_left = x - i
            if potential_left not in mapka:
                result.append(potential_left)
                for y in range(potential_left, x + 1):
                    mapka[y] = potential_left

                lengths[potential_left] = x - potential_left + 1

                break
            else:

                if lengths[mapka[potential_left]] + (x - potential_left) <= k:
                    result.append(mapka[potential_left])
                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):
                        mapka[y] = mapka[potential_left]
                        lengths[mapka[potential_left]] += 1

                    break

print(' '.join(map(str, result)))
",O(n ^ 2)
"import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def treeQueries(self, root, queries):
        def iter_dfs(root):
            top = collections.defaultdict(lambda: [0]*2)
            depth, height = {}, {}
            stk = [(1, (root, 0))]
            while stk:
                step, (curr, d) = stk.pop()
                if step == 1:
                    if not curr:
                        continue
                    stk.append((2, (curr, d)))
                    stk.append((1, (curr.right, d+1)))
                    stk.append((1, (curr.left, d+1)))
                elif step == 2:
                    h = 1+max((height[curr.left.val] if curr.left else 0), 
                              (height[curr.right.val] if curr.right else 0))
                    if h > top[d][0]:
                        top[d][0], top[d][1] = h, top[d][0]
                    elif h > top[d][1]:
                        top[d][1] = h
                    depth[curr.val], height[curr.val] = d, h
            return top, depth, height

        top, depth, height = iter_dfs(root)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"import sys

def inn(a,b):
	return (a[0] <= b[0] and b[1] <= a[1])

n = int(input())

seg = []

a,b = map(int,input().split())
seg.append((a,b,1))

for i in range(2,n+1):
	a,b = map(int,input().split())
	seg.append((a,b,i))

seg.sort(key=lambda x : (x[0],-x[1]))

main = seg.pop(0)

for i in seg:
	if inn(main,i):
		print(i[2],main[2])
		sys.exit(0)
	if main[1] < i[1]:
		main = i

print(-1,-1)",O(nlogn)
"class DoublyLinkedList:
    def __init__(self, val, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        head = DoublyLinkedList(tokens[0])
        curr = head

        for i in range(1, len(tokens)):
            curr.next = DoublyLinkedList(tokens[i], prev=curr)
            curr = curr.next

        while head is not None:
            if head.val in ""+-*/"":
                l = int(head.prev.prev.val)
                r = int(head.prev.val)
                if head.val == '+':
                    res = l + r
                elif head.val == '-':
                    res = l - r
                elif head.val == '*':
                    res = l * r
                else:
                    res = int(l / r)

                head.val = str(res)
                head.prev = head.prev.prev.prev
                if head.prev is not None:
                    head.prev.next = head

            ans = int(head.val)
            head = head.next

        return ans
",O(n)
"class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        return max((l**2+w**2, l*w) for l, w in dimensions)[1]",O(n)
"class Solution(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in reversed(range(len(nums)-1)):
            if nums[i] < nums[i+1]:
                k = i
                break
        else:
            nums.reverse()
            return

        for i in reversed(range(k+1, len(nums))):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",O(n)
"class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):
        curr, max_count = 1, 1
        for i in range(1, len(nums)):
            curr = 1 if nums[i-1] < nums[i] else curr+1
            max_count = max(max_count, curr)
        return K*max_count <= len(nums)",O(n)
"class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        dp = [[-1 for _ in range(len(colors))] for _ in range(3)]
        dp[colors[0]-1][0] = 0
        for i in range(1, len(colors)):
            for color in range(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(range(len(colors)-1)):
            for color in range(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]",O(n)
"x, k = map(int,input().split())
if x==0:
  print(0)
else:
  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)",O(logn)
"from sys import stdin

def solve(tc):
    n, k = map(int, stdin.readline().split())

    if n == 1:
        print(0)
        return

    if n <= k:
        print(1)
        return

    lo, hi = 1, k-1
    while lo < hi:
        mid = lo + (hi-lo+1)//2

        cum = (k-2+mid-1)*(k-mid)//2
        if cum < n-k:
            hi = mid - 1
        else:
            lo = mid

    if lo == 1:
        print(-1)
        return

    print(k-lo+1)

tcs = 1
for tc in range(tcs):
    solve(tc)
",O(logn)
"def solution():

    n = int(input())
    segments = []
    for i,_ in enumerate(range(n)):
        x,y = input().split("" "")
        segments.append((int(x), int(y), i+1))

    segments = sorted(segments, key=lambda x: (x[0], -x[1]))

    for i,seg in enumerate(segments):
        j = i+1
        if j >= n:
            print(""-1 -1"")
            return

        while segments[j][1] <= seg[1]:
            print(""{} {}"".format(segments[j][2], seg[2]))
            return

    print(""-1 -1"")
    return

solution()
",O(nlogn)
"class Solution(object):
    def minStartValue(self, nums):
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix",O(n)
"class Solution2(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        for i in range(len(nums)+1):
            if not cnt[i%value]:
                return i
            cnt[i%value] -= 1",O(n)
"
class Solution(object):
    def minPartitions(self, n):
        return int(max(n))
",O(n)
"from math import factorial

def C(k, n):
    return factorial(n) // factorial(k) // factorial(n - k)

s1 = input()
s2 = input()
n1 = s1.count('+')
n2 = s2.count('+')
n3 = s2.count('?')
if n2 > n1:
    print(0)
else:
    try:
        print(C(n1 - n2, n3) / (2 ** n3))
    except:
        print(0)
",np
"n = int(input())
a = list(map(int, input().split()))
a = sorted(a, reverse=True)
s1 = 0
s2 = sum(a)

for i in range(len(a)):
    s1 += a[i]
    s2 -= a[i]
    if s1 > s2:
        break

print(i + 1)",O(nlogn)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
mod2 = 998244353
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)
def pe(s): return print(str(s), file=sys.stderr)
def JA(a, sep): return sep.join(map(str, a))
def JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)
def IF(c, t, f): return t if c else f
def YES(c): return IF(c, ""YES"", ""NO"")
def Yes(c): return IF(c, ""Yes"", ""No"")

def main():
    t = 1

    rr = []
    for _ in range(t):
        n,k = LI()

        t = 0
        for i in range(1,10**5):
            t += i
            if t - (n-i) == k:
                rr.append(n-i)
                break

    return JA(rr, ""\n"")

print(main())
",O(logn)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"import math;
def f(n,s):
    d=[-n,-n];
    d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"class Solution(object):
    def runningSum(self, nums):
        for i in range(len(nums)-1):
            nums[i+1] += nums[i]
        return nums",O(n)
"class Solution(object):
    def finalValueAfterOperations(self, operations):
        return sum(1 if '+' == op[1] else -1 for op in operations)",O(n)
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",O(nlogn)
"class Solution(object):
    def canJump(self, A):
        reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                break
            reachable = max(reachable, i + length)
        return reachable >= len(A) - 1",O(n)
"import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1",O(n ^ 2)
"class Solution(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result += left
        return result",O(n)
"from math import ceil

n, k = map(int, input().split())

print(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))
",O(1)
"n, k = map(int , input().split())
s = k // n
if k % n != 0:
    s += 1
print(s)
",O(1)
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M= 998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

n,k = value()
a = array()

ans = 0

for i in range(n-k+1):

    num = sum(a[i:i+k])
    den = k
    ans = max(ans , num/den)

    for j in range(i+k,n):

        num += a[j]
        den += 1
        ans = max(ans , num/den)

print(ans)
",O(n ^ 2)
"import math
import sys

n=int(input())
s=list(map(int,input().split()))
ce=list(map(int,input().split()))

best=10**9
for j in range(1,n-1):
    a=ce[j];b=10**9;c=10**9
    for i in range(j-1,-1,-1):
        if s[i]<s[j]:
            b=min(b,ce[i])
    for k in range(j+1,n):
        if s[k]>s[j]:
            c=min(c,ce[k])
    best=min(best,a+b+c)

if best>=10**9:
    print(-1)
else:
    print(best)",O(n ^ 2)
"class Solution(object):
    def interpret(self, command):
        result, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                result += [""G""]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += [""o""]
                i += 2
            else:
                result += [""al""]
                i += 4
        return """".join(result)",O(n)
"for x in range(int(input())):
	a,b = map(int,input().split())
	if a > b or a == b:c,d = a,b
	else:c,d = b,a
	e = [0]
	def fun(c,d):
		e[0] += c // d
		f = d
		d = c % d
		c = f
		if f > 0 and d > 0:
			fun(c,d)
	fun(c,d)
	print(e[0])",O(1)
"class Solution(object):
    def returnToBoundaryCount(self, nums):
        result = curr = 0
        for x in nums:
            curr += x
            if curr == 0:
                result += 1
        return result",O(n)
"from sys import stdin, stdout

def solve(s1, s2, next):

    dp = [[INF for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    dp[0][0] = 0
    for i in range(len(s1)+1):
        for j in range(len(s2)+1):
            if dp[i][j] == INF:
                continue

            if i < len(s1) and dp[i][j] < len(next) and next[dp[i][j]][ord(s1[i]) - ord('a')] < INF:
                dp[i+1][j] = min(dp[i+1][j], next[dp[i][j]][ord(s1[i]) - ord('a')] + 1)
            if j < len(s2) and dp[i][j] < len(next) and next[dp[i][j]][ord(s2[j]) - ord('a')] < INF:
                dp[i][j+1] = min(dp[i][j+1], next[dp[i][j]][ord(s2[j]) - ord('a')] + 1)

    return dp[len(s1)][len(s2)]

INF = 1e20
T = int(stdin.readline())
for _ in range(T):
    s = stdin.readline().strip()
    rs = stdin.readline().strip()
    next = [[INF for _ in range(26)] for _ in range(len(s))]

    for i in range(len(s)-1, -1, -1):
        if i < len(s)-1:
            for j in range(26):
                next[i][j] = next[i+1][j]
        next[i][ord(s[i]) - ord('a')] = i

    found = False

    if len(rs) == 1:
        if rs in s:
            found = True
    else:
        for p in range(1, len(rs)):
            s1 = rs[:p]
            s2 = rs[p:]

            if solve(s1, s2, next) < INF:
                found = True
                break

    if found:
        stdout.write('YES\n')
    else:
        stdout.write('NO\n')
",O(n ^ 3)
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1

    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:

                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE

check=[0]*(N+1)
check[1]=1

LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

print(ANS)
",O(n)
"import sys
sys.setrecursionlimit(50000)
for _ in range(1):
    n,m,k = map(int,input().split())
    s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        d = [int(x) for x in input().split()]
        for j in range(m-1):
            s[i][j][1] = d[j]
            s[i][j+1][3] = d[j]
    for i in range(n-1):
        d = [int(x) for x in input().split()]
        for j in range(m):
            s[i][j][2] = d[j]
            s[i+1][j][0] = d[j]
    if k%2==1:
        for i in range(n):
            print(*[-1 for _ in range(m)])
        continue
    dp = [[[9999999 for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for q in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                cands = []
                if i > 0:
                    cands.append(dp[i-1][j][q-1] + s[i-1][j][2])
                if j > 0:
                    cands.append(dp[i][j-1][q-1] + s[i][j-1][1])
                if i < n - 1:
                    cands.append(dp[i+1][j][q-1] + s[i+1][j][0])
                if j < m - 1:
                    cands.append(dp[i][j+1][q-1] + s[i][j+1][3])
                dp[i][j][q] = min(cands)
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][k//2],end=' ')
        print()",O(n ^ 3)
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))
",O(n)
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
",O(n ^ 2)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
X = [0 for i in range(n)]
Y = [0 for i in range(n)]
for _ in range(n):
    X[_],Y[_] = mi()

def solve(n,X,Y):
    if n<=3:
        return True

    def check(i,j,k):
        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])

    a,b = -1,-1
    for i in range(n):
        if not check(0,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(2,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(0,2,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    return False

print(""YES"" if solve(n,X,Y) else ""NO"")
",O(nlogn)
"class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def binary_search(self, x):
                if self.tree[1] < x:
                    return -1
                i = 1
                while not i >= self.base:
                    if self.tree[2*i] >= x:
                        i = 2*i
                    else:
                        i = 2*i+1
                return i-self.base

        def build(i):
            return baskets[i]

        st = SegmentTree(len(baskets), build_fn=build)
        result = 0
        for x in fruits:
            i = st.binary_search(x)
            if i == -1:
                result += 1
            else:
                st.update(i, 0)
        return result",O(nlogn)
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, max_i = 0, 0
        for i, v in enumerate(arr):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result",O(n)
"n, m, k = map(int,input().split())
line = [int(x) for x in input().split()]
line.sort(reverse = True)
count = 0
if k >=m:
    print(count)
    exit(0)
for i in range(n):
    k += line[i]-1
    count += 1
    if k >= m:
        print(count)
        exit(0)
print(-1)",O(nlogn)
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            res = num ^ res
        return res
",O(n)
"n = int(input())
p = [0,0] + [int(w) for w in input().split()]

d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]

if n == 1:
    d[1] = 1

d = d[1:]
d.sort()

print(*d)
",O(n)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        offset = 1

        for i in range(1, n + 1):
            if offset * 2 == i:
                offset = i
            dp[i] = 1 + dp[i - offset]
        return dp
",O(n)
"class Solution(object):
    def fourSum(self, nums, target):
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                total = target - nums[i] - nums[j]
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[left] + nums[right] == total:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        right -= 1
                        left += 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif nums[left] + nums[right] > total:
                        right -= 1
                    else:
                        left += 1
        return result",O(n ^ 3)
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",O(n ^ 2)
"n = int(input())
r = 0
i = 2
while i*2 <=n:
	a = int(n/i)
	r += (a+2)*(a-2+1)/2
	i += 1
print(int(4*r))
",O(n)
"x,y,z=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
c=0
s=z
t=False
while s<y and c<x:
    c+=1
    s=s+l[x-c]-1
if s<y:
    print(-1)
else:
    print(c)
",O(nlogn)
"a=input()
b=input()
v=sorted(a)
v=v[::-1]
x=""""
for i in range(len(v)):
    x=x+v[i]
v=x
if(len(a)<len(b)):
    print(v)
else:
    if(b==a):
        print(a)
    else:
        fin=""""
        flag=False
        for j in range(len(a)):
            for k in range(len(a)):
                num=fin+v[k]+''.join(sorted(v[:k:]+v[k+1::]))

                if(num<=b):
                    fin+=v[k]

                    if(int(v[k])<int(b[j])):
                        flag=True
                        v=v[:k:]+v[k+1::]
                        fin+=v
                    v=v[:k:]+v[k+1::]
                    break
            if(flag):
                break
        print(fin)",O(n ^ 3)
"class Solution(object):
    def minimumArrayLength(self, nums):
        mn = min(nums)
        return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1",O(n)
"import sys
input = sys.stdin.readline

ok = set()
for i in range(114514):
    x = i * i
    ok.add(2 * x)
    ok.add(4 * x)

t = int(input())
for _ in range(t):
    n = int(input())
    ans = ""YES"" if n in ok else ""NO""
    print(ans)",O(1)
"class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ""."":
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])

        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ""."":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])

        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ""."":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True
",O(n ^ 2)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8",O(n)
"import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        print(a[0],a[0],a[0],a[0])
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")
",O(nlogn)
"class Solution(object):
    def numberOfCombinations(self, num):
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in range(len(num)+1)] 
            for i in reversed(range(len(lcp)-1)):
                for j in reversed(range(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in range(len(num))] 
        dp[0][0] = int(num[0] != '0')
        for i in range(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in range(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu 
                if i-l < 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)",O(n ^ 2)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if max([n, m]) > k:
        print(-1)
    else:
        if (n + m) % 2 == 0:
            if max([n, m]) % 2 != k % 2:
                print(k - 2)
            else:
                print(k)
        else:
            print(k - 1);
",O(1)
"n, v = list(map(int, input().split()))
f = lambda x: x*(x+1)//2
print(min(n-1, v)+f(n-min(n-1, v))-1)",O(1)
"class Solution(object):
    def hasSameDigits(self, s):
        def check(mod):
            def decompose(x, mod): 
                cnt = 0
                while x > 1 and x%mod == 0:
                    x //= mod
                    cnt += 1
                return x, cnt

            result = cnt = 0
            curr = 1
            for i in range(len(s)-1):
                if cnt == 0:
                    result = (result+curr*(ord(s[i])-ord(s[i+1])))%mod
                x, c = decompose(len(s)-2-i, mod)
                curr = (curr*x)%mod
                cnt += c
                x, c = decompose(i+1, mod)
                curr = (curr*pow(x, mod-2, mod))%mod
                cnt -= c
            return result == 0

        return check(2) and check(5)",O(nlogn)
"def main():
    n,k=map(int,input().split( ))
    a=list(map(int,input().split( )))
    ans=-1*10**9+7
    for i in range(n):
        s=0
        for j in range(i,n):
            s+=a[j]
            if j-i+1>=k:

                ans=max(ans,s/(j-i+1))
    print(ans)

main()",O(n ^ 2)
"lr = input()
lr_list = lr.split("" "")
l = int(lr_list[0])
r = int(lr_list[1])
xor = l ^ r

bms = 0
while xor != 0:
    bms = bms + 1
    xor = xor >> 1

maxxor = 0
dois = 1
while bms != 0:
    maxxor = maxxor + dois
    dois = dois << 1
    bms = bms - 1

print(maxxor)
",O(logn)
"class Solution(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = 0
        result = []
        while i < len(s):
            if i+2 < len(s) and s[i+2] == 
                result.append(alpha(s[i:i+2]))
                i += 3
            else:
                result.append(alpha(s[i]))
                i += 1
        return """".join(result)",O(n)
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)]
for l in range(1, n):
	for s in range(n-l):
		e = s + l
		for m in range(s, e):
			if d[s][m] == d[m+1][e] and d[s][m] != -1:
				d[s][e] = d[s][m] + 1
a = [1]
for e in range(1, n):
	t = 4096
	for s in range(e+1):
		if d[s][e] != -1:
			t = min(t, ((a[s-1]+1) if s > 0 else a[s]))
	a.append(t)
print(a[-1])
",O(n ^ 3)
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if nums[mid] > target:
                right = mid-1
            elif nums[mid] < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"class Solution(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] == '1':
                curr += 1
            elif i+1 == len(s) or s[i+1] == '1':
                result += curr
        return result",O(n)
"l,r=map(int,input().split())
r1=len(bin(r))-3
l1=len(bin(l))-3
ans=0
while(l>0):
    if l1==r1:
        r-=(1<<l1)
        l-=(1<<l1)
    else:
        ans=(1<<(r1+1))-1
        break

    z1=min(l,r)
    z2=max(l,r)
    l,r=z1,z2
    r1 = len(bin(r)) - 3
    l1 = len(bin(l)) - 3

if ans==0:
    if l1==r1:
        if r==1:
            print(1)
        else:
            print(0)
    else:
        print((1<<(r1+1))-1)

else:
    print(ans)
",O(logn)
"class Solution2(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, prev, sum):
            if root is None:
                return 0

            curr = prev + root.val
            return int(curr == sum) + \
                   pathSumHelper(root.left, curr, sum) + \
                   pathSumHelper(root.right, curr, sum)

        if root is None:
            return 0

        return pathSumHelper(root, 0, sum) + \
               self.pathSum(root.left, sum) + \
               self.pathSum(root.right, sum)",O(n ^ 2)
"class Solution(object):
    def minBitwiseArray(self, nums):
        return [x-(((x+1)&~x)>>1) if x&1 else -1 for x in nums]",O(n)
"l=list(map(int,input().split()))
s1,s2,s3,s4=0,0,0,0
for i in l:
	if i==1:
		s1+=1
	if i==2:
		s2+=1
	if i==3:
		s3+=1
	if i==4:
		s4+=1

if s3>2 or s2>1 or s1>0 or (s4==2 and s2==1):
	print(""YES"")
else:
	print(""NO"")",O(1)
"import sys
from collections import OrderedDict

def sum_from_two(x):

    return x * (x + 1) // 2 - 1

def sum_last(k, x):

    if x == 0:
        return 1

    return sum_from_two(k) - sum_from_two(k - x) - x + 1

def possible(n, k, x):
    return sum_last(k, x) >= n

def main(n, k):
    if n == 1:

        return 0

    if sum_last(k, k - 1) < n:
        return -1

    minimum = 1

    maximum = k - 1
    while minimum <= maximum:
        if minimum == maximum:
            return minimum
        elif minimum == maximum - 1:
            if possible(n, k, minimum):
                return minimum
            else:
                return maximum

        mid = (minimum + maximum) // 2
        if possible(n, k, mid):

            maximum = mid
        else:

            minimum = mid

if __name__ == ""__main__"":
    curr = None
    for e, line in enumerate(sys.stdin.readlines()):
        n, k = list(map(int, line.strip().split()))
    print(main(n, k))
",O(logn)
"def check():
	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][j]:
				f = False
				break
	if f:
		return True

	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[n - 1 - i][j]:
				f = False
				break
	if f:
		return True

	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][n - 1 - j]:
				f = False
				break
	if f:
		return True

def rotate():
	wk1=[]
	for i in range(n):
		wk1.append([])
		for j in range(n):
			wk1[i].append(map1[i][j])

	for i in range(n):
		for j in range(n):
			map1[i][j] = wk1[j][n - 1 - i]

n = int(input())
map1 = []
for i in range(n):
	st = input()
	map1.append([])
	for j in st:
		map1[i].append(j)

map2 = []
for i in range(n):
	st = input()
	map2.append([])
	for j in st:
		map2[i].append(j)

f = False
for k in range(4):
	if check():
		f = True
		break
	rotate()

if f:
	print(""Yes"")
else:
	print(""No"")
",O(n ^ 2)
"q = int(input())
a,s = map(int,input().split())
if ((a+s-2)<=(q+q-a-s)):
    print(""White"")
else:
    print('Black')
",O(1)
"import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]

    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]

    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]

    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]

    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z

n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))

col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)

    for item in ans:
        print(*item)

def nouse0():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

def nouse3():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():

    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution(object):
    def minOperations(self, nums, x):
        target = sum(nums)-x
        result = -1
        curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            while left < len(nums) and curr > target:
                curr -= nums[left]
                left += 1
            if curr == target:
                result = max(result, right-left+1)
        return len(nums)-result if result != -1 else -1",O(n)
"class Solution(object):
    def maximumHappinessSum(self, happiness, k):
        happiness.sort(reverse=True)
        return sum(max(happiness[i]-i, 0) for i in range(k))",O(nlogn)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",O(1)
"n = int(input())
a = input()
sum = 0
for x in a:
    sum += int(x)
ans = ""NO""
if sum == 0:
    ans = ""YES""
s = 1
while s * s <= sum and ans == ""NO"":
    if sum % s == 0:
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == s:
                flag = 1
            if t > s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == s:
                        flag = 1
        if t == s and t != sum:
            ans = ""YES""
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == sum // s:
                flag = 1
            if t > sum // s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == sum // s:
                        flag = 1
        if t == sum // s and t != sum:
            ans = ""YES""
    s += 1
print(ans)",O(n ^ 2)
"MOD = int(1e9 + 7)
x, k = map(int, input().split())
if x == 0: print(0)
else: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)",O(logn)
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",O(n ^ 2)
"from collections import defaultdict
import bisect
from itertools import accumulate, count
import os
import sys
import math
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

s=input()
neg=0
if int(s)<0:
    neg=1
ans1 = """"
s=int(s)
s=abs(s)
s=str(s)
ans2 = """"
for i in range(0, len(s)):
    if i == len(s)-2:
        ans1 += s[i]
    elif i == len(s)-1:
        ans2 += s[i]
    else:
        ans1 += s[i]
        ans2 += s[i]
if neg==0:
    print(s)
else:
    if str(min(int(ans1), int(ans2)))==""0"":
        print(0)
    else:
        print(""-""+str(min(int(ans1), int(ans2))))
",O(1)
"k, n, s, p = map(int, input().split())

sheets = (n + s - 1) // s

print((sheets * k + p - 1) // p)
",O(1)
"from math import factorial

def lol(n):
    if n == 1:
        yield [0]
        yield [1]
    else:
        for p in lol(n - 1):
            p.append(0)
            yield p
            p[-1] = 1
            yield p
            p.pop()

def sp(g1, g2, g3, f):
    if g1 == 0:
        if g2 == g3:
            return 2
        elif abs(g2 - g3) == 1:
            return 1
        else:
            return 0
    elif g2 == 0:
        if g1 == g3:
            return 2
        elif abs(g1 - g3) == 1:
            return 1
        else:
            return 0
    elif g3 == 0:
        if g2 == g1:
            return 2
        elif abs(g2 - g1) == 1:
            return 1
        else:
            return 0
    else:
        if f == 1:
            b = sp(g1, g2 - 1, g3, 2)
            c = sp(g1, g2, g3 - 1, 3)
            return b + c
        elif f == 2:
            a = sp(g1 - 1, g2, g3, 1)
            c = sp(g1, g2, g3 - 1, 3)
            return a + c
        elif f == 3:
            a = sp(g1 - 1, g2, g3, 1)
            b = sp(g1, g2 - 1, g3, 2)
            return a + b
        else:
            a = sp(g1 - 1, g2, g3, 1)
            b = sp(g1, g2 - 1, g3, 2)
            c = sp(g1, g2, g3 - 1, 3)
            return a + b + c

n, T = map(int, input().split())
S = []
cnt = 0
M = 10 ** 9 + 7
for i in range(n):
    S.append(list(map(int, input().split())))
for p in lol(n):
    d = 0
    g1, g2, g3 = 0, 0, 0
    for i in range(n):
        if p[i]:
            d += S[i][0]
            if S[i][1] == 1:
                g1 += 1
            elif S[i][1] == 2:
                g2 += 1
            elif S[i][1] == 3:
                g3 += 1
    if d == T:
        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)
        cnt %= M
print(cnt)",np
"n=int(input())
x=list(map(int,input().split()))
x.sort()
count,count2=0,0
ans=1
for i in range(n):
    count+=x[i]-i
    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0
    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0
    if i>=1 and x[i]==x[i-1]: count2+=1
if n>=3 and x[0]==x[1]==0: ans=0
for i in range(n):
    if x[i]>0: break
    if i==n-1: ans=0
if ans==0 or count%2==0 or count2>1: print(""cslnb"")
else: print(""sjfnb"")",O(nlogn)
"n,m = map(int,input().split())

if m<=n:
    print((m-1)//2)
elif m>n:
    if (m-n) in range(1,n+1):
        if(n-(m-n))%2==0:
            print((n-(m-n))//2)
        else:
            print((n-(m-n))//2+1)
    else:
        print(0)",O(1)
"class Solution:
    def isHappy(self, n: int) -> bool:
        visit = set()

        while n not in visit:
            visit.add(n)
            n = self.sumOfSquares(n)
            if n == 1:
                return True
        return False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"import collections


class Solution(object):
    def replaceWords(self, dictionary, sentence):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in dictionary:
            reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        def replace(word):
            curr = trie
            for i, c in enumerate(word):
                if c not in curr:
                    break
                curr = curr[c]
                if ""_end"" in curr:
                    return word[:i+1]
            return word

        return "" "".join(map(replace, sentence.split()))",O(n)
"class Solution(object):
    def constructArray(self, n, k):
        result = []
        left, right = 1, n
        while left <= right:
            if k % 2:
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
            if k > 1:
                k -= 1
        return result",O(n)
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1

ans=[]
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:

    print(ans[-1])
",O(n ^ 3)
"x, k = map(int, input().split())
mod = 1000000007
if x == 0:
    print(0)
else:
    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))
",O(logn)
"import collections



class Solution(object):
    def __init__(self, capacity):
        self.cache = collections.OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        val = self.cache[key]
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.cache and len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.__update(key, val)
    
    def __update(self, key, val):
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = val",O(1)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def hasCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                return True
        return False

",O(n)
"import collections


class Solution(object):
    def checkInclusion(self, s1, s2):
        counts = collections.Counter(s1)
        l = len(s1)
        for i in range(len(s2)):
            if counts[s2[i]] > 0:
                l -= 1
            counts[s2[i]] -= 1
            if l == 0:
                return True
            start = i + 1 - len(s1)
            if start >= 0:
                counts[s2[start]] += 1
                if counts[s2[start]] > 0:
                    l += 1
        return False",O(n)
"def some_random_function():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    powe = [1]
    for _ in range(10**6):
        powe.append((powe[-1]*2)%mod)
    n = int(input())
    a = list(map(int,input().split()))
    ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0
    for i in range(1,n):
        if i == 1:
            dp = (dp+a[i])%mod
        else:
            dp = (dp*2+a[i]-dp1)%mod
        ans = (ans+powe[n-i-1]*dp)%mod
        dp1 = a[i]
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",O(n)
"class Solution(object):

    def serialize(self, root):
        def serializeHelper(node):
            if not node:
                vals.append(
                return
            vals.append(str(node.val))
            serializeHelper(node.left)
            serializeHelper(node.right)
        vals = []
        serializeHelper(root)
        return ' '.join(vals)


    def deserialize(self, data):
        def deserializeHelper():
            val = next(vals)
            if val == 
                return None
            node = TreeNode(int(val))
            node.left = deserializeHelper()
            node.right = deserializeHelper()
            return node
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
        vals = iter(isplit(data, ' '))
        return deserializeHelper()",O(n)
"class Solution(object):
    def maxProduct(self, nums):
        m1 = m2 = 0
        for num in nums:
            if num > m1:
                m1, m2 = num, m1
            elif num > m2:
                m2 = num
        return (m1-1)*(m2-1)",O(n)
"n, m = map(int, input().split())
x1 = -1
x2 = -1
y1 = -1
y2 = -1
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            if x1 == -1:
                x1 = j + 1
            x2 = max(x2, j + 1)
            if y1 == -1:
                y1 = i + 1
            y2 = i + 1
print((y1 + y2) // 2, (x1 + x2) // 2)",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
grip=[[-1]*(n-i) for i in range(n)]
grip[0]=a.copy()
for level in range(1,n):
    for left in range(n-level):
        for split in range(level):
            pl=grip[level-split-1][left]
            pr=grip[split][left+level-split]
            if pl==pr!=-1:
                grip[level][left]=pl+1
pref=[0]*(n+1)
for p in range(1,n+1):
    x=n
    for j in range(p):
        l=pref[j]
        r=grip[p-j-1][j]
        if r==-1:
            r=p-j
        else:
            r=1
        x=min(x,l+r)
    pref[p]=x
print(pref[-1])
",O(n ^ 3)
"class Solution(object):
    def minSwap(self, A, B):
        dp_no_swap, dp_swap = [0]*2, [1]*2
        for i in range(1, len(A)):
            dp_no_swap[i%2], dp_swap[i%2] = float(""inf""), float(""inf"")
            if A[i-1] < A[i] and B[i-1] < B[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1)
            if A[i-1] < B[i] and B[i-1] < A[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1)
        return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2])",O(n)
"class Solution(object):
    def maxSubarraySumCircular(self, A):
        total, max_sum, cur_max, min_sum, cur_min = 0, -float(""inf""), 0, float(""inf""), 0
        for a in A:
            cur_max = max(cur_max+a, a)
            max_sum = max(max_sum, cur_max)
            cur_min = min(cur_min+a, a)
            min_sum = min(min_sum, cur_min)
            total += a
        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum",O(n)
"import sys

n, m, k = map(int, input().split())

hor = [list(map(int, input().split())) for _ in range(n)]

ver = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2:
    for i in range(n):
        print(*([-1]*m))
    sys.exit()

k = k // 2
dp = [[[0]*m for _ in range(n)] for _ in range(k+1)]

for x in range(1, k+1):
    for y in range(n):
        for z in range(m):
            hold = float('inf')
            if y != 0:
                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )
            if y != n-1:
                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )
            if z != 0:
                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )
            if z != m-1:
                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )
            dp[x][y][z] = hold

for row in dp[k]:
    print(*map(lambda i: i*2, row))
",O(n ^ 3)
"def NOD(a, b):
    while b != 0:
        a %= b
        y = a
        a = b
        b = y
    return(a)

def NOK(a, b):
    i = (a*b) // NOD(a, b)
    return(i)

n = int(input())
maxnok = 0
x = 40
for i in range(max(1, n-x), n+1):
    for j in range(max(1, i-x), i+1):
        for f in range(max(1, j-x), j+1):
            nokk = NOK(NOK(i,j), f)
            if maxnok < nokk:
                maxnok = nokk
                delit = []
                delit.append(i)
                delit.append(j)
                delit.append(f)
print(maxnok)",O(1)
"def findSet(u):
  if parents[u] != u:
    parents[u] = findSet(parents[u])
  return parents[u]

def unionSet(u, v):
  up = findSet(u)
  vp = findSet(v)
  if up == vp:
    return

  if ranks[up] > ranks[vp]:
    parents[vp] = up
  elif ranks[up] < ranks[vp]:
    parents[up] = vp
  else:
    parents[up] = vp
    ranks[vp] += 1

n, a, b = map(int, input().split())
ps = list(map(int, input().split()))

mapping = set(ps)

parents = {x: x for x in ps}
parents['A'] = 'A'
parents['B'] = 'B'
ranks = {x: 0 for x in ps}
ranks['A'] = 0
ranks['B'] = 0

result = True
for x in ps:
  if a - x in mapping:
    unionSet(x, a - x)
  else:
    unionSet(x, 'B')

  if b - x in mapping:
    unionSet(x, b - x)
  else:
    unionSet(x, 'A')

if findSet('A') == findSet('B'):
  print(""NO"")

else:
  print(""YES"")
  for i in ps:
    if findSet(i) == findSet('A'):
      print(""0"", end = ' ')
    else:
      print(""1"", end = ' ')
",O(n)
"import collections



class Solution(object):
    def minimumSeconds(self, nums):
        lookup = collections.defaultdict(int)
        dist = collections.defaultdict(int)
        for i in range(2*len(nums)):
            x = nums[i%len(nums)]
            dist[x] = max(dist[x], i-lookup[x])
            lookup[x] = i
        return min(dist.values())//2",O(n)
"
class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x < y]
",O(n)
"n,kk=map(int,input().split())
s=input()
if(s==s[::-1] or s!=s[::-1]):
    k=""""
    l=0
    for i in reversed(range(1,n)):
        k=s[i]+k

        if(s.startswith(k)):
            l=len(k)
    ss=s[l:]
    fs=s+(ss*(kk-1))
    print(fs)
",O(n ^ 2)
"class Solution(object):
    def numDecodings(self, s):
        M, W = 1000000007, 3
        dp = [0] * W
        dp[0] = 1
        dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0
        for i in range(1, len(s)):
            if s[i] == '*':
                dp[(i + 1) % W] = 9 * dp[i % W]
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '2':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M
            else:
                dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '2' and s[i] <= '6':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M
        return dp[len(s) % W]",O(n)
"import sys
input = sys.stdin.readline
n,m,k=map(int,input().split())
A=[int(i) for i in input().split()]
if n<=m:
  AA=[0]*(n+1)
  for i in range(n):
    AA[i+1]=AA[i]+A[i]
  mm=0
  for i in range(n+1):
    for j in range(i+1,n+1):
      mm=max(mm,AA[j]-AA[i]-k)
else:
  DP=[[0]*(m+1) for _ in range(n+1)]
  for i in range(n):
    a=A[i]
    DP[i+1][0]=max([DP[i][0],DP[i][m],DP[i][m]+a-k,DP[i][1]])
    DP[i+1][1]=max(a-k,DP[i][m]+a-k)
    for j in range(2,m+1):
      DP[i+1][0]=max(DP[i+1][0],DP[i][j])
      if j>i+1:
        continue
      else:
        DP[i+1][j]=max(DP[i][j-1]+a,DP[i][m]+a-k)
print(max(A[0]-k,0) if n==1 else mm if n<=m else max(0,max(DP[n])))
",O(n ^ 2)
"class Solution2(object):
    def __init__(self):
        self.__nH = 0
        self.__nO = 0
        self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):
        with self.__cv:
            while (self.__nH+1) - 2*self.__nO > 2:
                self.__cv.wait()
            self.__nH += 1
            releaseHydrogen()
            self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):
        with self.__cv:
            while 2*(self.__nO+1) - self.__nH > 2:
                self.__cv.wait()
            self.__nO += 1
            releaseOxygen()
            self.__cv.notifyAll()",O(1)
"from sys import stdin
from itertools import permutations

rints = lambda: [int(x) for x in stdin.readline().split()]
x1, y1, x2, y2, x3, y3 = rints()

for x in [[x1, y1], [y1, x1]]:
    for y in [[x2, y2], [y2, x2]]:
        for z in [[x3, y3], [y3, x3]]:
            if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]:
                print(x[1])
                print('\n'.join(
                    ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in
                                                                                             range(z[0])]))
                exit()

for per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3):
    for x in per[0][:-1]:
        for y in per[1][:-1]:
            for z in per[2][:-1]:
                if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]:
                    print(x[1])
                    print('\n'.join(
                        [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in
                                                                    range(y[0])]))
                    exit()

print(-1)
",np
"for _ in range(int(input())):
	def get(n):
		return (4**n-1)//3
	n,k = map(int,input().split())
	if n<32 and 4**n < 1*3*k:
		print(""NO"")
		continue
	now = 1
	p = 2
	ans = n
	sq = 0
	buff = 0
	d = 4
	while k>=now:
		k -= now
		p *= 2
		now = p-1
		ans -= 1

		sq = sq*4 + d-3
		d *= 2
		if n < 60:
			buff += sq * (4**ans-1)//3
		else:
			buff = 10**19

		if ans == 0: break

	if buff < k: print(""NO"")
	else: print(""YES"",max(ans,0))",O(logn)
"n,k = map(int,input().split())
a = list(map(int,input().split()))

if k == 1:
    print(max(a) - min(a))
    exit()

dif = []
for i in range(n - 1):
    dif.append(a[i + 1] - a[i])
dif = sorted(dif)
print(sum(dif[:-k + 1]))",O(nlogn)
"import os,sys
from io import BytesIO, IOBase

def main():
    n,m = map(int,input().split())
    x = ((n-5)//4+((n-5)%4!=0))
    if n <= 5:
        a,b = '5','5'
    else:
        a = '5'*(x+1)
        b = '4'*x+'5'
    print(a,b)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(1)
"from math import factorial,pow
s1=list(input())
s2=list(input())
S1={""+"":0, ""-"":0}
S2={""+"":0, ""-"":0, ""?"":0}
for i in s1:
    S1[i]+=1
for i in s2:
    S2[i]+=1
if S1[""+""]-S2[""+""]>=0 and S1[""-""]-S2[""-""]>=0:
    pos=S1[""+""]-S2[""+""]
    neg=S1[""-""]-S2[""-""]
    ques=S2[""?""]
    res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques)
    print(""%.12f""%res)
else:
    print(""%.12f"" % 0)",np
"def candy_eaten(n, k):

    choco = 1
    last = 1
    eat = 0

    i = n - 1
    while i > 0:
        if choco > k:
            temp = choco - k
            choco -= temp
            eat += temp
            i -= temp
        else:
            last += 1
            choco += last
            i -= 1
    return eat

if __name__ == '__main__':
    n, k = map(int, input().strip().split())
    print(candy_eaten(n, k))
",O(logn)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",O(n ^ 2)
"class Solution2(object):
    def maximum69Number (self, num):
        return int(str(num).replace('6', '9', 1))",O(logn)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):

    def serialize(self, root):
        def dfs(node, vals):
            if not node:
                return
            vals.append(str(node.val))
            for child in node.children:
                dfs(child, vals)
            vals.append(
        
        vals = []
        dfs(root, vals)
        return "" "".join(vals)


    def deserialize(self, data):
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
                
        def dfs(vals):
            val = next(vals)
            if val == 
                return None
            root = Node(int(val), [])
            child = dfs(vals)
            while child:
                root.children.append(child)
                child = dfs(vals)
            return root

        if not data:
            return None
    
        return dfs(iter(isplit(data, ' ')))",O(n)
"import bisect


class Solution2(object):
    def maximumScore(self, nums, k):
        def score(nums, k):
            prefix = [nums[k]]*(k+1)
            for i in reversed(range(k)):
                prefix[i] = min(prefix[i+1], nums[i])
            result = right = nums[k]
            for j in range(k+1, len(nums)):
                right = min(right, nums[j])
                i = bisect.bisect_left(prefix, right)
                if i >= 0:
                    result = max(result, right*(j-i+1))
            return result

        return max(score(nums, k), score(nums[::-1], len(nums)-1-k))",O(nlogn)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

n=ri()
a=ris()
freq=Counter(a)
ans=0
for x in freq:
  for i in range(32):
    c=(1<<i)-x
    if c not in freq:
      continue
    if c==x and freq[x]==1:
      continue
    break
  else:
    ans+=freq[x]

print(ans)
",O(nlogn)
"class Solution(object):
    def minimumRecolors(self, blocks, k):
        result = k
        curr = 0
        for i, x in enumerate(blocks):
            curr += int(blocks[i] == 'W')
            if i+1-k < 0:
                continue
            result = min(result, curr)
            curr -= int(blocks[i+1-k] == 'W')
        return result",O(n)
"def combine(n, k, w=1, out=[], result=[]):
    if k == 0:
        result.append(out)

    for i in range(w, n + 1):
        new_out = out[:]
        new_out.append(i)
        combine(n, k-1, i+1, new_out)

    return result

def main():

    n, l, r, x = [int(i) for i in input().split()]
    c = [int(i) for i in input().split()]

    if n < 2:
        print(0)
        return

    result = None
    for i in range(2, n + 1):
        if i == n:
            result = combine(n, i)
        else:
            combine(n, i)

    for i in range(len(result)):
        comb = result[i]
        for j in range(len(comb)):
            comb[j] = c[comb[j] - 1]

    cnt = 0
    for i in range(len(result)):
        sm = sum(result[i])
        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):
            cnt += 1

    print(cnt)

if __name__ == '__main__':
    main()
",np
"n = int(input())
a = list(map(int, input().split()))

dp = [[False] * (n + 1) for i in range(n + 1)]

def solve(l, r):
    if dp[l][r]:
        return dp[l][r]
    if r - l == 1:
        dp[l][r] = (a[l], 1)
        return dp[l][r]
    tmp = 10 ** 9
    for i in range(l + 1, r):
        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:
            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])
        elif solve(l, i) == solve(i, r):
            tmp = solve(l, i)[0] + 1
            dp[l][r] = (tmp, 1)
            return dp[l][r]
        else:
            tmp = min(tmp, 2)
    dp[l][r] = (-1, tmp)
    return dp[l][r]

solve(0, n)
print(dp[0][n][1])",O(n ^ 3)
"n,tar=[int(i) for i in input().split()]
a=[int(i) for i in input().split()]

from collections import defaultdict
d=defaultdict(lambda:[])
count=0
for i in range(n):
    d[a[i]].append(i)
    if a[i]==tar:
        count+=1

presum=[1 if a[0]==tar else 0]
for e in a[1:]:
    if e==tar:
        presum.append(presum[-1]+1)
    else:
        presum.append(presum[-1])

final = 0
for k,v in d.items():
    if k==tar:
        continue

    t=1
    tt=1
    for i in range(1,len(v)):
        ind=v[i]
        preind=v[i-1]

        t -= presum[ind] - presum[preind]
        t=max(t,0)
        t+=1
        tt=max(tt,t)

    final=max(final,tt)

print(final + count)",O(n)
"import random

n = int(input())
v = []
a = []
for i in range(n):
    a.append(i)

for _ in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, x*x+y*y])

while 1>0:
    x = 0
    y = 0
    ans = [0]*n
    random.shuffle(a)
    for i in range(n):
        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:
            x += v[a[i]][0]
            y += v[a[i]][1]
            ans[a[i]] = 1
        else:
            x -= v[a[i]][0]
            y -= v[a[i]][1]
            ans[a[i]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break
",O(nlogn)
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",O(1)
"n = int(input())

if n > 0:
    print(n)
else:
    n = n * -1
    x = n % 10
    y = (n // 10) % 10

    if x > y:
        print(-(n // 10))
    else:
        print(-((n // 100)* 10 + x))
",O(1)
"class Solution2(object):
    def maxIncreasingGroups(self, usageLimits):
        usageLimits.sort()
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result",O(nlogn)
"class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))",O(n)
"n,k=map(int,input().split())
print(-(-k//n))",O(1)
"class Solution(object):
    def getHint(self, secret, guess):
        A, B = 0, 0
        lookup = defaultdict(int)
        for s, g in zip(secret, guess):
            if s == g:
                A += 1
            else:
                B += int(lookup[s] < 0) + int(lookup[g] > 0)
                lookup[s] += 1
                lookup[g] -= 1
        return ""%dA%dB"" % (A, B)",O(n)
"import sys
input = sys.stdin.readline

def int_array():
	return list(map(int, input().strip().split()))

def float_array():
	return list(map(float, input().strip().split()))

def str_array():
	return input().strip().split()
from collections import Counter
import math
import bisect
from collections import deque
n,m,lesson=int_array()
dp=[[250005 for i in range(lesson+2)]for j in range(n+1)]
days=[[] for i in range(n)]
for i in range(n):
	s=input()
	for  j in range(m):
		if s[j]==""1"":
			days[i].append(j+1)

m=[[250005 for i in range(lesson+2)]for j in range(n+1)]
for i in range(n):
	for j in range(lesson+1):
		if j<=len(days[i]):
			if j==len(days[i]):
				m[i][j]=0
				continue
			else:
				for k  in range(0,j+1):
					var=days[i][0+k]
					var1=days[i][-1*max(1,1+(j-k))]
					m[i][j]=min(m[i][j],var1-var+1)

for i in range(lesson+1):
	dp[0][i]=m[0][i]
for i in range(1,n):
	for j in range(lesson+1):
		for k in range(j+1):

			dp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k])

print(min(dp[n-1]))
",O(n ^ 3)
"import math
n,k=map(int,input().split())
edges=[]
for i in range(n-1):
    edges.append(tuple(map(int,input().split())))
degreelist=[]
for i in range(min(k+1,math.floor(math.log2(n))+10)):
    degreelist.append({})
degrees=degreelist[0]
for i in range(1,n+1):
    degrees[i]=0
for guy in edges:
    degrees[guy[0]]+=1
    degrees[guy[1]]+=1
small=[]
center=None
done=False
for i in range(k):
    if not done:
        small=[]
        for guy in degrees:
            if degrees[guy]==2:
                print(""No"")
                done=True
                break
            if degrees[guy]==3:
                small.append(guy)
                if center==None:
                    center=guy
                elif center!=guy:
                    print(""No"")
                    done=True
                    break
            elif degrees[guy]>1:
                small.append(guy)
        degrees=degreelist[i+1]
        if center!=None and center not in small:
            if not done:
                print(""No"")
            done=True
            break
        elif len(small)==0:
            if not done:
                print(""No"")
            done=True
            break
        for guy in small:
            degrees[guy]=0
        for guy in edges:
            if guy[0] in degrees and guy[1] in degrees:
                degrees[guy[0]]+=1
                degrees[guy[1]]+=1
        for guy in degrees:
            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:
                if not done:
                    print(""No"")
                done=True
                break
    else:
        break
if not done:
    if len(degreelist[-1])==1:
        print(""Yes"")
    else:
        print(""No"")",O(n)
"import sys
import math
input = sys.stdin.readline

testcase=int(input())
T=[list(map(int,input().split())) for i in range(testcase)]

def bi(n,k):
    MIN=0
    MAX=n

    while MAX>MIN+1:
        bn=(MIN+MAX)//2
        if math.log2(k+2+bn)<bn+1:
            MAX=bn
        elif math.log2(k+2+bn)==bn+1:
            return bn
        else:
            MIN=bn

    if MAX+1<=math.log2(k+2+MAX):
        return MAX

    return MIN

for n,k in T:
    if n==1:
        if k==1:
            print(""YES"",0)
        else:
            print(""NO"")
        continue

    if n==2:
        if 1<=k<=2:
            print(""YES"",1)
        elif k==3:
            print(""NO"")
        elif 4<=k<=5:
            print(""YES"",0)
        else:
            print(""NO"")
        continue

    if n<=30 and k>(pow(4,n)-1)//3:
        print(""NO"")
        continue

    ANS=bi(n,k)

    print(""YES"",n-ANS)
",O(logn)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:n -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
import heapq
from random import randint as rn
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1

q=[]
for _ in range(input()):
    a=int(stdin.readline())
    b=map(int,stdin.readline().split())
    w={}
    for i in range(a):
        if(w.has_key(b[i])):
            w[b[i]]+=1
        else:
            w[b[i]]=1
    s=-1
    l=0
    mi=2325234324324234
    d=[]
    for i in w:
        if(w[i]>=4):
            t=[str(i),str(i),str(i),str(i)]
            q.append("" "".join(t))
            l=1
            break
        if(w[i]>=2):
            d.append(i)
    if(l==1):
        continue
    d.sort()
    for i in range(len(d)):
        if(s==-1):
            s=d[i]
        else:
            r=float(s)/float(d[i])
            r+=float(d[i])/float(s)
            if(r<mi):
                p=[str(d[i]),str(s)]
                mi=r
            s=d[i]
    p=p*2
    q.append("" "".join(p))
stdout.write(""\n"".join(q))
",O(nlogn)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
d = {}
sm = 0

for i in range(n):
    indx , y = MAP()
    d[indx] = [1 , [y]]

m = INT()
for i in range(m):
    indx , y = MAP()
    if indx in d :
        d[indx][0] += 1
        d[indx][1].append(y)
    else:
        d[indx] = [1 , [y]]

for i in d :
    if d[i][0] == 1 :
        sm += d[i][1][0]
    else:
        sm += max(d[i][1])

print(sm)
",O(nlogn)
"def main():
    n, m = map(int, input().split())
    def intCompare(x):
        if int(x) == m:
            return 0
        if int(x) < m:
            return -1
        return 1
    p = list(map(intCompare, input().split()))
    ret = 0
    ind = p.index(0)
    tem = 0
    ret0 = [0] * 400001
    ret1 = [0] * 400001
    set0 = set()
    for i in range(ind, -1, -1):
        tem += p[i]
        ret0[tem] += 1
        set0.add(tem)
    tem = 0
    for i in range(ind, n):
        tem += p[i]
        ret1[tem] += 1
    for i in set0:
        ret += ret0[i] * (ret1[-i] + ret1[1-i])
    print(ret)
    return 0
main()",O(nlogn)
"import collections


class Solution(object):

    def __init__(self):
        self.__freq = collections.Counter()
        self.__group = collections.defaultdict(list)
        self.__maxfreq = 0

    def push(self, x):
        self.__freq[x] += 1
        if self.__freq[x] > self.__maxfreq:
            self.__maxfreq = self.__freq[x]
        self.__group[self.__freq[x]].append(x)   

    def pop(self):
        x = self.__group[self.__maxfreq].pop()
        if not self.__group[self.__maxfreq]:
            self.__group.pop(self.__maxfreq)
            self.__maxfreq -= 1
        self.__freq[x] -= 1
        if not self.__freq[x]:
            self.__freq.pop(x)
        return x",O(1)
"x = int(input())
print(0,0,x)",O(1)
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",O(n ^ 2)
"import collections


class Solution(object):
    def numPairsDivisibleBy60(self, time):
        result = 0
        count = collections.Counter()
        for t in time:
            result += count[-t%60]
            count[t%60] += 1
        return result",O(n)
"class Solution(object):
    def canMakeSubsequence(self, str1, str2):
        i = 0
        for c in str1:
            if (ord(str2[i])-ord(c))%26 > 1:
                continue
            i += 1
            if i == len(str2):
                return True
        return False",O(n)
"def main():
	n, d, k = map(int, input().split())
	if n < d+1 or d > 1 and k == 1:
		print('NO')
		return

	edges = [(1, 2)]
	stack = []
	d2 = d/2
	d21 = d2+1
	for node in range(2, d+1):
		edges.append((node, node+1))
		stack.append([node, d2-abs(d21 - node), k-2])
	next_i = d+2
	while next_i <= n:
		if not stack:
			print('NO')
			return

		node = stack[-1]
		i, remaining_depth, remaining_degree = node
		if remaining_depth == 0 or remaining_degree == 0:
			stack.pop()
			continue

		node[2] -= 1
		edges.append((i, next_i))
		stack.append([next_i, remaining_depth-1, k-1])
		next_i += 1

	print('YES')
	print('\n'.join('{} {}'.format(a, b) for a, b in edges))

main()",O(n ^ 2)
"from sys import stdin, stdout

nxt = []

def find_it(s, left, right):
    global nxt
    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]
    dp[0][0] = 0
    for i in range(len(left)+1):
        for j in range(len(right)+1):
            if dp[i][j] > len(s):
                continue
            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:
                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:
                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1
            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:
                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:
                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1
    if dp[len(left)][len(right)] != 1000:
        return True
    else:
        return False

def main():
    global nxt
    n = int(stdin.readline())
    for _ in range(n):
        s = stdin.readline().rstrip()
        t = stdin.readline().rstrip()
        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)]
        for i,x in enumerate(s):
            nxt[ord(x) - 97][i] = i
        for i in range(26):
            for j in range(len(s)-1 ,-1,-1):
                if nxt[i][j] != j:
                    nxt[i][j] = nxt[i][j+1]

        r = False
        for i in range(len(t)):
            res = find_it(s, t[:i], t[-len(t)+i:])
            if res is True:
                r = True
                break

        if r is True:
            stdout.write(""YES\n"")
        else:
            stdout.write(""NO\n"")

main()",O(n ^ 3)
"from collections import Counter
mp = Counter()
n = int(input())
arr = list(map(int,input().split()))

tot , cnt, ans = 0, 0, 0
for i in arr:
	ncnt = cnt - mp[i] - mp[i+1] - mp[i-1]
	ntot = tot - (i * mp[i]) - ((i-1)*mp[i-1]) - ((i+1)*mp[i+1])
	nsum = (ncnt * i) - ntot
	ans += nsum
	mp[i] += 1
	cnt += 1
	tot += i
print(ans)
",O(nlogn)
"import collections


class Solution(object):
    def reformat(self, s):
        def char_gen(start, end, count):
            for c in range(ord(start), ord(end)+1):
                c = chr(c)
                for i in range(count[c]):
                    yield c
            yield ''
    
        count = collections.defaultdict(int)
        alpha_cnt = 0
        for c in s:
            count[c] += 1
            if c.isalpha():
                alpha_cnt += 1
        if abs(len(s)-2*alpha_cnt) > 1:
            return """"

        result = []
        it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count)
        if alpha_cnt < len(s)-alpha_cnt:
            it1, it2 = it2, it1
        while len(result) < len(s):
            result.append(next(it1))
            result.append(next(it2))
        return """".join(result)",O(n)
"I=lambda:map(int,input().split())
n,s=I()
l=[0]
for i in range(n):
    q,w=I()
    q=q*60+w
    l+=[q]
if l[1]-l[0]>s:exit(print(0, 0))
for i in range(n):
    if l[i+1]-l[i]>2*s+1:
        l[i]+=s+1
        exit(print(l[i]//60,l[i]%60))
l[-1]+=s+1
print(l[-1]//60,l[-1]%60)",O(n)
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",O(n)
"reduced = 1
n, m ,k = map(int,input().split())

p = list(map(int, input().split()))

p.reverse()
cnt = 0
while(len(p)):

    cnt1 = 1
    first = p.pop()
    fack = ((first - reduced)//k) * k
    while(len(p) and p[-1] - fack - reduced < k):
        cnt1 += 1
        p.pop()

    reduced += cnt1
    cnt += 1
print(cnt)",O(n)
"l,r=list(map(int,input().split()))
if l==r:
    print(0)
else:
    x=l^r
    c=0
    while x>0:
        x=x//2
        c=c+1
    print(2**c-1)",O(logn)
"class Solution2(object):
    def countSmaller(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        sorted_nums = sorted(zip(nums, list(range(len(nums)))))
        lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)}

        result, bit = [0]*len(nums), BIT(len(nums))
        for i in reversed(range(len(nums))):
            result[i] = bit.query(lookup[i]-1)
            bit.add(lookup[i], 1)
        return result",O(nlogn)
"class Solution(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sl = SortedList()
        result = 0
        for x, y in zip(nums1, nums2):
            result += sl.bisect_right((x-y)+diff)
            sl.add(x-y)
        return result

import itertools
import bisect


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret",O(nlogn)
"def size_of_group(i):
    return long(9 * 10**(i - 1)) * i

def find_group(k, i = 1):
    diff = long(k - (size_of_group(i)))
    if diff <= 0:
        return k, i
    return find_group(diff, i + 1)

def get_number(k, g):
    return str(long(10**(g - 1)) + k / g)[k % g]

def get_sequence_number(num):

    k_prim, g_prim = find_group(num)
    return get_number(k_prim - 1, g_prim)

if __name__ == ""__main__"":
    print(get_sequence_number(long(input())))",O(logn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def preorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    result.append(curr.val)
                    node.right = curr
                    curr = curr.left
                else:
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"vals=list(map(int,input().split()))
l=vals[0]
r=vals[1]

if l==r:
    print(""0"")
else:
    i=0
    j=0
    while l>0 or r>0:
        i+=1
        if (l&1)^(r&1)==1:
            j=i
        l=l>>1
        r=r>>1
    ans=1
    for i in range(0,j):
        ans=ans*2
    ans-=1
    print(ans)",O(logn)
"n, k = [int(i) for i in input().split()]
a, j = sorted([int(i) for i in input().split()]), 0
for i in a:
    while i > a[j]:
        if i <= a[j] + k:
            n -= 1
        j += 1
print(n)",O(nlogn)
"class Solution2(object):
    def plusOne(self, digits):
        result = digits[::-1]
        carry = 1
        for i in range(len(result)):
            result[i] += carry
            carry, result[i] = divmod(result[i], 10)
        if carry:
            result.append(carry)
        return result[::-1]",O(n)
"class Solution(object):
    def check(self, nums):
        count = 0
        for i in range(len(nums)):
            if nums[i] > nums[(i+1)%len(nums)]:
                count += 1
                if count > 1:
                    return False
        return True",O(n)
"class Solution(object):
    def findMode(self, root):
        def inorder(root, prev, cnt, max_cnt, result):
            if not root:
                return prev, cnt, max_cnt

            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
            if prev:
                if root.val == prev.val:
                    cnt += 1
                else:
                    cnt = 1
            if cnt > max_cnt:
                max_cnt = cnt
                del result[:]
                result.append(root.val)
            elif cnt == max_cnt:
                result.append(root.val)
            return inorder(root.right, root, cnt, max_cnt, result)

        if not root:
            return []
        result = []
        inorder(root, None, 1, 0, result)
        return result",O(n)
"n = int(input())
s = list(input())
t = list(input())

if sorted(t) == sorted(s):
    ans = []
    for i in range(n-1, -1, -1):
        if t[i] != s[i]:
            j = s.index(t[i])
            for k in range(j, i):
                s[k], s[k+1] = s[k+1], s[k]
                ans.append(str(k+1))
    print(len(ans))
    print(' '.join(ans))
else:
    print(-1)
",O(n ^ 2)
"import sys
def ask(i):
    print('?', i + 1)
    sys.stdout.flush()
    a_i = int(input())
    return a_i
def answer(i):
    print('!', i + 1 if i != -1 else -1)
    sys.exit()

def has_intersection(l1, r1, l2, r2):
    if l1 <= l2 and r2 <= r1:
        return True
    if l2 <= l1 and r1 <= r2:
        return True
    return False

n = int(input())
assert n >= 2 and n % 2 == 0
if (n // 2) % 2 == 1:
    answer(-1)
else:
    assert n % 4 == 0
    l1 = 0
    r1 = n // 2
    a_l1 = ask(l1)
    a_r1 = ask(r1)
    if a_l1 == a_r1:
        answer(0)
    a_l2 = a_r1
    a_r2 = a_l1

    while True:
        m1 = (l1 + r1) // 2
        m2 = (m1 + n // 2) % n
        a_m1 = ask(m1)
        a_m2 = ask(m2)
        if a_m1 == a_m2:
            answer(m1)
        if has_intersection(a_l1, a_m1, a_l2, a_m2):
            r1 = m1
            a_r1 = a_m1
            a_r2 = a_m2
        else:
            assert has_intersection(a_m1, a_r1, a_m2, a_r2)
            l1 = m1
            a_l1 = a_m1
            a_l2 = a_m2

assert False
",O(logn)
"class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        dp = [0] * (n + 1)
        dp[1], dp[2] = 1, 2
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]
",O(n)
"n = int(input())
if n <= 5:
    print(-1)
    for i in range(2, n+1):
        print(1, i)
    exit()

print(1, 2)
print(2, 3)
print(2, 4)
for i in range(5, n+1):
    print(3, i)

for i in range(2, n+1):
    print(1, i)
",O(n)
"class Solution3(object):
    def printLinkedListInReverse(self, head):
        tail = None
        while head != tail:
            curr = head
            while curr.getNext() != tail:
                curr = curr.getNext()
            curr.printValue()
            tail = curr",O(n ^ 2)
"class Solution2(object):
    def getRow(self, rowIndex):
        result = [1]
        for i in range(1, rowIndex + 1):
            result = [1] + [result[j - 1] + result[j] for j in range(1, i)] + [1]
        return result",O(n ^ 2)
"import math
def solve(n, x, y):
    g = math.gcd(x, y)
    if g != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    p = x + y
    weights = [n // p] * p
    for i in range(p):
        if (i * x) % p < n % p:
            weights[i] += 1
    ans = -n
    for i in range(2):
        dp = [-n, -n]
        dp[i] = 0
        for w in weights:
            dp = [max(dp[0], dp[1]), dp[0] + w]
        ans = max(ans, dp[i])
    return ans

def main():
    n, x, y = [int(x) for x in input().split()]
    print(solve(n, x, y))

main()",np
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod=10**9+7
n=int(input())
a=list(map(int,input().split()))
c=0
for i in range (1,n):
    for j in range (i):
        if a[j]>a[i]:
            c+=1
c=c%2
m=int(input())
for i in range (m):
    l,r=map(int,input().split())
    s=(r-l+1)//2
    if s%2==1:
        c=(c+1)%2
    if c==0:
        print(""even"")
    else:
        print(""odd"")",O(n ^ 2)
"fre =[0,0,0,0,0,0,0,0,0,0,0]
a=input();b=input()
c=False
def DFS(aa,bb):
  if int(aa)==len(a):
    print(bb)
    exit()
  global c
  for i in range(9,-1,-1):
    if (fre[i]>0 and i<=int(b[int(aa)])) or (fre[i]>0 and c):
      fre[i]-=1
      if i<int(b[int(aa)]):
        c=True
      DFS(aa+1,bb*10+i)
      fre[i]+=1
      c=False

if len(b)>len(a):
  x=sorted(a);

  print(*x[::-1],sep='')
else:
  for i in a:
    fre[int(i)]+=1
  DFS(0,0)
",O(n ^ 3)
"class Solution(object):
    def findNonMinOrMax(self, nums):
        mx, mn = float(""-inf""), float(""inf"")
        result = -1
        for x in nums:
            if mn < x < mx:
                return x
            if x < mn:
                result = mn
                mn = x
            if x > mx:
                result = mx
                mx = x
        return result if mn < result < mx else -1",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

p, u = ""Petr"", ""Um_nik""

def main():
    n = N()
    arr = RLL()
    vis = [0]*(n+1)
    dic = {v: i+1 for i, v in enumerate(arr)}

    sm = 0
    for i in range(1, n+1):
        if vis[i]==0:
            now = i
            vis[now] = 1

            while dic[now]!=i:
                sm+=1
                now = dic[now]
                vis[now] = 1
    if (3*n-sm)%2==0:
        print(p)
    else:
        print(u)

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution(object):
    def minOperations(self, nums, k):
        mn = min(nums)
        return len(set(nums))-int(mn == k) if mn >= k else -1",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def add(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if not node:
            l.insert(ListNode(key, 0))

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)

    def contains(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        return node is not None",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
class Solution(object):
    def reverseBetween(self, head, m, n):
        diff, dummy, cur = n - m + 1, ListNode(-1), head
        dummy.next = head

        last_unswapped = dummy
        while cur and m > 1:
            cur, last_unswapped, m = cur.__next__, cur, m - 1

        prev, first_swapped = last_unswapped,  cur
        while cur and diff > 0:
            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

        last_unswapped.next, first_swapped.next = prev, cur

        return dummy.__next__",O(n)
"class Solution(object):
    def maximizeGreatness(self, nums):
        return len(nums)-max(collections.Counter(nums).values())
    
    
",O(n)
"n = int(input())
queen_x, queen_y = list(map(int, input().strip().split()))
king_x, king_y = list(map(int, input().strip().split()))
tar_x, tar_y = list(map(int, input().strip().split()))

min_x, max_x = sorted([king_x, tar_x])
min_y, max_y = sorted([king_y, tar_y])

if max_x > queen_x > min_x or max_y > queen_y > min_y:
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"try:
    odd, even, oddIndex, evenIndex = 0, 0, 0, 0
    n = int(input())
    s = list(map(int, input().split()))
    counter = 0
    for i in s:
        if i % 2 == 0:
            even += 1
            evenIndex = counter
        else:
            odd += 1
            oddIndex = counter
        counter += 1
    ans = evenIndex + 1 if even == 1 else oddIndex + 1
    print(ans)
except EOFError as e:
    pass",O(n)
"x= int(input(""""))
print(int((x/2)*3))",O(1)
"def solve(n, m, x, t):
    r = [0] * n
    d = [0] * m
    ans = [0] * m
    cr = 0
    cd = 0
    for i in range(n+m):
        if t[i]:
            d[cd] = x[i]
            cd += 1
        else:
            r[cr] = x[i]
            cr += 1
    cn = 0
    for i in range(m-1):
        mid = (d[i] + d[i+1]) // 2
        while cn < n and r[cn] <= mid:
            cn += 1
            ans[i] += 1
    ans[-1] += n - sum(ans)
    return ' '.join(str(i) for i in ans)

def main():
    n, m = [int(i) for i in input().split()]
    x = [int(i) for i in input().split()]
    t = [int(i) for i in input().split()]
    print(solve(n, m, x, t))

main()
",O(n)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0

for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1

print(p)",O(n ^ 2)
"class Solution2(object):
    def goodNodes(self, root):
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max <= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)",O(n)
"input()
a = sorted(list(map(int, input().split())))
print(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))",O(nlogn)
"n = int(input())
d={}
for _ in range(n):
    a,b = map(int,input().split())
    d[a] = b

s=0
m = int(input())
for _ in range(m):
    x,y = map(int,input().split())

    if x in d:
        d[x] = max(d[x],y)

    else:
        d[x] = y

for i in d:

    s+=d[i]
print(s)
",O(nlogn)
"class Solution2(object):
    def countExcellentPairs(self, nums, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        sorted_cnts = sorted(popcount(x) for x in set(nums))
        result = 0
        left, right = 0, len(sorted_cnts)-1
        while left <= right:
            if sorted_cnts[left]+sorted_cnts[right] < k:
                left += 1
            else:
                result += 1+2*((right-1)-left+1)
                right -= 1
        return result",O(nlogn)
"import os,sys
from io import BytesIO,IOBase
from collections import Counter

def main():
    n,k = map(int,input().split())
    a = input().split()
    a1 = list(map(int,a))
    dct = [Counter() for _ in range(11)]
    for i in range(n):
        dct[len(a[i])][a1[i]%k] += 1
    ans = 0
    for i in range(n):
        x = a1[i]
        for j in range(1,11):
            x = (x*10)%k
            if x:
                ans += dct[j][k-x]
            else:
                ans += dct[j][0]
        if not (a1[i]*(pow(10,len(a[i]),k)+1))%k:
            ans -= 1
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(nlogn)
"s=input().split()
n=int(s[0])
arr=list(map(int,input().split()))

children=[[] for i in range(n+1)]
for i,j in enumerate(arr):
    if 1<i+2<=n:
        children[j].append(i+2)
leaves=[0]*(n+1)

for i in range(n,0,-1):
    if not children[i]:
        leaves[i]=1
    else:
        leaves[i]=sum(leaves[j] for j in children[i])

print(' '.join(map(str,sorted(leaves[1:]))))",O(nlogn)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,-1,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
        else:
            ind=m-1
            for j in range(ind,-1,-1):
                while len(rem[j])>req:
                    pop,_=rem[j].pop()
                    rem[i].append([pop+(i-j)%m,_])
                    if len(rem[i])==req:
                        ok=True
                        break
                if ok:
                    break
                ind-=1

out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
",O(n)
"def main():

    a = input()
    b = input()
    if len(a) < len(b):
        a = list(a)
        a.sort(reverse=True)
        print(''.join(a))
        return

    def solve(i, a: list):
        if i == len(b):
            return ''
        if a.__contains__(b[i]):
            a.remove(b[i])
            suf = solve(i+1, a)
            if suf is not None:
                return b[i] + suf
            a.append(b[i])
        best = ''
        for c in a:
            if c < b[i] and c > best:
                best = c
        if best == '':
            return None
        a.remove(best)
        a.sort(reverse=True)
        return best + ''.join(a)

    a = list(a)
    print(solve(0, a))

main()",O(n ^ 3)
"n, r = map(int, input().split())
y = []
x = list(map(int, input().split()))
for xi in x:
    yi = r
    for tx, ty in zip(x, y):
        if xi - 2 * r <= tx <= xi + 2 * r:
            dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5
            yi = max(yi, ty + dy)
    y.append(yi)
print(*y)
",O(n ^ 2)
"def if_spruce(n,l,s):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if i not in s:
            d[l[i]]+=1
    for i in range(1,n+1):
        if i in s and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,a=[0]*2,0
for _ in range(n-1):
    a=int(input())
    l.append(a)
s=set(l)
print(if_spruce(n,l,s))",O(n)
"def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x

n, k = list(map(int, input().split(' ')))
answer = int((-1/2) * isqrt(8*k + 8*n + 9) + n + 3/2)

print(answer)
",O(logn)
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",O(1)
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def output(answer):stdout.write(str(answer))

lst1={}
lst2={}
n=int(z())
lst=set()
for _ in range( n ):
    x,y=zzz()
    lst1[x]=y
    lst.add(x)

m=int(z())

for _ in range( m ):
    x,y=zzz()
    lst2[x]=y
    lst.add(x)

ans=0
for i in lst:
    try:
        x=lst1[i]
    except:
        x=0

    try:
        y=lst2[i]
    except:
        y=0
    ans+=max(x,y)
print(ans)
",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def heightOfTree(self, root):
        result = -1
        stk = [(root, 0)]
        while stk:
            u, d = stk.pop()
            result = max(result, d)
            if u.right and u.right.left != u:
                stk.append((u.right, d+1))
            if u.left and u.left.right != u:
                stk.append((u.left, d+1))
        return result",O(n)
"n, l, r, x = map(int, input().split())
a = [int(i) for i in input().split()]

count = 0
for i in range(1, 2**n+1):
	temp = []
	for j in range(n):
		if i & (1 << j):
			temp.append(a[j])

	if len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r:
		count += 1

print(count)",np
"class Solution(object):
    def distinctIntegers(self, n):
        return n-1 if n >= 2 else 1",O(1)
"class Solution(object):
    def countOdds(self, low, high):
        return (high+1)//2 - ((low-1)+1)//2",O(1)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}

i = int(input())
l = []
for x in range(i):
    d.pop(input())

print(len(d))
for i in d.values() : print(i)",O(1)
"n = int(input())-1
x, y = 1, 9
while n > x * y: n,x,y = n-x*y,x+1,y*10
a = str(10 ** (x - 1) + n // x)[n%x]
print(a)
",O(logn)
"a = int(input())
b = input()
s = 0
for i in range(a-2):
    if b[i:i+3] == 'xxx':
        s = s + 1
print(s)",O(n)
"class Solution(object):
    def countDistinct(self, nums, k, p):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for i in range(len(nums)):
            cnt = 0
            curr = trie
            for j in range(i, len(nums)):
                cnt += (nums[j]%p == 0)
                if cnt > k:
                    break
                if nums[j] not in curr:
                    result += 1
                curr = curr[nums[j]]
        return result",O(n ^ 2)
"n,m=map(int, input().split())
cols=[]
for i in range(n):
    cols.append(int(input()))
rows=[]
for i in range(m):
    k=list(map(int, input().split()))
    if k[0]==1:
        rows.append(k[1])
ans=n+m
cols.sort()
rows.sort()
cols.append(int(1e9))
j=0
rem=0

for i in cols:
    while j<len(rows) and rows[j]<i:
        j+=1
    ans=min(ans, len(rows)-j+rem)
    rem+=1
print(ans)
",O(nlogn)
"class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)",O(n)
"class Solution(object):
    def buildArray(self, nums):
        for i in range(len(nums)):
            prev, curr = i, nums[i]
            while curr >= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in range(len(nums)):
            if nums[i] < 0:
                nums[i] = ~nums[i]
        return nums",O(n)
"class Solution(object):
    def minimumTime(self, nums1, nums2, x):
        dp = [0]*(len(nums1)+1)
        for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):
            for j in reversed(range(1, i+1)):
                dp[j] = max(dp[j], dp[j-1]+(a+j*b))
        total1, total2 = sum(nums1), sum(nums2)
        return next((j for j in range(len(dp)) if (total1+j*total2)-dp[j] <= x), -1)",O(n ^ 2)
"
import collections


class Solution(object):
    def distanceK(self, root, target, K):
        def dfs(parent, child, neighbors):
            if not child:
                return
            if parent:
                neighbors[parent.val].append(child.val)
                neighbors[child.val].append(parent.val)
            dfs(child, child.left, neighbors)
            dfs(child, child.right, neighbors)

        neighbors = collections.defaultdict(list)
        dfs(None, root, neighbors)
        bfs = [target.val]
        lookup = set(bfs)
        for _ in range(K):
            bfs = [nei for node in bfs
                   for nei in neighbors[node]
                   if nei not in lookup]
            lookup |= set(bfs)
        return bfs

",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",O(n ^ 2)
"n = int(input())
for q in range(n):
    x, y, k = map(int, input().split())
    if max(x, y) > k:
        print(-1)
    else:
        if 0 == (x + y) % 2:
            if k % 2 == max(x, y) % 2:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",O(1)
"class Solution(object):
    def minimumOperations(self, nums):
        result = 0
        left, right = 0, len(nums)-1
        l, r = nums[left], nums[right]
        while left < right:
            if l == r:
                left += 1
                right -= 1
                l, r = nums[left], nums[right]
                continue
            if l < r:
                left += 1
                l += nums[left]
            else:
                right -= 1
                r += nums[right]
            result += 1
        return result",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"def solve(board):
  n=len(board)
  ans=0
  for i in range(n):
    for j in range(n):
      if board[i][j] is 'X':
        ans+=2**(i*n+j)
  return ans

def reverse_array(arr):
  for i in range(len(arr)):
    arr[i].reverse()

def rotate(matrix, degree):
    if degree == 0:
        return matrix
    elif degree > 0:
        return rotate(zip(*matrix[::-1]), degree-90)
    else:
        return rotate(zip(*matrix)[::-1], degree+90)

def make_list(board):
    board=list(board)
    arr=[]
    for i in range(len(list(board))):
        arr.append(list(board[i]))
    return arr

def add_rotations(board,st):
  for i in range(4):
    st.add(solve(board))
    reverse_array(board)
    st.add(solve(board))
    reverse_array(board)
    board=make_list(rotate(board, 90))

n=int(input())
arr1=[]
arr2=[]
for _ in range(n):
    arr1.append(list(input().strip()))
for _ in range(n):
    arr2.append(list(input().strip()))
s=set()
s.add(solve(arr1))
add_rotations(arr1,s)
l1=len(s)

s.add(solve(arr2))
add_rotations(arr2,s)

l2=len(s)
if l1==l2:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"mod = 1000000007
x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod
    print(ans)",O(logn)
"T = int(input())
for ti in range(T):
    s = input().strip()
    t = input().strip()
    N = len(t)
    for i in range(1, N+1):

        dp = [[0]+[-1]*i for _ in range(len(s)+1)]
        for l, c in enumerate(s):
            for j in range(i+1):
                dp[l+1][j] = dp[l][j]

                if dp[l][j] != -1:
                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:
                        dp[l+1][j] = dp[l][j]+1

                if j != 0 and c == t[j-1]:
                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])

        if dp[-1][i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")
",O(n ^ 3)
"n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

matrix = list()
for i in range(n):
    s = input()
    matrix.append(s)

for i in range(n):
    left = matrix[i].find('B')
    if left != -1:
        top[0] = i
        top[1] = left
        break

for i in range(n-1, -1, -1):
    right = matrix[i].rfind('B')
    if right != -1:
        bottom[0] = i
        bottom[1] = right
        break

print(1 + top[0] + (bottom[0] - top[0]) // 2, 1 + top[1] + (bottom[1] - top[1]) // 2)
",O(n ^ 2)
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n):
        return(0)
    if(k == 2*n or k==1):
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)
        for j in range(k):
            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo
            if(j >= 1):
                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo

        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())",np
"n,k=map(int,input().split())
mod=998244353
dp=[[0,0,0,0] for _ in range(k+1)]

dp[1][0]=dp[1][3]=1
if k>1:
    dp[2][2]=dp[2][1]=1
for x in range(1,n):
    g=[[0,0,0,0] for _ in range(k+1)]

    g[1][0]=g[1][3]=1
    for i in range(2,k+1):
        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod
        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod
    dp=g
print(sum(dp[-1])%mod)",np
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
maxx=0
arr=[0]*(n+1)
for i in range(n):
    summ=0
    for j in range(i,n):
        summ+=lst[j]
        arr[j-i]=max(arr[j-i], summ/(j-i+1))
print(max(arr[m-1:]))",O(n ^ 2)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return None

        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
",O(n)
"def maxXORInRange(L, R):

	LXR = L ^ R
	msbPos = 0
	while(LXR):

		msbPos += 1
		LXR >>= 1
	maxXOR, two = 0, 1

	while (msbPos):

		maxXOR += two
		two <<= 1
		msbPos -= 1

	return maxXOR

L, R = [int(i) for i in input().split()]
print(maxXORInRange(L, R))
",O(logn)
"a = int(input())
b = list(map(int, input().split()))
c = [int(i % 2 == 0) for i in b]
if(c.count(1) == 1):
	print(c.index(1) + 1)
else:
	print(c.index(0) + 1)
",O(n)
"class Solution2(object):
    def climbStairs(self, n):
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current,
        return current",O(n)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
while len(a) > 0:
    k = a.pop(0)
    a = [i for i in a if i % k != 0]
    ans += 1

print(ans)
",O(n ^ 2)
"from decimal import *
ar = [list(map(float, input().split())) for i in range(int(input()))]
dp = [[0 for i in range(1 << 18)] for j in range(18)]
n, ans = len(ar), 0
dp[0][(1 << n) - 1] = 1
for i in range((1 << n) - 1, 0, -1):
    for j in range(n):
        if i & (1 << j) == 0:
            continue
        for k in range(n):
            if i & (1 << k) != 0 or j == k:
                continue
            dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k])
for i in range(n):
    ans = max(ans, dp[i][1 << i])
print('{:.6f}'.format(ans))",np
"n = int(input())
x, y = map(int, input().split())

if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):
    print('White')
else:
    print('Black')
",O(1)
"class Solution2(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return sum(parity(x) == 0 for x in range(1, num+1))",O(nlogn)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    def __init__(self):
        n, m = map(int, input().strip().split())
        segs = list()
        for i in range(m):
            segs.append(list(map(int, input().strip().split())))

        def calc(s, segs):
            res = 0
            for x in segs:
                ones = sum(s[x[0]:x[1] + 1])
                res += ones * (x[1] - x[0] + 1 - ones)
            return res

        s1 = [0 for i in range(n)]
        s2 = [1 for i in range(n)]
        for i in range(n):
            if i % 2 == 0:
                s1[i] = 1
                s2[i] = 0

        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2
        print(''.join(map(str, ans)))

solver()",O(n)
"t = int(input())

def sol(n, k):
    p = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += (2*p-1)*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",O(logn)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
        return root
",O(n ^ 2)
"
class Node(object):
    def __init__(self, val, left, right):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def treeToDoublyList(self, root):
        if not root:
            return None
        left_head, left_tail, right_head, right_tail = root, root, root, root
        if root.left:
            left_head = self.treeToDoublyList(root.left)
            left_tail = left_head.left
        if root.right:
            right_head = self.treeToDoublyList(root.right)
            right_tail = right_head.left
        left_tail.right, right_head.left = root, root
        root.left, root.right = left_tail, right_head
        left_head.left, right_tail.right = right_tail, left_head
        return left_head

",O(n)
"class Solution2(object):
    def average(self, salary):
        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)",O(n)
"def binary_search(n, k):
    left = -1
    right = n
    while left < right - 1:
        middle = (left + right) // 2
        if middle % 2 != 0:
            s = (1 + middle) * (middle // 2) + ((1 + middle) // 2)
        else:
            s = (1 + middle) * (middle // 2)
        if s - (n - middle) >= k:
            right = middle
        else:
            left = middle
    return right

n, k = map(int, input().split())
i = 1
count = 0
print(n - binary_search(n, k))",O(logn)
"class Solution(object):
    def findTheLongestSubstring(self, s):
        VOWELS = ""aeiou""
        result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS))
        lookup[0] = -1
        for i, c in enumerate(s):
            index = VOWELS.find(c)
            mask ^= (1 << index) if index >= 0 else 0
            if lookup[mask] == -2:
                lookup[mask] = i
            result = max(result, i-lookup[mask])
        return result",O(n)
"import heapq


class Solution(object):
    def findSecondMinimumValue(self, root):
        def findSecondMinimumValueHelper(root, max_heap, lookup):
            if not root:
                return
            if root.val not in lookup:
                heapq.heappush(max_heap, -root.val)
                lookup.add(root.val)
                if len(max_heap) > 2:
                    lookup.remove(-heapq.heappop(max_heap))
            findSecondMinimumValueHelper(root.left, max_heap, lookup)
            findSecondMinimumValueHelper(root.right, max_heap, lookup)

        max_heap, lookup = [], set()
        findSecondMinimumValueHelper(root, max_heap, lookup)
        if len(max_heap) < 2:
            return -1
        return -max_heap[0]",O(n)
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)
",O(1)
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True

def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""

n = int(input())

print(lucky(n))",O(1)
"def main():
    n, k = map(int, input().split())
    n -= 1
    k -= 1
    if n == 0:
        minSplitters = 0
    elif n <= k:
        minSplitters = 1
    elif n > sum_consecutive(k):
        minSplitters = -1
    else:
        minSplitters = min_splitters(n, k)

    print(minSplitters)

def min_splitters(n, k):
    low, high = 1, k
    while low < high:
        mid = (low + high) // 2
        summation = sum_consecutive2(mid, k)
        if summation == n:
            return k - mid + 1
        elif summation > n:
            low = mid + 1
        else:
            high = mid

    return k - low + 2

def sum_consecutive(num):
    return int(0.5 * num * (num + 1))

def sum_consecutive2(num1, num2):
    return sum_consecutive(num2) - sum_consecutive(num1 - 1)

if __name__ == '__main__':
    main()
",O(logn)
"from collections import defaultdict as dd
d=dd(int)
n,m=map(int,input().split())
arr=list(map(int,input().split()))
has=False
count=0
d[0] =1
total=0
for i in range(n):
    if arr[i] >m:
        count  +=1
    if arr[i] <m:
        count -=1
    if arr[i] ==m:
        has=True
    if has:
        total +=d[count] +d[count-1]
    else:
        d[count] +=1
print(total)",O(nlogn)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",O(n ^ 2)
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0

ans=sum(dp[k])
ans%=mod
print(ans)
",np
"class Solution(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center
        x = x1 if x1 > 0 else x2 if x2 < 0 else 0
        y = y1 if y1 > 0 else y2 if y2 < 0 else 0
        return x**2 + y**2 <= radius**2",O(1)
"class Solution(object):
    def averageWaitingTime(self, customers):
        avai = wait = 0.0
        for a, t in customers:
            avai = max(avai, a)+t
            wait += avai-a
        return wait/len(customers)",O(n)
"a,b=input().split()
if(a==b):
    print(""0"")
else:
    xor=bin(int(a)^int(b))[2:]
    a=bin(int(a))[2:]
    b=bin(int(b))[2:]
    ans=""""
    if a[0]==b[0]:
        ans+=""0""
    else:
        ans+=""1""
    for i in range(len(xor)):
        ans+=""1""
    print(int(ans,2))
",O(logn)
"def prefix_func(s):
    slen, k = len(s), 0
    p = [0]*slen
    p[0] = 0
    for i in range(1, slen):
        while k>0 and s[k] != s[i]:
            k = p[k-1]
        if s[k] == s[i]:
            k += 1
        p[i] = k
    return p
n,k=map(int,input().split())
s=input()
l=prefix_func(s)[-1]
print(s+s[l:]*(k-1))
",O(n ^ 2)
"import sys
input=sys.stdin.buffer.readline
from collections import defaultdict as dd
n=int(input())
d=dd(int)
for i in range(n):
    l,r=map(int,input().split())
    d[l] +=1
    d[r+1] -=1
arr=list(d.keys())
arr.sort()
ans=[0 for i in range(n+1)]
count =0
l=len(arr)
arr.append(arr[-1])
for i in range(l):
    count +=d[arr[i]]
    ans[count] +=arr[i+1] -arr[i]
print(*ans[1:])",O(nlogn)
"import sys

input = sys.stdin.readline

a, b= map(int,input().split())

if a == b:
    print(0)

else:
    x = a ^ b
    c = 1

    while x:
        x >>= 1
        c <<= 1

    print(c-1)",O(logn)
"def reach_max(n, k):
    return n * k + 1 - n * (n + 1) // 2

n, k = map(int, input().split())

if n == 1:
    print(0)
    exit()

lo, hi = 1, k - 1

if n > reach_max(hi, k):
    print(-1)
    exit()

while lo < hi:
    mid = (lo + hi) // 2
    if reach_max(mid, k) < n:
        lo = mid + 1
    else:
        hi = mid

print(lo)
",O(logn)
"from math import ceil
N = int(input())
S = (N * (N + 1)) / 2
F = int(ceil(N /2.0))
ans = int((S + F) / 2)
print(ans)",O(n)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])
",np
"class Solution2(object):
    def numTrees(self, n):
        counts = [1, 1]
        for i in range(2, n + 1):
            count = 0
            for j in range(i):
                count += counts[j] * counts[i - j - 1]
            counts.append(count)
        return counts[-1]",O(n ^ 2)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",np
"n=int(input())
arr=[int(x) for x in input().split()]
pos=dict()
if(n==1):print(""B"")
else:
    for i in range(n):
        pos[arr[i]]=i
    ans=[""Q""]*n

    ans[pos[1]]=""A""
    ans[pos[n]]=""B""
    for i in range(n-1,0,-1):
        flag=0
        p=pos[i]
        j=1
        while(p+j*i<n):
            if(ans[p+j*i]==""B""):
                flag=1
                ans[pos[i]]=""A""
                break
            j+=1
        if(flag==0):
            j=1
            while(p-j*i>=0):
                if(ans[p-j*i]=='B'):
                    flag=1
                    ans[pos[i]]=""A""
                    break
                j+=1
        if(flag==0):ans[pos[i]]=""B""
    print("""".join(ans))
",O(nlogn)
"n,k=map(int,input().split())
for i in range(10**5):
  if (i*(i+1))//2-(n-i)==k:
    print(n-i)",O(1)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(1)
"def go():
    n = int(input())
    a = [i for i in input()]
    x = 0
    for i in a:
        if i == '-':
            x = max(0, x - 1)
        else:
            x += 1
    return x

print(go())
",O(n)
"import sys
import math

t=1
for _ in range(t):

    a=input()
    b=input()
    dp=[0]*(11)
    for i in a:
        dp[int(i)]+=1

    if len(b)>len(a):
        ans=''
        for i in range(len(a)):
            for j in range(9,-1,-1):
                if dp[j]!=0:
                    ans+=str(j)
                    dp[j]-=1
                    break
    elif len(a)==len(b):
        ans=''
        a1=[]
        cmpr=''
        i=0
        while i<len(a):
            cmpr+=b[i]

            if i==0:
                flag=0
                for j in range(9,0,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        dp[j]-=1
                        ans+=str(j)
                        a1.append(j)
                        break
                if flag==0:
                    dp[1]-=1
                    a1.append(1)
                    ans+='1'
            else:
                flag=0
                for j in range(9,-1,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        ans+=str(j)
                        a1.append(j)
                        dp[j]-=1
                        break

                if flag==0:
                    ch=0
                    for i1 in range(i-1,-1,-1):
                        if ch==1:
                            break
                        for j1 in range(int(ans[i1])-1,-1,-1):
                            if i1==0:
                                if j1>0 and dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    index=i1
                                    a1.pop()
                                    a1.append(j1)
                                    ch=1
                                    break
                            else:
                                if  dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    a1.pop()
                                    index=i1

                                    a1.append(j1)
                                    ch=1
                                    break
                            if ch==1:
                                break
                        if ch==1:
                            break
                        val=a1.pop()
                        dp[val]+=1

                    ans=''
                    cmpr=''

                    dp=[0]*11
                    for i1 in range(len(a)):
                        dp[int(a[i1])]+=1

                    for i1 in range(len(a1)):
                        dp[a1[i1]]-=1

                    for i1 in range(len(a1)):
                        ans+=str(a1[i1])
                        cmpr+=b[i1]
                    i=index

            i+=1
    print(ans)",O(n ^ 3)
"class Solution3(object):
    def invertTree(self, root):
        if root is not None:
            root.left, root.right = self.invertTree(root.right), \
                                    self.invertTree(root.left)

        return root",O(n)
"
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child


class Solution(object):
    def flatten(self, head):
        curr = head
        while curr:
            if curr.child:
                curr_next = curr.__next__
                curr.child.prev = curr
                curr.next = curr.child
                last_child = curr
                while last_child.__next__:
                    last_child = last_child.__next__
                if curr_next:
                    last_child.next = curr_next
                    curr_next.prev = last_child
                curr.child = None
            curr = curr.__next__
        return head

",O(n)
"class Solution(object):
    def canBeTypedWords(self, text, brokenLetters):
        lookup = set(brokenLetters)
        result, broken = 0, False
        for c in text:
            if c == ' ':
                result += int(broken == False)
                broken = False
            elif c in lookup:
                broken = True
        return result + int(broken == False)",O(n)
"k,n,s,p = map(int,input().split())
print(int((int((n+s-1)/s)*k+p-1)/p))",O(1)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        xorr = n
        for i in range(n):
            xorr ^= i ^ nums[i]
        return xorr
",O(n)
"from collections import defaultdict
from math import gcd
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
dp = defaultdict(lambda: float(""inf""))
for a, b in zip(A, B):
    dp[a] = min(dp[a], b)
    for d in dp.copy():
        cur = gcd(a, d)
        dp[cur] = min(dp[cur], dp[a] + dp[d])
if 1 not in dp:
    print(-1)
else:
    print(dp[1])",np
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))
    idx = arr.index(n)
    ok = 1
    for i in range(1, idx):
        if arr[i] < arr[i - 1]:
            ok = 0
    for i in reversed(range(idx, n - 1)):
        if arr[i] < arr[i + 1]:
            ok = 0
    if ok:
        print(""YES"")
    else:
        print(""NO"")

    return 0

main()",O(n)
"s = input()

def check_x(mid):
    ans = 'no'
    d = {}
    for i in range(len(s)-mid+1):

        if s[i:i+mid] in d.keys():
            ans = 'yes'
            break
        d[s[i:i+mid]] = 1

    return ans

l = 0
r = len(s) - 1
while r-l > 1:
    mid = (r+l) // 2

    ans = check_x(mid)
    if ans == 'yes':
        l = mid
    else:
        r = mid

if check_x(r) == 'yes':
    print(r)
else:
    print(l)
",O(n ^ 3)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res
p = 1000000007
x = [int(i) for i in raw_input().split()]
y = power(2,x[1],p)

if(x[0]>0):
    ans = 2 * y * x[0]%p - (y - 1)%p
else:
    ans = 0
print(ans%p)",O(logn)
"from sortedcontainers import SortedList



class Solution(object):
    def shortestDistanceAfterQueries(self, n, queries):
        sl = SortedList(range(n))
        result = []
        for u, v in queries:
            for i in reversed(range(sl.bisect_right(u), sl.bisect_left(v))): 
                sl.pop(i)
            result.append(len(sl)-1)
        return result",O(nlogn)
"rnd_mod = 1234567890133
rnd_x = 987654321098
def rnd():
    global rnd_x
    rnd_x = rnd_x**2 % rnd_mod
    return (rnd_x>>5) % (1<<20)
def randrange(a):
    return rnd() % a

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    X = []
    for __ in range(N):
        X.append([int(a) for a in input().split()])
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(577):
        for i in range(M):
            a = randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np
"k = int(input())

if k <= 9:
	print(k)

else:
	s = 9
	n = 1

	while s < k:
		n += 1
		prev_s = s
		s += (10**n - 10**(n-1)) * n

	digit_pos = k - (prev_s + 1)
	number = 10**(n-1) + digit_pos // n

	if digit_pos / n != digit_pos // n:
		digit_pos = digit_pos - (digit_pos // n) * n

	else:
		digit_pos = 0

	print(str(number)[digit_pos])",O(logn)
"class Solution2(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0} 
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.items():
                for k2, v2 in right.items():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]",O(n)
"n=int(input())
w=[int(k) for k in input().split()]
c={w[j]:j+1 for j in range(n)}

res=0
for j in range(1, n+1):
    if w[j-1]==j:
        pass
    else:
        res+=1
        y=w[j-1]
        w[j-1]=j
        w[c[j]-1]=y
        r=c[j]
        c[j]=j
        c[y]=r
if n%2==0:
    if res%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")
else:
    if res%2:
        print(""Petr"")
    else:
        print(""Um_nik"")
",O(nlogn)
"n, k = map(int, input().split())
m = 1000000007
if n == 0:
    print(0)
    exit(0)
r = pow(2, k+1, m)*n - pow(2, k, m) + 1
print(r % m)
",O(logn)
"class Solution3(object):
    def flipEquiv(self, root1, root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2 or root1.val != root2.val:
            return False

        return (self.flipEquiv(root1.left, root2.left) and
                self.flipEquiv(root1.right, root2.right) or
                self.flipEquiv(root1.left, root2.right) and
                self.flipEquiv(root1.right, root2.left))",O(n)
"k=int(input())

num_digits=1
num_numbers=9

k-=1
while k>num_digits*num_numbers:

    k -= num_numbers*num_digits
    num_digits += 1
    num_numbers *= 10

number = 10**(num_digits - 1) + k // num_digits

index = k % num_digits
answer = str(number)[index]
print(answer)",O(1)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result",O(nlogn)
"x,y=map(int,input().strip().split())
if(abs(x-y)<2):
    print(-1)
else:
    k=[]
    for i in range(x,y+1):
        if(i%2==0):
            k.append(i)
            if(i+1<y):
                k.append(i+1)
                k.append(i+2)
                break
    if(len(k)==3):
        print("" "".join(str(t) for t in k))
    else:
        print(-1)",O(1)
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

def solve2(s, t, left, right):
    n = len(s)
    m = len(t)
    nuxt = [-1]*(left+1)
    nuxt[0] = 0

    for i in range(n):
        for j in reversed(range(left+1)):
            k = nuxt[j]
            if k == -1:
                continue
            if j != left:
                if s[i] == t[j]:
                    nuxt[j+1] = max(nuxt[j+1], k)
            if k != right:
                if s[i] == t[left+k]:
                    nuxt[j] = max(nuxt[j], k+1)
    return nuxt[-1]==right

def solve():
    s = input()
    t = input()
    m = len(t)
    for i in range(m+1):
        if solve2(s,t,i,m-i):
            print(""YES"")
            return
    print(""NO"")

t = int(input())
for i in range(t):
    solve()
",O(n ^ 3)
"import sys
readline = sys.stdin.buffer.readline

N = int(readline())
A = list(map(int, readline().split()))

dp = [[0]*N for _ in range(N)]
for j in range(N):
    dp[j][0] = A[j]

for l in range(1, N):
    for j in range(l, N):
        for k in range(j-l, j):
            if dp[k][k-j+l] == dp[j][j-k-1] > 0:
                dp[j][l] = 1+dp[j][j-k-1]
                break

dp = [None] + dp
Dp = [0]*(N+1)
for j in range(1, N+1):
    res = N
    for l in range(j):
        if dp[j][l]:
            res = min(res, 1+Dp[j-l-1])
    Dp[j] = res
print(Dp[N])
",O(n ^ 3)
"n,l,r,x=map(int,input().split())
c=list(map(int,input().split()))
c.sort()
p=1<<n
cnt=0
for j in range(p):
    list1=[]
    if(j>0 and j&(j-1)!=0):
        for k in range(n):
            if(j&(1<<k)):
                list1.append(c[k])
        if(sum(list1)>=l and sum(list1)<=r and list1[-1]-list1[0]>=x):
            cnt+=1
print(cnt)",np
"import collections


class Solution(object):
    def findShortestSubArray(self, nums):
        counts = collections.Counter(nums)
        left, right = {}, {}
        for i, num in enumerate(nums):
            left.setdefault(num, i)
            right[num] = i
        degree = max(counts.values())
        return min(right[num]-left[num]+1 \
                   for num in list(counts.keys()) \
                   if counts[num] == degree)",O(n)
"import math

n, r = map(int, input().split())

a = math.pi/n
sin = math.sin(a)
R = r*sin/(1-sin)

print(R)",O(1)
"import collections



class Solution(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                while dq and not check(nums[dq[-1]], nums[right]):
                    i = dq.pop()
                    cnt = i-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                    total -= cnt*nums[i]
                cnt = right-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                dq.append(right)
                total += cnt*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0]]
                    if dq[0] == right-(k-1):
                        dq.popleft()
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)",O(n)
"n, m = map(int, input().split())
y = []
for i in range(n):
    y.append(int(input()))
y.append(10 ** 9)
x = []
for i in range(m):
    a, b, c = map(int, input().split())
    if a == 1:
        x.append(b)
y.sort(); x.sort()
m = len(x)
ans = m
k = 0
for i in range(n + 1):
    ok = True
    for j in range(k, m):
        if y[i] <= x[j]:
            k = j
            ok = False
            break
    if ok:
        k = m
        ans = min(ans, m - k + i)
        break
    ans = min(ans, m - k + i)
print(ans)
",O(nlogn)
"n = int(input())
pairs = [list(map(int, input().split()))+[i] for i in range(n)]
pairs.sort(key=lambda x:(x[0], -x[1]))
for i in range(1, n):
    if pairs[i][1] <= pairs[i-1][1]:
        print(pairs[i][2]+1, pairs[i-1][2]+1)
        break
else:
    print(-1, -1)",O(nlogn)
"def forninho(miolo, s):
    premiolo = miolo
    temp = 0
    while (miolo > 0):
        temp += miolo % 10;
        miolo = miolo // 10;
    if (premiolo - temp >= s):
        return 1
    else:
        return 0

entrada = input().split()
n = int(entrada[0])
s = int(entrada[1])

result = -1
l = 1
r = n
while (r-l >= 0):
    miolo = (l + r) // 2
    if(forninho(miolo,s) == 1):
        r = miolo - 1
        result = miolo
    else:
        l = miolo + 1

if (result == -1):
    print(""0"")
else:
    print(n - result + 1)
",O(logn)
"from bisect import bisect_left

def readint():
    return int(input())

def readline():
    return [int(c) for c in input().split()]

def main():
    MAX = 10**9
    n, m = readline()
    v = sorted([readint() for _ in range(n)])

    h = []
    for _ in range(m):
        x1, x2, _ = readline()
        if x1 == 1:
            h.append(x2)
    h.sort()

    lh = len(h)
    if lh == 0:
        print(0)
    elif n == 0:
        print(lh - bisect_left(h, MAX))
    else:
        mn = n + lh - bisect_left(h, MAX)
        for i in range(n):
            mn = min(mn, lh - bisect_left(h, v[i]) + i)
        print(mn)

if __name__ == '__main__':
    main()
",O(nlogn)
"import sys

def dp(ri, gi, bi):
    if ri>r or gi>g or bi>b:
        return 0

    if not list_memo[ri][gi][bi]==-1:
        return list_memo[ri][gi][bi]

    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])
    return list_memo[ri][gi][bi]

r, g, b = map(int, sys.stdin.readline().split())

r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)

list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

print(dp(0, 0, 0))",O(n ^ 3)
"class Solution(object):
    def resultArray(self, nums):
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            if a[-1] > b[-1]:
                a.append(nums[i])
            else:
                b.append(nums[i])
        return a+b",O(n)
"class Solution(object):
    def mostCompetitive(self, nums, k):
        stk = []
        for i, x in enumerate(nums):
            while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k:
                stk.pop()
            if len(stk) < k:
                stk.append(x)
        return stk",O(n)
"l,r=map(int,input().split())
p=bin(l)
p=p[2:]
q=bin(r)
q=q[2:]

t=len(q)
u=len(p)
p=(t-u)*'0'+p
ans=[]

for i in range(len(q)):
    if(q[i]=='1' and p[i]=='0'):
        ans.append(1)
        break;
    elif(q[i]=='1' and p[i]=='1'):
        ans.append(0)
        continue;
    elif(q[i]=='0' and p[i]=='1'):
        ans.append(1)
        continue;
    else:
        ans.append(0)
for j in range(i+1,len(p)):
        ans.append(1)
total=0

ans.reverse()

for i in range(len(ans)):
    total+=pow(2,i)*ans[i]

print(total)
",O(logn)
"from collections import namedtuple

Point = namedtuple(""Point"", ""x y"")
Square = namedtuple(""Square"", ""left right top bottom"")
Triangle = namedtuple(""Triangle"", ""left top"")

a = [int(v) for v in input().split()]
b = [int(v) for v in input().split()]

a = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)]
b = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)]

bc = Point(sum(p.x for p in b) // 4, sum(p.y for p in b) // 4)
bb = [None] * 4
for p in b:
    if p.x < bc.x:
        bb[0] = p
    elif p.y > bc.y:
        bb[1] = p
    elif p.x > bc.x:
        bb[2] = p
    elif p.y < bc.y:
        bb[3] = p
    else:
        assert False

def in_sqr(sqr, pt):
    return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top

def in_tri(tri, pt):
    return (
        tri.left.x <= pt.x <= tri.top.x and
        tri.left.y <= pt.y <= tri.top.y and
        pt.y - tri.left.y <= pt.x - tri.left.x
    )

def solve_sqr_tri(sqr, tri):
    return (
        in_sqr(sqr, tri.left) or
        in_sqr(sqr, tri.top) or
        in_sqr(sqr, Point(tri.top.x, tri.left.y)) or
        in_tri(tri, Point(sqr.left, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.bottom)) or
        in_tri(tri, Point(sqr.left, sqr.bottom))
    )

def rotate90(pt):
    return Point(-pt.y, pt.x)

def iterate_rot(pt, times):
    for _ in range(times):
        pt = rotate90(pt)
    return pt

def solve_sqr_sqr45(sqr_pts, sqr45):
    for i in range(4):
        tri_pts = sqr45[i], sqr45[(i + 1) % 4]
        left, top = [iterate_rot(pt, i) for pt in tri_pts]

        assert left.x < top.x
        assert left.y < top.y

        tri = Triangle(left=left, top=top)

        sqr = Square(
            left=min(p.x for p in sqr_pts),
            right=max(p.x for p in sqr_pts),
            top=max(p.y for p in sqr_pts),
            bottom=min(p.y for p in sqr_pts),
        )

        if solve_sqr_tri(sqr, tri):
            return True

        sqr_pts = [rotate90(pt) for pt in sqr_pts]

    return False

print([""NO"", ""YES""][solve_sqr_sqr45(a, bb)])
",O(1)
"from random import randint
from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.__list = []
        self.__used = defaultdict(list)


    def insert(self, val):
        has = val in self.__used

        self.__list += (val, len(self.__used[val])),
        self.__used[val] += len(self.__list)-1,

        return not has


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[val][-1]
        self.__list[self.__used[val][-1]], self.__list[-1] = self.__list[-1], self.__list[self.__used[val][-1]]

        self.__used[val].pop()
        if not self.__used[val]:
            self.__used.pop(val)
        self.__list.pop()

        return True

    def getRandom(self):
        return self.__list[randint(0, len(self.__list)-1)][0]",O(1)
"import sys
def ints():
    return list(map(int, sys.stdin.readline().strip().split()))
tc = 1
while tc:
    tc-=1
    n, k = map(int, input().split())
    l = -1
    r = n+1
    while r-l > 1:
        m = (r+l)//2
        if (n-m)*(n-m+1)//2 - m > k:
            l = m
        else:
            r = m
    print(r)",O(logn)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
diameter = 2*k

for i,level in enumerate(d):
    if level == diameter:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

if center == -1:
    print(""NO"")
    exit()

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"class Solution(object):
    def calculateScore(self, instructions, values):
        result = 0
        lookup = [False]*len(instructions)
        i = 0
        while 0 <= i < len(instructions):
            if lookup[i]:
                break
            lookup[i] = True
            if instructions[i] == ""add"":
                result += values[i]
                i += 1
            else:
                i += values[i]
        return result",O(n)
"class Solution(object):
    def getAverages(self, nums, k):
        total, l = 0, 2*k+1
        result = [-1]*len(nums)
        for i in range(len(nums)):
            total += nums[i]
            if i-l >= 0:
                total -= nums[i-l]
            if i >= l-1:
                result[i-k] = total//l
        return result",O(n)
"import sys
from math import gcd
from collections import defaultdict as dd
input=sys.stdin.readline
n=int(input())
l=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=dict()
for i in range(n):
    if dp.get(l[i]):
        dp[l[i]]=min(dp[l[i]],c[i])
    else:
        dp[l[i]]=c[i]
for ll in l:
    keys=list(dp.keys())
    for j in keys:
        g=gcd(j,ll)
        if dp.get(g):
            dp[g]=min(dp[g],dp[ll]+dp[j])
        else:
            dp[g]=dp[ll]+dp[j]
if 1 in dp:
    print(dp[1])
else:
    print(-1)",np
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):
        result = [None]
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret[0] = Node(node.val)
                for child in reversed(node.children):
                    ret1 = [None]
                    stk.append((2, (ret1, ret)))
                    stk.append((1, (child, ret1)))
            else:
                ret1, ret = params
                ret[0].children.append(ret1[0])
        return result[0]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructFromPrePost(self, pre, post):
        stack = [TreeNode(pre[0])]
        j = 0
        for i in range(1, len(pre)):
            node = TreeNode(pre[i])
            while stack[-1].val == post[j]:
                stack.pop()
                j += 1
            if not stack[-1].left:
                stack[-1].left = node
            else:
                stack[-1].right = node
            stack.append(node)
        return stack[0]",O(n)
"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []

        def dfs(node, depth):
            if not node:
                return None
            if len(res) == depth:
                res.append([])

            res[depth].append(node.val)
            dfs(node.left, depth + 1)
            dfs(node.right, depth + 1)

        dfs(root, 0)
        return res
",O(n)
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)
",O(n ^ 2)
"class Solution(object):
    def countCollisions(self, directions):
        result = cnt = 0
        smooth = 1
        for x in directions:
            if x == 'R':
                cnt += 1
            elif x == 'S' or (cnt or not smooth):
                result += cnt+int(x == 'L')
                cnt = smooth = 0
        return result",O(n)
"games,bills = map(int,input().split())
g = list(map(int,input().split()))
b=list(map(int,input().split()))
total = 0
i=0
j=0

while(i < games and j < bills):
    if g[i] <= b[j]:
        total+=1
        i+=1
        j+=1
    elif g[i] > b[j]:
        i+=1
print(total)",O(n)
"from collections import deque as de
import math
from math import sqrt as sq
from math import floor as fl
from math import ceil as ce
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb

from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())

    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True

def primes_method5(n):
    out ={}
    sieve = [True] * (n+1)
    for p in range(2, n+1):
        if (sieve[p]):
            out[p]=1
            for i in range(p, n+1, p):
                sieve[i] = False
    return out

def getSum(n):

    strr = str(n)
    list_of_number = list(map(int, strr.strip()))
    return sum(list_of_number)

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(value)] = int(index)+1
    return dic
def frqdict():

    dic={}
    for index, value in enumerate(input()):
        if value not in dic:
            dic[value] =1
        else:
            dic[value] +=1
    return dic

n=ii()
a=sorted(li())
if a[n-1]==1:
    a[n-1]=2
else:
    a[n-1]=1
a.sort()
print(*a)
",O(nlogn)
"import itertools


class Solution(object):
    def climbStairs(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]",O(logn)
"class Solution(object):
    def maximumOr(self, nums, k):
        right = [0]*(len(nums)+1)
        for i in reversed(range(len(nums))):
            right[i] = right[i+1]|nums[i]
        result = left = 0
        for i in range(len(nums)):
            result = max(result, left|(nums[i]<<k)|right[i+1])
            left |= nums[i]
        return result",O(n)
"class Solution(object):
    def minimumChairs(self, s):
        result = curr = 0
        for x in s:
            curr += +1 if x == ""E"" else -1
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def canThreePartsEqualSum(self, A):
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts >= 3",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, k = map(int, stdin.readline().split())
stdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))",O(1)
"n,m=map(int,input().split())
arr=[]
for i in range(m):
    arr.append(list(map(int,input().split())))
count=0
for i in range(m):
    count +=arr[i][0] *(n)
    if n %2==1 and arr[i][1] <0:
        count +=(n//2)*(n//2 +1)*arr[i][1]
    if n %2==1 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1]//2
    if n %2==0 and arr[i][1] <0:
        count +=(n//2)*(n//2 -1)*arr[i][1]
        count +=(n//2) *arr[i][1]
    if n %2==0 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1] //2
print(count /n)",O(n)
"from math import ceil, log
from heapq import heappop, heappush, heapify
t = 1
for test in range(t):
    n,k = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]
    maxcoins = [0 for i in range(k)]
    heapify(maxcoins)
    ans = list(p)
    tmpSum = 0
    tmpSum2 = 0
    prev = arr[0][1]
    for ind, power in arr:
        if power>prev:
            ans[ind] = tmpSum+c[ind]
            tmpSum2 = tmpSum
        else:
            ans[ind] = tmpSum2+c[ind]
        heappush(maxcoins, c[ind])
        tmpSum+=c[ind]
        tmpSum-=heappop(maxcoins)
    print(*ans)
",O(nlogn)
"n,pos,l,r=map(int,input().split())
if l==1 and r==n:
    print(0)
elif l==1:
    print(abs(pos-r)+1)
elif r==n:
    print(abs(pos-l)+1)
else:
    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)",O(1)
"class Solution(object):
    def countPalindromicSubsequences(self, S):
        def dp(i, j, prv, nxt, lookup):
            if lookup[i][j] is not None:
                return lookup[i][j]
            result = 1
            if i <= j:
                for x in range(4):
                    i0 = nxt[i][x]
                    j0 = prv[j][x]
                    if i <= i0 <= j:
                        result = (result + 1) % P
                    if None < i0 < j0:
                        result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P
            result %= P
            lookup[i][j] = result
            return result

        prv = [None] * len(S)
        nxt = [None] * len(S)

        last = [None] * 4
        for i in range(len(S)):
            last[ord(S[i])-ord('a')] = i
            prv[i] = tuple(last)

        last = [None] * 4
        for i in reversed(range(len(S))):
            last[ord(S[i])-ord('a')] = i
            nxt[i] = tuple(last)

        P = 10**9 + 7
        lookup = [[None] * len(S) for _ in range(len(S))]
        return dp(0, len(S)-1, prv, nxt, lookup) - 1",O(n ^ 2)
"from collections import defaultdict

n, a = int(input()), [int(x) for x in input().split()]
pow2 = [1 << i for i in range(32)]
mp = defaultdict()
for x in a:
    mp[x] = 1
mxSiz = 1
ans = [a[0]]
for x in a:
    for y in pow2:
        if x-y in mp and x+y in mp:
            mxSiz = 3
            ans = [x-y, x, x+y]
        if x-y in mp and 2 > mxSiz:
            mxSiz = 2
            ans = [x-y, x]

print(mxSiz)
print(*ans)
",O(nlogn)
"from sys import stdin
c=int(stdin.readline().strip())
for i in range(c):
    n=int(stdin.readline().strip())

    s=list(map(int,stdin.readline().strip().split()))
    s.sort()
    l=min(s[-1],s[-2])
    ans=min(l-1,n-2)
    print(ans)
",O(nlogn)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def removeLeafNodes(self, root, target):
        if not root:
            return None
        root.left = self.removeLeafNodes(root.left, target)
        root.right = self.removeLeafNodes(root.right, target)
        return None if root.left == root.right and root.val == target else root
",O(n)
"n = int(input())
a = [0]*n;

def fun(n,ptr1):
	global a

	if n == 1:
		a[ptr1] = 1;

	elif n == 2:

		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1] = 2;
	elif n == 3:
		a[ptr1] = 1;
		ptr1 +=1;
		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1]=3;

	else:
		itera = n - n//2;

		for i in range(itera):
			a[ptr1] = 1;
			ptr1+=1;

		fun(n//2,ptr1);
		for i in range((n//2)):
			a[ptr1] = 2*a[ptr1];
			ptr1+=1;

fun(n,0);
for i in a:
	print(i,end="" "");

print();",O(n)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

a,b,c,d,e,f=kk()
al = [a,b,c,d,e,f]
s = sum(al)
area = a*b+c*d+e*f
side = int(area**.5)
if side**2 != area or side not in al:
	print(-1)
	exit()
if al.count(side) == 3:

	if s == 4*side:
		rest = [a for a in al if a != side]
		print(side)
		for _ in range(side):
			print("""".join([""A""*rest[0], ""B""*rest[1], ""C""*rest[2]]))
elif al.count(side) > 1:
	print(-1)
else:
	x=al.index(side)
	y=x^1
	res = al[y]
	a,b=min(x,y),max(x,y)
	s1 = ""ABC""[a//2]
	s23 = [s for s in ""ABC"" if s != s1]
	rest = al[:a]+al[b+1:]
	res = side - res
	a,b=[rest[0],rest[1]],[rest[2],rest[3]]
	if not (res in a and res in b):
		print(-1)
		exit()
	o1,o2 = a[a.index(res)^1],b[b.index(res)^1]
	print(side)
	for _ in range(al[y]):
		print(s1*side)
	for _ in range(res):
		print("""".join([s23[0]*o1,s23[1]*o2]))",np
"import collections


class Solution(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        q = collections.deque()
        left = [0]
        for i in range(len(s)):
            while q and q[0][1] < i:
                q.popleft()
            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))
            q.append((i, i+P[2*i+2]//2))
        q = collections.deque()
        result = right = 0
        for i in reversed(range(len(s))):
            while q and q[0][1] > i:
                q.popleft()
            right = max(right, 1+2*(q[0][0]-i) if q else 1)
            q.append((i, i-P[2*i+2]//2))
            result = max(result, left[i]*right)
        return result",O(n)
"n = int(input())
s = input()
t = input()
p = [-1, -1]
a = [[-1] * 26 for i in range(26)]
k = 0
for i in range(n):
    if t[i] != s[i]:
        k += 1
for i in range(n):
    if t[i] != s[i]:
        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:
            print(k - 2)
            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)
            exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
for i in range(n):
    if t[i] != s[i]:
        for j in range(26):
            if a[j][ord(s[i]) - 97] != -1:
                print(k - 1)
                print(a[j][ord(s[i]) - 97] + 1, i + 1)
                exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
print(k)
print(-1, -1)
",O(n)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if k == 0:
        if n == 0 and m == 0:
            print(0)
        else:
            print(-1)
    elif k == 1:
        if max(abs(n), abs(m)) != 1:
            print(-1)
        elif abs(n) == abs(m) == 1:
            print(1)
        else:
            print(0)
    else:
        if max(abs(n), abs(m)) > k:
            print(-1)
        elif abs(n) == abs(m):
            if (k - abs(n)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:
            if (k - max(abs(n), abs(m))) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",O(1)
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)

    prev = lst[i][0]
print(ans+prev)",O(n)
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import sys
import string
import random
from typing import List
sys.setrecursionlimit(99999)

n,k = map(int,input().split())
arr = list(map(int,input().split()))
cs = collections.Counter(arr)
ks = list(cs.keys())
ks.sort()
ans= 0
for i in range(1,len(ks)):
    if ks[i]<=ks[i-1]+k:
        continue
    else:
        ans+=cs[ks[i-1]]
ans+= cs[ks[-1]]
print(ans)",O(nlogn)
"n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
hh = a[0][1]
wahh = max(-1, a[0][2])
for i in range(1, n):
    if a[i][1] >= hh:
        print(a[i][2], wahh)
        exit()
    else:
        hh = a[i][1]
        wahh = a[i][2]
print(-1, -1)
",O(nlogn)
"class Solution(object):
    def minimumOperations(self, nums, target):
        for i in range(len(target)):
            target[i] -= nums[i]
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))",O(n)
"import itertools




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])



class Solution(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEFT] = result[RIGHT] = y
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            return result

        def query(x, y):
            return x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.tree[1][MAX_LEN])
        return result",O(nlogn)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,mod = mi()

N = 1000
g1 = [1]*(N+1)
g2 = [1]*(N+1)
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    g1[i]=( ( g1[i-1] * i ) % mod )
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2[i]=( (g2[i-1] * inverse[i]) % mod )
inverse[0]=0

pow_2 = [1 for i in range(1001)]
for i in range(1,1001):
    pow_2[i] = (pow_2[i-1] * 2) % mod

dp = [[1]]

for i in range(n):
    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]
    for s in range(i+1):
        for k in range(i+1):
            if not dp[s][k]:
                continue

            if k!=0:
                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod
                ndp[s+k][0] %= mod

    dp = ndp

res = 0
for s in range(n+1):
    for k in range(1,n+1):
        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod
        res %= mod

print(res)
",O(n ^ 3)
"class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)",O(n)
"import collections


class Solution2(object):
    def averageHeightOfBuildings(self, buildings):
        count = collections.defaultdict(lambda: (0, 0))
        for x, y, h in buildings:
            count[x] = (count[x][0]+1, count[x][1]+h)
            count[y] = (count[y][0]-1, count[y][1]-h)
        result = []
        total = cnt = 0
        prev = -1
        for curr, (c, h) in sorted(count.items()):
            if cnt:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h
            cnt += c
            prev = curr
        return result",O(nlogn)
"n = int(input())
a = sorted(set(map(int, input().split())))

if len(a) > 1:
    x = iter(a)
    next(x)
    print(next(x))
else:
    print(""NO"")
",O(nlogn)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"import collections



class Solution(object):
    def maxSubarrayLength(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while not (cnt[nums[right]] <= k):
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"import sys

n, m, k = map(int, input().split())
table = [input() for _ in range(n)]

dp = [0]*(k+1)

for a in table:
    one = []
    for i in range(m):
        if a[i] == '1':
            one.append(i)

    if not one:
        continue

    ni = len(one)
    subdp = [10**9] * (ni+1)
    subdp[-1] = 0

    for i in range(ni):
        for j in range(i, ni):
            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)

    next_dp = [10**9]*(k+1)
    for i in range(k, -1, -1):
        for j in range(ni+1):
            if i+j > k:
                break
            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])
    dp = next_dp

print(min(dp))
",O(n ^ 3)
"def getIntList():
    return list(map(int, input().split()));
nbColumn, h=getIntList();
if (nbColumn-2)*2<h:
    print('NO')
else:
    print('YES')
    if h%2==0:
        print('.'*nbColumn);
        print('.'+'
        print('.'+'
        print('.'*nbColumn);
    else:
        print('.'*nbColumn);
        hFirst=min(h, nbColumn-2);
        countPoint=(nbColumn-hFirst)//2;
        print('.'*countPoint+'
        hSecond=(h-hFirst)//2;
        countPoint=nbColumn-2*hSecond-2;
        print('.'+'
        print('.'*nbColumn);",O(n)
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult

        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)

            md = min(md, d)

        if md > maxd:

            last_tree = (i, j)
            maxd = md

with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")
",O(n ^ 3)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def dfs():
            token = tokens.pop()
            if token not in ""+-*/"":
                return int(token)

            right = dfs()
            left = dfs()

            if token == '+':
                return left + right
            elif token == '-':
                return left - right
            elif token == '*':
                return left * right
            elif token == '/':
                return int(left / right)

        return dfs()
",O(n)
"import heapq
n, k = map(int, input().split())
p = list(map(int, input().split()))
c = list(map(int, input().split()))
indexes = sorted(list(range(n)), key=p.__getitem__)
most_vyg_odn_yye = []
res = [1]*n
cur_res = 0
for ind in indexes:
	this_cost = c[ind]
	heapq.heappush(most_vyg_odn_yye, this_cost)
	cur_res += this_cost
	res[ind] = cur_res
	if len(most_vyg_odn_yye) > k:
		cur_res -= heapq.heappop(most_vyg_odn_yye)
print(*res)
",O(nlogn)
"from sys import stdout
from sys import stdin
def get():
    return stdin.readline().strip()
def getf(sp = "" ""):
    return [int(i) for i in get().split(sp)]
def put(a, end = ""\n""):
    stdout.write(str(a) + end)
def putf(a, sep = "" "", end = ""\n""):
    stdout.write(sep.join([str(i) for i in a]) + end)

from math import log
from bisect import bisect_right as br, bisect_left as bl

def main():
    n, k = getf()
    a = getf()
    rem = [[] for i in range(11)]
    ln = [0] * n
    for i in range(n):
        ln[i] = int(log(a[i], 10)) + 1
        rem[ln[i]] += [a[i] % k]
    for i in range(11):
        rem[i].sort()
    ans = 0
    for i in range(n):
        res = 0
        for add_len in range(1, 11):
            cur_rem = ((a[i] % k) * pow(10, add_len, k)) % k
            need_rem = (k - cur_rem) % k
            sz = len(rem[add_len])
            l = bl(rem[add_len], need_rem)
            r = br(rem[add_len], need_rem)
            if(l > sz - 1):
                continue
            if(rem[add_len][l] == need_rem):
                res += (r - l)
        if((a[i] + (a[i] % k) * pow(10, ln[i], k)) % k == 0):
            res -= 1
        ans += res
    put(ans)
main()
",O(nlogn)
"class Solution(object):
    def findSubstringInWraproundString(self, p):
        letters = [0] * 26
        result, length = 0, 0
        for i in range(len(p)):
            curr = ord(p[i]) - ord('a')
            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):
                length = 0
            length += 1
            if length > letters[curr]:
                result += length - letters[curr]
                letters[curr] = length
        return result",O(n)
"q = int(input())
for _ in range(q):
	l, r = map(int, input().split())
	sign = -1 if l % 2 else 1
	if (r-l) % 2:
		print(-sign*(r-l+1)//2)
	else:
		print(sign*(l+(r-l)//2))
",O(1)
"n = int(input())
a = sorted(map(int , input().split()))
ans = 0
for i in range(n):
    f = 1
    for j in range(i):
        if a[i] % a[j] == 0:
            f = 0
            break
    ans += f
print(ans)",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def minCameraCover(self, root):
        UNCOVERED, COVERED, CAMERA = list(range(3))
        def dfs(root, result):
            left = dfs(root.left, result) if root.left else COVERED
            right = dfs(root.right, result) if root.right else COVERED
            if left == UNCOVERED or right == UNCOVERED:
                result[0] += 1
                return CAMERA
            if left == CAMERA or right == CAMERA:
                return COVERED
            return UNCOVERED
        
        result = [0]
        if dfs(root, result) == UNCOVERED:
            result[0] += 1
        return result[0]",O(n)
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",O(n)
"class Solution(object):
    def isMonotonic(self, A):
        inc, dec = False, False
        for i in range(len(A)-1):
            if A[i] < A[i+1]:
                inc = True
            elif A[i] > A[i+1]:
                dec = True
        return not inc or not dec",O(n)
"import math
n=int(input())
if n==1:
	print(1)
	exit()
a=[]
for i in range(1,n+1,2):
	a.append(1)
b=[]
for i in range(2,n+1,2):
	b.append(i)
p=len(b)
k=2

while p>0:
	c=[]

	for i in range(p):
		if b[i]%k==0 and b[i]%(k*2)!=0:

			a.append(k)
			p-=1

		else:
			c.append(b[i])
	b=c[:]
	k=k*2

p=a[-1]//2
a.pop()
q=p
for i in range(p,n+1):
	if i%p==0 and i>q:
		q=i
a.append(q)

for i in a:
	print(i,end="" "")
",O(nlogn)
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))",O(n)
"class Solution(object):
    def minScoreTriangulation(self, A):
        dp = [[0 for _ in range(len(A))] for _ in range(len(A))]
        for p in range(3, len(A)+1):
            for i in range(len(A)-p+1):
                j = i+p-1
                dp[i][j] = float(""inf"")
                for k in range(i+1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k])
        return dp[0][-1]",O(n ^ 3)
"n = int(input())

segments = []

for i, _ in enumerate(range(n)):
    a, b = map(int, input().split())
    segments.append(((a, b), i + 1))

segments.sort(key=lambda x: (x[0][0], -x[0][1]))

last_r = 0
last_index = 0

for segment, index in segments:
    if last_r >= segment[1]:
        print(index, last_index)
        break

    last_r = segment[1]
    last_index = index
else:
    print(-1, -1)",O(nlogn)
"r,g,b = map(int,input().split())
rs = list(map(int,input().split()))
gs = list(map(int,input().split()))
bs = list(map(int,input().split()))
rs.sort()
gs.sort()
bs.sort()
rs.reverse()
gs.reverse()
bs.reverse()
dp = [[[0]*201 for x in range(201)] for y in range(201)]
for i in range(min(r,g)+1):
    for j in range(min(g,b)+1):
        for k in range(min(b,r)+1):
            options = []

            if i == 0:
                pass
            elif i+k-1 < r and i+j-1 < g:
                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])
            else:
                options.append(dp[i-1][j][k])
            if j == 0:
                pass
            elif i+j-1 < g and j+k-1 < b:
                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])
            else:
                options.append(dp[i][j-1][k])
            if k == 0:
                pass
            elif j+k-1 < b and i+k-1 < r:
                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])
            else:
                options.append(dp[i][j][k-1])
            if len(options) == 0:
                continue
            dp[i][j][k] = max(options)
print(dp[min(r,g)][min(g,b)][min(r,b)])
",O(n ^ 3)
"n, s = map(int, input().split())
print((s + n - 1) // n)",O(1)
"class Solution2(object):
    def areNumbersAscending(self, s):
        nums = [int(x) for x in s.split() if x.isdigit()]
        return all(nums[i] < nums[i+1] for i in range(len(nums)-1))",O(n)
"class Solution4(object):
    def fallingSquares(self, positions):
        heights = [0] * len(positions)
        for i in range(len(positions)):
            left_i, size_i = positions[i]
            right_i = left_i + size_i
            heights[i] += size_i
            for j in range(i+1, len(positions)):
                left_j, size_j = positions[j]
                right_j = left_j + size_j
                if left_j < right_i and left_i < right_j: 
                    heights[j] = max(heights[j], heights[i])

        result = []
        for height in heights:
            result.append(max(result[-1], height) if result else height)
        return result",O(n ^ 2)
"import itertools

element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.astype({""grade"" : int})
",O(n)
"def f(ch):
    if ch=='0':
        return 0
    else:
        return 1

U=[ [f(i) for i in list(input())],
    [f(i) for i in list(input())]]
i=0
size=len(U[0])
ans=0
while i+1<size:
    if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1:
        i+=1
        continue
    elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        U[1][i+1]=1
        ans+=1
    else:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        ans+=1

    i+=1

print(ans)
",O(1)
"import collections



class Solution2(object):
    def treeQueries(self, root, queries):
        def dfs(curr, d):
            if not curr:
                return 0
            h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1))
            if h > top[d][0]:
                top[d][0], top[d][1] = h, top[d][0]
            elif h > top[d][1]:
                top[d][1] = h
            depth[curr.val], height[curr.val] = d, h
            return h
        
        top = collections.defaultdict(lambda: [0]*2)
        depth, height = {}, {}
        dfs(root, 0)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"class Solution(object):
    def smallestBeautifulString(self, s, k):
        def check(i):
            return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i])

        arr = [ord(x)-ord('a') for x in s]
        for i in reversed(range(len(arr))):
            arr[i] += 1
            while not check(i):
                arr[i] += 1
            if arr[i] < k:
                break
        else:
            return """"
        for j in range(i+1, len(arr)):
            arr[j] = 0
            while not check(j):
                arr[j] += 1
        return """".join([chr(ord('a')+x) for x in arr])",O(n)
"def rotate_90(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[y][x])
        b.append(l)
    return b
def flip(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[x][y])
        b.append(l)
    return b
n=int(input())
l=[]
for i in range(n):
    a=input()
    l2=[]
    for i2 in a:
        l2.append(i2)
    l.append(l2)
l2=[]
for i in range(n):
    a=input()
    l3=[]
    for i2 in a:
        l3.append(i2)
    l2.append(l3)
d='no'
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
l=flip(l)
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
print(d)
",O(n ^ 2)
"
import collections


class Solution(object):
    def subdomainVisits(self, cpdomains):
        result = collections.defaultdict(int)
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            frags = domain.split('.')
            curr = []
            for i in reversed(range(len(frags))):
                curr.append(frags[i])
                result[""."".join(reversed(curr))] += count

        return [""{} {}"".format(count, domain) \
                for domain, count in result.items()]

",O(n)
"class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        result = left = 0
        right = [-1]*2
        for i, x in enumerate(nums):
            if not (minK <= x <= maxK):
                left = i+1
                continue
            if x == minK:
                right[0] = i
            if x == maxK:
                right[1] = i
            result += max(min(right)-left+1, 0)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def postorderTraversal(self, root):
        dummy = TreeNode(0)
        dummy.left = root
        result, cur = [], dummy
        while cur:
            if cur.left is None:
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    result += self.traceBack(cur.left, node)
                    node.right = None
                    cur = cur.right

        return result

    def traceBack(self, frm, to):
        result, cur = [], frm
        while cur is not to:
            result.append(cur.val)
            cur = cur.right
        result.append(to.val)
        result.reverse()
        return result",O(n)
"class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):
        result = duration * len(timeSeries)
        for i in range(1, len(timeSeries)):
            result -= max(0, duration - (timeSeries[i] - timeSeries[i-1]))
        return result",O(n)
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)

	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break
",O(n ^ 3)
"class Solution3(object):
    def arrayPairSum(self, nums):
        nums = sorted(nums)
        return sum([nums[i] for i in range(0, len(nums), 2)])",O(nlogn)
"n = int(input())
m = input().split()
t = []
for i in range(n):
    m[i] = int(m[i])
    if i == 0:
        t.append(m[i]+1)
    else:
        t.append(max(t[i-1], m[i]+1))
s = t[n-1] - m[n-1] - 1
for i in range(n-2, -1, -1):
    if t[i] < t[i+1]-1:
        t[i] = t[i+1]-1
    s += t[i] - m[i] - 1
print(s)",O(n)
"d = {
    ""purple"": ""Power"",
    ""green"": ""Time"",
    ""blue"": ""Space"",
    ""orange"": ""Soul"",
    ""red"": ""Reality"",
    ""yellow"": ""Mind"",
}

all_colors = list(d.keys())

n = int(input())
colors = [input() for i in range(n)]

print(len(d) - len(colors))
for color in all_colors:
    if color not in colors:
        print(d[color])
",O(1)
"class Solution2(object):
    def isCompleteTree(self, root):
        prev_level, current = [], [(root, 1)]
        count = 0
        while current:
            count += len(current)
            next_level = []
            for node, v in current:
                if not node:
                    continue
                next_level.append((node.left, 2*v))
                next_level.append((node.right, 2*v+1))
            prev_level, current = current, next_level
        return prev_level[-1][1] == count",O(n)
"def read():
    return int(input())

def readlist():
    return list(map(int, input().split()))

def readmap():
    return map(int, input().split())

N, A, B = readmap()

if N == 1:
    print(""YES"")
    print(0)

elif N == 2:
    if A == 1 and B == 2:
        print(""YES"")
        print(""01"")
        print(""10"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""00"")
        print(""00"")
    else:
        print(""NO"")

elif N == 3:
    if A == 1 and B == 2:
        print(""YES"")
        print(""011"")
        print(""100"")
        print(""100"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""001"")
        print(""000"")
        print(""100"")
    elif A == 1 and B == 3:
        print(""YES"")
        print(""011"")
        print(""101"")
        print(""110"")
    elif A == 3 and B == 1:
        print(""YES"")
        print(""000"")
        print(""000"")
        print(""000"")
    else:
        print(""NO"")

else:
    if A != 1 and B != 1:
        print(""NO"")
    else:
        print(""YES"")
        if B == 1 and A != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= A:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= A:
                        vec[0] = 1
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        elif A == 1 and B != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= B:
                            vec.append(0)
                        else:
                            vec.append(1)
                    vec[i] = 0
                    mat.append(vec)
                else:
                    vec = [1] * N
                    if i >= B:
                        vec[0] = 0
                    vec[i] = 0
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        else:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= 2:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= 2:
                        vec[0] = 1
                    mat.append(vec)

            mat[1][2] = 1
            mat[2][1] = 1
            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
",O(n ^ 2)
"class Solution3(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        lookup = SortedDict()
        for right in range(len(nums)):
            lookup[nums[right]] = right
            to_del = []
            for x, i in list(lookup.items()):
                if nums[right]-x <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x)
            for x, i in reversed(list(lookup.items())):
                if x-nums[right] <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x) 
            for x in to_del:
                del lookup[x]
            result += right-left+1
        return result",O(nlogn)
"class Solution2(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def dfs(u, p):
            cnt = [1-is_prime(u+1), is_prime(u+1)]
            for v in adj[u]:
                if v == p:
                    continue
                new_cnt = dfs(v, u)
                result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0]
                if is_prime(u+1):
                    cnt[1] += new_cnt[0]
                else:
                    cnt[0] += new_cnt[0]
                    cnt[1] += new_cnt[1]
            return cnt

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"class Solution(object):
    def findLengthOfShortestSubarray(self, arr):
        j = -1
        for j in reversed(range(1, len(arr))):
            if arr[j-1] > arr[j]:
                break
        else:
            return 0
        result = j
        for i in range(j):
            if i and arr[i] < arr[i-1]:
                break
            while j < len(arr) and arr[i] > arr[j]:
                j += 1
            result = min(result, (j-i+1)-2)
        return result",O(n)
"n, m = map(int, input().split())
k = list(map(int, input().split()))
p = list(map(int, input().split()))
a = 0
b = 0
ans = 0
while a != n and b != m:
    if p[b] >= k[a]:
        ans += 1
        a += 1
        b += 1
    else:
        a += 1
print(ans)
",O(n)
"class Solution(object):
    def closestFair(self, n):
        digits = list(map(int, str(n)))
        result = []
        if len(digits)%2 == 0:            
            left = [0]*2
            for d in digits:
                left[d%2] += 1
            if left[0] == len(digits)//2:
                return n
            for i in reversed(range(len(digits)//2, len(digits))):
                left[digits[i]%2] -= 1
                right = [len(digits)//2-left[0], len(digits)//2-left[1]]
                if any(x < 0 for x in right):
                    continue
                d = digits[i]+1 if right[(digits[i]+1)%2]-1 >= 0 else digits[i]+2
                if d > 9:
                    continue
                right[d%2] -= 1
                result = digits[:i]+[d]+[0]*right[0]+[1]*right[1]
                break
        if not result:
            l = len(digits)//2+1
            result = [1]+[0]*l+[1]*(l-1)
        return int("""".join(map(str, result)))",O(logn)
"n, k = map(int, input().split())
nums = list(map(int, input().split()))
counts = [{} for _ in range(11)]
for n in nums:
    a = n
    for i in range(11):
        r = a % k
        try:
            counts[i][r] += 1
        except KeyError:
            counts[i][r] = 1
        a *= 10
res = 0
for i in nums:
    wo = str(i)
    le = len(wo)
    mimo = (k-(i % k)) % k
    if mimo in counts[le]:
        res += counts[le][mimo]
        if int(wo+wo) % k == 0:
            res -= 1
print(res)",O(nlogn)
"import sys
n=int(input())

l=list(map(int,input().split()))
c=list(map(int,input().split()))
a=[]
for i in range(1,n-1):
    lr=sys.maxsize
    lc=sys.maxsize
    for j in range(0,i):

        if l[i]>l[j]:
            lc=min(lc,c[j])

    for j in range(i+1,n):

        if l[j]>l[i]:
            lr=min(lr,c[j])

    if lr<sys.maxsize and lc<sys.maxsize:
        a.append(lr+lc+c[i])

if not a:
    print(-1)
else:
    print(min(a))
",O(n ^ 2)
"import sys
input = sys.stdin.readline
n = int(input())
if n < 6:
    print(-1)

else:
    l = []
    o = []
    x = (3+n)//2
    for i in range(3,x+1):
        l.append((1,i))

    for i in range(x+1,n+1):
        o.append((2,i))

    sys.stdout.write(""1""+"" ""+""2""+""\n"")
    for x in l:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

    for x in o:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

sys.stdout.write(""1""+"" ""+""2""+""\n"")
p = 2
for i in range(3,n+1):
    sys.stdout.write(str(p) + "" "" + str(i) + ""\n"")
    p = i
",O(n)
"x,k = map(int, input().split())
mod = 10 ** 9 + 7
print(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)
",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrderBottom(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)

        return result[::-1]",O(n)
"def solve(mat1: list, mat2: list, K: int) -> list:
    if K % 2 == 1:
        res = [[-1] * n for _ in range(m)]
    else:

        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]
        for k in range(K // 2 + 1):
            for i in range(m):
                for j in range(n):
                    if k == 0:
                        dp[i][j][k] = 0
                    else:
                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]
                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]
                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]
                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]
        res = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                res[i][j] = 2 * dp[i][j][-1]
    for i in range(m):
        for j in range(n):
            if j < n - 1:
                print(res[i][j], end = ' ')
            else:
                print(res[i][j])
    return

m, n, K = map(int, input().split())
mat1 = []
mat2 = []
for _ in range(m):
    mat1.append(list(map(int, input().split())))
for _ in range(m - 1):
    mat2.append(list(map(int, input().split())))
solve(mat1, mat2, K)
",O(n ^ 3)
"class Solution(object):
    def findComplement(self, num):
        return 2 ** (len(bin(num)) - 2) - 1 - num",O(1)
"import string


class Solution(object):
    def validIPAddress(self, IP):
        blocks = IP.split('.')
        if len(blocks) == 4:
            for i in range(len(blocks)):
                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \
                   (blocks[i][0] == '0' and len(blocks[i]) > 1):
                    return ""Neither""
            return ""IPv4""

        blocks = IP.split(':')
        if len(blocks) == 8:
            for i in range(len(blocks)):
                if not (1 <= len(blocks[i]) <= 4) or \
                   not all(c in string.hexdigits for c in blocks[i]):
                    return ""Neither""
            return ""IPv6""
        return ""Neither""",O(1)
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
a=[]
def bs(a,mid,ans):
    global n,m
    can=[0 for i in range(1<<m)]
    for i in range(n):
        t=0
        for j in range(m):
            t=(t<<1)|(a[i][j]>=mid)

        can[t]=i+1

    for i in range(1<<m):
        if(not can[i]):
            continue
        for j in range(1<<m):
            if not can[j]:
                continue
            if i|j==(1<<m)-1:

                ans[0]=can[i]
                ans[1]=can[j]
                return 1
    return 0

for i in range(n):
    p=[int(x) for x in input().split()]
    a.append(p)
l=0
r=100000000000
ans=[1,1]
while l<=r:
    mid=(l+r)//2
    if bs(a,mid,ans):
        l=mid+1
    else:
        r=mid-1

print(*ans)
",np
"class Solution2(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            result = bal = 0
            for i in range(len(rooks)):
                bal += cnt[i]-1
                result += abs(bal)
            return result

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n=I()
    points,l=[],[]
    for i in range(n):
        a,b=In()
        l.append((a,b))
        points.append(a)
        points.append(b)
    points.sort()
    k=0
    d={}
    l1=[]
    for i in range(2*n):
        if d.get(points[i],-1)==-1:
            d[points[i]]=k
            l1.append(points[i])
            k+=1

    n1=len(d)
    dp=[[0,0] for i in range(n1)]
    for a,b in l:
        dp[d[a]][0]+=1
        dp[d[b]][1]-=1

    ans={}
    last=dp[0][0]
    ans[last]=1
    last+=dp[0][1]
    for i in range(1,n1):
        cnts=l1[i]-l1[i-1]-1
        if ans.get(last,-1)!=-1:
            ans[last]+=cnts
        else:
            ans[last]=cnts
        last+=dp[i][0]
        if ans.get(last,-1)!=-1:
            ans[last]+=1
        else:
            ans[last]=1
        last+=dp[i][1]
    if ans.get(last,-1)!=-1:
        ans[last]+=1
    else:
        ans[last]=1
    for i in range(1,n+1):
        print(ans.get(i,0),end=' ')
    print()
    pass
def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(nlogn)
"import sys
import math
input = sys.stdin.readline

def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s.rstrip()))
def invr():
    return(map(int,input().split()))
n, m, k=inlt()
M=[[[] for i in range(m)] for j in range(n)]
S=[[-1]*m for i in range(n)]
for y in range(n):
	L=inlt()
	for x in range(m-1):
		M[y][x].append(((y, x+1), L[x]))
		M[y][x+1].append(((y, x), L[x]))

for y in range(n-1):
	L=inlt()

	for x in range(m):
		M[y][x].append(((y+1, x), L[x]))
		M[y+1][x].append(((y, x), L[x]))
if k%2==0:
	for l in range(k//2):
		S2=[[0]*m for i in range(n)]
		for y in range(n):
			for x in range(m):
				Mi=10000000000000000000000
				for ((a, b), p) in M[y][x]:
					Mi=min(Mi,max(0,S[a][b])+p)
				S2[y][x]=Mi
		S=S2
	for y in range(n):
		for x in range(m):
			S[y][x]*=2

for y in range(n):
	print(' '.join(list(map(str, S[y]))))",O(n ^ 3)
"n = int(input())

if n<6:
	print(-1)
else:
	print(""1 2\n1 3\n1 4"")
	for i in range(5,n+1):
		print('2 '+str(i))
for i in range(2, n+1):
	print('1 '+str(i))",O(n)
"class Solution(object):
    def minCost(self, n, cuts):
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in range(len(sorted_cuts))]
        for l in range(2, len(sorted_cuts)):
            for i in range(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in range(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]",O(n ^ 3)
"n = int(input())
rang = list(range(2,n//2+1))
a = [i*(n//i-1) for i in rang]
print(sum(a)*4)
",O(n)
"def solve(n,k):
    print(1*k,end = ' ')
    if n==2:
        print(2*k,end = ' ')
    if n == 3:
        print(k,3*k,end = ' ')
    else:
        temp = n//2
        if(n%2 == 0): temp -= 1
        print((str(k)+' ')*temp,end='')
        if(n>3):
            solve(n//2,k*2)

n = int(input())
solve(n,1)",O(n)
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",O(n)
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
res = 0
for i in range(1 << n):
	Bit = []
	for j in range(n):
		if i & (1 << j):
			Bit.append(c[j])
	if (len(Bit) >= 2) and (l<= sum(Bit) <= r) and (max(Bit) - min(Bit) >= x):
		res+= 1
print(res)",np
"name = input()
for i in range(len(name), 0, -1):
	for j in range(len(name) - i + 1):
		if name[j: j + i] in name[j + 1:]:
			print(i)
			exit()
print(0)
",O(n ^ 3)
"def main():
    n, m = map(int, input().split())

    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))

    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))

    print('\n'.join(r))

main()
",O(n ^ 2)
"CANDNUM = 5

I = lambda: [int(x) for x in raw_input().split()]
T = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2

def getCandidates(tsLst, curN, notSeen):
	r = []
	curD = {}
	k = 0
	cand = None
	curSet = set()
	for x in tsLst:
		i, j = x
		curSet.add(i)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
		curSet.add(j)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
	i = 0
	for x in tsLst:
		if cand in x:
			r.append(x)
			i += 1
			if i == CANDNUM:
				break
	return r

def solve(xs, ys, n, oLst):
	def solveEven(seen):
		def solveEvenRec(notSeen, tsLst):
			if len(notSeen) == 0:
				return 0, []
			ns = tuple(notSeen)
			if ns in solveEvenRec.d:
				return solveEvenRec.d[ns]
			minLst = []
			minT = 10000000

			cands = getCandidates(tsLst, len(notSeen), notSeen)
			for x in cands:
				i, j = x
				newNotSeen = notSeen.copy()
				if i in newNotSeen:
					newNotSeen.remove(i)
				if j in newNotSeen:
					newNotSeen.remove(j)
				newTsLst = []
				for x1 in tsLst:
					i1, j1 = x1
					if i1 in newNotSeen and j1 in newNotSeen:
						newTsLst.append(x1)
				rT, rLst = solveEvenRec(newNotSeen, newTsLst)
				rT += ts[x]
				if rT < minT:
					minT = rT
					minLst = [x] + rLst
			r = minT, minLst
			solveEvenRec.d[ns] = r
			return r
		solveEvenRec.d = {}

		newLst = []
		for i in range(n):
			if i not in seen:
				newLst.append(i)
		newN = n - len(seen)
		if newN == 2:
			minT = 10000000
			minLst = []
			for a in ts:
				if ts[a] < minT:
					minT = ts[a]
					minLst = [a]
			rT = minT
			rLst = minLst
		else:
			newTsLst = []
			for x in tsLst:
				a, _ = x
				i, j = a
				if i not in seen and j not in seen:
					newTsLst.append(a)
			notSeen = set(range(n)) - set(seen)
			rT, rLst = solveEvenRec(notSeen, newTsLst)
		return rT, rLst
	ts = {}
	tss = {}
	for i in range(n-1):
		x1, y1 = oLst[i]
		for j in range(i+1, n):
			x2, y2 = oLst[j]
			t = T(x1, y1, x2, y2)
			t1 = T(x1, y1, xs, ys)
			t2 = T(xs, ys, x2, y2)
			if t1+t2 >= t:
				ts[(i, j)] = t
				tss[(i, j)] = True
			else:
				ts[(i, j)] = t1+t2
				tss[(i, j)] = False
	tsLst = []
	for x in ts:
		tsLst.append((x, ts[x]))
	tsLst.sort(key=lambda x:x[1])
	if n%2:
		if n > 1:
			resT = 10000000
			resLst = []
			for i in range(n):
				x, y = oLst[i]
				t = 2*T(x, y, xs, ys)
				rT, rLst = solveEven([i])
				for a in rLst:
					i1, i2 = a
					x1, y1 = oLst[i1]
					x2, y2 = oLst[i2]
					rT += T(xs, ys, x1, y1)
					rT += T(xs, ys, x2, y2)
				rT += t
				if rT < resT:
					resT = rT
					newRLst = ['0']
					for a in rLst:
						w, v = a
						if tss[(w, v)]:
							newRLst.append(str(w+1))
							newRLst.append(str(v+1))
							newRLst.append('0')
						else:
							newRLst.append(str(w+1))
							newRLst.append('0')
							newRLst.append(str(v+1))
							newRLst.append('0')
					newRLst.append(str(i+1))
					newRLst.append('0')
					resLst = newRLst
		else:
			x, y = oLst[0]
			resT = 2*T(x, y, xs, ys)
			resLst = ['0', '1', '0']
	else:
		resT, rLst = solveEven([])
		for a in rLst:
			i1, i2 = a
			x1, y1 = oLst[i1]
			x2, y2 = oLst[i2]
			resT += T(xs, ys, x1, y1)
			resT += T(xs, ys, x2, y2)
		newRLst = ['0']
		for a in rLst:
			w, v = a
			if tss[(w, v)]:
				newRLst.append(str(w+1))
				newRLst.append(str(v+1))
				newRLst.append('0')
			else:
				newRLst.append(str(w+1))
				newRLst.append('0')
				newRLst.append(str(v+1))
				newRLst.append('0')
		resLst = newRLst
	return resT, resLst

xs, ys = I()
n = input()
oLst = []
for _ in range(n):
	x, y = I()
	oLst.append((x, y))
resT, resLst = solve(xs, ys, n, oLst)
print(resT)
print(' '.join(resLst))",np
"first = [int(i) for i in input()]
second = [int(i) for i in input()]

pref_dists = [
    [0] + [int(0 != c) for c in second],
    [0] + [int(1 != c) for c in second]
]
for i in range(1, len(second) + 1):
    pref_dists[0][i] += pref_dists[0][i - 1]
    pref_dists[1][i] += pref_dists[1][i - 1]

total = 0
for i, c in enumerate(first):
    end = len(second) - (len(first) - i)
    total += pref_dists[c][end + 1] - pref_dists[c][i]
print(total)
",O(n)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n*m):
    dp.set((i, 0), 0)
  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))
      dp.set((i, t), ans)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp.get((node, k/2)) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n,k=map(int,input().split())
ans=0
ans+=(2*n)//k + bool((2*n)%k!=0)
ans+=(5*n)//k + bool((5*n)%k!=0)
ans+=(8*n)//k + bool((8*n)%k!=0)
print(ans)",O(1)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
while cur > 0:
    prev = pp[cur]
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"def main():
    n, d, k = list(map(int, input().split()))
    if n == 2 and d == 1 and k == 1:
        print(""YES"")
        print(""1 2"")
        return 0
    if n == d + 1 and k - 1:
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        return 0
    if  n < d +1 or k <= 2 or d == 1:
        print(""NO"")
        return 0
    if d % 2 == 0:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 1 + dev + d // 2]

    else:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2) + (k - 2) * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2, 2 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 2 + dev + d // 2]
main()
",O(n ^ 2)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        q1 = deque([p])
        q2 = deque([q])

        while q1 and q2:
            for _ in range(len(q1)):
                nodeP = q1.popleft()
                nodeQ = q2.popleft()

                if nodeP is None and nodeQ is None:
                    continue
                if nodeP is None or nodeQ is None or nodeP.val != nodeQ.val:
                    return False

                q1.append(nodeP.left)
                q1.append(nodeP.right)
                q2.append(nodeQ.left)
                q2.append(nodeQ.right)

        return True
",O(n)
"import itertools


class Solution2(object):
    def createTargetArray(self, nums, index):
        result = []
        for i, x in zip(index, nums):
            result.insert(i, x)
        return result",O(n ^ 2)
"import math

def field(n, x, y, t):
    t = t + 1
    upper_dist = x - 1
    left_dist = y - 1
    down_dist = n - x
    right_dist = n - y
    out_up = max(0, t - upper_dist - 1)
    out_down = max(0, t - down_dist - 1)
    out_left = max(0, t - left_dist - 1)
    out_right = max(0, t - right_dist - 1)

    field = base_field(t) - right_field(out_right) - right_field(out_left) - up_field(out_up, n, y) - up_field(out_down, n, y)
    return field

def right_field(out_r):
    return out_r ** 2

def up_field(out_up, n, y):
    rect = max(0, out_up - n + 1)
    h = out_up - rect
    wyst = max(y - 1 + h - n, 0, h - y)
    result = n * rect + h ** 2 - int((1 + wyst) / 2 * wyst)
    if result < 0:
        result = 0
    return result

def base_field(t):
    return 2 * (t ** 2) - 2 * t + 1

class CodeforcesTask256BSolution:
    def __init__(self):
        self.result = ''
        self.n_x_y_c = []

    def read_input(self):
        self.n_x_y_c = [int(x) for x in input().split("" "")]

    def process_task(self):
        search = 0
        mid = 1
        found = False
        last_sm = 0
        while not found:

            ff = field(self.n_x_y_c[0], self.n_x_y_c[1], self.n_x_y_c[2], search)
            if ff == self.n_x_y_c[3]:
                found = True
            elif ff > self.n_x_y_c[3]:
                if search - last_sm == 1:
                    found = True
                else:
                    search = last_sm + (search - last_sm) // 2
            else:
                last_sm = search
                search += mid
                mid = search - last_sm
        self.result = str(search)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask256BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(logn)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",O(n ^ 2)
"class Solution(object):
    def findMinArrowShots(self, points):
        if not points:
            return 0

        points.sort()

        result = 0
        i = 0
        while i < len(points):
            j = i + 1
            right_bound = points[i][1]
            while j < len(points) and points[j][0] <= right_bound:
                right_bound = min(right_bound, points[j][1])
                j += 1
            result += 1
            i = j
        return result",O(nlogn)
"def parse(line):
	i = 0
	while line[i].isalpha():
		i += 1
	i1 = i
	while i < len(line) and line[i].isdigit():
		i += 1
	return line[:i1], int(line[i1:i]), line[i:]

for _ in range(int(input())):
	a1, n1, rest = parse(input())
	if rest:
		_, n2, _ = parse(rest)
		a2 = ''
		while n2:
			r = (n2 - 1) % 26
			a2 = chr(r + ord('A')) + a2
			n2 = (n2 - r - 1) // 26
		print(a2 + str(n1))
	else:
		n2 = 0
		for c in a1:
			n2 = 26 * n2 + (ord(c) - ord('A') + 1)
		print(f'R{n1}C{n2}')
",O(n)
"a, b = [int(x) for x in input().split(' ')]
idx = 0
if(a == b):
    print(0)
else:
    for i in range(63,-1,-1):
        set1 = (a >> i) & 1
        set2 = (b >> i) & 1
        if(set1!=set2):
            idx = i
            break
    print((1<<(idx+1))-1)",O(logn)
"import sys
from math import gcd, sqrt
from typing import Deque

sys.setrecursionlimit(10 ** 5)

inf = float(""inf"")
en = lambda x: list(enumerate(x))

ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())

n = ii()
arr = rr()
arr = en(arr)

arr.sort(key=lambda x: x[1])

i = 0
brr = []

for j in input():
    if j == ""0"":
        brr.append(arr[i])
        print(arr[i][0] + 1, end="" "")
        i += 1
    else:
        x = brr.pop()
        print(x[0] + 1, end="" "")
",O(nlogn)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [set() for _ in range(n)]

for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].add(b - 1)
    graph[b - 1].add(a - 1)

leafs = [i for i,v in enumerate(graph) if len(v) == 1]
new_leafs = []
valid = True
centers = dict()
count = 0

while len(leafs) > 1 and valid:
    for leaf in leafs:
        center = graph[leaf].pop()

        try:
            centers[center] += 1
        except KeyError:
            centers[center] = 1

        graph[center].remove(leaf)

        if len(graph[center]) == 0:
            break

        elif len(graph[center]) == 1:
            new_leafs.append(center)

    if any(mult < 3 for mult in centers.values()):
        valid = False
        break

    count = count + 1
    leafs = new_leafs
    new_leafs = []
    centers = {}

if valid and count == k:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n = int(input())
s = input()
t = input()
dic, diff = {}, []
res, res1, res2 = 0, -1, -1
for i in range(n) :
    if s[i] != t[i] :
        res += 1
        diff.append(i)
        dic[t[i]] = i
swap1, swap2 = False, False
for i in diff :
    if s[i] in dic:
        swap1 = True
        res1 = i+1
        j = dic[s[i]]
        res2 = j+1
        if s[j] == t[i] :
            swap2 = True
            break
print(res - (2 if swap2 else 1 if swap1 else 0))
print(res1, res2)
",O(n)
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]

DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0

			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])

			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])

			DP[idx(r, g, b)] = best

print(max(DP))",O(n ^ 3)
"import math

p2 =[1] * 64

for i in range(1, 64):
    p2[i] = p2[i-1] * 2

def find_level(x):
    x0 = 1

    for i in range(max_level+1):
        if (x-x0) % (x0*2) == 0:
            return i
        x0 *=2

def move_U(number):
    cur_lv    =  find_level(number)

    if cur_lv == max_level:
        return number

    x0      =   p2[cur_lv]
    seg     =   x0 * 2
    index   =  (number - x0) // seg

    return (x0*2) + (index // 2) * (seg * 2)

def move_L(number):
    cur_lv    =  find_level(number)

    if cur_lv == 0:
        return number

    x0      =   p2[cur_lv]
    seg     =   x0 * 2
    index   =  (number - x0) // seg

    return (x0 // 2) + (index * 2) * (seg // 2)

def move_R(number):
    cur_lv    =  find_level(number)

    if cur_lv == 0:
        return number

    x0      =   p2[cur_lv]
    seg     =   x0 * 2
    index   =  (number - x0) // seg

    return (x0 // 2) + (index * 2 + 1) * (seg // 2)

def move(s,num):
    if s == 'U':
        return move_U(num)

    if s == 'L':
        return move_L(num)

    return move_R(num)

def process(S, num):
    for s in S:
        num = move(s, num)
    return num

n, q = map(int, input().split())
max_level = int(math.log2(n+1)) - 1
ans  = ''

for _ in range(q):
    num  = int(input())
    S    = input()
    ans += str(process(S, num)) + '\n'

print(ans)
",np
"import collections


class Solution(object):
    def countLargestGroup(self, n):
        count = collections.Counter()
        for x in range(1, n+1):
            count[sum(map(int, str(x)))] += 1
        max_count = max(count.values())
        return sum(v == max_count for v in count.values())",O(nlogn)
"class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        mp = defaultdict(int)
        for start, end in intervals:
            mp[start] += 1
            mp[end] -= 1

        res = []
        interval = []
        have = 0
        for i in sorted(mp):
            if not interval:
                interval.append(i)
            have += mp[i]
            if have == 0:
                interval.append(i)
                res.append(interval)
                interval = []
        return res
",O(nlogn)
"b = [list(input()) for _ in range(2)]

n = len(b[0])
ans = 0
a = []
for i in range(n):
    ai = 0
    if b[0][i] == '0':
        ai += 1
    if b[1][i] == '0':
        ai += 1
    a.append(ai)
prv = 0
for i in range(n):
    if a[i] == 0:
        prv = 0
    elif a[i] == 1:
        if prv == 2:
            ans += 1
            prv = 0
        else:
            prv = 1
    elif a[i] == 2:
        if prv == 2:
            ans += 1
            prv = 1
        elif prv == 1:
            ans += 1
            prv = 0
        else:
            prv = 2
print(ans)",O(1)
"class Solution(object):
    def findArray(self, pref):
        for i in reversed(range(1, len(pref))):
            pref[i] ^= pref[i-1]
        return pref",O(n)
"class Solution(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        curr = 0
        prefix = [0]*(len(strength)+1)
        for i in range(len(strength)):
            curr = (curr+strength[i])%MOD
            prefix[i+1] = (prefix[i]+curr)%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD
            stk.append(i)
        return result",O(n)
"import math
def max_sub(arr,n):
	dp = [0]*n
	dp[0] = arr[0]
	for i in range(1,n):
		dp[i] = max(dp[i-1]+arr[i],arr[i])
	return max(0,max(dp))
n,m,k = map(int,input().split())
arr = list(map(int,input().split()))
q = -math.inf
dp = [0]*(300100)
for i in range(300100):
	dp[i] = [q]*(11)
if (m==1):
	for i in range(n):
		arr[i]= arr[i]-k
	print(max_sub(arr,n))
else:
	for i in range(n):
		dp[i][1] = arr[i]-k
		for j in range(m):
			if (i-1<0 or dp[i-1][j]==q):
				continue
			if ((j+1)%m!=1):
				dp[i][(j+1)%m] = dp[i-1][j]+arr[i]
			else:
				dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)
	ma=0
	for i in range(n):

		for j in range(m):

			ma = max(ma,dp[i][j])

	print(ma)",O(n ^ 2)
"x, k = map(int, input().split())
mod = 1000 * 1000 * 1000 + 7
if x == 0:
    print(0)
else:
    mul = pow(2, k + 1, mod)
    cnt = pow(2, k, mod)
    s1 = mul * cnt * x
    s2 = cnt * (cnt - 1)
    ans  = (s1 - s2) % mod
    rev = pow(cnt, mod - 2, mod)
    assert rev * cnt % mod == 1
    ans *= rev
    print(ans % mod)
",O(logn)
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",O(n ^ 2)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    by_last_one = [[] for _ in range(k)]
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])
            if found and not answer[mask]:
                answer[mask] = True
                masks[mask] = path
                simple[mask] = True
                by_last_one[calc_last_one(mask)].append(mask)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    for mask_right in range(2, 1 << k):
        if not simple[mask_right]:
            continue
        last_one = calc_last_one(mask_right)
        zeroes_count = 0
        alternative_sum = 0
        zero_list = []
        for u in range(last_one):
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
                alternative_sum += len(by_last_one[u])
                zero_list.append(u)
        if zeroes_count == 0:
            continue
        if alternative_sum < (1 << zeroes_count):
            for fill_last_zero in zero_list:
                for mask_left in by_last_one[fill_last_zero]:
                    if (mask_left & mask_right) != 0:
                        continue
                    joint_mask = mask_left | mask_right
                    if not answer[joint_mask]:
                        answer[joint_mask] = True
                        left[joint_mask] = mask_left
                        right[joint_mask] = mask_right
                        by_last_one[last_one].append(joint_mask)
                        if joint_mask == ((1 << k) - 1):
                            return build_answer(k, masks, left, right)
        else:
            for mask_mask in range(1 << zeroes_count):
                mask_left = 0
                for u in range(zeroes_count):
                    if (mask_mask & (1 << u)) != 0:
                        mask_left = mask_left | (1 << zero_list[u])
                joint_mask = mask_left | mask_right
                if answer[mask_left] and not answer[joint_mask]:
                    answer[joint_mask] = True
                    left[joint_mask] = mask_left
                    right[joint_mask] = mask_right
                    by_last_one[last_one].append(joint_mask)
                    if joint_mask == ((1 << k) - 1):
                        return build_answer(k, masks, left, right)
    return False, None, None

def calc_last_one(x):
    result = -1
    while x > 0:
        x = x >> 1
        result = result + 1
    return result

def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for i, a, j in masks[right[pos]]:
            c[i] = a
            p[i] = j
        pos = left[pos]
    for i, a, j in masks[pos]:
        c[i] = a
        p[i] = j
    return True, c, p

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path.append((i_next, a[i_next][j_next], i))
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",O(n ^ 3)
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)
",O(n ^ 2)
"r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])

print(ans)
",O(n ^ 3)
"l,r = map(int,input().split())
ans = l ^ r
x = bin(ans)[1:]
if ans == 0:
    print(0)
else:
    ptr = -1
    po = 0
    while True:
        if( x[ptr] == '0') :
            ans += 2**po
        po += 1
        ptr-=1
        if( ptr == -len(x)-1 ):
            break

    print(ans)
",O(logn)
"n,d,k = [int(x) for x in input().strip().split(' ')]
l = []
i = 1
if n<=d:
	print(""NO"")
elif k==1:
	if n>2:
		print(""NO"")
	elif n==2:
		print(""YES"")
		print(1,2)
else:
	n+=1
	flag = False
	while i<min(d+1,n):
		l.append(str(i)+"" ""+str(i+1))
		i+=1
	i+=1
	cnt1=0
	cnt2=1
	se=[[2,d+1,1]]
	while cnt1<cnt2:
		start = se[cnt1][0]
		end = se[cnt1][1]
		mode = se[cnt1][2]

		kk = 3
		while (i<n) and (kk<=k):
			if i<n and not flag:
				j = start

				while i<n and j<end:
					if mode==1:
						c = min(j-start+1,end-j)
					else:
						c = min(end-j,d-end+j)
					if c>1:
						se.append([i,i+c-1,2])
						cnt2+=1
					ki=j
					while i<n and c>0:
						l.append(str(ki)+"" ""+str(i))

						c-=1
						ki=i
						i+=1
					j+=1

			else:
				flag = True
				break
			kk+=1
		cnt1+=1
	if i<n or flag:

		print(""NO"")
	else:
		print(""YES"")
		print('\n'.join(l))",O(n ^ 2)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        result = 0
        while head: 
            result = result*2 + head.val 
            head = head.__next__ 
        return result",O(n)
"import sys
import math
from collections import defaultdict
n,m=map(int,sys.stdin.readline().split())

up,down=1,n
count=0
while up<=down:
    left,right=1,m

    while left<=m and count<n*m:

        if count<n*m:
            sys.stdout.write((str(up)+"" ""+str(left)+""\n""))
        count+=1
        left+=1

        if count<n*m:
            sys.stdout.write((str(down)+"" ""+str(right)+""\n""))
        count+=1

        right-=1
    up+=1
    down-=1
",O(n ^ 2)
"print(int(input())//2 + 1)
",O(1)
"_, k = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
c = list(sorted(zip(a, b, range(len(b)))))
d = [0] * len(b)

if k == 0:
    print(' '.join(map(str, b)))
else:
    best = [0] * k
    for pwr, cnt, index in c:
        d[index] = sum(best) + cnt

        if cnt > best[0]:
            for i in range(len(best)):
                if cnt <= best[i]:
                    best.insert(i, cnt)
                    best = best[1:]
                    break
            else:
                best = best[1:] + [cnt]

    print(' '.join(map(str, d)))
",O(nlogn)
"class Solution(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        curr = left = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            curr += nums[right%len(nums)]
            while curr > target:
                curr -= nums[left%len(nums)]
                left += 1
            if curr == target:
                result = min(result, right-left+1)
        return result+q*len(nums) if result != INF else -1",O(n)
"def really_big(x):
    sum_digit = 0
    digits = x
    while digits > 0:
        sum_digit += digits % 10
        digits = digits // 10

    if x - sum_digit >= s:
        return True
    return False

def solve():
    left = 1
    right = n
    ans = 0
    while left <= right:
        mid = (left + right) // 2
        if really_big(mid):
            right = mid - 1
            ans = n - mid + 1
        else:
            left = mid + 1
    return ans

n, s = map(int, input().split())
print(solve())
",O(logn)
"def A(n):
	return (4**n-1)//3

L = 31

T = int(input())
for _ in range(T):
	n,k = [int(_) for _ in input().split()]

	if n > L:
		print(""YES"",n-1)
		continue

	if k > A(n):
		print(""NO"")
		continue

	E = 1
	M = 0
	R = 0
	while n >= 0:
		M += E

		I = 2*E-1
		E = 2*E+1

		n -= 1
		R += I*A(n)

		if M <= k and k <= M+R: break

	if n >= 0: print(""YES"",n)
	else: print(""NO"")
",O(logn)
"a,b,c,d,e,f=map(int,input().split())
if a<b:a,b=b,a
if c<d:c,d=d,c
if e<f:e,f=f,e
sides=[[a,b,'A'],[c,d,'B'],[e,f,'C']]
sides.sort(reverse=True)
c1,c2,c3=sides[0][2],sides[1][2],sides[2][2]
area=a*b+c*d+e*f
if int(area**0.5)**2!=area:
	print(-1)
else:
	l=int(area**0.5)
	if l not in sides[0]:
		print(-1)
	elif l in sides[1] and l in sides[2]:
		print(l)
		for i in range(3):sides[i].remove(l)
		for i in range(3):
			for _ in range(sides[i][0]):
				print([c1,c2,c3][i]*l)
	else:
		r=l-sides[0][1]
		if r in sides[1] and r in sides[2]:
			print(l)
			for i in range(1,3):sides[i].remove(r)
			for _ in range(sides[0][1]):
				print(c1*l)
			for _ in range(r):
				print(c2*sides[1][0]+c3*sides[2][0])
		else:
			print(-1)",np
"def push(d, u, v):
    if u not in d:
        d[u] = []
    if v not in d:
        d[v] = []
    d[u].append(v)
    d[v].append(u)

def push_v(d, u, val):
    if u not in d:
        d[u] = 0
    d[u] += val

n, k = map(int, input().split())
g    = {}

for _ in  range(n-1):
    u, v = map(int, input().split())
    push(g, u, v)

deg1 = []
used = [0] * (n+1)

for u in g:
    if len(g[u]) == 1:
        used[u]  = 1
        deg1.append(u)

flg = True
while k > 0:
    if k >= 1 and len(deg1) < 3:
        flg=False
        break

    cnt = {}
    for u in deg1:
        for v in g[u]:
            if used[v] == 0:
                push_v(cnt, v, 1)

    for v in deg1:
        used[v] = 1

    deg1 = []

    for v, val in cnt.items():
        if val < 3:
            flg=False
            break
        deg1.append(v)

    if flg==False:
        break
    k-=1

if flg==True and len(deg1) > 1:
    flg=False

if flg==False:
    print('NO')
else:
    print('YES')
",O(nlogn)
"import os,sys
from io import BytesIO,IOBase

def check(n,mid,path,cost,num):
    ans,poi,visi = [],[0]*n,[0]*n
    for i in range(n):
        if visi[i]:
            continue
        visi[i],st,st1 = 2,[i],[]
        while len(st):
            x,y = st[-1],path[st[-1]]
            if poi[x] == len(y):
                visi[x] = 1
                st1.append(st.pop())
            else:
                i,j = y[poi[x]],cost[st[-1]][poi[x]]
                poi[x] += 1
                if j <= mid:
                    continue
                if visi[i] == 2:
                    return -1
                if not visi[i]:
                    st.append(i)
                    visi[i] = 2
        ans += st1
    start = [0]*n
    for ind,i in enumerate(reversed(ans)):
        start[i] = ind
    poi,visi,fin = [0]*n,[0]*n,[]
    for i in range(n):
        if visi[i]:
            continue
        visi[i],st = 1,[i]
        while len(st):
            x,y = st[-1],path[st[-1]]
            if poi[x] == len(y):
                st.pop()
            else:
                i,j,k = y[poi[x]],cost[st[-1]][poi[x]],num[st[-1]][poi[x]]
                poi[x] += 1
                visi[i] = 1
                st.append(i)
                if start[i] < start[x] and j <= mid:
                    fin.append(k)
    return fin

def main():
    n,m = map(int,input().split())
    path = [[] for _ in range(n)]
    cost = [[] for _ in range(n)]
    num = [[] for _ in range(n)]
    for _ in range(m):
        u1,v1,c1 = map(int,input().split())
        path[u1-1].append(v1-1)
        cost[u1-1].append(c1)
        num[u1-1].append(_+1)
    hi,lo = 10**9,0
    while hi >= lo:
        mid = (hi+lo)//2
        z = check(n,mid,path,cost,num)
        if z == -1:
            lo = mid+1
        else:
            hi = mid-1
            ans = mid
            an = z
    print(ans,len(an))
    print(*an)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(nlogn)
"class Solution(object):
    def maximumBooks(self, books):
        def count(right, l):
            left = max(right-l+1, 0)
            return (left+right)*(right-left+1)//2
        
        result = curr = 0
        stk = [-1]
        for i in range(len(books)):
            while stk[-1] != -1 and books[stk[-1]] >= books[i]-(i-stk[-1]):
                j = stk.pop()
                curr -= count(books[j], j-stk[-1])
            curr += count(books[i], i-stk[-1])
            stk.append(i)
            result = max(result, curr)
        return result",O(n)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - Decimal(1)) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input()
n = Decimal(line.split()[0])
k = Decimal(line.split()[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(2,k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(int(k - res1 + 1));",O(logn)
"import math

def get_digit(x, pos):
    s = []

    while x > 0:
        s.append(x%10)
        x //= 10

    return s[::-1][pos]

def find_digit(x):
    n     = 0
    next_ = 9 * (10**n) * (n+1)

    while next_ <= x:
        x -= next_

        n += 1
        next_ = 9 * (10**n) * (n+1)

    if x == 0:
        return 9

    pos_ = 10 ** n + math.ceil(x / (n+1)) - 1

    return get_digit(pos_, (x-1)%(n+1))

k = int(input())
print(find_digit(k))",O(logn)
"class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        if n == 0:
            return 1

        res = 1
        power = abs(n)

        while power:
            if power & 1:
                res *= x
            x *= x
            power >>= 1

        return res if n >= 0 else 1 / res
",O(logn)
"class Solution(object):
    def repeatedNTimes(self, A):
        for i in range(2, len(A)):
            if A[i-1] == A[i] or A[i-2] == A[i]:
                return A[i]
        return A[0]",O(n)
"class Solution(object):
    def canWinNim(self, n):
        return n % 4 != 0",O(1)
"b = list(map(int, input().split()))
n = 14
ans = 0
for i in range(n):
    a = b.copy()
    if a[i] == 0:
        continue
    x = a[i]
    a[i] = 0
    full = x // n
    xex = x % n
    for j in range(n):
        a[j] += full
    for j in range(xex):
        a[(i + j + 1) % n] += 1
    pot = 0
    for j in a:
        if j % 2 == 0:
            pot += j
    ans = max(ans, pot)
print(ans)
",O(1)
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = []

        for i in range(n):
            count = 1
            j = i + 1
            while j < n:
                if temperatures[j] > temperatures[i]:
                    break
                j += 1
                count += 1
            count = 0 if j == n else count
            res.append(count)
        return res
",O(n ^ 2)
"n,m = map(int, input().split())
a = []
for i in range(n):
    s = input()
    a.append(s)
for i in range(n):
    for j in range(m):
        if a[i][j] == '.':
            continue
        if i >= 2 and j >= 2:
            if a[i-2][j-2] == '
                    and a[i-1][j] == '
                continue
        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '
                and a[i][j-2] == '
            continue
        if i <= n-3 and j >= 2 and a[i][j-1] == '
                and a[i+1][j-2] == '
            continue
        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '
                and a[i+1][j+1] == '
            continue
        if i <= n-3 and j <= m-3 and a[i][j+1] == '
                and a[i+1][j+2] == '
            continue
        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '
                and a[i][j+2] == '
            continue
        if i >= 2 and j <= m-3 and a[i-2][j] == '
                and a[i-1][j] == '
            continue
        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '
                and a[i-1][j-1] == '
            continue
        print('NO')
        exit()
print('YES')",O(n ^ 2)
"class Solution(object):
    def uniqueXorTriplets(self, nums):
        return 1<<len(nums).bit_length() if len(nums) >= 3 else len(nums)",O(1)
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]

def f(i, j):
	if d[i][j] != -1:
		return d[i][j]
	d[i][j] = 0
	for m in range(i, j):
		l = f(i, m)
		if f(m+1, j) == l and l:
			d[i][j] = l+1
			break
	return d[i][j]

a = [_ for _ in range(1, n+1)]
for e in range(1, n):
	for s in range(e+1):
		if f(s, e):
			a[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))
print(a[-1])",O(n ^ 3)
"class Solution(object):

    def __init__(self, A):
        self.__A = A
        self.__i = 0
        self.__cnt = 0

    def next(self, n):
        while self.__i < len(self.__A):
            if  n > self.__A[self.__i] - self.__cnt:
                n -= self.__A[self.__i] - self.__cnt
                self.__cnt = 0
                self.__i += 2
            else:
                self.__cnt += n
                return self.__A[self.__i+1]
        return -1",O(n)
"import random



class Solution(object):
    def minOperationsToMakeMedianK(self, nums, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        nth_element(nums, len(nums)//2)
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(n)
"class Solution(object):
    def circularArrayLoop(self, nums):
        def next_index(nums, i):
            return (i + nums[i]) % len(nums)

        for i in range(len(nums)):
            if nums[i] == 0:
                continue

            slow, fast = i, i
            while nums[next_index(nums, slow)] * nums[i] > 0 and \
                  nums[next_index(nums, fast)] * nums[i] > 0 and \
                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:
                slow = next_index(nums, slow)
                fast = next_index(nums, next_index(nums, fast))
                if slow == fast:
                    if slow == next_index(nums, slow):
                        break
                    return True

            slow, val = i, nums[i]
            while nums[slow] * val > 0:
                tmp = next_index(nums, slow)
                nums[slow] = 0
                slow = tmp

        return False",O(n)
"class Solution(object):
    def pathsWithMaxScore(self, board):
        MOD = 10**9+7
        directions = [[1, 0], [0, 1], [1, 1]]
        dp = [[[0, 0] for r in range(len(board[0])+1)]
              for r in range(2)]
        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]
        for r in reversed(range(len(board))):
            for c in reversed(range(len(board[0]))):
                if board[r][c] in ""XS"":
                    continue
                dp[r%2][c] = [0, 0]
                for dr, dc in directions:
                    if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]
                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD
                if dp[r%2][c][1] and board[r][c] != 'E':
                    dp[r%2][c][0] += int(board[r][c])
        return dp[0][0]",O(n ^ 2)
"n = int(input())

arr = [int(z) for z in list(input())]
ans = 0

if n == 2:
    if arr[0] == arr[1]:
        print(""YES"")
    else:
        print(""NO"")
    exit()

for l in range(1, n-1):
    s = sum(arr[:l])
    i = l
    v = [s]
    curr = 0
    while i < n:
        curr += arr[i]
        if i == n-1:
            if curr > s:
                curr -= arr[i]
                v.append(curr)
                curr = arr[i]
            v.append(curr)
        elif curr > s:
            curr -= arr[i]
            v.append(curr)
            curr = arr[i]
        i += 1

    if len(set(v)) == 1:
        print(""YES"")

        ans = 1
        exit()

if not ans:
    print(""NO"")
",O(n ^ 2)
"def max_subarray(A):
    max_ending_here = max_so_far = A[0]
    for x in A[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

ans = 0
n, m, k = map(int, input().split())
a = list(map(int, input().split()))
for i in range(m):
    li = a[0:i] + [-k]
    s = 0
    while True:
        li += a[i+s:min(i+m+s, len(a))]
        li += [-k]
        if i+m+s >= len(a):
            break
        s += m
    ans = max(max_subarray(li) - k,ans)
print(ans)
",O(n ^ 2)
"def cal(x, n):
    return (1 + n - x) * (n - x) // 2 - x

n, k = map(int, input().strip().split())
low, hgh, mid = 0, n, -1
while low <= hgh:
    mid = (low + hgh) // 2
    cm = cal(mid, n)
    if cm == k:
        print(mid)
        break
    elif cm > k:
        low = mid + 1
    else:
        hgh = mid - 1",O(logn)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    counter=collections.Counter(arr)
    ans=set()
    for i in counter:
        for j in range(1,32):
            no=2**j
            diff=no-i
            if diff<0:
                continue
            if diff==i:
                if counter[i]>1:
                    ans.add(i)

                    break
            else:
                if diff not in  counter:
                    continue
                else:
                    ans.add(i)

                    break

    val=0
    ans=list(ans)
    for i in ans:
        val+=counter[i]
    print(n-val)",O(nlogn)
"import sys, collections

n, k = map(int, sys.stdin.readline().split())
left = 0
right = n + 1
while left < right:
    mid = (left + right) // 2
    candy = n - mid
    total = (candy * (candy + 1)) // 2 - mid
    if total < k:
        right = mid
    elif total > k:
        left = mid + 1
    else:
        print(mid)
        break",O(logn)
"class Solution(object):
    def maxDistToClosest(self, seats):
        prev, result = -1, 1
        for i in range(len(seats)):
            if seats[i]:
                if prev < 0:
                    result = i
                else:
                    result = max(result, (i-prev)//2)
                prev = i
        return max(result, len(seats)-1-prev)",O(n)
"class Solution2(object):
    def tribonacci(self, n):
        a, b, c = 0, 1, 1
        for _ in range(n):
            a, b, c = b, c, a+b+c
        return a",O(logn)
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > k:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length",O(n)
"import collections


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def serialize(self, root):
        def serializeHelper(node, vals):
            if node:
                vals.append(node.val)
                serializeHelper(node.left, vals)
                serializeHelper(node.right, vals)

        vals = []
        serializeHelper(root, vals)

        return ' '.join(map(str, vals))


    def deserialize(self, data):
        def deserializeHelper(minVal, maxVal, vals):
            if not vals:
                return None

            if minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = deserializeHelper(minVal, val, vals)
                node.right = deserializeHelper(val, maxVal, vals)
                return node
            else:
                return None

        vals = collections.deque([int(val) for val in data.split()])

        return deserializeHelper(float('-inf'), float('inf'), vals)",O(n)
"import sys

def input():
    return sys.stdin.readline().strip()

def dinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rt(x1, x2, y3):
    print(0.5 * (x2 + x1) * y3)

def main():
    n, k = rinput()
    i = 0
    t = 0
    while k > i:
        t += 1
        i += t
    c = n - t
    i -= c
    while i != k:
        t += 1
        i += t + 1
        c -= 1
    print(c)
main()",O(n)
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))
s=input()
for j in range(n):
    lst[j]=[lst[j],j+1]
lst.sort()
stk=[]
i=0
for j in range(2*n):
    if s[j]=='0':
        stk.append(lst[i][1])
        print(lst[i][1],end="" "")
        i+=1

    else:
        print(stk[-1],end="" "")
        stk.pop()
",O(nlogn)
"for i in range(int(input())):
    n,k=[int(i) for i in input().split()]
    if n>31:
        print('YES '+str(n-1))
    else:
        rez=-1
        for i in range(1,n+1):
            x=(4**i-2**(i+1)+1)*((4**(n-i)-1)//3)+(4**i-1)//3
            y=(4**i-1)//3-(4**(i-1)-1)//3
            if y<=k<=x:
                rez=n-i
                break
        print('YES '+str(rez) if rez!=-1 else 'NO')",O(logn)
"import sys
sys.setrecursionlimit(2000)
from collections import Counter

if __name__ == ""__main__"":

    n = [int(val) for val in input().split()][0]
    b = [int(val) for val in input().split()]

    l = 0
    r = b[0]
    a = [0] * n
    for i in range(n//2):
        a[i] = l
        a[n-1-i] = r
        if(i != n//2-1):
            val = b[i+1]
            summ = l + r
            if(summ == val):
                continue
            elif(summ > val):
                diff = summ - val
                r -= diff
            elif(summ < val):
                diff = val - summ
                l += diff

    for i in a:
        print(i, end=' ')
    print('')
",O(n)
"class Solution2(object):
    def pancakeSort(self, arr):
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
            
        idxs = []
        smaller_counts = [0]*len(arr)
        for i, x in enumerate(arr):
            idxs.append((x, i))
        smallerMergeSort(idxs, 0, len(idxs)-1, smaller_counts)
        result = []
        for i, n in enumerate(smaller_counts):
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result",O(nlogn)
"class Solution(object):
    def convertBST(self, root):
        def convertBSTHelper(root, cur_sum):
            if not root:
                return cur_sum

            if root.right:
                cur_sum = convertBSTHelper(root.right, cur_sum)
            cur_sum += root.val
            root.val = cur_sum
            if root.left:
                cur_sum = convertBSTHelper(root.left, cur_sum)
            return cur_sum

        convertBSTHelper(root, 0)
        return root",O(n)
"k = int(input())
n = 0
i = 0
while (k > n):
    n += pow(10, i) * 9 * (i + 1)
    i = i + 1
n -= pow(10, i - 1) * 9 * i
k -= n
t = (k - 1) / i
r = k % i
if (r == 0):
    r = i
m = pow(10, i - 1) + t
m = int(m)
ans = int(m / pow(10,i - r)) % 10
print(ans)

def pow(i):
    n = 1
    for x in range(0,i):
        n*=10
    return n
",O(logn)
"def res(d,N):
    for i in range(1,N):
        if d[i][1] <= d[i-1][1]:
            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)
    return '-1 -1'

N = int(input())
d = []
for i in range(N):
    a,b = map(int,input().split())
    d.append((a,b,i))
d = sorted(d, key = lambda x:(x[0],-x[1]))
print(res(d,N))
",O(nlogn)
"class Solution(object):
    def canChoose(self, groups, nums):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(start, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True",O(n)
"class Solution(object):
    def createTargetArray(self, nums, index):
        for i in range(len(nums)):
            for j in range(i):
                if index[j] >= index[i]:
                    index[j] += 1
        result = [0]*(len(nums))
        for i in range(len(nums)):
            result[index[i]] = nums[i]
        return result",O(n ^ 2)
"import re
def main():

    total_games, total_notes = map(int, input().split())
    games = [int(i) for i in input().split()]
    notes = [int(i) for i in input().split()]
    note = 0
    for game in games:
        if notes[note] >= game:
            note += 1
        if note == total_notes:
            break
    print(note)

main()",O(n)
"import collections
import itertools


class Solution3(object):
    def rearrangeString(self, s, k):
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        buckets = [[] for _ in range(bucket_cnt)]
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2)):
            for _ in range(cnts[c]):
                buckets[i].append(c)
                i = (i+1) % max(cnts[c], bucket_cnt-1)
        if any(len(buckets[i]) < k for i in range(len(buckets)-1)):
            return """"
        return """".join(["""".join(x) for x in buckets])",O(n)
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
fl = 0
m = n
s = list(range(n))
for i in range(n):
    s[i] = m - (l[i] + r[i])
    if fl != 1 and s[i] == m:
        fl = 1
for i in range(n):
    ll = 0;
    for j in range(i):
        if s[j] > s[i]:
            ll += 1
    rr = 0
    for j in range(i + 1, n):
        if s[j] > s[i]:
            rr += 1
    if l[i] != ll or rr != r[i]:
        fl = 0
        break

if fl == 1 and l[0] == 0 and r[n - 1] == 0:
    print('YES')
    print(*s)
else:
    print('NO')
",O(n ^ 2)
"a = int(input())
print((a // 2) * 3)",O(1)
"class Solution(object):
    def validSubarrays(self, nums):
        result = 0
        s = []
        for num in nums:
            while s and s[-1] > num:
                s.pop()
            s.append(num)
            result += len(s)
        return result",O(n)
"def bs(n, k, lo, hi):
    while lo <= hi:
        mid = (hi + lo)//2
        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)
        if summ == n: return k - mid + 1
        elif summ > n: lo = mid + 1
        elif summ < n: hi = mid - 1
    if summ > n: mid += 1
    return k - mid + 1

def solve():
    n, k = map(int, input().split())
    if n == 1: return 0
    elif (k * (k + 1)//2) - (k-2) <= n: return -1
    elif k >= n: return 1
    else: return bs(n, k, 2, k)

print(solve())",O(logn)
"class Solution(object):
    def countPartitions(self, nums):
        result = left = 0
        right = sum(nums)
        for i in range(len(nums)-1):
            left += nums[i]
            right -= nums[i]
            if left%2 == right%2:
                result += 1
        return result",O(n)
"from itertools import zip_longest


class Solution2(object):
    def addBinary(self, a, b):
        result = """"
        carry = 0
        for x, y in zip_longest(reversed(a), reversed(b), fillvalue=""0""):
            carry, remainder = divmod(int(x)+int(y)+carry, 2)
            result += str(remainder)
        
        if carry:
            result += str(carry)
        
        return result[::-1]",O(n)
"x=int(input())
d=x//2
print(d+1)
",O(1)
