[{"instruction":"if __name__ == \"__main__\":\n    s = input().rstrip().split()\n    N = int(s[0])\n    K = int(s[1])\n    a = list(map(int, list(input().rstrip().split())))\n\n    diff = []\n    for i in range(1, N):\n        diff.append([i, a[i] - a[i - 1]])\n    diff = sorted(diff, key = lambda x: -x[1])\n    res = max(a) - min(a)\n\n    k = 0\n    while (k < K - 1 and k < len(diff)):\n        res -= diff[k][1]\n\n        k += 1\n    print(res)","output":"nlogn"},{"instruction":"from collections import deque, defaultdict, Counter\nfrom itertools import product, groupby, permutations, combinations\nfrom math import gcd, floor, inf, log2, sqrt, log10\nfrom bisect import bisect_right, bisect_left\nfrom statistics import mode\nfrom string import ascii_uppercase\n\nk = int(input()) -1\n\ny = 9\nx = 1\nwhile k > x*y:\n    k -= x*y\n    y *= 10\n    x += 1\n\nstart = 10**(x-1)\nstart += k\/\/x\n\nprint(str(start)[k%x])","output":"logn"},{"instruction":"MOD=int(1e9+7)\nn=int(input())\na=[]\nfor i in range(n):\n    a.append(input())\na=\"\".join(a)\ndp,s=[],[]\nfor i in range(n+1):\n    dp.append([0]*(n+1))\n    s.append([0]*(n+1))\ndp[0][0]=1\ns[0][0]=1\nfor i in range(1,n):\n    for j in range(0,n):\n        if a[i-1]=='f':\n            dp[i][j+1]=dp[i-1][j]%MOD\n        elif a[i-1]=='s':\n            dp[i][j]=s[i-1][j]%MOD\n\n    for j in reversed(range(n)):\n        s[i][j]+=(dp[i][j]+s[i][j+1])%MOD\nprint(s[n-1][0]%MOD)","output":"quadratic"},{"instruction":"a, b = map(int, input().split(\" \"))\n\na, b = min(a, b), max(a, b)\n\nbina = str(bin(a))[2:]\nbinb = str(bin(b))[2:]\n\nlena = len(bina)\nlenb = len(binb)\n\nans = 0\nif lena != lenb:\n\tans = 2**lenb-1\nelse:\n\ta = '0'*(lena-lenb) + bina\n\tfor i in range(lenb):\n\t\tif (bool(int(bina[i])) != bool(int(binb[i]))):\n\t\t\tans = 2**(lenb-i) - 1\n\t\t\tbreak\n\nprint(ans)","output":"logn"},{"instruction":"n, k = map(int, input().split())\nli = [int(num) for num in input().split(\" \", n - 1)]\nans = []\nfor i in range(0, n):\n    su = 0\n    for j in range(i, n):\n        su += li[j]\n        if (j - i + 1 >= k):\n            ans.append(su \/ (j - i + 1))\nprint(max(ans))","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nparity = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if a[i] > a[j]:\n            parity ^= 1\nres = []\nfor _ in range(m):\n    l, r = map(int, input().split())\n    s = r - l + 1\n    parity ^= (s * (s - 1) \/\/ 2) % 2\n    res.append(\"odd\" if parity else \"even\")\nprint(\"\\n\".join(res))","output":"quadratic"},{"instruction":"import sys\nimport heapq\ninput = sys.stdin.readline\n\nn,x,y = map(int,input().split())\nMOD_NUM = 10**9+7\n\nevents = dict()\nfor i in range(n):\n    l,r = map(int,input().split())\n    if l not in events:\n        events[l] = []\n    events[l].append(r)\n\ntv = []\npq = []\ncost = 0\n\nfor t in sorted(events):\n    while tv and tv[0] < t:\n        heapq.heappush(pq, -(x + heapq.heappop(tv)*y))\n\n    for ri in sorted(events[t],reverse=True):\n        if pq and -pq[0] > t*y:\n            val = -heapq.heappop(pq)\n            rj = (val-x)\/\/y\n\n            cost += (ri-rj)*y\n            heapq.heappush(tv, ri)\n        else:\n            cost += x + (ri-t)*y\n            heapq.heappush(tv, ri)\n    cost %= MOD_NUM\n\nprint(cost)","output":"nlogn"},{"instruction":"from math import *\nimport sys\n\ninput = sys.stdin.readline\n\ndef bin_search(arr, n):\n\n\tpos = -1\n\n\tfor i in range(35, -1, -1):\n\t\tjump = (1 << i)\n\n\t\tif (pos + jump) >= len(arr):\n\t\t\tcontinue\n\n\t\tif arr[pos + jump] <= n-1:\n\t\t\tpos += jump\n\n\treturn len(arr) - pos - 1\n\ndef main():\n\tn, m = [int(x) for x in input().split(' ')]\n\n\tvert = []\n\tfor i in range(n):\n\t\tvert.append(int(input()))\n\n\thor = []\n\tfor i in range(m):\n\t\tcol1, col2, row = [int(x) for x in input().split(' ')]\n\n\t\tif col1 != 1:\n\t\t\tcontinue\n\n\t\thor.append((col2))\n\n\tvert.append(1000000000)\n\n\tvert = sorted(vert)\n\thor = sorted(hor)\n\n\tbest = int(1e10)\n\n\tfor i in range(len(vert)):\n\t\tcur_ans = bin_search(hor, vert[i]) + i\n\t\tbest = min(best, cur_ans)\n\n\tprint(best)\n\nif __name__ == \"__main__\":\n\tmain()","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = rint()\n    deg, edges = [0] * n, rints_2d(n - 1)\n    for u, v in edges:\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n\n    coun = [0, deg.count(1), deg.count(2)]\n\n    if n - coun[1] == 1:\n        print(f'Yes\\n{n - 1}')\n        [print(*x) for x in edges]\n\n    elif coun[1] + coun[2] == n:\n        print(f'Yes\\n1\\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')\n\n    elif n - sum(coun) == 1:\n        for i in range(n):\n            if deg[i] > 2:\n                print(f'Yes\\n{deg[i]}')\n                for j in range(n):\n                    if deg[j] == 1:\n                        print(i + 1, j + 1)\n                exit()\n    else:\n        print('No')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\ndef power(a,b,z):\n    if b==0:\n        return 1\n    temp=power(a,b\/\/2,z)\n    if b%2==0:\n        return (temp*temp)%z\n    return (a*temp*temp)%z\nx,k=list(map(int,input().split()))\nif x==0:\n    print(0)\nelse:\n    z=(10**9)+7\n    n=(power(2,k+1,z)*x)%z\n    m=power(2,k,z)\n    print((n-m+1)%z)","output":"logn"},{"instruction":"read = lambda: map(int, input().split())\ndef sq(x):\n    return int(x ** 0.5) ** 2 == x\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if (n % 2 == 0 and sq(n \/\/ 2)) or (n % 4 == 0 and sq(n \/\/ 4)):\n        print('YES')\n    else:\n        print('NO')","output":"constant"},{"instruction":"import sys\n\ndef main():\n\n    n,k=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    arr.sort(reverse=True)\n    dic={}\n    for a in arr:\n        if a*k not in dic:\n            dic[a]=1\n\n    print(len(dic))\n\nmain()","output":"nlogn"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    a = int(input())\n    b = int(input())\n    a = list(str(a))\n    a.sort()\n    ans = []\n    while a:\n        for i in range(len(a) - 1, -1, -1):\n            c = ans + [a[i]] + a[:i] + a[i+1:]\n            if int(''.join(c)) <= b:\n                ans.append(a[i])\n                a.pop(i)\n                break\n    print(''.join(ans))\n\nmain()","output":"cubic"},{"instruction":"n,m=map(int,input().split())\nlock=0\nfor i in range(n):\n    s=str(input())\n    if(('B' in s) and (lock==0)):\n        Rstart=s.index('B')\n        cnt=s.count('B')\n        Rcen=Rstart+(cnt\/\/2)\n        Cstart=i\n        Ccen=Cstart+(cnt\/\/2)\n        lock=1\n\nprint(Ccen+1,Rcen+1)","output":"quadratic"},{"instruction":"n, t = [int(item) for item in input().split(' ')]\ncont, ans = [], 2\nfor i in range(n):\n\n    temp = list(map(int, input().split(' ')))\n    house_center, house_len = temp[0], temp[1]\n    cont.append([house_center - house_len \/ 2, house_center + house_len \/ 2])\n\ncont.sort(key=lambda element: element[0])\n\nfor i in range(0,n - 1):\n    gap = cont[i+1][0] - cont[i][1]\n    if gap > t:\n        ans += 2\n    elif gap == t:\n        ans += 1\n\nprint(ans)","output":"nlogn"},{"instruction":"cadena = input()\nn = len(cadena)\n\nrpta = 0\n\nfor i in range(n-1):\n    tamanho_cadena = n-i-1\n    for j in range(n-tamanho_cadena):\n        subcadena = cadena[j:j+tamanho_cadena]\n        contador = 1\n        for k in range(n-tamanho_cadena-j):\n            if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]:\n                contador = contador + 1\n        if contador >=2  and rpta == 0:\n            rpta = tamanho_cadena\n    if rpta !=0:\n        break\n\nprint(rpta)","output":"cubic"},{"instruction":"n,m=map(int,input().split())\na=list(map(int,input().split()))\ndic={}\nfor i in range(m):\n  if a[i] in dic:\n    dic[a[i]]+=1\n  else:\n    dic[a[i]]=1\nfor i in range(1,102):\n  r=0\n  for j in dic:\n    r+=dic[j]\/\/i\n  if r<n:\n    print(i-1)\n    break","output":"nlogn"},{"instruction":"from bisect import bisect\nn, m = map(int, input().split())\nvv = sorted([int(input()) for _ in range(n)])\nhh = [0] * n\nrr = 0\nfor _ in range(m):\n  one, x, _ = map(int, input().split())\n  if one == 1:\n    if x == 1000000000:\n      rr += 1\n    else:\n      ind = bisect(vv, x)\n      if ind:\n        hh[ind-1] += 1\nr = n\ns = 0\n\nfor i, h in reversed(list(enumerate(hh))):\n  s += h\n\n  r = min(r, s+i)\nprint(r+rr)","output":"nlogn"},{"instruction":"def solve():\n    n, l, r, x = map(int, input().split(' '))\n    c = list(map(int, input().split(' ')))\n    ans = 0\n    for bitmask in range(2 ** n):\n        if bin(bitmask).count('1') > 1:\n            res, _min, _max = 0, float('+inf'), float('-inf')\n            for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))):\n                if bit_i:\n                    res += c_i * bit_i\n                    if c_i < _min:\n                        _min = c_i\n                    if c_i > _max:\n                        _max = c_i\n            if l <= res <= r and (_max - _min) >= x:\n                ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    solve()","output":"np"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef bit_count(x):\n    ans = 0\n    while x:\n        x &= x-1\n        ans += 1\n    return ans\n\ndef main():\n    n = input().strip()\n    x = len(n)\n    k = int(input())\n    if n == '1':\n        print(int(k==0))\n        exit()\n    if not k:\n        print(1)\n        exit()\n    mod = 10**9+7\n    dp = [0]*(x+1)\n    dp[1] = 1\n    for i in range(2,x+1):\n        dp[i] = dp[bit_count(i)]+1\n    dp1 = [[0]*(x+1) for _ in range(x+1)]\n\n    for i in range(x+1):\n        dp1[i][0] = 1\n    for i in range(1,x+1):\n        for j in range(1,i+1):\n            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod\n    ans = 0\n    cou = n.count('1')\n    for i in range(1,x+1):\n        if dp[i] != k:\n            continue\n        se = i\n        for j in range(x):\n            if n[j] == '0':\n                continue\n            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod\n            se -= 1\n            if se < 0:\n                break\n        if cou == i:\n            ans = (ans+1)%mod\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"def rec(r,g,b):\n    if(dp[r][g][b]!=-1):\n        return dp[r][g][b]\n    ans=0\n    if r<R and g<G:\n        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))\n    if r<R and b<B:\n        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))\n    if b<B and g<G:\n        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))\n    dp[r][g][b]=ans\n    return ans\nR,G,B=map(int,input().split())\nred=sorted(list(map(int, input().split())), reverse=True)\ngreen=sorted(list(map(int, input().split())), reverse=True)\nblue=sorted(list(map(int, input().split())), reverse=True)\ndp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]\nprint(rec(0,0,0))","output":"cubic"},{"instruction":"from math import factorial as fc\ndef per(a,b):\n    return fc(a+b)\/(fc(a)*fc(b))\nimport sys\ns=input()\ns1=input()\nx=s.count(\"+\")\ny=s.count(\"-\")\nx1=s1.count(\"+\")\ny1=s1.count(\"-\")\np=x-y\np1=x1-y1\nq=s1.count(\"?\")\ndif=p-p1\nif q<abs(p1-p) or dif>q:\n    print(0.0)\n    sys.exit()\nm=abs(y-y1)\npl=abs(x-x1)\nprint(per(m,pl)\/(2**(m+pl)))","output":"np"},{"instruction":"import math\n\nline = input().split()\nN = int(line[0])\nK = int(line[1])\n\nn = (-3 + math.sqrt(9+4*(2*N+2*K)))\/2\n\nprint(int(N-n))","output":"logn"},{"instruction":"n=int(input())\nx=list(map(int,input().split()))\nx.sort()\ncount,count2=0,0\nans=1\nfor i in range(n):\n    count+=x[i]-i\n    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0\n    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0\n    if i>=1 and x[i]==x[i-1]: count2+=1\nif n>=3 and x[0]==x[1]==0: ans=0\nfor i in range(n):\n    if x[i]>0: break\n    if i==n-1: ans=0\nif ans==0 or count%2==0 or count2>1: print(\"cslnb\")\nelse: print(\"sjfnb\")","output":"nlogn"},{"instruction":"from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    l=sorted(zip(lst(),range(n)))\n    p=0;ans=[0]*(2*n)\n    st=[0]*n;ln=0\n    s=input()\n    for i in range(2*n):\n\n        ch=s[i]\n        if ch=='0':\n            st[ln]=p\n            ans[i]=l[p][1]+1\n            ln+=1\n            p+=1\n        else:\n            ans[i]=l[st[ln-1]][1]+1\n            ln-=1\n    print(*ans)","output":"nlogn"},{"instruction":"n = int(input())\nl = list(map(int, input().split()))\nansl = ['sjfnb', 'cslnb']\nans = -1\nd = dict()\nval = 0\nif n == 1:\n    ans = (l[0] + 1) % 2\nelse:\n    l.sort()\n    for elem in l:\n        d[elem] = d.get(elem, 0) + 1\n    hm = 0\n    which = -1\n    i = 0\n    for elem in d.values():\n        if elem >= 2:\n            hm += 1\n            which = i\n        i += 1\n    which = list(d.keys())[which]\n    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:\n        ans = 1\n    elif hm == 1 and d.get(which - 1, 0) > 0:\n        ans = 1\n    else:\n        for i in range(n):\n            val += l[i] - i\n        ans = (val + 1) % 2\nprint(ansl[ans])","output":"nlogn"},{"instruction":"import math\nn=int(input())\n\na=[9]\nfor i in range(2,20):\n    a.append(10**i   - 10**(i-1) )\nb=[0]\nfor i in range(1,20):\n    b.append(b[-1]+ i*a[i-1])\nfor i in range(20):\n    if n<=b[i]:\n        break\np=b[i-1]\nk=n-p\n\nans=10**(i-1) - 1 + math.ceil(k\/(i))\n\nif k%i==0:\n    print(('0'+str(ans))[i])\nelse:\n    print(('0'+str(ans))[k%i])","output":"logn"},{"instruction":"n=int(input())\nc=[0]*4\nfor k in range(4):\n for i in range(n):\n  s=input()\n  for j in range(n):\n   if(i+j)%2!=int(s[j]):c[k]+=1\n if k<3:input()\nc.sort()\nprint(c[0]+c[1]+2*n*n-c[2]-c[3])","output":"quadratic"},{"instruction":"import sys\nimport math\nimport collections\nimport heapq\ninput=sys.stdin.readline\nk1,k2,k3=(int(i) for i in input().split())\nl=[k1,k2,k3]\nif(1 in l):\n    print(\"YES\")\nelif(l.count(2)>=2):\n    print(\"YES\")\nelif(l.count(3)==3):\n    print(\"YES\")\nelif(sorted(l)==[2,4,4]):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import math\nimport sys\n\nDEBUG = False\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\ndef solve(H, W, A):\n    visited = [bytearray(W) for _ in range(H)]\n\n    for y in range(H):\n        for x in range(W):\n            if A[y][x] == '.' or visited[y][x]:\n                continue\n\n            dprint(x, y)\n            for dx, dy in [(0, 0), (-1, 0), (-2, 0),\n                           (0, -1), (-2, -1),\n                           (0, -2), (-1, -2), (-2, -2)]:\n                tx = x + dx\n                ty = y + dy\n                dprint('  ', tx, ty)\n                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:\n                    continue\n                bad = False\n                for ex, ey in [(0, 0), (1, 0), (2, 0),\n                               (0, 1), (2, 1),\n                               (0, 2), (1, 2), (2, 2)]:\n                    nx = tx + ex\n                    ny = ty + ey\n                    if A[ny][nx] == '.':\n                        bad = True\n                        break\n                if bad:\n                    continue\n\n                for ex, ey in [(0, 0), (1, 0), (2, 0),\n                               (0, 1), (2, 1),\n                               (0, 2), (1, 2), (2, 2)]:\n                    nx = tx + ex\n                    ny = ty + ey\n                    visited[ny][nx] = 1\n\n                assert visited[ny][nx] == 1\n                break\n\n            if visited[y][x] == 0:\n                return False\n\n    return True\n\ndef main():\n    H, W = [int(e) for e in inp().split()]\n    A = [inp() for _ in range(H)]\n\n    print('YES' if solve(H, W, A) else 'NO')\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n = int(input())\na = input()\nzero = 0\nfor i in range(len(a)):\n    if (a[i] == \"0\"):\n        zero += 1\nif (\"1\" in a):\n    print(\"1\", end=\"\")\n    print(\"0\"*zero)\nelse:\n    print(\"0\"*zero)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef float_array():\n\treturn list(map(float, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\nfrom collections import Counter\nimport math\nimport bisect\nfrom collections import deque\nn,m,lesson=int_array()\ndp=[[250005 for i in range(lesson+2)]for j in range(n+1)]\ndays=[[] for i in range(n)]\nfor i in range(n):\n\ts=input()\n\tfor  j in range(m):\n\t\tif s[j]==\"1\":\n\t\t\tdays[i].append(j+1)\n\nm=[[250005 for i in range(lesson+2)]for j in range(n+1)]\nfor i in range(n):\n\tfor j in range(lesson+1):\n\t\tif j<=len(days[i]):\n\t\t\tif j==len(days[i]):\n\t\t\t\tm[i][j]=0\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tfor k  in range(0,j+1):\n\t\t\t\t\tvar=days[i][0+k]\n\t\t\t\t\tvar1=days[i][-1*max(1,1+(j-k))]\n\t\t\t\t\tm[i][j]=min(m[i][j],var1-var+1)\n\nfor i in range(lesson+1):\n\tdp[0][i]=m[0][i]\nfor i in range(1,n):\n\tfor j in range(lesson+1):\n\t\tfor k in range(j+1):\n\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k])\n\nprint(min(dp[n-1]))","output":"cubic"},{"instruction":"n, m, k = map(int, input().split())\n\nh = []\nfor i in range(n):\n  h.append(list(map(int, input().split())))\n\nv = []\nfor i in range(n - 1):\n  v.append(list(map(int, input().split())))\n\nif k % 2 == 0:\n  d = [[0] * m for i in range(n)]\n  for t in range(k \/\/ 2):\n    dt = [[0] * m for i in range(n)]\n    for i in range(n):\n      for j in range(m):\n        x = float('inf')\n        if i - 1 >= 0:\n          x = min(x, d[i - 1][j] + v[i - 1][j] * 2)\n        if i + 1 < n:\n          x = min(x, d[i + 1][j] + v[i][j] * 2)\n        if j - 1 >= 0:\n          x = min(x, d[i][j - 1] + h[i][j - 1] * 2)\n        if j + 1 < m:\n          x = min(x, d[i][j + 1] + h[i][j] * 2)\n        dt[i][j] = x\n    d = dt.copy()\nelse:\n  d = [[-1] * m for i in range(n)]\nfor i in d:\n    print(*i)","output":"cubic"},{"instruction":"def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\nn = 10**7\nsquares = [i * i for i in range(1, 3162)]\n\np = [i for i in range(n + 1)]\nfor i in range(1, n + 1):\n\tif p[i] == i:\n\t\tfor sq in squares:\n\t\t\tif i * sq > n: break\n\t\t\tp[i * sq] = i\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = [p[a] for a in nrs()]\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [set()] * (K + 1)\n\tfor a in A:\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = set([a])\n\t\t\telse:\n\t\t\t\tused[j].add(a)\n\tprint(min(dp))","output":"cubic"},{"instruction":"import sys\n\nn, l, r, x = map(int, input().split())\ntemp = []\ntemp = list(map(int, input().split()))\n\ntemp.sort()\nans = 0\n\nfor i in range(1 << n):\n    score = 0\n    _min = sys.maxsize\n    _max = -sys.maxsize\n    for j in range(n):\n        if i & (1 << j) > 0:\n            _min = min(_min, temp[j])\n            _max = max(_max, temp[j])\n            score += temp[j]\n    if score >= l and score <= r and _max-_min >= x:\n        ans += 1\n\nprint(ans)","output":"np"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nzl = getIntList()\nzr = getIntList()\n\nzt = [ (zl[i] + zr[i], i) for i in range(N) ]\nzt.sort()\nza = [0 for i in range(N) ]\nnow = N\nfor i in range(N):\n    if i>0 and zt[i-1][0] <zt[i][0]:\n        now-=1\n    za[ zt[i][1] ] = now\n\nfor i in range(N):\n    l = 0\n    r = 0\n    for j in range(i):\n        if za[j] > za[i]:\n            l+=1\n    for j in range(i+1, N):\n        if za[j] > za[i]:\n            r+=1\n    if zl[i] != l or zr[i] != r:\n        print('NO')\n        sys.exit()\nprint('YES')\nfor i in range(N):\n    print(za[i],end = ' ')","output":"quadratic"},{"instruction":"def solve():\n    from sys import stdin\n    f_i = stdin\n\n    n = int(f_i.readline())\n\n    segments = []\n    for i in range(n):\n        x, w = map(int, f_i.readline().split())\n        segments.append((x + w, x - w))\n    segments.sort()\n\n    ans = 0\n    t = segments[0][1]\n    for end, start in segments:\n        if t <= start:\n            ans += 1\n            t = end\n\n    print(ans)\n\nsolve()","output":"nlogn"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect, insort\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nfrom copy import deepcopy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\ndef pmat(A):\n    for ele in A: print(*ele,end=\"\\n\")\n\nn=L()[0]\nA=L()\nA.sort()\nif A[-1]==1:\n    A[-1]=2\nelse:\n    A[-1]=1\n    A.sort()\nprint(*A)","output":"nlogn"},{"instruction":"import sys, os\nfrom collections import defaultdict\n\nif os.environ['USERNAME']=='kissz':\n    inp=open('in.txt','r').readline\n    def debug(*args):\n        print(*args,file=sys.stderr)\nelse:\n    inp=input\n    def debug(*args):\n        pass\n\ndef get_hash(s):\n    r=0\n    for c in s:\n        r*=30\n        if c!='_':\n            r+=ord(c)-96\n    return r\n\ndef matches(s):\n    R=[]\n    for i in range(2**k):\n        r=0\n        for j in range(k):\n            if i&(1<<j):\n                r+=(ord(s[j])-96)*(30**(k-j-1))\n        if pattern_pos[r]>=0:\n\n            R.append(pattern_pos[r])\n    return R\n\nn,m,k=map(int,inp().split())\n\npattern_pos=[-1]*(30**k)\n\nfor i in range(n):\n    p=get_hash(inp().strip())\n    pattern_pos[p]=i+1\n\nparents=[0]*(n+1)\nedges=defaultdict(list)\nfailed=False\nfor i in range(m):\n    s,l=inp().split()\n    l=int(l)\n    M=matches(s)\n    if l in M:\n        for m in M:\n            if l==m: continue\n            edges[l].append(m)\n            parents[m]+=1\n    else:\n        failed=True\n        break\n\nif failed:\n    print('NO')\nelse:\n    Q=[]\n    for i in range(1,n+1):\n        if parents[i]==0:\n            Q.append(i)\n\n    ans=[]\n    while Q:\n        i=Q.pop()\n        ans.append(i)\n        for child in edges[i]:\n            parents[child]-=1\n            if parents[child]==0:\n                Q.append(child)\n    if len(ans)==n:\n        print('YES')\n        print(*ans)\n    else:\n        print('NO')","output":"np"},{"instruction":"n = int(input())\nprint(1+2*((n-1)*n))","output":"constant"},{"instruction":"import math\nimport sys\nfrom collections import deque\n\ndef scan() -> list:\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solution() -> None:\n\n    n, k = scan()\n    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))\n\nif __name__ == '__main__':\n    solution()","output":"logn"},{"instruction":"from collections import Counter\nn, m = map(int, input().split())\nc = Counter(input().split()).values()\nd = 1\nwhile sum(ci\/\/d for ci in c) >= n:\n    d += 1\nprint(d - 1)","output":"nlogn"},{"instruction":"def pow_mod(x, pwr, mod):\n\tres = 1\n\tmultiplier = x\n\twhile pwr > 0:\n\t\tif pwr%2 == 1:\n\t\t\tres = res*multiplier % mod\n\t\tmultiplier = multiplier*multiplier % mod\n\n\t\tpwr \/\/= 2\n\n\treturn res\n\n[x, k] = map(int, input().split())\n\nMOD = 1000000007\n\nif x == 0:\n\tres = 0\nelse:\n\tres = pow_mod(2, k+1, MOD)*x % MOD\n\tres = (res - pow_mod(2, k, MOD)) % MOD\n\tres = (res + 1) % MOD\n\nprint(res)","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = [0] + list(map(int, input().split()))\na.sort()\nans = 0\nh = a[-1]\nfor i in range(n, 0, -1):\n\tif a[i - 1] < h - 1:\n\t\tans = ans + a[i] - h + a[i - 1]\n\t\th = a[i - 1]\n\telse:\n\t\tans = ans + a[i] - 1\n\t\th = h - 1\nprint(ans)","output":"nlogn"},{"instruction":"import math\na=input()\nb=input()\nc=int(0)\nd=int(0)\nq=int(0)\nfor i in range(len(a)):\n    if a[i]==\"+\":\n        c+=1\n    elif a[i]==\"-\":\n        c-=1\nfor i in range(len(b)):\n    if b[i]==\"+\":\n        d+=1\n    elif b[i]==\"-\":\n        d-=1\n    else:\n        q+=1\nif c == d:\n    print((math.factorial(q)\/(math.factorial(q\/2)*math.factorial(q\/2)))\/(2**q))\nelse:\n    mx=d+q\n    mn=d-q\n    if c>mx or c<mn:\n        print(0.0)\n    else:\n        ans=c-d\n        if ans > 0:\n            print((math.factorial(q)\/(math.factorial(((q-ans)\/2)+ans)*math.factorial((q-ans)\/2)))\/(2**q))\n        else:\n            print((math.factorial(q)\/(math.factorial((q-ans)\/2)*math.factorial(((q-ans)\/2)+ans)))\/(2**q))","output":"np"},{"instruction":"import sys,math\na,b=map(int,input().split())\nl=list(map(int,input().split()))\nt=[[-1,0] for i in range(100001)]\nfor i in range(a):\n    if t[l[i]][0]!=-1:print(0);sys.exit()\n    t[l[i]][0]=3\ns=math.inf\nfor i in range(a):\n    if t[l[i]&b][0]!=-1:\n\n        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:\n            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]\n\n    else:t[l[i]&b]=[2,1]\n\nfor i in range(a):\n    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])\nif s==math.inf:\n    print(-1)\nelse:\n    print(s)","output":"linear"},{"instruction":"from sys import stdin\ninput=stdin.readline\nfrom collections import defaultdict\ndef f(d,n):\n    res=0\n    prev=None\n    ans=[0]*(n+1)\n    for i in sorted(d.keys()):\n\n        if prev==None:\n            prev=i\n        else:\n            ans[res]+=i-prev\n            prev=i\n        res+=d[i]\n    return ans[1:]\n\nn=int(input())\nd=defaultdict(int)\nfor i in range(n):\n    x,y=map(int,input().strip().split())\n    d[x]+=1\n    d[y+1]-=1\nprint(*f(d,n))","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nw = sum(a[i] == i + 1 for i in range(n))\nprint(\"Petr\") if w >= n \/\/ 1000 else print(\"Um_nik\")","output":"nlogn"},{"instruction":"x0, y0 = map(int, input().split())\nn = int(input())\narr = [[x0, y0]]\nfor i in range(0, n):\n    x, y = map(int, input().split())\n    arr.append([x, y])\ndist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]\nfor i in range(0, n+1):\n    for j in range(0, n+1):\n        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2\n\ndef dfs(status, memo, pp):\n    if memo[status] != None:\n        return memo[status]\n    if status < 0:\n        return 1e8\n    res = 1e8\n    prev = []\n    for i in range(1, n+1):\n        if (status & (1 << (i - 1))) == 0:\n            continue\n        t1 = status ^ (1 << (i - 1))\n\n        temp = dfs(t1, memo, pp) + dist[0][i]*2\n        if temp < res:\n            res = temp\n            prev = [i, 0]\n        for j in range(i+1, n+1):\n            if j == i:\n                continue\n            if (t1 & (1 << (j - 1))) == 0:\n                continue\n            next = t1 ^ (1 << (j - 1))\n            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]\n            if temp < res:\n                res = temp\n                prev = [i, j, 0]\n        break\n    memo[status] = res\n    pp[status] = prev\n    return res\n\nmemo = [None for i in range(0, 1 << n)]\npp = [None for i in range(0, 1 << n)]\nmemo[0] = 0\npp[0] = []\nstart = 0\nend = 0\nfor i in range(0, n):\n    end += (1 << i)\nres = dfs(end, memo, pp)\npath = [0]\ncur = end\nwhile cur > 0:\n    prev = pp[cur]\n    path.extend(prev)\n    for i in range(len(prev) - 1):\n        cur -= (1 << (prev[i] - 1))\n\nprint(res)\nprint(' '.join(map(str, path)))","output":"np"},{"instruction":"x,k=map(int,input().split())\nif x==0:\n  print(0)\n  exit()\nmod=10**9+7\np=pow(2,k,mod)\nprint((2*p*x-p+1)%mod)","output":"logn"},{"instruction":"import math\nfrom decimal import Decimal\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - Decimal(1)) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) \/ 2\n\nline = input()\nn = Decimal(line.split()[0])\nk = Decimal(line.split()[1])\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(2,k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = math.floor((3 + discriminant) \/ 2)\n    res2 = math.floor((3 - discriminant) \/ 2)\n    res1 = max(res1, res2)\n    print(int(k - res1 + 1));","output":"logn"},{"instruction":"import sys\ninput=sys.stdin.readline\nhashi=dict()\nfor i in range(1,10**5):\n    hashi[i*i]=1\n    hashi[(2*i*i)]=1\nt=int(input())\nfor you in range(t):\n    n=int(input())\n    if(n%2):\n        print(\"NO\")\n        continue\n    z=n\/\/2\n    if(z in hashi):\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"def main():\n    a = sorted(input(), reverse=True)\n    b = int(input())\n    k = \"\"\n    while len(a) > 0:\n        for i in range(len(a)):\n            num = k + a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\n            if int(num) <= b:\n                k += a[i]\n                a = a[:i] + a[i + 1:]\n                break\n    print(k)\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef matching(n,m,path):\n\n    match1 = [-1]*n\n    match2 = [-1]*m\n    for node in range(n):\n        for nei in path[node]:\n            if match2[nei] == -1:\n                match1[node] = nei\n                match2[nei] = node\n                break\n    while 1:\n        bfs = [node for node in range(n) if match1[node] == -1]\n        depth = [-1]*n\n        for node in bfs:\n            depth[node] = 0\n\n        for node in bfs:\n            for nei in path[node]:\n                next_node = match2[nei]\n                if next_node == -1:\n                    break\n                if depth[next_node] == -1:\n                    depth[next_node] = depth[node]+1\n                    bfs.append(next_node)\n            else:\n                continue\n            break\n        else:\n            break\n        pointer = [len(c) for c in path]\n        dfs = [node for node in range(n) if depth[node] == 0]\n        while dfs:\n            node = dfs[-1]\n            while pointer[node]:\n                pointer[node] -= 1\n                nei = path[node][pointer[node]]\n                next_node = match2[nei]\n                if next_node == -1:\n                    while nei != -1:\n                        node = dfs.pop()\n                        match2[nei],match1[node],nei = node,nei,match1[node]\n                    break\n                elif depth[node]+1 == depth[next_node]:\n                    dfs.append(next_node)\n                    break\n            else:\n                dfs.pop()\n    return n-match1.count(-1)\n\ndef main():\n    n,m = map(int,input().split())\n    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]\n    ans = float(\"inf\")\n    for centre in range(n):\n        path = [[] for _ in range(n)]\n        cost = 2*n-1\n        extra = m\n        for u,v in edg:\n            if u == centre or v == centre:\n                cost -= 1\n                extra -= 1\n            else:\n                path[u].append(v)\n        maxMatch = matching(n,n,path)\n        extra -= maxMatch\n        cost += n-1-maxMatch+extra\n        ans = min(ans,cost)\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:\n    print('NO')\nelse:\n    print('YES')\n","output":"constant"},{"instruction":"from random import randint\n\nmod = 10**9 + 7\nd = {}\nn, m, l = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\ndef go(i, j, k):\n    val = i * 40401 + j * 201 + k\n    ret = 0\n    if val in d:\n        return d[val]\n    elif i < n and j < m and k < l:\n        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))\n    elif i < n and j < m:\n        ret = a[i] * b[j] + go(i + 1, j + 1, k)\n    elif j < m and k < l:\n        ret = b[j] * c[k] + go(i, j + 1, k + 1)\n    elif k < l and i < n:\n        ret = c[k] * a[i] + go(i + 1, j, k + 1)\n    d[val] = ret\n    return ret\n\na.sort(reverse = True)\nb.sort(reverse = True)\nc.sort(reverse = True)\nprint(go(0, 0, 0))","output":"cubic"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\nX = [0 for i in range(n)]\nY = [0 for i in range(n)]\nfor _ in range(n):\n    X[_],Y[_] = mi()\n\ndef solve(n,X,Y):\n    if n<=3:\n        return True\n\n    def check(i,j,k):\n        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])\n\n    a,b = -1,-1\n    for i in range(n):\n        if not check(0,1,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    a,b = -1,-1\n    for i in range(n):\n        if not check(2,1,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    a,b = -1,-1\n    for i in range(n):\n        if not check(0,2,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    return False\n\nprint(\"YES\" if solve(n,X,Y) else \"NO\")","output":"nlogn"},{"instruction":"a = list(input())\nb = int(input())\na.sort(reverse=True)\n\nans=''\nwhile a:\n    for i in range(len(a)):\n        temp=''\n        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))\n        if int(x)<=b:\n            ans+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(int(ans))","output":"cubic"},{"instruction":"import os\nimport heapq\nimport sys, threading\nimport math\nimport bisect\nimport operator\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 5)\nfrom io import BytesIO, IOBase\n\ndef gcd(a, b):\n    if b == 0:\n\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef power(x, p, m):\n    res = 1\n    while p:\n        if p & 1:\n            res = (res * x) % m\n        x = (x * x) % m\n        p >>= 1\n    return res\n\ndef inar():\n    return [int(k) for k in input().split()]\n\ndef lcm(num1, num2):\n    return (num1 * num2) \/\/ gcd(num1, num2)\nrr=0\ngg=0\nbb=0\ndp=[]\ndef func(x,y,z,red,green,blue):\n    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):\n        return 0\n    if dp[x][y][z]!=-1:\n        return dp[x][y][z]\n    take=0\n    if x<rr and y<gg:\n        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))\n    if y<gg and z<bb:\n        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))\n    if x<rr and z<bb:\n        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))\n    dp[x][y][z]=take\n    return take\n\ndef main():\n    global rr,gg,bb,dp\n\n    for i in range(202):\n        temp=[]\n        for j in range(202):\n            lis=[]\n            for k in range(202):\n                lis.append(-1)\n            temp.append(lis)\n        dp.append(temp)\n    rr, gg, bb = map(int, input().split())\n    red = inar()\n    green = inar()\n    blue = inar()\n    red.sort(reverse=True)\n    green.sort(reverse=True)\n    blue.sort(reverse=True)\n    print(func(0,0,0,red,green,blue))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"from collections import deque as de\nimport math\nfrom sys import stdin, stdout\nimport re\nfrom collections import Counter as cnt\nfrom functools import  reduce\n\nfrom itertools import groupby as gb\n\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef binarytodecimal(n):\n    return int(n,2)\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n    return prime_factors\n\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef getProduct(n):\n\n    product = 1\n\n    while (n != 0):\n        product = product * (n % 10)\n        n = n \/\/ 10\n\n    return product\n\ndef lcm(x,y):\n   lcm = (x*y)\/\/math.gcd(x,y)\n   return lcm\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\ndef checkisap(list):\n    d=list[1]-list[0]\n    for i in range(2,len(list)):\n        temp=list[i]-list[i-1]\n        if temp !=d:\n            return False\n    return True\n\ndef ceildiv(x,y):\n    return (x+y-1)\/\/y\n\ndef di():return map(int, input().split())\ndef ii():return int(input())\ndef li():return list(map(int, input().split()))\ndef si():return list(map(int, input()))\ndef indict():\n    dic = {}\n    for index, value in enumerate(input().split()):\n        dic[int(index)+1] = int(value)\n    return dic\ndef frqdict():\n\n    dic={}\n    for index, value in enumerate(input().split()):\n        if int(value) not in dic:\n            dic[int(value)] =1\n        else:\n            dic[int(value)] +=1\n    return dic\n\nn,pos, l, r=di()\nif l==1 and r==n:\n    print(0)\nelse:\n    if pos < l:\n        ans=l-pos+1\n        if r <n:\n            ans+=(r-l)\n            ans+=1\n        print(ans)\n    elif l<=pos<=r:\n        if l >1 and r<n:\n            ans=(r-l)\n            ans+=min(pos-l,r-pos)\n            ans+=2\n        elif l>1 and r==n:\n            ans=pos-l\n            ans+=1\n        else:\n            ans=r-pos\n            ans+=1\n        print(ans)\n\n    else:\n        ans=pos-r+1\n        if l>1:\n            ans+=(r-l)\n            ans+=1\n        print(ans)","output":"constant"},{"instruction":"n, k = [int(i) for i in input().split()]\nd = dict()\nd[0] = 1\nx = 0\nfor i in [int(i) for i in input().split()]:\n    x ^= i\n    v = min(x, (1 << k) - x - 1)\n    if v not in d.keys():\n        d[v] = 0\n    d[v] += 1\nans = 0\nfor k, v in d.items():\n    c1 = v \/\/ 2\n    c2 = v - c1\n    ans += c1 * (c1 - 1) \/\/ 2 + c2 * (c2 - 1) \/\/ 2\nprint(n * (n - 1) \/\/ 2 + n - ans)","output":"linear"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\ni = 0\np = []\nwhile 2**i <= 10**18:\n    p.append(2**i)\n    i = i+1\n\nd = {}\ns = set()\nfor i in l:\n    s.add(i)\n    if i in d:\n        d[i] += 1\n\n    else:\n        d[i] = 1\n\nz = set()\nfor i in s:\n    f = 1\n    for j in p:\n        e = j-i\n        if e in s:\n            if e == i and d[e] == 1:\n                continue\n\n            f = 0\n            break\n\n    if f:\n        z.add(i)\n\nans = 0\nfor i in z:\n    ans += d[i]\n\nprint(ans)","output":"nlogn"},{"instruction":"def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    t = input()\n    j = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            j = i\n    s = t + (k - 1) * t[-(n - j):]\n    return s\n\nprint(solve())","output":"quadratic"},{"instruction":"s0=input()\nk=int(input())\ns1=s0[::-1]\nlens1=len(s1)\nmaxnum=1005\nmod=1000000007\ndp=[[0]*maxnum for tmpi in range(maxnum)]\nf=[0]*maxnum\nc=[[0]*maxnum for tmpi in range(maxnum)]\n\ndef cntone(num):\n    tmps=bin(num)[2:]\n    cnt=0\n    for i in range(len(tmps)):\n        if(tmps[i]=='1'):\n            cnt+=1\n    return cnt\n\nfor i in range(1,maxnum):\n    if(i==1):\n        f[i]=0\n    else:\n        f[i]=f[cntone(i)]+1\n\nfor i in range(maxnum):\n    if(i==0):\n        c[i][0]=1\n        continue\n    for j in range(i+1):\n        if(j==0):\n            c[i][j]=1\n        else:\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod\n\nfor i in range(lens1):\n    if(i==0):\n        dp[i][0] = 1\n        if(s1[i]=='1'):\n            dp[i][1]=1\n        else:\n            dp[i][1]=0\n        continue\n    else:\n        for j in range(0,i+2):\n            if(j==0):\n                dp[i][j]=1\n                continue\n            if(s1[i]=='1'):\n                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod\n            else:\n                dp[i][j]=dp[i-1][j]%mod\n\nans=0\n\nfor i in range(1,lens1+1):\n    if(f[i]==k-1):\n        ans=(ans+dp[lens1-1][i])%mod\n\nif(k==0):\n    ans=1\nelif(k==1):\n    ans-=1\nelse:\n    ans=ans\nprint(ans)","output":"linear"},{"instruction":"k = int(input())\na = 9\nfor i in range(1,12):\n    if k<=a*i:\n        a = (a\/\/9)+(k\/\/i)-1\n        if k%i!=0:\n            b = str(a+1)\n            c = (k%i)-1\n            print(b[c])\n        else:\n            b = str(a)\n            print(b[-1])\n        break\n    else:\n        k = k-a*i\n        a = a*10","output":"logn"},{"instruction":"def naiveSolve():\n\n    return\n\ndef main():\n\n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        grid=[]\n        for __ in range(n):\n            grid.append(readIntArr())\n        columns=[]\n        for col in range(m):\n            temp=[grid[i][col] for i in range(n)]\n            columns.append(temp)\n\n        valCol=[]\n        for i in range(n):\n            for j in range(m):\n                valCol.append((grid[i][j],j))\n        valCol.sort(reverse=True)\n\n        topCols=set()\n        for val,col in valCol:\n            topCols.add(col)\n            if len(topCols)==n:\n                break\n\n        m2=len(topCols)\n        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]\n        topColsList=list(topCols)\n        for j in range(m2):\n            col=topColsList[j]\n            for i in range(n):\n                grid2[i][j]=grid[i][col]\n        ans=-inf\n        for mask in range(n**m2):\n            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]\n            for col in range(m2):\n                shift=mask%n\n                for row in range(n):\n                    grid3[row][col]=grid2[(shift+row)%n][col]\n                mask\/\/=n\n            tempAns=0\n            for row in range(n):\n                maxx=-inf\n                for col in range(m2):\n                    maxx=max(maxx,grid3[row][col])\n                tempAns+=maxx\n            ans=max(ans,tempAns)\n        allans.append(ans)\n\n    multiLineArrayPrint(allans)\n\n    return\n\nimport sys\ninput=sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n    return [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory,dimensionArr):\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(r):\n    print('? {}'.format(r))\n    sys.stdout.flush()\n    return readIntArr()\n\ndef answerInteractive(adj,n):\n    print('!')\n    for u in range(1,n+1):\n        for v in adj[u]:\n            if v>u:\n                print('{} {}'.format(u,v))\n    sys.stdout.flush()\n\ninf=float('inf')\nMOD=10**9+7\n\nfrom math import gcd,floor,ceil\n\nfor _abc in range(1):\n    main()","output":"np"},{"instruction":"def read():\n    return [int(v) for v in input().split()]\n\ndef main():\n    mod = 10 ** 9 + 7\n    x, k = read()\n    if x == 0:\n        print(0)\n    else:\n        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"import math, sys\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n, m, k, l = mp()\n    ost = n - k\n    need = (l + k)\n    if ost < l or need > n:\n        print(-1)\n        return\n    ans = (l + k - 1) \/\/ m + 1\n    if ans * m - k >= l and ans * m <= n:\n        print(ans)\n    else:\n        print(-1)\n\ndeb = 0\nif deb:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nelse:\n    input = sys.stdin.readline\n\nmain()\n\nif deb:\n    file.close()","output":"constant"},{"instruction":"n,k=map(int,input().split())\nmod=998244353\ndp=[[0,0,0,0] for _ in range(k+1)]\n\ndp[1][0]=dp[1][3]=1\nif k>1:\n    dp[2][2]=dp[2][1]=1\nfor x in range(1,n):\n    g=[[0,0,0,0] for _ in range(k+1)]\n\n    g[1][0]=g[1][3]=1\n    for i in range(2,k+1):\n        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod\n        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod\n    dp=g\nprint(sum(dp[-1])%mod)","output":"np"},{"instruction":"yellow, blue = map(int, input().split())\nx, y, z = map(int, input().split())\nanswer1 = x*2+y-yellow\nanswer2 = z*3+y - blue\nif answer1 > 0:\n    if answer2 > 0:\n        print(answer1+answer2)\n    else:\n        print(answer1)\nelse:\n    if answer2 > 0:\n        print(answer2)\n    else:\n        print(0)","output":"constant"},{"instruction":"def solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n+1\n    lower_bound = -1\n    while upper_bound > lower_bound + 1:\n        m = (upper_bound + lower_bound) \/\/ 2\n        if (n - m) * (n - m + 1) \/\/ 2 - m > k:\n            lower_bound = m\n        else:\n            upper_bound = m\n    print(upper_bound)\n\nsolve()","output":"logn"},{"instruction":"import math\n\nl1 = input().split()\n\nl1 = [int(i) for i in l1]\n\nl2 = l1[1]\nl1 = l1[0]\n\nx=l1^l2;\ny=1;\nwhile(y<=x):\n  y=y*2;\n\nprint(y-1);","output":"logn"},{"instruction":"def solve(n, arr):\n\ts = sum(arr)\n\tif s == 0:\n\t\treturn \"cslnb\"\n\n\tn_num = {}\n\n\tfor item in arr:\n\t\tif item in n_num:\n\t\t\tn_num[item] += 1\n\t\telse:\n\t\t\tn_num[item] = 1\n\n\tif 0 in n_num and n_num[0] >= 2:\n\t\treturn 'cslnb'\n\n\tfor key in n_num.keys():\n\t\tif n_num[key] >= 3:\n\t\t\treturn \"cslnb\"\n\n\tind_pairs = []\n\tfor key in n_num.keys():\n\t\tif n_num[key] == 2:\n\t\t\tind_pairs.append(key)\n\n\tif len(ind_pairs) >= 2:\n\t\treturn \"cslnb\"\n\telif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:\n\t\treturn \"cslnb\"\n\telse:\n\n\t\tsum_targ = n*(n-1) \/\/ 2\n\n\t\tdif_sum = s - sum_targ\n\n\t\tif dif_sum % 2 == 0:\n\t\t\treturn \"cslnb\"\n\t\telse:\n\t\t\treturn \"sjfnb\"\n\nn = int(input())\n\narr = list(map(int, input().split()))\nprint(solve(n, arr))","output":"linear"},{"instruction":"import sys, os\nfrom io import BytesIO, IOBase\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)\/\/b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nn, m, k = mp()\nhor = [lmp() for i in range(n)]\nver = [lmp() for i in range(n-1)]\nif k%2:\n    ml = l2d(n, m, -1)\n    for i in ml: print(*i)\n    exit()\nk\/\/=2\ndp = [l2d(n, m) for i in range(k+1)]\nfor f in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            a = inf\n            if i!=0:\n                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])\n            if i!=n-1:\n                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])\n            if j!=0:\n                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])\n            if j!=m-1:\n                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])\n            dp[f][i][j] = a\nfor i in dp[-1]:\n    outa(*i)","output":"cubic"},{"instruction":"N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp = defaultdict(lambda :-1)\nM=1000001\nfor i in range(N):\n    dp[i+M] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp[j+M*k], dp[j+k+M*(i-k)]\n            if u == -1 or v == -1 or u != v:\n                continue\n            dp[j+M*i] = u+1;break\n\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    for j in range(i+1):\n        if dp[j+(i+1-j)*M] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])","output":"cubic"},{"instruction":"n = int(input())\na = sorted(list(map(int, input().split())))\nduplicates = {}\nd = None\ndelta = 0\nfor i, el in enumerate(a, 1):\n    if el not in duplicates:\n        duplicates[el] = 0\n    else:\n        d = el\n        duplicates[el] += 1\n    min_value = i-1\n    delta += el - min_value\nif sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):\n    print('cslnb')\nelif delta == 0:\n    print('cslnb')\nelif delta % 2 == 1:\n    print('sjfnb')\nelse:\n    print('cslnb')","output":"linear"},{"instruction":"a,b,c,n=list(map(int,input().split()))\np=(a+b-c)\nf=n-p\nif p>=n or c>a or c>b:\n\tprint(\"-1\")\nelse:\n\tprint(f)","output":"constant"},{"instruction":"N, M = map(int, input().split())\n\nfac = [1] + [0] * N\nfor i in range(1, N + 1):\n    fac[i] = fac[i - 1] * i % M\nfac_inv = [0] * N + [pow(fac[N], M - 2, M)]\nfor i in range(N, 0, -1):\n    fac_inv[i - 1] = fac_inv[i] * i % M\npow2 = [1] + [0] * N\nfor i in range(N):\n    pow2[i + 1] = pow2[i] * 2 % M\n\nDP = [[0] * N for _ in range(N + 2)]\nDP[0][0] = 1\nfor i in range(N):\n    for j in range(N):\n        DP[i][j] %= M\n        if DP[i][j]:\n            for k in range(i + 2, N + 2):\n                DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M\nans = 0\nfor j in range(N):\n    DP[N + 1][j] %= M\n    if DP[N + 1][j]:\n        ans += DP[N + 1][j] * fac[N - j + 1] % M\nprint(ans % M)","output":"cubic"},{"instruction":"import sys, os.path\nif(os.path.exists('input.txt')):\n\tsys.stdin = open(\"input.txt\",\"r\")\n\nt = int(input())\nlast = []\ncurrent = []\n\nfor i in range(t):\n\tlast.append(str(input()))\nfor i in range(t):\n\tcurrent.append(str(input()))\n\nfor i in range(len(last)):\n\tif last[i] in current:\n\t\tcurrent[current.index(last[i])] = \"*\"\n\t\tlast[i] = \"*\"\n\nlast.sort()\ncurrent.sort()\n\ntotal = 0\nfor i in range(len(last)):\n\tif last[i] == current[i]:\n\t\tcontinue\n\telse:\n\t\ttotal+=1\n\nprint(total)","output":"linear"},{"instruction":"n = int(input())\nlst = list(map(int,input().split()))\nlst.sort()\nlst.reverse()\nm = 0\nfor i in range(n):\n  if sum(lst[:i]) > sum(lst[i:]):\n    break\n  else:\n    m+=1\nprint(m)","output":"nlogn"},{"instruction":"t=int(input())\nk=set()\nfor i in range(1,10**5):\n  k.add(4*i*i)\n  k.add(2*i*i)\nfor _ in range(t):\n  n=int(input())\n  if n in k:\n    print('YES')\n  else:\n    print('NO')","output":"constant"},{"instruction":"n=int(input())\ns=input()\ncur=0\nfor a in s:\n    cur=max(cur,0)\n    if(a=='-'):\n        cur-=1\n    else: cur+=1\n    cur=max(cur,0)\nprint(cur)","output":"linear"},{"instruction":"N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp1 = defaultdict(lambda :-1)\nM=1001\ndef ec(i,j):\n    return i*M+j\n\nfor i in range(N):\n    dp1[ec(i,i+1)] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]\n            if u != -1 and v != -1 and u == v:\n                dp1[ec(j,j+i)] = u+1\n                break\n\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    for j in range(i+1):\n        if dp1[ec(j,i+1)] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])","output":"cubic"},{"instruction":"from sys import stdin,stdout\ndef main():\n\tn=int(stdin.readline())\n\ts=stdin.readline()\n\tsum=0\n\ta=[]\n\tfor v in s:\n\t\tif v!='0' and v!='\\n':\n\t\t\ta.append(v)\n\tif not a and n>1:\n\t\treturn 'YES'\n\tn=len(a)\n\ts=a\n\tfor i in range(n-1):\n\t\tsum+=int(s[i])\n\t\tj=i+1\n\t\tcheck=1\n\t\twhile j<n:\n\t\t\ttemp=int(s[j])\n\t\t\tj+=1\n\t\t\twhile j<n:\n\t\t\t\tif temp>=sum:\n\t\t\t\t\tbreak\n\t\t\t\ttemp+=int(s[j])\n\t\t\t\tj+=1\n\t\t\tif sum!=temp:\n\t\t\t\tcheck=1\n\t\t\t\tbreak\n\t\tif sum!=temp:\n\t\t\tcheck=0\n\t\tif check:\n\t\t\treturn 'YES'\n\treturn 'NO'\nprint(main())","output":"quadratic"},{"instruction":"import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nt=True\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            t=False\n            break\n    else:\n        c+=aux\n        c1+=1\n        continue\n    break\nif t:\n    print(\"Yes\")","output":"nlogn"},{"instruction":"x, k= [int(x) for x in raw_input().split()]\n\nMOD = 10 ** 9 + 7\n\ndef modulus(a, b, m):\n\n    if b == 0:\n        return 1\n    if b == 1:\n        return a % m\n\n    result = int(modulus(a, b \/\/ 2, m))\n\n    if b % 2 == 0:\n        return  int (( (result % m) * (result % m) ) % m)\n    else:\n        return int (( (result % m) * (result % m) * (a % m)) % m)\n\ndef pow_mod(x, y, z):\n    \"Calculate (x ** y) % z efficiently.\"\n    number = 1\n    while y:\n        if y & 1:\n            number = number * x % z\n        y >>= 1\n        x = x * x % z\n    return number\nif x == 0:\n    print(0)\nelif k != 0:\n    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))\nelse:\n    print(int((x % MOD) * 2 % MOD) )","output":"logn"},{"instruction":"def helper(n,m,k):\n\n    if k % 2 == 1:\n        res = [[-1] * m for i in range(n)]\n        return res\n\n    k = k \/\/ 2\n\n    pool = [[[0]*m for i in range(n)] for j in range(k+1)]\n\n    dx = [0,0,1,-1]\n    dy = [1,-1,0,0]\n\n    for t in range(1,k+1):\n        for i in range(n):\n            for j in range(m):\n                tres = [9999999] * 4\n                for c in range(4):\n                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:\n                        if c == 0:\n                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 1:\n                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 2:\n                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        else:\n                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                pool[t][i][j] = min(tres)\n\n    return pool[k]\n\nn,m,k = map(int,input().split(\" \"))\nhedge = []\nvedge = []\nfor i in range(n):\n    hedge.append(list(map(int,input().split(\" \"))))\nfor i in range(n-1):\n    vedge.append(list(map(int,input().split(\" \"))))\n\nres = helper(n,m,k)\nfor j in range(len(res)):\n    print(\" \".join(map(str,res[j])))","output":"cubic"},{"instruction":"import sys\nn,m=map(int,input().split())\ns=[list(input()) for i in range(n)]\nu=[[-1 for i in range(m)] for j in range(n)]\nd=[[-1 for i in range(m)] for j in range(n)]\nl=[[-1 for i in range(m)] for j in range(n)]\nr=[[-1 for i in range(m)] for j in range(n)]\nfor i in range(m):\n    acum=0\n    for j in range(n):\n        if s[j][i]==\".\":\n            acum=0\n        else:\n            acum+=1\n        u[j][i]=acum\nfor i in range(m):\n    acum=0\n    for j in range(n-1,-1,-1):\n        if s[j][i]==\".\":\n            acum=0\n        else:\n            acum+=1\n        d[j][i]=acum\nfor i in range(n):\n    acum=0\n    for j in range(m):\n        if s[i][j]==\".\":\n            acum=0\n        else:\n            acum+=1\n        l[i][j]=acum\nfor i in range(n):\n    acum=0\n    for j in range(m-1,-1,-1):\n        if s[i][j]==\".\":\n            acum=0\n        else:\n            acum+=1\n        r[i][j]=acum\nans=[]\nt1=[[0 for i in range(m)] for j in range(n)]\nt2=[[0 for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1\n        if d1>0:\n            ans.append([i+1,j+1,d1])\n            t1[i+d1][j]+=1\n            t1[i-d1][j]-=1\n            t2[i][j-d1]+=1\n            t2[i][j+d1]-=1\ndp=[['.' for i in range(m)] for j in range(n)]\nfor i in range(n):\n    acum=0\n    for j in range(m):\n        acum+=t2[i][j]\n        if acum!=0 or t2[i][j]!=0:\n            dp[i][j]='*'\nfor i in range(m):\n    acum=0\n    for j in range(n):\n        acum+=t1[j][i]\n        if acum!=0 or t1[j][i]!=0 :\n            dp[j][i]='*'\nif dp!=s:\n    print(-1)\n    sys.exit()\nprint(len(ans))\nfor i in ans:\n    print(*i)","output":"quadratic"},{"instruction":"from math import gcd\ndef t_prime(n):\n    if n == 1:        return False\n    for p in [2,3,5,7,11,13,17,19,23]:\n        if p < n and pow(p,n-1,n) != 1:            return False\n    return True\nprimes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))\nif k == 1: print(0);exit()\nfor i in range(n):\n    for j in range(i):\n        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)\/\/poss;smol = min(poss,poss2)\n        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)\npowers = set();count = 0;outLs = [];pgood = []\nfor p in primes:\n    curr = [];    fp = [v for v in l if v % p == 0]\n    for v in fp:\n        v2 = v\n        while v2 % p == 0:            v2 \/\/= p\n        if v2 == 1:   curr.append(v);   powers.add(v)\n    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)\norder = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])\nif len(order) == 0:    print(0); exit()\nif order[-1][0] == 2 and k % 2 and count > k:\n    extra = -1;    need = -1;    last = []\n    for v in l:\n        if v in powers:            continue\n        v2 = v;        primesn = []\n        for p in pgood:\n            add = 1\n            while v2 % p == 0:\n                v2 \/\/= p\n                if add:                    primesn.append(p)\n                add = 0\n        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2\n    if need == -1 or 2 * need + 1 > k:  print(0);   exit()\n    other = [];    out = [extra]\n    for a,b in outLs:\n        works = False\n        for p in last:\n            if a % p == 0:   works = True;           break\n        if works:       out.append(a);   out.append(b)\n        else:       other.append(a);      other.append(b)\n    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()\nout = [];need = k\nfor i in range(len(order)):\n    assert need != 1;lis = order[i][1]\n    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis)\n    elif len(lis) == need - 1:\n        if len(lis) > 2: out += lis[:-1];  need -= (len(lis) - 1);   assert need == 2\n    else: out += lis[:need]; need = 0\nassert need + len(out) == k;assert need >= 0;assert need == 0 or len(out) == count\nfor v in l:\n    if need == 0:        break\n    if v in powers:        continue\n    v2 = v\n    for p in pgood:\n        while v2 % p == 0:            v2 \/\/= p\n    if v2 == 1:        out.append(v);        need -= 1\nif need == 0:    print(' '.join(map(str,out)));    exit()\nelse:    print(0)","output":"np"},{"instruction":"class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        arr = []\n\n        def dfs(node):\n            if not node:\n                return\n\n            arr.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        arr.sort()\n        return arr[k - 1]","output":"nlogn"},{"instruction":"N = int(input())\nm1 = []\nm2 = []\nms = []\nfor n in range(N):\n    m1.append(input())\nfor n in range(N):\n    m2.append(input())\n\nms = [\n    m2,\n    [x[::-1] for x in m2],\n    [x for x in reversed(m2)],\n]\n\na = []\nfor m in ms:\n    a.append(m)\n    a.append([x[::-1] for x in reversed(m)])\n    a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)])\n    a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)])\n\nms = a\nprint(['NO', 'YES'][m1 in ms])","output":"quadratic"},{"instruction":"L1=list(map(int, input().split()))\nnumList=list(map(int, input().split()))\nlength=L1[0]\ntargetnumber=L1[1]\npos=numList.index(targetnumber)\npos_r=pos+1\nrem=0\nright={0:1}\nleft={0:1}\nwhile pos_r<=length-1:\n    if numList[pos_r]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in right:\n        right[rem]=1\n    else:\n        right[rem]+=1\n    pos_r+=1\npos_l=pos-1\nrem=0\nwhile pos_l>=0:\n    if numList[pos_l]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in left:\n        left[rem]=1\n    else:\n        left[rem]+=1\n    pos_l-=1\nsum=0\nfor number_l in left:\n    if number_l*(-1) in right:\n        sum += (left[number_l] * right[(-1) * number_l])\n    if 1-number_l in right:\n        sum += (left[number_l] * right[1-number_l])\nprint(sum)","output":"nlogn"},{"instruction":"n, m = list(map(int, input().split()))\ncl = []\nfor i in range(n):\n  cl.append(input())\n\ndef is_squad(x, y):\n  if cl[x][y]=='\n    return True\n  else:\n    return False\n\ndef cv(x, y):\n  counter = 0\n  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):\n    return True\n\n  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):\n    return True\n\n  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):\n    return True\n\n  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):\n    return True\n\n  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):\n    return True\n\n  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):\n    return True\n\n  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):\n    return True\n\n  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):\n    return True\n  else:\n    return False\n\nfor i in range(n):\n  for j in range(m):\n    if cl[i][j]=='\n      if not cv(i, j):\n        print('NO')\n        exit()\n\nprint('YES')","output":"quadratic"},{"instruction":"r,g,b=map(int,input().split())\nR=list(map(int,input().split()))\nR.sort()\nG=list(map(int,input().split()))\nG.sort()\nB=list(map(int,input().split()))\nB.sort()\ndp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i<r and j<g:\n                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])\n            if i<r and k<b:\n                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])\n            if j<g and k<b:\n                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"from collections import defaultdict as dd\nfrom collections import deque, Counter\nimport bisect\nimport heapq\nfrom math import inf\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\nn, m = rl()\naa = rl()\n\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m:\n\t    bb[i] = 1\n\telif aa[i] < m:\n\t    bb[i] = -1\n\telse:\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\ndef mergeSortGoodOrder(arr):\n\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        a = arr[:len(arr)\/\/2]\n        b = arr[len(arr)\/\/2:]\n\n        a, ai = mergeSortGoodOrder(a)\n        b, bi = mergeSortGoodOrder(b)\n        c = []\n\n        i = 0\n        j = 0\n        good = 0 + ai + bi\n\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            c.append(a[i])\n            i += 1\n            good += (len(b)-j)\n        else:\n            c.append(b[j])\n            j += 1\n\n    c += a[i:]\n    c += b[j:]\n\n    return c, good\n\nidx = 0\nfor i in range(n):\n    if aa[i] == m:\n        idx = i\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\nfirst_count = good - bad_left - bad_right\n\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m + 1:\n\t    bb[i] = 1\n\telif aa[i] < m + 1:\n\t    bb[i] = -1\n\telse:\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\nsecond_count = good - bad_left - bad_right\n\nans   = first_count - second_count\n\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\ndef rl(proc=None):\n    if proc is not None:\n        return proc(sys.stdin.readline())\n    else:\n        return sys.stdin.readline().rstrip()\n\ndef srl(proc=None):\n    if proc is not None:\n        return list(map(proc, rl().split()))\n    else:\n        return rl().split()\n\ndef main():\n    rl()\n    a = srl(int)\n    a.sort()\n    cnt = 0\n    for i in range(0, len(a)-1):\n        if a[i] == a[i+1]:\n            a[i] -= 1\n            cnt += 1\n            break\n    if a[0] < 0:\n        print('cslnb')\n        return\n\n    for i in range(0, len(a)-1):\n        if a[i] == a[i+1]:\n            print('cslnb')\n            return\n\n    for i, x in enumerate(a):\n        cnt += x - i\n\n    print('sjfnb' if (cnt & 1) else 'cslnb')\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys\n\nIS_LOCAL = False\n\ndef readMultiple(f):\n    return f(map(int, input().split()))\n\ndef main():\n    n = 3\n    a = [1, 2, -4]\n\n    if not IS_LOCAL:\n        n = int(input())\n        a = readMultiple(list)\n\n    for i, x in enumerate(a):\n        if x >= 0:\n            a[i] = -x - 1\n\n    cnt_neg = 0\n    for x in a:\n        if x < 0:\n            cnt_neg += 1\n\n    b = sorted([(abs(x), i) for i, x in enumerate(a)])\n    if cnt_neg % 2 == 1:\n        ind = b[n-1][1]\n        a[ind] = -a[ind] - 1\n\n    print(' '.join(map(str, a)))\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1 and sys.argv[1] == 'True':\n        IS_LOCAL = True\n    main()","output":"nlogn"},{"instruction":"mod = int(1000000007)\n\ndef somaPa(nSteps):\n    if nSteps == 0:\n        return 0\n    return (1 + nSteps) * nSteps \/ 2\n\ndef diminui(step):\n    return (pow(2, step, mod) - 2) % mod\n\nx, k = map(int, raw_input().split())\n\nif x == 0:\n    print(0)\nelse:\n    pot = pow(2, k + 1, mod)\n    inv = pow(2, mod - 2, mod)\n\n    big = (x * pot) % mod\n    small = (big - diminui(k + 1) ) % mod\n\n    print(int((( ( (big + small) % mod)  * inv ) % mod)))","output":"logn"},{"instruction":"import sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())\n\nN = I()\nA = LI()\nmod = 10**9+7\n\nm = 20\nM = 1 << m\nF = [0]*M\nfor a in A:\n    F[a] += 1\n\ndef zeta_transform(F,n):\n\n    N = 1 << n\n    res = F[:]\n    for i in range(n):\n        k = 1 << i\n        for j in range(N):\n            if not j & k:\n                res[j] += res[j^k]\n    return res\n\nG = zeta_transform(F,m)\npower = [1]\nfor _ in range(N):\n    power.append((power[-1]*2) % mod)\n\ndef bit_count(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\nans = 0\nfor i in range(M):\n    bc = bit_count(i)\n    a = power[G[i]]\n    if bc % 2 == 0:\n        ans += a\n    else:\n        ans -= a\n    ans %= mod\n\nprint(ans)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nclass sieve:\n  def __init__(self, n):\n    self.n = n\n    self.sv = [1] * (n + 1)\n    self.sv[0] = 0\n    self.sv[1] = 0\n    for i in range(2, n + 1):\n      if self.sv[i]:\n        for j in range(i * 2, n + 1, i):\n          self.sv[j] = 0\n  def isprime(self, x):\n    if x > self.n:\n      return False\n    return self.sv[x] == 1\n  def factorize(self, x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n      if self.sv[i]:\n        while x % i == 0:\n          x \/\/= i\n          res.append(i)\n    if x != 1:\n      res.append(x)\n    return res\n  def modlcm(self, a, mod):\n    res = [0] * (self.n + 1)\n    ex = set()\n    for i in range(len(a)):\n      f = self.factorize(a[i])\n      for j in f:\n        if j > self.n:\n          ex.add(j)\n          continue\n        res[j] = max(f.count(j), res[j])\n    rres = 1\n    for i in range(self.n + 1):\n      if res[i] != 0:\n        rres *= pow(i, res[i], mod)\n        rres %= mod\n    for i in ex:\n      rres *= i\n      rres %= mod\n    return rres\n\nsv = sieve(10 ** 4)\nfor _ in range(int(input())):\n  n, k = map(int, input().split())\n  a = list(map(int, input().split()))\n  for i in range(n):\n    x = a[i]\n    q = sv.factorize(x)\n    s = [1]\n    while len(q):\n      y = q.pop()\n      if y == s[-1]:\n        s.pop()\n        a[i] \/\/= y ** 2\n      else: s.append(y)\n  s = [set() for _ in range(k + 1)]\n\n  dp = [n] * (k + 1)\n  dp[0] = 0\n\n  for i in range(n):\n    for j in range(k, -1, -1):\n      if dp[j] == n: continue\n      if a[i] in s[j]:\n        if j + 1 <= k and dp[j + 1] > dp[j]:\n          dp[j + 1] = dp[j]\n          s[j + 1] = s[j]\n        dp[j] += 1\n        s[j] = set()\n        s[j].add(a[i])\n      else:\n        s[j].add(a[i])\n\n  for j in range(k + 1): dp[j] += len(s[j]) > 0\n  print(min(dp))","output":"cubic"},{"instruction":"import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\n\nvals = set()\nlocs = defaultdict(list)\nfor i in range(n):\n    inp = map(int, input().split())\n    for pos, v in enumerate(inp):\n        vals.add(v)\n        locs[v].append((pos, i))\n\nmasks = [0] * n\nfull = (1<<m) - 1\nmet = {0:0}\nfor v in sorted(vals, reverse=True):\n    for pos, i in locs[v]:\n        curr_mask = masks[i] = masks[i] | (1<<pos)\n        met[curr_mask] = i\n        complement = full ^ curr_mask\n        if complement in met:\n            print(i+1, met[complement]+1)\n            sys.exit()","output":"np"},{"instruction":"n, s = map(int, input().split())\nans = s \/\/ n\ns %= n\nif s != 0:\n    ans += 1\nprint(ans)","output":"constant"},{"instruction":"class SegmentTree:\n    def __init__(self, N, A):\n        self.n = N\n        while (self.n & (self.n - 1)) != 0:\n            self.n += 1\n        self.build(N, A)\n\n    def build(self, N, A):\n        self.tree = [float('-inf')] * (2 * self.n)\n        for i in range(N):\n            self.tree[self.n + i] = A[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1])\n\n    def query(self, l, r):\n        res = float('-inf')\n        l += self.n\n        r += self.n + 1\n        while l < r:\n            if l & 1:\n                res = max(res, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res = max(res, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return res\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        n = len(nums)\n        segTree = SegmentTree(n, nums)\n        output = []\n        for i in range(n - k + 1):\n            output.append(segTree.query(i, i + k - 1))\n        return output","output":"nlogn"},{"instruction":"import sys,math\ninput = sys.stdin.readline\n\nout = []\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n\n    o1 = math.isqrt(n\/\/2)\n    o2 = math.isqrt(n\/\/4)\n\n    if 2 * o1 * o1 == n or 4 * o2 * o2 == n:\n        out.append('YES')\n    else:\n        out.append('NO')\nprint('\\n'.join(out))","output":"constant"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn = int(z())\narr = set(zz())\n\ndef solve():\n    for i in arr:\n        for k in range(31):\n            if i - (1 << k) in arr and i + (1 << k) in arr:\n                return [i - (1 << k), i, i + (1 << k)]\n    for i in arr:\n        for k in range(31):\n            if i + (1 << k) in arr:\n                return [i, i + (1 << k)]\n\n    for i in arr:\n        return [i]\n\nlst = solve()\n\nprint(len(lst))\nfor i in lst:\n    output(i,' ')","output":"nlogn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn, m = zz()\narr = zzz()\ns = sum(arr)\nx = [[] for i in range(m)]\nfor i in range(n): x[arr[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n \/\/ m:\n        while j < i or len(x[j % m]) >= n \/\/ m: j += 1\n        k = x[i].pop()\n        arr[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(arr) - s)\nprint(*arr)","output":"linear"},{"instruction":"n = int(input())\nar = [int(i) for i in input().split()]\n\nif n == 1:\n    print(1)\n    exit()\n\nif ar[1] > ar[0]:\n    li = [1]\nelif ar[1] < ar[0]:\n    li = [5]\nelse:\n    li = [3]\n\nc = 1\nwhile c != n:\n    j = 0\n\n    if ar[c] > ar[c - 1]:\n        while c != n and ar[c] > ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] + 1)\n            if li[-1] == 6:\n                print(-1)\n\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] + 1)\n        else:\n            li.append(5)\n\n    elif ar[c] < ar[c - 1]:\n        while c != n and ar[c] < ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] - 1)\n            if li[-1] == 0:\n                print(-1)\n\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] - 1)\n        else:\n            li.append(1)\n\n    else:\n        while c != n and ar[c] == ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j):\n            if li[-1] > 3:\n                li.append(li[-1] - 1)\n            else:\n                li.append(li[-1] + 1)\n        if c != n and ar[c] > ar[c - 1]:\n            if li[-2] == 1:\n                li[-1] = 2\n            else:\n                li[-1] = 1\n        elif c != n and ar[c] < ar[c - 1]:\n            if li[-2] == 5:\n                li[-1] = 4\n            else:\n                li[-1] = 5\n\nif max(li) > 5 or min(li) < 1:\n    print(-1)\nelse:\n    print(*li)","output":"quadratic"},{"instruction":"a = [0,1]\nn = int(input())\ni=2\nr=0\nwhile r<n:\n     r = a[i-1]+a[i-2]\n     a.append(r)\n     i+=1\nl = len(a)-1\nif n>3:\n    print(a[l-4],a[l-3],a[l-1])\nelif n==3:\n    print(1,1,1)\nelif n==2:\n    print(0,1,1)\nelif n==1:\n    print(0,0,1)\nelif n==0:\n    print(0,0,0)","output":"constant"},{"instruction":"from math import *\na,r = map(int,input().split())\nx = list(map(int,input().split()))\ny = [0]*a\nfor i in range(a):\n    h = r\n    for j in range(i):\n        if abs(x[i]-x[j])<=2*r:\n            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])\n    y[i] = h\n    print(h, end = \" \")","output":"quadratic"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue\n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0:\n            flag = True\n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num \/\/ prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1\n\n    if num>1: output.append(num)\n\n    return tuple(output)\n\nwhile r<=T:\n    n,k = map(int,input().split())\n    arr = list(map(int,input().split()))\n\n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n\n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n\n        fact[factor] = i\n\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n\n    print(dp[-1][-1])\n    r += 1","output":"cubic"},{"instruction":"n, m, a, b = map(int, input().split())\nprint(min(n%m*b, (m-n%m)*a))\n","output":"linear"},{"instruction":"l,r=map(int,input().split())\na=bin(l)\nb=bin(r)\na=\"0\"*(len(b)-len(a))+a[2:len(a)]\nb=b[2:len(b)]\nc=[0 for i in range(len(a))]\nflag=False\nfor i in range(len(a)):\n    if(a[i]!=b[i]):\n        flag=True\n    if(flag):c[i]=1\nans=0\nfor j in range(len(a)):\n    ans+=c[len(a)-1-j]*(2**(j))\nprint(ans)","output":"logn"},{"instruction":"k = int(input())\nch = 0\ni = 0\nr = 1\nwhile k > r - 1:\n    r += 9 * (i + 1) * 10 ** i\n    i += 1\nr -= 9 * i * 10 ** (i - 1)\n\nprint(str((k - r) \/\/ i + 10 ** (i - 1))[(k - r) % i]  )","output":"constant"},{"instruction":"n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))","output":"quadratic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n\n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n\n    return powerset_orderred\ndef fastPlrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\n\nt = 1\n\nfor _ in range(t):\n    n,m = li()\n    s = list(si())\n    t = list(si())\n    if '*' not in s:\n        if s==t:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n        continue\n    i = s.index('*')\n    if s[:i]==t[:i]:\n        s = s[i:]\n        t = t[i:]\n        s=s[::-1]\n        t = t[::-1]\n        i = s.index('*')\n\n        if len(t)>=i and s[:i]==t[:i]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")","output":"linear"},{"instruction":"from itertools import combinations\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\n\nN, T = [int(x) for x in input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)","output":"np"},{"instruction":"n,s=map(int,input().split())\n\ndef ver(i):\n\tt=str(i)\n\tans=0\n\tfor j in t:\n\t\tans+=int(j)\n\treturn(ans)\nl=len(str(s))\nif n<s:\n\tprint(0)\n\texit()\nif s+10*(l**2+1)<=n:\n\tans=n-s+1-10*(l**2+1)\n\tfor i in range(s,s+10*(l**2+1)):\n\t\tif s+ver(i)<=i:ans+=1\nelse:\n\tans=0\n\tfor i in range(s,n+1):\n\t\tif s+ver(i)<=i:ans+=1\nprint(ans)","output":"logn"},{"instruction":"import bisect\nfrom itertools import accumulate\nimport os\nimport sys\nimport math\nfrom decimal import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ndef SieveOfEratosthenes(n):\n    prime=[]\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n\n        if (primes[p] == True):\n            prime.append(p)\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return prime\ndef factors(n):\n    fac=[]\n    while(n%2==0):\n        fac.append(2)\n        n=n\/\/2\n    for i in range(3,int(math.sqrt(n))+2):\n        while(n%i==0):\n            fac.append(i)\n            n=n\/\/i\n    if n>1:\n        fac.append(n)\n    return fac\n\na = input()\nb = a.count('1')\na = a.replace('1','')\nc = a.find('2')\nif c==-1:\n    a = (a+ '1'*b)\nelse:\n    a = a[:c]+ '1'*b + a[c:]\nprint(a)","output":"linear"},{"instruction":"name = input()\nfor i in range(len(name), 0, -1):\n\tfor j in range(len(name) - i + 1):\n\t\tif name[j: j + i] in name[j + 1:]:\n\t\t\tprint(i)\n\t\t\texit()\nprint(0)","output":"cubic"},{"instruction":"from sys import stdin\nfrom collections import deque,Counter\nimport sys\nimport math\nimport operator\nimport random\nfrom fractions import Fraction\n\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\narr.sort()\nf = arr[0]\np = n\ni = 0\ncount = 0\nwhile i<n:\n    while i<n and arr[i] == f:\n        i+=1\n        count+=1\n    if i<n and arr[i]<=f+k:\n        p-=count\n    if i<n:\n        f=arr[i]\n        count=0\n    continue\n\nprint(p)","output":"nlogn"},{"instruction":"from itertools import combinations\nn,l,r,x=map(int,input().split())\n*a,=map(int,input().split())\nprint(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))","output":"np"},{"instruction":"from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\n\nfor _ in range(1):\n    sa=sorted(input(), reverse=True)\n    na=len(sa)\n    sb=input()\n    nb=len(sb)\n    if nb>na:\n        print(''.join(sa))\n        continue\n    ans=''\n    while sa:\n        for i in range(len(sa)):\n            new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:]))\n            if int(new)<=int(sb):\n                ans+=sa[i]\n                sa.pop(i)\n                break\n    print(ans)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n\nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])\/(j-i+1))\nprint(ans)","output":"quadratic"},{"instruction":"s = input().split()\ns.sort()\nif s[0] == s[1] == s[2]:\n\tprint(0)\n\texit()\nif s[0][1] == s[1][1] == s[2][1]:\n\tif ord(s[0][0]) + 1 == ord(s[1][0]) == ord(s[2][0]) - 1:\n\t\tprint(0)\n\t\texit()\nif s[0][1] == s[1][1] and ord(s[0][0]) + 2 >= ord(s[1][0]) or s[1][1] == s[2][1] and ord(s[1][0]) + 2 >= ord(s[2][0]) or s[0][1] == s[2][1] and ord(s[0][0]) + 2 >= ord(s[2][0]):\n\tprint(1)\n\texit()\nif s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:\n\tprint(1)\n\texit()\nprint(2)","output":"nlogn"},{"instruction":"from collections import Counter;\n\nn = int(input())\n\na = input()\nb = input()\nc = input()\n\nfa = Counter(a);\nfb = Counter(b);\nfc = Counter(c);\n\nla = min(fa.most_common(1)[0][1] + n, len(a))\nlb = min(fb.most_common(1)[0][1] + n, len(a))\nlc = min(fc.most_common(1)[0][1] + n, len(a))\n\nif fa.most_common(1)[0][1] == len(a) and n == 1:\n    la = len(a)-1\n\nif fb.most_common(1)[0][1] == len(b) and n == 1:\n    lb = len(b)-1\n\nif fc.most_common(1)[0][1] == len(c) and n == 1:\n    lc = len(c)-1\n\nif la > max(lb, lc):\n    print(\"Kuro\")\nelif lb > max(la, lc):\n    print(\"Shiro\")\nelif lc > max(la, lb):\n    print(\"Katie\")\nelse:\n    print(\"Draw\")","output":"linear"},{"instruction":"import copy\nimport sys\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in w.items():\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines):\n        u, v, c = map(int, line.split())\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in w.keys():\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in w_tmp.keys():\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        exit(0)\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) \/ 2)\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))","output":"nlogn"},{"instruction":"n,m=map(int, input().split())\na=list(map(int, input().split()))\nt=n\/\/m\nremain=[[] for i in range(m)]\nfor i in range(n):\n    x=a[i]%m\n    remain[x].append(i)\nans=0\nf=[]\nfor i in range(2*m):\n    cur=i%m\n    while len(remain[cur])>t:\n        elm=remain[cur].pop()\n        f.append([elm,i])\n    while len(remain[cur])<t and len(f)!=0:\n        elm,j=f.pop()\n        remain[cur].append(elm)\n        a[elm]+=abs(i-j)\n        ans+=abs(i-j)\nprint(ans)\nprint(*a)","output":"linear"},{"instruction":"def read(type = 1):\n    if type:\n        file = open(\"input.dat\", \"r\")\n        n = int(file.readline())\n        a = list(map(int, file.readline().split()))\n        b = file.readline()\n        file.close()\n    else:\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        b = input().strip()\n    return n, a, b\n\ndef solve():\n    sol = 0\n    e = 0\n    big = 0\n    g = 0\n    for i in range(n):\n        if b[i] == \"W\":\n            big = 1\n            sol += 3 * a[i]\n            e += a[i]\n        if b[i] == \"G\":\n            sol += 5 * a[i]\n            e += a[i]\n            g += 2*a[i]\n        if b[i] == \"L\":\n            sol += a[i]\n            e -= a[i]\n            if e < 0:\n                if big:\n                    sol -= 3 * e\n                else:\n                    sol -= 5 * e\n                e = 0\n        g = min(g, e)\n    if e:\n        sol -= 2*g\n        sol -= (e-g)\n    return int(sol)\n\nn, a, b = read(0)\nsol = solve()\nprint(sol)","output":"linear"},{"instruction":"l, r=map(int, input().split())\ndef cntbit(n):\n  ans=0\n  while(n):\n    ans+=1\n    n\/\/=2\n  return ans\nc1=cntbit(l)\nc2=cntbit(r)\nif(c2>c1):\n  print(2**c2-1)\nelse:\n  x=l^r\n  c=cntbit(x)\n  print(2**c-1)","output":"logn"},{"instruction":"import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\n\nfor i in range (0, n):\n    if a[i] >= 0:\n        a[i] = - a[i] - 1\n\nif n % 2 == 1:\n    i = a.index(min(a))\n    a[i] = - a[i] - 1\n\na = list(map(str,a))\nprint(\" \".join(a))","output":"linear"},{"instruction":"x,y,z=map(int,input().split())\nl=list(map(int,input().split()))\nl.sort()\nc=0\ns=z\nt=False\nwhile s<y and c<x:\n    c+=1\n    s=s+l[x-c]-1\nif s<y:\n    print(-1)\nelse:\n    print(c)","output":"nlogn"},{"instruction":"l, r = list(map(int, input().strip().split()))\n\nif l == r:\n    print(0)\n    exit()\n\nl, r = bin(l)[2:].zfill(64), bin(r)[2:].zfill(64)\ni = 0\nwhile i < len(r):\n    if l[i] == r[i]:\n        i += 1\n    else:\n        break\nrslt = len(r[:i])*'0' + len(r[i:])*'1'\nprint(int(rslt, 2))","output":"logn"},{"instruction":"import math\nn,r = list(map(int,input().split()))\nangle = math.pi\/(n)\nc = math.sin(angle)\nk = c\/(1-c)\nR = k*r\nR = float(format(R,'.7f'))\nprint(R)","output":"constant"},{"instruction":"from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\n\nans = [[0] * 55 for _ in range(55)]\n\ndef find(c: 'str') -> 'int':\n    if 'A' <= c <= 'Z':\n        return ord(c) - ord('A') + 26\n    else:\n        return ord(c) - ord('a')\n\nfor i in s:\n    buc[find(i)] += 1\n\nfac[0] = 1\nfor i in range(1, n + 1):\n    fac[i] = (fac[i - 1] * i) % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n    inv[i] = (inv[i + 1] * (i + 1)) % MOD\n\nnum = pow(fac[n \/\/ 2], 2, MOD)\nfor i in range(0, 52):\n    num = (num * inv[buc[i]]) % MOD\n\ndp[0] = 1\n\nfor i in range(0, 52):\n    if not buc[i]:\n        continue\n    for j in range(n, buc[i] - 1, -1):\n        dp[j] += dp[j - buc[i]]\n        if dp[j] >= MOD:\n            dp[j] -= MOD\nfor i in range(52):\n    ans[i][i] = dp[n \/\/ 2]\n\nfor i in range(52):\n    if not buc[i]:\n        continue\n    temp_dp = dp.copy()\n    for k in range(buc[i], n + 1):\n        temp_dp[k] -= temp_dp[k - buc[i]]\n        if temp_dp[k] < 0:\n            temp_dp[k] += MOD\n\n    for j in range(i + 1, 52):\n        if not buc[j]:\n            continue\n        for k in range(buc[j], n + 1):\n            temp_dp[k] -= temp_dp[k - buc[j]]\n            if temp_dp[k] < 0:\n                temp_dp[k] += MOD\n        ans[i][j] = (2 * temp_dp[n \/\/ 2]) % MOD\n\n        for k in range(n, buc[j] - 1, -1):\n            temp_dp[k] += temp_dp[k - buc[j]]\n            if temp_dp[k] >= MOD:\n                temp_dp[k] -= MOD\n\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n    x, y = map(int, i.split())\n    l, r = find(s[x - 1]), find(s[y - 1])\n    if l > r:\n        l, r = r, l\n    print(num * ans[l][r] % MOD)","output":"cubic"},{"instruction":"n = input()\n\nm = 0\nfor i in range(len(n)):\n\n    for j in range(i,len(n)+1):\n\n        if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]:\n\n            m = len(n[i:j])\n\nprint(m)","output":"cubic"},{"instruction":"class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]","output":"constant"},{"instruction":"n,m = map(int,input().split())\nli = [[j for j in input()] for i in range(n)]\nposition1=0\nposition2=0\nposition3=0\nposition4=0\nfor j in range(m):\n    flag = False\n    for i in range(n):\n        if li[i][j] == \"B\":\n            flag = True\n            position1 = i\n            break\n    if(flag == True):\n        break\nfor j in range(m-1,-1,-1):\n    flag = False\n    for i in range(n-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position2 = i\n            break\n    if(flag == True):\n        break\nfor i in range(n):\n    flag = False\n    for j in range(m):\n        if li[i][j] == \"B\":\n            flag = True\n            position3 = j\n            break\n    if(flag == True):\n        break\nfor i in range(n-1,-1,-1):\n    flag = False\n    for j in range(m-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position4 = j\n            break\n    if(flag == True):\n        break\n\navg1 = (position1+position2)\/\/2 + 1\navg2 = (position3 + position4)\/\/2 + 1\nprint(avg1,avg2)","output":"quadratic"},{"instruction":"import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\na = {0:0}\nb = [0]\n\nfor i in range(n):\n    for p in b:\n        d = gcd(p, l[i])\n        cost = a[p] + c[i]\n        if d not in a:\n            a[d] = cost\n            b.append(d)\n        elif a[d] > cost: a[d] = cost\n\nif 1 not in a: a[1] = -1\nprint(a[1])","output":"np"},{"instruction":"a,b,c,n=map(int,input().split())\nif(c>b or c>a or c>n):\n    print(-1)\nelse:\n    k=c+(a-c)+(b-c)\n    k=n-k\n    if(k>0):\n        print(k)\n    else:\n        print(-1)","output":"constant"},{"instruction":"N,M=map(int,input().split())\nlight=[0]+[int(_) for _ in input().split()]+[M]\nsumlist=[]\nsumlight,ans=0,-10**30\nfor i in range(N+1):\n    sumlight+=(-1)**(i+1)*light[i]\n    sumlist.append(sumlight)\nfor i in range(1,N+1):\n    if light[i]>light[i-1]+1:\n        ans=max(ans,2*sumlist[i-1]-sumlight+(-1)**(i+1)*(light[i]-1))\n    if light[i]<light[i+1]-1:\n        ans=max(ans,2*sumlist[i]-sumlight+(-1)**i*(light[i]+1))\nif N%2==0:\n    print(max(ans,sumlight+M))\nelse:\n    print(max(ans+M,sumlight))","output":"linear"},{"instruction":"x, k = map(int, input().split())\nans = 0\nmd = 1000000007\n\ndef bpow(base, exp, md):\n    if (exp == 0):\n        return 1\n    if (exp % 2 == 1):\n        return (base * bpow(base, exp-1, md)) % md\n    else:\n        k = bpow(base, exp\/\/2, md)\n        return (k*k) % md\n\npw = bpow(2, k, md)\nans = (2 * pw * x) % md\nif (x != 0):\n    ans -= pw-1\nans = (ans + md) % md\nprint(ans)","output":"logn"},{"instruction":"M = 1000000007\nx, k  = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)","output":"logn"},{"instruction":"n=int(input())\nlist1=list(map(int,input().split(' ')))\nsum2=0\nsum1=0\ncount=0\nlist1.sort(reverse=True)\nfor i in range(len(list1)):\n    sum1=sum1+list1[i]\n\nfor i in range(len(list1)):\n    if(int(sum1\/2)>=sum2):\n        sum2=sum2+list1[i]\n        count=count+1\nprint(count)","output":"nlogn"},{"instruction":"import sys\ndef fi():\n\treturn sys.stdin.readline()\nif __name__ == '__main__':\n\tn,k = map(int, fi().split())\n\n\tl = list(map(int, fi().split()))\n\td = dict()\n\tc = set()\n\tl.sort()\n\tfor i in range (n):\n\t\tif not d.get(l[i]):\n\t\t\tc.add(l[i])\n\t\t\td.setdefault(l[i]*k,1)\n\tprint(len(c))","output":"nlogn"},{"instruction":"def bigNumber(n, s):\n  for i in range(s, n + 1):\n    sumVal = 0\n    num = i\n    while num:\n      sumVal += num % 10\n      num \/\/= 10\n    if i - sumVal >= s:\n      print(n - i + 1)\n      return\n  print(0)\n\nn, s = (int(x) for x in input().split())\nbigNumber(n,s)","output":"logn"},{"instruction":"def binary(n,k,low,high):\n    if low<=high:\n        mid=(low+high)\/\/2\n        if (mid*(mid+1))\/\/2-(n-mid)==k:\n            return n-mid\n        elif mid*(mid+1)\/\/2-(n-mid)>k:\n            return binary(n,k,low,mid-1)\n        else:\n            return binary(n,k,mid+1,high)\n\nn,k=[int(x) for x in input().split()]\nprint(binary(n,k,1,n))","output":"logn"},{"instruction":"n=int(input())\ndict1={}\ndict2={}\nfor i in range(n):\n    s=input()\n    s=s.split('\/')\n    c=int(s[1])\n    s=s[0].strip('(').strip(')').split('+')\n    a=int(s[0])\n    b=int(s[1])\n    ans=(a+b)\/c\n    try:\n        dict2[ans] += 1\n    except:\n        dict2[ans] = 1\n    dict1[i] = ans\nfor i in range(n):\n    print(dict2[dict1[i]],end=' ')","output":"linear"},{"instruction":"string = input().strip()\nmx = 0\n\nfor i in range(len(string)):\n    for j in range(i+1, len(string)):\n        m = 0\n        while(j+m < len(string) and string[i+m] == string[j+m]):\n            m += 1\n        mx = max(mx, m)\n\nprint(mx)","output":"cubic"},{"instruction":"s=input().split()\nn=int(s[0])\narr=list(map(int,input().split()))\n\nchildren=[[] for i in range(n+1)]\nfor i,j in enumerate(arr):\n    if 1<i+2<=n:\n        children[j].append(i+2)\nleaves=[0]*(n+1)\n\nfor i in range(n,0,-1):\n    if not children[i]:\n        leaves[i]=1\n    else:\n        leaves[i]=sum(leaves[j] for j in children[i])\n\nprint(' '.join(map(str,sorted(leaves[1:]))))","output":"nlogn"},{"instruction":"import sys\n\ndef bin_ser(arr,curr):\n    l=0\n    r=len(arr)-1\n    ans=-1\n    while l<=r:\n        mid=(l+r)\/\/2\n        if arr[mid]<=curr:\n            ans=mid\n            l=mid+1\n        else:\n            r=mid-1\n    return ans\n\ndef main():\n    n,q=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    brr=list(map(int,sys.stdin.readline().strip().split()))\n    su=sum(arr)\n    curr=0\n    for i in range(1,n):\n        arr[i]=arr[i]+arr[i-1]\n    for b in brr:\n        curr+=b\n        pos=n-bin_ser(arr,curr)-1\n        if pos==0:\n            pos=n\n        print(pos)\n        if curr>=su:\n            curr=0\n\nmain()","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\na.sort(reverse=True)\nworst=0\nmaxi=a[0]\na.append(0)\nfor i in range(n+1):\n    bad=maxi-a[i]-i\n    worst=max(worst,bad)\nprint(sum(a)-n-worst)","output":"nlogn"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\nk = 10 ** 10\nfor i in range(1, n - 1):\n    k = min(k, min(A[0], A[i]) \/\/ i)\n    k = min(k, min(A[-1], A[i]) \/\/ (n - i - 1))\nk = min(k, min(A[0], A[-1]) \/\/ (n - 1))\nprint(k)","output":"linear"},{"instruction":"import math\nsone= list(input())\nstwo = list(input())\nsum1=0\nsum2=0\nm=0\nfor i in range(len(sone)):\n    if sone[i]=='+':\n        sum1=sum1 + 1\n        m=m+1\n    else:\n        sum1=sum1 - 1\nk=0\nfor i in range(len(stwo)):\n    if stwo[i]=='+':\n        sum2=sum2 + 1\n        k=k\n    elif stwo[i]=='-':\n        sum2=sum2 - 1\n        k=k\n    elif stwo[i]=='?':\n        k=k+1\nn=0\nif (k-(abs(sum1-sum2)))<0:\n    print(float (0))\nelif (k-(abs(sum1-sum2)))==0:\n    if k==0:\n        print(float (1))\n    else:\n        print(float (pow(0.5,k)))\n\nelse:\n    n=k-(abs(sum1-sum2))\n    n=abs(sum1-sum2)+n\/2\n    if abs(sum1-sum2)==0:\n        print(float ((math.factorial(k)\/(math.factorial(k\/2)*math.factorial(k\/2))) * pow(0.5,k)))\n    else:\n        print(float ((math.factorial(k)\/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))","output":"np"},{"instruction":"N, K= map(int, input().split())\nRcnt = N * 2\nGcnt = N * 5\nBcnt = N * 8\n\nres = (Rcnt + K - 1) \/\/ K + (Gcnt + K - 1) \/\/K + (Bcnt + K -1 ) \/\/ K\nprint(res)","output":"constant"},{"instruction":"import sys\n\nif __name__ == '__main__':\n    cin = sys.stdin\n\n    n = int(next(cin))\n    a = list(map(int, next(cin).split()))\n\n    n2idx = {a[i]: i for i in range(n)}\n\n    f = [False] * (n+1)\n\n    for i in range(n, 0, -1):\n        idx_lg = n2idx[i]\n\n        win_flag = False\n        for j in range(idx_lg%i, n, i):\n            if a[j] > i and not f[a[j]]:\n                win_flag = True\n                break\n        f[i] = win_flag\n\n    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])\n    print(f, flush=True)","output":"quadratic"},{"instruction":"I=lambda:[*map(int,input().split())]\nR=range;m=min;N,M,K=I();r=R(N)\nif K&1:\n\tfor _ in r:print(*[-1]*M)\n\texit()\nA=[I()for _ in r]\nB=[I()for _ in R(N-1)]\nX=[M*[0]for _ in r]\nfor k in R(1,K\/\/2+1):\n\tY=[M*[9**9]for _ in r]\n\tfor i in r:\n\t\tfor j in R(M):\n\t\t\tif i:Y[i][j]=X[i-1][j]+2*B[i-1][j]\n\t\t\tif i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])\n\t\t\tif j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])\n\t\t\tif j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])\n\tX=Y\nfor x in X:print(*x)","output":"cubic"},{"instruction":"def solve(n, v):\n    fuel = min(n - 1, v)\n    cost = fuel\n    for i in range(2, n):\n        if fuel >= n - 1:\n            break\n        fuel += 1\n        cost += i\n    return cost\n\nn, v = map(int, input().split())\nprint(solve(n, v))","output":"linear"},{"instruction":"n, m = map(int, input().split())\na = [list(map(int, input())) for i in range(n)]\n\nignorable = [True] * n\n\nfor i in range(m):\n    cnt = 0\n    for j in range(n):\n        cnt += a[j][i]\n    if cnt == 1:\n        for j in range(n):\n            if a[j][i]:\n                ignorable[j] = False\n\nif any(ignorable):\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"l = list(map(int,input().split()))\nn = 0\nm=-1\nwhile(n<14):\n    c=0\n    g = l.copy()\n    div = l[n]\/\/14\n    h = l[n]%14\n    i = n+1\n    sum = div*14\n    g[n]=0\n    while(sum):\n        if i==14:\n            i=0\n        g[i]+=div\n        sum-=div\n        i+=1\n    i = n+1\n    while(h):\n        if i==14:\n            i=0\n        g[i]+=1\n        h-=1\n        i+=1\n    for j in g:\n        if j%2==0:\n            c+=j\n\n    m = max(c,m)\n    n+=1\nprint(m)","output":"constant"},{"instruction":"yellow,blue = map(int,input().split())\nx,y,z = map(int,input().split())\nry = x*2+y\nrb =z*3+y\nr1,r2 = 0,0\nif ry-yellow < 0:\n    r1 = 0\nelse:\n    r1 = ry-yellow\nif rb - blue < 0:\n    r2 = 0\nelse:\n    r2 = rb-blue\nprint(r1+r2)","output":"constant"},{"instruction":"n,k = map(int,input().split())\nmod = 998244353\ndp = [[[0,0]for j in range(2*n+1)] for i in range(n)]\ndp[0][0][0] = dp[0][1][1] = 1\nfor i in range(1,n):\n  for j in range(2*n-1):\n    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod\n    dp[i][j+1][0] += dp[i-1][j][0] % mod\n    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod\n    dp[i][j][1] += dp[i-1][j][1] %mod\n    dp[i][j+2][1] += dp[i-1][j][1] %mod\nprint(sum(dp[n-1][k-1])*2%mod)","output":"np"},{"instruction":"from collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\n\nrec = defaultdict(list)\nfor j in range(n):\n    for k in range(j, n):\n        rec[sum(a[j:k + 1])].append((j, k))\n\nans = []\nfor k in rec.keys():\n    tmp = []\n    rec[k] = sorted(rec[k], key=lambda x: x[1])\n    pre = -1\n    for a, b in rec[k]:\n        if pre >= a:\n            continue\n        else:\n            tmp.append((a + 1, b + 1))\n            pre = b\n    if len(tmp) > len(ans):\n        ans = tmp\n\nprint(len(ans))\nfor a, b in ans:\n    print(a, b)","output":"cubic"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,m,k=map(int,input().strip().split(\" \"))\n\nlr=[]\nfor i in range(n):\n\tlr.append([100000001]+list(map(int,input().strip().split(\" \")))+[100000001])\nud=[[100000001]*m]\nfor i in range(n-1):\n\tud.append(list(map(int,input().strip().split(\" \"))))\nud.append([100000001]*m)\no=[[1000000001]*(m+2)]\nfrom copy import deepcopy\nif k%2:\n\tfor i in range(n):\n\t\tsys.stdout.write(\" \".join([\"-1\"]*m)+\"\\n\")\n\tsys.exit()\nfor _ in range(n):\n\too=[100000001]\n\tfor _ in range(m):\n\t\too.append(0)\n\too.append(100000001)\n\to.append(oo)\no.append([100000001]*(m+2))\nfor _ in range(k\/\/2):\n\too=deepcopy(o)\n\tfor i in range(1,n+1):\n\t\tfor j in range(1,m+1):\n\t\t\too[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])\n\to=deepcopy(oo)\nfor i in o[1:n+1]:\n\tsys.stdout.write(\" \".join(map(str,[j*2 for j in i[1:m+1]]))+\"\\n\")","output":"cubic"},{"instruction":"def get_smallest(m, l):\n    res = ''\n    for i in \"0123456789\":\n        if m.get(i, 0):\n            if i == l:\n                res += i * (m[i] - 1)\n            else:\n                res += i * m[i]\n    return res\n\na = input()\nb = input()\n\nif len(a) < len(b):\n    a = sorted(a)\n    a.reverse()\n    print(''.join(a))\nelif a == b:\n    print(a)\nelse:\n    cmap = dict()\n    for i in a:\n        cmap[i] = cmap.get(i, 0) + 1\n\n    cur = 0\n    res = ''\n    gm = False\n\n    while cur < len(a):\n        for i in \"9876543210\":\n            if cmap.get(i, 0):\n                if cur == len(a) - 1 or i < b[cur] or gm:\n                    res += i\n                    cmap[i] -= 1\n                    gm = True\n                    break\n                elif i == b[cur]:\n                    if get_smallest(cmap, i) <= b[cur + 1:]:\n                        res += i\n                        cmap[i] -= 1\n                        break\n        cur += 1\n\n    print(res)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = list(map(int, input().split()))\n\ndp = [[-1]*(N+1) for _ in range(N+1)]\nfor l in range(N):\n    dp[l][l+1] = A[l]\n\nfor d in range(2, N+1):\n    for l in range(N-d+1):\n        for t in range(1, d):\n            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:\n                dp[l][l+d] = dp[l][l+t] + 1\n                break\n\ndp2 = [i for i in range(N+1)]\nfor r in range(1,N+1):\n    if dp[0][r] != -1:\n        dp2[r] = 1\nfor l in range(N):\n    for r in range(l+2, N+1):\n        if dp[l+1][r] != -1:\n            dp2[r] = min(dp2[l+1]+1, dp2[r])\n        else:\n            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])\n\nprint(dp2[N])","output":"cubic"},{"instruction":"n,s=map(int,input().split())\nif s>=n:\n    print(\"0\")\n    exit()\nfor i in range(s,n+2):\n    cur=int(0)\n    for j in str(i):\n        cur+=int(j)\n    if i-cur>=s:\n        break\nprint(n-i+1)","output":"logn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(10)]\npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n                pp[i]+=1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n\nn,m=map(int,input().split())\nl=[]\ntot=[]\ndone=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    l.append(input())\ncolsum=[[0 for i in range(m)]for j in range(n)]\nrowsum=[[0 for i in range(m)]for j in range(n)]\ncol=[[0 for i in range(m)]for j in range(n)]\nrow=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            rowsum[i][j]=1\n            colsum[i][j]=1\n            row[i][j]=1\n            col[i][j]=1\nfor i in range(n):\n    for j in range(1,m):\n        if l[i][j]=='.':\n            continue\n        rowsum[i][j]+=rowsum[i][j-1]\nfor i in range(n):\n    for j in range(m-2,-1,-1):\n        if l[i][j]=='.':\n            continue\n        row[i][j]+=row[i][j+1]\nfor i in range(m):\n    for j in range(n-2,-1,-1):\n        if l[j][i]=='.':\n            continue\n        col[j][i]+=col[j+1][i]\nfor i in range(m):\n    for j in range(1,n):\n        if l[j][i]=='.':\n            continue\n        colsum[j][i]+=colsum[j-1][i]\ndef check(x,y):\n    i=x\n    j=y\n    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1\n    if ans==0:\n        return []\n    return [ans]\nh=[[0 for i in range(m+1)]for j in range(n)]\nv=[[0 for i in range(m)]for j in range(n+1)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            ans=check(i,j)\n            for j1 in ans:\n                tot.append([i+1,j+1,j1])\n                h[i][j-j1]+=1\n                h[i][j+j1+1]-=1\n                v[i-j1][j]+=1\n                v[i+j1+1][j]-=1\nfor i in range(n):\n    for j in range(1,m):\n        h[i][j]+=h[i][j-1]\nfor i in range(m):\n    for j in range(1,n):\n        v[j][i]+=v[j-1][i]\n\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:\n            print(-1)\n            sys.exit(0)\nprint(len(tot))\nfor i in tot:\n    print(*i)","output":"quadratic"},{"instruction":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nxw = [LIST() for _ in range(N)]\n\nrl = []\nfor x, w in xw:\n    rl.append((x-w, x+w))\n\nrl.sort(key = lambda x: (x[1], x[0]))\n\nans = 0\ntmp = -INF\n\nfor r, l in rl:\n    if r < tmp:\n        continue\n    ans += 1\n    tmp = l\n\nprint(ans)","output":"nlogn"},{"instruction":"class Solution:\n    def isValid(self, s: str) -> bool:\n        while '()' in s or '{}' in s or '[]' in s:\n            s = s.replace('()', '')\n            s = s.replace('{}', '')\n            s = s.replace('[]', '')\n        return s == ''\n","output":"quadratic"},{"instruction":"n = int(input())\nif n == 0:\n    print(0)\nelse:\n    if n % 2 == 0:\n        print(n+1)\n    else:\n        print((n+1)\/\/2)","output":"constant"},{"instruction":"n = int(input())\nx,y = map(int,input().split())\nif max(x-1,y-1) > max(n-x,n-y):\n    print(\"Black\")\nelse:\n    print(\"White\")","output":"constant"},{"instruction":"n = int(input())\nprint(n**2+((n-1)**2))","output":"constant"},{"instruction":"n=int(input())\nl=[int(x) for x in input().strip().split()]\nl1=sorted(l)\nc=0\nfor i in range(n):\n    if(l[i]!=l1[i]):\n        c+=1\nif(c<=2):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n=int(input())\nlst = list(map(int, input().strip().split(' ')))\nc=0\nwhile(len(lst)!=0):\n    p=lst[0]\n    del lst[0]\n    i=lst.index(p)\n    c+=i\n    del lst[i]\nprint(c)","output":"quadratic"},{"instruction":"from sys import stdin,stdout\ndef main():\n\tn,k=map(int,stdin.readline().split( ))\n\ts=stdin.readline()\n\tstart=-1\n\ti=0;j=1;prev=1\n\twhile i<n-1:\n\t\twhile j<n:\n\t\t\tif s[i]==s[j]:\n\t\t\t\tif start==-1:\n\t\t\t\t\tstart=j\n\t\t\t\t\tprev=j\n\t\t\t\ti+=1\n\t\t\t\tj+=1\n\t\t\telse:\n\t\t\t\ti=0\n\t\t\t\tj=prev+1\n\t\t\t\tprev=j\n\t\t\t\tstart=-1\n\t\tbreak\n\tif start==-1:\n\t\tstdout.write(\"%s\\n\"%(s[:n]*k))\n\telse:\n\t\tj = n - start\n\t\tstdout.write(\"%s\\n\"%(s[:n]+s[j:n]*(k-1)))\nmain()","output":"quadratic"},{"instruction":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return nums[i]\n        return -1","output":"nlogn"},{"instruction":"import sys\nketa=29\nprint(\"?\",0,0,flush=True)\n\nA00=int(input())\nif A00==0:\n    ANS=0\n    for k in range(keta,-1,-1):\n        print(\"?\",2**k,0,flush=True)\n        if int(input())==-1:\n            ANS+=2**k\n    print(\"!\",ANS,ANS,flush=True)\n    sys.exit()\n\nA=0\nB=0\nfor k in range(keta,-1,-1):\n    LIST=[]\n    print(\"?\",2**k+A,B,flush=True)\n    LIST.append(int(input()))\n    print(\"?\",A,2**k+B,flush=True)\n    LIST.append(int(input()))\n\n    if LIST[0]!=LIST[1]:\n        if LIST[0]==-1:\n            A+=2**k\n            B+=2**k\n\n    else:\n        if A00==1:\n            A+=2**k\n        else:\n            B+=2**k\n        A00=LIST[0]\nprint(\"!\",A,B,flush=True)","output":"constant"},{"instruction":"from sys import stdin\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\ngraph = [[] for _ in range(n)]\nleaf = -1\nfor _ in range(n-1):\n    a,b = map(int,stdin.readline().split())\n\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(G, s):\n\n    Q = deque()\n    Q.append(s)\n\n    infinite = 10 ** 6\n    d = [infinite]*n\n\n    parent = [-1]*n\n    valid = True\n\n    d[s] = 0\n\n    while Q:\n\n        u = Q.popleft()\n\n        not_visited_count = 0\n\n        for v in G[u]:\n\n            if d[v] == infinite:\n                d[v] = d[u] + 1\n                parent[v] = u\n                Q.append(v)\n                not_visited_count += 1\n\n        if not_visited_count < 3 and d[u] != k:\n            valid = False\n\n    return d, parent, valid\n\nleaf = -1\nfor i,v in enumerate(graph):\n    if len(v) == 1:\n        leaf = i\n        break\n\nd, parent, _ = bfs(graph,leaf)\ncenter = -1\nfarthest_leaf = -1\npath = 2*k\n\nfor i,level in enumerate(d):\n    if level == path:\n        farthest_leaf = i\n        break\n\nif len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:\n    print(\"NO\")\n    exit()\n\nfor _ in range(k):\n    center = parent[farthest_leaf]\n    farthest_leaf = center\n\n_, _, valid = bfs(graph,center)\n\nif valid:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n,v=[int(x) for x in input().split()]\nif v>=(n-1):\n    print(n-1)\nelse:\n    print(int((((n-v)*(n-v+1))\/2)-1+v))","output":"constant"},{"instruction":"n,m=map(int, input().split())\ncols=[]\nfor i in range(n):\n    cols.append(int(input()))\nrows=[]\nfor i in range(m):\n    k=list(map(int, input().split()))\n    if k[0]==1:\n        rows.append(k[1])\nans=n+m\ncols.sort()\nrows.sort()\ncols.append(int(1e9))\nj=0\nrem=0\n\nfor i in cols:\n    while j<len(rows) and rows[j]<i:\n        j+=1\n    ans=min(ans, len(rows)-j+rem)\n    rem+=1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\na, b= map(int,input().split())\n\nif a == b:\n    print(0)\n\nelse:\n    x = a ^ b\n    c = 1\n\n    while x:\n        x >>= 1\n        c <<= 1\n\n    print(c-1)","output":"logn"},{"instruction":"n,m=[int(x) for x in input().split(' ')]\nprint((n-1)*'4'+'5')\nprint(n*'5')","output":"constant"},{"instruction":"import math\n\nn,k = map(int,input().split())\nl=[]\nc=0\nfor j in range(2,n):\n    p=0\n\n    for i in range(2,int(math.sqrt(j))+1):\n\n        if j%i==0:\n\n            p=1\n            break\n        else:\n            pass\n\n    if p==0:\n        l.append(j)\n\nl+=[n]\n\nfor i in range(len(l)-1):\n\n    if (l[i]+l[i+1]+1) in l:\n\n        c+=1\nif c>=k:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"from collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef lcm(a, b): return (a * b) \/\/ gcd(a, b)\n\ndef main():\n\n    n = ii()\n    d = defaultdict(int)\n    ll = defaultdict(list)\n    rr = defaultdict(list)\n    llst = []\n    rlst = []\n    lst = []\n    for i in range(n):\n        l, r = mii()\n        lst.append([l,r])\n        llst.append(l)\n        rlst.append(r)\n        ll[l].append(r)\n        rr[r].append(l)\n    left = max(llst)\n    right = min(rlst)\n    lleft = min(ll[left])\n    lright = max(rr[right])\n    lst.remove([left,lleft])\n    pl = max(i[0] for i in lst)\n    pr = min(i[1] for i in lst)\n    mx = max(0,pr-pl)\n    lst.append([left,lleft])\n    lst.remove([lright,right])\n    pl = max(i[0] for i in lst)\n    pr = min(i[1] for i in lst)\n    print(max(mx, max(0,pr-pl)))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"import math\nfrom collections import defaultdict\nml=lambda:map(int,input().split())\nll=lambda:list(map(int,input().split()))\nii=lambda:int(input())\nip=lambda:list(input())\n\nn,k=ml()\nans=0;\nfor i in range(1,1000001):\n    val=(i*(i+1))\/\/2\n    if(val-(n-i)==k):\n        ans=n-i\nprint(ans)","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i],inf)\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\nn,m=map(lambda x:int(x), input().split())\nA = []\nfor _ in range(n):\n    scores = list(map(lambda x:int(x), input().split()))\n    A.append(scores)\n\ndef solve(n,m,A):\n\n    ans = ()\n    nstats = 2**m\n    def judge(finalScore):\n        nonlocal ans\n        seen = {}\n        for i,scores in enumerate(A):\n            sta = 0\n            for e in scores:\n                sta=sta*2+(e>=finalScore)\n\n            seen[sta]=i\n\n        for i in range(nstats):\n            for j in range(nstats):\n                if ((i|j) == nstats-1) and i in seen and j in seen:\n                    ans = (seen[i], seen[j])\n                    return True\n\n        return False\n\n    l=0\n    r=2**31-1\n    while l<r:\n        m=l+(r-l)\/\/2\n        if not judge(m):\n            r=m\n        else:\n            l=m+1\n\n    print(ans[0]+1,ans[1]+1)\n\nsolve(n,m,A)","output":"np"},{"instruction":"N = int(input())\nfirst = []\nsecond = []\nfor i in range(N):\n    first.append([s for s in input()])\nfor i in range(N):\n    second.append([s for s in input()])\n\ndef rotate_90(matrix):\n    return list(zip(*matrix[::-1]))\n\ndef flip(matrix):\n    return matrix[::-1]\n\ndef compare_matrices(first, second):\n    for i in range(N):\n        for j in range(N):\n            if first[i][j] != second[i][j]:\n                return False\n    return True\n\ndef wrap(first, second):\n    if compare_matrices(first, second) == True:\n        return 'Yes'\n    hold_first = first[::]\n    for _ in range(3):\n        first = rotate_90(first)\n        if compare_matrices(first, second) == True:\n            return 'Yes'\n    first = hold_first\n    first = flip(first)\n    if compare_matrices(first, second) == True:\n        return 'Yes'\n    for _ in range(3):\n        first = rotate_90(first)\n        if compare_matrices(first, second) == True:\n            return 'Yes'\n    return 'No'\n\nprint(wrap(first, second))","output":"quadratic"},{"instruction":"def readline(): return tuple(map(int, input().split()))\ndef readlines(count): return (readline() for __ in range(count))\n\ndef main():\n    n, = readline()\n    segments = sorted(readline() + (idx + 1,) for idx in range(n))\n\n    prev = (-1, -1, -1)\n    for segment in segments:\n        assert prev[0] <= segment[0]\n        if prev[0] == segment[0]:\n            assert prev[1] <= segment[1]\n            print(prev[2], segment[2])\n            break\n        elif prev[1] >= segment[1]:\n            print(segment[2],  prev[2])\n            break\n        prev = segment\n    else:\n        print(-1, -1)\n\nmain()","output":"nlogn"},{"instruction":"import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\nMOD = 998244353\n\nN,K = ilele()\nif K == 1 or K == 2*N:\n    print(2)\n    exit(0)\ndp = list3d(N+1,4,K+1,0)\ndp[1][0][1] = 1\ndp[1][3][1] = 1\ndp[1][1][2] = 1\ndp[1][2][2] = 1\n\nfor n in range(2,N+1):\n    for k in range(1,K+1):\n        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD\n        if k > 1:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        else:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n\nprint(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)","output":"np"},{"instruction":"def valid(k, mid):\n    return (2*k - mid - 1) * mid \/\/ 2 + 1\n\ndef binary_search(n, k):\n    l, r = 0, k-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(k, mid) < n):\n            l = mid+1\n        else:\n            r = mid-1\n    return l\n\ndef main():\n    n, k = map(int, input().split())\n    res = binary_search(n, k)\n    print(-1 if res == k else res)\n\nmain()","output":"logn"},{"instruction":"from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nn,L = li()\nl = []\nfor i in range(n):\n    l.append(li())\n\nindex = defaultdict(list)\nfor ind,i in enumerate(l):\n    index[tuple(i)].append(ind + 1)\n\nl.sort(key = lambda x:x[1])\nd = defaultdict(list)\n\nans = i = tot = currpoints = 0\nanspattern = []\nhe = []\n\nwhile i < n:\n\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n\n    if currpoints > ans:\n        ans = currpoints\n\n    i += 1\ni = tot = currpoints = 0\nhe = []\nd = defaultdict(list)\n\nwhile i < n:\n\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n\n    if currpoints == ans:\n        anspattern = []\n        for i in he:\n            for j in d[i]:\n                anspattern.append(index[tuple([i,j])][-1])\n                index[tuple([i,j])].pop()\n        print(ans)\n        print(len(anspattern))\n        print(*sorted(anspattern))\n        exit()\n    i += 1","output":"nlogn"},{"instruction":"n,m=map(int,input().split())\nMAP=[list(input()) for i in range(n)]\n\nANSMAP=[[\".\" for i in range(m)] for j in range(n)]\n\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if MAP[i-1][j-1]==\"\n            ANSMAP[i-1][j-1] =\"\n            ANSMAP[i-1][j]=\"\n            ANSMAP[i-1][j+1]=\"\n            ANSMAP[i][j-1]=\"\n            ANSMAP[i][j+1]=\"\n            ANSMAP[i+1][j-1]=\"\n            ANSMAP[i+1][j]=\"\n            ANSMAP[i+1][j+1]=\"\n\nif MAP==ANSMAP:\n    print(\"YES\")\n\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"import math\ns1=str(input())\ns2=str(input())\nd1=0;d2=0;n=0\nanswer=0\nfor i in s1:\n    if i=='+':d1+=1\n    else:\n        d1-=1\nfor i in s2:\n    if i=='+':d2+=1\n    elif i=='?':n+=1\n    else:\n        d2-=1\nif n>=abs(d2-d1):\n    y=(n-abs(d1-d2))\/2\n    if y%1==0:\n        answer=math.factorial(n)\/math.factorial(n-y)\/math.factorial(y)\/2**n\nprint('%.9f'%answer)","output":"np"},{"instruction":"def isValid(field, y, x):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 1 and j == 1:\n\t\t\t\tcontinue\n\t\t\tif field[y + i][x + j] == '.':\n\t\t\t\treturn False\n\treturn True\ndef fill(field, y, x):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 1 and j == 1:\n\t\t\t\tcontinue\n\t\t\tcur[y + i][x + j] = '\nn, m = list(map(int, input().split()))\nsig = []\ncur = []\nfor i in range(n):\n\tsig += [list(input())]\n\tcur += [[\".\"] * m]\n\nfor i in range(n - 2):\n\tfor j in range(m - 2):\n\t\tif isValid(sig, i, j):\n\t\t\tfill(cur, i, j)\n\nif sig == cur:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"from collections import deque\nn, d, k = map(int, input().split())\nif n==1:\n    print('NO')\n    exit(0)\nif n==2:\n    if d>1:\n        print('NO')\n    else:\n        print('YES')\n        print(1, 2)\n    exit(0)\nif (not 2<=d<=n-1) or k==1:\n    print('NO')\n    exit(0)\nans = []\nfor i in range(d):\n    ans.append((i+1, i+2))\nnow = d+2\nfor i in range(d-1):\n    q = deque([(i+2, min(i, d-i-2))])\n    first = True\n    while q and len(ans)<n-1:\n        node, depth = q.popleft()\n        end = now+k-1\n        if first:\n            end -= 1\n        for j in range(now, end):\n            ans.append((node, j))\n            if len(ans)==n-1:\n                break\n            if depth>0:\n                q.append((j, depth-1))\n        now = end\n        first = False\n\nif len(ans)==n-1:\n    print('YES')\n    for i, j in ans:\n        print(i, j)\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n = int(input())\nb = [int(w) for w in input().split()]\na = [0]*n\n\nl = n\/\/2 - 1\nr = n\/\/2\n\na[l] = b[l] \/\/ 2\na[r] = b[l] - a[l]\n\nwhile l > 0:\n    if b[l-1] >= b[l]:\n        a[l-1] = a[l]\n        a[r+1] = b[l-1] - a[l]\n    else:\n        a[r+1] = a[r]\n        a[l-1] = b[l-1] - a[r]\n    l -= 1\n    r += 1\n\nprint(*a)","output":"linear"},{"instruction":"def isPoss(n, arrs, nvals):\n    masks = set()\n    midx = {}\n    for pos,arr in enumerate(arrs):\n        mask = 0\n        for i in range(nvals):\n            if arr[i]>=n:\n                mask += 1<<i\n        midx[mask] = pos+1\n        masks.add(mask)\n\n    for m1 in masks:\n        for m2 in masks:\n            if m1|m2 == (1<<nvals)-1:\n                return midx[m1], midx[m2]\n\n    return -1, -1\n\nnarr, nvals = map(int, input().split())\n\narrs = []\nfor i in range(narr):\n    arrs.append(list(map(int, input().split())))\n\nmn = -1\nmx = 10**9+1\nwhile mn < mx-1:\n    mid = (mn + mx) \/\/ 2\n    a,b = isPoss(mid, arrs, nvals)\n    if a != -1:\n        mn = mid\n    else:\n        mx = mid - 1\n\nfor i in range(1,-1,-1):\n    a,b = isPoss(mn+i, arrs, nvals)\n    if a != -1:\n        print(a,b)\n        break","output":"np"},{"instruction":"from sys import stdin,stdout\nfor _ in range(1):\n\n    moves,left=list(map(int,stdin.readline().split()))\n\n    l=1;r=10**9+1\n    while l<=r:\n        mid=(l+r)>>1\n        fx=(mid*(mid+1))\/\/2-left+mid\n\n        if fx<=moves:l=mid+1\n        else:r=mid-1\n    print(moves-r)","output":"logn"},{"instruction":"def getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\n\nn = getN()\nmid = n * 2 -1\nans = -mid\nwhile(mid > 0):\n    ans += mid*2\n    mid -= 2\n\nprint(ans)","output":"linear"},{"instruction":"candies = 0\nn, k = map(int,input().split())\nsumm = 0\nif k == 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies == i:\n            print(i)\n            break\n\nif k != 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies - i == k:\n            print(i)\n            break","output":"logn"},{"instruction":"c = 0\ndef backtracking(actuales,restantes,l,r,x):\n    global c\n    if sum(actuales)<=r and sum(actuales) >= l:\n        if max(actuales)- min(actuales) >= x:\n            c += 1\n    if restantes:\n        for i in range(len(restantes)):\n            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)\n    return 0\ndef main():\n    n,l,r,x = input().split(\" \")\n    n,l,r,x = int(n), int(l), int(r), int(x)\n    difficulties = input().split(\" \")\n    for i in range(len(difficulties)):\n        difficulties[i] = int(difficulties[i])\n    difficulties.sort()\n    backtracking([],difficulties,l,r,x)\n    global c\n    return c\n\nif __name__ == \"__main__\":\n    print(main())","output":"np"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nimport random\nimport time\nrandom.seed( int(time.time()) )\n\nbb = random.randint(0, 2**30-1)\n\nhat1 = 0\nhat2 = 0\nlastresult = None\nfor i in range(29, -1, -1):\n    g1 = hat1 + (1<<i)\n    g2 = hat2 + (1<<i)\n\n    if lastresult is None:\n        print('?',hat1^ bb,hat2)\n        t1 = int(input())\n    else:\n        t1 = lastresult\n    if t1!=0:\n        print('?',g1^ bb,g2)\n        t2 = int(input())\n        if t1!=t2:\n            if t1==1:\n                hat1+= (1<<i)\n            else:\n                hat2+= (1<<i)\n            lastresult = None\n            continue\n    lastresult = t1\n    print('?',g1^ bb,hat2)\n    t3 = int(input())\n    if t3==1:\n        pass\n    else:\n        hat1+= (1<<i)\n        hat2+= (1<<i)\n\nprint('!', hat1^bb% (2**30), hat2)","output":"constant"},{"instruction":"ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n\na,b,c,d,e,f=kk()\nal = [a,b,c,d,e,f]\ns = sum(al)\narea = a*b+c*d+e*f\nside = int(area**.5)\nif side**2 != area or side not in al:\n\tprint(-1)\n\texit()\nif al.count(side) == 3:\n\n\tif s == 4*side:\n\t\trest = [a for a in al if a != side]\n\t\tprint(side)\n\t\tfor _ in range(side):\n\t\t\tprint(\"\".join([\"A\"*rest[0], \"B\"*rest[1], \"C\"*rest[2]]))\nelif al.count(side) > 1:\n\tprint(-1)\nelse:\n\tx=al.index(side)\n\ty=x^1\n\tres = al[y]\n\ta,b=min(x,y),max(x,y)\n\ts1 = \"ABC\"[a\/\/2]\n\ts23 = [s for s in \"ABC\" if s != s1]\n\trest = al[:a]+al[b+1:]\n\tres = side - res\n\ta,b=[rest[0],rest[1]],[rest[2],rest[3]]\n\tif not (res in a and res in b):\n\t\tprint(-1)\n\t\texit()\n\to1,o2 = a[a.index(res)^1],b[b.index(res)^1]\n\tprint(side)\n\tfor _ in range(al[y]):\n\t\tprint(s1*side)\n\tfor _ in range(res):\n\t\tprint(\"\".join([s23[0]*o1,s23[1]*o2]))","output":"np"},{"instruction":"import io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nl,r=list(map(int,input().split()))\nif l==r:\n    print(0)\nelse:\n    a=bin(l)[2:]\n    b=bin(r)[2:]\n    x=len(a)\n    y=len(b)\n    if x!=y:\n        ans=0\n        for i in range(y):\n            ans+=(2**i)\n        print(ans)\n    else:\n        for i in range(x):\n            if a[i]!=b[i]:\n                ind=i\n                break\n        l=x-ind\n        ans=0\n        for i in range(l):\n            ans+=(2**i)\n        print(ans)","output":"logn"},{"instruction":"n=int(input())\nS=[]\nfor i in range(n):\n    A=[int(i) for i in input().split()]\n    S.append(sum(A))\nif S[0]==max(S):\n    print(\"1\")\n    exit()\nthomas=S[0]\nrank=1\nS.sort(reverse=True)\nfor i in S:\n    if i == thomas:\n        print(rank)\n        exit()\n    else:\n        rank+=1","output":"linear"},{"instruction":"import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):\n\t    d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"a,v=map(int,input().split())\n\nl,d,w=map(int,input().split())\n\nt=0\n\ndef gett(a,b,c):\n\n    delta=b**2-4*a*c\n\n    t1=(-b+delta**(1\/2))\/(2*a)\n\n    t2=(-b-delta**(1\/2))\/(2*a)\n\n    if min(t1,t2)>0:\n\n        return min(t1,t2)\n\n    else:\n\n        return max(t1,t2)\n\nif 2*a*d<=w*w or v<=w:\n\n    if 2*a*l<=v*v:\n\n        t=(2*l\/a)**(1\/2)\n\n    else:\n\n        t=l\/v+v\/a\/2\n\nelse:\n\n    tmp=d-1\/2*v*v\/a+1\/2*(v-w)**2\/a-v*(v-w)\/a\n\n    if tmp<=0:\n\n        tmp2=l-d-(1\/2*(v-w)**2\/a+w*(v-w)\/a)\n\n        if tmp2>=0:\n\n            t=tmp2\/v+(v-w)\/a+2*gett(a,2*w,w*w\/(2*a)-d)+w\/a\n\n        else:\n\n            t=gett(a\/2,w,d-l)+2*gett(a,2*w,w*w\/(2*a)-d)+w\/a\n\n    else:\n\n        tmp2=l-d-(1\/2*(v-w)**2\/a+w*(v-w)\/a)\n\n        if tmp2>=0:\n\n            t=tmp2\/v+(v-w)\/a+(2*v-w)\/a+tmp\/v\n\n        else:\n\n            t=gett(a\/2,w,d-l)+(2*v-w)\/a+tmp\/v\n\nprint(\"%.12f\" %(t))","output":"constant"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    if a[i]>=0:\n        a[i] = -a[i]-1\nx = min(a)\n\nif len(a)%2==1:\n    for i in range(n):\n        if a[i]==x:\n            a[i] = -a[i]-1\n            break\nprint(*a)","output":"linear"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nfor _ in range(N):\n    l,r = getIntList()\n    n = (r-l+1)\n    z = n\/\/2\n    if l%2==0:\n        z*=-1\n    if n%2==1:\n        if r%2==0:\n            z += r\n        else:\n            z-=r\n    print(z)","output":"constant"},{"instruction":"l,r = map(int,input().split())\nans = l ^ r\nx = bin(ans)[1:]\nif ans == 0:\n    print(0)\nelse:\n    ptr = -1\n    po = 0\n    while True:\n        if( x[ptr] == '0') :\n            ans += 2**po\n        po += 1\n        ptr-=1\n        if( ptr == -len(x)-1 ):\n            break\n\n    print(ans)","output":"logn"},{"instruction":"def solve():\n    l, r = map(int, input().split())\n\n    ans = l^r\n    j = 0\n    while 1<<j <= ans:\n        ans |= 1<<j\n        j += 1\n\n    print(ans)\n\nsolve()","output":"logn"},{"instruction":"ans = []\nimport math\ndisks_rad = [int(x) for x in input().split(\" \")]\nnums = [int(x) for x in input().split(\" \")]\nr = disks_rad[1]\nans.append(r)\nfor i in range(1, disks_rad[0]):\n  y_cord = r\n  for j in range(i):\n      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):\n          y_cord = max(y_cord,\n                        ans[j] +\n                        math.sqrt(4 *\n                                  (r ** 2) -\n                                  (nums[j] - nums[i]) ** 2\n                                )\n                      )\n  ans.append(y_cord)\nprint(\" \".join([str(x) for x in ans]))","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\na = []\narray = []\nfor i in range(n):\n    a.append(list(map(str, input())))\n    listt = []\n    for c in range(m):\n        if a[i][c] == '\n            listt.append(1)\n        else:\n            listt.append(0)\n    array.append(listt)\nfor y in range(1, n - 1):\n    for x in range(1, m - 1):\n        f = a[y + 1][x] == '\n        s = a[y][x + 1] == '\n        th = a[y - 1][x] == '\n        if f and s and th:\n            array[y + 1][x] -= 1\n            array[y + 1][x + 1] -= 1\n            array[y + 1][x - 1] -= 1\n            array[y][x + 1] -= 1\n            array[y][x - 1] -= 1\n            array[y - 1][x - 1] -= 1\n            array[y - 1][x] -= 1\n            array[y - 1][x + 1] -= 1\nmb = True\nfor y in range(n):\n    for x in range(m):\n        if array[y][x] == 1:\n            mb = False\n            break\nif mb:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"n ,m  = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = 0\nfor i in range(len(a)):\n    if (len(b) == 0):\n        break\n    if (b[0] >= a[i]):\n        ans += 1\n        del b[0]\nprint(ans)","output":"linear"},{"instruction":"n, v = map(int, input().split())\nif n - 1 > v:\n    print(v + (n - v + 2) * (n - v - 1) \/\/ 2)\nelse:\n    print(n - 1)","output":"constant"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nst=[a[0]]\nfor i in range(1,n):\n    if len(st)>0 and st[-1]%2==a[i]%2:\n        st.pop()\n    else:\n        st.append(a[i])\nif len(st)<=1:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    arr = list(map(int, input().split()))\n    idx = arr.index(n)\n    ok = 1\n    for i in range(1, idx):\n        if arr[i] < arr[i - 1]:\n            ok = 0\n    for i in reversed(range(idx, n - 1)):\n        if arr[i] < arr[i + 1]:\n            ok = 0\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n    return 0\n\nmain()","output":"linear"},{"instruction":"from sys import stdin\nfrom collections import defaultdict\nimport heapq\n\nn = int(stdin.readline())\na = [[] for _ in range(n)]\nfor _ in range(n-1):\n    e = stdin.readline().split(' ')\n    u, v = int(e[0]), int(e[1])\n    a[u-1].append(v-1)\n    a[v-1].append(u-1)\n\nleaves = [i for i in range(n) if len(a[i]) == 1]\n\ndef dfs_from(root):\n    depth = defaultdict(int)\n    child = {}\n    parent = defaultdict(lambda: -1)\n    stack = [root]\n    visited = [False for _ in range(n)]\n    while len(stack) > 0:\n        crt = stack[-1]\n        if visited[crt]:\n            stack.pop(-1)\n            if len(a[crt]) > 1:\n                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]\n                                              if c != parent[crt]],\n                                             key=lambda x: x[1])\n            else:\n                child[crt] = -1\n                depth[crt] = 0\n            continue\n\n        visited[crt] = True\n        for next in a[crt]:\n            if next != parent[crt]:\n                stack.append(next)\n                parent[next] = crt\n\n    return depth, child\n\nfirst_choice = leaves[0]\nd1, child1 = dfs_from(first_choice)\n\nroot = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],\n           key=lambda leaf_depth: leaf_depth[1])[0]\nwhile child1[root] != -1:\n    root = child1[root]\ndepth, child = dfs_from(root)\n\nsolution = [1]\npq = []\nfor k, v in depth.items():\n    heapq.heappush(pq, (-v, k))\n\nseen = [False for _ in range(n)]\nseen[root] = True\n\nwhile len(pq) > 0:\n    _, best = heapq.heappop(pq)\n    if seen[best]:\n        continue\n    path = []\n    c = best\n    s = 0\n    while c != -1:\n        seen[c] = True\n        c = child[c]\n        s = s+1\n    s = s + solution[-1]\n    solution.append(s)\n\nfor _ in range(n - min(len(solution), n)):\n    solution.append(n)\n\nprint(' '.join([str(s) for s in solution]))","output":"nlogn"},{"instruction":"n,m=map(int,input().split())\ndp=[[-1 for i in range(m)] for j in range(n)]\ndp2=[[-1 for i in range(m)] for j in range(n)]\n\nfor i in range(0,n):\n    s=input()\n    for j in range(0,m):\n        if(s[j]=='.'):\n            dp[i][j]=-1\n        else:\n            dp[i][j]=s[j]\nfor i in range(0,n-2):\n    for j in range(0,m-2):\n\n        p=0\n        c=0\n        for k in range(i,i+3):\n            for h in range(j,j+3):\n                p=p+1\n                if(p!=5):\n                    if(dp[k][h]=='\n                        c=c+1\n\n        if(c==8):\n            p=0\n            for k in range(i,i+3):\n                for h in range(j,j+3):\n                    p=p+1\n                    if(p!=5):\n                        dp2[k][h]='\n\nif(dp==dp2):\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"from math import gcd\nimport sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\nDXY = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\ndef on_one_line(Points):\n    n = len(Points)\n    s = set([])\n    for i in range(1,n):\n        x,y = Points[i][0] - Points[0][0],Points[i][1] - Points[0][1]\n        g = gcd(x,y)\n        x \/\/= g\n        y \/\/= g\n        if (x < 0):\n            x *= -1;y *= -1\n        if (x == 0):\n            y = abs(y)\n        s.add((x,y))\n    return len(s) == 1\n\ndef main():\n    n = int(input())\n    Ps = [tuple(map(int, input().split())) for i in range(n)]\n    if n <= 2:\n        print(\"YES\")\n        return 0\n    if on_one_line(Ps):\n        print(\"YES\")\n        return 0\n\n    p,q = Ps[1][0] - Ps[0][0],Ps[1][1] - Ps[0][1]\n    g = gcd(p,q)\n    p \/\/= g;q \/\/= g\n    if (p < 0):p *= -1;q *= -1\n    elif (p == 0):q = abs(q)\n\n    not_same = []\n    for i in range(2,n):\n        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]\n        x,y = x\/\/gcd(x,y),y\/\/gcd(x,y)\n        if (x < 0):x *= -1;y *= -1\n        if (x == 0):y = abs(y)\n        if (x,y) != (p,q):\n            not_same.append(Ps[i])\n\n    if len(not_same) <= 1:\n        print(\"YES\")\n        return 0\n\n    if on_one_line(not_same):\n        print(\"YES\")\n        return 0\n\n    p,q = not_same[0][0] - Ps[0][0],not_same[0][1] - Ps[0][1]\n    P,Q = not_same[0]\n    g = gcd(p,q)\n    p \/\/= g;q \/\/= g\n    if (p < 0):p *= -1;q *= -1\n    elif (p == 0):q = abs(q)\n    not_same = []\n\n    for i in range(n):\n        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]\n        if (x == 0 and y == 0):continue\n        x,y = x\/\/gcd(x,y),y\/\/gcd(x,y)\n        if (x < 0):x *= -1;y *= -1\n        if (x == 0):y = abs(y)\n        if (x,y) != (p,q):\n            not_same.append(Ps[i])\n\n    if len(not_same) <= 1:\n        print(\"YES\")\n        return 0\n\n    if on_one_line(not_same):\n        print(\"YES\")\n        return 0\n\n    p,q = P - Ps[1][0],Q - Ps[1][1]\n    g = gcd(p,q)\n    p \/\/= g;q \/\/= g\n    if (p < 0):p *= -1;q *= -1\n    elif (p == 0):q = abs(q)\n\n    not_same = []\n    for i in range(n):\n        x,y = Ps[i][0] - Ps[1][0],Ps[i][1] - Ps[1][1]\n        if (x == 0 and y == 0):continue\n        x,y = x\/\/gcd(x,y),y\/\/gcd(x,y)\n        if (x < 0):x *= -1;y *= -1\n        if (x == 0):y = abs(y)\n        if (x,y) != (p,q):\n            not_same.append(Ps[i])\n\n    if len(not_same) <= 1:\n        print(\"YES\")\n        return 0\n\n    if on_one_line(not_same):\n        print(\"YES\")\n        return 0\n\n    print(\"NO\")\n    return 0\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n,l,r,x = map(int,input().split())\nc = [int(i) for i in input().split()]\nans = 0\nfor bit in range(2,1<<n):\n    probs = []\n    t = 0\n    for i in range(n):\n        if bit&(1<<i):\n            probs.append(c[i])\n            t += c[i]\n\n    a = min(probs)\n    b = max(probs)\n\n    if t >= l and t <= r and abs(a-b) >= x:\n        ans += 1\nprint(ans)","output":"np"},{"instruction":"n = int(input())\nif n % 2 == 1:\n    print((n + 2) \/\/ 2)\nelif n > 0:\n    print(n + 1)\nelse:\n    print(0)","output":"constant"},{"instruction":"n = int(input())\nu = list(map(int, input().split()))\nu.sort()\nans = 0\nk = 1\nok = False\nfor i in range(1, n):\n    if u[i] == u[i - 1]:\n        k += 1\n        if k == 3:\n            print('cslnb')\n            exit()\n        if k == 2:\n            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:\n                print('cslnb')\n                exit()\n            ok = True\n    else:\n        k = 1\nfor i in range(n):\n    ans += u[i] - i\nif ans % 2 == 0:\n    print('cslnb')\nelse:\n    print('sjfnb')","output":"nlogn"},{"instruction":"from sys import stdin, stdout\nimport bisect\ninput = stdin.readline\nt = 1\nfor _ in range(t):\n    n,q=map(int,input().split())\n    a=[int(x) for x in input().split()]\n    pre=[]\n    s=0\n    for i in a:\n        s+=i\n        pre.append(s)\n    lost=0\n    val_lost=0\n    ans=[]\n    qu=[int(x) for x in input().split()]\n    for i in qu:\n        val=i+val_lost\n        b=bisect.bisect_left(pre,val,lost,n)\n        val_lost=min(val,pre[-1])\n        if b==n:\n            lost = 0\n            val_lost = 0\n            ans.append(n)\n            continue\n        if pre[b]==val:\n            lost=b+1\n        else:\n            lost=b\n        if lost==n:\n            lost = 0\n            val_lost = 0\n        ans.append(n-lost)\n    for i in ans:\n        print(i)","output":"nlogn"},{"instruction":"x,y,z,t1,t2,t3 = map(int, input().split())\nstairs = abs(x - y) * t1\nlift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\nprint('YES' if lift <= stairs else 'NO')","output":"constant"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\ncost=[(l[i]+r[i],i) for i in range(n)]\n\ncost.sort()\n\nCANDIES=[None]*n\nCANDIES[cost[0][1]]=n\n\ncandy=n\nfor i in range(1,n):\n    if cost[i][0]==cost[i-1][0]:\n        CANDIES[cost[i][1]]=candy\n    else:\n        candy-=1\n        CANDIES[cost[i][1]]=candy\n\ncheck=1\nfor i in range(n):\n    lc=0\n    rc=0\n    for j in range(i):\n        if CANDIES[j]>CANDIES[i]:\n            lc+=1\n    for j in range(i+1,n):\n        if CANDIES[j]>CANDIES[i]:\n            rc+=1\n\n    if lc!=l[i] or rc!=r[i]:\n        check=0\n\nif check==1:\n    print(\"YES\")\n    for c in CANDIES:\n        print(c,end=\" \")\n\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport random\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')):\n\n    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n    def I():return (int(input()))\n    def In():return(map(int,input().split()))\nelse:\n\n    def I():return (int(stdin.readline()))\n    def In():return(map(int,stdin.readline().split()))\n\ndef dict(a):\n    d={}\n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n    return d\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return -1\n\ndef cal(r,g,b,dp,R,G,B,nr,ng,nb):\n    if dp[r][g][b]!=-1:\n        return dp[r][g][b]\n    best=0\n    if r<nr and g<ng:\n        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])\n    if r<nr and b<nb:\n        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])\n    if g<ng and b<nb:\n        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])\n    dp[r][g][b]=best\n    return dp[r][g][b]\ndef main():\n    try:\n        nr,ng,nb=In()\n        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]\n        R=list(In())\n        G=list(In())\n        B=list(In())\n        R.sort(reverse=True)\n        G.sort(reverse=True)\n        B.sort(reverse=True)\n        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))\n    except:\n        pass\n\nM = 998244353\nP = 1000000007\n\nif __name__ == '__main__':\n\n    for _ in range(1):main()","output":"cubic"},{"instruction":"fib = [0]*100\nfib[1] = 1\nfor i in range(2, 100):\n    fib[i] = fib[i-1] + fib[i-2]\n\nn = int(input())\n\nif (n in fib):\n    if (n == 0):\n        print(0, 0, 0)\n    elif (n == 1):\n        print(0, 0, 1)\n    else:\n        print(0, fib[fib.index(n)-2], fib[fib.index(n)-1])\nelse:\n    print(\"I'm too stupid to solve this problem\")","output":"constant"},{"instruction":"R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\n\nDP = [0] * ((R+1) * (G+1) * (B+1))\ndef idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b\n\nfor r in range(R+1):\n\tfor g in range(G+1):\n\t\tfor b in range(B+1):\n\t\t\tbest = 0\n\n\t\t\tif r:\n\t\t\t\tif g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n\t\t\t\tif b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n\n\t\t\tif g and b:\n\t\t\t\tbest = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n\n\t\t\tDP[idx(r, g, b)] = best\n\nprint(max(DP))","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n, k = map(int, input().split())\n    print(n-int(((9+8*(n+k))**0.5-3)\/2))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"x, k = map(int, input().split())\nMOD = 1000000007\npw = pow(2, k + 1, MOD)\nn = pow(2, k, MOD)\na = (pw * x) - n\na = (a + 1) % MOD\nif x == 0:\n    a = 0\nprint(int(a))","output":"logn"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,m=get_ints()\n    space=0\n    saved=[]\n    for i in range(n):\n        a,b=get_ints()\n        space+=a\n        saved.append(a-b)\n    saved.sort(reverse=True)\n    if space-sum(saved)>m:\n        print(-1)\n        continue\n    i=0\n    count=0\n    if space<=m:\n        print(0)\n        continue\n    while i<n:\n        count+=1\n        space-=saved[i]\n        if space<=m:\n            print(count)\n            break\n        i+=1","output":"nlogn"},{"instruction":"t = int(input())\n\ndef getcol(x1, y1, x2, y2):\n    dx = max((x2-x1+1), 0)\n    dy = max((y2-y1+1), 0)\n    b = w = dx*dy\/\/2\n    if dx % 2 and dy % 2:\n        if (x1+y1) % 2:\n            b = b + 1\n        else:\n            w = w + 1\n    return w, b\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    w, b = getcol(1,1,n,m)\n    w1, b1 = getcol(x1,y1,x2,y2)\n    w2, b2 = getcol(x3,y3,x4,y4)\n    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))\n    woff = w-w1-w2+w3\n    boff = b-b1-b2+b3\n    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)","output":"constant"},{"instruction":"a = []\nn = int(input())\nfor _ in range(n):\n    a.append(input())\nif n==1:\n    print(\"YES\")\n    print(a[0])\nelse:\n    a.sort(key = len)\n    for i in range(1,n):\n        if a[i-1] not in a[i]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n        for i in a:\n            print(i)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nx1 = -1\nx2 = -1\ny1 = -1\ny2 = -1\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        if s[j] == 'B':\n            if x1 == -1:\n                x1 = j + 1\n            x2 = max(x2, j + 1)\n            if y1 == -1:\n                y1 = i + 1\n            y2 = i + 1\nprint((y1 + y2) \/\/ 2, (x1 + x2) \/\/ 2)","output":"quadratic"},{"instruction":"from collections import deque\n\nm, k = list(map(int, input().split()))\n\nG = [set() for _ in range(m + 1)]\n\nq, nq = deque(), deque()\n\nfor _ in range(m - 1):\n    u, v = list(map(int, input().split()))\n    G[u].add(v)\n    G[v].add(u)\n\nfor u in range(1, m + 1):\n    if len(G[u]) == 1:\n        q.append(u)\n\nstep = 0\nremoved = 0\nok = True\n\nwhile removed < m - 1:\n    each = {}\n    for u in q:\n        nxt = G[u].pop()\n        G[nxt].remove(u)\n        each[nxt] = each.get(nxt, 0) + 1\n        removed += 1\n        if len(G[nxt]) == 0:\n            break\n        if len(G[nxt]) == 1:\n            nq.append(nxt)\n    if any(v < 3 for k,v in each.items()):\n        ok = False\n        break\n    q, nq = nq, deque()\n    step += 1\n\nif ok and step == k and removed == m - 1:\n    print('Yes')\nelse:\n    print('No')","output":"nlogn"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nans=0\nm=[]\nfor i in range(2*n-1,-1,-1):\n    if l[i] not in m:\n        m.append(l[i])\n\nfor tt in range(0,n):\n    i=m[tt]\n    j=l.index(i)\n    l.pop(j)\n    k=l.index(i)\n    l.insert(k,j)\n    ans+=k-j\nprint(ans)","output":"quadratic"},{"instruction":"print(\"? 0 0\")\nans00 = input()\nxr = 0\na = 0\nb = 0\ncb = 2 ** 29\nwhile cb:\n\tprint(\"?\", xr + cb, cb)\n\tans11 = input()\n\tprint(\"?\", xr, cb)\n\tif ans11 == ans00:\n\t\tans01 = input()\n\t\tif ans01 == '1':\n\t\t\ta += cb\n\t\t\tb += cb\n\telse:\n\t\tans00 = input()\n\t\tif ans11 == '1':\n\t\t\tb += cb\n\t\telse:\n\t\t\ta += cb\n\t\txr += cb\n\tcb \/\/= 2\nprint(\"!\", a, b)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nP=[input().strip() for i in range(n)]\nS=[input().split() for i in range(m)]\n\nfor i in range(m):\n    S[i][1]=int(S[i][1])-1\n\nPDICT=dict()\nfor i in range(n):\n    PDICT[P[i]]=i\n\nE=[]\n\nfor i in range(m):\n    x=S[i][0]\n    LIST=[]\n\n    for j in range(1<<k):\n        t=\"\"\n        for l in range(k):\n            if (1<<l) & j != 0:\n                t+=\"_\"\n            else:\n                t+=x[l]\n\n        if t in PDICT:\n            LIST.append(PDICT[t])\n\n    if not (S[i][1] in LIST):\n        print(\"NO\")\n        exit()\n\n    else:\n        s=S[i][1]\n        for l in LIST:\n            if l==s:\n                continue\n            else:\n                E.append((s,l))\n\nEDGEIN=[0]*n\nEDGEOUTLIST=[[] for i in range(n)]\nfor x,y in E:\n    EDGEIN[y]+=1\n    EDGEOUTLIST[x].append(y)\n\nfrom collections import deque\nQUE = deque()\n\nfor i in range(n):\n    if EDGEIN[i]==0:\n        QUE.append(i)\n\nTOP_SORT=[]\nwhile QUE:\n    x=QUE.pop()\n    TOP_SORT.append(x)\n    for to in EDGEOUTLIST[x]:\n        EDGEIN[to]-=1\n        if EDGEIN[to]==0:\n            QUE.appendleft(to)\n\nif len(TOP_SORT)==n:\n    print(\"YES\")\n    print(*[i+1 for i in TOP_SORT])\nelse:\n    print(\"NO\")","output":"np"},{"instruction":"from collections import Counter\n\ndef f(x):\n    return max(list(Counter(x).values()))\n\nn=int(input())\nz=input()\nl=len(z)\na=f(z)\nb=f(input())\nc=f(input())\n\ndef v(x):\n    if x==l:\n        return x-1\n    else:\n        return x+1\n\nif n==1:\n    a, b, c=v(a), v(b), v(c)\n    if a>b and a>c:\n        print(\"Kuro\")\n    elif b>a and b>c:\n        print(\"Shiro\")\n    elif c>a and c>b:\n        print(\"Katie\")\n    else:\n        print(\"Draw\")\nelif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:\n    print(\"Draw\")\nelif a>b and a>c:\n    print(\"Kuro\")\nelif b>a and b>c:\n    print(\"Shiro\")\nelif c>a and c>b:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")","output":"linear"},{"instruction":"N = int(input())\nsrc = [tuple(map(int,input().split() + [i])) for i in range(N)]\nsrc.sort()\n\nprev_l = max_r = 0\nprev_i = outer = -1\nfor l,r,i in src:\n    if prev_l == l:\n        print(prev_i+1, i+1)\n        exit()\n    if r <= max_r:\n        print(i+1, outer+1)\n        exit()\n    else:\n        max_r = r\n        outer = i\n    prev_l = l\n    prev_i = i\nprint(-1,-1)","output":"nlogn"},{"instruction":"def MI():\n    return map(int,input().split())\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\n\nn,k=MI()\n\nb=-(2*n+3)\nc=n*n+n-2*k\nx=(-b-((b*b-4*c)**0.5))\/\/2\ny=(-b+((b*b-4*c)**0.5))\/\/2\nx,y=int(x),int(y)\nfor i in [x-1,x,x+1,y-1,y,y+1]:\n    if i**2+b*i+c==0 and 0<=i<=n-1:\n        print(i)\n        break","output":"constant"},{"instruction":"n = int(input())\nx,y = map(int,input().split())\nnum = x - 1 + y - 1\nnum2 = n - x + n - y\nans = num <= num2\nif ans:\n    print(\"White\")\nelse:\n    print(\"Black\")","output":"constant"},{"instruction":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n\n        def dfs(i, j):\n            if i == len(nums):\n                return 0\n\n            LIS = dfs(i + 1, j)\n\n            if j == -1 or nums[j] < nums[i]:\n                LIS = max(LIS, 1 + dfs(i + 1, i))\n\n            return LIS\n\n        return dfs(0, -1)","output":"np"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nT, = getIntList()\n\nMAXN = 10**18 + 10\ndef getUpper(N):\n    z = 1\n    r = 0\n    for i in range(N):\n        r+=z\n        z*=4\n        if r>MAXN:\n            break\n    return r\nfor _ in range(T):\n    N,K = getIntList()\n    tk = K\n    z = 1\n    for i in range(N):\n        tk -= z\n        z*= 4\n        if tk<0: break\n    if tk>0:\n        print('NO')\n        continue\n    nowcut =  0\n    nt = 1\n    nowupper = 0\n    ok = False\n    for i in range(N):\n        nt *=2\n        nowcut += nt-1\n\n        if nowcut >K: break\n        t = (nt *2 - 3)\n        tu  = t * getUpper(N-1-i)\n        nowupper += tu\n        dprint('bound', nowcut, nowcut+nowupper)\n        if nowcut<=K<= nowcut+nowupper:\n            ok = True\n            break\n    if ok:\n        print('YES', N-1-i)\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"n = int(input())\na = tuple(map(int, input().split()))\nif n * 2 > sum(a) + 2:\n\tprint(\"NO\")\nelse:\n\tn1 = []\n\ton = []\n\tfor i in range(n):\n\t\tif a[i] != 1:\n\t\t\tn1.append(i)\n\t\telse:\n\t\t\ton.append(i)\n\tprint(\"YES\", len(n1) + min(2, len(on)) - 1)\n\tprint(n - 1)\n\tn1it = iter(n1)\n\tnext(n1it)\n\tfor v, u in zip(n1, n1it):\n\t\tprint(v + 1, u + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[-1] + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[0] + 1)\n\ton = iter(on)\n\tfor n11 in n1:\n\t\tfor i in range(a[n11] - 2):\n\t\t\ttry:\n\t\t\t\tprint(n11 + 1, next(on) + 1)\n\t\t\texcept StopIteration:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak","output":"linear"},{"instruction":"l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = bin(r)[2:], bin(l)[2:]\nbinl = '0' * (len(binr) - len(binl)) + binl\n\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        binl = '1' * len(binl[i:])\n        break\n\nprint(int(binl, 2))","output":"logn"},{"instruction":"from itertools import*\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\nN, T = [int(x) for x in raw_input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in raw_input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)","output":"np"},{"instruction":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res, resLen = \"\", 0\n\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                l, r = i, j\n                while l < r and s[l] == s[r]:\n                    l += 1\n                    r -= 1\n\n                if l >= r and resLen < (j - i + 1):\n                    res = s[i : j + 1]\n                    resLen = j - i + 1\n        return res","output":"cubic"},{"instruction":"R = lambda: map(int, input().split())\nfor _ in range(int(input())):\n    n,k = R()\n    s = input()\n    p = (k+2)\/\/2\n    l = \"RGB\"*p\n    res = n\n    for i in range(n-k+1):\n        c = 0\n\n        for j in range(0,k):\n            c += (s[i+j] != l[j])\n        res = min(res,c)\n\n        c = 0\n\n        for j in range(1,k+1):\n            c += (s[i+j-1] != l[j])\n        res = min(res,c)\n\n        c = 0\n\n        for j in range(2,k+2):\n            c += (s[i+j-2] != l[j])\n        res = min(res,c)\n\n    print(res)","output":"quadratic"},{"instruction":"def x(a,b):\n    if(a>b):\n        return(1)\n    else:\n        return(0)\nn=int(input())\na1,a2=map(int,input().split())\nb1,b2=map(int,input().split())\nc1,c2=map(int,input().split())\nif((a1-a2)==(b1-b2)):\n    print(\"NO\")\nelif((a1+a2)==(b1+b2)):\n    print(\"NO\")\nelif(a1==b1):\n    print(\"NO\")\nelif(a2==b2):\n    print(\"NO\")\nelif((a1-a2)==(c1-c2)):\n    print(\"NO\")\nelif((a1+a2)==(c1+c2)):\n    print(\"NO\")\nelif(a1==c1):\n    print(\"NO\")\nelif(a2==c2):\n    print(\"NO\")\nelse:\n    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"def f():\n    b = [a[0]]\n    for e in a[1:]:\n        if b != []:\n            if e == b[-1] or abs(e-b[-1])%2==0:\n                b.pop()\n\n            else:\n                b.append(e)\n        else:\n            b.append(e)\n\n    for i in range(1,len(b)):\n        if abs(b[i]-b[i-1])%2:\n            print('NO')\n            return\n\n    print('YES')\n\nn=int(input())\na=[int(i) for i in input().split()]\n\nf()","output":"linear"},{"instruction":"x, k = map(int, input().split())\n\nif x == 0:\n    result = 0\nelse:\n    modulo = 10**9 + 7\n\n    x %= modulo\n\n    result = pow(2, k, modulo)*(2*x - 1) + 1\n    result %= modulo\n\nprint(result)","output":"logn"},{"instruction":"import math\n\nSPACE = ' '\n\ndef get_data(file_name):\n    result = list()\n    state = 0\n    data = list()\n\n    try:\n        for line in open(file_name, 'r').readlines():\n            line = line.strip()\n            if state == 0:\n                if line == 'Input':\n                    data = list()\n                    state = 1\n                elif line == 'Answer':\n                    state = 2\n            elif state == 1:\n                data += list(map(int, line.split(SPACE)))\n                state = 11\n            elif state == 11:\n                data += list(map(int, line.split(SPACE)))\n                state = 0\n            elif state == 2:\n                data.append(float(line))\n                result.append(data)\n                state = 0\n    except FileNotFoundError:\n        print(f'File {file_name} not found.')\n    return result\n\ndef time(d=None, v=None, v0=0, steady=False):\n    if steady:\n        return d \/ v\n\n    if d is None:\n\n        return (v - v0) \/ ACCEL\n\n    if v is None:\n        v = vel(d=d, v0=v0)\n    return (2 * d) \/ (v + v0)\n\ndef dist(t=None, v=None, v0=0, steady=False):\n    if steady:\n        return v * t\n\n    if t is None:\n\n        return (pow(v, 2) - pow(v0, 2)) \/ (2 * ACCEL)\n\n    return (1 \/ 2) * (v + v0) * t\n\ndef vel(d=None, t=None, v0=0, steady=False):\n    if steady:\n        return d \/ t\n\n    if d is None:\n\n        return t * ACCEL - v0\n\n    return pow(2 * d * ACCEL + v0 ** 2, 1 \/ 2)\n\ndef can_ignore_sign(v, w, d):\n    return v <= w or d <= dist(v=w)\n\ndef ignore_sign(v, w, l):\n    dmax = dist(v=v)\n    if l <= dmax:\n        return time(d=l)\n    return time(v=v) + time(d=l - dmax, v=v, steady=True)\n\ndef get_time(a, v, l, d, w):\n    global ACCEL\n    ACCEL = a\n\n    if can_ignore_sign(v, w, d):\n        return ignore_sign(v, w, l)\n\n    tmax, dmax = time(v=v), dist(v=v)\n    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)\n    if dmax + dlim_max <= d:\n\n        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max\n    else:\n\n        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) \/ 2, v0=w), v0=w) * 2\n\n    x = d + dist(v=v) - dist(v=w)\n    if x >= l:\n\n        res += time(d=l - d, v0=w)\n        return res\n    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)\n\nif __name__ == '__main__':\n    a, v = map(int, input().split())\n    l, d, w = map(int, input().split())\n    print(get_time(a, v, l, d, w))","output":"constant"},{"instruction":"s=input()\nfor ln in range(len(s),0,-1):\n    for L in range(len(s)-ln+1):\n        if s[L:L+ln] in s[L+1:]:\n            print(ln)\n            exit()\nprint(0)","output":"cubic"},{"instruction":"n=int(input())\na=[]\nfor i in range(n+1):\n    a.append(((n+1)-i)*i)\nprint(max(a))","output":"linear"},{"instruction":"n, e = map( int, input().split() )\nd = (n - e) \/\/ 2\nq = []\nwhile n > 0:\n    i = min(n, d)\n    while i > 0:\n        q.append('1')\n        i -= 1\n        n -= 1\n    if n > 0:\n        q.append('0')\n        n -= 1\n\nprint( \"\".join(q) )","output":"quadratic"},{"instruction":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        mask = 0xFFFFFFFF\n        max_int = 0x7FFFFFFF\n\n        while b != 0:\n            carry = (a & b) << 1\n            a = (a ^ b) & mask\n            b = carry & mask\n\n        return a if a <= max_int else ~(a ^ mask)","output":"constant"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nre = 0\nfor i in range(2,N):\n\n    t = N \/\/ i -1\n    re += t * i\n\nprint(re *4)","output":"linear"},{"instruction":"r,g,b = map(int,input().split())\nR = list(map(int,input().split()))\nG = list(map(int,input().split()))\nB = list(map(int,input().split()))\nR.sort()\nG.sort()\nB.sort()\ndp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]\ndef solve(r,g,b):\n\tif ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):\n\t\treturn 0\n\tif dp[r][g][b]==-1:\n\t\tif r==0:\n\t\t\tans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)\n\t\telif g==0:\n\t\t\tans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)\n\t\telif b==0:\n\t\t\tans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)\n\t\telse:\n\t\t\tans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))\n\t\tdp[r][g][b] = ans\n\treturn dp[r][g][b]\nans = solve(r,g,b)\nprint(ans)","output":"cubic"},{"instruction":"l = []\nn = []\nsum = 0\nmultiply = 9\nfor i in range(1,12):\n    s = '9' * i\n    n.append(int(s))\n    sum+=i*multiply\n    multiply *= 10\n    l.append(sum)\nk = int(input())\nif(k<9):\n    print(k)\nelse:\n    t = 0\n    for i in range(len(l)):\n        if(k < l[i]):\n            t=i\n            break\n    temp = k-l[t-1]\n    offset = temp%(t+1)\n    value = temp\/\/(t+1)\n    number = n[t-1]+value\n    if(offset == 0):\n        print(number%10)\n    else:\n        number += 1\n        offset -= 1\n        print(str(number)[offset])","output":"logn"},{"instruction":"from copy import deepcopy\ndef sol(n,m,k,aa,bb):\n    if k&1:\n        return [[-1] * m] * n\n    ans = [[float('inf')]*(m+2) for _ in range(n+2)]\n    k >>= 1\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])\n    for _ in range(k-1):\n        oans = deepcopy(ans)\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                ans[i][j] = min(\n                    aa[i][j]+oans[i][j+1],\n                    aa[i][j-1]+oans[i][j-1],\n                    bb[i][j]+oans[i+1][j],\n                    bb[i-1][j]+oans[i-1][j])\n\n    ans = ans[1:-1]\n    ans = [x[1:-1] for x in ans]\n    ans = [[2*x for x in a] for a in ans]\n    return ans\n\nn,m,k = map(int, input().split())\naa = [list(map(int, input().split())) for _ in range(n)]\ninf = float('inf')\nbb = [list(map(int, input().split())) for _ in range(n-1)]\naa = [[inf, *x, inf] for x in aa]\nbb = [[inf, *x, inf] for x in bb]\npad = [inf] * (m+1)\naa = [pad, *aa, pad]\npad = [inf] * (m+2)\nbb = [pad, *bb, pad]\nans = sol(n,m,k,aa,bb)\nprint('\\n'.join(' '.join(map(str, a)) for a in ans))","output":"cubic"},{"instruction":"success = 0\ndef solve(b, freq, i, n, res):\n    global success\n    if i == len(b):\n        success = res\n    else:\n        success = 0\n        move = 9\n        while move >= 0 and success == 0:\n            m = int(b[i])\n            if freq[move] > 0 and res * 10 + move <= n * 10 + m:\n                res = res * 10 + move\n                n = n * 10 + m\n                freq[move] -= 1\n                if solve(b, freq, i + 1, n, res) == 0:\n                    res \/\/= 10\n                    n \/\/= 10\n                    freq[move] += 1\n            move -= 1\n    return success\n\na = input()\nb = input()\nfreq = []\nfor i in range(10):\n    freq.append(0)\nv = []\nfor x in a:\n    n = int(x)\n    v.append(n)\n    freq[n] += 1\nv.sort()\nans = 0\nif len(b) > len(a):\n    m = 1\n    for x in v:\n        ans = x * m + ans\n        m *= 10\nelse:\n    ans = solve(b, freq, 0, 0, 0)\nprint(ans)","output":"cubic"},{"instruction":"import os\nimport re\nimport sys\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom io import BytesIO, IOBase\nfrom itertools import (\n    accumulate, combinations, combinations_with_replacement, groupby,\n    permutations, product)\nfrom math import (\n    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,\n    sin, sqrt, tan)\nfrom operator import itemgetter, mul\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\ndef inp():\n    return(int(input()))\n\ndef inlist():\n    return(list(map(int, input().split())))\n\ndef instr():\n    s = input()\n    return(list(s[:len(s)]))\n\ndef invr():\n    return(map(int, input().split()))\n\ndef getSum(p, q):\n    n = q - p + 1\n\n    temp = (n * (p + q)\/\/2) - n + 1\n\n    return temp, n\n\ndef main():\n\n    n, k = invr()\n\n    l = 2\n    r = k\n    ans = -1\n\n    while l <= r:\n        mid = l + (r - l) \/\/ 2\n        tot, count = getSum(mid, k)\n        if tot >= n:\n            ans = count\n        if tot < n:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if n == 1:\n        ans = 0\n    print(ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"from sys import stdin,stdout\nimport heapq\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    l=sorted(zip(lst(),lst(),range(n)))\n    h=[];sm=0\n    ans={}\n    for i in range(n):\n        pwr,cns,ind=l[i]\n        sm+=cns\n        if len(h)>k:\n            p=0\n            for i in range(len(h)):\n                if h[p]>h[i]:\n                    p=i\n            sm-=h.pop(p)\n        ans[ind]=sm\n        h+=[cns]\n    for i in range(n):\n        stdout.write(str(ans[i])+' ')\n    print()","output":"nlogn"},{"instruction":"n = int(input())\na = list(input())\nb = list(input())\n\nans = 0\ni = 0\nwhile i < n:\n    if a[i] != b[i]:\n        ans += 1\n        if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]:\n            i += 1\n    i += 1\nprint(ans)","output":"linear"},{"instruction":"import math\n\nn = int(input())\na = list(map(lambda x : int(x), input().split()))\nq = len(a)\n\nearliest_time = pow(10, 9) + 1000\nearliest_queue = 1\nfor i in range(q):\n    n = int(max(0, math.ceil((a[i] + 1 - (i + 1)) \/ q)))\n    t = (i + 1) + n * q\n    if t < earliest_time:\n        earliest_time = t\n        earliest_queue = i + 1\n\nprint(earliest_queue)","output":"linear"},{"instruction":"n,m = map(int, input().strip().split(' '))\nlst = list(map(int, input().strip().split(' ')))\nres = list(dict.fromkeys(lst))\nc=[]\nfor i in range(len(res)):\n    c.append(lst.count(res[i]))\n\nif m<n:\n    print(0)\nelif m==n:\n    print(1)\nelse:\n    m1=1\n    c1=0\n    j=2\n    f=0\n    while(True):\n        c1=0\n        for i in range(len(c)):\n            c1+=c[i]\/\/j\n        if c1>=n:\n            m1=j\n            j+=1\n        else:\n            f=1\n        if f==1:\n            print(m1)\n            break","output":"nlogn"},{"instruction":"def sum_of_digits(n):\n    ans = 0\n    while(n):\n        ans += n%10\n        n\/\/=10\n    return ans\n\nn,s = map(int,input().split())\nlo = 0; hi = n\nx = n+1\nwhile(lo<=hi):\n    mid = (lo+hi)\/\/2\n    if(mid - sum_of_digits(mid) >= s):\n        x = min(mid,x)\n        hi = mid - 1\n    else:\n        lo = mid + 1\nprint(n - x + 1)","output":"logn"},{"instruction":"n, l, r, x = map(int, input().split())\na = [int(i) for i in input().split()]\n\ncount = 0\nfor i in range(1, 2**n+1):\n\ttemp = []\n\tfor j in range(n):\n\t\tif i & (1 << j):\n\t\t\ttemp.append(a[j])\n\n\tif len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r:\n\t\tcount += 1\n\nprint(count)","output":"np"},{"instruction":"n=int(input())+1\nif n==1:\n    print(0)\nelif n%2:\n    print(n)\nelse:\n    print(n\/\/2)","output":"constant"},{"instruction":"import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\n\ndef modInverse(a , m):\n\tm0 = m\n\ty = 0\n\tx = 1\n\tif (m == 1):\n\t\treturn 0\n\twhile (a > 1):\n\t\tq = a \/\/ m\n\t\tt = m\n\t\tm = a % m\n\t\ta = t\n\t\tt = y\n\t\ty = x - q * y\n\t\tx = t\n\tif (x < 0):\n\t\tx = x + m0\n\treturn x\n\ndef num():\n\treturn map(int , input().split())\n\ndef nu():\n\treturn int(input())\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\nn,m=num()\na=[0]*n\nfor i in range(n):\n\ta[i]=[0]*m\nfor i in range(n):\n\ts=input()\n\tfor j in range(m):\n\t\ta[i][j]=s[j]\nz=[\".\"]*n\nfor i in range(n):\n\tz[i]=[\".\"]*m\nfor i in range(n):\n\tfor j in range(m):\n\t\tif(j-1>=0 and j+1 <m and i+1<n and i-1>=0):\n\t\t\tif(a[i-1][j]==\"\n\t\t\t\tz[i-1][j]=\"\n\t\t\t\tz[i + 1][j] = \"\n\t\t\t\tz[i][j - 1] = \"\n\t\t\t\tz[i][j + 1] = \"\n\t\t\t\tz[i - 1][j - 1] = \"\n\t\t\t\tz[i - 1][j + 1] = \"\n\t\t\t\tz[i + 1][j - 1] = \"\n\t\t\t\tz[i + 1][j + 1] = \"\nff=True\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif(z[i][j]!=a[i][j]):\n\t\t\tff=False\n\t\t\tbreak\nif(ff):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"n=int(input())\nm=int(input())\nprint(m%(1<<n))","output":"constant"},{"instruction":"l,r=map(int,input().split())\nif(l%2==0 and r-l>1):\n    print(l,l+1,l+2,end=\" \")\nelif(l%2!=0 and r-l>2):\n    print(l+1,l+2,l+3,end=\" \")\nelse:\n    print(\"-1\")","output":"constant"},{"instruction":"import io,os\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn,m=map(lambda x:int(x), input().split())\nA = []\nfor _ in range(n):\n    scores = list(map(lambda x:int(x), input().split()))\n    A.append(scores)\n\ndef solve(n,m,A):\n\n    ans = ()\n    nstats = 2**m\n    def judge(finalScore):\n        nonlocal ans\n        seen = {}\n        for i,scores in enumerate(A):\n            sta = 0\n            for e in scores:\n                sta=sta*2+(e>=finalScore)\n\n            seen[sta]=i\n\n        for i in range(nstats):\n            for j in range(nstats):\n                if ((i|j) == nstats-1) and i in seen and j in seen:\n                    ans = (seen[i], seen[j])\n                    return True\n\n        return False\n\n    l=0\n    r=2**31-1\n    while l<r:\n        m=l+(r-l)\/\/2\n        if not judge(m):\n            r=m\n        else:\n            l=m+1\n\n    print(ans[0]+1,ans[1]+1)\n\nsolve(n,m,A)","output":"np"},{"instruction":"n=int(input())\nans=[]\nm=int(n**0.5)\nx=n\nwhile x-m>0:\n  for i in range(1,m+1):\n    ans.append(x-m+i)\n  x-=m\nfor i in range(1,x+1):\n  ans.append(i)\nprint(*ans)","output":"linear"},{"instruction":"n, = map(int,input().split())\n\ns = input()\nif s=='0':\n    print(0)\nelse:\n    print(\"1\"+\"0\"*s.count('0'))","output":"linear"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nj = 0\na.sort()\nn1 = n\nfor i in range(n):\n    while a[j] < a[i]:\n        if a[i] <= a[j] + k:\n            n1 -= 1\n        j += 1\nprint(n1)","output":"nlogn"},{"instruction":"from math import factorial\ndef C(m,n):\n    return factorial(n) \/\/ (factorial(m) * factorial(n - m))\n\ncommand_1, command_2 = input(), input()\nnum = command_2.count('?')\ni = command_1.count('+') - command_1.count('-') -\\\ncommand_2.count('+') + command_2.count('-') + num\nif i % 2 == 0 and 0 <= i\/\/2 <= num:\n    print(\"%.9f\"%(C(i\/\/2, num) \/ 2**num))\nelse:\n    print(\"0.000000000\")","output":"np"},{"instruction":"n,m=map(int,input().split())\na=list(map(int,input().split()))\nk=0\nans=-1\nfor i in range(n-1):\n    while k<n-1 and a[k+1] - a[i]<=m:\n        k+=1\n    if i<k-1:\n        ans=max(ans,(a[k]-a[i+1]) \/ (a[k]-a[i]))\nprint(ans)","output":"nlogn"},{"instruction":"def rotate(L):\n    L1 = ['' for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            L1[n - j - 1] += L[i][j]\n    return L1\n\ndef flip_v(L):\n    L1 = []\n    for i in range(n):\n        L1.append(L[i][::-1])\n    return L1\n\ndef flip_h(L):\n    L1 = []\n    for i in range(n):\n        L1.append(L[n - i - 1])\n    return L1\n\nn = int(input())\nL = []\nM = []\nfor i in range(n):\n    L.append(input())\nfor i in range(n):\n    M.append(input())\nL1 = rotate(L)\nL2 = rotate(L1)\nL3 = rotate(L2)\nL4 = flip_v(L)\nL5 = flip_h(L)\nL6 = rotate(L4)\nL7 = rotate(L6)\nL8 = rotate(L7)\nL9 = rotate(L5)\nL10 = rotate(L9)\nL11 = rotate(L10)\nif L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:\n    print('Yes')\nelse:\n    print('No')","output":"quadratic"},{"instruction":"s = [list(input()), list(input())]\nans = 0\nl = len(s[0])\ni = 0\nwhile i < l - 1:\n    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])\n    if a.count(\"0\") == 4:\n        ans += 1\n        s[0][i + 1] = \"X\"\n        i+=1\n    elif a.count(\"0\") == 3:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)","output":"constant"},{"instruction":"from collections import deque\n\nn, m = map(int, input().split())\n\narr = [int(z) for z in input().split()]\n\nmods = [0 for i in range(m)]\nplacement = [[] for i in range(m)]\n\nfor i in range(n):\n    mods[arr[i] % m] += 1\n    placement[arr[i] % m].append(i)\n\ncnt = 0\nqueue = deque()\ntarget = n\/\/m\nfor i in range(2*m):\n    mod = i % m\n    if mods[mod] > n\/\/m:\n\n        for c in range(mods[mod] - target):\n            queue.append([i, placement[mod][c]])\n        mods[mod] = target\n\n    elif mods[mod] < target:\n        while len(queue) > 0 and mods[mod] < target:\n            elem, indice = queue.popleft()\n            mods[mod] += 1\n            cnt += (mod - elem) % m\n            arr[indice] += (mod - elem) % m\n\nprint(cnt)\nprint(' '.join([str(i) for i in arr]))","output":"linear"},{"instruction":"from math import factorial as fact\n\ns=input()\nt=input()\n\npos=s.count('+')-t.count('+')\nneg=s.count('-')-t.count('-')\nque=t.count('?')\nif pos<0 or neg<0:\n    print(0)\nelse:\n    print((fact(que)\/(fact(pos)*fact(neg)))\/(2**que))","output":"np"},{"instruction":"import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\ndef slv():\n    k = int(input())\n\n    def cnt_special(N):\n        if N == 0:\n            return 0\n        return cnt_special(N - 1) + N * (pow(10, N) - pow(10, N - 1))\n\n    def cnt_digit(N):\n        ord = len(str(N))\n        bound = ord - 1\n        return cnt_special(bound) + ord * (N + 1 - 10 ** bound)\n\n    if k < 10:\n        print(k)\n    else:\n        l = 1\n        r = int(1e12)\n        while r - l > 1:\n            med = (r + l)\/\/2\n            if cnt_digit(med) >= k:\n                r = med\n            else:\n                l = med\n\n        rep = k - cnt_digit(l)\n        print(str(r)[rep - 1])\n        return\n\ndef main():\n    t = 1\n    for i in range(t):\n        slv()\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\ndef main():\n    n,m,k = map(int,input().split())\n    if k%2==1:\n        for i in range(n):\n            for j in  range(m):\n                print(-1,end=\" \")\n            print()\n        return 0\n    kk=k\n    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]\n\n    dp=[[[1e9 for i in range(k\/\/2+1)] for j in range(m)] for ii in range(n)]\n    for i in range(n):\n            for j in range(m):\n                dp[i][j][0]=0\n    for i in range(n):\n        s=list(map(int,input().split()))\n        for j in range(m-1):\n            maps[i][j][0]=s[j]\n            maps[i][j+1][1]=s[j]\n    for i in range(n-1):\n        s=list(map(int,input().split()))\n        for j in range(m):\n            maps[i][j][2]=s[j]\n            maps[i+1][j][3]=s[j]\n    for k in range(1,kk\/\/2+1):\n        for i in range(n):\n            for j in range(m):\n                if j<m-1:\n                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])\n                if i<n-1:\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])\n                if i>0:\n                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])\n                if j>0:\n                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k]*2,end=\" \")\n        print()\nmain()","output":"cubic"},{"instruction":"import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        n, d = map(int, input().strip().split())\n        x = list(map(int, input().strip().split()))\n        ans = set()\n        for i in range(n):\n            for z in [-d, d]:\n                y = x[i] + z\n                dmin = min(abs(y - xi) for xi in x)\n                if dmin == d:\n                    ans.add(y)\n        print(len(ans))\n\nsolver()","output":"linear"},{"instruction":"def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    r = 0\n    while a:\n        c = a[0]\n        del a[0]\n        for i in range(len(a)):\n            if c == a[i]:\n                break\n        del a[i]\n        r += i\n    print(r)\n\nif __name__ == \"__main__\":\n    main()","output":"quadratic"},{"instruction":"def power(x,y):\n\tmod=1000000007\n\tres = 1\n\twhile (y > 0):\n\t\tif (y &1):\n\t\t\tres = (res * x)%mod\n\t\ty = y >> 1\n\t\tx = (x * x)%mod\n\treturn res;\nx,k=map(int,input().split())\nmod=1000000007\nfactor=power(2,k)\nfactor%=mod\nans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod\nif x==0:\n\tprint(\"0\")\nelse:\n\tprint(ans)","output":"logn"},{"instruction":"def solve(r, g, b, rs, gs, bs):\n    rs.sort(reverse=True)\n    gs.sort(reverse=True)\n    bs.sort(reverse=True)\n    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n    sol = 0\n    for ri in range(r+1):\n        for gi in range(g+1):\n            for bi in range(b+1):\n                if ri < r and gi < g:\n                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])\n                if ri < r and bi < b:\n                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])\n                if gi < g and bi < b:\n                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])\n                sol = max(sol, dp[ri][gi][bi])\n    return sol\n\nr, g, b = map(int, input().split())\nrs = list(map(int, input().split()))\ngs = list(map(int, input().split()))\nbs = list(map(int, input().split()))\nprint(solve(r, g, b, rs, gs, bs))","output":"cubic"},{"instruction":"n, s = int(input()), input() * 2\n\nh = s.count('H') \/\/ 2\n\nprint(h - max(s[i:i + h].count('H') for i in range(n)))","output":"linear"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\nn=ri()\na=ris()\nfreq=Counter(a)\nans=0\nfor x in freq:\n  for i in range(32):\n    c=(1<<i)-x\n    if c not in freq:\n      continue\n    if c==x and freq[x]==1:\n      continue\n    break\n  else:\n    ans+=freq[x]\n\nprint(ans)","output":"nlogn"},{"instruction":"class Solution:\n    def lengthOfLIS(self, nums):\n        n = len(nums)\n        memo = [[-1] * (n + 1) for _ in range(n)]\n\n        def dfs(i, j):\n            if i == n:\n                return 0\n            if memo[i][j + 1] != -1:\n                return memo[i][j + 1]\n\n            LIS = dfs(i + 1, j)\n\n            if j == -1 or nums[j] < nums[i]:\n                LIS = max(LIS, 1 + dfs(i + 1, i))\n\n            memo[i][j + 1] = LIS\n            return LIS\n\n        return dfs(0, -1)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nR,G,B = map(int,input().split())\n\nr = list(map(int,input().split()))\ng = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\nr = [0] + r\ng = [0] + g\nb = [0] + b\nR += 1\nG += 1\nB += 1\ndp = [[[0]*B for _ in range(G)] for __ in range(R)]\n\nres = 0\n\nfor i in range(R):\n    for j in range(G):\n        for k in range(B):\n\n            tmp = 0\n            if i > 0 and j > 0:\n                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])\n            if i > 0 and k > 0:\n                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])\n            if j > 0 and k > 0:\n                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])\n            dp[i][j][k] = tmp\n            res = max(res,tmp)\n\nprint(res)","output":"cubic"},{"instruction":"n = int(input())\nm = ''.join(set(list(str(n))))\nif m == '47' or m == '74' or m == '4' or m == '7':\n  print('YES')\nelse:\n  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:\n    print('YES')\n  else:\n    print(\"NO\")","output":"constant"},{"instruction":"from math import *\nk,n,s,p = map(int,input().split())\nsheetsforone = ceil(n\/s)\nsheetsfork = sheetsforone*k\npacks = ceil(sheetsfork\/p)\nprint(int(packs))","output":"constant"},{"instruction":"a = int(input())\nprint((a \/\/ 2) * 3)","output":"constant"},{"instruction":"import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\nfrom itertools import permutations\n\nI=sys.stdin.readline\n\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\ndef ncr(n, r, p):\n\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef valid(row,col,rows,cols,rcross,lcross):\n \treturn rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0\n\ndef div(n):\n\tif n==1:\n\t\treturn 1\n\tcnt=2\n\tfor i in range(2,int(n**.5)+1):\n\t\tif n%i==0:\n\t\t\tif i!=n\/\/i:\n\t\t\t\tcnt+=2\n\t\t\telse:\n\t\t\t\tcnt+=1\n\treturn cnt\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\t\tflag=True\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\tflag=False\n\t\t\t\tbreak\n\t\treturn flag\n\ndef s(b):\n\tans=[]\n\twhile b>0:\n\t\ttmp=b%10\n\t\tans.append(tmp)\n\t\tb=b\/\/10\n\treturn ans\n\ndef main():\n\tn,k=mi()\n\tarr=[]\n\tfor _ in range(n):\n\t\tx,y=mi()\n\t\tarr.append((x,y))\n\n\tarr=sorted(arr,key=lambda x: x[0],reverse=True)\n\n\tfor i in range(n-1):\n\t\tfor j in range(i+1,n):\n\t\t\tif arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:\n\t\t\t\tarr[i],arr[j]=arr[j],arr[i]\n\n\tcnt=arr.count(arr[k-1])\n\tprint(cnt)\n\nif __name__ == '__main__':\n\tmain()","output":"nlogn"},{"instruction":"import os\nfrom sys import stdin\nfrom math import inf\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef solve(tc):\n    N, M, K = map(int, stdin.readline().split())\n\n    wx = [[] for j in range(N)]\n    for i in range(N):\n        wx[i] = list(map(int, stdin.readline().split()))\n\n    wy = [[] for i in range(N-1)]\n    for i in range(N-1):\n        wy[i] = list(map(int, stdin.readline().split()))\n\n    if K & 1:\n        for i in range(N):\n            for j in range(M):\n                print(-1, end=' ')\n            print()\n        return\n\n    mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)]\n\n    half = K \/\/ 2\n    for kk in range(1, half+1):\n        for yy in range(N):\n            for xx in range(M):\n                mem[kk][yy][xx] = inf\n\n                for d in range(4):\n                    y = yy + dy[d]\n                    x = xx + dx[d]\n\n                    if y < 0 or y >= N or x < 0 or x >= M:\n                        continue\n\n                    if d == 0:\n                        mem[kk][yy][xx] = min(\n                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2)\n                    elif d == 1:\n                        mem[kk][yy][xx] = min(\n                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2)\n                    elif d == 2:\n                        mem[kk][yy][xx] = min(\n                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2)\n                    else:\n                        mem[kk][yy][xx] = min(\n                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2)\n\n    for yy in range(N):\n        for xx in range(M):\n            print(mem[half][yy][xx], end=' ')\n        print()\n\ntcs = 1\n\ntc = 1\nwhile tc <= tcs:\n    solve(tc)\n    tc += 1","output":"cubic"},{"instruction":"from sys import stdin\ninput=stdin.readline\ndef check(mid,a,limit):\n\tres=[]\n\ts=0\n\tfor r,t,id in a:\n\t\tif r>=mid and t+s<=limit:\n\t\t\tres.append(id+1)\n\t\t\ts+=t\n\t\telif t+s>limit:\n\t\t\tbreak\n\t\tif len(res)==mid:\n\t\t\tbreak\n\n\treturn res\n\ndef f(a,limit):\n\ta.sort(key=lambda s:s[1])\n\tans=None\n\tlo=0\n\thi=10**9\n\twhile lo<=hi:\n\t\tmid=(lo+hi)\/\/2\n\t\tres=check(mid,a,limit)\n\t\tif len(res)>=mid:\n\t\t\tlo=mid+1\n\t\t\tans=(res,mid)\n\t\telse:\n\t\t\thi=mid-1\n\tprint(ans[1])\n\tprint(ans[1])\n\tprint(*ans[0])\n\nn,limit=map(int,input().strip().split())\nq=[]\nfor i in range(n):\n\tx,y=map(int,input().strip().split())\n\tq.append((x,y,i))\nf(q,limit)","output":"nlogn"},{"instruction":"one = list(map(int, input().split()))\ntwo = list(map(int, input().split()))\n\none_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))\ntwo_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))\n\nones = [one_[0], one_[2], one_[3], one_[1]]\ntwos = [two_[1], two_[3], two_[2], two_[0]]\n\nL, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]\n\ndef in_one(point):\n    x, y = point\n\n    return L <= x <= R and D <= y <= U\n\ndef in_two(point):\n    x_0, y_0 = twos[0]\n\n    def U_p(x_):\n        return x_ + y_0 - x_0\n\n    def D_m(x_):\n        return -x_ + y_0 + x_0\n\n    x_1, y_1 = twos[2]\n\n    def U_m(x_):\n        return -x_ + y_1 + x_1\n\n    def D_p(x_):\n        return x_ + y_1 - x_1\n\n    x, y = point\n\n    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)\n\nc_one = ((L + R) \/ 2, (U + D) \/ 2)\nc_two = ((twos[0][0] + twos[2][0]) \/ 2, (twos[1][1] + twos[3][1]) \/ 2)\n\nones.append(c_one)\ntwos.append(c_two)\n\nfor p in ones:\n    if in_two(p):\n        print('YES')\n        exit()\n\nfor p in twos:\n    if in_one(p):\n        print('YES')\n        exit()\n\nprint('NO')","output":"constant"},{"instruction":"x,y=map(int,input().strip().split())\nif(abs(x-y)<2):\n    print(-1)\nelse:\n    k=[]\n    for i in range(x,y+1):\n        if(i%2==0):\n            k.append(i)\n            if(i+1<y):\n                k.append(i+1)\n                k.append(i+2)\n                break\n    if(len(k)==3):\n        print(\" \".join(str(t) for t in k))\n    else:\n        print(-1)","output":"constant"},{"instruction":"get = lambda : list(map(int, input().split(' ')))\nn, m, k = get()\nrlist, clist = [], []\nfor _ in range(n):\n    rlist.append(get())\nfor _ in range(n-1):\n    clist.append(get())\n\ndway = [[0,1],[0,-1],[1,0],[-1,0]]\nif k%2:\n    res = [[-1]*m for _ in range(n)]\nelse:\n    flist = [[0]*m for _ in range(n)]\n    for _ in range(k\/\/2):\n        glist = [[10**9]*m for _ in range(n)]\n        for dx, dy in dway:\n            klist = rlist if dx == 0 else clist\n            for x in range(n):\n                for y in range(m):\n                    xx, yy = x+dx, y+dy\n                    if not (0<=xx<n) or not (0<=yy<m):\n                        continue\n                    tx = xx if dx==-1 else x\n                    ty = yy if dy==-1 else y\n                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)\n        flist = glist\n    res = flist\nfor row in res:\n    print(' '.join(map(str, row)))","output":"cubic"},{"instruction":"from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\n\nfor _ in range(1):\n    n,m=lst()\n    a=lst()\n    a=[0]+a+[m]\n    n=len(a)\n    suf=[0]*n\n    suf[n-2]=abs(a[-2]-a[-1])\n    for i in range(n-3, -1, -1):\n        suf[i]=a[i+1]-a[i]+suf[i+2]\n    ans=suf[0]\n    cost=0\n    for i in range(1, n):\n        if i&1:\n            v=a[i]-1-a[i-1]\n            if v!=0:ans=max(ans, cost+v+suf[i])\n            cost+=a[i]-a[i-1]\n        else:\n            v=a[i-1]+1\n            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))\n    print(ans)","output":"linear"},{"instruction":"n,m=map(int,input().split())\nl=[]\nfor i in range(n):\n    s=input()\n    l.append(s)\nminX,minY,maxX,maxY=n,m,0,0\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='B':\n            minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j)\nprint((minX+maxX)\/\/2+1,(minY+maxY)\/\/2+1)","output":"quadratic"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\nn = INT()\nd = {}\nsm = 0\n\nfor i in range(n):\n    indx , y = MAP()\n    d[indx] = [1 , [y]]\n\nm = INT()\nfor i in range(m):\n    indx , y = MAP()\n    if indx in d :\n        d[indx][0] += 1\n        d[indx][1].append(y)\n    else:\n        d[indx] = [1 , [y]]\n\nfor i in d :\n    if d[i][0] == 1 :\n        sm += d[i][1][0]\n    else:\n        sm += max(d[i][1])\n\nprint(sm)","output":"nlogn"},{"instruction":"class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Vector:\n\n    def __init__(self, start, end):\n        self.x = end.x - start.x\n        self.y = end.y - start.y\n\n    def mult(self, a):\n        return self.y * a.x - self.x * a.y\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append(Point(x, y))\n\nif n <= 3:\n    print('YES')\n    exit()\n\ndef onLine(points):\n    n = len(points)\n    if n < 3:\n        return True\n    a = Vector(points[0], points[1])\n    for i in range(2, n):\n        b = Vector(points[0], points[i])\n        if a.mult(b) != 0:\n            return False\n    return True\n\ntmp = [points[0], points[1]]\noth = []\nfor i in range(2, n):\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[0], points[2]]\noth = []\nfor i in range(1, n):\n    if i == 2:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[1], points[2]]\noth = []\nfor i in range(0, n):\n    if i == 2 or i == 1:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\nprint('NO')","output":"nlogn"},{"instruction":"from sys import stdin, stdout\nfrom math import sin, tan, cos\n\nn, m, k, l = map(int, stdin.readline().split())\n\nlb, rb = 0, n \/\/ m + 1\nwhile rb - lb > 1:\n    mid = (lb + rb) >> 1\n\n    if mid * m - k >= l:\n        rb = mid\n    else:\n        lb = mid\n\nif lb != n \/\/ m:\n    stdout.write(str(rb))\nelse:\n    stdout.write('-1')","output":"logn"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nprint('\\n'.join(map(lambda x: ''.join(map(str, x)), r)))","output":"quadratic"},{"instruction":"import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\ndef slv():\n    n, m, k = map(int, input().split())\n    if k % 2 != 0:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n\n    k \/\/= 2\n\n    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]\n    G = [[[] for i in range(m)] for j in range(n)]\n    for i in range(n):\n        C = list(map(int,input().split()))\n        for j in range(m - 1):\n            cost = C[j]\n            G[i][j].append((cost,i,j + 1))\n            G[i][j + 1] .append((cost,i,j))\n\n    for i in range(n - 1):\n        C = list(map(int,input().split()))\n        for j in range(m):\n            cost = C[j]\n            G[i][j].append((cost,i + 1,j))\n            G[i+1][j].append((cost,i,j))\n\n    for p in range(1,k + 1):\n        for u in range(n):\n            for v in range(m):\n                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])\n    for i in range(n):\n        ans = [DP[k][i][j]*2 for j in range(m)]\n        print(*ans)\n    return\ndef main():\n    t = 1\n    for i in range(t):\n        slv()\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n=int(raw_input())\n\nans=[]\np=1\nfin=n\nwhile len(ans)<n-1:\n\tfor i in range(fin-(n\/(2**p))):\n\t\tans.append(2**(p-1))\n\t\tfin-=1\n\tp+=1\n\nif 2**(p-2) + 2**(p-1) <=n:\n\tans.append(2**(p-1) + 2**(p-2))\nelse:\n\tans.append(2**(p-1))\n\ns=\" \".join(str(x) for x in ans)\n\nprint(s)","output":"nlogn"},{"instruction":"rgb = 'RGB' * 1000\nfor q in range(int(input())):\n    n, k = [int(s) for s in input().split()]\n    s = input()\n    ans = 3000\n    for w in range(3):\n        for e in range(n - k + 1):\n            temp = 0\n            for i in range(k):\n                if s[e + i] != rgb[w + i]:\n                    temp += 1\n            ans = min(ans, temp)\n    print(ans)","output":"quadratic"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0.0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nget_bit = lambda x, i: (x >> i) & 1\n\nn = int(input())\na, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1\n\nif n == 1:\n    exit(print(1))\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        masks[big ^ (1 << j)] += a[i][j]\n        masks[big ^ (1 << i)] += a[j][i]\n\nfor _ in range(2, n):\n    tem = dict()\n    for msk in masks:\n        for bit in range(18):\n            if get_bit(msk, bit):\n                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]\n    masks = tem\n\nsu = sum(masks.values())\nprint(*[masks[1 << i] \/ su for i in range(n)])","output":"np"},{"instruction":"from sys import stdin\n\ndef solve(x: int) -> bool:\n    global ans\n    dp = {}\n    for i in range(n):\n        temp = 0\n        for j in range(m):\n            if a[i][j] >= x:\n                temp = temp | (1 << j)\n        dp[temp] = i\n    for aa, bb in dp.items():\n        for cc, dd in dp.items():\n            if aa | cc == 2 ** m - 1:\n                ans = (bb + 1, dd + 1)\n                return True\n    return False\n\nans = (-1, -1)\nn, m = map(int, stdin.readline().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, stdin.readline().split())))\nl, r = 0, 10 ** 9\nwhile l <= r:\n    mid = (l + r) \/\/ 2\n    if solve(mid):\n        l = mid + 1\n    else:\n        r = mid - 1\nprint(*ans)","output":"np"},{"instruction":"import sys\n\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef rinput():   return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\nn=iinput()\nprint(3*n\/\/2)","output":"constant"},{"instruction":"n=int(input())\nl=[]\nnn=n\nwhile n :\n    n-=1\n    s=input()\n    l.append([len(s),s])\nl.sort()\nch=1\ni=1\n\nans=[]\nfor i in range(nn-1):\n    if l[i][1] not in l[i+1][1]:\n        ch=0\n        break\n    else:\n\n        ans.append(l[i][1])\n\nif ch:\n    ans.append(l[nn-1][1])\n    print(\"YES\")\n\n    print(*ans, sep = \"\\n\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"def s(k):\n\tif k % 2 == 0:\n\t\treturn k \/\/ 2\n\telse:\n\t\treturn - (k + 1) \/\/ 2\n\nfor i in range(int(input())):\n\tl, r = map(int, input().split())\n\tprint(s(r) - s(l - 1))","output":"constant"},{"instruction":"x, y, z, t1, t2, t3 = map(int, raw_input().split())\nelev = t3*3 + t2*(abs(z-x) + abs(x-y))\nstairs = t1*abs(x - y)\nif elev <= stairs:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"n, k = map(int, input().strip().split())\ndata = map(int, input().strip().split())\nsol = []\nmapping = [(-1,1000)]*256\nfor x in data:\n    if mapping[x][0] == -1:\n        for i in range(max(x-k+1,0), x+1):\n            if mapping[i][0] == -1:\n                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:\n                    p = mapping[i-1][1]+1\n                    for j in range(i, x+1):\n                        mapping[j] = (mapping[i-1][0], p)\n                        p += 1\n                else:\n                    p = 1\n                    for j in range(i, x+1):\n                        mapping[j] = (i, p)\n                        p += 1\n                break\n    sol.append(mapping[x][0])\nprint(' '.join(map(str, sol)))","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\nn = int(input().strip())\na = [int(x) for x in input().strip().split()]\ndp = [[0]*n for i in range(n)]\nfor i in range(n):\n    dp[i][i] = [a[i], 1]\nfor i in range(1, n):\n    for j in range(n-i):\n        v, c = -1, i+1\n        for k in range(i):\n            if dp[j][j+k][0]!=-1 and dp[j][j+k][0] == dp[j+k+1][j+i][0]:\n                v,c = dp[j][j+k][0]+1, 1\n                break\n            else:\n                v, c = -1, min(c, dp[j][j+k][1] + dp[j+k+1][j+i][1])\n        dp[j][j+i] = [v, c]\nprint(dp[0][-1][1])","output":"cubic"},{"instruction":"def f(k):\n    res = 1\n    a = 2\n    while k:\n        if k % 2 == 1:\n            res *= a\n            k -= 1\n        else:\n            a *= a\n            k \/\/= 2\n        res = res % (1000000007)\n        a = a % (1000000007)\n    return res\n\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelif k == 0:\n    print((n * 2) % 1000000007)\nelse:\n    first = (2 * n - 1) % 1000000007\n    first *= f(k)\n    first = (first + 1) % 1000000007\n    print(first)","output":"logn"},{"instruction":"from itertools import combinations\n\nn, l, r, x = map(int, input().split())\na = list(map(int, input().split()))\n\narr = []\n\nfor i in range(2, n+1):\n    ar = combinations(a, i)\n    for j in ar:\n        arr += [(list(j))]\n\ncount = 0\nfor i in arr:\n    dif = max(i) - min(i)\n    total = sum(i)\n    if dif >= x and (total >= l and total <= r):\n        count +=1\n\nprint(count)","output":"np"},{"instruction":"import sys\nfrom math import floor, ceil\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\n\nprint(ceil((n*2)\/k) + ceil((n*5)\/k) + ceil((n*8)\/k))","output":"constant"},{"instruction":"print(\"? 0 0\")\nans00 = input()\nxr = 0\na = 0\nb = 0\ncb = 2 ** 29\nwhile cb:\n    print(\"?\", xr + cb, cb)\n    ans11 = input()\n    print(\"?\", xr, cb)\n    if ans11 == ans00:\n        ans01 = input()\n        if ans01 == '1':\n            a += cb\n            b += cb\n    else:\n        ans00 = input()\n        if ans11 == '1':\n            b += cb\n        else:\n            a += cb\n        xr += cb\n    cb \/\/= 2\nprint(\"!\", a, b)","output":"logn"},{"instruction":"from itertools import product\nimport itertools\n\nimport sys\nimport heapq\nfrom collections import deque\nMOD=1000000000007\n\ndef find(parent,i):\n\n    if parent[i] != i:\n        parent[i]=find(parent,parent[i])\n    return parent[i]\n\ndef union(parent,rank,xx,yy):\n    x=find(parent,xx)\n    y=find(parent,yy)\n    if rank[x]>rank[y]:\n        parent[y]=x\n    elif rank[y]>rank[x]:\n        parent[x]=y\n    else:\n        parent[y]=x\n        rank[x]+=1\nans=0\n\nx=0\ny=0\n\nMAX=1000000000\nN,M,K=list(map(int,sys.stdin.readline().strip().split()))\nW=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)]\nfor i in range(N):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M-1):\n        W[i][j][1]=l[j]\n        W[i][j+1][0]=l[j]\nfor i in range(N-1):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M):\n\n        W[i][j][3]=l[j]\n        W[i+1][j][2]=l[j]\n\nif K%2==1:\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(\"-1\")\n        print(\" \".join(ans))\nelse:\n\n    K=K\/\/2\n    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]\n    for kt in range(1,K+1):\n\n        dl=((0,-1),(0,1),(-1,0),(1,0))\n        for i in range(N):\n            for j in range(M):\n                ans=MAX\n                for t in range(4):\n\n                    ii,jj=dl[t]\n\n                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:\n                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)\n\n                dp[kt][i][j]=ans\n\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(str(dp[-1][i][j]))\n        print(\" \".join(ans))","output":"cubic"},{"instruction":"import sys\n\ndef read_input(input_path=None):\n    if input_path is None:\n        f = sys.stdin\n    else:\n        f = open(input_path, 'r')\n\n    n, m = map(int, f.readline().split())\n\n    return n, m\n\ndef sol(n, m):\n    v = [0 for _ in range(n+1)]\n    left, right = 1, n\n    for i in range(1, n + 1):\n        if n - i - 1 <= 0:\n            pw = 1\n        else:\n            pw = 1 << (n - i - 1)\n\n        if m <= pw:\n            v[left] = i\n            left += 1\n        else:\n            v[right] = i\n            right -= 1\n            m -= pw\n    return [' '.join(map(str, v[1:]))]\n\ndef solve(input_path=None):\n    return sol(*read_input(input_path))\n\ndef main():\n    for line in sol(*read_input()):\n        print(f\"{line}\")\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n,k = map(int, input().split())\ns = input()\nl = []\nfor i in s:\n    a = ord(i)-96\n    if a not in l:\n        l.append(a)\nl.sort()\nc = l[0]\na = 1\nb = l[0]\nfor i in range(1,len(l)):\n    if a==k:\n        break\n    if (l[i]-b)>1:\n        a += 1\n        c += l[i]\n        b = l[i]\nif a<k:\n    print(-1)\nelse:\n    print(c)","output":"linear"},{"instruction":"n = int(input())\nmod = 10**9+7\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(n):\n    nx = [0]*(n+1)\n    s = str(input())\n    if s == 'f':\n        nx[0] = 0\n        for j in range(1, n+1):\n            nx[j] = dp[j-1]\n            nx[j] %= mod\n    else:\n        nx[n] = dp[n]\n        for j in reversed(range(n)):\n            nx[j] = nx[j+1]\n            nx[j] += dp[j]\n            nx[j] %= mod\n    if i != n-1:\n        dp = nx\nprint(sum(dp)%mod)","output":"quadratic"},{"instruction":"n,m = map(int,input().split())\nx = input().split()\nt = input().split()\nr = [0]*n\nd = [0]*m\ncountr = 0\ncountd = 0\nfor i in range(n+m):\n    if int(t[i]) == 1:\n        d[countd] = int(x[i])\n        countd += 1\n    else:\n        r[countr] = int(x[i])\n        countr += 1\ncurrent = 0\ncount = [0]*m\nfor i in range(n):\n    while current < m-1:\n        if d[current+1] >= r[i]:\n            break\n        current += 1\n    if current == m-1:\n        count[m-1] += (n-i)\n        break\n    if 2*r[i] <= (d[current]+d[current+1]):\n        count[current] += 1\n    else:\n        count[current+1] += 1\ns = \"\"\nfor i in range(m):\n    s += str(count[i])+\" \"\nprint(s[:-1])","output":"nlogn"},{"instruction":"import math\n\nn,m,kk=[int(x) for x in input().split()]\nright,down=[],[]\nfor i in range(n) :\n\ta=[int(x) for x in input().split()]\n\tright.append(a)\n\nfor i in range(n-1) :\n\ta=[int(x) for x in input().split()]\n\tdown.append(a)\n\ndp,dpCopy=[],[]\nfor i in range(n) :\n\tli,li1=[],[]\n\tfor j in range(m) :\n\t\tli.append(math.inf)\n\t\tli1.append(math.inf)\n\tdp.append(li)\n\tdpCopy.append(li1)\n\nfor i in range(1,(kk\/\/2)+1) :\n\n\tfor j in range(n) :\n\t\tfor k in range(m) :\n\t\t\tif i==1 :\n\t\t\t\tif j==0 :\n\t\t\t\t\tif k==0 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],down[j][k],right[j][k])\n\t\t\t\t\telif k==m-1 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])\n\t\t\t\t\telse :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])\n\t\t\t\telif j==n-1 :\n\t\t\t\t\tif k==0 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])\n\t\t\t\t\telif k==m-1 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])\n\t\t\t\t\telse :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])\n\t\t\t\telif k==0 :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])\n\n\t\t\t\tcontinue\n\n\t\t\tif j==0 :\n\t\t\t\tif k==0 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])\n\t\t\telif j==n-1 :\n\t\t\t\tif k==0 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])\n\t\t\telif k==0 :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])\n\t\t\telif k==m-1 :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])\n\t\t\telse :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])\n\n\tfor ii in range(n) :\n\t\tfor jj in range(m) :\n\t\t\tdpCopy[ii][jj]=dp[ii][jj]\n\nif kk%2==1 :\n\tfor i in range(n) :\n\t\tfor j in range(m) :\n\t\t\tprint(-1,end=' ')\n\t\tprint()\n\texit(0)\n\nfor i in range(n) :\n\tfor j in range(m) :\n\t\tprint(2*dp[i][j],end=' ')\n\tprint()","output":"cubic"},{"instruction":"n,r=list(map(int,input().split()))\nx=list(map(int,input().split()))\ny=[r]*n\nfor i in range(1,n):\n    for j in range(i):\n        d=abs(x[i]-x[j])\n        if d<=2*r:\n            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))\nprint(*y)","output":"quadratic"},{"instruction":"import math\n\nn=int(input())\n\ns2=input()\ns2=list(s2)\ns=[]\nfor i in range(n):\n    if s2[i]=='0':\n        continue\n    else:\n        s.append(int(s2[i]))\ns1=sum(s)\nn=len(s)\nl=[]\nfor i in range(2,n+1):\n    if s1%i==0:\n        l.append(s1\/\/i)\nf=0\nif len(s)==0:\n    f=1\nfor i in range(len(l)):\n    c=0\n    if f==1:\n        break\n    for j in range(n):\n        c+=s[j]\n        if c==l[i]:\n            c=0\n            if j==n-1:\n                f=1\n        elif c<l[i]:\n            c=c\n        else:\n            break\nif f==0:\n    print('NO')\nelse:\n    print('YES')","output":"quadratic"},{"instruction":"n = int(input())\ns = list(str(input()))\nt = list(str(input()))\n\nfrom collections import Counter\ncs = Counter(s)\nct = Counter(t)\nif cs != ct:\n    print(-1)\n    exit()\n\nxs = [[] for _ in range(26)]\nxt = [[] for _ in range(26)]\nfor i in range(n):\n    j = ord(s[i])-ord('a')\n    xs[j].append(i)\n\nfor i in range(n):\n    j = ord(t[i])-ord('a')\n    xt[j].append(i)\n\nx = [-1]*n\nfor i in range(26):\n    for j, k in zip(xs[i], xt[i]):\n        x[j] = k\n\nans = []\nfor i in range(n):\n    for j in reversed(range(i+1, n)):\n        if x[j-1] > x[j]:\n            x[j-1], x[j] = x[j], x[j-1]\n            ans.append(j)\nprint(len(ans))\nprint(*ans)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nrr, gg, bb = map(int, input().split())\ninf = 114514\nr = list(map(int, input().split())) + [inf]\ng = list(map(int, input().split())) + [inf]\nb = list(map(int, input().split())) + [inf]\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\ndp = []\nfor _ in range(rr + 1):\n    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])\nans = 0\nfor i in range(rr + 1):\n    ri = r[i]\n    for j in range(gg + 1):\n        gj = g[j]\n        for k in range(bb + 1):\n            bk = b[k]\n            if (i + j + k) % 2:\n                continue\n            dpijk = 0\n            if i > 0 and j > 0:\n                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)\n            if j > 0 and k > 0:\n                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)\n            if k > 0 and i > 0:\n                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)\n            dp[i][j][k] = dpijk\n            if ans < dpijk:\n                ans = dpijk\nprint(ans)","output":"cubic"},{"instruction":"import random\n\nn = int(input())\n\nvec = [list(map(int, input().rstrip('\\n').split(' '))) for i in range(n)]\n\nbo = 10**6\n\ncoef = [[1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],\n[1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],\n[0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]]\n\ndef lv(x):\n\treturn (x[0]**2 + x[1]**2)**0.5\n\nif n == 1:\n\tres = [1]\nelif n == 2:\n\tif vec[0][0]*vec[1][0] + vec[0][1]*vec[1][1] <= 0:\n\t\tres = [1, 1]\n\telse:\n\t\tres = [1, -1]\nelse:\n\tres = [0 for i in range(n)]\n\tfer = [[vec[0], vec[1], vec[2]],[[0], [1], [2]]]\n\tfor l in range(len(vec)-2):\n\t\tfor j in coef:\n\t\t\tder = [0, 0]\n\t\t\tder[0] = j[0]*fer[0][0][0] + j[1]*fer[0][1][0] + j[2]*fer[0][2][0]\n\t\t\tder[1] = j[0]*fer[0][0][1] + j[1]*fer[0][1][1] + j[2]*fer[0][2][1]\n\t\t\tif lv(der) <= bo:\n\t\t\t\tner = []\n\t\t\t\tfor i in range(3):\n\t\t\t\t\tif j[i] != 0:\n\t\t\t\t\t\tner.append(i)\n\t\t\t\tif len(fer[1][ner[0]]) == 1:\n\t\t\t\t\tres[fer[1][ner[0]][0]] = j[ner[0]]\n\t\t\t\telif j[ner[0]] == -1:\n\t\t\t\t\tfor k in fer[1][ner[0]]:\n\t\t\t\t\t\tres[k] *= -1\n\t\t\t\tfer[0][ner[0]] = der\n\t\t\t\tfer[1][ner[0]] += fer[1][ner[1]]\n\t\t\t\tif len(fer[1][ner[1]]) == 1:\n\t\t\t\t\tres[fer[1][ner[1]][0]] = j[ner[1]]\n\t\t\t\telif j[ner[1]] == -1:\n\t\t\t\t\tfor k in fer[1][ner[1]]:\n\t\t\t\t\t\tres[k] *= -1\n\t\t\t\tif l == len(vec)-3:\n\t\t\t\t\tdel fer[0][ner[1]]\n\t\t\t\t\tdel fer[1][ner[1]]\n\t\t\t\telse:\n\t\t\t\t\tfer[0][ner[1]] = vec[3+l]\n\t\t\t\t\tfer[1][ner[1]] = [3+l]\n\t\t\t\tbreak\n\tif fer[0][0][0]*fer[0][1][0] + fer[0][0][1]*fer[0][1][1] <= 0:\n\t\tif len(fer[1][0]) == 1:\n\t\t\tres[fer[1][0][0]] = 1\n\t\tif len(fer[1][1]) == 1:\n\t\t\tres[fer[1][1][0]] = 1\n\telse:\n\t\tif len(fer[1][0]) == 1:\n\t\t\tres[fer[1][0][0]] = -1\n\t\telif len(fer[1][1]) == 1:\n\t\t\tres[fer[1][1][0]] = -1\n\t\telse:\n\t\t\tfor k in fer[1][0]:\n\t\t\t\tres[k] *= -1\nres1 = ''\nfor i in res:\n\tres1 += str(i)+' '\nres1 = res1[:-1]\nprint(res1)","output":"nlogn"},{"instruction":"x = int('00001111', 2)\ny = int('00110011', 2)\nz = int('01010101', 2)\nE = set()\nT = set()\nF = {('x', x), ('y', y), ('z', z)}\nprv = (set(), set(), set())\nfam = 2 ** 8\ntmpl = '\nans = [tmpl] * fam\ndef cmpr(E):\n    global ans\n    ans = [tmpl] * fam\n    for e in E:\n        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:\n            ans[e[1]] = e[0]\n    return set((j, i) for i, j in enumerate(ans) if j != tmpl)\nwhile prv != (E, T, F):\n    prv = E.copy(), T.copy(), F.copy()\n    for f in prv[2]:\n        F.add(('!' + f[0], ~f[1] & (fam - 1)))\n        T.add(f)\n        for t in prv[1]:\n            T.add((t[0] + '&' + f[0], t[1] & f[1]))\n    for t in prv[1]:\n        E.add(t)\n    for e in prv[0]:\n        if e not in F:\n            F.add(('(' + e[0] + ')', e[1]))\n        for t in prv[1]:\n            E.add((e[0] + '|' + t[0], e[1] | t[1]))\n    E, T, F = cmpr(E), cmpr(T), cmpr(F)\ncmpr(E)\nn = int(input())\nfor i in range(n):\n\tprint(ans[int(input(), 2)])","output":"quadratic"},{"instruction":"fast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nz,zz=input,lambda:list(map(int,z().split()))\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom re import *\nfrom sys import *\nfrom math import *\nfrom heapq import *\nfrom queue import *\nfrom bisect import *\nfrom string import *\nfrom itertools import *\nfrom collections import *\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom collections import Counter as cc\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef output(answer):stdout.write(str(answer))\n\ns=fast()\nans=s.replace('1','')+'2'\nt=ans.find('2')\nprint(ans[:t]+'1'*s.count('1')+ans[t:-1])","output":"linear"},{"instruction":"n, k = map(int, input().split())\nps = list(map(int, input().split()))\nif k == 1:\n    print(' '.join([str(i) for i in ps]))\n    exit()\n\ng = [None for i in range(256)]\nf = [None for i in range(256)]\nans = []\nfor i in range(n):\n    p = ps[i]\n    if g[p] is not None:\n        ans.append(g[p])\n        f[p] = 1\n    else:\n        gb= 0\n        for j in range(1, k):\n            ind = p - j\n            if f[ind] is not None:\n                gb = ind +1\n                break\n            if ind <= 0:\n                break\n            if j == k-1:\n                gb = ind\n        ans.append(gb)\n        for j in range(k):\n            if gb+j >= 256:\n                break\n            if f[gb + j] is None:\n                g[gb+j] = gb\n            else:\n                break\n        f[gb] = 1\n        f[p] = 1\nprint(' '.join([str(i) for i in ans]))","output":"quadratic"},{"instruction":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    q = I()\n    rr = []\n\n    def f(a,b,c,d):\n        if a > c or b > d:\n            return (0,0)\n        sa = c-a + 1\n        sb = d-b + 1\n        g = h = (sa * sb) \/\/ 2\n        if (sa*sb) % 2 == 1:\n            g += 1\n\n        if (a+b) % 2 == 0:\n            return (g,h)\n        return (h,g)\n\n    def fa(a):\n        return f(a[0],a[1],a[2],a[3])\n\n    for _ in range(q):\n        n,m = LI()\n        wa = LI()\n        ba = LI()\n        wc,bc = f(1,1,n,m)\n        w1,b1 = fa(wa)\n        w2,b2 = fa(ba)\n        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))\n\n        wc += b1\n        bc -= b1\n        wc -= w2\n        bc += w2\n        wc -= b3\n        bc += b3\n        rr.append('{} {}'.format(wc,bc))\n\n    return \"\\n\".join(map(str,rr))\n\nprint(main())","output":"constant"},{"instruction":"import math\nimport heapq,bisect\nimport sys\nfrom collections import deque,defaultdict\nfrom fractions import Fraction\nmod=10**9+7\nmod1=998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree1:\n    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por=1\n    for i in range(len(l)):\n        por*=l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] <= key):\n\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c=0\n    while(n>0):\n        n\/\/=10\n        c+=1\n    return c\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\ndef findmin(h,n):\n    n.sort()\n    h=int(h)\n    ans='-1'\n\n    for i in n:\n        if int(i)>h:\n            break\n        ans=i\n\n    return ans\nn=list(input())\nn1=list(input())\nif len(n)<len(n1):\n    n.sort(reverse=True)\n    print(*n,sep='')\n    sys.exit()\nn.sort()\nans=\"\"\nf=0\nfor i in range(len(n)):\n    t=i-1\n    c=0\n    r = findmin(n1[i], n)\n    if r=='-1':\n        while(r=='-1'):\n            n.append(ans[-c-1])\n            r=findmin(int(n1[t])-1,n)\n            t-=1\n            c+=1\n        ans=ans[:len(ans)-c]\n        ans+=r\n        n.remove(r)\n        f=1\n        break\n    n.remove(r)\n    if r==n1[i]:\n        ans+=r\n        continue\n    else:\n        ans+=r\n        f=1\n        break\nif f==1:\n    n.sort(reverse=True)\n    for i in n:\n        ans+=i\nprint(ans)","output":"cubic"},{"instruction":"import sys\ndef countR(ip):\n    c=0\n    for i in ip:\n        if(i=='R'):\n            c+=1\n    return c\n\ndef countB(ip):\n    c=0\n    for i in ip:\n        if(i=='B'):\n            c+=1\n    return c\n\ndef countG(ip):\n    c=0\n    for i in ip:\n        if(i=='G'):\n            c+=1\n    return c\n\nt=int(sys.stdin.readline())\nx='RGB'*680\ny='GBR'*680\nz='BRG'*680\nfor i in range(t):\n    n,k=list(map(int,sys.stdin.readline().strip().split()))\n    a=sys.stdin.readline().strip()\n    xk=x[:k]\n    yk=y[:k]\n    zk=z[:k]\n\n    op=2001\n    for j in range(n-k+1):\n        b=a[j:j+k]\n\n        xd=0\n        yd=0\n        zd=0\n\n        for jj in range(len(b)):\n            if(b[jj]!=xk[jj]):\n                xd+=1\n            if(b[jj]!=yk[jj]):\n                yd+=1\n            if(b[jj]!=zk[jj]):\n                zd+=1\n\n        op=min(op,xd,yd,zd)\n    print(op)","output":"quadratic"},{"instruction":"import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\nsys.setrecursionlimit(2*10**5+10)\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\ndebug = lambda x: sys.stderr.write(x+\"\\n\")\nwritef = lambda x: print(\"{:.12f}\".format(x))\n\ndef zeta_super(val, n):\n\n    out = val[:]\n    for i in range(n):\n        for j in range(1<<n):\n            if not j>>i&1:\n                out[j] += out[j^(1<<i)]\n    return out\n\nn = int(input())\na = list(map(int, input().split()))\nm = max(a).bit_length()\nM = 10**9+7\nv = [0]*(1<<m)\nfor item in a:\n    v[item] += 1\nv2 = [1]\nfor i in range(n+1):\n    v2.append(v2[-1]*2%M)\nnv = zeta_super(v, m)\nans = 0\nfor b in range(1<<m):\n    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(\"1\"))\n    ans %= M\nprint(ans%M)","output":"np"},{"instruction":"def detect_cycle(n,edges):\n        visited = [False]*n\n        stack = []\n        color = [0]*n\n        for v in range(n):\n            if not visited[v]:\n                if dfs_visit(v,edges,visited,stack,color):\n                    return stack\n        return None\n\ndef dfs_visit(v,edges,visited,stack,color):\n        visited[v] = True\n        stack.append(v)\n        color[v] = 1\n        for u in edges[v]:\n            if not visited[u]:\n               if dfs_visit(u,edges,visited,stack,color):\n                   return True\n\n            elif color[u] == 1:\n                stack.append(u)\n                return True\n\n        color[v] = 2\n        stack.pop(stack.index(v))\n        return False\n\nif __name__ == '__main__':\n        n,m = map(int,input().split())\n        edges = [[] for i in range(n)]\n        for _ in range(m):\n            u,v  = map(int,input().split())\n            edges[u - 1].append(v - 1)\n\n        inCycle = detect_cycle(n,edges)\n        if inCycle:\n            possible = False\n            index = inCycle.index(inCycle[-1])\n            inCycle = inCycle[index:]\n            for v in range(len(inCycle) - 1):\n                edges[inCycle[v]].remove(inCycle[v + 1])\n                if detect_cycle(n,edges) is None:\n                    possible = True\n                    break\n                else:\n                    edges[inCycle[v]].append(inCycle[v + 1])\n        else: possible = True\nprint('YES' if possible else 'NO')","output":"quadratic"},{"instruction":"import sys\nfrom math import sqrt, gcd, ceil, log, floor\nfrom bisect import bisect, bisect_left\nfrom collections import defaultdict, Counter, deque\nfrom heapq import heapify, heappush, heappop\ninput = sys.stdin.readline\nread = lambda: list(map(int, input().strip().split()))\n\nMOD = 10**9 + 7\n\ndef main():\n\n\tr, g, b = read()\n\tr_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)\n\tN = 201\n\tdp = [[[-1]*N for i in range(N)]for j in range(N)]\n\n\tdef f(x, y, z):\n\n\t\tif ((x >= r) + (y >= g) + (z >= b)) >= 2:\n\t\t\treturn(0)\n\t\tif dp[x][y][z] != -1:\n\t\t\treturn(dp[x][y][z])\n\t\tmaxi = 0\n\t\tif x < r and y < g:\n\t\t\tmaxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))\n\t\tif z < b and y < g:\n\t\t\tmaxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))\n\t\tif x < r and z < b:\n\t\t\tmaxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))\n\t\tdp[x][y][z] = maxi\n\t\treturn(maxi)\n\tprint(f(0, 0, 0))\n\nif __name__ == \"__main__\":\n\tmain()","output":"cubic"},{"instruction":"import math\nimport random\nimport heapq,bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree1:\n    def __init__(self, data, default=2**51, func=lambda a, b: a & b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: max(a , b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nn=int(input())\nl=list(map(int,input().split()))\ncost=list(map(int,input().split()))\ndp=defaultdict(int)\ndp[0]=0\nse=set([0])\nfor i in range(n):\n    for j in se:\n        k=int(math.gcd(j,l[i]))\n        if dp[k]==0:\n            dp[k]=dp[j]+cost[i]\n        dp[k]=min(dp[k],dp[j]+cost[i])\n    se=set(dp.keys())\nif dp[1]==0:\n    print(-1)\nelse:\n    print(dp[1])","output":"np"},{"instruction":"def solve(a, b):\n    m = max(a, b)\n    n = min(a, b)\n    if n == 0:\n        return 0\n    if m == n:\n        return 1\n    elif m % n == 0:\n        return m \/\/ n\n    k = m \/\/ n\n    return k + solve(n, m - n * k)\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    print(solve(a, b))","output":"constant"},{"instruction":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        A = []\n        for i, num in enumerate(nums):\n            A.append([num, i])\n\n        A.sort()\n        i, j = 0, len(nums) - 1\n        while i < j:\n            cur = A[i][0] + A[j][0]\n            if cur == target:\n                return [min(A[i][1], A[j][1]),\n                        max(A[i][1], A[j][1])]\n            elif cur < target:\n                i += 1\n            else:\n                j -= 1\n        return []","output":"nlogn"},{"instruction":"n,m,a,b=map(int, input().split())\nprint(min(n%m*b, (m-n%m)*a))","output":"linear"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef prsh(N):\n    prime = [2]\n    for L in range(3,N):\n        for p in prime:\n            if not L % p:\n                break\n            if p > L**(1\/2):\n                prime.append(L)\n                break\n    return prime\nlimit = 59\nprime = prsh(limit+1)\nC = set([tuple()])\nCp = []\nfor i in range(2, limit+1):\n    if i >= 30 and i in prime:\n        Cp.append(i)\n        continue\n    for k in C.copy():\n        if all(gcd(ki, i) == 1 for ki in k):\n            kn = tuple(list(k) + [i])\n            C.add(kn)\n\nINF = 10**9+7\n\nN = int(readline())\nA = list(map(int, readline().split()))\nAo = A[:]\nA.sort()\nans = INF\nAns = None\nfor ci in C:\n    tc = [1]*(N-len(ci)) + list(ci) + Cp\n    for j in range(8):\n        res = 0\n        for a, t in zip(A, tc[j:]):\n            res += abs(a-t)\n        if ans > res:\n            ans = res\n            Ans = tc[j:j+N]\nbuc = [[] for _ in range(limit+1)]\nfor a, an in zip(A, Ans):\n    buc[a].append(an)\nAA = []\nfor ao in Ao:\n    AA.append(buc[ao].pop())\n\nprint(*AA)","output":"np"},{"instruction":"def search(current, digits, target, idx, bulk):\n    if len(current) == len(target) and int(current) <= int(target):\n        print(current)\n        exit(0)\n\n    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]\n\n    if len(possibilities) == 0:\n        return None\n\n    for possible_digit in sorted(set(possibilities), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(possible_digit)\n        if not bulk:\n            bulk = True if possible_digit != target[idx] else False\n        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)\n\ndef main():\n    digits = sorted(list(input()), reverse=True)\n    target = input()\n\n    if len(digits) < len(target):\n        print(''.join(digits))\n        exit(0)\n\n    entries = [char for char in digits if char <= target[0]]\n\n    for current in sorted(set(entries), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(current)\n        search(current, tmp_digits, target, 1, True if current != target[0] else False)\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"l,r=map(int,input().split())\nj=r-l+1\n\nif j==3:\n\tif l%2==0:\n\t\tprint(l,l+1,l+2)\n\telse:\n\t\tprint(-1)\nelif j>3:\n\tif l%2==0:print(l,l+1,l+2)\n\telse:print(l+1,l+2,l+3)\nelse:print(-1)","output":"constant"},{"instruction":"n, k = map(int, raw_input().split())\na = map(int, raw_input().split())\nfor i in range(n):\n    ai = a[i]\n    nai = ((1<<k) - 1)^ai\n    if nai < ai:\n        a[i] = nai\n\nfrom collections import Counter\nC = Counter()\nC[0] += 1\nS = 0\ncnt = 0\nfor j, ai in enumerate(a):\n    nai = ((1<<k) - 1)^ai\n    v1, v2 = C[S^ai], C[S^nai]\n    if v1 <= v2:\n        cnt += j + 1 - v1\n        S ^= ai\n        C[S] += 1\n    else:\n        cnt += j + 1 - v2\n        S ^= nai\n        C[S] += 1\nprint(cnt)","output":"linear"},{"instruction":"import math\ndef solve():\n    words = input().split()\n    people = int(words[0])\n    planes_each = int(words[1])\n    per = int(words[2])\n    sheets = int(words[3])\n    sheets_per_person = math.ceil(planes_each\/per)\n    needed = sheets_per_person*people\n    packs = math.ceil(needed\/sheets)\n    print(packs)\n\nsolve()","output":"constant"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\ndp = [[505]*n for _ in range(n)]\nMax = [[0]*n for _ in range(n)]\n\nfor i in range(n):\n    dp[i][i] = 1\n    Max[i][i] = a[i]\n\nfor len in range(1, n+1):\n    for i in range(n-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][n-1])","output":"cubic"},{"instruction":"n = int(input())\ndis = list(map(lambda x: int(x) << 1, input().split()))\nter = input()\nst, ans = 0, 0\ntime = {'G': 5, 'W': 3, 'L': 1}\ndelta = {'G':1, 'W':1, 'L':-1}\nhasWater = False\nconvert = 0\nfor i in range(n):\n\tst += dis[i] * delta[ter[i]]\n\tans += dis[i] * time[ter[i]]\n\n\tif ter[i] == 'W':\n\t\thasWater = True\n\telif ter[i] == 'G':\n\t\tconvert += dis[i]\n\tif st < 0:\n\t\tif hasWater:\n\t\t\tans += (-st) * 3\n\t\telse:\n\t\t\tans += (-st) * 5\n\t\tst = 0\n\tconvert = min(convert, st \/\/ 2)\n\nans -= 4 * convert\nans -= 2 * (st \/\/ 2 - convert)\nprint(ans \/\/ 2)","output":"linear"},{"instruction":"n , k = map(int, input().split())\nl = list(map(int,input().split()))\nl.sort()\na = 0\ni = 0\nwhile i<(n-1):\n    j = i+1\n    while j<n and l[j]==l[i]:\n        j+=1\n    if j==n:\n        break\n    else:\n        if l[j]<=l[i]+k:\n            a+=(j-i)\n    i = j\nprint(n-a)","output":"nlogn"},{"instruction":"def read():\n    return [c == '1' for c in input()]\nn = int(input())\na, b = read(), read()\n\nres = 0\n\ni = 0\nwhile i + 1 < n:\n    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:\n        a[i] = b[i]\n        a[i+1] = b[i+1]\n        res += 1\n        i += 2\n    else:\n        i += 1\n\nfor i in range(n):\n    if a[i] != b[i]:\n        res += 1\n\nprint(res)","output":"linear"},{"instruction":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = n\n        res = (res >> 16) | (res << 16) & 0xFFFFFFFF\n        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)\n        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)\n        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)\n        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)\n        return res & 0xFFFFFFFF","output":"constant"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,k=map(int, input().split())\nkk=list(map(str, input()))\ns=sorted(list(set(kk)))\nif k > 13:\n    print(-1)\nelse:\n    dic={}\n    for index, value in enumerate(\"abcdefghijklmnopqrstuvwxyz\"):\n        dic[value]= index+1\n\n    ans=0\n    ans+=dic[s[0]]\n    k-=1\n    curr=s[0]\n    for i in range(1,len(s)):\n        if k:\n            if dic[s[i]]>dic[curr]+1:\n                ans+=dic[s[i]]\n                curr=s[i]\n                k-=1\n            if k==0:\n                break\n    if k==0:\n        print(ans)\n    else:\n        print(-1)","output":"linear"},{"instruction":"x = list(map(int, input().split()))\n\nstart = 0\nend = x[0] -1\n\ntarget = x[1]\n\nans = 0\n\nwhile start<= end:\n\n    mid = (start+end)\/\/2\n    sum = mid*(mid+1) \/\/2\n\n    ans1 = x[0] - mid\n\n    if sum - ans1 == target:\n        ans = ans1\n        break\n    elif sum - ans1 > target:\n        end = mid - 1\n    else:\n        start = mid+1\n\nprint(ans)","output":"logn"},{"instruction":"from collections import defaultdict\n\nn = int(raw_input())\nt = defaultdict(list)\nfor _ in range(n - 1):\n    u, v = map(int, raw_input().split())\n    t[u].append(v)\n    t[v].append(u)\na = list(map(int, raw_input().split()))\no = {a_: i for i, a_ in enumerate(a)}\n\ni = 0\nq = [1]\nlv = {1: 0}\npar = {1: 1}\nwhile i < len(q):\n    u = q[i]\n    i += 1\n    for v in t[u]:\n        if v not in lv:\n            lv[v] = lv[u] + 1\n            q.append(v)\n            par[v] = u\n\ndepths = defaultdict(list)\nfor x in a:\n    depths[lv[x]].append(o[par[x]])\n\nans = a[0] == 1\nif ans:\n    for d in depths.values():\n        if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)):\n            ans = False\n            break\n\nif ans:\n    l = [lv[x] for x in a]\n    ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n\nprint(('No', 'Yes')[ans])","output":"linear"},{"instruction":"def sum_from1(k):\n      return (k*(k+1))\/\/2\ndef sum_of_subtraction(p,k):\n      if p<=1:\n            return sum_from1(k)\n      else:\n            return sum_from1(k)-sum_from1(p-1)\nn,k=map(int,input().split())\nif n==1:\n      print(0)\nelif n<=k:\n      print(1)\nelse:\n      n-=1\n      k-=1\n      if n>sum_from1(k):\n            print(-1)\n      else:\n            s=1\n            e=k\n\n            while s<e:\n                  mid=(s+e)\/\/2\n                  r=sum_of_subtraction(mid,k)\n\n                  if r==n:\n                        print(k-mid+1)\n                        break\n                  elif r>n:\n                        s=mid+1\n                  else:\n                        e=mid\n            else:\n                  print(k-s+2)","output":"logn"},{"instruction":"n,m,a,b=map(int,input().split())\nz=(n%m)*b\nx=((n\/\/m+1)*m-n)*a\ny=min(z,x)\nprint(y if y>0 else 0)","output":"linear"},{"instruction":"n,m=map(int,input().split())\nlisti=[]\nfor i in range(0,n):\n    string=input()\n    listi.append(string)\nrownum=0\nflag=False\nfor row in listi:\n\n    for letter in row:\n            if(\"B\" in row):\n                p=row.index(\"B\")\n\n                s=row[::-1]\n                q=abs(m-s.index(\"B\")-1)\n\n                if(p==q):\n                    print(rownum+1,row.index(row[p])+1)\n                    flag=True\n                    break\n                mr=(q+p)\/2\n\n                length=abs(q-p+1)\n\n                rn= rownum + length\/\/2\n\n                print(rn+1,int(mr+1))\n                flag=True\n                break\n\n    if(flag==True):\n        break\n\n    rownum+=1","output":"quadratic"},{"instruction":"import sys, math, queue\n\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef getMul(x):\n    a = 1\n    for xi in x:\n        a *= xi\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nd = {}\nfor ai in a:\n    if ai in d: d[ai] += 1\n    else: d[ai] = 1\n\nf = [[] for i in range(max(a)+10)]\nfor i in range(1, len(f)):\n    for j in range(i, len(f), i):\n        f[j].append(i)\n\nseq = [0 for i in range(max(a)+10)]\nfor ai in d:\n    for fi in f[ai]:\n        seq[fi] += d[ai]\nfor i in range(len(seq)):\n    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD\n\npf = [[] for i in range(max(a)+10)]\npf[0] = None\npf[1].append(1)\nfor i in range(2, len(f)):\n    if len(pf[i]) == 0:\n        for j in range(i, len(pf), i):\n            pf[j].append(i)\nfor i in range(1, len(pf)):\n    mul = getMul(pf[i])\n    if mul == i:\n        if len(pf[i])&1 == 1: pf[i] = -1\n        else: pf[i] = 1\n    else:\n        pf[i] = 0\npf[1] = 1\n\nans = 0\nfor i in range(1, len(seq)):\n    ans += seq[i]*pf[i]\n    ans = (ans + MOD) % MOD\nprint(ans)","output":"np"},{"instruction":"import sys\ninput_file = sys.stdin\nC = (10**9+7)\n[n, q] = list(int(i) for i in input_file.readline().split())\ntemp = input_file.readline()\nlst = []\nfor char in temp[:-1]:\n    lst.append(int(char))\n\nnew_lst = [(0, 0)]\nfor i in lst:\n    if i == 0:\n        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))\n    else:\n        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))\n\nls = [1]\nfor i in range(n):\n    ls.append(ls[-1]*2 % C)\n\nfor line in input_file:\n    [l, r] = list(int(i) for i in line[:-1].split())\n    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])\n    print((ls[sum(q)] - ls[q[0]]) % C)","output":"linear"},{"instruction":"from heapq import heappush, heappop\nn = int(input())\nL = list(map(int, input().split()))\nT = input()\n\nans = sum(L)\n\nQ = []\n\nfor l, t in zip(L, T):\n    if t == 'G':\n        heappush(Q, (2, 2 * l))\n        heappush(Q, (5, float('inf')))\n    elif t == 'W':\n        heappush(Q, (1, 2 * l))\n        heappush(Q, (3, float('inf')))\n\n    need_stamina = l\n    while need_stamina > 0:\n        cost, quantity = heappop(Q)\n        if need_stamina > quantity:\n            ans += quantity * cost\n            need_stamina -= quantity\n        else:\n            ans += need_stamina * cost\n            heappush(Q, (cost, quantity - need_stamina))\n            need_stamina = 0\n\nprint(ans)","output":"nlogn"},{"instruction":"ceil1 = lambda a, b: (a + b - 1) \/\/ b\nn = int(input())\nsq = int(n ** .5)\nsq2, ans, cur = ceil1(n, sq), [], 0\n\nfor i in range(sq2 - 1):\n    cur += sq\n    ans.extend([x for x in range(cur, cur - sq, -1)])\n\nans.extend([x for x in range(n, cur, -1)])\nprint(' '.join(map(str, ans)))","output":"linear"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nm=l[:]\nm.sort()\nf=1\nc=0\nfor i in range(n):\n    if(l[i]!=m[i]):\n        c+=1\n    if(c>2):\n        f=0\n        break\nif(f==0):\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"x,k=map(int,input().split())\nprint(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))","output":"logn"},{"instruction":"n=int(input())\nm=int(input())\nprint(m%(pow(2,n)))","output":"constant"},{"instruction":"l = []\na, b = map(int, input().split())\nl.append((a,b))\na, b = map(int, input().split())\nl.append((a,b))\na, b = map(int, input().split())\nl.append((a,b))\nl.sort()\npath = []\npath.append(l[0])\nx = l[0][0]\nwhile(x<l[1][0]):\n\tpath.append((x, l[0][1]))\n\tx = x + 1\nup = False\nif(l[0][1]<l[1][1]):\n\n\tup = True\nif(up):\n\ty = l[0][1]\n\twhile(y<=l[1][1]):\n\t\tpath.append((l[1][0], y))\n\t\ty = y+1\nelse:\n\ty = l[0][1]\n\twhile(y>=l[1][1]):\n\t\tpath.append((l[1][0], y))\n\t\ty = y-1\nup = False\nif(l[1][1]<l[2][1]):\n\tup = True\nif(up):\n\ty = l[1][1]\n\twhile(y<=l[2][1]):\n\t\tpath.append((l[1][0], y))\n\t\ty = y+1\nelse:\n\ty = l[1][1]\n\twhile(y>=l[2][1]):\n\t\tpath.append((l[1][0], y))\n\t\ty = y-1\nx = l[1][0]\nwhile(x<l[2][0]):\n\tpath.append((x, l[2][1]))\n\tx = x + 1\npath.append(l[2])\npath = list(set(path))\nprint(len(path))\nfor i in range(len(path)):\n\tprint(str(path[i][0])+\" \"+str(path[i][1]))","output":"constant"},{"instruction":"from math import gcd\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"right\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\right\\n\")\n\ndef func(left:int, right:int):\n    if left == 1:\n        left += 1\n    if right - left < 2:\n        return -1\n\n    if left & 1:\n        if right - left > 2:\n            left += 1\n            return '{} {} {}'.format(left, left + 1, left + 2)\n        else:\n            if gcd(left, left + 2) != 1:\n                return '{} {} {}'.format(left, left + 1, left + 2)\n            return -1\n    return '{} {} {}'.format(left, left + 1, left + 2)\n\ndef main():\n    left, right = map(int, input().split())\n    print(func(left, right))\n    return\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"import math\n\nn, d = [int(x) for x in input().split(' ')]\npos = [int(x) for x in input().split(' ')]\n\ncount = 2\n\nfor i in range(1,n):\n\tif math.fabs(pos[i] - pos[i-1]) > 2*d:\n\t\tcount += 2\n\telif math.fabs(pos[i] - pos[i-1]) == 2*d:\n\t\tcount += 1\n\telse:\n\t\tcontinue;\n\nprint(count)","output":"linear"},{"instruction":"def whb(a,b,c,d):\n    dim = (c-a+1)*(d-b+1)\n    col1 = dim\/\/2\n    col2 = dim-col1\n    if (a+b)%2==0:\n        return [col2, col1]\n    else:\n        return [col1, col2]\n\ndef insegment(a, b, a1, b1):\n    li = [[a,1], [b,1], [a1,2], [b1,2]]\n    li.sort()\n    if li[0][1] == li[1][1]:\n        if li[1][0] == li[2][0]:\n            return [li[1][0], li[2][0]]\n        else:\n            return -1\n    else:\n        return [li[1][0], li[2][0]]\n\ndef inrect(a,b,c,d,a1,b1,c1,d1):\n    xra = insegment(a,c,a1,c1)\n    yra = insegment(b,d,b1,d1)\n    if xra==-1 or yra==-1:\n        return -1\n    else:\n        return [xra[0], yra[0], xra[1], yra[1]]\n\nq = int(input())\nfor quer in range(q):\n    [n, m] = [int(i) for i in input().split()]\n    [x1, y1, x2, y2] = [int(i) for i in input().split()]\n    [x3, y3, x4, y4] = [int(i) for i in input().split()]\n    [white, black] = whb(1,1,n,m)\n    [w1, b1] = whb(x1, y1, x2, y2)\n    [w2, b2] = whb(x3, y3, x4, y4)\n    black+= w2-b1\n    white+= b1-w2\n    inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4)\n    if type(inter)==list:\n        [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3])\n        black += b3\n        white -= b3\n    print(white, black)","output":"constant"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nR,G,B=map(int,input().split())\nr=sorted(list(map(int,input().split())))\ng=sorted(list(map(int,input().split())))\nb=sorted(list(map(int,input().split())))\ndp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i>0 and j>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])\n            if i>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])\n            if j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])\nprint(dp[R][G][B])","output":"cubic"},{"instruction":"query = input().split()\n\nn = int(query[0])\nk = int(query[1])\nimport math\n\ntemp = 2* (k + n)\n\nm = (-3 + math.sqrt(9 + 4*temp))\/2\n\nprint(int(n-m))","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m = map(int,input().split())\n\nA = [None]*n\nlo,hi = 1<<32,-1<<32\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n    lo = min(min(A[i]), lo)\n    hi = max(max(A[i]), hi)\n\nbest = -1\nans = [-1,-1]\n\ndef possible(x):\n    global best, ans\n\n    M = [-1]*(1<<m)\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if A[i][j] >= x:\n                mask += (1<<j)\n        M[mask] = i\n\n    for m0 in range(1<<m):\n        if M[m0] == -1:\n            continue\n\n        for m1 in range(1<<m):\n            if M[m1] == -1:\n                continue\n\n            if m0 | m1 == (1<<m) - 1:\n                if best < x:\n                    best = x\n                    ans = [M[m0]+1, M[m1]+1]\n\n                return True\n    return False\n\npossible(hi)\npossible(lo)\n\nwhile lo+1 < hi:\n    mid = (lo+hi)\/\/2\n    if possible(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(*ans)","output":"np"},{"instruction":"a,b=map(int,input().split())\nif b>=a-1:\n    print(a-1)\nelse:\n    summ=b\n    k=a-b\n    for i in range(2,k+1):\n        summ+=i\n    print(summ)","output":"linear"},{"instruction":"n , k = map(int , input().split())\nlst = []\nfor i in range(n):\n    p , t =  map(int , input().split())\n    lst.append([p,-t])\n\ntmp  = sorted(lst , key =lambda x : (x[0],x[-1]) , reverse = True)[k-1]\nprint(lst.count(tmp))","output":"nlogn"},{"instruction":"n = int(input())\n\nd = {}\n\nfor i in range(n-1):\n\ta,b = map(int,input().split())\n\n\ttry:\n\t\td[a].append(b);\n\texcept:\n\t\td[a] = [b]\n\ttry:\n\t\td[b].append(a);\n\texcept:\n\t\td[b] = [a]\n\narray = list(map(int,input().split()))\nflag=0;\n\nif array[0]==1:\n\n\ti = 1;\n\tj = 0;\n\n\twhile ( j < n and i < n ):\n\t\tif ( array[j] in d[array[i]] ):\n\t\t\ti+=1;\n\t\telse:\n\t\t\tj+=1;\n\tif j==n and i!=n:\n\t\tflag=1;\nelse:\n\tflag=1;\n\nif flag==1:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")","output":"linear"},{"instruction":"from sys import stdin,stdout\nfrom collections import Counter\nnmbr=lambda:int(stdin.readline())\nlst = lambda: list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    a=lst()\n    d={};r=l=-2\n    for i in range(n):\n        d[a[i]]=d.get(a[i],0)+1\n        if len(d)==k:\n            r=i\n            break\n    for i in range(r+1):\n        if d[a[i]]==1:\n            l=i\n            break\n        d[a[i]]-=1\n    print(l+1,r+1)","output":"linear"},{"instruction":"class Solution:\n    def climbStairs(self, n: int) -> int:\n\n        def dfs(i):\n            if i >= n:\n                return i == n\n            return dfs(i + 1) + dfs(i + 2)\n\n        return dfs(0)","output":"np"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write('\\n'.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\nfrom decimal import Decimal\nfrom fractions import Fraction\n\nINF = float('inf')\nmod = int(1e9)+7\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n@bootstrap\ndef recur(r,g,b):\n    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:\n        yield 0\n        return\n    if dp[r][g][b]:\n        yield dp[r][g][b]\n        return\n    if r>0 and g>0:\n        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))\n    if r>0 and b>0:\n        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))\n    if b>0 and g>0:\n        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))\n    yield dp[r][g][b]\n\nr,g,b=mdata()\nR=sorted(mdata())\nG=sorted(mdata())\nB=sorted(mdata())\ndp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]\nout(recur(r,g,b))","output":"cubic"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\ndef seive():\n    prime=[1 for i in range(10**6+1)]\n    prime[0]=0\n    prime[1]=0\n    for i in range(10**6+1):\n        if(prime[i]):\n            for j in range(2*i,10**6+1,i):\n                prime[j]=0\n    return prime\n\na,b=L()\ndef rec(a,b):\n    if b==1:\n        return a\n    if a>b:\n        return a\/\/b+rec(b,a%b)\n    else:\n        return rec(b,a)\nprint(rec(a,b))\n\nendtime = time.time()","output":"constant"},{"instruction":"import os,io\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nn,m,k=map(int,input().split())\ndist1=[]\nfor i in range(n):\n  dist1.append(list(map(int,input().split())))\ndist2=[]\nfor i in range(n-1):\n  dist2.append(list(map(int,input().split())))\nif k%2:\n  print(' '.join(map(str,[-1]*(n*m))))\n  exit()\nk\/\/=2\ndp=[10**9]*((k+1)*n*m)\nfor i in range(n):\n  for j in range(m):\n    dp[i*m+j]=0\nfor t in range(k):\n  r=(t+1)*n*m\n  q=t*n*m\n  for i in range(n):\n    for j in range(m):\n      if i<n-1:\n        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])\n      if i>0:\n        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])\n      if j<m-1:\n        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])\n      if j>0:\n        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])\nans=[]\nfor i in range(n):\n  for j in range(m):\n    ans.append(dp[k*n*m+i*m+j])\nprint(' '.join(map(str,ans)))","output":"cubic"},{"instruction":"n=int(input())\nl=sorted(list(map(int,raw_input().split())))\ndef f():\n    global n\n    dou=False\n    for k in range(1,n):\n        if l[k]==l[k-1]:\n            if dou or l[k]==0 or (l[k]==l[k-2] and n!=2) or l[k]==l[k-2]+1:\n                return False\n            else:\n                dou=True\n    return (sum(l)-(n*(n-1))\/\/2)%2\nif f():\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")","output":"nlogn"},{"instruction":"n = int(input())\nif n==1:\n    print(5)\nelse:\n    print(25)","output":"constant"},{"instruction":"import math\ndef C(a, b):\n\treturn math.factorial(a)\/\/(math.factorial(b)*math.factorial(a-b))\n\na = list(input())\nb = list(input())\nx, y, d, ans, power = 0, 0, 0, 0, 0\nfor i in range(len(a)):\n\tif a[i] == '+':\n\t\tx += 1\n\tif a[i] == '-':\n\t\tx -= 1\n\tif b[i] == '?':\n\t\td += 1\n\tif b[i] == '+':\n\t\ty += 1\n\tif b[i] == '-':\n\t\ty -= 1\nplus, minus = d, 0\nfor i in range(0, d+1):\n\tk = C(d, plus)\n\tif y+(plus-minus) == x:\n\t\tans += k\n\tpower += k\n\tplus -= 1\n\tminus += 1\nprint(\"{0:.12f}\".format(ans\/power))","output":"np"},{"instruction":"def main():\n    import sys\n    import collections\n    input = sys.stdin.readline\n    n, m, K = map(int, input().split())\n\n    A = [input().rstrip() for i in range(n)]\n\n    B = [list(input().rstrip().split()) for i in range(m)]\n\n    alpha = 'abc\uff44'\n\n    D = dict()\n    for i, x in enumerate(A):\n        D[x] = i\n\n    G = [set() for i in range(n)]\n    X = [set() for i in range(n)]\n\n    for i in range(m):\n        a, b = B[i]\n        b = int(b)\n        flag = False\n        for j in range(2**K):\n            x = []\n            for k in range(K):\n                if (j >> k) % 2 == 1:\n                    x.append('_')\n                else:\n                    x.append(a[k])\n            x = ''.join(x)\n            if x in D:\n                if D[x] == b-1:\n                    flag = True\n                    continue\n                else:\n                    G[b-1].add(D[x])\n                    X[D[x]].add(b-1)\n        if flag:\n            continue\n        else:\n            print(\"NO\")\n            exit(0)\n    X = [len(X[i]) for i in range(n)]\n    ANS = []\n    s = set()\n    q = collections.deque()\n    for i in range(n):\n        if X[i] == 0:\n            q.append(i)\n            s.add(i)\n\n    while(q):\n        if len(ANS) == n:\n            print(\"NO\")\n            exit(0)\n        x = q.popleft()\n        ANS.append(x+1)\n        for y in G[x]:\n            if X[y] == 0:\n                continue\n            else:\n                X[y] -= 1\n                if X[y] == 0:\n                    q.append(y)\n    if len(ANS) == n:\n        print(\"YES\")\n        print(*ANS)\n    else:\n        print(\"NO\")\n\nmain()","output":"np"},{"instruction":"import math;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn, a, b = getIntList();\nif a>1 and b>1:\n    print('NO');\nelif a==b==1 and (n==2 or n==3):\n    print('NO');\nelse:\n    c=max(a, b);\n    m=[[0]*n for _ in range(n)];\n    for i in range(n-c):\n        m[i][i+1]=1;\n        m[i+1][i]=1;\n    if b>1:\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    m[i][j]=1-m[i][j];\n    print('YES');\n    for i in range(n):\n        print(''.join(map(str, m[i])));","output":"quadratic"},{"instruction":"n=int(input())\nif n>-1:\n    print(n)\nelse:\n    n=str(n)\n    x=int(n[:len(n)-1])\n    y=int(n[:len(n)-2]+n[-1])\n    print(max(x,y))","output":"constant"},{"instruction":"n, pos, l, r = map(int,input().split())\nstep, dif = 0, lambda a, b : abs(a - b)\n\nif dif(pos, l) < dif(pos, r):\n\tif l != 1:\n\t\tstep += dif(pos, l) + 1\n\t\tpos = l\n\tif r != n:\n\t\tstep += dif(pos, r) + 1\nelse:\n\tif r != n:\n\t\tstep += dif(pos, r) + 1\n\t\tpos = r\n\tif l != 1:\n\t\tstep += dif(pos, l) + 1\nprint(step)","output":"constant"},{"instruction":"import sys, string\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\narr.sort()\nst = []\nfor i in arr:\n    if not st:\n        st.append(i)\n    else:\n        while st:\n            if 0 < abs(st[-1] - i) <= k:\n                st.pop()\n            else:\n                break\n        st.append(i)\nprint(len(st))","output":"nlogn"},{"instruction":"k = int(input())\n\ntotal_digit = 0\ndigit = 1\n\nwhile k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):\n    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))\n    digit += 1\n\nremaining = k - total_digit - 1\ncorr_num = str(pow(10, digit - 1) + remaining \/\/ digit)\nprint(corr_num[remaining % digit])","output":"logn"},{"instruction":"I = lambda: map(int, input().split())\n\nn, l, r, x = I()\nC, k = [*I()], 0\n\nfor i in range(2 ** n):\n    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']\n    if l <= sum(W) <= r and max(W) - min(W) >= x:\n        k += 1\n\nprint(k)","output":"np"},{"instruction":"R,G,B = map(int,input().split())\nr = sorted(list(map(int,input().split())), reverse=True)\ng = sorted(list(map(int,input().split())), reverse=True)\nb = sorted(list(map(int,input().split())), reverse=True)\n\ndp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]\nans = 0\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if j*k > 0:\n                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])\n            if i*k > 0:\n                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])\n            if i*j > 0:\n                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])\n            ans = max(ans,dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"actions, end_total_candies = [int(i) for i in input().split()]\ncandies = 1\nif(actions == 1):\n    print(0)\nelse:\n    for i in range(1, actions):\n        candies = candies + i + 1\n\n        if(candies >= end_total_candies + (actions - i - 2)):\n            print(candies - end_total_candies)\n            exit()","output":"logn"},{"instruction":"from collections import defaultdict\nfrom sys import stdin\ninput=stdin.readline\nt=int(input())\nfor _ in range(t):\n  n=int(input())\n  a=list(map(int,input().split()))\n  dd=defaultdict(int)\n  for i in range(n):\n    dd[a[i]]+=1\n  l=[]\n  for aa in a:\n    if dd[aa]>=2:\n      l.append(aa)\n      dd[aa]-=2\n  l.sort()\n  ans=[-1,-1,-1,-1]\n  m=10**18\n  for i in range(len(l)-1):\n    x=(4*(l[i]+l[i+1])**2)\/(l[i]*l[i+1])\n    if x<m:\n      ans=[l[i],l[i],l[i+1],l[i+1]]\n      m=x\n  print(*ans)","output":"nlogn"},{"instruction":"try:\n    n=int(input())\n    x=list(map(int,input().split(\" \")))\n    x=set(x)\n    x=list(x)\n    x.sort()\n    if len(x)!=1:\n        print(x[1])\n    else:\n        print(\"NO\")\n\nexcept:\n    pass","output":"nlogn"},{"instruction":"n = int(input())\nans = [(0, 0)]\nfor i in range(1, n):\n    ans.append((0, i))\n    ans.append((i, 0))\n    ans.append((0, -i))\n    ans.append((-i, 0))\nfor i in range(n):\n    print(str(ans[i][0]) + ' ' + str(ans[i][1]))","output":"linear"},{"instruction":"a , b = list(map(int, input().split()))\nx, y, z = list(map(int, input().split()))\nans = 0\np = a - ((x*2) + y)\nq = b - ((z*3) + y)\n\nif (p < 0 and q < 0):\n    print(abs(p) + abs(q))\nelif (p < 0):\n    print(abs(p))\nelif (q < 0):\n    print(abs(q))\nelse:\n    print(0)","output":"constant"},{"instruction":"n, m = map(int, input().split())\n\ntop = [-1, -1]\nbottom = [-1, -1]\n\nfor i in range(n):\n    s = input()\n    left = s.find('B')\n    if left != -1:\n        right = s.rfind('B')\n        c = (right - left) \/\/ 2 + 1\n        print(i + c, left + c)\n        break","output":"quadratic"},{"instruction":"def substraction(a,b):\n    if a==0 or b==0:\n        return 0\n    else:\n        if a>b:\n            count=a\/\/b\n            return substraction(a%b,b)+count\n        else:\n            count = b\/\/a\n            return substraction(a,b%a)+count\n\nt=int(input())\nlst=[]\nres=[]\nfor i in range(0,t):\n    lst=[int(i) for i in input().split()]\n    ele=substraction(lst[0],lst[1])\n    res.append(ele)\n\nfor i in range(0,t):\n    print(res[i])","output":"constant"},{"instruction":"def main():\n    n = int(input())\n    V = []\n    for i in range(n):\n        x,w = map(int,input().split())\n        V.append((x-w,x+w))\n    V.sort(key=lambda x: x[1])\n    ans = 1\n    now = V[0]\n    for i in range(1,n):\n        if V[i][0] >= now[1]:\n            now = V[i]\n            ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\npal = 1 if arr[1] > arr[0] else 3 if arr[0] == arr[1] else 5\nb = True\narr_pal = [pal]\nfor i in range(n - 2):\n    if arr[i + 1] > arr[i]:\n        if pal == 5:\n            b = False\n            break\n        if arr[i + 2] < arr[i + 1]:\n            pal = 5\n            arr_pal.append(pal)\n        else:\n            pal += 1\n            arr_pal.append(pal)\n    elif arr[i + 1] < arr[i]:\n        if pal == 1:\n            b = False\n            break\n        if arr[i + 2] > arr[i + 1]:\n            pal = 1\n            arr_pal.append(pal)\n        else:\n            pal -= 1\n            arr_pal.append(pal)\n    else:\n        if arr[i + 2] > arr[i + 1]:\n            pal = 2 if pal == 1 else 1\n            arr_pal.append(pal)\n        elif arr[i + 2] < arr[i + 1]:\n            pal = 4 if pal == 5 else 5\n            arr_pal.append(pal)\n        else:\n            pal = 4 if pal < 4 else 3\n            arr_pal.append(pal)\nif arr[-2] < arr[-1]:\n    if pal == 5:\n        b = False\n    else:\n        pal += 1\n        arr_pal.append(pal)\nelif arr[-2] > arr[-1]:\n    if pal == 1:\n        b = False\n    else:\n        pal -= 1\n        arr_pal.append(pal)\nelse:\n    pal = 3 if pal == 5 else 5\n    arr_pal.append(pal)\nif b:\n    print(*arr_pal)\nelse:\n    print(-1)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\ndef ctd(chr): return ord(chr)-ord(\"a\")\nmod = 998244353\nINF = float('inf')\n\np, u = \"Petr\", \"Um_nik\"\n\ndef main():\n    n = N()\n    arr = RLL()\n    vis = [0]*(n+1)\n    dic = {v: i+1 for i, v in enumerate(arr)}\n\n    sm = 0\n    for i in range(1, n+1):\n        if vis[i]==0:\n            now = i\n            vis[now] = 1\n\n            while dic[now]!=i:\n                sm+=1\n                now = dic[now]\n                vis[now] = 1\n    if (3*n-sm)%2==0:\n        print(p)\n    else:\n        print(u)\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"MOD = int(1e9+9)\n\ndef fast_power(x, y):\n    res = 1\n    while y > 0:\n        if y % 2 == 1:\n            res = res * x%MOD\n        x = x * x % MOD\n        y \/\/= 2\n    return res\n\nn, m, k = map(int, input().split())\nx = max(0, m - n \/\/ k * (k - 1) - n % k)\nz = (m - x * k) % MOD\nres = fast_power(2, x+1)\nres = (res - 2) % MOD * k % MOD\nres = (res + z) % MOD\nprint(res)","output":"logn"},{"instruction":"from sys import stdin,stdout\ninput=stdin.readline\nfor _ in range(int(input())):\n    x=10**5\n    n,k=map(int,input().split())\n    s=input()\n    a=10**9\n    ans=[[0]*n for i in range(3)]\n    curr=['R','G','B']\n    for l in range(3):\n        z=l\n        for j in range(n):\n            if s[j]!=curr[z]:\n                ans[l][j]=1\n            z+=1\n            z%=3\n    for i in range(3):\n        ans[i]=[0]+ans[i]\n    for l in range(3):\n        z=l\n        for j in range(1,n+1):\n            ans[l][j]+=ans[l][j-1]\n    for l in range(3):\n        for j in range(1,n-k+2):\n            a=min(a,ans[l][j+k-1]-ans[l][j-1])\n\n    print(a)","output":"linear"},{"instruction":"MOD = 1000000007\ndef fast_power(base, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        power = power \/\/ 2\n        base = (base * base) % MOD\n\n    return result\n\nx, k = map(int, input().split())\n\nif x == 0 or k == 0:\n    print((x * 2) % MOD)\nelse:\n    d = ((x * 4) - 1) - (x * 2)\n    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)","output":"logn"},{"instruction":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [0] * n\n\n        for i in range(n):\n            prod = 1\n            for j in range(n):\n                if i == j:\n                    continue\n                prod *= nums[j]\n\n            res[i] = prod\n        return res","output":"quadratic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n\n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n\n    return powerset_orderred\ndef fastPlrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\n\ndef solve():\n    n,k = li()\n    l = [['.' for i in range(n)] for j in range(4)]\n    print(\"YES\")\n    if k%2==0:\n        for i in range(1,k\/\/2+1):\n            l[1][i]='\n            l[2][i]='\n    else:\n        if (k>n-2):\n\n            for i in range(1,n-1):\n                l[1][i]='\n            k-=(n-2)\n        if k>0:\n            i = n\/\/2\n            if k%2==1:\n                l[2][i]='\n                k-=1\n            i = n\/\/2+1\n            for i in range(n\/\/2+1,n\/\/2+1+k\/\/2):\n                l[2][i]='\n            k = k\/\/2\n            for i in range(n\/\/2-1,-1,-1):\n                if k==0:\n                    break\n                k-=1\n                l[2][i]='\n    for i in l:\n        print(''.join(i))\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading\nfrom bisect import bisect_right\nfrom math import gcd,log\nfrom collections import Counter,defaultdict,deque\nfrom pprint import pprint\nfrom itertools import permutations\nfrom bisect import bisect_right\nfrom random import randint as rti\n\nn,m=0,0\n\ndef main(tnum):\n    global n,m,d\n    n,m,k=map(int,input().split())\n    if k%2:\n        ans=[[-1]*m for i in range(n)]\n        for li in ans:\n            print(*li)\n        return\n    cost=dict()\n    dp=[[float('inf')]*m for i in range(n)]\n    crr=[]\n    rrr=[]\n    for i in range(n):\n        arr=list(map(int,input().split()))\n        for j in range(m-1):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i][j+1]=min(dp[i][j+1],arr[j])\n        crr.append(arr)\n\n    for i in range(n-1):\n        arr=list(map(int,input().split()))\n        for j in range(m):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i+1][j]=min(dp[i+1][j],arr[j])\n\n        rrr.append(arr)\n\n    for i in range(1,k\/\/2):\n        ndp=[[float('inf')]*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                x,y=i,j\n                if x>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])\n                if x<n-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])\n                if y>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])\n                if y<m-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])\n        dp=ndp\n    for li in dp:\n        li=[2*x for x in li]\n        print(*li)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n\n    for _ in range(1):\n        main(_+1)","output":"cubic"},{"instruction":"import sys\nfrom collections import defaultdict\n\nreadline=sys.stdin.readline\n\nclass Prime:\n    def __init__(self,N):\n        assert N<=10**8\n        self.smallest_prime_factor=[None]*(N+1)\n        for i in range(2,N+1,2):\n            self.smallest_prime_factor[i]=2\n        n=int(N**.5)+1\n        for p in range(3,n,2):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n                for i in range(p**2,N+1,2*p):\n                    if self.smallest_prime_factor[i]==None:\n                        self.smallest_prime_factor[i]=p\n        for p in range(n,N+1):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]\n\n    def Factorize(self,N):\n        assert N>=1\n        factorize=defaultdict(int)\n        if N<=len(self.smallest_prime_factor)-1:\n            while N!=1:\n                factorize[self.smallest_prime_factor[N]]+=1\n                N\/\/=self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N%p==0:\n                    N\/\/=p\n                    factorize[p]+=1\n                if N<p*p:\n                    if N!=1:\n                        factorize[N]+=1\n                    break\n                if N<=len(self.smallest_prime_factor)-1:\n                    while N!=1:\n                        factorize[self.smallest_prime_factor[N]]+=1\n                        N\/\/=self.smallest_prime_factor[N]\n                    break\n            else:\n                if N!=1:\n                    factorize[N]+=1\n        return factorize\n\n    def Divisors(self,N):\n        assert N>0\n        divisors=[1]\n        for p,e in self.Factorize(N).items():\n            A=[1]\n            for _ in range(e):\n                A.append(A[-1]*p)\n            divisors=[i*j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self,N):\n        return N==self.smallest_prime_factor[N]\n\n    def Totient(self,N):\n        for p in self.Factorize(N).keys():\n            N*=p-1\n            N\/\/=p\n        return N\n\n    def Mebius(self,N):\n        fact=self.Factorize(N)\n        for e in fact.values():\n            if e>=2:\n                return 0\n        else:\n            if len(fact)%2==0:\n                return 1\n            else:\n                return -1\n\nN,Q=map(int,readline().split())\nP=Prime(5*10**5)\nmebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]\ncnt=[0]*(5*10**5+1)\nans=0\nA=list(map(int,readline().split()))\nused=[False]*(N)\nfor _ in range(Q):\n    q=int(readline())-1\n    prime=list(P.Factorize(A[q]).keys())\n    l=len(prime)\n    for bit in range(1<<l):\n        s=1\n        for i in range(l):\n            if bit>>i&1:\n                s*=prime[i]\n        if used[q]:\n            cnt[s]-=1\n            ans-=cnt[s]*mebius[s]\n        else:\n            ans+=cnt[s]*mebius[s]\n            cnt[s]+=1\n    if used[q]:\n        used[q]=False\n    else:\n        used[q]=True\n    print(ans)","output":"np"},{"instruction":"import sys\nfrom math import floor\n\nif __name__ == '__main__':\n\n    entrada = input()\n    entrada_str = list(entrada.split(\" \"))\n    entrada_int = list(map(int, entrada_str))\n\n    a = entrada_int[0]\n    b = entrada_int[1]\n\n    if a == b:\n        print(0)\n        sys.exit()\n\n    string_1 = \"\"\n    string_2 = \"\"\n    while a:\n        if a%2 == 0:\n            string_1 = string_1 + \"0\"\n        else:\n            string_1 = string_1 + \"1\"\n        a = floor(a\/2)\n\n    while b:\n        if b%2 == 0:\n            string_2 = string_2 + \"0\"\n        else:\n            string_2 = string_2 + \"1\"\n        b = floor(b\/2)\n\n    lista_1 = list(string_1)\n    lista_1.reverse()\n    contrario_1 = \"\".join(lista_1)\n\n    lista_2 = list(string_2)\n    lista_2.reverse()\n    contrario_2 = \"\".join(lista_2)\n\n    if len(string_1) != len(string_2):\n        resposta = pow(2, len(string_2)) - 1\n    else:\n        potencia = 0\n        for i in range(len(string_1)):\n            if contrario_1[i] != contrario_2[i]:\n                break\n            potencia += 1\n\n        potencia = len(string_1) - potencia\n        resposta = pow(2, potencia)-1\n\n    print(resposta)","output":"logn"},{"instruction":"n,k=map(int,input().split())\ns=[[\".\"]*n for i in range(4)]\nif k%2==0:\n  for j in range(1,n-1):\n    if k==0:\n      break\n    s[1][j]=\"\n    s[2][j]=\"\n    k-=2\nelse:\n  cen=n\/\/2\n  s[1][cen]=\"\n  k-=1\n  for i in range(1,3):\n    for j in range(1,cen):\n      if k>0:\n        k-=2\n        s[i][j]=s[i][-j-1]=\"\nif k==0:\n  print(\"YES\")\n  for i in range(4):\n    print(\"\".join(s[i]))\nelse:\n  print(\"NO\")","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\nimport copy\n\nn,m,k = map(int,input().split())\nA = list(map(int,input().split()))\nANS = 0\n\nfor i in range(m):\n    B = copy.deepcopy(A)\n\n    for j in range(i,n,m):\n        B[j] -= k\n\n    SUM = list(accumulate(B))\n    SUMMIN = [float(\"inf\")]*n +[0]\n\n    if i==0:\n        SUMMIN[0] = 0\n\n    for j in range(max(1,i),n):\n        if j % m == i % m:\n            SUMMIN[j] = min(SUMMIN[j-1],SUM[j-1])\n        else:\n            SUMMIN[j] = SUMMIN[j-1]\n\n    for j in range(i,n):\n        ANS = max(ANS,SUM[j] - SUMMIN[j])\n\nprint(ANS)","output":"quadratic"},{"instruction":"n = int(input())\nif n==0:\n    print(0)\nelif n%2==1:\n    print((n+1)\/\/2)\nelse:\n    print(n+1)","output":"constant"},{"instruction":"from sys import stdin,stdout\nimport sys\n\nn=int(stdin.readline().strip())\narr=list(map(int,stdin.readline().strip().split(' ')))\n\ndp_arr=[[None for i in range(n)] for i in range(n)]\n\nfor i in range(n):\n\tdp_arr[i][i]=(arr[i],1,arr[i])\n\ndef merge_small(c1,c2):\n\tif c1[1]==1 and c2[1]==1:\n\t\tif c1[0]==c2[0]:\n\t\t\treturn (c1[0]+1,1,c1[0]+1)\n\t\telse:\n\t\t\treturn (c1[0],2,c2[0])\n\telif c1[1]==2 and c2[1]==1:\n\t\tif c1[2]==c2[0]:\n\t\t\tif c1[0]==c1[2]+1:\n\t\t\t\treturn (c1[0]+1,1,c1[0]+1)\n\t\t\telse:\n\t\t\t\treturn (c1[0],2,c2[2]+1)\n\t\telse:\n\t\t\treturn (c1[0],3,c2[2])\n\n\telif c1[1]==1 and c2[1]==2:\n\t\tif c1[2]==c2[0]:\n\t\t\tif c2[2]==c2[0]+1:\n\t\t\t\treturn (c2[2]+1,1,c2[2]+1)\n\t\t\telse:\n\t\t\t\treturn (c2[0]+1,2,c2[2])\n\t\telse:\n\t\t\treturn(c1[0],3,c2[2])\n\n\telif c1[1]==2 and c2[1]==2:\n\t\tif c1[2]==c2[0]:\n\t\t\tc1=(c1[0],2,c1[2]+1)\n\t\t\tc2=(c2[2],1,c2[2])\n\t\t\tif c1[1]==2 and c2[1]==1:\n\t\t\t\tif c1[2]==c2[0]:\n\t\t\t\t\tif c1[0]==c1[2]+1:\n\t\t\t\t\t\treturn (c1[0]+1,1,c1[0]+1)\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn (c1[0],2,c2[2]+1)\n\t\t\t\telse:\n\t\t\t\t\treturn (c1[0],3,c2[2])\n\t\telse:\n\t\t\treturn (c1[0],4,c2[2])\n\ndef merge_main(c1,c2):\n\n\tif c1[1]>2:\n\t\tif c2[1]>2:\n\t\t\tif c1[2]==c2[0]:\n\t\t\t\treturn (c1[0],c1[1]+c2[1]-1,c2[2])\n\t\t\telse:\n\t\t\t\treturn (c1[0],c1[1]+c2[1],c2[2])\n\t\telse:\n\t\t\tif c2[1]==1:\n\t\t\t\tif c1[2]==c2[0]:\n\t\t\t\t\treturn (c1[0],c1[1],c2[2]+1)\n\t\t\t\telse:\n\t\t\t\t\treturn (c1[0],c1[1]+1,c2[2])\n\t\t\tif c2[1]==2:\n\t\t\t\tif c1[2]==c2[0]:\n\t\t\t\t\tif c1[2]+1==c2[2]:\n\t\t\t\t\t\treturn (c1[0],c1[1],c2[2]+1)\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn (c1[0],c1[1]+1,c2[2])\n\t\t\t\telse:\n\t\t\t\t\treturn (c1[0],c1[1]+2,c2[2])\n\telse:\n\t\tif c2[1]>2:\n\t\t\tif c1[1]==1:\n\t\t\t\tif c1[2]==c2[0]:\n\t\t\t\t\treturn (c1[2]+1,c2[1],c2[2])\n\t\t\t\telse:\n\t\t\t\t\treturn (c1[2],c2[1]+1,c2[2])\n\n\t\t\tif c1[1]==2:\n\t\t\t\tif c1[2]==c2[0]:\n\t\t\t\t\tif c1[0]==c1[2]+1:\n\t\t\t\t\t\treturn (c1[0]+1,c2[1],c2[2])\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn (c1[0],c2[1]+1,c2[2])\n\t\t\t\telse:\n\t\t\t\t\treturn (c1[0],c2[1]+2,c2[2])\n\t\telse:\n\n\t\t\treturn merge_small(c1,c2)\n\nfor i1 in range(1,n):\n\tfor j1 in range(n-i1):\n\t\tcurr_pos=(j1,j1+i1)\n\n\t\tfor k1 in range(j1,j1+i1):\n\n\t\t\tres=merge_main(dp_arr[j1][k1],dp_arr[k1+1][j1+i1])\n\n\t\t\tif dp_arr[j1][j1+i1]==None or dp_arr[j1][j1+i1][1]>res[1]:\n\t\t\t\tdp_arr[j1][j1+i1]=res\n\nstdout.write(str(dp_arr[0][n-1][1])+\"\\n\")","output":"cubic"},{"instruction":"n,m=map(int, input().split())\nout=[n]\ni=n-1\nm-=1\nfor _ in range(n-1):\n    if m%2:\n        out.append(i)\n    else:\n        out=[i]+out\n\n    m\/\/=2\n    i-=1\n\nfor i in out:\n    print(i, end=\" \")\nprint()","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input()))\nb = list(map(int, input()))\n\nans = sum(q != w for q, w in zip(a, b))\ni = 1\nwhile i < n:\n    aii = a[i - 1]\n    ai = a[i]\n    bii = b[i - 1]\n    bi = b[i]\n    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:\n        ans -= 1\n        i += 1\n    i += 1\n\nprint(ans)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\na,b,c = list(map(int,input().split()))\n\nx = list(map(int,input().split()))\ny = list(map(int,input().split()))\nz = list(map(int,input().split()))\n\nx.sort(reverse=True)\ny.sort(reverse=True)\nz.sort(reverse=True)\n\na+=1\nb+=1\nc+=1\n\nx = [0] + x\ny = [0] + y\nz = [0] + z\n\ntmp = [[0]*c for _ in range(b)]\nbest = [tmp for _ in range(a)]\n\nans = 0\n\nfor i in range(a):\n    for j in range(b):\n        for k in range(c):\n            if (i+j+k) % 2 == 0:\n                aa,bb,cc = 0,0,0\n                if i>0 and j>0:\n                    aa = best[i-1][j-1][k] + x[i] * y[j]\n                if i>0 and k>0:\n                    bb = best[i-1][j][k-1] + x[i] * z[k]\n                if j>0 and k>0:\n                    cc = best[i][j-1][k-1] + y[j] * z[k]\n\n                best[i][j][k] = max(aa,bb,cc)\n                ans = max(ans, best[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"import math\nimport sys\n\nDEBUG = False\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\ndef solve(N):\n    ans = []\n\n    end = N\n    fac = 1\n\n    while end >= 1:\n        if end == 1:\n            ans.append(fac)\n            end = 0\n            break\n\n        if end == 2:\n            ans.append(fac)\n            ans.append(fac * 2)\n            end = 0\n            break\n\n        if end == 3:\n            ans.append(fac)\n            ans.append(fac)\n            ans.append(fac * 3)\n            end = 0\n            break\n\n        ans.extend([fac] * ((end + 1) \/\/ 2))\n        end \/\/= 2\n        fac *= 2\n\n    return ans\n\ndef main():\n    N = int(inp())\n    print(*solve(N))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\nfrom itertools import groupby as gb\nfrom fractions import Fraction as fr\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,m,a,b=map(int,input().split())\nif n%m:\n    ul=(n\/\/m)+1\n    ll=n\/\/m\n    print(min(((ul*m)-n)*a, (n-(ll*m))*b))\nelse:\n    print(0)","output":"linear"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\n\ndp = [[1 for j in range(5)] for i in range(n)]\nPrev = [[-1 for i in range(5)] for i in range(n)]\n\nfor i in range(1, n):\n    for j in range(5):\n        for finger in range(5):\n            if dp[i - 1][finger] == 1:\n                if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j):\n                    dp[i][j] = 1\n                    Prev[i][j] = finger\n                    break\n        else:\n            dp[i][j] = 0\nfinger = 0\nfor j in range(5):\n    if dp[-1][j] == 1:\n        finger = j\n        path = [finger]\n        for i in range(n - 1, 0, -1):\n            finger = Prev[i][finger]\n            path.append(finger)\n        path = path[::-1]\n        for i in range(n):\n            print(path[i] + 1, end=' ')\n        break\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans )","output":"cubic"},{"instruction":"from itertools import combinations\n\ndef findsum(comb):\n    sum = 0\n    for song in comb:\n        sum += song[0]\n    return sum\n\ndef finda(a,b,c):\n    if a == 0:\n        return 0\n    if a == 1 and b == 0 and c == 0:\n        return 1\n    else:\n        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))\n\ndef findb(a,b,c):\n    if b == 0:\n        return 0\n    if b == 1 and a == 0 and c == 0:\n        return 1\n    else:\n        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))\n\ndef findc(a,b,c):\n    if c == 0:\n        return 0\n    if c == 1 and a == 0 and b == 0:\n        return 1\n    else:\n        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))\n\nn, T = map(int,input().split())\nsongs = []\ntotal_combinations = 0\nfor i in range(n):\n    t, g = map(int,input().split())\n    songs.append([t,g])\n\nfor i in range(1, n+1):\n    allcomb = list(combinations(songs,i))\n    for comb in allcomb:\n        sum = findsum(comb)\n\n        if sum == T:\n            a = 0\n            b = 0\n            c = 0\n            for song in comb:\n                if song[1] == 1:\n                    a += 1\n                elif song[1] == 2:\n                    b += 1\n                else:\n                    c += 1\n            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)\ntotal_combinations = total_combinations%1000000007\nprint(total_combinations)","output":"np"},{"instruction":"n,m,k=list(map(int,input().split()))\np=[]\nfor _ in range(n):\n    p.append(list(map(int,input().split())))\nq=[]\nfor _ in range(n-1):\n    q.append(list(map(int,input().split())))\ndef f(g):\n    r=[[0]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            l=[]\n            if i-1>=0:\n                l.append(g[i-1][j]+q[i-1][j])\n            if i+1<n:\n\n                l.append(g[i+1][j]+q[i][j])\n            if j-1>=0:\n                l.append(g[i][j-1]+p[i][j-1])\n            if j+1<m:\n                l.append(g[i][j+1]+p[i][j])\n            r[i][j]=min(l)\n    return r\ng=[[0]*m for _ in range(n)]\nif k%2!=0:\n    for i in range(n):\n        for j in range(m):\n            g[i][j]=-1\n        print(*g[i])\nelse:\n    for _ in range(k\/\/2):\n       g=f(g)\n    for i in range(n):\n        for j in range(m):\n            g[i][j]*=2\n        print(*g[i])","output":"cubic"},{"instruction":"def prefix_func(s):\n    slen, k = len(s), 0\n    p = [0]*slen\n    p[0] = 0\n    for i in range(1, slen):\n        while k>0 and s[k] != s[i]:\n            k = p[k-1]\n        if s[k] == s[i]:\n            k += 1\n        p[i] = k\n    return p\nn,k=map(int,input().split())\ns=input()\nl=prefix_func(s)[-1]\nprint(s+s[l:]*(k-1))","output":"quadratic"},{"instruction":"class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n\n        left = self.height(root.left)\n        right = self.height(root.right)\n        if abs(left - right) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def height(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.height(root.left), self.height(root.right))","output":"quadratic"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n\nINF = 10001\nmod = int(1e9) + 7\n\ndef cal(l,r):\n    if l==r:\n        dp1[l][r]=a[l]\n        dp3[l][r] = 1\n        return dp1[l][r]\n    if dp1[l][r]!=-1:\n        return dp1[l][r]\n    for i in range(l,r):\n        if cal(l,i) == cal(i+1,r) != 0:\n            dp1[l][r]=dp1[l][i]+1\n            dp3[l][r]=1\n        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])\n    if dp1[l][r] == -1:\n        dp1[l][r] = 0\n    return dp1[l][r]\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[-1]*n for i in range(n)]\ndp3=[[10001]*n for i in range(n)]\ncal(0,n-1)\nout(dp3[0][n-1])","output":"cubic"},{"instruction":"import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    def __init__(self):\n        n, m = map(int, input().strip().split())\n        segs = list()\n        for i in range(m):\n            segs.append(list(map(int, input().strip().split())))\n\n        def calc(s, segs):\n            res = 0\n            for x in segs:\n                ones = sum(s[x[0]:x[1] + 1])\n                res += ones * (x[1] - x[0] + 1 - ones)\n            return res\n\n        s1 = [0 for i in range(n)]\n        s2 = [1 for i in range(n)]\n        for i in range(n):\n            if i % 2 == 0:\n                s1[i] = 1\n                s2[i] = 0\n\n        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2\n        print(''.join(map(str, ans)))\n\nsolver()","output":"linear"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\ndp = [ [False,False,False,False,False] for _ in range(n) ]\ndp[0] = [True, True, True, True, True]\nfor i in range(1, n):\n\tfor j in range(5):\n\t\tif a[i] == a[i - 1]:\n\t\t\tfor k in range(5):\n\t\t\t\tif k != j:\n\t\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telif a[i] > a[i - 1]:\n\t\t\tfor k in range(j):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telse:\n\t\t\tfor k in range(j + 1, 5):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\nif dp[-1].count(True) == 0:\n\tprint(-1)\n\texit(0)\nj = 0\nfor k in range(5):\n\tif dp[-1][k]:\n\t\tj = k\nans = []\nfor i in range(n - 1, -1, -1):\n\tans.append(j + 1)\n\tif i == 0:\n\t\tbreak\n\tif a[i] == a[i - 1]:\n\t\tfor k in range(5):\n\t\t\tif k != j and dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telif a[i] > a[i - 1]:\n\t\tfor k in range(j):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telse:\n\t\tfor k in range(j + 1, 5):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\nprint(*ans[::-1])","output":"quadratic"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n\nINF = 10001\nmod = int(1e9) + 7\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[0]*n for i in range(n)]\ndp2=[[n]*n for i in range(n)]\nfor i in range(n-1,-1,-1):\n    dp1[i][i]=a[i]\n    dp2[i][i]=1\n    for j in range(i+1,n):\n        for k in range(i,j):\n            if dp1[i][k] == dp1[k+1][j] != 0:\n                dp1[i][j] = dp1[i][k] + 1\n                dp2[i][j] = 1\n            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])\nout(dp2[0][n-1])","output":"cubic"},{"instruction":"n = int(input())\na = [int(x) for x in input().split()]\n\na_reverse = a.copy()\nstatus = []\nfor i in range(n):\n    a_reverse[a[i]-1] = i\n    status.append(None)\n\npos = a_reverse[n-1]\nstatus[pos] = False\nfails = set()\nfails.add(pos)\nfor i in range(n-1,0,-1):\n    i_ = i-1\n    pos = a_reverse[i_]\n    for k in range((pos+1)%i-1,n,i):\n        if k == pos:\n            continue\n        if k in fails:\n            status[pos] = True\n            break\n    if not status[pos]:\n        status[pos] = False\n        fails.add(pos)\n\nfor i in status:\n    if i == True:\n        result=result+\"A\"\n    else:\n        result=result+\"B\"\n\nprint(result)","output":"quadratic"},{"instruction":"def digit_sum(n):\n\tcnt = 0\n\twhile n:\n\t\tcnt += n % 10\n\t\tn \/\/= 10\n\treturn cnt\n\ndef bsearch(low, high, s):\n\th = high\n\tans = -1\n\twhile low <= high:\n\t\tmid = (low + high) \/\/ 2\n\t\tif mid - digit_sum(mid) >= s:\n\t\t\tans = mid\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid + 1\n\tif ans == -1:\n\t\treturn 0\n\telse:\n\t\treturn h - ans + 1\n\nn, s = map(int, input().split())\nst = 1\nend = 10\ncnt = 0\ncnt += (bsearch(1, n, s))\nprint(cnt)","output":"logn"},{"instruction":"mod = 1000000000+7\ndef fp(x ,y):\n    if y == 1:\n        return x\n    if y == 0:\n        return 1\n    t = fp(x,y\/\/2)%mod\n    if y%2 == 1:\n        return (t*t*x)%mod\n    else:\n        return (t*t)%mod\n\ndef inv(x):\n    return fp(x%mod,mod-2)%mod\n\nn,k=list(map(int,input().split()))\nif not n:\n    print(0)\n    exit()\nif not k:\n    print( (2*n)%mod )\n    exit()\nnumberOfPro =fp(2,k)\nlast = n*numberOfPro\nfirst = (n-1)*numberOfPro+1\nsumOfLast = (last)*(last+1)*inv(2)\nsumOfFirst = first*(first-1)*inv(2)\nnum = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)\nprint(num%mod)","output":"logn"},{"instruction":"from math import ceil, log\nfrom heapq import heappop, heappush, heapify\nt = 1\nfor test in range(t):\n    n,k = map(int, input().split())\n    p = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]\n    maxcoins = [0 for i in range(k)]\n    heapify(maxcoins)\n    ans = list(p)\n    tmpSum = 0\n    tmpSum2 = 0\n    prev = arr[0][1]\n    for ind, power in arr:\n        if power>prev:\n            ans[ind] = tmpSum+c[ind]\n            tmpSum2 = tmpSum\n        else:\n            ans[ind] = tmpSum2+c[ind]\n        heappush(maxcoins, c[ind])\n        tmpSum+=c[ind]\n        tmpSum-=heappop(maxcoins)\n    print(*ans)","output":"nlogn"},{"instruction":"MAX=10**9\ndef main():\n\n    n,m=readIntArr()\n    arrs=[]\n    for _ in range(n):\n        arrs.append(readIntArr())\n\n    def checkPossible(minB):\n        binRepresentations=set()\n        for arr in arrs:\n            binRepresentations.add(convertToBinary(arr,minB))\n        binList=list(binRepresentations)\n        ii=jj=-1\n        n=len(binList)\n        for i in range(n):\n            for j in range(i,n):\n                if binList[i]|binList[j]==(1<<m)-1:\n                    ii=binList[i]\n                    jj=binList[j]\n        if ii!=-1:\n            ansi=ansj=-1\n            for i in range(len(arrs)):\n                b=convertToBinary(arrs[i],minB)\n                if b==ii:\n                    ansi=i\n                if b==jj:\n                    ansj=i\n\n            return (ansi,ansj)\n        else:\n            return None\n\n    def convertToBinary(arr,minB):\n        b=0\n        for i in range(m):\n            if arr[i]>=minB:\n                b|=(1<<i)\n        return b\n\n    minB=-1\n    i=j=-1\n    b=MAX\n    while b>0:\n        temp=checkPossible(minB+b)\n        if temp==None:\n            b\/\/=2\n        else:\n            minB+=b\n            i,j=temp\n    i+=1;j+=1\n    print('{} {}'.format(i,j))\n\n    return\n\nimport sys\ninput=sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n    return [int(x) for x in input().split()]\n\ndef makeArr(*args):\n\n    assert len(args) >= 2, \"makeArr args should be (default value, dimension 1, dimension 2,...\"\n    if len(args) == 2:\n        return [args[0] for _ in range(args[1])]\n    else:\n        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]\n\ndef queryInteractive(x,y):\n    print('? {} {}'.format(x,y))\n    sys.stdout.flush()\n    return int(input())\n\ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n\ninf=float('inf')\nMOD=10**9+7\n\nfor _abc in range(1):\n    main()","output":"np"},{"instruction":"import sys, heapq\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nq = []\nfor i in range(n):\n    heapq.heappush(q, (-arr[i], i))\nres = []\ntemp_k = k\nwhile temp_k:\n    val, idx = heapq.heappop(q)\n    res.append((-val, idx))\n    temp_k -= 1\nres.sort(key=lambda x : x[1])\nans = 0\nfor i in res:\n    ans += i[0]\npath = []\ncnt = 0\nfor i in range(n):\n    if (arr[i], i) in res:\n        path.append(cnt + 1)\n        cnt = 0\n    else:\n        cnt += 1\npath[-1] += n - sum(path)\nprint(ans)\nprint(' '.join(map(str, path)))","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\n\ns = [\"\"] * n\nfor i in range(n):\n    s[i] = input()\n\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == 'B':\n            cnt = 1\n            for k in range(j + 1, m):\n                if s[i][k] == 'B':\n                    cnt += 1\n                else:\n                    break\n\n            print(i + 1 + cnt \/\/ 2, j + 1 + cnt \/\/ 2)\n            exit(0)","output":"quadratic"},{"instruction":"from collections import namedtuple\nn = int(input())\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    tmp = rr[i]\n    v = vertex(tmp, i + 1)\n    if tmp > 1:\n        a.append(v)\n    else:\n        b.append(v)\n    c += tmp\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    if len(a) == 0:\n        print('YES 1')\n        print('1 2')\n    else:\n        print('YES', len(a) - 1 + min(2, len(b)))\n        print(n - 1)\n        for i in range(len(a)):\n            if i == 0:\n                continue\n            print(a[i - 1].id, a[i].id)\n        if len(b) > 0:\n            print(b[0].id, a[0].id)\n        if len(b) > 1:\n            print(b[1].id, a[-1].id)\n        j = 2\n        for i in range(len(a)):\n            if j >= len(b):\n                yes = 1\n                break\n            k = a[i].degree - 2\n            yes = 0\n            for t in range(k):\n                print(a[i].id, b[j].id)\n                j += 1\n                if j >= len(b):\n                    yes = 1\n                    break\n            if yes == 1:\n                break","output":"linear"},{"instruction":"from collections import deque, defaultdict, Counter\nfrom itertools import product, groupby, permutations, combinations\nfrom math import gcd, floor, inf, log2, sqrt, log10\nfrom bisect import bisect_right, bisect_left\nfrom statistics import mode\nfrom string import ascii_uppercase\n\ncases = int(input())\nmatrix1 = []\nfor _ in range(cases):\n    matrix1.append(list(input()))\n\nmatrix2 = []\nfor _ in range(cases):\n    matrix2.append(list(input()))\n\ndef transpose(matrix):\n    return [list(x) for x in zip(*matrix)]\n\ndef reverse_row(matrix):\n    return matrix[::-1]\n\ndef reverse_column(matrix):\n    return [x[::-1] for x in matrix]\ndef rotate_90(matrix):\n\n    return reverse_row(transpose(matrix))\n\ndef rotate_180(matrix):\n\n    return reverse_row(reverse_column(matrix))\ndef rotate_270(matrix):\n\n    return reverse_column(transpose(matrix))\n\nif matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \\\n    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):\n    print(\"Yes\")\n\n    exit()\n\nmatrix2 = reverse_row(matrix2)\nif matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \\\n    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):\n    print(\"Yes\")\n    exit()\n\nmatrix2 = reverse_column(matrix2)\nif matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \\\n    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):\n    print(\"Yes\")\n    exit()\nmatrix2 = transpose(matrix2)\nif matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \\\n    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):\n    print(\"Yes\")\n    exit()\nelse:\n    print(\"No\")","output":"quadratic"},{"instruction":"import atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a*x+b + vy\n        dd = a*nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx,vy) not in dc[dd]:\n            dc[dd][(vx,vy)] = 0\n        dc[dd][(vx,vy)] += 1\n\n    tot = 0\n    for v,k in dc.items():\n        tt = 0\n        pp =0\n        for _,cc in k.items():\n            tt -= cc * (cc+1) \/\/ 2\n            pp += cc\n        tt += pp * (pp+1) \/\/ 2\n        tot += tt*2\n    print(tot)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        MOD = 998244353\n        N = 1000007\n        pow2 = [0] * N\n\n        n = int(input())\n        a = list(map(int, input().strip().split()))\n\n        pow2[0] = 1\n        for i in range(n):\n            pow2[i + 1] = (2 * pow2[i]) % MOD\n\n        res = 0\n        for i in range(1, n):\n            tmp = (a[i - 1] * (n + 2 - i)) % MOD\n            res += (pow2[n - 1 - i] * tmp) % MOD\n            res %= MOD\n        res += a[n - 1]\n        res %= MOD\n        print(res)\n\nsolver()()","output":"linear"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\np = [0] * (n + 1)\nnow = 0\nfor i in range(0, n):\n    if (t[i] == 1):\n        now += a[i]\n    p[i + 1] = p[i]\n    if (t[i] == 0):\n        p[i + 1] += a[i]\ns = 0\nfor i in range(n - k + 1):\n    s = max(s, p[i + k] - p[i])\nprint(now + s)","output":"linear"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nfor x in r:\n    print(*x, sep='')","output":"quadratic"},{"instruction":"import sys\nn=int(input())\n\ni=0\nANS=[]\nwhile n>0:\n    if n==3:\n        ANS=ANS+[2**i,2**i,3*2**i]\n        break\n    x=(n+1)\/\/2\n    ANS=ANS+[2**i]*x\n    n=n-x\n    i+=1\n\nfor a in ANS:\n    print(a,end=\" \")","output":"logn"},{"instruction":"def lower_bound(n, k):\n    low = 1\n    high = k\n    while low < high:\n        mid = low + (high - low) \/\/ 2\n        pipes = mid * k - (mid + 2) * (mid - 1) \/\/ 2\n        if pipes >= n:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef main():\n    n, k = map(int, input().split())\n    if n == 1:\n        print(0)\n    else:\n        ans = lower_bound(n, k)\n        if ans == k:\n            print(-1)\n        else:\n            print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"a=int(input())\nb=str(a)\nc=[]\nfor i in range(2,a+1):\n    if(a%i==0):\n        c.append(i)\n\nl=0\nfor j in c:\n    r=str(j)\n    t=len(r)\n    o=0\n    for p in r:\n        if(p==\"4\" or p==\"7\"):\n            o=o+1\n    if(o==t):\n        l=l+1\nif(l>0):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\nmod=10**9+7\nn,q=map(int,sys.stdin.readline().split())\nS=sys.stdin.readline().strip()\nLR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]\n\nLIST=[0]\nfor s in S:\n    if s==\"1\":\n        LIST.append(LIST[-1]+1)\n    else:\n        LIST.append(LIST[-1])\n\ndef count(m,n,mod):\n    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod\n\nfor l,r in LR:\n    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\nfrom itertools import permutations\n\nk = list(map(int,input().split()))\n\nworked = 0\nfor k1,k2,k3 in permutations(k):\n    worked2 = 1\n    for t in range(10000):\n        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):\n            worked2 = 0\n\n    if worked2:\n        worked = 1\n        break\n\nif worked:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"inp = input().split()\ntotNums, mod = int(inp[0]), int(inp[1])\n\ndef Exp(b,exp):\n\tif exp==0: return 1\n\ttemp = Exp(b,exp>>1)**2\n\tif exp%2==1: temp*=b\n\treturn temp%mod\n\nn = 410\n\nfact, inv = [0 for i in range(n)],[0 for i in range(n)]\nfact[0] = inv[0] = 1;\nfor i in range(1,totNums+1):\n\tfact[i] = fact[i-1]*i%mod\n\tinv[i] = Exp(fact[i],mod-2)\n\ndp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]\nfor i in range(0,totNums+1):\n\tfor j in range(0,i+1):\n\t\tchoose[i][j] = fact[i]*inv[j]*inv[i-j]%mod\npow2 = [Exp(2,i) for i in range(n)]\n\ndp[0][0] = 1\nfor i in range(totNums):\n\tfor j in range(i+1):\n\t\tfor k in range(1,totNums-i+1):\n\t\t\tdp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]\n\t\t\tdp[i+k+1][j+k] %= mod\n\nans = 0\nfor i in range(0,totNums+1):\n\tans = (ans+dp[totNums+1][i])%mod\nprint(ans)","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int, input().strip().split()))\n\namin = min(a)\nfor i in range(n):\n    a[i] -= amin\nans = amin % n\ncnt = 0\nwhile True:\n    if a[ans] <= cnt:\n        break\n    ans = (ans + 1) % n\n    cnt += 1\nprint(ans + 1)","output":"linear"},{"instruction":"n=int(input())\nfor i in range(n):\n\ta,b = map( int, input().split() )\n\tif a>b:\n\t    a,b=b,a\n\tans=0\n\twhile a>0:\n\t\tans+=b\/\/a\n\t\tb%=a\n\t\ta,b=b,a\n\tprint(ans)","output":"constant"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn,m = inpl()\ns = [inpsl(m) for _ in range(n)]\nlampcnt = [0]*m\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == '1':\n            lampcnt[j] += 1\nres = False\nfor i in range(n):\n    only = False\n    for j in range(m):\n        if s[i][j] == '1' and lampcnt[j] == 1:\n            only = True\n    if not only: res = True\nprint('YES' if res else 'NO')","output":"quadratic"},{"instruction":"def isValid(k):\n    last=a[0]\n    count=1\n    step=0\n    i=1\n    if count==k and step+1==n:\n        return True\n    elif count==k:\n        step+=1\n        count=1\n\n    while i<m:\n\n        if step==n:\n            return True\n        if count==k:\n            step+=1\n            count=1\n            if step==n:\n                return True\n            last=a[i]\n        elif a[i]==last:\n            count+=1\n\n            if count==k and step+1==n:\n                return True\n        elif a[i]!=last:\n            last=a[i]\n            count=1\n        i+=1\n    return False\n\nn,m=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nl=1\nh=m\nans=0\n\nwhile l<=h:\n    mid=(l+h)\/\/2\n\n    if isValid(mid)==True:\n        ans=mid\n        l=mid+1\n    else:\n        h=mid-1\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdout\nN,M=map(int,input().split())\nif M%2==0 and N%2==0:\n    for m in range (1,M\/\/2+1):\n        for n in range (1,N+1):\n            stdout.write(str(n)+' '+str(m)+'\\n')\n            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\\n')\nelif M%2==0 and N%2==1:\n    for m in range (1,M\/\/2+1):\n        for i in range (1,N+1):\n            stdout.write(str(i)+' '+str(m)+'\\n')\n            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\\n')\nelse:\n    for m in range (1,(M+1)\/\/2):\n        for n in range (1,N+1):\n            stdout.write(str(n)+' '+str(m)+'\\n')\n            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\\n')\n    if N%2==0:\n        for i in range (1,N\/\/2+1):\n            stdout.write(str(i)+' '+str((M+1)\/\/2)+'\\n')\n            stdout.write(str(N+1-i)+' '+str((M+1)\/\/2)+'\\n')\n    else:\n        for i in range (1,(N+1)\/\/2):\n            stdout.write(str(i)+' '+str((M+1)\/\/2)+'\\n')\n            stdout.write(str(N+1-i)+' '+str((M+1)\/\/2)+'\\n')\n        stdout.write(str((N+1)\/\/2)+' '+str((M+1)\/\/2)+'\\n')","output":"quadratic"},{"instruction":"def req_num(a, b, x, y, z):\n    req_a = (x * 2) + y\n    req_b = (z * 3) + y\n    if (req_a - a) <= 0:\n        ans_a = 0\n    else:\n        ans_a = req_a - a\n    if (req_b - b) <= 0:\n        ans_b = 0\n    else:\n        ans_b = req_b - b\n    return ans_a + ans_b\n\na, b = list(map(int, input().strip().split()))\nx, y, z = list(map(int, input().strip().split()))\nprint(req_num(a, b, x, y, z))","output":"constant"},{"instruction":"t = int(input())\n\nwhile t>0:\n    n, k = input().split()\n    n, k = int(n), int(k)\n\n    if n >= 32:\n        print(\"YES\", n-1)\n        t -= 1\n        continue\n\n    possibleSize = -1\n    sz = 1\n\n    while sz <= n:\n\n        req_cuts = 2**(sz+1) - 2 - sz\n\n        tot_cuts = ((4**sz) - 1) \/\/ 3 + (((2**sz) -1)**2) * (((4**(n-sz)) - 1) \/\/ 3)\n\n        if (req_cuts > k):\n            break\n        if (tot_cuts >= k):\n            possibleSize = sz\n            break\n\n        sz+=1\n\n    if (possibleSize != -1):\n        print(\"YES\", n - possibleSize)\n    else:\n        print(\"NO\")\n\n    t-=1","output":"logn"},{"instruction":"a = int(input())\ns = {}\nans = 0\nfor i in range(a - 1):\n    v, c = map(int, input().split())\n    if v in s:\n        s[v].append(c)\n    else:\n        s[v] = [c]\n    if c in s:\n        s[c].append(v)\n    else:\n        s[c] = [v]\nc = 0\nfor i in range(1, a + 1):\n    if len(s[i]) > 2:\n        c += 1\n        ans = i\nif c > 1:\n    print(\"No\")\nelif c == 0:\n    print(\"Yes\")\n    print(1)\n    for i in s:\n        if len(s[i]) == 1:\n            print(i, end=\" \")\nelse:\n    print(\"Yes\")\n    print(len(s[ans]))\n    k = []\n    for i in s:\n        if len(s[i]) == 1:\n            k.append(i)\n    for i in k:\n        print(min(ans, i), max(ans, i))","output":"linear"},{"instruction":"n, s = map(int, input().split())\n\ndef binsearch(n, s):\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) \/\/ 2\n        digits = sum([int(i) for i in list(str(mid))])\n        if mid - digits >= s:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return right\n\nprint(max(0, n - binsearch(n, s)))","output":"logn"},{"instruction":"if __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    aa = list(map(int,input().split()))\n    ans = 0\n    for start in range(m):\n        ac = aa[:]\n        for i in range(start, n, m):\n            ac[i] -= k\n        cur = 0\n        for i in range(start, n):\n            if i%m == start:\n                cur = max(ac[i] + cur, ac[i])\n            else:\n                cur += ac[i]\n            ans = max(cur, ans)\n    print(ans)","output":"quadratic"},{"instruction":"s = input()\nres = 0\nsolve = 0\nfor pos in range(1,len(s)):\n    for i in range(len(s) - pos):\n        if s[i:i+pos] in s[i+1:]:\n            if solve < pos:\n                solve = pos\nprint(solve)","output":"cubic"},{"instruction":"n = int(input())\nmap1 = [list(input()) for i in range(n)]\nmap2 = [list(input()) for i in range(n)]\n\ndef vFlip (m):\n    return([list(reversed(i)) for i in m])\n\ndef hFlip(m):\n    return(list(reversed(m)))\n\ndef rotate(m):\n    return(list(zip(*reversed(m))))\n\ndef check():\n    global map1\n    for i in range(4):\n        if map1 == map2:\n            return(True)\n        if vFlip(map1)==map2:\n            return(True)\n        if hFlip(map1)==map2:\n            return(True)\n        if vFlip(hFlip(map1))==map2:\n            return(True)\n        map1 = rotate(map1)\n    return(False)\n\nprint('YES' if check() else 'NO')","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\na.sort()\nk = 0\nfor i in range(n) :\n    if a[i] :\n        k += 1\n        for j in range(i + 1, n) :\n            if a[j] and a[j] % a[i] == 0 :\n                a[j] = 0\nprint(k)","output":"quadratic"},{"instruction":"R = lambda: map(int, input().split())\n\nn = int(input())\narr1 = tuple(R())\narr2 = tuple(R())\n\nd = dict()\nans = [0]*n\n\nfor i in range(n):\n    d[i] = [arr1[i], arr2[i]]\n\ndef run():\n    for nn in range(n, 0, -1):\n        s = list()\n        for i in d:\n            if d[i][0] == d[i][1] == 0:\n                s.append(i)\n                ans[i] = nn\n\n        if s:\n            for i in s: del d[i]\n            for i in d:\n                l = r = 0\n                for j in s:\n                    if j < i:\n                        l += 1\n                    else:\n                        r += 1\n                if d[i][0] >= l:\n                    d[i][0] -= l\n                else:\n                    return\n                if d[i][1] >= r:\n                    d[i][1] -= r\n                else:\n                    return\n\n        else:\n            return\n\nrun()\n\nif 0 in ans:\n    print('NO')\n\nelse:\n    print('YES')\n    print(*ans, sep=' ')","output":"quadratic"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\nclass SegTree:\n\n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n\n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n\n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\ndef SieveOfEratosthenes(limit):\n\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        a,b=ria()\n\n        op=0\n        while min(a,b):\n            if a>b:\n                op+=a\/\/b\n                a%=b\n            else:\n                op+=b\/\/a\n                b%=a\n\n        wi(op)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"constant"},{"instruction":"n,k = input().split()\nn,k = int(n),int(k)\n\nini,fin = 1,k-1\nif n == 1:\n\tprint(\"0\")\n\texit(0)\n\nif 1 + (k*(k-1) )\/\/2 < n:\n\tprint(\"-1\")\n\texit(0)\n\nwhile ini < fin:\n\tmid = (ini+fin)\/\/2\n\ts = 1 + (k-1)*mid - (mid*(mid-1))\/\/2\n\tif s>=n:\n\t\tfin = mid\n\telse:\n\t\tini = mid+1\n\nprint(ini)","output":"logn"},{"instruction":"t1, t2, t3 = input().split()\nans = 2\nif t1 == t2 or t2 == t3 or t3 == t1:\n    if t1 == t2 == t3:\n        ans = 0\n    else:\n        ans = 1\naaa = []\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            if k - j == j - i == 1:\n                aaa.append({i, j, k})\nif t1[1] == t2[1] == t3[1] and {int(t1[0]), int(t2[0]), int(t3[0])} in aaa:\n    ans = 0\nelif (t1[1] == t2[1] and (abs(int(t1[0]) - int(t2[0])) == 1 or abs(int(t1[0]) - int(t2[0])) == 2)) or (t1[1] == t3[1] and (abs(int(t1[0]) - int(t3[0])) == 1 or abs(int(t1[0]) - int(t3[0])) == 2)) or (t3[1] == t2[1] and (abs(int(t3[0]) - int(t2[0])) == 1 or abs(int(t3[0]) - int(t2[0])) == 2)):\n    ans = min(1, ans)\nprint(ans)","output":"constant"},{"instruction":"MAX = 1000\nf = [0]\nfor i in range(1, MAX):\n    f.append(f[i - 1] + (1 << (2 * i - 2)))\n\ng = [0]\nfor i in range(1, MAX):\n    g.append(g[i - 1] + (1 << i) - 1)\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split(' '))\n    ans = False\n    for i in range(1, n + 1):\n        if k >= g[i]:\n            if n >= MAX:\n                print(\"YES %d\" % (n - i))\n                ans = True\n            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:\n                print(\"YES %d\" % (n - i))\n                ans = True\n        if ans == True:\n            break\n    if ans == False:\n        print(\"NO\")","output":"linear"},{"instruction":"from sys import stdin,stdout,setrecursionlimit\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\nfrom collections import defaultdict as dd,Counter as C,deque\nfrom math import ceil,gcd,sqrt,factorial,log2,floor\nfrom bisect import bisect_right as br,bisect_left as bl\nimport heapq\n\ndef solve(a,b):\n\tif a == 0:\n\t\treturn 0\n\treturn b\/\/a + solve(b%a,a)\nprint(solve(*mp()))","output":"constant"},{"instruction":"print(\"? 0 0\")\nans00 = input()\nxr = 0\na = 0\nb = 0\ncb = 2 ** 29\nwhile cb:\n\tprint(\"?\", xr + cb, cb)\n\tans11 = input()\n\tprint(\"?\", xr, cb)\n\tif ans11 == ans00:\n\t\tans01 = input()\n\t\tif ans01 == '1':\n\t\t\ta += cb\n\t\t\tb += cb\n\telse:\n\t\tans00 = input()\n\t\tif ans11 == '1':\n\t\t\tb += cb\n\t\telse:\n\t\t\ta += cb\n\t\txr += cb\n\tcb \/\/= 2\nprint(\"!\", a, b)","output":"logn"},{"instruction":"n = int(input())\ni = 0\ns = 0\nwhile True:\n\ttemp = (i+1)*9*(10**i)\n\tif s + temp <= n:\n\t\ts += temp\n\t\ti += 1\n\telse:\n\t\tbreak\ntc = n - s\n\nnd = tc\/\/(i+1) - 1\ntc -= (nd+1)*(i+1)\nf = 10**i + nd\nif tc != 0:\n\tprint(str(10**i+nd+1)[tc-1])\nelse:\n\tprint(str(10**i+nd)[-1])","output":"logn"},{"instruction":"n,p = map(int,input().split())\na  = list(map(int,input().split()))\nforward = [a[0]]\nfor i in range(1,n):\n    forward.append(forward[-1] + a[i])\nsm = sum(a)\nmx = -float('inf')\nfor i in range(n-1):\n    mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p))\nprint(mx)","output":"linear"},{"instruction":"from sys import stdin\n\nline = stdin.readline().rstrip().split()\nx = int(line[0])\nk = int(line[1])\n\nif x == 0:\n    print(0)\nelse:\n    nn = pow(2, k, 1000000007)\n    result = (nn*2*x - nn + 1) % 1000000007\n    print(result)","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    for _ in range(N()):\n        n, m = RL()\n        arr = []\n        for _ in range(n): arr.append(RLL())\n\n        larr = [list(i) for i in zip(*arr)]\n        larr.sort(key = lambda a: max(a), reverse=1)\n        larr = larr[:n]\n\n        res = 0\n\n        def dfs(lst, pos=0):\n            nonlocal res\n            if pos==min(n, len(larr)):\n                res = max(res, sum(lst))\n                return\n\n            for i in range(n):\n                now = larr[pos][i:n]+larr[pos][0:i]\n                nex = [max(now[j], lst[j]) for j in range(n)]\n                dfs(nex, pos+1)\n\n        dfs([0]*n)\n        print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,c = map(int,input().split())\n    a = list(map(int,input().split()))\n    nums = [[0] for _ in range(500001)]\n    freq,minus = [0]*500001,0\n    for i in a:\n        if i == c:\n            minus += 1\n        else:\n            freq[i] += 1\n            nums[i].append(freq[i]-minus)\n    tot = minus\n    suff = [i[:] for i in nums]\n    for i in range(500001):\n        for j in range(len(nums[i])-2,0,-1):\n            suff[i][j] = max(suff[i][j],suff[i][j+1])\n    freq,ans = [0]*500001,tot\n    for i in a:\n        if i == c:\n            continue\n        freq[i] += 1\n        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"a,b=input().split()\nif(a==b):\n    print(\"0\")\nelse:\n    xor=bin(int(a)^int(b))[2:]\n    a=bin(int(a))[2:]\n    b=bin(int(b))[2:]\n    ans=\"\"\n    if a[0]==b[0]:\n        ans+=\"0\"\n    else:\n        ans+=\"1\"\n    for i in range(len(xor)):\n        ans+=\"1\"\n    print(int(ans,2))","output":"logn"},{"instruction":"import bisect\n\ntmp = input().split()\nn = int(tmp[0])\nk = int(tmp[1])\n\nscores = list()\ntimes = list()\nfor i in range(n):\n    tmp = input().split()\n    scores.append(int(tmp[0]))\n    times.append(int(tmp[1]))\n\nsorted_scores = sorted(zip(scores, times), key=lambda y : (y[0], -y[1]), reverse=True)\n\nans = 1\ni = k-2\nwhile i>=0 and (sorted_scores[i] == sorted_scores[k-1]):\n    ans = ans + 1\n    i = i - 1\n\ni = k\nwhile i < n and (sorted_scores[i] == sorted_scores[k-1]):\n    ans = ans + 1\n    i = i + 1\n\nprint(ans)","output":"nlogn"},{"instruction":"q = int(input())\na,s = map(int,input().split())\nif ((a+s-2)<=(q+q-a-s)):\n    print(\"White\")\nelse:\n    print('Black')","output":"constant"},{"instruction":"s1, s2 = input().split()\nans = s1[0]\nfor i in range(1, len(s1)):\n    if s1[i] < s2[0]:ans += s1[i]\n    else:break\nprint(ans + s2[0])","output":"linear"},{"instruction":"import sys, math, queue\n\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[-10**20 for i in range(m)] for i in range(n)]\ndp[0][0] = a[0]-k\n\nfor i in range(1, n):\n\tfor j in range(m):\n\t\tif j == 0:\n\t\t\tdp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k\n\t\telse:\n\t\t\tdp[i][j] = dp[i-1][j-1]+a[i]\n\nans = 0\nfor i in range(n):\n\tans = max(ans, max(dp[i]))\nprint(ans)","output":"quadratic"},{"instruction":"from collections import deque\nfrom collections import OrderedDict\nimport math\n\nimport sys\nimport os\nimport threading\nimport bisect\n\nimport operator\n\nimport heapq\n\nfrom atexit import register\nfrom io import BytesIO\n\nimport io\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nr,g,b = map(int, input().split())\na = []\nfor i in range(3):\n    a.append([int(x) for x in input().split()])\n    a[i].sort(reverse=True)\n\ndp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]\nanswer = 0\n\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i<r and j<g:\n                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])\n            if i<r and k<b:\n                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])\n            if j<g and k<b:\n                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])\n            answer=max(answer, dp[i][j][k])\nprint(answer)\n\nsys.exit(0)\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\np1 = Person(\"heelo\", 27)\n\nprint(help(Person))\n\nage = 26\nname = 'Swaroop'\nprint('\u0412\u043e\u0437\u0440\u0430\u0441 {} -- {} \u043b\u0435\u0442'.format(name, age))\nprint(help(object))","output":"cubic"},{"instruction":"import sys\n\nimport random\n\nn = int(input())\nif n<=3:\n    print('YES')\n    sys.exit()\ncoord = [int(x) for line in sys.stdin for x in line.split()]\n\nX = [coord[2*i] for i in range(n)]\nY = [coord[2*i+1] for i in range(n)]\n\nfor i in range(13):\n    a = random.randint(0,n-1)\n    b = random.randint(0,n-2)\n\n    if a==b:\n        b+=1\n\n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n\n    dx = x1-x0\n    dy = y1-y0\n    not_on_line = []\n    for c in range(n):\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            not_on_line.append(c)\n    if len(not_on_line)<=1:\n        print('YES')\n        sys.exit()\n\n    a = not_on_line[0]\n    b = not_on_line[1]\n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n\n    dx = x1-x0\n    dy = y1-y0\n    can = True\n    for c in not_on_line:\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            can = False\n            break\n    if can:\n        print('YES')\n        sys.exit()\nprint('NO')","output":"nlogn"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\n\nx=L()[0]\nif x<=2:\n    print(x)\n    exit()\nif x%2:\n    n=x\n    lcm=n*(n-1)\/\/gcd(n,n-1)\n    lcm=lcm*(n-2)\/\/gcd(lcm,n-2)\n    print(lcm)\nelse:\n    ans=1\n    for n1 in range(max(1,x-50),x+1):\n        for n2 in range(max(1,x-50),x+1):\n            for n3 in range(max(1,x-50),x+1):\n                lcm=(n1*n2)\/\/(gcd(n1,n2))\n                lcm=(lcm*n3)\/\/gcd(lcm,n3)\n                ans=max(ans,lcm)\n    print(ans)\n\nendtime = time.time()","output":"constant"},{"instruction":"from sys import stdin\n\ndef f(lst, num):\n    new = lst[num:] + lst[:num]\n    return new\n\nt = int(stdin.readline())\nfor i in range(t):\n    row, col = tuple(int(x) for x in stdin.readline().split())\n    lst = list([int(x)] for x in stdin.readline().split())\n\n    for j in range(row-1):\n        line = tuple(int(x) for x in stdin.readline().split())\n        for k in range(len(line)):\n            lst[k].append(line[k])\n\n    lst.sort(key=lambda x: max(x), reverse = True)\n\n    ans = float('-inf')\n    for a in range(4):\n        for b in range(4):\n            for c in range(4):\n                for d in range(4):\n                    if col >= 1:\n                        aa = f(lst[0], a)\n                    else:\n                        aa = (0,)*row\n                    if col >= 2:\n                        bb = f(lst[1], b)\n                    else:\n                        bb = (0,)*row\n                    if col >= 3:\n                        cc = f(lst[2], c)\n                    else:\n                        cc = (0,)*row\n                    if col >= 4:\n                        dd = f(lst[3], d)\n                    else:\n                        dd = (0,)*row\n\n                    ans = max(ans,\n                              sum(max(x[j] for x in (aa, bb, cc, dd))\n                                  for j in range(row)))\n    print(ans)","output":"np"},{"instruction":"def if_spruce(n,l,m):\n    d=[0]*(n+1)\n    for i in range(1,n+1):\n        if m[i]==0:\n            d[l[i]]+=1\n    for i in range(1,n+1):\n        if m[i]>0 and d[i]<3:\n            return \"No\"\n    return \"Yes\"\n\nn=int(input())\nl,m,a=[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nprint(if_spruce(n,l,m))","output":"linear"},{"instruction":"from math import ceil\ndef test(f):\n    for i in range(n):\n        if (r1+ f) > f * lift[i]:\n            return 0\n        f -= (r1 + f) \/ lift[i]\n        if (r1+ f) > f * land[i + 1]:\n            return 0\n        f -= (r1 + f) \/ land[i + 1]\n    return 1\np=int(input())\ntotal_wgt=int(input());r1=total_wgt\nlift=list(map(int,input().split()))\nland=list(map(int,input().split()));n=len(land);ans=1e20\nlift+=[lift[0]];land+=[land[0]]\nl=0.0;r=1e20\nfor i in range(1000):\n  mid=(l+r)\/2.0\n\n  if test(mid):r=mid\n  else:l=mid\nif r<1e19:\n    print('%.17f' %r)\nelse:\n    print(-1)","output":"linear"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\nn = INT()\nl  = []\nd = {}\nsm = 0\n\nfor i in range(n):\n    indx , y  = MAP()\n\n    d[indx] = y\n    sm += y\n\nm = INT()\nfor i in range(m):\n    indx , y = MAP()\n    if indx in d :\n        sm -= d[indx]\n        sm += max(y , d[indx])\n    else:\n        sm += y\n\nprint(sm)","output":"nlogn"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append(ai)\n\ndef check(mid):\n    mask = (1<<m)-1\n    s = set()\n    d = dict()\n    for i in range(n):\n        state = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                state += 1<<j\n\n        if state in s:\n            continue\n        s.add(state)\n        k = state\n        while k>=0:\n\n            k &= state\n            d[k] = i\n            k -= 1\n        need = mask^state\n\n        if need in d:\n            q1, q2 = d[need], i\n            if q1 > q2:\n                q1, q2 = q2, q1\n            return True, (q1, q2)\n\n    return False, (-1, -1)\n\nleft = 0\nright = 10**9+1\ni,j = 0, 0\nwhile right-left>1:\n    mid = (right+left)\/\/2\n    flag, (q1, q2) = check(mid)\n\n    if flag:\n        left = mid\n        i,j = q1, q2\n    else:\n        right = mid\nprint(i+1, j+1)","output":"np"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=None):\n        self.BIT=[0]*(n+1)\n        self.num=n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        self.mod = mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nk = li()\nk.sort()\nk = tuple(k)\n\nans = [(2,4,4),(3,3,3)]\nif k.count(1)>=1:\n    print(\"YES\")\nelif k.count(2)>=2:\n    print(\"YES\")\nelif k.count(3)>=3:\n    print(\"YES\")\nelif k in ans:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] == nums[i + 1]:\n                i += 2\n            else:\n                return nums[i]\n        return nums[i]","output":"nlogn"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\na.sort()\ncount = 0\nfor i in range(n):\n    cur_c = a[i]\n    if not cur_c:\n        continue\n    count += 1\n    for j in range(i+1,n):\n        if a[j]%cur_c == 0:\n            a[j] = 0\nprint(count)","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\nlst=list(map(int,input().split()))\nmaxx=0\narr=[0]*(n+1)\nfor i in range(n):\n    summ=0\n    for j in range(i,n):\n        summ+=lst[j]\n        arr[j-i]=max(arr[j-i], summ\/(j-i+1))\nprint(max(arr[m-1:]))","output":"quadratic"},{"instruction":"n, m = (int(x) for x in input().split())\nboys_out = sorted([int(x) for x in input().split()], reverse=True)\ngirls_in = sorted([int(x) for x in input().split()])\nmax_boy = max(boys_out)\nans = 0\nfor boy in boys_out:\n    ans += boy * m\n\ncount = 0\ni = 0\nfor girl in girls_in:\n    if girl < max_boy:\n        print(-1)\n        quit()\n\n    if girl > max_boy:\n        if count == m - 1:\n            count = 0\n            i += 1\n        if i >= n:\n            print(-1)\n            quit()\n        ans += girl - boys_out[i]\n        count += 1\n\nprint(ans)","output":"nlogn"},{"instruction":"import math\n\nn=int(input())\n\nfor _ in range(n):\n    a,b=map(int,input().split())\n    ans=0\n    while a>0 and b>0:\n        if a>=b:\n            ans+=a\/\/b\n            a=a%b\n        else:\n            ans+=b\/\/a\n            b=b%a\n    print(ans)","output":"constant"},{"instruction":"n, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])","output":"np"},{"instruction":"import sys\nfrom collections import defaultdict\n\nexist_num,new_width = map(int,sys.stdin.readline().strip().split())\nbuildings = []\nfor _ in range(exist_num):\n    center, width = map(int,sys.stdin.readline().strip().split())\n    buildings.append((center-width\/2,center+width\/2))\nbuildings.sort()\npossible_loc = 2\nfor left,right in zip(buildings,buildings[1:]):\n    gap=right[0] - left[1]\n    if gap == new_width:\n        possible_loc += 1\n    elif gap > new_width:\n        possible_loc += 2\n\nprint(possible_loc)","output":"nlogn"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor t in range(ii()):\n    n, k = mi()\n    if n == 1:\n        ans = 'YES 0' if k == 1 else 'NO'\n    elif n == 2:\n        if k <= 2:\n            ans = 'YES 1'\n        elif k == 3 or k > 5:\n            ans = 'NO'\n        else:\n            ans = 'YES 0'\n    elif n <= 32 and k > (4 ** n - 1) \/\/ 3:\n        ans = 'NO'\n    else:\n        c, x = 0, n\n        p2 = 2\n        while x > 0:\n            if c + p2 - 1 > k:\n                break\n            c += p2 - 1\n            x -= 1\n            p2 *= 2\n        ans = 'YES %d' % (x,)\n    print(ans)","output":"logn"},{"instruction":"import sys,io,os\ntry:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nexcept:Z=lambda:sys.stdin.readline().encode()\nY=lambda:[*map(int,Z().split())]\nn,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]\nif k&1:print('\\n'.join(' '.join(['-1']*m)for i in range(n)));quit()\nd=[0]*n*m\nfor _ in range(k\/\/2):\n    nd=[0]*n*m\n    for x in range(n):\n        for y in range(m):\n            v=x*m+y;w=[]\n            if x:w.append(d[v-m]+V[x-1][y])\n            if y:w.append(d[v-1]+H[x][y-1])\n            if x<n-1:w.append(d[v+m]+V[x][y])\n            if y<m-1:w.append(d[v+1]+H[x][y])\n            nd[v]=min(w)\n    d=nd\nprint('\\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))","output":"cubic"},{"instruction":"n , m = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\ndiff = [0] * n\nfor i in range(n):\n\tif a[i] < m:\n\t\tdiff[i] = -1\n\tif a[i] > m:\n\t\tdiff[i] = 1\n\naim = a.index(m)\nleft = {}\nright = {}\nsuml = 0\nfor i in reversed(range(aim + 1)):\n\tsuml += diff[i]\n\tif not suml in left:\n\t\tleft[suml] = 0\n\tleft[suml] += 1\n\nsumr = 0\nfor i in range(aim, n):\n\tsumr += diff[i]\n\tif not sumr in right:\n\t\tright[sumr] = 0\n\tright[sumr] += 1\n\nans = 0\nfor i in left:\n\twk1 = -i\n\tif wk1 in right:\n\t\tans += left[i] * right[wk1]\n\twk1 = 1 - i\n\tif wk1 in right:\n\t\tans += left[i] * right[wk1]\n\nprint(ans)","output":"nlogn"},{"instruction":"def operations(a, b):\n    less = min(a, b)\n    more = max(a, b)\n    ops = 0\n    while less > 0 and more > 0:\n        ops += more \/\/ less\n        more -= less * (more \/\/ less)\n        less, more = more, less\n    return ops\n\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(operations(a, b))","output":"constant"},{"instruction":"x,k = map(int,input().split())\nif x==0:\n    print(0)\n    exit()\nmod = 10**9+7\nprint((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nleft = 0\nright = 10**9+1\nans = (0, 0)\nwhile left < right:\n    mid = (left + right) \/\/ 2\n    masks = {}\n    for i in range(n):\n        mask = 0\n        for j in a[i]:\n            mask <<= 1\n            if j >= mid:\n                mask += 1\n        masks[mask] = i\n    ok = False\n    for m1 in masks:\n        for m2 in masks:\n            if m1 | m2 == ((1 << m) - 1):\n                ok = True\n                ans = (masks[m1]+1, masks[m2]+1)\n                break\n        if ok:\n            break\n    if ok:\n        left = mid+1\n    else:\n        right = mid\nprint(ans[0], ans[1])","output":"np"},{"instruction":"pri=998244353\ndp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)]\nn,k=map(int,input().split())\n\nfor i in range(1,n+1):\n    if(i==1):\n        dp[0][i][1]=2\n        dp[1][i][2]=2\n\n        continue;\n    for j in range(1,(2*i)+1):\n        dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j]))\n\n        dp[0][i][j]%=pri\n        dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2])\n        dp[0][i][j]%=pri\n        dp[1][i][j]%=pri\ny=dp[0][n][k]+dp[1][n][k]\ny%=pri\nprint(y)","output":"np"},{"instruction":"def maxlen():\n    string = input()\n    maxi = 0;\n    for x in range(len(string)):\n        substring = \"\"\n        for y in string[x:]:\n            substring +=y;\n            if string[x:].rfind(substring) != string[x:].find(substring):\n                maxi = max(maxi, len(substring))\n                continue\n    print(maxi)\n\nmaxlen()","output":"cubic"},{"instruction":"import sys\nfrom array import array\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = array('h', [1 << i for i in range(m)])\n    max_bit = 1 << m\n    fullbit = max_bit - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = array('i', [-1]) * max_bit\n        for i in range(n):\n            dp[sum(bit[j] for j in range(m) if mat[i][j] >= x)] = i\n\n        for i in range(max_bit):\n            if dp[i] == -1:\n                continue\n            for j in range(i, max_bit):\n                if dp[j] != -1 and i | j == fullbit:\n                    return dp[i], dp[j]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"from sys import stdin\na, b, c, n = map(int, stdin.readline().split())\nif c > a or c > b:\n    print(-1)\nelse:\n    val = n - ((a - c) + (b - c)) - c\n    print(val if val <= n and val > 0 else -1)","output":"constant"},{"instruction":"fac = [1] * 500\nfinv = [1] * 500\np2 = [1] * 500\n\nn, MOD = map(int, input().split())\n\nfor i in range(len(fac) - 1):\n    fac[i + 1] = fac[i] * (i + 1) % MOD\n    finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD)\n    p2[i + 1] = p2[i] * 2 % MOD\n\nans = 0\ndp = [[0] * (n \/\/ 2 + 2) for _ in range(n + 2)]\ndp[0][0] = 1\nfor i in range(n):\n    for j in range(i + 2, n + 2):\n        for k in range(n \/\/ 2 + 1):\n            dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2]\nans = 0\nfor i in range(1, n \/\/ 2 + 2):\n    ans += dp[n + 1][i] * fac[n - i + 1]\nprint(ans % MOD)","output":"cubic"},{"instruction":"def m():\n\t[x, y, k] = [int(i) for i in input().split()]\n\td=min(x, y)\n\tx-=d\n\ty-=d\n\tk-=d\n\n\tif k-x-y<0:\n\t\tprint(-1)\n\telse:\n\t\tx+=y\n\t\tif x%2 > 0 and k%2>0:\n\t\t\tprint(d+k-1)\n\t\telif x%2 >0:\n\t\t\tprint(d+k-1)\n\t\telif k%2>0:\n\t\t\tprint(d+k-2)\n\t\telse:\n\t\t\tprint(d+k)\n\nn=int(input())\nfor i in range(n):\n\tm()","output":"constant"},{"instruction":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        return max(LIS)","output":"quadratic"},{"instruction":"import sys\nN, M = map(int, input().split())\n\nAns = [(0, 0) for  _ in range(N*M)]\nfor i in range(1, N*M+1):\n    if i % 2:\n        a, b = divmod(i\/\/2, M)\n    else:\n        a, b = divmod(N*M - i\/\/2, M)\n    Ans[i-1] = ' '.join((str(a+1), str(b+1)))\n\nfor a in Ans:\n    sys.stdout.write(f'{a}\\n')","output":"quadratic"},{"instruction":"rr = lambda: input().rstrip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\n\nfrom functools import lru_cache;memo=lru_cache(None)\nfrom sys import setrecursionlimit as srl;srl(10**5)\n\ndef solve(N, A):\n    @memo\n    def dp(i, j, left=0):\n        if i == j:\n            if left == 0:\n                return 1\n            if A[i] == left:\n                return 1\n            return 2\n        if i > j:\n            return 0 if left == 0 else 1\n\n        ans = 1 + dp(i+1, j, A[i])\n        if left >= 1:\n            stack = []\n            for k in range(i, j+1):\n                stack.append(A[k])\n\n                while len(stack) >= 2 and stack[-1] == stack[-2]:\n                    stack.pop()\n                    stack[-1] += 1\n                if len(stack) == 1 and left == stack[-1]:\n                    cand = dp(k+1, j, left+1)\n                    if cand < ans:\n                        ans = cand\n        return ans\n\n    return dp(1, N-1, A[0])\n\nprint(solve(rri(), rrm()))","output":"cubic"},{"instruction":"from sys import stdin,stdout\ndef count(audrey,imba,banget):\n    return((imba-audrey-1)%(banget-1))\n\nn,q=map(int,input().split())\nL=list(map(int,input().split()))\nmaxi=max(L)\nindexmax=L.index(maxi)\nP=[]\nfor i in range(indexmax):\n    P.append((L[0],L[1]))\n    if L[0]<L[1]:\n        L.append(L.pop(0))\n    else:\n        L.append(L.pop(1))\nY=tuple(L[1:])\nfor p in range(q):\n    m=int(stdin.readline())\n    if m<=indexmax:\n        print(str(P[m-1][0])+' '+str(P[m-1][1]))\n    else:\n        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\\n')","output":"linear"},{"instruction":"a, b, c, n = map(int, input().split())\nt = a + b - c\nif a >= n or b >= n or c > a or c > b or t >= n:\n    print(-1)\nelse:\n    print(n - t)","output":"constant"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\ncodd = 0\nceven = 0\nptodd = -1\npteven = -1\nfor i in range(n):\n    if arr[i]%2 == 0:\n        ceven += 1\n        pteven = i\n    else:\n        codd += 1\n        ptodd = i\n\nif ceven == 1:\n    print(pteven+1)\nelse:\n    print(ptodd+1)","output":"linear"},{"instruction":"n = int(input())\nfor i in range(n):\n    a,b = map(int, input().split())\n    a1 = a\n    if a % 2 == 0:\n        a1 += 1\n    b1 = b\n    if b % 2 == 0:\n        b1 -= 1\n    n = 0\n    if a1 <= b1:\n        num = (b1 - a1) \/\/ 2 + 1\n        n = num * (b1 + a1) \/\/ 2\n        n *= -1\n    b2 = b\n    a2 = a\n    if a % 2 == 1:\n        a2 += 1\n    if b % 2 == 1:\n        b2 -= 1\n    n2 = 0\n    if a2 <= b2:\n        num = (b2 - a2) \/\/ 2 + 1\n        n2 = num * (b2 + a2) \/\/ 2\n    print(n + n2)","output":"constant"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque, defaultdict\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = ''\n            for j in range(k):\n                if i>>j&1:\n                    ans = ''.join([ans, s[j]])\n                else:\n                    ans = ''.join([ans, '_'])\n            Ans.add(ans)\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag == 0 or not T:\n        print('NO')\n    else:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n\nmain()","output":"np"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\nfrom math import inf,isinf\n\ndef solve(s,t):\n    if len(t) == 1:\n        if s.count(t[0]):\n            return 'YES'\n        return 'NO'\n    for i in range(1,len(t)):\n        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]\n        dp[0][0] = 0\n        for j in range(len(s)):\n            dp[j+1] = dp[j][:]\n            for k in range(i+1):\n                if k != i and s[j] == t[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])\n                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:\n                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)\n\n        for l in range(len(s)+1):\n            if dp[l][-1] == len(t)-i:\n                return 'YES'\n    return 'NO'\n\ndef main():\n    for _ in range(int(input())):\n        s = input().strip()\n        t = input().strip()\n        print(solve(s,t))\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n,a,b = map(int,input().split())\nc = []\nc = list(map(int,input().split()))\nc.sort()\nl = c[b-1]\nr = 0\nok = False\nfor i in range (b,n-a+1):\n  if c[i] > l:\n    ok = True\n    r = c[i]\n    break\nif ok == True: print(r-l)\nelse: print(0)","output":"nlogn"},{"instruction":"import sys,math\nclass Node:\n    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):\n        self.up=u\n        self.dn=d\n        self.lt=l\n        self.rt=r\n    def __str__(self):\n        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)\n\nn,m,k=list(map(int,sys.stdin.readline().strip().split()))\ngraph=[[Node() for j in range(m)]for i in range(n)]\nfor i in range(n):\n    wts=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(m-1):\n        graph[i][j].rt=wts[j]\n        graph[i][j+1].lt=wts[j]\n\nfor i in range(n-1):\n    wts=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(m):\n        graph[i][j].dn=wts[j]\n        graph[i+1][j].up=wts[j]\n\nans=[[math.inf for j in range(m)]for i in range(n)]\n\nif k%2:\n    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]\n\nelse:\n    def bfs(prsnt,stps):\n\n        if stps==0:\n            return 0\n        else:\n            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:\n                min_cost=math.inf\n                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:\n                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:\n                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)\n                dp[prsnt[0]][prsnt[1]][stps]=min_cost\n                return min_cost\n            else:\n                return dp[prsnt[0]][prsnt[1]][stps]\n\n    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            ans[i][j]=bfs((i,j),k\/\/2)*2\n    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]","output":"cubic"},{"instruction":"list1=list(input())\nlist2=list(input())\nplus1=list1.count('+')\nplus2=list2.count('+')\nminus1=list1.count('-')\nminus2=list2.count('-')\nwths=list2.count('?')\ndef giveFactorial(n,x):\n    if x==0 or x==n or x>n or n==0:\n        return 1\n    else:\n        return giveFactorial(n-1,x-1)+giveFactorial(n-1,x)\na=(giveFactorial(wths,plus1-plus2))\n\nif plus1==plus2 and wths==0:\n    print(1)\nelif wths==0 :\n    print(0)\nelif plus1-plus2>wths or minus1-minus2>wths:\n    print(0)\nelse:\n    print((0.5**(plus1-plus2+minus1-minus2))*a)","output":"np"},{"instruction":"def getArray():\n    return list(map(int, input().split()))\ndef createDP(R, G, B):\n    dp = []\n    for i in range(R):\n        temp1 = []\n        for j in range(G):\n            temp2 = []\n            for k in range(B):\n                temp2.append(-1)\n            temp1.append(temp2)\n        dp.append(temp1)\n    return dp\ndef go(r, g, b, R, G, B, ri, gi, bi, state):\n    if state[ri][gi][bi] != -1 :\n        return state[ri][gi][bi]\n    best = 0\n    if ri < R and gi < G:\n        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))\n    if ri < R and bi < B:\n        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))\n    if gi < G and bi < B:\n        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))\n\n    state[ri][gi][bi] = best\n    return best\n\nR,G,B = map(int, input().split())\nr = getArray()\ng = getArray()\nb = getArray()\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\ndp = createDP(201,201,201)\nprint(go(r, g, b, R, G, B, 0, 0, 0, dp))","output":"cubic"},{"instruction":"import sys\n\nSIZE = 105\na = SIZE * [0]\nb = SIZE * [0]\n\nlr = input().split()\nl = int(lr.pop(0))\nr = int(lr.pop(0))\n\nif l == r:\n    print(0)\n\nelse:\n    len1 = 0\n    len2 = 0\n    while l != 0:\n        a[len1] = l % 2\n        l = int(l\/2)\n        len1 += 1\n\n    while r != 0:\n        b[len2] = r % 2\n        r = int(r\/2)\n        len2 += 1\n\n    tag = 0\n    for i in range(max(len1, len2)-1, 0, -1):\n        if b[i] == 1 and a[i] == 0:\n            tag = i\n            break\n\n    print(pow(2, tag+1)-1)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\ndef validation(n, k, x):\n    if (x*(x+1)) \/\/ 2 - (n-x) == k:\n        return 0\n    if (x * (x + 1)) \/\/ 2 - (n - x) > k:\n        return 1\n    return 2\n\nn, k = getList()\n\nl = 0\nr = 1000000001\nwhile(True):\n    mid = (l+r)\/\/2\n    flag = validation(n, k, mid)\n    if flag == 0:\n        ans = mid\n        break\n    elif flag == 1:\n        r = mid\n    else:\n        l = mid\n\nprint(n - ans)","output":"logn"},{"instruction":"def problem(s, p):\n    for i in range(len(p)):\n        l = p[:i] + ' '\n        r = p[i:] + ' '\n\n        dp = [0] + [None] * i\n\n        for x in s:\n            for j in range(i, -1, -1):\n                if dp[j] is None:\n                    continue\n\n                if l[j] == x:\n                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])\n\n                temp = r[dp[j]]\n                if r[dp[j]] == x:\n                    dp[j] += 1\n\n        if dp[-1] == len(r) - 1:\n            return 'YES'\n\n    return 'NO'\n\nfor _ in range(int(input())):\n    print(problem(input(), input()))","output":"cubic"},{"instruction":"import atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a * x + b + vy\n        dd = a * nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx, vy) not in dc[dd]:\n            dc[dd][(vx, vy)] = 0\n        dc[dd][(vx, vy)] += 1\n\n    tot = 0\n    for v, k in dc.items():\n        tt = 0\n        pp = 0\n        for _, cc in k.items():\n            tt -= cc * (cc + 1) \/\/ 2\n            pp += cc\n        tt += pp * (pp + 1) \/\/ 2\n        tot += tt * 2\n    print(tot)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nn,m=map(int,input().split())\nl=[]\ntot=[]\ndone=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    l.append(input())\ncolsum=[[0 for i in range(m)]for j in range(n)]\nrowsum=[[0 for i in range(m)]for j in range(n)]\ncol=[[0 for i in range(m)]for j in range(n)]\nrow=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            rowsum[i][j]=1\n            colsum[i][j]=1\n            row[i][j]=1\n            col[i][j]=1\nfor i in range(n):\n    for j in range(1,m):\n        if l[i][j]=='.':\n            continue\n        rowsum[i][j]+=rowsum[i][j-1]\nfor i in range(n):\n    for j in range(m-2,-1,-1):\n        if l[i][j]=='.':\n            continue\n        row[i][j]+=row[i][j+1]\nfor i in range(m):\n    for j in range(n-2,-1,-1):\n        if l[j][i]=='.':\n            continue\n        col[j][i]+=col[j+1][i]\nfor i in range(m):\n    for j in range(1,n):\n        if l[j][i]=='.':\n            continue\n        colsum[j][i]+=colsum[j-1][i]\ndef check(x,y):\n    i=x\n    j=y\n    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1\n    if ans==0:\n        return []\n    return [ans]\nh=[[0 for i in range(m+1)]for j in range(n)]\nv=[[0 for i in range(m)]for j in range(n+1)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            ans=check(i,j)\n            for j1 in ans:\n                tot.append([i+1,j+1,j1])\n                h[i][j-j1]+=1\n                h[i][j+j1+1]-=1\n                v[i-j1][j]+=1\n                v[i+j1+1][j]-=1\nfor i in range(n):\n    for j in range(1,m):\n        h[i][j]+=h[i][j-1]\nfor i in range(m):\n    for j in range(1,n):\n        v[j][i]+=v[j-1][i]\n\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:\n            print(-1)\n            sys.exit(0)\nprint(len(tot))\nfor i in tot:\n    print(*i)","output":"quadratic"},{"instruction":"n, k = [int(x) for x in input().split()]\n\nans = \"\"\nwhile len(ans) < n:\n    ans += '1' * ((n - k) \/\/ 2) + '0';\nans = ans[:n]\nprint(ans)","output":"linear"},{"instruction":"n=int(input())\nl1=list(map(int,input().split()))\nif len(list(set(l1)))==1 and l1[0]>0:\n    print(1)\nelse:\n    l2=list(set(l1))\n    x=l1.count(0)\n    if x==0:\n        print(len(l2))\n    else:\n        print(len(l2)-1)","output":"linear"},{"instruction":"def binar(a,st,d):\n    if st==0:\n        return 1\n\n    elif st==1:\n        return a%d\n\n    return (   binar(a**2%d,st\/\/2,d) *  binar(a, st%2,d)   )%d\n\nx,k=map(int,input().split())\n\nif x==0:\n\tprint(0)\n\texit()\n\nres= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007\nprint(res)","output":"logn"},{"instruction":"n, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nprocessed = set()\ncolor = {}\nlength = {}\nans = []\n\ndef exists(p, elt, d):\n    for e in p:\n        if e > elt:\n            if e <= elt + d:\n                return True\n            elif e - d <= elt + d:\n                return False\n    return False\n\ndef exists2(p, elt, d):\n    for e in p:\n        if e > elt:\n            if e <= elt + d:\n                return False\n            elif e - d <= elt + d:\n                return [True, e - d]\n    return False\n\nfor i in range(n):\n    elt = p[i]\n    if elt in processed:\n        ans.append(color[elt])\n    else:\n        processed.add(elt)\n        new = 1\n        run = True\n        for j in range(1, k):\n            if elt - j < 0:\n                break\n            elif (elt - j) not in processed:\n                processed.add(elt - j)\n                new += 1\n            elif length[elt - j] + new <= k:\n                for i2 in range(length[elt - j] + new):\n                    color[elt - i2] = color[elt - j]\n                length[elt] = length[elt - j] + new\n                run = False\n                break\n            else:\n                break\n        if run:\n            for j in range(new):\n                color[elt - j] = elt - new + 1\n            length[elt] = new\ns = str(color[p[0]])\nfor elt in p[1:]:\n    s += ' ' + str(color[elt])\nprint(s)","output":"quadratic"},{"instruction":"import sys\nimport math as mt\nimport bisect\ninput=sys.stdin.readline\n\nt=1\ndef ncr_util():\n    inv[0]=inv[1]=1\n    fact[0]=fact[1]=1\n    for i in range(2,300001):\n        inv[i]=(inv[i%p]*(p-p\/\/i))%p\n    for i in range(1,300001):\n        inv[i]=(inv[i-1]*inv[i])%p\n        fact[i]=(fact[i-1]*i)%p\ndef solve():\n    a=1\n    b=2*n+3\n    c=n+n**2-2*k\n    x1=b+int(mt.sqrt(b**2-4*a*c))\n    x2=b-int(mt.sqrt(b**2-4*a*c))\n    if x1%2==0 and x1\/\/2<=n:\n        return x1\/\/2\n    return x2\/\/2\n\nfor _ in range(t):\n\n    n,k=(map(int,input().split()))\n\n    print(solve())","output":"logn"},{"instruction":"n=int(input())\nprint(int(n\/2+1))","output":"constant"},{"instruction":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = set()\n        nums.sort()\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        tmp = [nums[i], nums[j], nums[k]]\n                        res.add(tuple(tmp))\n        return [list(i) for i in res]","output":"cubic"},{"instruction":"n,k=map(int,input().split())\n\nif k==(n*(n+1))\/\/2:\n    print(0)\nelse:\n    left=0\n    right=n\n    while left<right:\n        mid=(left+right)\/\/2\n        candies=(mid*(mid+1))\/\/2\n        if candies + mid < k + n:\n            left=mid+1\n        else:\n            right=mid\n    print(n-left)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nif n == 1:\n\tprint(a[0])\nelse:\n\tprod_minus = False\n\tfor i in range(n - 1):\n\t\tif a[i] * a[i + 1] <= 0:\n\t\t\tprod_minus = True\n\t\t\tbreak\n\tMin_abs = float(\"inf\")\n\tSum = 0\n\tfor num in a:\n\t\tSum += abs(num)\n\t\tif abs(num) < Min_abs:\n\t\t\tMin_abs = abs(num)\n\n\tif prod_minus:\n\t\tprint(Sum)\n\telse:\n\t\tprint(Sum - 2 * Min_abs)","output":"linear"},{"instruction":"s = input()\nif int(s) < 0:\n    k = int(s)\/10\n    m = s[:len(s)-2]+s[-1]\n    print(max(int(k),int(m)))\n\nelse:\n    print(s)","output":"constant"},{"instruction":"tmp = input().split()\nn = int(tmp[0])\nm = int(tmp[1])\n\na = list()\nb = list()\ndiff = list()\nfor i in range(n):\n    tmp = input().split()\n    a.append(int(tmp[0]))\n    b.append(int(tmp[1]))\n    diff.append(a[i] - b[i])\n\ndiff.sort(reverse=True)\n\nsum_a = sum(a)\ni = 0\nwhile sum_a > m and i < n:\n    sum_a = sum_a - diff[i]\n    i = i + 1\n\nif i >= n and sum_a > m:\n    print(-1)\nelse:\n    print(i)","output":"nlogn"},{"instruction":"def main():\n\tn, pos, l, r=tuple(map(int,input().split()))\n\ttime=0\n\tif l!=1 and r!=n:\n\t\tif abs(pos-l)<abs(pos-r):\n\t\t\ttime+=abs(pos-l)+abs(l-r)+2\n\t\telse:\n\t\t\ttime+=abs(pos-r)+abs(l-r)+2\n\telif l==1 and r!=n:\n\t\ttime+=abs(pos-r)+1\n\telif r==n and l!=1:\n\t\ttime+=abs(pos-l)+1\n\telse:\n\t\ttime+=0\n\tprint(time)\nif __name__=='__main__':\n\tmain()","output":"constant"},{"instruction":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumOfSquares(n)\n        power = lam = 1\n\n        while slow != fast:\n            if power == lam:\n                slow = fast\n                power *= 2\n                lam = 0\n            fast = self.sumOfSquares(fast)\n            lam += 1\n        return True if fast == 1 else False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n \/\/ 10\n        return output","output":"logn"},{"instruction":"n,K=map(int,input().split())\nb=sorted([int(x)for x in input().split()])\nl=cur=0\nfor i in range(1,n):\n    if b[i]==b[i-1]:continue\n    if b[i]>b[i-1]+K:l=i\n    else:cur+=(i-l);l=i\nprint(n-cur)","output":"nlogn"},{"instruction":"import math\n\ndef getdt():\n    return map(int,input().split())\ndef calc(v0,v,a,x):\n    t = (v - v0)\/a\n    x0 = v0 * t + 0.5*a*t*t\n    if x0>=x:\n        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)\/a)\n    return (x0,t)\ndef go(v0,v,a,x):\n    x0,t = calc(v0,v,a,x)\n    return t + (x-x0)\/v\n\na,v = getdt()\nl,d,w = getdt()\nif w>v:\n    w = v\nx,t = calc(0,w,a,d)\nif x==d:\n    print(go(0,v,a,l))\nelse:\n    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))","output":"constant"},{"instruction":"from os import path\nimport sys,time\n\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import *\n\nmaxx = float('inf')\n\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().replace('\\n', '').strip()\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n\nn , k= tup()\ns = S()\n\nfl =0\nl = None\nfor i in range(1, n):\n\tx =s[i:n]\n\tfor j in range(n):\n\t\tif x == s[:j+1]:\n\t\t\tl = j+1\n\t\t\tfl = 1\n\t\t\tbreak\n\tif fl :\n\t\tbreak\nif fl :\n\tans = s + s[l:n]*(k-1)\n\tprint(ans)\nelse:\n\tprint(s*k)\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"quadratic"},{"instruction":"n=int(input())\na=[]\nb=[]\nfor i in range(n):\n    a.append(input())\nfor i in range(n):\n    b.append(input())\n\ndef h(d):\n    c=[]\n    for i in range(n):\n        c.append(d[n-i-1])\n    return c\ndef r(d):\n    c=[]\n    for i in range(n):\n        temp=\"\"\n        for j in range(n):\n            temp+=d[j][n-i-1]\n        c.append(temp)\n    return c\nyes=0\nfor i in range(4):\n    if a==b:\n        print('YES')\n        yes=1\n        break\n    a=r(a)\nif yes==0:\n    a=h(a)\n    for i in range(4):\n        if a==b:\n            print('YES')\n            yes=1\n            break\n        a=r(a)\nif yes==0:\n    print('NO')","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\n\ndef prod(n):\n\tif n%2:\n\t\treturn n*((n+1)\/\/2)\n\telse:\n\t\treturn (n\/\/2)*(n+1)\n\ndef total_count(n, k):\n\tif k >= n:\n\t\treturn (0, 0, 1)\n\telse:\n\t\tcount = 0\n\t\tl = 1; r = k\n\t\ts = prod(k)\n\t\twhile l <= r:\n\t\t\tmid = (l+r)\/\/2\n\t\t\tif n > s - prod(mid) + mid:\n\t\t\t\tr = mid-1\n\t\t\telse:\n\t\t\t\tl = mid+1\n\n\t\tn = n - (s - prod(l) + l)\n\t\tcount += (k-l+1)\n\t\tk = l-1\n\t\treturn (n, k, count)\n\nif prod(k) - (k-1) < n:\n\tprint(-1)\nelif n == 1:\n\tprint(0)\nelif k >= n:\n\tprint(1)\nelse:\n\tn = n-k\n\tk = k-2\n\t(n, k, count) = total_count(n, k)\n\tif n:\n\t\tprint(count+2)\n\telse:\n\t\tprint(count+1)","output":"logn"},{"instruction":"import sys\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, sys.stdin.readline().strip().split())\ndef listinput(): return list(map(int, sys.stdin.readline().strip().split()))\nn=iinput()\ncolor=['purple','green','blue','orange','red','yellow']\ngem=['Power','Time','Space','Soul','Reality','Mind']\nfor _ in range(n):\n    s=input()\n    indexofcolor=color.index(s)\n    color.remove(s)\n    gem.pop(indexofcolor)\nprint(len(gem))\nfor i in gem:\n    print(i)","output":"constant"},{"instruction":"n = int(input())\nx, y = list(map(int, input().split()))\nd0 = max(x - 1, y - 1)\nd1 = max(n - x, n - y)\nprint('White' if d0 <= d1 else 'Black')","output":"constant"},{"instruction":"N, M, K = map(int, input().split())\nA = [int(a) for a in input().split()]\nS = [0]\nfor a in A:\n    S.append(S[-1]+M*a-K)\nMI = [(10**50)] * M\nans = 0\nfor i in range(N+1):\n    MI[i%M] = min(MI[i%M], S[i])\n    for j in range(M):\n        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))\/\/M)\nprint(ans)","output":"quadratic"},{"instruction":"def main():\n\n    def num(left, right, dp, rev, revI):\n        if left > right:\n            return 1\n\n        key = left, rev, revI\n        if key in dp:\n            return dp[key]\n        nonlocal ans\n\n        acc = 0\n\n        for x in ('01' if ans[left]=='\n\n            temp = None\n            if left == right:\n                tmp = x\n            elif ans[right]=='\n                tmp = '01'\n            else:\n                tmp = ans[right]\n\n            for y in tmp:\n                if not ((rev and x>y) or (revI and x==y=='1')):\n                    acc += num(\n                        left+1,\n                        right-1,\n                        dp,\n                        rev and x==y,\n                        revI and x!=y\n                    )\n        dp[key] = acc\n        return acc\n\n    n, k = map(int, input().split())\n    k += 1\n\n    ans = ['\n\n    for i in range(n):\n        ans[i] = '0'\n        tmp = num(0, n-1, {}, True, True)\n\n        if k > tmp:\n            k -= tmp\n            ans[i] = '1'\n\n    if ans[0] == '0':\n        print(''.join(ans))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    import sys, os\n    from time import time\n    if len(sys.argv)>1 and os.path.exists(sys.argv[1]):\n        sys.stdin = open(sys.argv[1], 'rb')\n    st = time()\n    main()\n    print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)","output":"cubic"},{"instruction":"k, n, s, p = map(int, input().split())\nL = (n - 1) \/\/ s + 1\nL *= k\nprint((L - 1) \/\/ p + 1)","output":"constant"},{"instruction":"def func():\n    N = 520\n    K = 12\n    C = 100 * 1000 + 11\n    n, k = [int(x) for x in list(raw_input().split(' '))]\n    c = [0 for _ in range(C)]\n    f = [0 for _ in range(C)]\n\n    dp = [[0 for _ in range(K*(N))] for _ in range(N)]\n\n    a = [int(x) for x in list(raw_input().split(' '))]\n    for x in a:\n        c[x] += 1\n\n    b = [int(x) for x in list(raw_input().split(' '))]\n    for x in b:\n        f[x] += 1\n\n    h = [0]+[int(x) for x in list(raw_input().split(' '))]\n\n    for i in range(n):\n        for j in range(n*k + 1):\n            for cur in range(k+1):\n                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])\n\n    ans = 0\n    for i in range(C):\n        if f[i] != 0:\n            ans += dp[f[i]][c[i]]\n\n    return ans\n\nif __name__ == \"__main__\":\n    print(func())","output":"cubic"},{"instruction":"import os,sys,math\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return len(a)\n\ndef solve():\n    n,m,k=In()\n    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]\n    for i in range(n):\n        z=list(In())\n        for j in range(m-1):\n            rt[i][j]=z[j]\n    for i in range(n-1):\n        z=list(In())\n        for j in range(m):\n            do[i][j]=z[j]\n\n    dp=[[0]*m for i in range(n)]\n    if k%2==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    k\/\/=2\n    dp_next=[[P]*m for i in range(n)]\n    for op in range(k):\n        for i in range(n):\n            for j in range(m):\n                ans=Inf\n                if i!=0:\n                    ans=min(ans,dp[i-1][j]+do[i-1][j])\n                if j!=0:\n                    ans=min(ans,dp[i][j-1]+rt[i][j-1])\n                if i!=n-1:\n                    ans = min( ans , dp[i+1][j]+do[i][j])\n                if j!=m-1 :\n                    ans=min( ans , dp[i][j+1]+rt[i][j])\n                dp_next[i][j]=ans\n\n        for i in range(n):\n            for j in range(m):\n                dp[i][j]=dp_next[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j],end=' ')\n        print()\n\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n\nM = 998244353\nP = 1000000007\nInf=float('inf')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"a=[int(x) for x in input().split()]\nn=a[0]^a[1]\nx=bin(n)[2:]\n\nf=0\nfor i in range(len(x)):\n    if x[i]=='1':\n        f=1\n        break\nl=len(x)-i\nsum=0\nfor i in range(l):\n   sum+=2**i\nif f==0:\n    sum=0\nprint(sum)","output":"logn"},{"instruction":"import sys\nif __name__=='__main__':\n\n    numCases = int(sys.stdin.readline())\n    for i in range(numCases):\n        a, b = sys.stdin.readline().split()\n        a = int(a)\n        b = int(b)\n        total = 0\n        largerNum = max(a,b)\n        smallerNum = min(a,b)\n        while True:\n            div = int(largerNum\/smallerNum)\n            total += div\n            rem = int(largerNum%(smallerNum*div))\n            if rem == 0:\n                break\n            else:\n                largerNum = smallerNum\n                smallerNum = rem\n\n        print(total)","output":"constant"},{"instruction":"n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\n\nif max(b) > min(g):\n    print(-1)\nelse:\n    total = m*sum(b)\n    b.sort()\n    g.sort()\n    while len(g) > 0:\n        current = 0\n        count = 1\n        if len(b) > 0:\n            current = b.pop()\n        while len(g) > 0 and g[-1] > current and count < m:\n            total += g[-1] - current\n            g.pop()\n            count += 1\n        while len(g) > 0 and g[-1] == current:\n            g.pop()\n    print(total)","output":"nlogn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\ngrip=[[-1]*(n-i) for i in range(n)]\ngrip[0]=a.copy()\nfor level in range(1,n):\n    for left in range(n-level):\n        for split in range(level):\n            pl=grip[level-split-1][left]\n            pr=grip[split][left+level-split]\n            if pl==pr!=-1:\n                grip[level][left]=pl+1\npref=[0]*(n+1)\nfor p in range(1,n+1):\n    x=n\n    for j in range(p):\n        l=pref[j]\n        r=grip[p-j-1][j]\n        if r==-1:\n            r=p-j\n        else:\n            r=1\n        x=min(x,l+r)\n    pref[p]=x\nprint(pref[-1])","output":"cubic"},{"instruction":"lst = list()\n\nlst.append(0)\nlst.append(1)\n\nnow = 1\nwhile now <= 1e25 :\n\tnow = now * 4 + 1\n\n\tlst.append(now)\n\nt = int(input())\n\nfor i in range(t):\n\ts = input().split()\n\tn = int(s[0])\n\tk = int(s[1])\n\tif(n >= 34):\n\t\tprint(\"YES \" + str(n - 1))\n\t\tcontinue\n\n\tsek = 0\n\tambil = 1\n\tnyak = 0\n\tcnt = 0\n\n\tsudah = False\n\twhile (sek < n):\n\t\tcnt = cnt + (1 << (sek + 1)) - 1\n\n\t\tif cnt > k:\n\t\t\tprint(\"NO\")\n\t\t\tsudah = True\n\t\t\tbreak\n\n\t\tnext_ambil = (ambil + 1) * 2 - 1\n\t\tsisa = 4 * ambil - next_ambil\n\t\tambil = next_ambil\n\n\t\tsek += 1\n\t\tnyak = nyak + sisa * lst[n - sek]\n\t\tif (nyak + cnt) >= k :\n\t\t\tprint(\"YES \" + str(n - sek))\n\t\t\tsudah = True\n\t\t\tbreak\n\n\tif sudah == False:\n\t\tprint(\"NO\")","output":"linear"},{"instruction":"n = int(input())\narr = [int(x) for x in input().split()]\nx = arr.index(max(arr))\ncur = max(arr)\nl = x - 1\nr = x + 1\nok = 1\nfor i in range(n - 1):\n    if l < 0:\n        ok *= (arr[r] < cur)\n        cur = arr[r]\n        r += 1\n    elif r >= n:\n        ok *= (arr[l] < cur)\n        cur = arr[l]\n        l -= 1\n    else:\n        if arr[l] > arr[r]:\n            ok *= (arr[l] < cur)\n            cur = arr[l]\n            l -= 1\n        else:\n            ok *= (arr[r] < cur)\n            cur = arr[r]\n            r += 1\nprint(\"YES\" if ok else \"NO\")","output":"linear"},{"instruction":"import os\nimport sys\n\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\ndef ok(here):\n\n    have = defaultdict(lambda : -1)\n    for j in range(n):\n        b = a[j]\n        s = ''\n        for i in b:\n            if(i>=here): s+='1'\n            else: s+='0'\n        have[int(s,2)] = j\n\n    for i in range(300):\n        for j in range(300):\n            if(i|j == 2**m-1 and have[i]!=-1 and have[j]!=-1): return (have[i]+1,have[j]+1)\n\n    return -1\n\nn,m = value()\na = []\n\nfor i in range(n): a.append(array())\n\nlow = 0\nhigh = 10**9\n\nwhile(low<=high):\n\n    mid = low + (high - low)\/\/2\n    here = ok(mid)\n\n    if(here != -1):\n        ans = here\n        low = mid+1\n    else:\n        high = mid - 1\n\nprint(*ans)","output":"np"},{"instruction":"n,m,k = [int(y) for y in input().split()]\na = [int(y) for y in input().split()]\na.sort(reverse=True)\nno = 0\nwhile k < m and no < n:\n    k += a[no]-1\n    no += 1\nif k < m:\n    print(-1)\nelse:\n    print(no)","output":"nlogn"},{"instruction":"n = int(input())\nprint([\"YES\", \"NO\"][all(n % i for i in [4, 7, 47, 744, 477])])","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nMAXN = 202\n\ndef main():\n    R, G, B = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    g = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    r.sort()\n    g.sort()\n    b.sort()\n    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]\n    for i in range(1, R+1):\n        for j in range(1, G+1):\n            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]\n    for i in range(1, R+1):\n        for k in range(1, B+1):\n            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]\n    for j in range(1, G+1):\n        for k in range(1, B+1):\n            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]\n    for i in range(1, R+1):\n        for j in range(1, G+1):\n            for k in range(1, B+1):\n                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])\n    print(dp[R][G][B])\n\nmain()","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\nn,k=map(int,input().split())\nA=[int(i) for i in input().split()]\nB=[]\nfor i in range(1,n):\n  B.append(A[i]-A[i-1])\nB.sort()\nprint(sum(B[:n-k]))","output":"nlogn"},{"instruction":"n,q = map(int, raw_input().split())\nnums = list(map(int, raw_input().split()))\n\nm = max(nums)\n\nab = []\nwhile nums[0] < m:\n    ab.append([nums[0], nums[1]])\n    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))\n\nfor i in range(q):\n    mj = int(input())\n    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))\n    print(a + \" \" + b)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    alst = [int(input()) for _ in range(n)]\n    ans = []\n    for a in alst:\n        if a == 1:\n            ans.append(\"1\")\n            print(\".\".join(ans))\n            continue\n        while ans and int(ans[-1]) != a - 1:\n            ans.pop()\n        if not ans:\n            ans.append(str(a))\n        else:\n            ans.pop()\n            ans.append(str(a))\n\n        print(\".\".join(ans))\n\nfor _ in range(int(input())):\n    main()","output":"quadratic"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, i * 2 + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)","output":"np"},{"instruction":"ma = {0:1}\nn, m = [int(x) for x in input().split()]\narr  = [int(x) for x in input().split()]\ns, fla, ans=0,False,0\nfor v in arr:\n    if v == m: fla = True\n    elif v < m: s-= 1\n    elif v > m: s+= 1\n    if fla:\n        ans += ma.get(s, 0) + ma.get(s-1, 0)\n    else:\n            ma[s] = ma.get(s, 0) + 1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\nf = sys.stdin\n\ndef line():\n    return f.readline().strip().split()\n\ndef powers(limit):\n    size = limit+1\n    p = [1]*size\n    for n in range(1,size):\n        p[n] = (2*p[n-1]) % M\n\n    return p\n\ndef binomials(limit):\n    size = limit+1\n    bc = [[0 for k in range(size)] for n in range(size)]\n    for n in range(size):\n        bc[n][0]=1\n\n    for n in range(1,size):\n        for k in range(1,n+1):\n            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]\n            bc[n][k] %= M\n\n    return bc\n\ndef solve():\n\n    size = N+1\n    dp = [[0 for _ in range(size)] for _ in range(size)]\n    dp[1][0]=1\n\n    for i in range(2,size):\n        for k in range(1,i):\n            for j in range(1,k):\n                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]\n                dp[i][j] %= M\n        dp[i][0] = POW[i-1]\n\n    res=0\n    for j in range(0,N-1):\n        res = (res + dp[N][j]) % M\n\n    return str(res)\n\nT = 1\nfor test in range(1,T+1):\n    N,M = map(int,line())\n\n    BC = binomials(N)\n    POW = powers(N)\n\n    print(solve())\n\nf.close()","output":"cubic"},{"instruction":"def formula(n, x):\n    return x*(x + 1)\/\/2 - (n-x)\n\ndef solve():\n    n, k = map(int, input().split())\n    l = 1\n    r = n\n    x = 0\n    while l <= r:\n        x = (l+r)\/\/2\n        res = formula(n, x)\n        if res == k:\n            break\n        elif res < k:\n            l = x + 1\n        else:\n            r = x - 1\n    print(n-x)\n    return\n\nsolve()","output":"logn"},{"instruction":"def f(a, ind):\n    if a[ind] == 0:\n        return -1\n    k = a[ind] \/\/ 14\n    x = a[ind] % 14\n    b = a[:]\n    b[ind] = 0\n    for j in range(14):\n        b[j] += k\n    for j in range(ind + 1, ind + x + 1):\n        j1 = j % 14\n        b[j1] += 1\n    res = 0\n    for j in range(14):\n        if b[j] % 2 == 0:\n            res += b[j]\n    return res\na = list(map(int, input().split()))\nans = 0\nfor i in range(14):\n    cur = f(a, i)\n    ans = max(ans, cur)\nprint(ans)","output":"constant"},{"instruction":"n = int(input())\nrang = list(range(2,n\/\/2+1))\na = [i*(n\/\/i-1) for i in rang]\nprint(sum(a)*4)","output":"linear"},{"instruction":"n = int(input())\n\nt = list(map(int,input().split()))\n\np = sum(t)\nimport math\n\na = math.ceil(p\/2)\n\nu=0\nfor j in range(n):\n    u+=t[j]\n    if u>=a:\n        print(j+1)\n        break","output":"linear"},{"instruction":"import sys\nN, M = map(int, input().split())\n\nAns = [None]*(N*M)\nfor i in range(1, N*M+1):\n    if i % 2:\n        a, b = divmod(i\/\/2, M)\n    else:\n        a, b = divmod(N*M - i\/\/2, M)\n    Ans[i-1] = (a+1, b+1)\nfor a in Ans:\n    sys.stdout.write('{} {}\\n'.format(*a))","output":"quadratic"},{"instruction":"def find(A):\n    from collections import defaultdict\n    A=sorted(A)\n    N=len(A)\n    dic=defaultdict(int)\n    for i in range(N):\n        dic[A[i]]+=1\n\n    checked=[]\n    count=set([])\n    for x in A:\n        if dic[x]>2:\n            return \"cslnb\"\n        if dic[x]==2:\n            count.add(x)\n            y=x-1\n            if y in dic:\n                return \"cslnb\"\n    if len(count)>1:\n        return \"cslnb\"\n\n    if 0 in count:\n        return \"cslnb\"\n\n    temp=0\n    for i in range(N):\n        temp+=A[i]-i\n    if temp%2==1:\n        return \"sjfnb\"\n    return \"cslnb\"\ninput()\nA=list(map(int,input().strip().split(' ')))\nprint(find(A))","output":"nlogn"},{"instruction":"line = input().split()\nl = int(line[0])\nr = int(line[1])\n\ndiff = (r ^ l)\nprint(pow(2, diff.bit_length()) - 1)","output":"logn"},{"instruction":"n = int(input())\nx, y = map(int, input().split())\nna = abs(x - 1) + abs(y - 1)\nnb = abs(n - x) + abs(n - y)\nif na <= nb:\n    print(\"white\")\nelse:\n    print(\"black\")","output":"constant"},{"instruction":"n = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nk = n[2]\nans = 0\ndele = 1\ni = 0\nwhile(i<n[1]):\n\tcount = 1\n\twhile(((i+count)<n[1]) and (a[(i+count)]-dele)\/\/k == (a[i]-dele)\/\/k):\n\t\tcount += 1\n\n\tans += 1\n\tdele += count\n\ti += count\nprint(ans)","output":"linear"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nans = a[-1] - a[0]\ndelta = [-a[i] + a[i - 1] for i in range(1, n)]\ndelta.sort()\nans += sum(delta[:(k-1)])\nprint(ans)","output":"nlogn"},{"instruction":"def f(n):\n    return n + n\/\/2\n\nn = int(input())\nprint(f(n))","output":"constant"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\nk = list(map(int, readline().split()))\n\nans = 'NO'\nif min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1):\n    ans = 'YES'\n\nprint(ans)","output":"constant"},{"instruction":"n, p = map(int, input().split())\n\narr = [int(b) for b in input().split()]\n\nres = []\n\nprefsums = [arr[0]]\n\nfor i in range(1, n):\n    prefsums.append(prefsums[i - 1] + arr[i])\n\nallsum = sum(arr)\n\nif len(arr) == 2:\n    print(arr[0] % p + arr[1] % p)\n    exit()\n\nfor i in range(1, n - 1):\n    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))\n\nprint(max(res))","output":"linear"},{"instruction":"a=input()\nb=int(a)+1\nif b==1 :\n    print(\"0\")\nelif b%2==0 :\n    print(b\/\/2)\nelif b%2!=0 :\n    print(b)","output":"constant"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\nstair = t1 * abs(x - y)\nlift = t2 * (abs(z - x) + abs(x - y)) + t3 * 3\nprint(\"YES\" if lift <= stair else \"NO\")","output":"constant"},{"instruction":"n = int(input())\nar = []\nfor i in range(n):\n    ar.append(input())\nsortedAr = sorted(ar,key=len)\nflag = False\nfor i in range(n-1):\n    if sortedAr[i+1].find(sortedAr[i]) == -1:\n        print('NO')\n        flag = True\n        break\nif not flag:\n    print('YES')\n    for i in sortedAr:\n        print(i)","output":"nlogn"},{"instruction":"n, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nret = 0\nfor i in range(m):\n\tcur = 0\n\tfor j in range(i, n):\n\t\tif j % m == i:\n\t\t\tcur = max(0, cur)\n\t\t\tcur -= k\n\t\tcur += a[j]\n\t\tret = max(ret, cur)\nprint(ret)","output":"quadratic"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef isPrime(n) :\n\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n\n    prime_factors = []\n\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\n\nn=int(input())\npp=n\nnn=n\n\npl=[]\nnl=[]\nwhile pp:\n    pp-=1\n    pl.append(input())\nwhile nn:\n    nn-=1\n    nl.append(input())\nans=0\npmc=pl.count(\"M\")\nmc=nl.count(\"M\")\nif pmc < mc:\n    ans+=mc -pmc\npsc=pl.count(\"S\")\nsc=nl.count(\"S\")\nif psc < sc:\n    ans+=sc -psc\n\nplc=pl.count(\"L\")\nlc=nl.count(\"L\")\nif plc < lc:\n    ans+=lc -plc\n\npxlc=pl.count(\"XL\")\nxlc=nl.count(\"XL\")\nif pxlc < xlc:\n    ans+=xlc -pxlc\n\npxxlc=pl.count(\"XXL\")\nxxlc=nl.count(\"XXL\")\nif pxxlc < xxlc:\n    ans+=xxlc -pxxlc\n\npxxxlc=pl.count(\"XXXL\")\nxxxlc=nl.count(\"XXXL\")\nif pxxxlc < xxxlc:\n    ans+=xxxlc -pxxxlc\n\npxsc=pl.count(\"XS\")\nxsc=nl.count(\"XS\")\nif pxsc < xsc:\n    ans+=xsc -pxsc\n\npxxsc=pl.count(\"XXS\")\nxxsc=nl.count(\"XXS\")\nif pxxsc < xxsc:\n    ans+=xxsc -pxxsc\n\npxxxsc=pl.count(\"XXXS\")\nxxxsc=nl.count(\"XXXS\")\nif pxxxsc < xxxsc:\n    ans+=xxxsc -pxxxsc\nprint(ans)","output":"linear"},{"instruction":"from sys import stdin, stdout\nimport sys\ninput=sys.stdin.readline\n\ndef solve(n, t, tasks):\n    lo = 0\n    hi = n\n\n    res = []\n    curr_res = 0\n\n    tasks.sort(key=lambda x: x[1])\n\n    while lo <= hi:\n        mid = lo + (hi - lo) \/\/ 2\n\n        valid_tasks = []\n        for i in tasks:\n            if i[0] >= mid:\n                valid_tasks.append(i)\n\n        can_do = False\n\n        curr_sum = 0\n        total_used = 0\n        r = []\n        for i in valid_tasks:\n            curr_sum += i[1]\n            total_used += 1\n            r.append(i[2])\n            if curr_sum > t:\n                break\n            elif total_used >= mid:\n                can_do = True\n                curr_res = mid\n                res = r\n                break\n        if can_do:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return curr_res, res\n\ndef main():\n    n, t = (int(x) for x in input().split(\" \"))\n    tasks = []\n    nums = n\n    idx = 1\n    while n:\n        a_i, t_i = (int(x) for x in input().split(\" \"))\n        tasks.append((a_i, t_i, idx))\n        idx += 1\n        n -= 1\n\n    res, res_arry = solve(nums, t, tasks)\n    print(res)\n    print(res)\n    stdout.write(\" \".join(map(str, res_arry)))\n    stdout.write(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nn, m = map(int, input().split())\n\nMAX = 0\nMIN = 10**18\nfor i in range(n):\n    l = i*(i+1)\/\/2\n    r = (n-1-i)*(n-1-i+1)\/\/2\n    MAX= max(MAX, l+r)\n    MIN = min(MIN, l+r)\n\nans = 0\nfor i in range(m):\n    x, d = map(int, input().split())\n    ans += n*x\n    if d  >= 0:\n        ans += d*MAX\n    else:\n        ans += d*MIN\nprint(ans\/n)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,k = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = dict()\n    c = set()\n    l.sort()\n    for i in range (n):\n        if not d.get(l[i]):\n            c.add(l[i])\n            d.setdefault(l[i]*k,1)\n    print(len(c))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"def solve():\n    n = int(input())\n    for d in [2,4]:\n        if n % d != 0:\n            continue\n        temp = int((n\/\/d) ** (0.5))\n        temp -= 1\n        while temp*temp < n\/\/d:\n            temp += 1\n        if temp*temp == n\/\/d:\n            print(\"YES\")\n            return\n    print(\"NO\")\nfor _ in range(int(input())):\n    solve()","output":"constant"},{"instruction":"import sys\n\nsys.setrecursionlimit(10**5)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ninf = 10**16\nmd = 10**9+7\n\ntrie = [{}]\n\ndef push(s, val):\n    now = 0\n    for c in s:\n        if c not in trie[now]:\n            trie[now][c] = len(trie)\n            trie.append({})\n        now = trie[now][c]\n    trie[now][\"end\"] = val\n\ndef match(s):\n    res = []\n    stack = [(0, 0)]\n    while stack:\n        u, i = stack.pop()\n        if i == k:\n            res.append(trie[u][\"end\"])\n            continue\n        if s[i] in trie[u]:\n            stack.append((trie[u][s[i]], i+1))\n        if \"_\" in trie[u]:\n            stack.append((trie[u][\"_\"], i+1))\n    return res\n\nn, m, k = MI()\nfor i in range(n):\n    push(SI(), i)\n\nto = [[] for _ in range(n)]\nfor _ in range(m):\n    s, u = SI().split()\n    u = int(u)-1\n    vv = match(s)\n\n    notmatch = True\n    for v in vv:\n        if u == v: notmatch = False\n        else: to[u].append(v)\n    if notmatch:\n        print(\"NO\")\n        exit()\n\nvis=[-1]*n\ntopo=[]\nfor u in range(n):\n    if vis[u]==1:continue\n    stack=[u]\n    while stack:\n        u=stack.pop()\n        if vis[u]==-1:\n            vis[u]=0\n            stack.append(u)\n            for v in to[u]:\n                if vis[v]==0:\n                    print(\"NO\")\n                    exit()\n                if vis[v]==-1:\n                    stack.append(v)\n        elif vis[u]==0:\n            topo.append(u+1)\n            vis[u]=1\n\nprint(\"YES\")\nprint(*topo[::-1])","output":"np"},{"instruction":"cs = int(input())\n\nfor c in range(cs):\n    l, r = map(int, input().split())\n\n    if l%2 == 0 and r%2 == 0:\n        print((r - l) \/\/ 2 + l)\n    if l%2 == 1 and r%2 == 0:\n        print((r - l + 1) \/\/ 2)\n    if l%2 == 0 and r%2 == 1:\n        print(-(r - l + 1) \/\/ 2)\n    if l%2 == 1 and r%2 == 1:\n        print(-(r - l) \/\/ 2 - l)","output":"constant"},{"instruction":"from sys import stdin,stdout\nfrom math import gcd,sqrt,factorial,pi,inf\nfrom collections import deque,defaultdict\nfrom bisect import bisect,bisect_left\nfrom time import time\nfrom itertools import permutations as per\nfrom heapq import heapify,heappush,heappop,heappushpop\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nS=lambda:input().rstrip('\\r\\n')\nL=lambda:list(R())\nP=lambda x:stdout.write(str(x)+'\\n')\nlcm=lambda x,y:(x*y)\/\/gcd(x,y)\nnCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N\ninv=lambda x:pow(x,N-2,N)\nsm=lambda x:(x**2+x)\/\/2\nN=10**9+7\n\nn,k=R()\ns=0\nfor i in range(k):\n\tx,d=R()\n\ts+=n*x\n\tif d<0:\n\t\ts+=sm(n\/\/2)*d+sm(n\/\/2-(n+1)%2)*d\n\telse:\n\t\ts+=sm(n-1)*d\nprint(s\/n)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for i in range(n)]\n    ans = []\n    le = 0\n    ri = int(1e9)\n\n    def check(mid: int) -> bool:\n        nonlocal ans\n        dic = {}\n        for i in range(n):\n            bit = 0\n            for j in range(m):\n                if a[i][j] >= mid:\n                    bit += 1\n                bit <<= 1\n            dic[bit >> 1] = i\n        for x, idx in dic.items():\n            for y, idy in dic.items():\n                if x | y == 2**m-1:\n                    ans = idx + 1, idy + 1\n                    return True\n        return False\n    while le <= ri:\n        mid = (le + ri) >> 1\n        if check(mid):\n            le = mid + 1\n        else:\n            ri = mid - 1\n    print(ans[0], ans[1])\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap,0,len(heap)-1)\nfrom math import gcd as Gcd\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n\/\/m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii\/\/=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii\/\/=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)","output":"quadratic"},{"instruction":"def main():\n    n, k = map(int, input().split(' '))\n\n    if(k > 2*n):\n        return(0)\n    if(k == 2*n or k==1):\n        return(2)\n\n    iguales = [0]*(k+1)\n    diferentes = [0]*(k+1)\n\n    iguales[1] = 2\n    diferentes[2] = 2\n\n    modulo = 998244353\n\n    for i in range(1, n):\n        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)\n        for j in range(k):\n            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo\n            if(j >= 1):\n                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo\n\n        iguales = auxigual\n        diferentes = auxdiff\n\n    return((iguales[-1] + diferentes[-1]) % modulo)\n\nprint(main())","output":"np"},{"instruction":"def main():\n    def calc(x):\n        if x & 1:\n            return -x + calc(x - 1)\n        return x \/\/ 2\n    n = int(input())\n    for i in range(n):\n        a, b = map(int, input().split())\n        print(calc(b) - calc(a - 1))\n\nmain()","output":"constant"},{"instruction":"import sys,math\n\ndef read_int():\n\treturn int(sys.stdin.readline().strip())\n\ndef read_int_list():\n\treturn list(map(int,sys.stdin.readline().strip().split()))\n\ndef read_string():\n\treturn sys.stdin.readline().strip()\n\ndef read_string_list(delim=\" \"):\n\treturn sys.stdin.readline().strip().split(delim)\n\nk = read_int()\n\nbase_digit_number = 1; expo = 0\n\nwhile k >= base_digit_number:\n\tbase_digit_number += 9*(expo+1)*(10**expo)\n\texpo += 1\n\nbase_digit_number -= 9*(expo)*(10**(expo-1))\n\nans_number = (k - base_digit_number)\/\/expo + 10**(expo-1)\n\nans_digit = str(ans_number)[(k - base_digit_number)%expo]\n\nprint(ans_digit)","output":"logn"},{"instruction":"a, b = sorted(input()), int(input())\nfor i in range(len(a)):\n\tfor j in range(i+1, len(a)):\n\t\tc = int(str.join('', a))\n\t\ta[i], a[j] = a[j], a[i]\n\t\td = int(str.join('', a))\n\t\tif c <= d <= b:\n\t\t    continue\n\t\telse:\n\t\t    a[i], a[j] = a[j], a[i]\nprint(str.join('', a))","output":"cubic"},{"instruction":"print(\"? 0 0\")\nt = int(input())\nA=[]\nB=[]\na=0\nb=0\nfor i in range(30):\n    A.append(-1)\n    B.append(-1)\ni = 29\nd = 2**i\nwhile i>=0:\n    a+=d\n    b+=d\n    print(\"?\", end=' ')\n    print(a, end=' ')\n    print(b)\n    s=int(input())\n    if s == -t:\n        if s==1:\n            A[i]=0\n            B[i]=1\n            b-=d\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n        elif s==-1:\n            A[i]=1\n            a-=d\n            B[i]=0\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n    i-=1\n    d\/\/=2\nd=1\nfor j in range(30):\n    if A[j]==-1:\n        a = a^d\n        print(\"?\", end=' ')\n        print(a, end=' ')\n        print(b)\n        s = int(input())\n        if s==1:\n            A[j]=1\n            B[j]=1\n        else:\n            A[j]=0\n            B[j]=0\n        a = a^d\n    d*=2\nd=1\na=0\nb=0\nfor i in range(30):\n    a+=d*A[i]\n    b+=d*B[i]\n    d*=2\nprint(\"!\", end=' ')\nprint(a, end=' ')\nprint(b)","output":"constant"},{"instruction":"n = int(input())\n\na = input().split()\n\nfor i in range(n):\n    a[i] = int(a[i])\n\nif(n==1):\n    print(a[0])\nelse:\n    sm = 0\n    havePositive = False\n    haveNegative = False\n\n    for c in a:\n        if(c==0):\n            haveNegative = True\n            havePositive = True\n        elif(c>0):\n            havePositive = True\n            sm += c\n        else:\n            haveNegative = True\n            sm -= c\n\n    if(haveNegative and havePositive):\n        print(sm)\n    else:\n        for i in range(n):\n            a[i] = abs(a[i])\n\n        ans = sum(a)\n        low = a[0]\n        for c in a:\n            low = min(low,c)\n\n        print(ans-2*low)","output":"linear"},{"instruction":"n = int(input())+1\nprint(0 if not (n-1) else n\/\/2 if not n&1 else n)","output":"constant"},{"instruction":"d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\",\"orange\":\"Soul\", \"red\":\"Reality\",\"yellow\":\"Mind\"}\n\ni = int(input())\nl = []\nfor x in range(i):\n    d.pop(input())\n\nprint(len(d))\nfor i in d.values() : print(i)","output":"constant"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\na.sort()\n\ntotal_money=sum(a)\ni_have=0\nreaming=total_money-i_have\ncnt=0\nfor i in range(n-1,-1,-1):\n    reaming=total_money-i_have\n    if i_have>reaming:\n        break\n    i_have+=a[i]\n    cnt+=1\nprint(cnt)","output":"nlogn"},{"instruction":"n = int(raw_input())\na = list(raw_input())\nb = list(raw_input())\n\nans = 0\n\nfor i in range(n - 1):\n    if a[i] == b[i]:\n        continue\n    if a[i + 1] == b[i + 1]:\n        continue\n\n    if a[i] == b[i + 1] and a[i + 1] == b[i]:\n        a[i], a[i + 1] = a[i + 1], a[i]\n        ans += 1\n\nfor i in range(n):\n    ans += a[i] != b[i]\n\nprint(ans)","output":"linear"},{"instruction":"n,a,b,c,T=map(int,input().split())\narr=list(map(int,input().split()))\nTcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0\nfor i in range(1,T):\n  for j in range(n):\n    if arr[j]<=i:a1+=1\n\n  ans+=a1*c;a1=0\nb1=0\n\nfor i in range(n):\n  b1=a-((T-arr[i])*b)\n  if b1<=0:ans+=b1;\n  else:ans+=b1\nans1=n*a\nprint(max(ans,ans1))","output":"linear"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\ncost = list(map(int,input().split()))\nans  = float(\"inf\")\nfor i in range(n):\n    m,r = float(\"inf\"),float(\"inf\")\n    for j in range(i):\n        if a[j]<a[i]:\n            m = min(m,cost[j])\n    for k in range(i+1,n):\n        if a[k]>a[i]:\n            r = min(r,cost[k])\n    ans = min(ans,cost[i]+m+r)\nprint(ans if ans!=float(\"inf\") else -1)","output":"quadratic"},{"instruction":"import math\nfrom decimal import Decimal, ROUND_FLOOR\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) \/ 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = int(((3 + discriminant) \/ 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res2 = int(((3 - discriminant) \/ 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res1 = max(res1, res2)\n    print(k - res1 + 1);","output":"logn"},{"instruction":"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}\nn = int(input())\na = []\nfor i in range(n):\n    a.append(input())\nprint(6-len(a))\nfor i in dic:\n    if i not in a:\n        print(dic[i])","output":"constant"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[[float('inf')] * (k \/\/ 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j][0] = 0\n\nfor k1 in range(1, k \/\/ 2 + 1):\n    for i in range(n):\n        for j in range(m):\n            ans = []\n            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])\n            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])\n            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])\n            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])\n            mem[i][j][k1] = min(ans)\n\n[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]","output":"cubic"},{"instruction":"n,l,r,d=[int(i) for i in input().split()]\nop=[int(i) for i in input().split()]\nc=0\nfor i in range(2,2**n):\n    s=0\n    k=0\n    maxx=0\n    minn=1000001\n    x=bin(i)[2:]\n    x='0'*(n-len(x))+x\n    for j in range(n):\n        if x[j]=='1':\n            s+=op[j]\n            k+=1\n            if maxx<op[j]:\n                maxx=op[j]\n            if op[j]<minn:\n                minn=op[j]\n    if l<=s<=r and maxx-minn>=d and k>=2:\n        c+=1\nprint(c)","output":"np"},{"instruction":"n = int(input())\nn = n + n\/\/2\n\nprint(n)","output":"constant"},{"instruction":"n,m=[int(x) for x in input().split()]\na=[int(x) for x in input().split()]\ns=sum(a)\nneed=0\na.sort()\nj=1\nflag=0\nk=max(a)\nif n==1:\n    print(0)\nelse:\n    for i in range(n):\n        if a[i]<j:\n            flag=1\n        else:\n            flag=0\n        if a[i]==1:\n            need+=1\n        elif a[i]>=j and i!=n-1:\n            need+=1\n        elif a[i]>=j and i==n-1 and j<=k:\n            need+=k-j+1\n        else:\n            need+=1\n        if flag!=1:\n            j+=1\n    print(s-need)","output":"nlogn"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append(ai)\n\ndef check(mid):\n    mask = (1<<m)-1\n    s = set()\n    d = dict()\n    for i in range(n):\n        state = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                state += 1<<j\n        if state in s:\n            continue\n        s.add(state)\n        k = state\n        while k>=0:\n            k &= state\n            d[k] = i\n            k -= 1\n        need = mask^state\n        if need in d:\n            q1, q2 = d[need], i\n            if q1 > q2:\n                q1, q2 = q2, q1\n            return True, (q1, q2)\n    return False, (-1, -1)\n\nleft = 0\nright = 10**9+1\ni,j = 0, 0\nwhile right-left>1:\n    mid = (right+left)\/\/2\n    flag, (q1, q2) = check(mid)\n    if flag:\n        left = mid\n        i,j = q1, q2\n    else:\n        right = mid\nprint(i+1, j+1)","output":"np"},{"instruction":"def maximum_candies_after_n_movies(n):\n    return n * (n + 1) \/\/ 2\n\ndef solve1():\n    n,k = list(map(lambda x: int(x), input().split()))\n    m = maximum_candies_after_n_movies(n)\n    current_candies = n\n    eaten_candies = 0\n    while m != k:\n        m = m - current_candies - 1\n        current_candies -= 1\n        eaten_candies += 1\n\n    print(eaten_candies)\n\ndef solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n\n    lower_bound = 0\n    while upper_bound > lower_bound:\n        if upper_bound == lower_bound + 1:\n            u_c = maximum_candies_after_n_movies(upper_bound)\n            if u_c == k:\n                print(n - upper_bound)\n                break\n\n        middle = (upper_bound + lower_bound) \/\/ 2\n        m_candies = maximum_candies_after_n_movies(middle) - (n - middle)\n        if m_candies == k:\n            print(n - middle)\n            break\n        elif m_candies < k:\n            lower_bound = middle\n        else :\n            upper_bound = middle\n\nsolve()","output":"logn"},{"instruction":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            l, r = i + 1, len(numbers) - 1\n            tmp = target - numbers[i]\n            while l <= r:\n                mid = l + (r - l)\/\/2\n                if numbers[mid] == tmp:\n                    return [i + 1, mid + 1]\n                elif numbers[mid] < tmp:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return []","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nimport time\nstart_time = time.time()\n\nimport collections as col\nimport math, string\nfrom functools import reduce\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef solve():\n    L, R = getInts()\n    if L == R:\n        return 0\n    l = len(bin(L)[2:])\n    r = len(bin(R)[2:])\n    while l == r:\n        L -= pow(2,r-1)\n        R -= pow(2,r-1)\n        l = len(bin(L)[2:])\n        r = len(bin(R)[2:])\n    return pow(2,r)-1\n\nprint(solve())","output":"logn"},{"instruction":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dp = [False] * n\n        dp[-1] = True\n\n        for i in range(n - 2, -1, -1):\n            end = min(n, i + nums[i] + 1)\n            for j in range(i + 1, end):\n                if dp[j]:\n                    dp[i] = True\n                    break\n        return dp[0]","output":"quadratic"},{"instruction":"n=int(input())\nans=0\nfor i in range(2,n+1):\n\tfor j in range(2*i,n+1,i):\n\t\tans+=(4*(j\/\/i))\nprint(ans)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nsun, su, ans = 0, 0, 0\ndif = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    sun += a; su += b\n    dif.append(a - b)\nif(su > m):print(-1)\nelif(sun == m):print(0)\nelse:\n    dif.sort()\n    j = n - 1\n    while(sun > m):\n        sun -= dif[j]\n        ans += 1\n        j -= 1\n    print(ans)","output":"nlogn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc=ri()\n    for _ in range(tc):\n        n=ri()\n        a=ria()\n        d=Counter(a)\n        a=sorted(list(set(a)))\n        s=[]\n        c=0\n        for i in a:\n            if d[i]>=4:\n                c=1\n                print(i,i,i,i)\n                break\n            if d[i]>=2:\n                s.append(i)\n        if c==0:\n            lx=9999999999999999999999999999999\n            bx=1\n            for i in range(len(s)-1):\n                l=s[i+1]\n                b=s[i]\n                if l*bx<lx*b:\n                    lx=l\n                    bx=b\n            print(lx,lx,bx,bx)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"nlogn"},{"instruction":"import math\ndef nCr(n,r):\n\tf = math.factorial\n\treturn f(n) \/ f(r) \/ f(n-r)\ndict1 = {'+':0,'-':0,'?':0}\nfor i in input():\n\tdict1[i]+=1\nfor i in input():\n\tif(i=='?'):\n\t\tdict1[i]+=1\n\telse:\n\t\tdict1[i]-=1\nif dict1['+']<0 or dict1['-']<0:\n\tprint(0.000000000000)\nelif dict1['+']==0 and dict1['-']==0:\n\tprint(1.000000000000)\nelif dict1['+'] and dict1['-']:\n\tans = (nCr(dict1['?'], dict1['+'])\/(2**dict1['?']))\n\tprint(\"%.12f\" %ans)\nelse:\n\tans = (1 \/ (2 ** dict1['?']))\n\tprint(\"%.12f\" % ans)","output":"np"},{"instruction":"n = int(input())\nb = list(map(int, input().split(' ')))\n\na = [0] * n\n\nminV = 0\nmaxV = b[0]\n\nm = n \/\/2\n\na[n - 1] = b[0]\n\ni = 1\nj = n - 2\n\nwhile(i < m):\n  if(b[i] - minV > 0 and b[i] - minV <= maxV):\n    a[i] = minV\n    a[j] = b[i] - minV\n    maxV = min(maxV, b[i] - minV)\n  else:\n    a[i] = b[i] - maxV\n    a[j] = maxV\n    minV = max(minV, b[i] - maxV)\n\n  i += 1\n  j -= 1\n\nprint(' '.join(map(str, a)))","output":"linear"},{"instruction":"from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\ndct = defaultdict(int)\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    t = input().strip()\n    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('\/') + 1:]))\n    x = (a + b) \/ c\n    lst[i] = x\n    dct[x] += 1\nfor i in lst:\n    print(dct[i], end=' ')","output":"linear"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)","output":"np"},{"instruction":"n, m = int(input()), int(input())\nvalue = False\nfor j in range(n + 1):\n    if pow(2, j) > m:\n        value = True\n        break\nif value:\n    print(m)\nelse:\n    print(m % pow(2, n))","output":"constant"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\narr=sorted(arr)\nif arr[-1]==1:arr[-1]=2\nelse:arr=[1]+arr[:n-1]\nprint(*arr)","output":"nlogn"},{"instruction":"t = int(input())\n\nfor i in range(0, t) :\n    n, k = [int(x) for x in input().split()]\n    if (n >= 32) :\n        print(\"YES %d\" % (n-1))\n    else :\n        low=0\n        co=-1\n        md = [0]\n        for j in range(1, n):\n            md.append(md[-1]*4 + 1)\n        kk = 0\n        found=0\n        for cut in range(1,n+1) :\n            low += (1<<cut)-1\n            co = 2*co + 3\n            kk += co*md[n-cut]\n            if (k>=low and k<=low+kk) :\n                print(\"YES %d\" % (n-cut))\n                found=1\n                break\n        if (found == 0) : print(\"NO\")","output":"logn"},{"instruction":"from collections import Counter\nimport sys\nreadline = sys.stdin.readline\n\ndef check(A):\n    CA = Counter(A)\n    if CA[0] >= 2:\n        return False\n    cnt = 0\n    for k, v in CA.items():\n        if v > 2:\n            return False\n        if v == 2 and CA[k-1] >= 1:\n            return False\n        if v >= 2:\n            cnt += 1\n    if cnt >= 2:\n        return False\n    L = len(A)\n    if (sum(A) - L*(L-1)\/\/2) % 2 == 0:\n        return False\n    return True\n\nN = int(readline())\nif check(list(map(int, readline().split()))):\n    print('sjfnb')\nelse:\n    print('cslnb')","output":"linear"},{"instruction":"n,k=map(int,input().split())\nsame=[0]*(k+1)\ndiff=[0]*(k+1)\nsame[1]=2\nif k>1:\n    diff[2]=2\nfor i in range(n-1):\n    newsame=[0]*(k+1)\n    newdiff=[0]*(k+1)\n    for i in range(1,k+1):\n        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353\n    for i in range(2,k+1):\n        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353\n    same=newsame\n    diff=newdiff\nprint((same[-1]+diff[-1])%998244353)","output":"np"},{"instruction":"n, m = map( int, input().split() )\na = list( map( int, input().split() ) )\n\nans = sum( a )\na.sort()\nlastlevel = 0\nlevel = 0\ngot = 0\n\nfor i in a:\n    got = max( got, i )\n    level = min( level + 1, got )\n    if i > 0:\n        ans -= 1\n        lastlevel = level\n\nans -= ( got - level )\nprint( ans )","output":"nlogn"},{"instruction":"def solve(mat1: list, mat2: list, K: int) -> list:\n    if K % 2 == 1:\n        res = [[-1] * n for _ in range(m)]\n    else:\n\n        dp = [[[-1] * (K \/\/ 2 + 1) for _ in range(n)] for _ in range(m)]\n        for k in range(K \/\/ 2 + 1):\n            for i in range(m):\n                for j in range(n):\n                    if k == 0:\n                        dp[i][j][k] = 0\n                    else:\n                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]\n                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]\n                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]\n                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]\n        res = [[-1] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] = 2 * dp[i][j][-1]\n    for i in range(m):\n        for j in range(n):\n            if j < n - 1:\n                print(res[i][j], end = ' ')\n            else:\n                print(res[i][j])\n    return\n\nm, n, K = map(int, input().split())\nmat1 = []\nmat2 = []\nfor _ in range(m):\n    mat1.append(list(map(int, input().split())))\nfor _ in range(m - 1):\n    mat2.append(list(map(int, input().split())))\nsolve(mat1, mat2, K)","output":"cubic"},{"instruction":"DR = [1,0,-1,0]\nDC = [0,1,0,-1]\n\nn, m, k = map(int, input().split())\nw = [[[0] * m for _ in range(n)] for _ in range(4)]\nfor r in range(n):\n    for c, e in enumerate(map(int, input().split())):\n        w[1][r][c] = w[3][r][c + 1] = e\nfor r in range(n - 1):\n    for c, e in enumerate(map(int, input().split())):\n        w[0][r][c] = w[2][r + 1][c] = e\n\nINF = 10 ** 9\n\ndef solve():\n    global k\n    global w\n    if k % 2 == 1:\n        return [[-1] * m] * n\n    k \/\/= 2\n    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]\n    for steps in range(1, k + 1):\n        for r in range(n):\n            for c in range(m):\n                best[steps][r][c] = INF\n                for d in range(4):\n                    r2, c2 = r + DR[d], c + DC[d]\n                    if 0 <= r2 < n and 0 <= c2 < m:\n                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])\n    return best[k]\n\nres = solve()\nfor e in res:\n    print(*e)","output":"cubic"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nha={}\nfor i in range(n):\n    ha[a[i]]=i\nremoved=0\nout=\"\"\nfor i in range(n):\n    if ha[b[i]]<removed:\n        out+=\"0 \"\n    else:\n        out+=str(ha[b[i]]-removed+1)+\" \"\n        removed=ha[b[i]]+1\nprint(out[:-1])","output":"linear"},{"instruction":"from sys import stdin,stdout\nn,q=map(int,input().split())\nmod=1000000007\no=[]\ns=[]\nr=m=0\na=input()\nfor i in a:\n    if i=='0':\n        r+=1\n    else:\n        m+=1\n    o.append(r)\n    s.append(m)\nz=[1]\n\nfor i in range(100000):\n    z.append((z[-1]*2)%mod)\nfor j in range(q):\n    l,r=(int(j) for j in stdin.readline().split())\n    m=r-l+1\n    zs=o[r-1]-o[l-1]+(a[l-1]=='0')\n    os=m-zs\n\n    if zs!=0:\n        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)\n    else:\n        print(((z[os]-1)%mod))","output":"linear"},{"instruction":"f=input\nD,E=dict(),[eval(f())for i in range(int(f()))]\nfor e in E:D[e]=D.get(e,0)+1\nfor e in E:print(D[e])","output":"linear"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef solve(node, remain, adj, dp, n, m):\n  if remain == 0:\n    return 0\n\n  key = (node + remain * n * m)\n  mem = dp[key]\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1,\n            adj, dp, n, m) + x[1], adj[node]))\n  dp[key] = ans\n  return ans\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k\/2+1))\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k\/2, adj, dp, n, m) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"def f_pow(a, n):\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return f_pow(a * a, n \/\/ 2)\n    else:\n        return a * f_pow(a, n - 1)\n\ndef get_c(n):\n    if(n > 68):\n        return int(1e40)\n    return (f_pow(4, n) - 4) \/\/ 12\n\ndef get_cc(n):\n    if(n > 51):\n        return int(1e30)\n    return (f_pow(4, n) - 4) \/\/ 12\n\ndef ans(n, k):\n    side = n - 1\n    way = 4\n    cnt_all = get_c(n + 1)\n    c = 2\n    op = 1\n    while (True):\n        if k < op or side < 0:\n            break\n        way_blocks = way - 1\n        if(get_cc(side - 1) > k):\n            return side\n        per_block = get_cc(side + 1)\n        kk = k - op\n        if cnt_all - way_blocks * per_block - op >= kk:\n            return side\n\n        side -= 1\n        op += (1 << c) - 1\n        c += 1\n        way *= 2\n    return -1\n\ndef read():\n    return [int(i) for i in input().split()]\n\nt = int(input())\n\nfor i in range(t):\n    n, k = read()\n    a = ans(n, k)\n    if(a == -1):\n        print(\"NO\")\n    else:\n        print(\"YES {}\".format(a))","output":"logn"},{"instruction":"def l(a):\n    b=bin(a)[2:]\n    b=\"0\"*(e-len(b))+b\n    d=len(b)\n    for i in range(d-1,-1,-1):\n        if b[i]==\"1\":\n            c=d-1-i\n            break\n    if c==0:\n        return -1\n    return (a-2**(c-1))\n\ndef r(a):\n    b=bin(a)[2:]\n    b=\"0\"*(e-len(b))+b\n    d=len(b)\n    for i in range(d-1,-1,-1):\n        if b[i]==\"1\":\n            c=d-1-i\n            break\n    if c==0:\n        return -1\n    return (a+2**(c-1))\n\ndef u(a):\n    b=bin(a)[2:]\n    b=\"0\"*(e-len(b))+b\n    d=len(b)\n    for i in range(d-1,-1,-1):\n        if b[i]==\"1\":\n            c=d-1-i\n            break\n    if c==d-1:\n        return -1\n    else:\n        if b[d-1-c-1]==\"0\":\n            return a+(2**c)\n        else:\n            return a-(2**c)\n\nn,q=list(map(int,input().split()))\ne=len(bin(n)[2:])\nfor i in range(q):\n    a=int(input())\n    b=input()\n    for i in range(len(b)):\n        if b[i]==\"U\":\n            c=u(a)\n            if c!=-1:\n                a=c\n        elif b[i]==\"R\":\n            c=r(a)\n            if c!=-1:\n                a=c\n        elif b[i]==\"L\":\n            c=l(a)\n            if c!=-1:\n                a=c\n    print(a)","output":"np"},{"instruction":"import math\nn=int(input())\nif(n==3):\n    print('1 1 3')\n\nelse:\n    t=1\n    while(t<=n):\n        ct=math.ceil((n\/\/t)\/2)\n        for i in range(0,ct):\n            print(t,end=\" \")\n\n        if(ct==2 and (n\/\/t)%2!=0):\n            t=t*3\n        else:\n            t=t*2\n    print(\" \")","output":"nlogn"},{"instruction":"from sys import stdin,stdout\n\nmod=10**9+7\nt=1\nfor _ in range(t):\n    a=input()\n    b=input()\n    n=len(a)\n    m=len(b)\n    dp=[[0 for i in range(2)] for j in range(m+1)]\n    dp[1][0]=int(b[0])^1\n    dp[1][1]=int(b[0])\n    for i in range(2,m+1):\n        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)\n        dp[i][1]=dp[i-1][1]+int(b[i-1])\n    ans=0\n    for i in range(n):\n        count0=dp[m-n+i+1][0]-dp[i][0]\n        count1=dp[m-n+i+1][1]-dp[i][1]\n        ans+=count0*int(a[i])+count1*(int(a[i])^1)\n    print(ans)","output":"linear"},{"instruction":"def main():\n    high = 10 ** 12\n    n, m, k = map(int, input().split())\n    hozs = []\n    for i in range(n):\n        hozs.append(list(map(int, input().split())))\n    verts = []\n    for i in range(n - 1):\n        verts.append(list(map(int, input().split())))\n    if k % 2:\n        for i in range(n):\n            print(\"-1 \" * m)\n        return\n    k \/\/= 2\n    dp = []\n    for i in range(n):\n        dp.append([])\n        for j in range(m):\n            dp[-1].append([])\n            for kay in range(k + 1):\n                dp[-1][-1].append(0)\n    for depth in range(1, k + 1):\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    up = high\n                else:\n                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]\n                if i == n - 1:\n                    down = high\n                else:\n                    down = verts[i][j] + dp[i + 1][j][depth - 1]\n                if j == 0:\n                    left = high\n                else:\n                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]\n                if j == m - 1:\n                    right = high\n                else:\n                    right = hozs[i][j] + dp[i][j + 1][depth - 1]\n                min_cost = min(up, down, left, right)\n\n                dp[i][j][depth] += min_cost\n    for i in range(n):\n        print(*[2 * dp[i][j][k] for j in range(m)])\nmain()","output":"cubic"},{"instruction":"MOD=1000000007\n\nx,k=map(int,raw_input().split())\n\nif x>0:\n\tans=(pow(2,k+1,MOD)*x)%MOD\n\tans=(ans-pow(2,k,MOD))%MOD\n\tans=(ans+1)%MOD\nelse:\n\tans=0\n\nprint(ans)","output":"logn"},{"instruction":"from collections import deque\nN,M=map(int,input().split())\ntable=[]\n\nfor i in range(M):\n    s,t,c=map(int,input().split())\n    s,t=s-1,t-1\n    table.append((s,t,c))\n\ndef check(k):\n    Lin=[0]*N\n    edge=[[] for i in range(N)]\n    for s,t,c in table:\n        if c>k:\n            Lin[t]+=1\n            edge[s].append(t)\n    Haco=deque()\n    ans=[]\n    for i in range(N):\n        if Lin[i]==0:\n            ans.append(i)\n            Haco.append(i)\n    while Haco:\n        x = Haco.pop()\n        for y in edge[x]:\n            Lin[y]-=1\n            if Lin[y]==0:\n                ans.append(y)\n                Haco.append(y)\n    return ans\nma=10**9+7\nmi=-1\nwhile ma-mi>1:\n    mid=(ma+mi)\/\/2\n    if len(check(mid))==N:\n        ma=mid\n    else:\n        mi=mid\nans=check(ma)\n\ndd={}\nfor i in ans:\n    dd[ans[i]]=i\nnum=0\nanswer=[]\n\nfor i in range(M):\n    s, t, c=table[i]\n    if dd[s]>dd[t] and c<=ma:\n        answer.append(i+1)\n        num+=1\nprint(ma,num)\nprint(' '.join(map(str,answer)))","output":"nlogn"},{"instruction":"from sys import stdin\ns=stdin.readline()\nfor ln in range(len(s),0,-1):\n    for L in range(len(s)-ln+1):\n        if s[L:L+ln] in s[L+1:]:\n            print(ln)\n            exit()\nprint(0)","output":"cubic"},{"instruction":"l, r = map(int, input().split())\ntarget, final = l ^ r, 1\nwhile target:\n    target >>= 1\n    final <<= 1\nprint(final - 1)","output":"logn"},{"instruction":"R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\ndp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]\ndef calc(nr,ng,nb):\n  if dp[nr][ng][nb]!=-1:\n    return dp[nr][ng][nb]\n  res=0\n  if nr<R and ng<G:\n    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])\n  if nr<R and nb<B:\n    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])\n  if ng<G and nb<B:\n    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])\n  dp[nr][ng][nb]=res\n  return res\nprint(calc(0,0,0))","output":"cubic"},{"instruction":"import sys\ndef power(x, y, p) :\n    res = 1\n\n    x = x % p\n\n    while (y > 0) :\n\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\nmod=(10**9)+7\nr,k=map(int,input().split())\nif r==0:\n    print(0)\n    sys.exit()\nprint((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)","output":"logn"},{"instruction":"k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)\/\/i)+10**(i-1))[(k-r)%i]\nprint(ans)","output":"logn"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                cnt += 1\n    even = cnt % 2 == 0\n    q = int(input())\n    ans = []\n    for _ in range(q):\n        l, r = map(int, input().split())\n        len = r - l + 1\n        pairs = len * (len-1) \/\/ 2\n        if pairs % 2 == 1:\n            even = not even\n        if even:\n            ans.append('even')\n        else:\n            ans.append('odd')\n    print('\\n'.join(ans))\n\nmain()","output":"quadratic"},{"instruction":"from math import ceil\n\nn, k = list(map(int, input().strip().split()))\nr = 2*n\ng = 5*n\nb = 8*n\n\nprint(ceil(r\/k)+ceil(g\/k)+ceil(b\/k))","output":"constant"},{"instruction":"pw = [1, 4]\nfor i in range(2, 32):\n    pw.append(pw[i - 1] * 4)\nt = int(input())\nfor cas in range(t):\n    n, k = map(int, input().split())\n    last = 1\n    path = 1\n    ans = n\n    i = 0\n    while True:\n        if((pw[i + 1] - 1) \/\/ 3 > k):\n            ans -= i\n            last = k - (pw[i] - 1) \/\/ 3\n            break\n        i = i + 1\n        path *= 2\n    sp = path * 2 - 1\n    if((ans < 0) or ((ans == 0) and (last > 0))):\n        print(\"No\")\n        continue\n    sq = path * path - sp\n    if (ans == 1) and (last > sq) and (last < sp):\n        print(\"No\")\n        continue\n    elif (ans == 1) and (last >= sp):\n        ans = ans - 1\n    print(\"Yes\", ans)","output":"logn"},{"instruction":"N = int(input())\ns1 = [list(input()) for i in range(N)]\ns2 = [list(input()) for i in range(N)]\n\ndef rotate(s):\n    ret = [[None for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            ret[i][j] = s[j][N-1-i]\n    return ret\n\ndef v_mirror(s):\n    return list(reversed(s))\n\ndef h_mirror(s):\n    return [list(reversed(row)) for row in s]\n\ndef solve():\n    global s1\n    for i in range(4):\n        if s1 == s2: return True\n        if v_mirror(s1) == s2: return True\n        if h_mirror(s1) == s2: return True\n        if v_mirror(h_mirror(s1)) == s2: return True\n        s1 = rotate(s1)\n    return False\n\nprint('Yes' if solve() else 'No')","output":"quadratic"},{"instruction":"n=int(input())\n\nx=1\n\nwhile n>(10**(len(str(x))-1)*9*len(str(x))):\n    n-=10**(len(str(x))-1)*9*len(str(x))\n\n    x*=10\n\nt=len(str(x))\nnadighe=False\nwhile nadighe==False:\n    qw=1\n    nadighe=True\n    while n>(10**(len(str(qw))-1)*9*t):\n        n-=10**(len(str(qw))-1)*9*t\n        nadighe=False\n        qw*=10\n    x+=qw-1\n\nwhile n>len(str(x)):\n    n-=len(str(x))\n    x+=1\nfor i in range(len(str(x))):\n    if n!=0:\n        s=str(x)[i]\n        n-=1\nprint(s)","output":"logn"},{"instruction":"n = int(input())\na = []\nfor i in map(int, input().split()):\n    if abs(-i-1)>abs(i):\n        a.append(-i-1)\n    else:\n        a.append(i)\n\nc = 0\nfor i in a:\n    if i<0:\n        c+=1\nif c%2:\n    me=0\n    for i in range(len(a)):\n        if a[i]<a[me]:\n            me=i\n    a[me]=-a[me]-1\nprint(*a)","output":"linear"},{"instruction":"import sys\nfrom collections import defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    cand = 0\n    tot = 0\n    p = 0\n    while tot < k or tot-(n-p) != k:\n        cand += 1\n        tot += cand\n        p += 1\n\n    print(tot-k)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"from math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *\nfrom fractions import *\nfrom sys import *\nfrom types import CodeType, new_class\n\na = []\nn, m = map(int, input().split())\nminx, miny, maxx, maxy = n, m, 0, 0\nfor x in range(n):\n    a.append(input())\n    for y in range(m):\n        if a[x][y] == 'B':\n            minx = min(minx, x + 1)\n            miny = min(miny, y + 1)\n            maxx = max(maxx, x + 1)\n            maxy = max(maxy, y + 1)\nprint((maxx + minx) \/\/ 2 , (maxy + miny) \/\/ 2)","output":"quadratic"},{"instruction":"import bisect\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        index = bisect.bisect_left(nums, target)\n        return index if index < len(nums) and nums[index] == target else -1","output":"logn"},{"instruction":"import os\nimport heapq\nimport sys\nimport math\nimport operator\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\n\ndef inpt():\n    return [int(k) for k in input().split()]\n\ndef main():\n    n1, n2, n3 = map(int, input().split())\n    ar = [int(x) for x in input().split()]\n    br = [int(x) for x in input().split()]\n    cr = [int(x) for x in input().split()]\n    ar.sort()\n    br.sort()\n    cr.sort()\n    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]\n    for i in range(n1 + 1):\n        for j in range(n2 + 1):\n            for k in range(n3 + 1):\n                if (i and j):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))\n                if (i and k):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))\n                if (k and j):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))\n    print(dp[n1][n2][n3])\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"x, k = (int(x) for x in input().split())\nmod = 10 ** 9 + 7\nif x == 0:\n    print(0)\n    exit()\nif k == 0:\n    print(2 * x % mod)\n    exit()\n\nans = pow(2, k + 1, mod)\nans *= x\nans %= mod\nans -= pow(2, k, mod)\nans += 1\nans %= mod\nans += mod\nans %= mod\n\nprint(ans)","output":"logn"},{"instruction":"n,k = map(int,input().split())\nprint((2*n + k - 1) \/\/ k + (5*n+k-1) \/\/ k + (8*n+k-1)\/\/k)","output":"constant"},{"instruction":"s = input().split(' ')\ns1 = s[0]\ns2 = s[1]\nres = s1[0]\nflag = 0\nfor i in range(1, len(s1)):\n    if(s1[i]>=s2[0]):\n        res+=s2[0]\n        flag = 1\n        break\n    else:\n        res+=s1[i]\nif(flag == 0):\n    res+=s2[0]\nprint(res)","output":"linear"},{"instruction":"a = int(input())\ns = input()\nd = s.count('H')\np = []\nfor i in range(len(s)):\n\tif i+d > len(s):\n\t\tn = d+i - len(s)\n\t\tm = d - n\n\t\th = s[:m] + s[-n:]\n\t\tk = h.count(\"T\")\n\t\tp.append(k)\n\telse:\n\t\th = s[i:d+i]\n\t\tk = h.count(\"T\")\n\t\tp.append(k)\nmi = a\nfor i in range(len(p)):\n\tif p[i] < mi:\n\t\tmi = p[i]\nif s.count(\"H\") == 1 or s.count(\"T\") == 0:\n\tprint(0)\nelse:\n\tprint(mi)","output":"linear"},{"instruction":"n,k=map(int,input().split())\nmod=int(1e9+7)\n\nif n>0:\n    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1\nelse:\n    ans=0\nprint(ans%mod)","output":"logn"},{"instruction":"import math\n\ndef main():\n    buf = input()\n    n = int(buf)\n    buf = input()\n    buflist = buf.split()\n    a = []\n    for i, item in enumerate(buflist):\n        a.append([i+1, int(item)])\n    a = list(reversed(list(sorted(a, key = lambda x:x[1]))))\n    one_deg_count = 0\n    for i in a:\n        if i[1] == 1:\n            one_deg_count += 1\n    if one_deg_count == len(a):\n        if one_deg_count == 2:\n            print(\"YES\", 1)\n            print(1)\n            print(1, 2)\n        else:\n            print(\"NO\")\n        return\n    elif one_deg_count == len(a) - 1:\n        if one_deg_count <= a[0][1]:\n            print(\"YES\", 2)\n            print(one_deg_count)\n            for i in range(one_deg_count):\n                print(a[0][0], a[-i-1][0])\n        else:\n            print(\"NO\")\n        return\n    else:\n        spare_edges = 2\n        for i in range(len(a) - one_deg_count):\n            spare_edges += a[i][1] - 2\n        if spare_edges >= one_deg_count:\n            diameter = len(a) - 1 - one_deg_count + min(one_deg_count, 2)\n            edge_count = 0\n            edge_list = []\n            for i in range(len(a) - one_deg_count - 1):\n                edge_list.append((a[i][0], a[i+1][0]))\n            for i in range(len(a) - one_deg_count):\n                a[i][1] -= 2\n            if one_deg_count > 0:\n                edge_list.append((a[0][0], a[-1][0]))\n                one_deg_count -= 1\n            if one_deg_count > 0:\n                edge_list.append((a[-one_deg_count-2][0], a[-2][0]))\n                one_deg_count -= 1\n            idx = 0\n            for i in range(one_deg_count):\n                edge_list.append((a[idx][0], a[-i-3][0]))\n                a[idx][1] -= 1\n                if a[idx][1] <= 0:\n                    idx += 1\n            print(\"YES\", diameter)\n            print(len(edge_list))\n            for i in edge_list:\n                print(i[0], i[1])\n        else:\n            print(\"NO\")\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"n,m=map(int,raw_input().split())\n\nl=[]\nfor i in range(n):\n\ts=raw_input()\n\tl.append([])\n\tfor j in range(m):\n\t\tl[-1].append(s[j])\n\nans=[]\nfor i in range(n):\n\n\tans.append([])\n\tfor j in range(m):\n\t\tans[-1].append(\".\")\n\nfor i in range(n-2):\n\tfor j in range(m-2):\n\t\tif l[i][j]==\"\n\t\t\tif l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:\n\t\t\t\tans[i][j]=\"\n\t\t\t\tans[i][j+1]=\"\n\t\t\t\tans[i][j+2]=\"\n\t\t\t\tans[i+1][j]=\"\n\t\t\t\tans[i+1][j+2]=\"\n\t\t\t\tans[i+2][j]=\"\n\t\t\t\tans[i+2][j+1]=\"\n\t\t\t\tans[i+2][j+2]=\"\n\nflag = True\nfor i in range(n):\n\tfor j in range(m):\n\t\tif l[i][j]!=ans[i][j]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag==False:\n\t\tbreak\n\nif flag==True:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"from bisect import bisect,bisect_left\n\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n\ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n\ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n\ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)\/\/fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n\ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return per(i,j)\/\/fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n\ndef catalan(n):\n    return com(2*n,n)\/\/(n+1)\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):\n    if a==0:return b\/\/c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b\/\/c*(n+1)+a\/\/c*n*(n+1)\/\/2\n    m=(a*n+b)\/\/c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)\/\/a)%m\n\ndef lowbit(n):\n    return n&-n\n\nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n\n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n\n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):\n        n=len(arr)\n        mx=n.bit_length()\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n\nclass DSU:\n    def __init__(self,n):\n        self.c=[-1]*n\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n\n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n\n    def size(self,x): return -self.c[self.find(x)]\n\nclass UFS:\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n\n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1)\n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n\ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        seen.add(u)\n        for v,w in graph[u]:\n            if v not in d or d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b\/\/gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n\nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\nt=1\nfor i in range(t):\n    n,m,k=RL()\n    h=[]\n    v=[]\n    for i in range(n):\n        h.append(RLL())\n    for i in range(n-1):\n        v.append(RLL())\n    if k&1:\n        for i in range(n):\n            print(*AI(m,-1))\n        exit()\n    k\/\/=2\n    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]\n    for i in range(n):\n        for j in range(m):\n            dp[0][i][j]=0\n    for i in range(1,k+1):\n        for j in range(n):\n            for a in range(m):\n                if j:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])\n                if j+1<n:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])\n                if a:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])\n                if a+1<m:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])\n    for i in range(n):\n        res=[]\n        for j in range(m):\n            res.append(dp[k][i][j])\n        print(*res)","output":"cubic"},{"instruction":"import math\nfrom math import factorial\n\ndef combination(n,r):\n    return float(factorial(n)) \/ float(factorial(r)) \/ float(factorial(n-r))\n\na = input()\nap = a.count('+')\nam = a.count('-')\nb = input()\nbp = b.count('+')\nbm = b.count('-')\nn = b.count('?')\nx = float(ap - bp)\ny = float(am - bm)\nif (x < 0 or y < 0 or x+y != n):\n    print(0.0)\nelse:\n    print(combination(n,x)\/(1<<n))","output":"np"},{"instruction":"dp=[]\nn,k=map(int,input().split())\nfor _ in range(n):\n    p,t=map(int,input().split())\n    dp.append((p,-t))\ndp.sort(reverse=True)\nprint(dp.count(dp[k-1]))","output":"nlogn"},{"instruction":"n,k=[int(x)for x in input().split()]\nns=[int(x) for x in input().split()]\ndone=[None]*256\nans=[None]*n\nfor i in range(n):\n    c=ns[i]\n    if done[c]==None:\n        j=c\n        while True:\n            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):\n                break\n            j-=1\n        j+=1\n        for kk in range(k):\n            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):\n                break\n            if kk+j<=c:\n                done[kk+j]=j\n            else:\n                done[kk+j]=-1\n    elif done[c]==-1:\n        j=c\n        while True:\n            if done[j]!=None and done[j]!=-1:\n                break\n            j-=1\n        a=done[j]\n        for kk in range(j,c+1):\n            done[kk]=a\n    else:\n        pass\n    ans[i]=done[c]\n\nans=[str(x)for x in ans]\nprint(' '.join(ans))","output":"quadratic"},{"instruction":"n,k=map(int,input().split())\nif n>=k:\n    print((k-1)\/\/2)\nelif n*2>k:\n    print(n-k\/\/2)\nelse: print(0)","output":"constant"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\nclass SegTree:\n\n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n\n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n\n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\ndef SieveOfEratosthenes(limit):\n\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        a,b=ria()\n        op=0\n        while True:\n            if b:\n                op+=a\/\/b\n                a%=b\n                a,b=b,a\n            else:\n                break\n        wi(op)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"constant"},{"instruction":"from math import inf\n\nif True:\n    n,m,k = map(int,input().split())\n    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]\n    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]\n    if k%2==1:\n        for _ in range(n):\n            print(*[-1]*m)\n\n    else:\n        dp = [[0]*m for i in range(n)]\n        xx,yy = [0,0,1,-1],[1,-1,0,0]\n        for _ in range(k\/\/2):\n            dp1 = [[inf]*m for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    for kk in range(4):\n                        x1,y1 = i+xx[kk],j+yy[kk]\n                        if kk < 2:\n                            if kk==1:\n                                edge = cosp[i][j-1]\n                            else:\n                                edge=cosp[i][j]\n                        else:\n                            if kk==3 :\n                                edge = cosv[i-1][j]\n                            else:\n                                edge = cosv[i][j]\n                        if edge != inf:\n                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])\n            dp = dp1[:]\n        for i in dp:\n            print(*i)","output":"cubic"},{"instruction":"k = int(input())\nx = [0,9]\ni = 2\ny = 90\nwhile x[-1] < 10**12:\n    x.append(x[-1]+y*i)\n    y *= 10\n    i += 1\nif k in x:\n    print(9)\nelse:\n    for t in range(len(x)):\n        if k < x[t]:\n            break\n    e = k-x[t-1]\n    if t == 1:q=str(e)\n    else:q =str(10**(t-1)+e\/\/t-1)\n    if e%t == 0:\n        print(q[-1])\n    else:\n        q = str(int(q)+1)\n        print(q[e%t-1])","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"def solve(i, j, k):\n    if dp[i][j][k]!=-1:\n        return dp[i][j][k]\n    call = 0\n    if i>0 and j>0:\n        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))\n    if j>0 and k>0:\n        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))\n    if k>0 and i>0:\n        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))\n    dp[i][j][k] = call\n    return call\n\nnr, ng, nb = map(int,input().split())\nR = [0]+list(map(int,input().split()))\nG = [0]+list(map(int,input().split()))\nB = [0]+list(map(int,input().split()))\nR.sort()\nG.sort()\nB.sort()\ndp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]\nans = solve(nr, ng, nb)\nprint(ans)","output":"cubic"},{"instruction":"import math\nmod=10**9 + 7\n\ndef calcpower(num,power,mod):\n\n    if(power==0):\n        return 1\n\n    a=[num,]\n    temp=num\n    for i in range(int(math.log(power,2))):\n\n        temp*=temp\n        temp=temp%mod\n        a.append(temp%mod)\n\n    power=bin(power)[2:]\n\n    power=power[::-1]\n    res=1\n    for i in range(len(power)):\n        if(int(power[i])):\n            res=(res*a[i])%mod\n    return res%mod\nimport sys\n\nx,k=map(int,input().split())\n\nif(x==0):\n    print(0)\n    sys.exit()\nif(k==0):\n    print(2*x%mod)\n    sys.exit()\nans=(2*x-1)*calcpower(2,k,mod)+1\n\nprint(ans%mod)","output":"logn"},{"instruction":"import copy\n\ndef rotate90(n, f):\n    return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]\n\ndef fliphor(n, f):\n    return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]\n\ndef flipver(n, f):\n    return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]\n\ndef eq(n, f, g):\n    for i in range(n):\n        for j in range(n):\n            if f[i][j] != g[i][j]:\n                return False\n    return True\n\nn = int(input())\nf = [list(input()) for i in range(n)]\ng = [list(input()) for i in range(n)]\n\nfor doflipv in range(2):\n    for dofliph in range(2):\n        for nrot in range(4):\n            h = copy.deepcopy(f)\n            if dofliph == 1:\n                h = fliphor(n, h)\n            if doflipv == 1:\n                h = flipver(n, h)\n            for i in range(nrot):\n                h = rotate90(n, h)\n            if eq(n, h, g):\n                print(\"Yes\")\n                exit(0)\n\nprint(\"No\")","output":"quadratic"},{"instruction":"import sys\n\ndef read():\n\treturn sys.stdin.readline()\n\ndef main():\n\tn = int(read())\n\ta = list(map(int, read().split()))\n\ta.sort()\n\tk = 0\n\tused = [0] * n\n\tfor i in range(n):\n\t\tif used[i]:\n\t\t\tcontinue\n\t\tk += 1\n\t\tfor j in range(i, n):\n\t\t\tif a[j] % a[i] == 0:\n\t\t\t\tused[j] = True\n\tprint(k)\n\nif __name__ == '__main__':\n\tmain()","output":"quadratic"},{"instruction":"n,k=map(int,input().split())\narr=list(map(int,input().split()))\nd={}\nfor i in arr:\n\tif i in d:\n\t\td[i]+=1\n\telse:\n\t\td[i]=1\nflag=True\nfor i in range(100,0,-1):\n\tt2=0\n\tfor j in d.values():\n\t\tt2+=j\/\/i\n\tif(t2>=n):\n\t\tprint(i)\n\t\tflag=False\n\t\tbreak\nif(flag):\n\tprint(0)","output":"nlogn"},{"instruction":"kk=lambda:map(int, input().split())\nll=lambda:list(kk())\nn,l,r,d=kk()\np,t=ll(),0\nfor v in range(2**n):\n\ts = []\n\tfor i in range(n):\n\t\tif v&(2**i):\n\t\t\ts.append(p[i])\n\tif l <= sum(s)<=r and max(s)-min(s) >= d: t+=1\nprint(t)","output":"np"},{"instruction":"n, k = [int(i) for i in input().split()]\na, j = sorted([int(i) for i in input().split()]), 0\nfor i in a:\n    while i > a[j]:\n        if i <= a[j] + k:\n            n -= 1\n        j += 1\nprint(n)","output":"nlogn"},{"instruction":"from collections import Counter\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\nfrom functools import reduce\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\n\nmod = int(1e9)+7\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\nif __name__ == \"__main__\":\n    n = iinput()\n    a = rlinput()\n    dp = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dp[i][i] = a[i]\n\n    for l in range(n-2, -1, -1):\n        for r in range(l+1, n):\n            for k in range(l, r):\n                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:\n\n                    dp[l][r] = dp[l][k]+1\n\n    squeeze = [float('inf')]*(n+1)\n    squeeze[0] = 0\n    for i in range(1, n+1):\n        for j in range(i):\n            if dp[j][i-1] != 0:\n                squeeze[i] = min(squeeze[i], squeeze[j]+1)\n\n    print(squeeze[n])","output":"cubic"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef count(x):\n    ans = 0\n    while x:\n        x &= x-1\n        ans += 1\n    return ans\n\ndef main():\n    n = int(input())\n    a = [list(map(float,input().split())) for _ in range(n)]\n    y = 1<<n\n    dp = [0]*(y-1)+[1]\n    powe = [1<<i for i in range(n)]\n    for i in range(y-1,0,-1):\n        bit = count(i)\n        prob = bit*(bit-1)\/\/2\n        for j in range(n):\n            if not i&powe[j]:\n                continue\n            for x in range(n):\n                if not i&powe[x]:\n                    continue\n                dp[i-powe[x]] += dp[i]*a[j][x]*prob\n                dp[i-powe[j]] += dp[i]*a[x][j]*prob\n    z = sum(dp[1<<i] for i in range(n))\n    for i in range(n):\n        print(dp[1<<i]\/z,end=' ')\n    print()\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import sys\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\na = list(map(int, sys.stdin.readline().strip().split()))\nb = [0] * (n+1)\nfor i in range (1, n+1):\n    b[i] = b[i-1] + m * a[i-1] - k\nM = [10 ** 20] * m\nans = 0\nfor i in range (0, n+1):\n    M[i % m] = min([M[i % m], b[i]])\n    for j in range (0, m):\n        if i > j:\n            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])\n\nprint(ans \/\/ m)","output":"quadratic"},{"instruction":"n = int(input())\na = list(set(map(int, input().split())))\nn = len(a)\n\ncnt = 0\nfor i in range(n):\n    f = True\n    for j in range(n):\n        if i == j:\n            continue\n        if a[i] % a[j] == 0:\n            f = False\n    if f:\n        cnt += 1\n\nprint(cnt)","output":"quadratic"},{"instruction":"import math\n\nstr1 = input()\nstr2 = input()\nvalue = 0\nvalue_2 = 0\nunknown = 0\nfor x in str1:\n    if x == '+':\n        value += 1\n    else:\n        value -= 1\nfor x in str2:\n    if x == '+':\n        value_2 += 1\n    elif x == '-':\n        value_2 -= 1\n    else:\n        unknown += 1\nplus_count = 0\nminus_count = 0\nrav = 0\nx = value - value_2\nif abs(x)<= unknown:\n    if x >= 0:\n        plus_count += x\n        rav = unknown - plus_count\n    else:\n        minus_count += x\n        rav = unknown - minus_count\n\n    if plus_count == 0 and minus_count == 0 and rav == 0:\n        print('1.000000000000')\n    else:\n        if rav % 2 == 0:\n            rav = int(rav \/ 2)\n            plus_count += rav\n            minus_count += rav\n\n            k = max(plus_count, minus_count)\n            C = math.factorial(unknown) \/ (math.factorial(unknown - k) * math.factorial(k))\n            O = math.pow(2, unknown)\n            res = C \/ O\n            print(f'{res:.12f}')\n        else:\n            print('0.000000000000')\nelse:\n    print('0.000000000000')","output":"np"},{"instruction":"def some_random_function():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function5():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\nimport os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,m,k = map(int,input().split())\n    hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)]\n    ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m]\n    if k&1:\n        for _ in range(n):\n            print(*[-1]*m)\n        exit()\n    dp = [[0]*m for _ in range(n)]\n    dx,dy = [0,0,1,-1],[1,-1,0,0]\n    for _ in range(k\/\/2):\n        dp1 = [[10**20]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                for kk in range(4):\n                    x1,y1 = i+dx[kk],j+dy[kk]\n                    if kk < 2:\n                        ed = hor[i][j-(kk==1)]\n                    else:\n                        ed = ver[i-(kk==3)][j]\n                    if ed != 10**20+1:\n                        dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1])\n        dp = dp1\n    for i in dp:\n        print(*i)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef some_random_function1():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function2():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function3():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function4():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function6():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function7():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function8():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"mass = list(input())\nb = int(input())\nmass.sort()\nmass = mass[::-1]\np = ''\nwhile(len(mass)>0):\n\tfor i in range(len(mass)):\n\t\tn = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))\n\t\tif int(n) <= b:\n\t\t\tp += mass[i]\n\t\t\tmass = mass[:i] + mass[i + 1:]\n\t\t\tbreak\nprint(p)","output":"cubic"},{"instruction":"import sys\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10**8\nN = 5*10**6\n\ndef solve(n):\n    arr = []\n    while n> 0:\n        arr.append(n%2)\n        n=n\/\/2\n    return arr\n\nl,r = Ri()\narrl = solve(l)\narrr = solve(r)\nif len(arrr) > len(arrl):\n    ans = (1<<len(arrr))-1\n    print(ans)\nelse:\n    ind = -1\n    for i in range(len(arrr)-1,-1,-1):\n        if arrr[i] != arrl[i]:\n            ind = i\n            break\n    if ind == -1:\n        print(0)\n    else:\n        ans = (1 << (ind+1)) -1\n        print(ans)","output":"logn"},{"instruction":"n, k = map(int, input().split())\na = [int(x) for x in input().split()]\nrda = []\nfor j in range(12):\n    rd = dict()\n    x = pow(10, j)\n    for i in range(n):\n        r = (a[i]*x)%k\n        rd[r] = rd.setdefault(r, 0) + 1\n    rda.append(rd)\nans = 0\nfor i in range(n):\n    r = a[i]%k\n    ln = len(str(a[i]))\n    x = pow(10, ln)\n    if r == 0: r = k\n    if k-r in rda[ln]:\n        ans += rda[ln][k-r]\n        if (a[i]*x)%k == k-r:\n            ans -= 1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef dinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rt(x1, x2, y3):\n    print(0.5 * (x2 + x1) * y3)\n\ndef main():\n    n, k = rinput()\n    i = 0\n    t = 0\n    while k > i:\n        t += 1\n        i += t\n    c = n - t\n    i -= c\n    while i != k:\n        t += 1\n        i += t + 1\n        c -= 1\n    print(c)\nmain()","output":"linear"},{"instruction":"n=int(input())\na=(n\/\/2)*3\nprint(a)","output":"constant"},{"instruction":"class BIT:\n\n    __all__ = ['add', 'sumrange', 'lower_left']\n\n    def __init__(self, maxsize=10**7):\n        assert (maxsize > 0)\n\n        self._n = maxsize+1\n        self._bitdata = [0]*(maxsize+1)\n\n    def add(self, i, x):\n\n        assert(0 <= i < self._n)\n\n        pos = i+1\n        while pos < self._n:\n            self._bitdata[pos] += x\n            pos += pos&(-pos)\n\n    def running_total(self, i):\n\n        assert (-1<= i < self._n)\n\n        if i == -1:\n            return 0\n        returnval = 0\n        pos = i+1\n        while pos:\n            returnval += self._bitdata[pos]\n            pos -= pos & (-pos)\n        return returnval\n\n    def sumrange(self, lo=0, hi=None):\n\n        if lo < 0:\n            raise ValueError('lo must be non-negative')\n        if hi is None:\n            hi = self._n\n\n        return self.running_total(hi) - self.running_total(lo-1)\n\n    def lower_left(self, total):\n\n        if total < 0:\n            return -1\n        pos = 0\n        k = 1<<(self._n.bit_length()-1)\n        while k > 0:\n            if pos+k < self._n and self._bitdata[pos+k] < total:\n                total -= self._bitdata[pos+k]\n                pos += k\n            k \/\/= 2\n        return pos\ndef tentousu(lis):\n  bit = BIT()\n  ans = 0\n  for i in range(len(lis)):\n      bit.add(lis[i], 1)\n      ans += i + 1 - bit.running_total(lis[i])\n  return ans\nN=int(input())\nL=list(map(int,input().split()))\na=tentousu(L)\na%=2\nif N%2==0 and a%2==0:\n  print(\"Petr\")\nif N%2==0 and a%2==1:\n  print(\"Um_nik\")\nif N%2==1 and a%2==0:\n  print(\"Um_nik\")\nif N%2==1 and a%2==1:\n  print(\"Petr\")","output":"nlogn"},{"instruction":"def main():\n    mod=1000000007\n\n    tc=1\n    for _ in range(tc):\n        a=list(rs())\n        b=list(rs())\n\n        if len(a)<len(b):\n            ws(''.join(sorted(a)[::-1]))\n        else:\n            a=sorted(a)\n            ans=[]\n            sa=SortedList(a)\n            for i in range(len(a)-1):\n                for j in range(len(sa)-1,-1,-1):\n                    temp=ans+[sa[j]]\n                    sa.discard(sa[j])\n                    for k in sa:\n                        temp.append(k)\n\n                    if temp<=b:\n                        ans.append(temp[i])\n                        break\n                    else:\n                        sa.add(temp[i])\n            ans.append(sa[-1])\n            ws(\"\".join(ans))\n\ndef rant():\n\n    return \"AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH\"\n\ndef SieveOfEratosthenes(limit):\n\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef memodict(f):\n\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return math.gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = math.gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = math.gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n \/\/ f)\n\ndef distinct_factors(n):\n\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n \/\/ i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n \/\/= mod\n            r \/\/= mod\n        return res\n\n    return nCr_mod\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = [*range(n+1)]\n        self.size = [1]*(n+1)\n        self.min, self.max = [*range(n+1)], [*range(n+1)]\n        self.count = n\n\n    def get(self, a):\n\n        if self.parent[a] == a:\n            return a\n        x = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while x != self.parent[x]:\n            self.parent[x], x = a, self.parent[x]\n        return a\n\n    def union(self, a, b):\n\n        a, b = self.get(a), self.get(b)\n        if a != b:\n            if self.size[a] > self.size[b]:\n                a, b = b, a\n            self.parent[a] = b\n            self.size[b] += self.size[a]\n            self.min[b] = min(self.min[a], self.min[b])\n            self.max[b] = max(self.max[a], self.max[b])\n            self.count -= 1\n\n    def count_sets(self):\n\n        return self.count\n\nclass SegmentTree:\n\n    def __init__(self, data, default=0, func=max):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n\n        stop+=1\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SparseTable:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n\n        depth = (stop + 1 - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\nimport sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom math import log2\nfrom bisect import bisect_left,bisect_right\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    main()\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")","output":"cubic"},{"instruction":"n,m=map(int,input().split())\narr=[]\nfor i in range(m):\n    arr.append(list(map(int,input().split())))\ncount=0\nfor i in range(m):\n    count +=arr[i][0] *(n)\n    if n %2==1 and arr[i][1] <0:\n        count +=(n\/\/2)*(n\/\/2 +1)*arr[i][1]\n    if n %2==1 and arr[i][1] >0:\n        count +=(n) *(n-1) *arr[i][1]\/\/2\n    if n %2==0 and arr[i][1] <0:\n        count +=(n\/\/2)*(n\/\/2 -1)*arr[i][1]\n        count +=(n\/\/2) *arr[i][1]\n    if n %2==0 and arr[i][1] >0:\n        count +=(n) *(n-1) *arr[i][1] \/\/2\nprint(count \/n)","output":"linear"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = []\n    b = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(n-1):\n        b.append(list(map(int, input().split())))\n    if k % 2:\n        ans = [-1] * m\n        for i in range(n):\n            print(*ans)\n        return\n    k \/\/= 2\n    pre = [[0]*m for i in range(n)]\n    cur = [[10**9]*m for i in range(n)]\n    for _ in range(k):\n        cur = [[10**9] * m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    cur[i][j] = min(cur[i][j], pre[i-1][j]+b[i-1][j])\n                if i < n - 1:\n                    cur[i][j] = min(cur[i][j], pre[i+1][j]+b[i][j])\n                if j:\n                    cur[i][j] = min(cur[i][j], pre[i][j-1]+a[i][j-1])\n                if j < m - 1:\n                    cur[i][j] = min(cur[i][j], pre[i][j+1]+a[i][j])\n        pre = cur\n    for i in range(n):\n        cur[i] = [cur[i][j]*2 for j in range(m)]\n        print(*cur[i])\n\nsolve()","output":"cubic"},{"instruction":"n,d,k=map(int,input().split())\nif n==1:\n  print(\"NO\")\n  exit()\nif k==1:\n  if n==2 and d==1:\n    print(\"YES\")\n    print(1,2)\n  else:\n    print(\"NO\")\n  exit()\nif n<d+1:\n  print(\"NO\")\n  exit()\nco=1\nans=[]\nfor i in range(1,d+1):\n  ans.append((i,i+1))\n  co+=1\ndef dfs(r,dist,co):\n  if 2<=r<=d:\n    t=k-2\n  else:\n    t=k-1\n  if co==n:\n    return co\n  for _ in range(t):\n    if dist==d:\n      return co\n    if co==n:\n      return co\n    co+=1\n    ans.append((r,co))\n    co=dfs(co,dist+1,co)\n  return co\nfor i in range(2,d+1):\n  co=dfs(i,max(i-1,d-i+1),co)\nif co==n:\n  print(\"YES\")\n  for j in ans:\n    print(*j)\nelse:\n  print(\"NO\")","output":"quadratic"},{"instruction":"from collections import defaultdict\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\nxors = defaultdict(int)\nxors[0]=1\ncomp = (1<<k)-1\nans = n*(n+1)\/\/2\nxor = 0\nfor a in arr:\n\txor^=a\n\tif xors[xor]>xors[comp^xor]:\n\t\txor^=comp\n\tans-=xors[xor]\n\txors[xor]+=1\nprint(ans)","output":"linear"},{"instruction":"import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\n\nans=0\nb=[]\n\ndef dfs2(root,par,d):\n    global gp,dp\n    dp[root]=d\n    for child in gp[root]:\n        if child==par:continue\n        dfs2(child,root,d+1)\ndef hnbhai(tc):\n    n,s=sd()\n    low=s\n    high=n+1\n    ans=n+1\n    while(low<=high):\n        mid=(low+high)\/\/2\n        ss=sum(list(map(int,list(str(mid)))))\n        if mid-ss<s:\n            low=mid+1\n        else:\n            ans=mid\n            high=mid-1\n    print(n-ans+1)\nfor _ in range(1):\n    hnbhai(_+1)","output":"logn"},{"instruction":"import re\nimport string\nimport math\n\nletter_number_pattern = \"[a-zA-Z]*[0-9]*\"\n\nalpha = dict(zip(range(1,28), string.ascii_uppercase))\ndecimals = dict(zip(string.ascii_uppercase, range(1,27)))\n\nalpha_len = len(alpha)\n\ndef letter_to_decimal(n):\n    exponents = []\n    pow_i = 0\n    while True:\n        if n \/\/ (26**pow_i) > 26:\n            exponents.append(1)\n            n = n - (26**pow_i)\n            pow_i += 1\n        else:\n            exponents.append(n \/\/ (26**pow_i))\n            n = n - ((n \/\/ (26**pow_i)) * (26**pow_i))\n            break\n    pow_i = pow_i - 1\n    while n != 0:\n        t = n \/\/ (26**pow_i)\n        n = n - (t * (26 ** pow_i))\n        exponents[pow_i] = exponents[pow_i] + t\n        pow_i = pow_i - 1\n    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))\n    return result\n\ndef letters_to_deci(letters):\n    total_sum = 0\n    pows = list(reversed(range(len(letters))))\n    for i in range(len(letters)):\n        total_sum += decimals[letters[i]] * (26**pows[i])\n    return total_sum\n\ninput_cells = []\n\nn_lines = input()\nfor i in range(int(n_lines)):\n    input_cells.append(input())\n\nfor cell in input_cells:\n    all_matches = re.findall(letter_number_pattern, cell)[:-1]\n    if len(all_matches) == 2:\n        rows = int(re.search(\"[0-9]*$\", all_matches[0]).group())\n        cols = int(re.search(\"[0-9]*$\", all_matches[1]).group())\n        converted_cols = letter_to_decimal(cols)\n        print(\"%s%s\" % (converted_cols, rows))\n    elif len(all_matches) == 1:\n        rows = re.match(\"[A-Z]*\", all_matches[0]).group()\n        cols = re.search(\"[0-9]*$\", all_matches[0]).group()\n        converted_rows = letters_to_deci(rows)\n        print(\"R%sC%s\" % (cols, converted_rows))\n    else:\n        pass","output":"linear"},{"instruction":"from collections import deque\n\ndef top_sort():\n    global dag, top, g, n\n    q = deque()\n    cnt = 0\n\n    for i in range(1, n+1):\n        if not dag[i]:\n            q.append(i)\n\n    while len(q):\n        u = q.popleft()\n        cnt += 1\n        top[u] = cnt\n        for to in g[u]:\n            dag[to] -= 1\n            if dag[to] == 0:\n                q.append(to)\n    return cnt == n\n\ndef check(mid):\n    global n, m, g, u, v, c, dag\n    for i in range(1, n+1):\n        g[i].clear()\n        dag[i] = 0\n    for i in range(1, m+1):\n        if c[i] > mid:\n            g[u[i]].append(v[i])\n            dag[v[i]] += 1\n    return top_sort()\n\ndef input_t():\n    return [int(x) for x in input().split()]\n\nMAX = int(10e5 + 42)\nn, m = input_t()\nr = 0\nu, v, c = [0] * MAX, [0] * MAX, [0] * MAX\ng, dag, top = [[]  for _ in range(MAX)], [0] * MAX, [0] * MAX\ncnt = 0\n\nfor i in range(1, m + 1):\n    u[i], v[i], c[i] = input_t()\n    r = max(r, c[i])\n\nl = 0\n\nwhile l < r:\n    mid = (l+r) >> 1\n    if check(mid):\n        r = mid\n    else:\n        l = mid + 1\n\ncheck(l)\nfor i in range(1, m+1):\n    if c[i] <= l and top[v[i]] < top[u[i]]:\n        cnt += 1\nprint(f\"{l} {cnt}\")\nfor i in range(1, m+1):\n    if c[i] <= l and top[v[i]] < top[u[i]]:\n        print(i, end=\" \")","output":"nlogn"},{"instruction":"n, s = map(int, input().rstrip().split())\nif n <= s:\n    print(0)\n    exit()\nfor i in range(s, n + 2):\n    l = 0\n    for j in str(i):\n        l += int(j)\n    if i - l >= s:\n        break\nprint(max(n - i + 1, 0))","output":"logn"},{"instruction":"from sys import stdin, stdout\n\ndef check(k, b, T):\n\tc = [e for e in b if e[0] >= k]\n\n\tif len(c) < k:\n\t\treturn False, None\n\n\tfirst_k_probs = c[:k]\n\ts = sum([e[1] for e in first_k_probs])\n\n\tif s > T:\n\t\treturn False, None\n\n\treturn True, first_k_probs\n\ndef solve(n, T, a, t):\n\tb = []\n\n\tfor i in range(n):\n\t\tb.append((a[i], t[i], i + 1))\n\n\tb.sort(key=lambda x: x[1])\n\n\tlow, high = 0, n\n\tresult = 0\n\tfinal_probs = []\n\n\twhile low <= high:\n\t\tmid = (low + high) \/\/ 2\n\n\t\t(possible, probs) = check(mid, b, T)\n\t\tif possible:\n\t\t\tresult, final_probs = mid, probs\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\n\treturn (result, [e[2] for e in final_probs])\n\nn, T = (int(x) for x in stdin.readline().split())\n\na = [0] * n\nt = [0] * n\n\nfor i in range(n):\n\ta[i], t[i] = (int(x) for x in stdin.readline().split())\n\npoint, probs = solve(n, T, a, t)\nstdout.write(\"%s\\n\" % point)\nstdout.write(\"%s\\n\" % len(probs))\nif len(probs) > 0:\n\tstdout.write(\"%s\\n\" % \" \".join([str(x) for x in probs]))","output":"nlogn"},{"instruction":"from math import *\nfrom collections import *\nn = int(input())\na = list(map(int,input().split()))\nd = Counter(a)\nans = 0\nfor i in range(n):\n    for j in range(31):\n        s = 2**j\n        s = s-a[i]\n        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):\n            break\n    else:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"t=int(input())\nfor _ in range(t):\n\tn,k=list(map(int,input().split()))\n\tif n>=32:\n\t\tprint(\"YES \"+str(n-1))\n\telse:\n\t\tans=-1\n\t\tfor i in range(1,n+1):\n\t\t\tp=(4**i)-(2**(i+1))+1\n\t\t\tp*=(((4**(n-i))-1)\/\/3)\n\t\t\tg=(((4**i)-1)\/\/3)\n\t\t\tp+=(((4**i)-1)\/\/3)\n\t\t\tg=(((4**i)-1)\/\/3)-(((4**(i-1))-1)\/\/3)\n\t\t\tif g<=k and p>=k:\n\t\t\t\tans=n-i\n\t\t\t\tbreak\n\t\tif ans!=-1:\n\t\t\tprint(\"YES \"+str(ans))\n\t\telse:\n\t\t\tprint(\"NO\")","output":"logn"},{"instruction":"n, a, b = [int(i) for i in input().split()]\nlst = sorted([int(i) for i in input().split()])\nprint(lst[b]-lst[b-1])","output":"nlogn"},{"instruction":"a=int(input())\nif a>0:\n    print(a)\nelse:\n    a=a-2*a\n    k=a\/\/10\n    b=a%10\n    c=(a\/\/100)*10+b\n    if k<c:\n        if k!=0:\n            print('-%d' %k)\n        else:\n            print(k)\n    else:\n        if c!=0:\n            print('-%d' %c)\n        else:\n            print(c)","output":"constant"},{"instruction":"n = int(input())\nd = []\nfor i in range(n):\n    xx, ww = [int(i) for i in input().split()]\n    d.append([xx-ww, xx+ww])\nd.sort(key=lambda x:x[0])\nlast = -100000000000\nans = 0\nfor i in range(n):\n    if last <= d[i][0]:\n        last = d[i][1]\n        ans += 1\n    elif last > d[i][1]:\n        last = d[i][1]\nprint(ans)","output":"nlogn"},{"instruction":"import math\nimport sys\nfrom decimal import Decimal\n\ndef main(l,r):\n\n  if l==r:\n    return 0\n\n  val=1\n\n  while val*2<=r:\n    val*=2\n\n  if val<=l:\n    return main(l-val,r-val)\n  else:\n    return 2*val-1\n\nl,r=list(map(int,input().split()))\nprint(main(l,r))","output":"logn"},{"instruction":"for _ in range(int(input())):\n    n = int(input())\n    li = sorted(list(map(int, input().split())))\n    print(min(li[n - 2] - 1, n - 2))","output":"nlogn"},{"instruction":"a=list(map(int, input().split()))\nh=0\nfor i in range(14):\n    b=a[:]\n    if i==13:\n        j=0\n    else:\n        j=i+1\n    if a[i]>0:\n        c=0\n        t=b[i]%14\n        x=b[i]\/\/14\n        b[i]=0\n\n        for i in range(14):\n            b[i]+=x\n\n        while t>0:\n            b[j]+=1\n            j+=1\n            if j==14:\n                j=0\n            t-=1\n        for i in range(14):\n            if b[i]%2==0:\n                c+=b[i]\n\n        if c>h:\n            h=c\nprint(h)","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\n\nmod=10**9+7\nn,t=map(int,input().split())\na=[]\nfor i in range(n):\n    time,genre=map(int,input().split())\n    genre-=1\n    a.append((time,genre))\ndp=[[0 for j in range(3)] for i in range(1<<n)]\nfor i in range(n):\n    dp[1<<i][a[i][1]]=1\nfor i in range(1<<n):\n    for j in range(3):\n        if(dp[i][j]==0):\n            continue\n        mask=1\n        for k in range(n):\n            if(i&mask or a[k][1]==j):\n                mask<<=1\n                continue\n            dp[i|mask][a[k][1]]=(dp[i|mask][a[k][1]]+dp[i][j])%mod\n            mask<<=1\nans=0\nfor i in range(1<<n):\n    mask=1\n    duration=0\n    for j in range(n):\n        if(i&mask):\n            duration+=a[j][0]\n        mask<<=1\n    if(duration==t):\n        ans=(ans+sum(dp[i]))%mod\nprint(ans)","output":"np"},{"instruction":"input()\nl=[int(x)%2 for x in input().split()]\nprint(l.index(sum(l)==1)+1)","output":"linear"},{"instruction":"from sys import stdin,stdout\nfrom math import ceil,log\ndef main():\n\td={}\n\tn=int(stdin.readline())\n\ta=list(map(int,stdin.readline().split( )))\n\tm=-1;mm=10**10\n\tfor v in a:\n\t\tif v not in d:\n\t\t\td[v]=1\n\t\telse:\n\t\t\td[v]+=1\n\t\tm=max(m,v)\n\t\tmm=min(mm,v)\n\tans=0\n\n\tfor v in a:\n\n\t\texponent=ceil(log(v,2))\n\t\tpower=2**exponent\n\t\tfind=0\n\t\twhile power-v>=0:\n\t\t\tif power-v>mm and power-v>m:\n\t\t\t\tbreak\n\n\t\t\telement=power-v\n\t\t\tif element in d and element==v and d[element]>1:\n\t\t\t\tfind=1\n\t\t\t\tbreak\n\t\t\telif element in d and element!=v:\n\t\t\t\tfind=1\n\t\t\t\tbreak\n\t\t\tpower=power*2\n\t\tif find==0:\n\t\t\tans+=1\n\tstdout.write(\"%d\\n\"%(ans))\n\nmain()","output":"nlogn"},{"instruction":"lst = []\nans = {'purple' : 'Power', 'green' : 'Time', 'blue': 'Space', \"orange\" : \"Soul\", \"red\" : \"Reality\", \"yellow\" : \"Mind\"}\nfor i in range(int(input())):\n    lst.append(input())\na = []\nfor i in ans.keys():\n    if i not in lst:\n        a.append(ans[i])\nprint(len(a))\nfor i in a:\n    print(i)","output":"constant"},{"instruction":"k = int(input().split()[1])\nl = sorted(list(map(int,input().split())))\n\nres = set()\nfor i in l:\n    if i\/\/k  not in res or i%k!=0:\n        res.add(i)\n\nprint(len(res))","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nd = set(a)\nif (0 in a):\n    print(len(d)-1)\nelse:\n    print(len(d))","output":"linear"},{"instruction":"R, G, B = list(map(lambda x: int(x), input().split()))\nr = list(map(lambda x: int(x), input().split()))\ng = list(map(lambda x: int(x), input().split()))\nb = list(map(lambda x: int(x), input().split()))\n\ndef f(t):\n    i, j, k = t\n    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)\n\nmax_area = [None]*((R+1)*(G+1)*(B+1)+1)\n\ndef get_max_area(i, j, k):\n    temp = f((i,j,k))\n    if max_area[temp] != None:\n        return max_area[temp]\n    x1=x2=x3=0\n    if i >= 0 and j>=0:\n        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]\n    if i >= 0 and k >= 0:\n        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]\n    if j >= 0 and k >= 0:\n        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]\n\n    max_area[temp] = max(x1, x2, x3)\n    return max_area[temp]\n\nr.sort()\ng.sort()\nb.sort()\nprint(get_max_area(R-1, G-1, B-1))","output":"cubic"},{"instruction":"def numtostr(a):\n    var=[]\n    while a>0:\n\n       if a%26==0:\n          var.append(\"Z\")\n          a=a\/\/26-1\n       else:\n          var.append(chr(a%26-1+ord(\"A\")))\n          a=a\/\/26\n    var.reverse()\n    return \"\".join(var)\n\ndef strtonum(b):\n    par=len(b)\n    result=0\n    for i in range(1,par):\n        result+=(26**i)\n    par=len(b)-1\n    for elem in b:\n        if par!=0:\n             result+=((ord(elem)-ord(\"A\"))*((26)**par))\n        else:\n            result += ((ord(elem) - ord(\"A\"))+1)\n\n        if par==0:\n            break\n        par -= 1\n    return result\n\ndef method1(par1):\n    C=par1.index(\"C\")\n    result=numtostr(int(par1[C+1:]))+str(par1[1:C])\n    return result\n\ndef method2(par2):\n    c=0\n    for elem in par2:\n        try:\n            if int(elem):\n                break\n        except:\n            c+=1\n    return \"R\"+par2[c:]+\"C\"+str(strtonum(par2[:c]))\n\ni=input()\ninp=[]\nfor j in range(int(i)):\n     x=input()\n     inp.append(x)\nfor key in range(len(inp)):\n    if \"R\" in inp[key] and \"C\" in inp[key]:\n        try:\n            if int(inp[key][1:inp[key].index(\"C\")]) and int(inp[key][inp[key].index(\"C\")+1:]):\n                print(method1(inp[key]))\n        except:\n            print(method2(inp[key]))\n    else:\n        print(method2(inp[key]))","output":"linear"},{"instruction":"n = int(input())\narr = list(map(int,input().split()))\narr.sort()\nif n>=2 and  arr[0]==arr[1]==0:\n\tprint(\"cslnb\")\nelse:\n\tflag=0\n\tfor i in range(n-2):\n\t\tif arr[i]==arr[i+1]==arr[i+2]:\n\t\t\tflag=1\n\t\t\tbreak\n\tif flag==1:\n\t\tprint(\"cslnb\")\n\telse:\n\t\tflag=0\n\t\tind=0\n\t\tfor i in range(n-1):\n\t\t\tif arr[i]==arr[i+1]:\n\t\t\t\tind = i\n\t\t\t\tflag+=1\n\t\tif flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:\n\t\t\tprint(\"cslnb\")\n\n\t\telif flag>=2:\n\t\t\tprint(\"cslnb\")\n\t\telse:\n\t\t\tsafe = 0\n\t\t\tfor i in range(n):\n\n\t\t\t\tif arr[i]-i>=0:\n\t\t\t\t\tsafe+=arr[i]-i\n\n\t\t\tif safe%2==0:\n\t\t\t\tprint(\"cslnb\")\n\t\t\telse:\n\t\t\t\tprint(\"sjfnb\")","output":"nlogn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nl=list(set(a))\nl.sort()\nif len(l) >=2:\n    print(l[1])\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))","output":"constant"},{"instruction":"def balance(x1, y1, x2, y2):\n    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)\n\ndef get_lr():\n    l, r = 0, n\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, 1, m, n\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res < 2:\n            l = m\n        else:\n            r = m\n    r2 = r\n    l, r = 1, n + 1\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = n, 1, m, n\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res == 2:\n            l = m\n        else:\n            r = m\n    l2 = l\n\n    l, r = 0, n\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, 1, m, n\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res < 1:\n            l = m\n        else:\n            r = m\n    r1 = r\n    l, r = 1, n + 1\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = n, 1, m, n\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res >= 1:\n            l = m\n        else:\n            r = m\n    l1 = l\n    return r1, r2, l2, l1\n\ndef get_ud():\n    l, r = 0, n\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, 1, n, m\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res < 2:\n            l = m\n        else:\n            r = m\n    r2 = r\n    l, r = 1, n + 1\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, n, n, m\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res == 2:\n            l = m\n        else:\n            r = m\n    l2 = l\n\n    l, r = 0, n\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, 1, n, m\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res < 1:\n            l = m\n        else:\n            r = m\n    r1 = r\n    l, r = 1, n + 1\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n        x1, y1, x2, y2 = 1, n, n, m\n        x1, y1, x2, y2 = balance(x1, y1, x2, y2)\n        print('?', x1, y1, x2, y2)\n        res = int(input())\n        if res >= 1:\n            l = m\n        else:\n            r = m\n    l1 = l\n    return r1, r2, l2, l1\n\nn = int(input())\nlr = get_lr()\nud = get_ud()\nrr = [lr[0], lr[1]]\nll = [lr[2], lr[3]]\nuu = [ud[0], ud[1]]\ndd = [ud[2], ud[3]]\nfor r1 in rr:\n    r2 = rr[0] if rr[0] != r1 else rr[1]\n    for l1 in ll:\n        l2 = ll[0] if ll[0] != l1 else ll[1]\n        for u1 in uu:\n            u2 = uu[0] if uu[0] != u1 else uu[1]\n            for d1 in dd:\n                d2 = dd[0] if dd[0] != d1 else dd[1]\n                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:\n                    continue\n                print('?', l1, d1, r1, u1)\n                res1 = int(input())\n                print('?', l2, d2, r2, u2)\n                res2 = int(input())\n                if res1 == res2 == 1:\n                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)\n                    __import__('sys').exit(0)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\ns = a[0] % 998244353\ny = a[0]\nfor x in a[1:]:\n\n\ts = s * 2 + y + x\n\ty = y * 2 + x\n\n\ts %= 998244353\n\ty %= 998244353\n\nprint(s)","output":"linear"},{"instruction":"money=input()\niniti=money\n\nif int(money)<0:\n    lst_dig=money[-1]\n    lsec_dig=money[-2]\n    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]\n    else:money=money[:-2]+money[-1]\n    print(int(money))\nelse:\n    lst_dig=money[-1]\n    lsec_dig=money[-2]\n    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]\n    else:money=money[:-2]+money[-2]\n    if int(initi)>=int(money):\n        print(initi)\n    else:\n        print(money)","output":"constant"},{"instruction":"import sys\n\nnum_riders, _ = map(int, next(sys.stdin).split())\n\nhouses = map(int, next(sys.stdin).split())\nis_rider = map(int, next(sys.stdin).split())\n\ncurrent_left_driver = None\ncurrent_citizens = []\n\nresult = []\n\nfor house, is_rider in zip(houses, is_rider):\n    if is_rider:\n        if current_left_driver is None:\n            result.append(len(current_citizens))\n        else:\n            result.append(0)\n            for citizen in current_citizens:\n                if abs(citizen - current_left_driver) <= abs(citizen - house):\n                    result[-2] += 1\n                else:\n                    result[-1] += 1\n\n        current_citizens = []\n        current_left_driver = house\n    else:\n        current_citizens.append(house)\n\nresult[-1] += len(current_citizens)\n\nprint(' '.join(map(str, result)))","output":"linear"},{"instruction":"a,b,c,n = map(int,input().split())\nif c > a or c > b or (a+b) - c >=n:\n    print(-1)\nelse:\n    print(n -((a+b)-c))","output":"constant"},{"instruction":"from math import floor\nfrom sys import stdin\n\nCONST = 9\n\ndef solve(k):\n    i = 0\n    while k > CONST * (10 ** i) * (i + 1):\n        k -= floor(CONST * (10 ** i)) * (i + 1)\n        i += 1\n    num_digits = i + 1\n    num = floor((k - 1) \/ num_digits)\n    num += floor(10 ** (i))\n    print(('{}'.format(num))[(k - 1) % num_digits])\n\nif __name__ == '__main__':\n    for line in stdin:\n        solve(int(line.rstrip()))","output":"logn"},{"instruction":"n,m,k=map(int,input().split())\nx=list(map(int,input().split()))\nx.sort(reverse=True)\ni=-1\nif k>=m:\n    print(0)\nelse:\n    for i in range(n):\n        k-=1\n        k+=x[i]\n        if k>=m:\n            break\n    if k>=m:\n        print(i+1)\n    else:print(-1)","output":"nlogn"},{"instruction":"import sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\n\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) \/\/ math.gcd(a, b)\ndef wr(arr): return ' '.join(map(str, arr))\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n \/ i == i):\n                r.append(i)\n            else:\n                r.extend([i, n \/\/ i])\n    return r\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n \/\/= i\n        divs_number *= t\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number \/\/= base\n    return newnumber\ndef cdiv(n, k): return n \/\/ k + (n % k != 0)\n\nn, k = mi()\nt = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)\nprint(n - t)","output":"logn"},{"instruction":"import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nINF=10**9\ndp=[[INF]*(n+1) for i in range(n+1)]\nval=[[-1]*(n+1) for i in range(n+1)]\nfor i in range(n):\n  dp[i][i+1]=1\n  val[i][i+1]=a[i]\nfor l in range(2,n+1):\n  for i in range(n-l+1):\n    j=i+l\n    for k in range(i+1,j):\n      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:\n        dp[i][j]=1\n        val[i][j]=val[i][k]+1\n      else:\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])\nprint(dp[0][n])","output":"cubic"},{"instruction":"from collections import defaultdict\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(s):\n    q = deque()\n    q.append(s)\n    dist = [-1] * (n + 1)\n    dist[s] = 0\n    p = []\n    parent = [1] * (n + 1)\n    ok = [0] * (n + 1)\n    while q:\n        i = q.popleft()\n        d = dist[i]\n        if d < 3:\n            ok[i] = 1\n        p.append(i)\n        for j in G[i]:\n            if dist[j] == -1:\n                q.append(j)\n                dist[j] = d + 1\n                parent[j] = i\n    ans = 0\n    while p:\n        i = p.pop()\n        j = parent[i]\n        if not ok[i]:\n            ok[j] = 1\n            ans += 1\n            for k in G[j]:\n                ok[k] = 1\n    return ans\n\nn = int(input())\nG = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    G[u].append(v)\n    G[v].append(u)\nans = bfs(1)\nprint(ans)","output":"linear"},{"instruction":"from collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = II()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI()\n    return res\ndef FR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR_(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI_()\n    return res\ndef SR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = S()\n    return res\ndef LSR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LS()\n    return res\nmod = 1000000007\ninf = float('INF')\n\ndef solve():\n    n = II()\n    a = LI()\n    dp = [[None for i in range(n + 1)] for i in range(n + 1)]\n    for i in range(n):\n        dp[i][i + 1] = [a[i], a[i], 1]\n        dp[i + 1][i] = [a[i], a[i], 1]\n    for i in range(2, n + 1):\n        for l in range(n - i + 1):\n            tmp = [-inf, inf, inf]\n            r = l + i\n            dpl = dp[l]\n            dpr = dp[r]\n            for m in range(l + 1, r):\n                lm = dpl[m]\n                mr = dpr[m]\n                lr = lm[2] + mr[2] - (lm[1] == mr[0])\n                if lr < tmp[2]:\n                    tmp[2] = lr\n                    if lm[1] == mr[0]:\n                        if lm[2] == 1:\n                            tmp[0] = lm[0] + 1\n                        else:\n                            tmp[0] = lm[0]\n                        if mr[2] == 1:\n                            tmp[1] = mr[1] + 1\n                        else:\n                            tmp[1] = mr[1]\n                    else:\n                        tmp[0] = lm[0]\n                        tmp[1] = mr[1]\n            dp[l][r] = tmp\n            dp[r][l] = tmp\n    print(dp[0][n][2])\n    return\n\nif __name__ == '__main__':\n    solve()","output":"cubic"},{"instruction":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        binary = \"\"\n        for i in range(32):\n            if n & (1 << i):\n                binary += \"1\"\n            else:\n                binary += \"0\"\n\n        res = 0\n        for i, bit in enumerate(binary[::-1]):\n            if bit == \"1\":\n                res |= (1 << i)\n\n        return res","output":"constant"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef fastPrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n\nfor _ in range(t):\n    n = ii()\n    a = li()\n    s = sum(a)\n    cur = 0\n    for i in range(n):\n        cur+=a[i]\n        if cur>=s\/2:\n            print(i+1)\n            break","output":"linear"},{"instruction":"from math import ceil\nn = int(input())\nif n == 1:\n    print(1)\n    exit(0)\nif n == 2:\n\tprint('1 2')\n\texit(0)\nelif n == 3:\n\tprint('1 1 3')\n\texit(0)\no = 0\nif n&1:\n\tn -= 1\n\to = 1\nans, i, t = '1 ' * ceil(n \/ 2), 1, n\nn = ceil(n\/2)\nj = 2\nwhile n > 1:\n\tans += (str(j) + ' ') * ((n \/\/ 2) if t&1 else ceil(n\/2))\n\ti += 1\n\tj = pow(2, i)\n\tn \/\/= 2\nprint(('1 ' if o else '') + ans + str((j\/\/2)*(t\/\/(j\/\/2))))","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\nimport math\nimport copy\nimport collections\nfrom collections import deque\nimport heapq\nimport itertools\nfrom collections import defaultdict\nfrom collections import Counter\n\nn,k = map(int,input().split())\nmod = 998244353\ndp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]\n\ndp[0][1][0] = 1\nif k>=2:\n    dp[0][2][1] = 1\nfor i in range(1,n):\n    for j in range(1,k+1):\n        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]\n        dp[i][j][0]%=mod\n        if j-2>=0:\n            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]\n        else:\n            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]\n        dp[i][j][1]%=mod\nans = 0\nfor z in range(2):\n    ans+=dp[n-1][k][z]\nans*=2\nprint(ans%mod)","output":"np"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nd=set()\nt={}\nrep=set()\nif a.count(0)>=2:\n\tprint(\"cslnb\")\n\texit()\n\nfor i in a:\n\tif i in d:\n\t\tif t[i]+1==3:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\n\t\telse:\n\t\t\tt[i]+=1\n\t\t\trep.add(i)\n\t\t\tif len(rep)>=2:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\texit()\n\telse:\n\t\tt[i]=1\n\t\td.add(i)\nif rep:\n\tfor c in rep:\n\t\tif c-1 in d:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\ns=0\na.sort()\nfor i in range(n):\n\ts+=a[i]-i\nif s%2==1:print(\"sjfnb\")\nelse:print(\"cslnb\")","output":"nlogn"},{"instruction":"t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        max1 = max2 = -1\n        for q in a:\n            if q > max1:\n                max1, max2 = q, max1\n            elif q > max2:\n                max2 = q\n        print(max(0, min(max2-1, len(a)-2)))","output":"linear"},{"instruction":"n, d = map(int, input().split())\nlst = list(map(int, input().split()))\nlst.sort()\nAns = 2\nfor i in range(1, n):\n    if lst[i] - lst[i - 1] > 2 * d:\n        Ans += 2\n    elif lst[i] - lst[i - 1] == 2 * d:\n        Ans += 1\nprint(Ans)","output":"linear"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\nn = INT()\narr = LIST()\n\ni = 0\np = []\nwhile 2**i <= 10**18:\n    p.append(2**i)\n    i = i+1\n\nd = {}\ns1= set()\nfor i in arr:\n    s1.add(i)\n    if i not in d :\n        d[i] = 1\n    else:\n        d[i]+=1\n\ns2 = set()\nfor i in s1 :\n    flag = False\n    for j in p :\n        x = j - i\n        k = -1\n        try:\n            k = d[x]\n        except :\n            k = -1\n        if k != -1:\n            if x == i and d[i] == 1 :\n                continue\n            else:\n                flag = True\n                break\n    if flag == False:\n        s2.add(i)\n\nres = 0\nfor i in s2 :\n    res+=d[i]\nprint(res)","output":"nlogn"},{"instruction":"import sys\n\nN, M, K, L = map(int, sys.stdin.readline().split())\n\nif M * (N \/ M) - K < L:\n  print(\"-1\")\n  sys.exit(0)\n\ndef solve(curr):\n  return curr * M - K >= L\n\nl = 0\nr = N \/ M\nwhile r - l > 1:\n  mid = (r + l) \/ 2\n  if solve(mid):\n    r = mid\n  else:\n    l = mid\n\nprint(r)","output":"logn"},{"instruction":"import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom time import time_ns\nfrom typing import List\nsys.setrecursionlimit(99999)\n\ndef II():return int(sys.stdin.readline().strip())\ndef IIs():return list(map(int,sys.stdin.readline().strip().split()))\ndef SI():return sys.stdin.readline().strip()\n\nn=II()\nif n&1:\n    print(9,n-9)\nelse:\n    print(8,n-8)","output":"constant"},{"instruction":"def main():\n    n = int(input())\n    piles = list(map(int,input().split()))\n    piles.sort()\n    num = piles[0]\n    count = 1\n    two = 0\n    two_num = 0\n    for i in range(1,n):\n        if piles[i] == num:\n            count += 1\n        else:\n\n            if count > 2:\n                print('cslnb')\n                return\n            elif count == 2:\n                two_num = num\n                two += 1\n            num = piles[i]\n            count = 1\n\n    if count == 2:\n        two_num = num\n        two += 1\n    if count > 2:\n        print('cslnb')\n        return\n    if two > 1:\n        print('cslnb')\n        return\n\n    if two == 1:\n        if (two_num-1) in piles:\n            print('cslnb')\n            return\n\n    if n >= 2:\n        if piles[0] == piles[1] and piles[0] == 0:\n            print('cslnb')\n            return\n    moves = 0\n    curr = 0\n    for i in range(n):\n        if piles[i] >= curr:\n            moves += piles[i]-curr\n            piles[i] = curr\n            curr += 1\n\n    for i in piles:\n        if i > 0:\n            moves += 1\n            break\n\n    if n == 1:\n        moves += 1\n    if moves%2 != 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n\nmain()","output":"nlogn"},{"instruction":"from sys import stdin, stdout\n\ns = input()\n\ns = s.split(' ')\n\nM = [0]*9\nP = [0]*9\nS = [0]*9\n\nfor pile in s:\n    pile = list(pile)\n\n    num = int(pile[0])\n    tile = pile[1]\n\n    if tile=='s':\n        S[num-1] += 1\n    elif tile=='p':\n        P[num-1] += 1\n    elif tile=='m':\n        M[num-1] += 1\n\nfor i in range(9):\n    if M[i]==3:\n        print(0)\n        quit()\n    if P[i]==3:\n        print(0)\n        quit()\n    if S[i]==3:\n        print(0)\n        quit()\n\nfor i in range(7):\n    if M[i]==1 and M[i+1]==1 and M[i+2]==1:\n        print(0)\n        quit()\n    if P[i]==1 and P[i+1]==1 and P[i+2]==1:\n        print(0)\n        quit()\n    if S[i]==1 and S[i+1]==1 and S[i+2]==1:\n        print(0)\n        quit()\n\nfor i in range(9):\n    if M[i]==2:\n        print(1)\n        quit()\n    if P[i]==2:\n        print(1)\n        quit()\n    if S[i]==2:\n        print(1)\n        quit()\n\nfor i in range(8):\n    if M[i]==1 and M[i+1]==1:\n        print(1)\n        quit()\n    if P[i]==1 and P[i+1]==1:\n        print(1)\n        quit()\n    if S[i]==1 and S[i+1]==1:\n        print(1)\n        quit()\n\nfor i in range(7):\n    if M[i]==1 and M[i+2]==1:\n        print(1)\n        quit()\n    if P[i]==1 and P[i+2]==1:\n        print(1)\n        quit()\n    if S[i]==1 and S[i+2]==1:\n        print(1)\n        quit()\n\nprint(2)","output":"linear"},{"instruction":"import sys,io,os,math\ntry:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nexcept:yash=lambda:sys.stdin.readline().encode()\nI=lambda:[*map(int,yash().split())]\nimport __pypy__;an=__pypy__.builders.StringBuilder()\nn,=I();lis=I();N=22;dp=[-1]*(1<<22)\nfor i in range(n):\n    dp[lis[i]]=lis[i]\n    for j in range(22):\n        lis[i]^=(1<<j)\nfor mask in range(1<<22):\n    for i in range(22):\n        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]\nfor num in lis:\n    an.append(\"%s \"%(dp[num]))\nan.append(\"\\n\")\nos.write(1, an.build().encode())","output":"np"},{"instruction":"n, m = map(int, input().split())\nsun, su, ans = 0, 0, 0\narr, brr, dif = [], [], []\nfor i in range(n):\n    a, b = map(int, input().split())\n\n    sun += a; su += b\n    dif.append(a - b)\nif(su > m):print(-1)\nelif(sun == m):print(0)\nelse:\n    dif.sort()\n    j = n - 1\n    while(sun > m):\n        sun -= dif[j]\n        ans += 1\n        j -= 1\n    print(ans)","output":"nlogn"},{"instruction":"n = int(input())\nl = [int(i) for i in input().split()]\nr = [int(i) for i in input().split()]\n\nitems = [(-l[i]-r[i],i) for i in range(n)]\nitems.sort()\nvals = [1] * n\nm = 1\nfor i in range(1, n):\n    if items[i-1][0] != items[i][0]:\n        m += 1\n    vals[items[i][1]] = m\n\nfor i in range(n):\n    ln = sum(map(lambda x: x-vals[i] > 0, vals[:i]))\n    lr = sum(map(lambda x: x-vals[i] > 0, vals[i:]))\n    if ln != l[i] or lr != r[i]:\n        print('NO')\n        break\nelse:\n    print('YES')\n    print(' '.join(str(i) for i in vals))","output":"quadratic"},{"instruction":"n, m, k =map(int, input().split())\nhorizontal = [list(map(int, input().split())) for i in range(n)]\nvertical = [list(map(int, input().split())) for i in range(n-1)]\nif k%2 or max(n, m)==1:print(*[\" \".join(['-1']*m) for i in range(n)], sep='\\n');exit()\ndp = [[[0]*(k\/\/2+1) for i in range(m)] for j in range(n)]\nfor length in range(1, k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\nfor i in range(n):print(*[dp[i][j][k\/\/2]*2 for j in range(m)])","output":"cubic"},{"instruction":"def bin(num):\n    i=9*num*11\n    count=0\n    add=0\n    for j in range(100):\n        add=0\n        a=str(i)\n        for k in range(10):\n            add+=(a.count(str(k))*k)\n        if i-add>=s:\n            return i\n        i+=1\n    return -1\n\nn,s=map(int,input().split())\ni=0\nj=10**30\nlimit=0\nwhile i<j:\n    m=(i+j)\/\/2\n    if bin(m) == -1:\n        i=m+1\n    else:\n        j=m\nprint(max(0,n-bin(i)+1))","output":"logn"},{"instruction":"from collections import Counter\nimport math\n\ni1 = list(input())\ni2 = list(input())\n\na = Counter(i1)\nb = Counter(i2)\n\nc = b-a\nd = a-b\n\nc1 = list(c.elements())\nd1 = list(d.elements())\n\ncount = 0\nfor i in c1:\n  if i == \"?\":\n    count = count+1\nif count != len(d1):\n  print(0)\nelse:\n  x = len(c1)\n  that = 0\n  for i in d1:\n    if i == \"+\":\n      that = that + 1\n  out = math.factorial(x)\/((math.factorial(that))*math.factorial(x-that))\n  print(out\/math.pow(2,x))","output":"np"},{"instruction":"x,k = map(int, input().strip().split())\n\nMOD = 1000000007\n\nif x > 0:\n\tr = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD\nelse:\n\tr = 0\n\nprint(r)","output":"logn"},{"instruction":"n = int(input())\nx, y = [int(i) for i in input().split()]\n\nd1 = abs(x - 1) + abs(y - 1)\nd2 = abs(n - x) + abs(n - y)\n\nprint(\"White\" if d1 <= d2 else \"Black\")","output":"constant"},{"instruction":"n, m = map(int, input().split())\ntc = [0]*m\nps = []\nfor _ in range(n):\n    temp = input()\n    psa = [0]*m\n    for i in range(m):\n        if temp[i] == '1':\n            psa[i] += 1\n            tc[i] += 1\n    ps.append(psa)\nans = 'NO'\n\nfor i in ps:\n    c = 0\n    for j in range(m):\n        if tc[j]-i[j] > 0:\n            c += 1\n    if c == m:\n        ans = 'YES'\n        break\n\nprint(ans)","output":"quadratic"},{"instruction":"x, k = map(int, input().split())\nmod = 10**9+7\nif x==0:\n    print(0)\nelse:\n    p = pow(2, k, mod)\n    res = (((2*x)%mod + mod - 1)%mod)\n    res = ((res*p)%mod + 1)%mod\n    print(res)","output":"logn"},{"instruction":"import sys\ninput_file = sys.stdin\n\n[n,m] = list(int(x) for x in input_file.readline().split())\nstacks = list(int(x) for x in input_file.readline().split())\nstacks.sort()\n\nans = 0\ncur_stack = 0\ncur_h = 0\n\nwhile cur_stack < n:\n    ans += 1\n    if stacks[cur_stack] >= cur_h + 1:\n        cur_h += 1\n    cur_stack += 1\nans += stacks[-1] - cur_h\n\nprint(sum(stacks) - ans)","output":"nlogn"},{"instruction":"s0=input()\nk=int(input())\ns1=s0[::-1]\nlens1=len(s1)\nmaxnum=1005\nmod=1000000007\ndp=[[0]*maxnum for tmpi in range(maxnum)]\nf=[0]*maxnum\nc=[[0]*maxnum for tmpi in range(maxnum)]\n\ndef cntone(num):\n    tmps=bin(num)[2:]\n    cnt=0\n    for i in range(len(tmps)):\n        if(tmps[i]=='1'):\n            cnt+=1\n    return cnt\n\nfor i in range(1,maxnum):\n    if(i==1):\n        f[i]=0\n    else:\n        f[i]=f[cntone(i)]+1\n\nfor i in range(maxnum):\n    if(i==0):\n        c[i][0]=1\n        continue\n    for j in range(i+1):\n        if(j==0):\n            c[i][j]=1\n        else:\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod\n\nfor i in range(lens1):\n    if(i==0):\n        dp[i][0] = 1\n        if(s1[i]=='1'):\n            dp[i][1]=1\n        else:\n            dp[i][1]=0\n        continue\n    else:\n        for j in range(0,i+2):\n            if(j==0):\n                dp[i][j]=1\n                continue\n            if(s1[i]=='1'):\n                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod\n            else:\n                dp[i][j]=dp[i-1][j]%mod\n\nans=0\n\nfor i in range(1,lens1+1):\n    if(f[i]==k-1):\n        ans=(ans+dp[lens1-1][i])%mod\n\nif(k==0):\n    ans=1\nelif(k==1):\n    ans-=1\nelse:\n    ans=ans\nprint(ans)","output":"linear"},{"instruction":"import bisect as bi\nn,q = map(int,input().split())\na = list(map(int,input().split()))\nl = list(map(int,input().split()))\nsom = sum(a)\ne = 0\np = []\nfor i in a:\n    e += i\n    p.append(e)\n\ne = 0\ns = set(p)\nfor i in l:\n    e += i\n    if e >= som:\n        e = 0\n\n    x = bi.bisect(p,e)\n    print(n-x)","output":"nlogn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\ndic=get_frequency(a)\nss=sorted(list(set(a)))\ntobesubtracttion=0\nfor i in range(len(ss)-1):\n    if ss[i+1] <= ss[i]+k:\n        tobesubtracttion+=dic[ss[i]]\nprint(n-tobesubtracttion)","output":"nlogn"},{"instruction":"import sys\nsys.stderr = sys.stdout\n\nfrom math import inf\n\ndef explorer(n, m, k, R, C):\n    if k % 2:\n        return None\n\n    G = [[0] * m for _ in range(n)]\n    G_ = [[0] * m for _ in range(n)]\n    for _ in range(k \/\/ 2):\n        for i in range(n):\n            for j in range(m):\n                x = inf\n                if i > 0:\n                    x = min(x, G[i-1][j] + 2*C[i-1][j])\n                if i + 1 < n:\n                    x = min(x, G[i+1][j] + 2*C[i][j])\n                if j > 0:\n                    x = min(x, G[i][j-1] + 2*R[i][j-1])\n                if j + 1 < m:\n                    x = min(x, G[i][j+1] + 2*R[i][j])\n                G_[i][j] = x\n        G, G_ = G_, G\n    return G\n\ndef main():\n    n, m, k = readinti()\n    R = readintll(n)\n    C = readintll(n-1)\n    G = explorer(n, m, k, R, C)\n    if G:\n        print(llstr(G))\n    else:\n        s = ' '.join('-1' for _ in range(m))\n        print('\\n'.join(s for _ in range(n)))\n\ndef readint():\n    return int(input())\n\ndef readinti():\n   return map(int, input().split())\n\ndef readintt():\n   return tuple(readinti())\n\ndef readintl():\n   return list(readinti())\n\ndef readinttl(k):\n    return [readintt() for _ in range(k)]\n\ndef readintll(k):\n    return [readintl() for _ in range(k)]\n\ndef lstr(l):\n    return ' '.join(map(str, l))\n\ndef llstr(ll):\n    return '\\n'.join(map(lstr, ll))\n\ndef log(*args, **kwargs):\n    print(*args, **kwargs, file=sys.__stderr__)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n,s = input().split()\n\ni = int(s)\nd_sum = sum(list(map(int,str(i))))\nwhile i - d_sum < int(s):\n    i += 1\n    d_sum = sum(list(map(int,str(i))))\n\nprint((max(0,int(n)-i+1)))","output":"logn"},{"instruction":"n=int(input())\nli=list(map(int,input().split(\" \")))\ndp1=[]\nfor i in range(n):\n  lis=[-1]*n\n  dp1.append(lis)\ndp2=[0]*n\nfor i in range(n):\n  dp1[i][i]=li[i]\n\nfor i in range(n):\n  dp2[i]=i+1\nsize=2\n\nwhile size<=n:\n  i=0\n  while i<n-size+1:\n    j=i+size-1\n    k=i\n    while k<j:\n      if dp1[i][k]!=-1:\n        if dp1[i][k]==dp1[k+1][j]:\n          dp1[i][j]=dp1[i][k]+1\n      k+=1\n    i+=1\n  size+=1\n\ni=0\nwhile i<n:\n  k=0\n  while k<=i:\n    if dp1[k][i]!=-1:\n      if k==0:\n        dp2[i]=1\n      else:\n        dp2[i]=min(dp2[i],dp2[k-1]+1)\n    k+=1\n  i+=1\n\nprint(dp2[n-1])","output":"cubic"},{"instruction":"n = int(input())\n\narr = list(map(int, input().split(' ')))\narr.sort()\n\nstop = 0\nequal = -1\ntempcounter = 0\n\nfor i in range(1, n):\n    if arr[i] == arr[i-1]:\n        equal = arr[i]\n        tempcounter += 1\n        if tempcounter == 2:\n            break\n\nif tempcounter == 1 and equal != 0:\n    for j in range(n):\n        if arr[j] == equal-1:\n            print(\"cslnb\")\n            stop = 1\n\nif tempcounter == 1 and equal == 0:\n    print(\"cslnb\")\n\nelif tempcounter < 2 and stop == 0:\n    moves = arr[0]\n    counter = 0\n\n    for i in range(1, n):\n        moves += arr[i] - i\n\n    if counter == 0:\n        if moves%2 == 0:\n            print(\"cslnb\")\n\n        else:\n            print(\"sjfnb\")\n\nelif stop == 0:\n    print(\"cslnb\")","output":"nlogn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nc=0\npo=[0]*1000000\nne=[0]*1000000\nfor i in range(n):\n    if(a[i]<0 and ne[a[i]]!=1):\n        c+=1\n        ne[a[i]]=1\n    elif(a[i]>0 and po[a[i]]!=1):\n        c+=1\n        po[a[i]]=1\nprint(c)","output":"linear"},{"instruction":"n = int(input())\nf0= 0\nf1 = 1\nli = [0,1]\nfor i in range(45):\n\tt = f1\n\tf1 += f0\n\tf0 = t\n\tli.append(f1)\nx = []\nfor i in range(3):\n\tfor i in range(len(li)-1, -1, -1):\n\t\tif li[i] <= n:\n\t\t\tn -= li[i]\n\t\t\tx.append(li[i])\n\t\t\tbreak\nif n == 0:\n\tprint(*x, sep = \" \")\nelse:\n\tprint(\"I'm too stupid to solve this problem\")","output":"constant"},{"instruction":"r=input()\nt1=int(r)\nt2=int(r[:len(r)-1])\nt3=int(r[:len(r)-2]+r[-1])\nprint(max(t1,t2,t3))","output":"constant"},{"instruction":"n,m,a,b=[int(x)for x in input().split()]\nif n<m:print(min(a*(m-n),b*n))\nelse:print(min(b*(n%m),a*(m-(n%m)) ))","output":"linear"},{"instruction":"import sys\nfrom itertools import accumulate\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nH, W = MAP()\ngrid = build_grid(H, W, '\n\nans = []\nimosw = list2d(H+2, W+2, 0)\nimosh = list2d(H+2, W+2, 0)\ndef check(i, j):\n    sz = min(L[i][j], R[i][j], U[i][j], D[i][j])\n    if sz > 1:\n        imosw[i][j-sz+1] += 1\n        imosw[i][j+sz] -= 1\n        imosh[i-sz+1][j] += 1\n        imosh[i+sz][j] -= 1\n        ans.append((i, j, sz-1))\n\ndef check2():\n    for i in range(1, H+1):\n        for j in range(1, W+1):\n            if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]:\n                return False\n    return True\n\nL = list2d(H+2, W+2, 0)\nR = list2d(H+2, W+2, 0)\nU = list2d(H+2, W+2, 0)\nD = list2d(H+2, W+2, 0)\nfor i in range(1, H+1):\n    for j in range(1, W+1):\n        if grid[i][j] == '.':\n            L[i][j] = 0\n        else:\n            L[i][j] = L[i][j-1] + 1\nfor i in range(1, H+1):\n    for j in range(W, 0, -1):\n        if grid[i][j] == '.':\n            R[i][j] = 0\n        else:\n            R[i][j] = R[i][j+1] + 1\nfor j in range(1, W+1):\n    for i in range(1, H+1):\n        if grid[i][j] == '.':\n            U[i][j] = 0\n        else:\n            U[i][j] = U[i-1][j] + 1\nfor j in range(1, W+1):\n    for i in range(H, 0, -1):\n        if grid[i][j] == '.':\n            D[i][j] = 0\n        else:\n            D[i][j] = D[i+1][j] + 1\n\nfor i in range(1, H+1):\n    for j in range(1, W+1):\n        if grid[i][j] == '*':\n            check(i, j)\nfor i in range(1, H+1):\n    for j in range(W+1):\n        imosw[i][j+1] += imosw[i][j]\nfor j in range(1, W+1):\n    for i in range(H+1):\n        imosh[i+1][j] += imosh[i][j]\n\nif check2():\n    print(len(ans))\n    [print(h, w, sz) for h, w, sz in ans]\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"n, q = map(int, input().split())\nfor _ in range(q):\n    u = int(input())\n    s = input()\n    for comm in s:\n        k = 1\n        while True:\n            if k & u:\n                break\n            k <<= 1\n        if comm == 'L':\n            if k != 1:\n                u -= k\n                u += (k>>1)\n        elif comm == 'R':\n            if k != 1:\n                u += (k>>1)\n        elif comm == 'U':\n            nu = u - k\n            nu |= (k<<1)\n            if nu <= n:\n                u = nu\n    print(u)","output":"np"},{"instruction":"import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter,deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap)-1)\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        item, heap[0] = heap[0], item\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\nclass Prime:\n    def __init__(self,N):\n        assert N<=10**8\n        self.smallest_prime_factor=[None]*(N+1)\n        for i in range(2,N+1,2):\n            self.smallest_prime_factor[i]=2\n        n=int(N**.5)+1\n        for p in range(3,n,2):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n                for i in range(p**2,N+1,2*p):\n                    if self.smallest_prime_factor[i]==None:\n                        self.smallest_prime_factor[i]=p\n        for p in range(n,N+1):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]\n\n    def Factorize(self,N):\n        assert N>=1\n        factorize=defaultdict(int)\n        if N<=len(self.smallest_prime_factor)-1:\n            while N!=1:\n                factorize[self.smallest_prime_factor[N]]+=1\n                N\/\/=self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N%p==0:\n                    N\/\/=p\n                    factorize[p]+=1\n                if N<p*p:\n                    if N!=1:\n                        factorize[N]+=1\n                    break\n                if N<=len(self.smallest_prime_factor)-1:\n                    while N!=1:\n                        factorize[self.smallest_prime_factor[N]]+=1\n                        N\/\/=self.smallest_prime_factor[N]\n                    break\n            else:\n                if N!=1:\n                    factorize[N]+=1\n        return factorize\n\n    def Divisors(self,N):\n        assert N>0\n        divisors=[1]\n        for p,e in self.Factorize(N).items():\n            A=[1]\n            for _ in range(e):\n                A.append(A[-1]*p)\n            divisors=[i*j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self,N):\n        return N==self.smallest_prime_factor[N]\n\n    def Totient(self,N):\n        for p in self.Factorize(N).keys():\n            N*=p-1\n            N\/\/=p\n        return N\n\n    def Mebius(self,N):\n        fact=self.Factorize(N)\n        for e in fact.values():\n            if e>=2:\n                return 0\n        else:\n            if len(fact)%2==0:\n                return 1\n            else:\n                return -1\n\nN=int(readline())\nA=list(map(int,readline().split()))\nmod=10**9+7\nm=max(A)\ncnt=[0]*(m+1)\nP=Prime(m)\nfor a,c in Counter(A).items():\n    for aa in P.Divisors(a):\n        cnt[aa]+=c\nfor i in range(1,m+1):\n    cnt[i]=pow(2,cnt[i],mod)-1\n    cnt[i]%=mod\nfor p in P.primes:\n    for i in range(p,m+1,p):\n        cnt[i\/\/p]-=cnt[i]\n        cnt[i\/\/p]%=mod\nans=cnt[1]\nprint(ans)","output":"np"},{"instruction":"n = int(input())\nrng = []\nfor _ in range(n):\n    x, w = map(int, input().split())\n    rng.append((x-w, x+w))\nrng.sort(key=lambda x: (x[1], x[0]))\n\nans = 0\ntmp = - 10 ** 10\nfor l, r in rng:\n    if tmp <= l:\n        ans += 1\n        tmp = r\n\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin\nfrom bisect import bisect_right as br\n\nfrom collections import deque\nn,m,k=map(int,stdin.readline().strip().split())\ns=deque(map(int,stdin.readline().strip().split()))\nlim=k\nans=0\nwhile len(s)!=0:\n    x=br(s,lim)\n    for i in range(x):\n        s.popleft()\n    if x!=0:\n        ans+=1\n        lim+=x\n    else:\n        if len(s)>0:\n            x=s[0]-lim\n            if x%k==0:\n                x=x\/\/k\n            else:\n                x=(x\/\/k)+1\n            lim+=x*k\n\nprint(ans)","output":"linear"},{"instruction":"a = list(input())\nb = int(input())\na = sorted(a, reverse=True)\nans = ''\nwhile len(a) > 0:\n    for i in range(len(a)):\n        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))\n        if int(tmp) <= b:\n            ans += a[i]\n            a = a[:i] + a[i + 1:]\n            break\nprint(ans)","output":"cubic"},{"instruction":"n=int(input())\n\nx=1\n\nwhile n>(10**(len(str(x))-1)*9*len(str(x))):\n    n-=10**(len(str(x))-1)*9*len(str(x))\n\n    x*=10\n\nt=len(str(x))\nnadighe=False\nwhile nadighe==False:\n    qw=1\n    nadighe=True\n    while n>(10**(len(str(qw))-1)*9*t):\n        n-=10**(len(str(qw))-1)*9*t\n        nadighe=False\n        qw*=10\n    x+=qw-1\n\nwhile n>len(str(x)):\n    n-=len(str(x))\n    x+=1\nfor i in range(len(str(x))):\n    if n!=0:\n        s=str(x)[i]\n        n-=1\nprint(s)","output":"constant"},{"instruction":"n=int(input())\nl=[input() for i in range(n)]\n\ns=sorted(l,key=len)\nfor i in range(1,n):\n    if s[i-1] not in s[i]:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in s:\n    print(i)","output":"nlogn"},{"instruction":"l=list(map(int,input().split()))\nans=0\nfor i in range(14):\n\ta=[]\n\tm=0\n\ta.extend(l)\n\tc=a[i]\/\/14\n\td=a[i]%14\n\ta[i]=0\n\tj=1\n\twhile(j<=d):\n\t\tk=(i+j)%14\n\t\ta[k]+=1\n\t\tj+=1\n\tfor j in range(14):\n\t\ta[j]+=c\n\t\tif a[j]%2==0:\n\t\t\tm+=a[j]\n\tans=max(ans, m)\nprint(ans)","output":"constant"},{"instruction":"import sys\nreadline = sys.stdin.buffer.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\n\ndp = [[0]*N for _ in range(N)]\nfor j in range(N):\n    dp[j][0] = A[j]\n\nfor l in range(1, N):\n    for j in range(l, N):\n        for k in range(j-l, j):\n            if dp[k][k-j+l] == dp[j][j-k-1] > 0:\n                dp[j][l] = 1+dp[j][j-k-1]\n                break\n\ndp = [None] + dp\nDp = [0]*(N+1)\nfor j in range(1, N+1):\n    res = N\n    for l in range(j):\n        if dp[j][l]:\n            res = min(res, 1+Dp[j-l-1])\n    Dp[j] = res\nprint(Dp[N])","output":"cubic"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = rint()\n    deg = [0] * n\n    if n == 2:\n        exit(print(f'Yes\\n1\\n1 2'))\n\n    for i in range(n - 1):\n        u, v = rints()\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n\n    ix = deg.index(max(deg))\n\n    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:\n        print(f'Yes\\n{deg.count(1)}')\n\n        for i in range(n):\n            if deg[i] == 1:\n                print(i + 1, ix + 1)\n    else:\n        print('No')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n\nelse:\n    sys.stdin = open('input.txt')\n\nn = ria()[0]\nx, y = ria()\nd1 = abs(1 - x) + abs(1 - y)\nd2 = abs(n - x) + abs(n - y)\nif d1<=d2:\n    print('White')\nelse:\n    print('Black')","output":"constant"},{"instruction":"if __name__ == '__main__':\n\t\tn,m = map(int, input().split())\n\t\tl = list(map(int, input().split()))\n\t\td = dict()\n\t\tif len(set(l)) < n:\n\t\t\tprint(0)\n\t\telse:\n\t\t\tfor i in range (m):\n\t\t\t\td.setdefault(l[i],0)\n\t\t\t\td[l[i]]+=1\n\t\t\tmin1 = 999999999\n\t\t\tfor i in d.values():\n\t\t\t\tif i < min1 :\n\t\t\t\t\tmin1 = i\n\t\t\tprint(min1)","output":"quadratic"},{"instruction":"from heapq import *\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    inf=10**9\n    n=II()\n    aa=LI()\n    dp1=[[-1]*(n+1) for _ in range(n)]\n    to=[[i+1] for i in range(n)]\n    for i in range(n):dp1[i][i+1]=aa[i]\n    for w in range(2,n+1):\n        for l in range(n-w+1):\n            r=l+w\n            for m in range(l+1,r):\n                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m][r]:\n                    dp1[l][r]=dp1[l][m]+1\n                    to[l].append(r)\n    hp=[]\n    heappush(hp,(0,0))\n    dist=[-1]*(n+1)\n    while hp:\n        d,i=heappop(hp)\n        if i==n:\n            print(d)\n            break\n        if dist[i]!=-1:continue\n        dist[i]=d\n        for j in to[i]:\n            if dist[j]!=-1:continue\n            heappush(hp,(d+1,j))\n\nmain()","output":"cubic"},{"instruction":"a = [int(i) for i in list(input())]\nb = [int(i) for i in list(input())]\n\nif (len(a)<len(b)):\n\ta.sort(reverse=True)\n\tans = 0\n\tfor i in range(len(a)):\n\t\tans = ans*10+a[i]\n\tprint(ans)\nelse:\n\n\tans = 0\n\tn = len(a)\n\tcount = [0]*10\n\tfor i in range(n):\n\t\tcount[a[i]] += 1\n\ti = 0\n\twhile (i<n):\n\t\tx = b[i]\n\t\tif (count[x]>0):\n\t\t\tans = ans*10+x\n\t\t\tcount[x] -= 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tbreak\n\tif (i==n):\n\t\tprint(ans)\n\t\texit(0)\n\tx = b[i]\n\tflag = False\n\tfor j in range(x-1,-1,-1):\n\t\tif (count[j]>0):\n\t\t\tans = ans*10+j\n\t\t\tcount[j] -= 1\n\t\t\tflag = True\n\t\t\tbreak\n\tif (flag) :\n\t\tfor j in range(9,-1,-1):\n\t\t\twhile (count[j]>0):\n\t\t\t\tans = ans*10+j\n\t\t\t\tcount[j] -= 1\n\telse:\n\t\twhile (not flag):\n\t\t\tt = ans%10\n\t\t\tans = ans\/\/10\n\t\t\tcount[t] += 1\n\t\t\tfor i in range(t-1,-1,-1):\n\t\t\t\tif (count[i]>0):\n\t\t\t\t\tcount[i] -= 1\n\t\t\t\t\tflag = True\n\t\t\t\t\tans = ans*10 + i\n\t\t\t\t\tbreak\n\t\tfor j in range(9,-1,-1):\n\t\t\twhile (count[j]>0):\n\t\t\t\tans = ans*10+j\n\t\t\t\tcount[j] -= 1\n\tprint(ans)","output":"cubic"},{"instruction":"def binary(n,k):\n    lower=1\n    upper=n\n    while(lower<upper):\n        mid=(lower+upper)\/\/2\n        total=(mid*(mid+1))\/\/2\n        if n-mid==total-k:\n            print(n-mid)\n            break\n        else:\n            if n-mid>total-k:\n                lower=mid+1\n            else:\n                upper=mid\n\nn,k=map(int,input().split())\nif n==1 and k==1:\n    print(0)\nelse:\n    binary(n,k)","output":"logn"},{"instruction":"import sys\nfrom enum import Enum\n\nclass flag(Enum):\n    UNVISITED = -1\n    EXPLORED = -2\n    VISITED = -3\n\ndef match(p, s):\n    for i in range(len(p)):\n        if p[i] != \"_\" and p[i] != s[i]:\n            return False\n    return True\n\ndef cycleCheck(u):\n    global AL\n    global dfs_num\n    global dfs_parent\n    global sol\n\n    dfs_num[u] = flag.EXPLORED.value\n    for v in AL[u]:\n        if dfs_num[v] == flag.UNVISITED.value:\n            dfs_parent[v] = u\n            cycleCheck(v)\n        elif dfs_num[v] == flag.EXPLORED.value:\n            sol = False\n    dfs_num[u] = flag.VISITED.value\n\ndef toposort(u):\n    global AL\n    global dfs_num\n    global ts\n\n    dfs_num[u] = flag.VISITED.value\n    for v in AL[u]:\n        if dfs_num[v] == flag.UNVISITED.value:\n            toposort(v)\n    ts.append(u)\n\nsol = True\nn, m, k = map(int, sys.stdin.readline().strip().split())\npd = {}\nps = set()\npa = []\nfor i in range(n):\n    p = sys.stdin.readline().strip()\n    pd[p] = i + 1\n    ps.add(p)\n    pa.append(p)\n\nAL = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, fn = sys.stdin.readline().strip().split()\n    fn = int(fn)\n    if not match(pa[fn-1], s):\n        sol = False\n\n    mm = [\"\"]\n    for i in s:\n        mm = list(map(lambda x: x + \"_\", mm)) + list(map(lambda x: x + i, mm))\n    for i in mm:\n        if i in ps:\n            if pd[i] != fn:\n                AL[fn-1].append(pd[i]-1)\n\ntry:\n    if not sol:\n        print(\"NO\")\n    else:\n        dfs_num = [flag.UNVISITED.value] * n\n        dfs_parent = [-1] * n\n        for u in range(n):\n            if dfs_num[u] == flag.UNVISITED.value:\n                cycleCheck(u)\n        if not sol:\n            print(\"NO\")\n        else:\n            dfs_num = [flag.UNVISITED.value] * n\n            ts = []\n            for u in range(n):\n                if dfs_num[u] == flag.UNVISITED.value:\n                    toposort(u)\n            ts = ts[::-1]\n            print(\"YES\")\n            print(' '.join(map(lambda x: str(x+1), ts)))\nexcept:\n    print(\"NO\")","output":"np"},{"instruction":"vals=list(map(int,input().split()))\nl=vals[0]\nr=vals[1]\n\nif l==r:\n    print(\"0\")\nelse:\n    i=0\n    j=0\n    while l>0 or r>0:\n        i+=1\n        if (l&1)^(r&1)==1:\n            j=i\n        l=l>>1\n        r=r>>1\n    ans=1\n    for i in range(0,j):\n        ans=ans*2\n    ans-=1\n    print(ans)","output":"logn"},{"instruction":"n = input()\nans = 0\nj = 2\nfor i in range(2,n\/2 + 1):\n    while i * j <= n:\n        ans += j * 4\n\n        j += 1\n    else :j = 2\nprint(ans)","output":"nlogn"},{"instruction":"import sys\nn = int(input().strip())\nsizes = list(map(int, input().strip().split()))\ncost = list(map(int, input().strip().split()))\ntot = []\nfor i in range(n):\n    tot.append([sizes[i], cost[i]])\nret = False\nlcomp = []\nfor j in range(len(tot)):\n    if j > 0 and j < len(tot)-1:\n        temp1 = tot[:j]\n        temp2 = tot[j+1:]\n        mi_1 = sys.maxsize\n        ret1 = False\n        for i in range(len(temp1)):\n            if temp1[i][0] < tot[j][0]:\n                mi_1 = min(mi_1, temp1[i][1])\n                ret1 = True\n        mi_2 = sys.maxsize\n        ret2 = False\n        for k in range(len(temp2)):\n            if temp2[k][0] > tot[j][0]:\n                mi_2 = min(mi_2, temp2[k][1])\n                ret2 = True\n        if ret1 and ret2:\n            ret = True\n            lcomp.append(mi_1+tot[j][1]+mi_2)\n\nif ret:\n    print(min(lcomp))\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"for _ in range(int(input())):\n\ta, b = map(int, input().split())\n\tresult = 0\n\twhile min(a, b)!=0:\n\t\tx = max(a, b)\n\t\ty = min(a, b)\n\t\ta = x\n\t\tb = y\n\t\tresult+=a\/\/b\n\t\ta%=b\n\tprint(result)","output":"constant"},{"instruction":"class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        res = []\n\n        for i in range(n):\n            count = 1\n            j = i + 1\n            while j < n:\n                if temperatures[j] > temperatures[i]:\n                    break\n                j += 1\n                count += 1\n            count = 0 if j == n else count\n            res.append(count)\n        return res","output":"quadratic"},{"instruction":"R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr.sort()\ng.sort()\nb.sort()\ndp = [[[0]*202 for i in range(202)] for j in range(202)]\nfor i in range(R+1):\n       for j in range(G+1):\n              for k in range(B+1):\n                     if i and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n                     if i and k:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n                     if k and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\nans = 0\nfor i in dp:\n       for j in i:\n              ans = max(ans, max(j))\n\nprint(ans)","output":"cubic"},{"instruction":"def getIntList():\n    return list(map(int, input().split()));\nn, k = getIntList();\np=getIntList();\nchoosed=[False]*256;\nleft=[i for i in range(256)];\nfor i, x in enumerate(p):\n    if not choosed[x]:\n        best=x;\n\n        for j in range(x-1, max(-1, x-k), -1):\n\n            if not choosed[j]:\n                best=j;\n            else:\n                if x-left[j]<k:\n                    best=left[j];\n                break;\n\n        for j in range(best, x+1):\n            choosed[j]=True;\n            left[j]=best;\n    p[i]=left[x];\nprint(' '.join(map(str, p)));","output":"quadratic"},{"instruction":"import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\ncount = [[0] * m for _ in range(m)]\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        count[c1][c2] += 1\n\nsum_of_subset = [[0] * (1 << m) for _ in range(m)]\nfor i in range(m):\n    for j in range(1 << m):\n        if j == 0:\n            continue\n        lsb = j & -j\n        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n\nadj_in_subset = [0] * (1 << m)\nfor i in range(1 << m):\n    for j in range(m):\n        if i & (1 << j):\n            adj_in_subset[i] += sum_of_subset[j][i]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)\nprint(dp[-1])","output":"np"},{"instruction":"import math\nimport collections\n\ndef func(a, k):\n    if a % k != 0:\n        mod = 1\n    else:\n        mod = 0\n    return math.floor(a \/ k) * k + mod * k\n\nn, m, k = input().split()\nlist = input().split()\nk = int(k)\ntemp = k\nsize = 0\nanswer = 0\nc = 0\nc2 = 0\ncheck = 'false'\nused = 0\n\ntemp = func(int(list[0]), k)\nfor i in range(len(list)):\n    list[i] = int(list[i])\n    used = 0\n    if list[i] <= temp:\n        c += 1\n        check = 'true'\n        used = 1\n    if list[i] >= temp:\n        if check is 'true':\n            answer += 1\n            check = 'false'\n            temp += c\n            c = 0\n            if list[i] - c <= temp and used == 0:\n                c += 1\n                check = 'true'\n                used = 1\n            else:\n                temp = temp + func(int(list[i]) - temp, k)\n                if list[i] - c <= temp and used == 0:\n                    c += 1\n                    check = 'true'\n                    used = 1\n        elif check is 'false':\n            temp = temp + func(int(list[i]) - temp, k)\n            if list[i] - c <= temp and used == 0:\n                c += 1\n                check = 'true'\n                used = 1\n\nprint(answer if check is 'false' else answer + 1)","output":"linear"},{"instruction":"N = int(input())\n\narr = list(map(int, input().split()))\n\ndp = [[-1 for x in range(N)] for y in range(N)]\n\nfor size in range(1, N + 1):\n    for i in range(N - size + 1):\n        j = i + size - 1\n        if (i == j):\n            dp[i][j] = arr[i]\n        else:\n            for k in range(i, j):\n                if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]):\n                    dp[i][j] = dp[i][k] + 1\n\ndp2 = [x+1 for x in range(N)]\n\nfor i in range(N):\n    for k in range(i + 1):\n        if (dp[k][i] != -1):\n            if (k == 0):\n                dp2[i] = 1\n            else:\n                dp2[i] = min(dp2[i], dp2[k - 1] + 1)\n\nprint(dp2[N - 1])","output":"cubic"},{"instruction":"M = {}\n\nN = int(input())\nS = input().strip()\n\ns = set()\nfor c in S:\n    s.add(c)\n    M[c] = 0\n\ni = 0; j = -1; aux = 0; ans = 1e10\nwhile j < N - 1:\n    j += 1\n\n    M[S[j]] += 1\n    if M[S[j]] == 1:\n        aux += 1\n    while M[S[i]] > 1:\n        M[S[i]] -= 1\n        i += 1\n\n    if aux == len(s):\n        ans = min(ans, j - i + 1)\n\nprint(ans)","output":"linear"},{"instruction":"k1, k2, k3  = sorted(map(int, input().split()))\n\nif 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \\\n    or (k1 == 2 and k2 == 4 and k3 == 4):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"x,k = map(int,input().split())\nmod = 10**9 + 7\nif x == 0:\n    print(0)\nelse:\n    print(((2*x-1)*pow(2,k,mod) + 1)%mod)","output":"logn"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = int(input())\n    p = [list(map(float,input().split())) for _ in range(n)]\n    y = 1<<n\n    dp = [[0]*y for _ in range(n)]\n\n    dp[0][y-1] = 1\n    for i in range(y-2,-1,-1):\n        mask = 1\n        for j in range(n):\n            if not mask&i:\n                mask <<= 1\n                continue\n            mask1 = 1\n            for k in range(n):\n                if i&mask1:\n                    mask1 <<= 1\n                    continue\n                dp[j][i] = max(dp[j][i],\n                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])\n                mask1 <<= 1\n            mask <<= 1\n    print(max(dp[i][1<<i] for i in range(n)))\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"from itertools import combinations\n\np, minn, maxn, dif = map(int, input().split())\n(*lst,) = map(int, input().split())\nc = 0\nfor i in range(2, p + 2):\n    for j in combinations(lst, i):\n        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):\n            c += 1\nprint(c)","output":"np"},{"instruction":"from math import gcd\n\ndef t_prime(n):\n    if n == 1:\n        return False\n    for p in [2,3,5,7,11,13,17,19,23]:\n        if p < n and pow(p,n-1,n) != 1:\n            return False\n    return True\n\nprimes = [i for i in range(2,10**5) if t_prime(i)]\npset = set(primes)\n\nn, k = map(int, input().split())\nl = list(map(int, input().split()))\n\nif k == 1:\n    print(0)\n    exit()\n\nfor i in range(n):\n    for j in range(i):\n        u, v = l[i], l[j]\n        poss = gcd(u,v)\n        poss2 = max(u,v)\/\/poss\n        smol = min(poss,poss2)\n        if t_prime(smol) and smol not in pset:\n            primes.append(smol)\n            pset.add(smol)\n\npowers = set()\n\ncount = 0\noutLs = []\npgood = []\nfor p in primes:\n    curr = []\n    fp = [v for v in l if v % p == 0]\n    for v in fp:\n        v2 = v\n        while v2 % p == 0:\n            v2 \/\/= p\n        if v2 == 1:\n            curr.append(v)\n            powers.add(v)\n    if len(curr) > 1:\n        count += len(curr)\n        outLs.append(curr)\n        pgood.append(p)\n\norder = [(len(lis), lis) for lis in outLs]\norder.sort(key = lambda x: x[0])\n\nif len(order) == 0:\n    print(0)\n    exit()\n\nif order[-1][0] == 2 and k % 2 and count > k:\n    extra = -1\n    need = -1\n    last = []\n\n    for v in l:\n        if v in powers:\n            continue\n\n        v2 = v\n        primesn = []\n        for p in pgood:\n            add = 1\n            while v2 % p == 0:\n                v2 \/\/= p\n                if add:\n                    primesn.append(p)\n                add = 0\n        if v2 == 1 and (need == -1 or need > len(primesn)):\n            extra = v\n            last = primesn\n            need = len(last)\n            assert need >= 2\n\n    if need == -1 or 2 * need + 1 > k:\n        print(0)\n        exit()\n\n    other = []\n    out = [extra]\n\n    for a,b in outLs:\n        works = False\n        for p in last:\n            if a % p == 0:\n                works = True\n                break\n        if works:\n            out.append(a)\n            out.append(b)\n        else:\n            other.append(a)\n            other.append(b)\n\n    assert len(out) == 2 * need + 1\n    assert (k - 2 * need - 1) % 2 == 0\n\n    ret = out + other[:(k - 2*need - 1)]\n    assert len(ret) == k\n\n    print(' '.join(map(str,ret)))\n    exit()\n\nout = []\nneed = k\nfor i in range(len(order)):\n    assert need != 1\n\n    lis = order[i][1]\n    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):\n        out += lis\n        need -= len(lis)\n    elif len(lis) == need - 1:\n        if len(lis) > 2:\n            out += lis[:-1]\n            need -= (len(lis) - 1)\n            assert need == 2\n    else:\n        out += lis[:need]\n        need = 0\n\nassert need + len(out) == k\nassert need >= 0\nassert need == 0 or len(out) == count\n\nfor v in l:\n    if need == 0:        break\n    if v in powers:        continue\n    v2 = v\n    for p in pgood:\n        while v2 % p == 0:            v2 \/\/= p\n    if v2 == 1:        out.append(v);        need -= 1\n\nif need == 0:\n    print(' '.join(map(str,out)))\n    exit()\nelse:\n    print(0)","output":"np"},{"instruction":"n, s = map(int, input().split())\n\na, b, c = 0, n + 1, 0\n\nwhile a < b:\n    c = (a + b) \/\/ 2\n    if c - sum([int(x) for x in str(c)]) < s:\n        a = c + 1\n    else:\n        b = c\n\nprint(n - b + 1)","output":"logn"},{"instruction":"N, mod = map(int, input().split())\n\ntwo = [1] * (N+1)\nfact = [1] * (N+1)\ninv = [1] * (N+1)\nfor i in range(1, N+1):\n    two[i] = two[i-1]*2 % mod\nfor i in range(2, N+1):\n    fact[i] = fact[i-1] * i % mod\ninv[N] = pow(fact[N], mod-2, mod)\nfor i in range(N, 0, -1):\n    inv[i-1] = inv[i] * i % mod\n\ndp = [[0] * (N+2) for _ in range(N+2)]\ndp[0][0] = 1\nfor i in range(N):\n    for j in range(i+1):\n        for k in range(1, N+1):\n            if i+k > N:\n                break\n            dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod\n            dp[i+k+1][j+1] %= mod\n\nans = 0\nfor j in range(1, N+1):\n    ans += dp[N+1][j] * fact[N-j+1] % mod\n    ans %= mod\nprint(ans)","output":"cubic"},{"instruction":"n = list(map(int, input().split()))\nu = []\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu[0].sort(reverse=True)\nu[1].sort(reverse=True)\nu[2].sort(reverse=True)\nres = 0\ndp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]\nfor i in range(n[0]+1):\n    for j in range(n[1]+1):\n        for k in range(n[2]+1):\n            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0\n            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0\n            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0\n            dp[i][j][k] = max(x0, x1, x2)\n            res = max(res, dp[i][j][k])\nprint(res)","output":"cubic"},{"instruction":"n,m,a,b=[int(x) for x in input().split()]\nif n>m:\n\tif n%m==0:\n\t\tprint(0)\n\telse:\n\t\tt1=n%m\n\t\tprint(min(t1*b,(m-t1)*a))\nelif n==m:\n\tprint(0)\nelse:\n\tprint(min(n*b,(m-n)*a))","output":"linear"},{"instruction":"l,r = map(int,input().split())\n\nx = 64\nwhile x>=0 and  (l&(1<<x)) == (r&(1<<x)):\n    x-=1\nprint((1<<(x+1))-1)","output":"logn"},{"instruction":"import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nn = int(rd())\nc = list(map(int, rd().split()))\na = list(map(lambda x: int(x)-1, rd().split()))\n\nvisited = [-1] * (n)\nres = 0\n\nfor i in range(n):\n    trace = []\n\n    t = i\n    mn = 1e9\n    while visited[t] == -1:\n        visited[t] = i\n        trace.append(t)\n        t = a[t]\n\n    if visited[t] != i:\n        continue\n\n    while len(trace) > 0:\n        v = trace.pop()\n        mn = min(mn, c[v])\n\n        if t == v: break\n\n    res += mn\n\nprint(res)","output":"linear"},{"instruction":"a,b=map(int,input().split())\nans=0\nwhile a and b:\n  ans+=a\/\/b\n  a,b=b,a%b\nprint(ans)","output":"constant"},{"instruction":"import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\ni = a.index(max(a))\nv = True\nfor j in range (0, i):\n    if a[j] > a[j+1]:\n        v = False\nfor j in range (i, n-1):\n    if a[j] < a[j+1]:\n        v = False\nif v == True:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"n=int(input())\na=input().split(' ')\nfor i in range(len(a)):\n    a[i]=int(a[i])\nkhat=n*[0]\nted=0\nassl=0\nkhat[0]=1\nlol=[0,0]\nfor i in range(1,len(khat)):\n    khat[i]=max([khat[i-1],a[i]+1])\nfor i in range(len(khat)-2,-1,-1):\n    if khat[i]<khat[i+1]-1:\n        khat[i]=khat[i+1]-1\n    ted=ted+(khat[i]-(a[i]+1))\nted=ted+(khat[n-1]-(a[n-1]+1))\nprint(ted)","output":"linear"},{"instruction":"n, m = map(int, input().split())\n\na = []\n\ndef is_center(a, y, x):\n    count1 = count2 = count3 = count4 = 0\n\n    y1 = y\n    x1 = x\n    while True:\n        y2 = y1 - 1\n        if y2 < 0:\n            break\n        c = a[y2][x]\n        if c == \"W\":\n            break\n        count1 += 1\n        y1 = y2\n\n    y1 = y\n    x1 = x\n    while True:\n        y2 = y1 + 1\n        if y2 == n:\n            break\n        c = a[y2][x]\n        if c == \"W\":\n            break\n        count2 += 1\n        y1 = y2\n\n    y1 = y\n    x1 = x\n    while True:\n        x2 = x1 - 1\n        if x2 < 0:\n            break\n        c = a[y1][x2]\n        if c == \"W\":\n            break\n        count3 += 1\n        x1 = x2\n\n    y1 = y\n    x1 = x\n    while True:\n        x2 = x1 + 1\n        if x2 == m:\n            break\n        c = a[y1][x2]\n        if c == \"W\":\n            break\n        count4 += 1\n        x1 = x2\n\n    return count1 == count2 == count3 == count4 and a[y][x] == \"B\"\n\nfor k in range(n):\n    s = input()\n    a.append(s)\n\nfor y in range(n):\n    c = False\n    for x in range(m):\n        if is_center(a, y, x):\n            print(y+1, x+1)\n            c = True\n            break\n    if c:\n        break","output":"quadratic"},{"instruction":"from math import log\nn,k=map(int,input().split())\ns=list(map(int,input().split()))\nans=0\nfor j in range(11):\n    d=dict()\n    z=10**j\n    for i in s:\n        y=i*z\n        u=y%k\n        if u in d:\n            d[u]+=1\n        else:\n            d.update({u:1})\n    for i in s:\n        y=i\n        lg=int(log(i,10))+1\n        lg=10**lg\n        if lg==z:\n            d[(y*z)%k]-=1\n            x=(k-y%k)\n            if y%k==0:\n                x=0\n            if x in d:\n                ans+=d[x]\n            d[(y*z)%k]+=1\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input())\nli1 = []\ns=\"\"\nli2 = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\",\"yellow\":\"Mind\"}\nfor i in range(n):\n    s = input()\n    li1.append(s)\nprint(6-n)\nfor key in li2:\n    if key in li1:\n        continue\n    else:\n        li1.append(key)\n        print(li2[key])","output":"constant"},{"instruction":"n, q = map(int, raw_input().split())\nl = raw_input()\ncnt1, cnt0 = [0]*(n+1), [0]*(n+1)\nmod = 10**9 + 7\nfor i in range(len(l)):\n\tif l[i] == '1':\n\t\tcnt1[i+1] = cnt1[i] + 1\n\t\tcnt0[i+1] = cnt0[i]\n\telse:\n\t\tcnt0[i+1] = cnt0[i] + 1\n\t\tcnt1[i+1] = cnt1[i]\npow2 = [1]\nfor i in range(1, 10**5 + 10):\n\tpow2.append((2*pow2[-1])%mod)\nfor i in range(q):\n\tl, r = map(int, raw_input().split())\n\tones = cnt1[r] - cnt1[l-1]\n\tzeroes = cnt0[r] - cnt0[l-1]\n\tt1 = (pow2[ones] - 1)%mod\n\tt2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod\n\tprint((t1+t2)%mod)","output":"linear"},{"instruction":"n,m=map(int,input().split())\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\nl=[]\nfor i in range(m):\n    if y[i] in x:\n        l.append(x.index(y[i]))\nl.sort()\nfor i in l:\n    print(x[i],end=\" \")","output":"quadratic"},{"instruction":"import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\nclass Node:\n    val = None\n\n    def __init__(self, val):\n        self.val = val\n        self.left = Node\n        self.right = None\n\ndef solve(W, H, N, A):\n    xs = [0] + [v for t, v in A if t == 0] + [W]\n    ys = [0] + [v for t, v in A if t == 1] + [H]\n    xs.sort()\n    ys.sort()\n\n    xlist = Node(0)\n    h = xlist\n    xnodes = {0: h}\n    maxw = max([xs[i+1] - xs[i] for i in range(len(xs)-1)] or [0])\n    maxh = max([ys[i+1] - ys[i] for i in range(len(ys)-1)] or [0])\n    for v in xs[1:]:\n        n = Node(v)\n        xnodes[v] = n\n        h.right = n\n        n.left = h\n        h = n\n\n    ylist =  Node(0)\n    h = ylist\n    ynodes = {0: h}\n    for v in ys[1:]:\n        n = Node(v)\n        ynodes[v] = n\n        h.right = n\n        n.left = h\n        h = n\n\n    ans = []\n    maxarea = maxh * maxw\n    for t, v in reversed(A):\n        ans.append(maxarea)\n        if t == 0:\n            node = xnodes[v]\n            w = node.right.val - node.left.val\n            maxw = max(maxw, w)\n        else:\n            node = ynodes[v]\n            h = node.right.val - node.left.val\n            maxh = max(maxh, h)\n        node.left.right = node.right\n        node.right.left = node.left\n        maxarea = maxh * maxw\n\n    return ans[::-1]\n\ndef solve2(W, H, N, A):\n    ws = [(-W, 0, W)]\n    hs = [(-H, 0, H)]\n    iw, ih = set(), set()\n    ans = []\n\n    xs, ys = [0, W], [0, H]\n    for t, v in A:\n        if t == 0:\n            bisect.insort_left(xs, v)\n            i = bisect.bisect_left(xs, v)\n            l, m, r = xs[i-1], xs[i], xs[i+1]\n            iw.add((l-r, l, r))\n            heapq.heappush(ws, (l - m, l, m))\n            heapq.heappush(ws, (m - r, m, r))\n            while ws[0] in iw:\n                heapq.heappop(ws)\n        else:\n            bisect.insort(ys, v)\n            i = bisect.bisect_left(ys, v)\n            l, m, r = ys[i-1], ys[i], ys[i+1]\n            ih.add((l-r, l, r))\n            heapq.heappush(hs, (l - m, l, m))\n            heapq.heappush(hs, (m - r, m, r))\n            while hs[0] in ih:\n                heapq.heappop(hs)\n        w, h = ws[0], hs[0]\n        ans.append(w[0] * h[0])\n\n    return ans\n\nW, H, N = map(int,input().split())\nA = []\nfor i in range(N):\n    a, b = input().split()\n    c = 0 if a == 'V' else 1\n    A.append((c, int(b)))\n\nprint('\\n'.join(map(str, solve(W, H, N, A))))","output":"nlogn"},{"instruction":"s = input()\ntrgt = 0\nfor c in s:\n    trgt += (1 if c == '+' else -1)\n\ncmd = input()\n\nqueue = [[0, 0]]\ndests = []\n\nwhile queue:\n    nextqueue = []\n    for pos, cmdi in queue:\n        if cmdi == len(cmd):\n            dests.append(pos)\n            continue\n        nextcmd = cmd[cmdi]\n        if nextcmd == '+':\n            nextqueue.append([pos+1, cmdi+1])\n        elif nextcmd == '-':\n            nextqueue.append([pos-1, cmdi+1])\n        else:\n            nextqueue.append([pos + 1, cmdi + 1])\n            nextqueue.append([pos - 1, cmdi + 1])\n    queue = nextqueue\n\noccurs = 0\nfor x in dests:\n    if x == trgt:\n        occurs+=1\nprint(occurs \/ len(dests))","output":"np"},{"instruction":"n = int(input())\nm = int(input())\nprint(m%2**n)","output":"constant"},{"instruction":"N = 1030\nMOD = int(1e9+7)\nc = [[0] * N for i in range(N)]\nfor i in range(N):\n    c[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, N):\n        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD\n\narr = list(map(int, list(input())))\ncnt = int(input())\nif cnt == 0:\n    print(1)\n    exit()\n\ndp = [0] * N\nfor i in range(2, N):\n    dp[i] = dp[bin(i).count('1')] + 1\nres = 0\nfor i in range(1, N):\n    if dp[i] != cnt - 1:\n        continue\n    n, k = len(arr)-1, i\n    for pos in range(len(arr)):\n        if arr[pos] == 1:\n            res = (res + c[n][k]) % MOD\n            k -= 1\n        n -= 1\n    if n == -1 and k == 0:\n        res += 1\nif cnt == 1:\n    res -= 1\nprint(res)","output":"linear"},{"instruction":"def bin(n):\n    if n == 0:\n        return 1\n    else:\n        if n % 2 == 1:\n            return bin(n - 1) * 2\n        else:\n            b = (bin(n \/\/ 2)) % 1000000007\n            return b * b;\nx, k = map(int,input().split())\nif x == 0:\n    print(0)\nelse:\n    z = bin(k + 1) % 1000000007\n    z = z * (x - 1)\n    z = z % 1000000007\n    z += bin(k)\n    z += 1\n    while(z < 0):\n        z += 1000000007\n    print(z % 1000000007)","output":"logn"},{"instruction":"import random\n\nn = int(input())\nv = []\na = []\nfor i in range(n):\n    a.append(i)\n\nfor _ in range(0, n):\n    x, y = map(int, input().split())\n    v.append([x, y, x*x+y*y])\n\nwhile 1>0:\n    x = 0\n    y = 0\n    ans = [0]*n\n    random.shuffle(a)\n    for i in range(n):\n        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:\n            x += v[a[i]][0]\n            y += v[a[i]][1]\n            ans[a[i]] = 1\n        else:\n            x -= v[a[i]][0]\n            y -= v[a[i]][1]\n            ans[a[i]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break","output":"nlogn"},{"instruction":"n = int(input())\nqueen = list(map(int,input().split(\" \")))\nking = list(map(int,input().split(\" \")))\ntarget = list(map(int,input().split(\" \")))\n\ndef done():\n\tprint(\"NO\")\n\texit()\n\ndef complete():\n\tprint(\"YES\")\n\texit()\n\nif king[0] < queen[0]:\n\tif target[0] > queen[0]:\n\t\tdone()\n\n\tif king[1] > queen[1]:\n\t\tif target[1] < queen[1]:\n\t\t\tdone()\n\t\tcomplete()\n\telse:\n\t\tif target[1] > queen[1]:\n\t\t\tdone()\n\t\tcomplete()\nelse:\n\tif target[0] < queen[0]:\n\t\tdone()\n\tif king[1] > queen[1]:\n\t\tif target[1] < queen[1]:\n\t\t\tdone()\n\t\tcomplete()\n\telse:\n\t\tif target[1] > queen[1]:\n\t\t\tdone()\n\t\tcomplete()","output":"constant"},{"instruction":"N = int(input())\nL = [int(s) for s in input().split(\" \")]\nR = [int(s) for s in input().split(\" \")]\n\nC = [N - L[i] - R[i] for i in range(0, N)]\n\nfor i, x in enumerate(C):\n    if C[i] <= 0:\n        print(\"NO\")\n        exit()\n\n    l = 0\n    r = 0\n\n    j = i-1\n    while j >= 0:\n        if C[j] > C[i]:\n            l = l + 1\n\n        j = j - 1\n\n    j = i+1\n    while j < N:\n        if C[j] > C[i]:\n            r = r + 1\n\n        j = j + 1\n\n    if L[i] != l or R[i] != r:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in range(0, N-1):\n    print(C[i], end=\" \")\n\nprint(C[N-1])","output":"quadratic"},{"instruction":"def number(pos):\n    ans = 0\n    for i in range(pos + 1):\n        ans += 2**(i)\n    return ans\n\nl, r = input().split()\nl = int(l)\nr = int(r)\n\nif(l == r):\n    print(0)\nelse:\n    b_pos = 0\n    i = 0\n    while(l > 0 or r > 0):\n        if(l%2 != r%2):\n            b_pos = i\n        l >>= 1\n        r >>= 1\n        i += 1\n    print(number(b_pos))","output":"logn"},{"instruction":"import sys\nimport os\nfrom io import IOBase, BytesIO\n\ndef main():\n    n = int(input())\n    arr = get_array()\n    arr.sort()\n    tmp = [-1] * n\n    c = 1\n    for i in range(n):\n        if tmp[i] != -1:\n            continue\n        x = arr[i]\n        for j in range(i, n):\n            if arr[j] % x == 0:\n                tmp[j] = c\n        c += 1\n\n    print(c - 1)\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill():\n            pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill()\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        py2 = round(0.5)\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2 == 1:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef input():\n    return sys.stdin.readline().strip()\n\nif __name__ == \"__main__\":\n    main()","output":"quadratic"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n\nINF = float('inf')\nmod = int(1e9) + 7\n\ndef cal(l,r):\n    if l==r:\n        dp1[l][r]=1\n        dp2[l][r]=a[l]\n    if dp1[l][r]:\n        return dp1[l][r]\n    for i in range(l,r):\n        if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]:\n            dp1[l][r]=1\n            dp2[l][r]=dp2[l][i]+1\n    if not dp2[l][r]:\n        dp1[l][r]=2\n    return dp1[l][r]\n\ndef cal2(l,r):\n    if dp1[l][r]==1:\n        dp3[l][r]=1\n        return 1\n    elif dp3[l][r]:\n        return dp3[l][r]\n    ans=INF\n    for i in range(l,r):\n        ans=min(cal2(l,i)+cal2(i+1,r),ans)\n    dp3[l][r]=ans\n    return ans\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[0]*n for i in range(n)]\ndp2=[[0]*n for i in range(n)]\ndp3=[[0]*n for i in range(n)]\ncal(0,n-1)\ncal2(0,n-1)\nout(dp3[0][n-1])","output":"cubic"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef check(n,mid,path,cost,num):\n    ans,poi,visi = [],[0]*n,[0]*n\n    for i in range(n):\n        if visi[i]:\n            continue\n        visi[i],st,st1 = 2,[i],[]\n        while len(st):\n            x,y = st[-1],path[st[-1]]\n            if poi[x] == len(y):\n                visi[x] = 1\n                st1.append(st.pop())\n            else:\n                i,j = y[poi[x]],cost[st[-1]][poi[x]]\n                poi[x] += 1\n                if j <= mid:\n                    continue\n                if visi[i] == 2:\n                    return -1\n                if not visi[i]:\n                    st.append(i)\n                    visi[i] = 2\n        ans += st1\n    start = [0]*n\n    for ind,i in enumerate(reversed(ans)):\n        start[i] = ind\n    poi,visi,fin = [0]*n,[0]*n,[]\n    for i in range(n):\n        if visi[i]:\n            continue\n        visi[i],st = 1,[i]\n        while len(st):\n            x,y = st[-1],path[st[-1]]\n            if poi[x] == len(y):\n                st.pop()\n            else:\n                i,j,k = y[poi[x]],cost[st[-1]][poi[x]],num[st[-1]][poi[x]]\n                poi[x] += 1\n                visi[i] = 1\n                st.append(i)\n                if start[i] < start[x] and j <= mid:\n                    fin.append(k)\n    return fin\n\ndef main():\n    n,m = map(int,input().split())\n    path = [[] for _ in range(n)]\n    cost = [[] for _ in range(n)]\n    num = [[] for _ in range(n)]\n    for _ in range(m):\n        u1,v1,c1 = map(int,input().split())\n        path[u1-1].append(v1-1)\n        cost[u1-1].append(c1)\n        num[u1-1].append(_+1)\n    hi,lo = 10**9,0\n    while hi >= lo:\n        mid = (hi+lo)\/\/2\n        z = check(n,mid,path,cost,num)\n        if z == -1:\n            lo = mid+1\n        else:\n            hi = mid-1\n            ans = mid\n            an = z\n    print(ans,len(an))\n    print(*an)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"class Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        intervals.sort(key=lambda i: i.start)\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1.end > i2.start:\n                return False\n        return True","output":"nlogn"},{"instruction":"import math\n\nt = int(input())\n\ndef eval_(n, k):\n    level = 0.5*math.log2(3*k+1)\n    if n > 30:\n        cond = (level - n) > 0\n    else:\n        cond = (3*k+1) > 4**n\n    if cond:\n        return \"NO\"\n    elif n == 2 and k == 3:\n        return \"NO\"\n    else:\n        level = math.floor(level)\n\n        if n > 5:\n\n            temp = 1 + 0.5*math.log2(3*(k-1) + 1)\n            if n > temp:\n                return \"YES \" + str(n - 1)\n            else:\n                return \"YES  0\"\n        else:\n            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)\/\/3\n            start = (4**(level)-1)\/\/3\n            if k <=(start+delta):\n                return \"YES \" + str(n - level)\n            else:\n                return \"YES \" + str(n - level-1)\n\nfor i in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    print(eval_(n, k))","output":"logn"},{"instruction":"a,b=map(int,input().split())\nx,y,z=map(int,input().split())\nif a < x*2+y:\n    ry=x*2+y-a\nelse:\n    ry=0\nif b < y+z*3:\n    rb=y+z*3-b\nelse:\n    rb=0\nprint(ry+rb)","output":"constant"},{"instruction":"from sys import stdin,stdout,setrecursionlimit\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\nfrom collections import defaultdict as dd,Counter as C,deque\nfrom math import ceil,gcd,sqrt,factorial,log2,floor\nfrom bisect import bisect_right as br,bisect_left as bl\nfrom heapq import *\nmod = 10**9+7\n\ndef solve():\n\tn = it()\n\tv=[0]*(n+1)\n\tfor i in range(1,n+1):\n\t\tv[i] = input()\n\n\tdp=[[0]*(n+2) for _ in range(n+1)]\n\n\tfor l in range(n+2):\n\t\tdp[n][l] = 1\n\n\tfor i in range(n-1,0,-1):\n\t\tcurr_sum = 0\n\t\tfor l in range(n):\n\t\t\tcurr_sum += dp[i+1][l]\n\t\t\tcurr_sum%=mod\n\t\t\tif v[i] == 'f':\n\t\t\t\tdp[i][l] = dp[i+1][l+1]\n\t\t\telse:\n\t\t\t\tdp[i][l]= curr_sum\n\n\tprint(dp[1][0])\n\nsolve()","output":"quadratic"},{"instruction":"import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(round(_y, 6))\n\nprint(' '.join(map(str, y)))","output":"quadratic"},{"instruction":"def main():\n    def calc(x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:\n            return (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n        if (x1 + y1) % 2 == 1:\n            return (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2 + 1\n        return (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n    T = int(input())\n    for t in range(T):\n        n, m = map(int, input().split())\n        a, b, c, d = map(int, input().split())\n        e, f, g, h = map(int, input().split())\n        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)\n        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)\n        print(n * m - black, black)\n\nmain()","output":"constant"},{"instruction":"n, m = map(int, input().split())\na = []\nb = []\nwhile n >= 0:\n    a.append(4)\n    n -= 4\n    b.append(5)\n\na.append(5)\nb.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")","output":"constant"},{"instruction":"n,k = map(int,input().split())\nl = [int(x) for x in input().split()]\nmaps = []\nfor _ in range(256):\n\tmaps.append(['empty',0])\noutput = []\nfor innum in l:\n\tif maps[innum][0] == 'chosen':\n\t\toutnum = maps[innum][1]\n\telif maps[innum][0] == 'potential':\n\t\toutnum = maps[innum][1]\n\t\ti = innum\n\t\twhile i >= 0 and maps[i][0] == 'potential':\n\t\t\tmaps[i] = ['chosen',outnum]\n\t\t\ti -= 1\n\telse:\n\t\ti = innum\n\t\twhile i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':\n\t\t\ti -= 1\n\t\ti += 1\n\t\toutnum = i\n\t\tfor j in range(outnum,innum+1):\n\t\t\tmaps[j] = ['chosen',outnum]\n\t\tif innum < 255:\n\t\t\tfor j in range(innum+1,min(256,outnum+k)):\n\t\t\t\tif maps[j][0] != 'chosen':\n\t\t\t\t\tmaps[j] = ['potential',outnum]\n\toutput.append(str(outnum))\nprint(' '.join(output))","output":"quadratic"},{"instruction":"string=input()\nn=len(string)\ncount1=[]\nlong=0\nfor s_i in range(n):\n    for end_i in range(s_i+1,n+1):\n        sub=string[s_i:end_i]\n        if sub not in count1:\n            count1.append(sub)\n        else:\n            if len(sub)>long:\n                long=len(sub)\n\nprint(long)","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = input()\nb = input()\nflag = 0\nfor c in a:\n    if(c == '*'):\n        flag = 1\nif(flag == 1):\n    a1, a2 = a.split('*')\n    Len1 = len(a1)\n    Len2 = len(a2)\n    b1 = b[:Len1]\n    b2 = ''\n    if(Len2):\n        b2 = b[-Len2:]\n\n    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):\n        print('YES')\n    else:\n        print('NO')\nelse:\n    if(a == b):\n        print('YES')\n    else:\n        print('NO')","output":"linear"},{"instruction":"def f(l,r,g,b,op):\n    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):\n        return 0\n    else:\n        if op[r][g][b]!=-1:\n            return op[r][g][b]\n        if r==0:\n           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)\n           return op[r][g][b]\n        if g==0:\n           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)\n           return op[r][g][b]\n        if b==0:\n         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)\n         return op[r][g][b]\n        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))\n        return op[r][g][b]\n\nr,g,b=list(map(int,input().split()))\nl=[]\nl.append(sorted(list(map(int,input().split()))))\nl.append(sorted(list(map(int,input().split()))))\nl.append(sorted(list(map(int,input().split()))))\nop=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]\n\nprint(f(l,r,g,b,op))","output":"cubic"},{"instruction":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT = {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        res, resLen = [-1, -1], float(\"infinity\")\n        for i in range(len(s)):\n            countS = {}\n            for j in range(i, len(s)):\n                countS[s[j]] = 1 + countS.get(s[j], 0)\n\n                flag = True\n                for c in countT:\n                    if countT[c] > countS.get(c, 0):\n                        flag = False\n                        break\n\n                if flag and (j - i + 1) < resLen:\n                    resLen = j - i + 1\n                    res = [i, j]\n\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"","output":"quadratic"},{"instruction":"from sys import stdin\nn,m=map(int,stdin.readline().strip().split())\ns=list(map(int,stdin.readline().strip().split()))\ns1=list(map(int,stdin.readline().strip().split()))\nif min(s1)<max(s):\n    print(-1)\n    exit(0)\ns.sort()\ns1.sort()\n\nans=0\nif s1[0]!=s[-1]:\n    ans+=s1[0]\n    ans+=s[-2]*(m-1)\n    ans+=sum(s1[1::])\n    ans+=s[-1]\n    for i in range(n-2):\n        ans+=s[i]*m\nelse:\n    ans+=sum(s1)\n    for i in range(n-1):\n        ans+=s[i]*m\nprint(ans)","output":"nlogn"},{"instruction":"n, v = list(map(int, input().split()))\nf = lambda x: x*(x+1)\/\/2\nprint(min(n-1, v)+f(n-min(n-1, v))-1)","output":"constant"},{"instruction":"def solve():\n    n = int(input())\n    max_degs = [int(x) for x in input().split()]\n\n    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]\n    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]\n\n    if 2 + sum(b - 2 for _, b in B) < len(S):\n        print('NO')\n        return\n\n    print('YES', len(B) + min(len(S), 2) - 1)\n    print(n-1)\n\n    for k in range(len(B) - 1):\n        i, x = B[k]\n        i_n, _ = B[k+1]\n        print(i, i_n)\n        B[k][1] -= 1\n        B[k+1][1] -= 1\n\n    k = 0\n    for i, (s_idx, _) in enumerate(S):\n        if i == 0:\n            print(B[0][0], s_idx)\n            B[0][1] -= 1\n        elif i == 1:\n            print(B[-1][0], s_idx)\n            B[-1][1] -= 1\n        else:\n            while B[k][1] == 0:\n                k += 1\n            print(B[k][0], s_idx)\n            B[k][1] -= 1\n\nsolve()","output":"linear"},{"instruction":"n,m,k = map(int,input().split())\nright = [[9999999 for i in range(m-1)] for j in range(n)]\ndown =  [[9999999 for i in range(m)] for j in range(n-1)]\nfor i in range(n):\n    right[i] = list(map(int,input().split()))\nfor i in range(n-1):\n    down[i] = list(map(int,input().split()))\n\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(\"-1\",end=\" \")\n        print()\nelse:\n    k = k\/\/2\n    row = n\n    col = m\n    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]\n    for steps in range(k+1):\n        for i in range(row):\n            for j in range(col):\n                if(steps==0):\n                    dp[steps][i][j] = 0\n                    continue\n                ans = 99999999999\n                if(i>0):\n                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])\n                if(i<n-1):\n                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])\n                if(j<m-1):\n                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])\n                if(j>0):\n                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])\n                dp[steps][i][j] = ans\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[k][i][j],end=\" \")\n        print()","output":"cubic"},{"instruction":"MOD = 1000000007\n\ndef main():\n    buf = input()\n    buflist = buf.split()\n    n = int(buflist[0])\n    q = int(buflist[1])\n    buf = input()\n    x = buf\n    sum_list = [0]\n    for i, deliciousness in enumerate(x):\n        sum_list.append(int(deliciousness) + sum_list[i])\n    enjoyment_list = [0]\n    for i in range(n):\n        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)\n    query_list = []\n    for i in range(q):\n        buf = input()\n        buflist = buf.split()\n        l = int(buflist[0])\n        r = int(buflist[1])\n        query_list.append((l, r))\n    for i, query in enumerate(query_list):\n        l = query[0]\n        r = query[1]\n        banhmi_count = r - l + 1\n        delicious_count = sum_list[r] - sum_list[l - 1]\n        non_delicious_count = banhmi_count - delicious_count\n        enjoyment = 0\n\n        if delicious_count == 0:\n            enjoyment = 0\n        else:\n            enjoyment += enjoyment_list[delicious_count]\n            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])\n            enjoyment = enjoyment % MOD\n        print(enjoyment)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"from math import ceil\n\nk, n, s, p = map(int, input().split())\nn_sheets = ceil(n \/ s)* k\nn_p = ceil(n_sheets \/ p)\nprint(n_p)","output":"constant"},{"instruction":"n=int(input())\nx,y=map(int,input().split())\nval1=max(x,y)-1\nval2=n-min(x,y)\nif(val1<=val2):\n    print('White')\nelse:\n    print('Black')","output":"constant"},{"instruction":"from collections import deque\ndef bfs(n):\n    global c,nd,ans,s\n    while len(b)>0 and len(s)>0:\n        aux=0\n        for i in l[s[0]]:\n            if not visited[i]:\n                visited[i]=True\n                dp[i]=1\n                aux+=1\n        for i in range(aux):\n            x=b.popleft()\n            if dp[x]==1:\n                s.append(x)\n                dp[x]=-1\n            else:\n                ans=\"No\"\n                return\n        s.popleft()\n\nn=int(input())\nvisited=[False for i in range(n+2)]\ndp=[-1 for i in range(n+2)]\nl=[[] for i in range(n+2)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=deque(map(int,input().split()))\nb.popleft()\ns=deque([1])\nans=\"Yes\"\nvisited[1]=True\nbfs(1)\nprint(ans)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = []\nb = []\ncheck = True\nwhile n >= 0:\n    if check == True:\n        a.append(5)\n        n -= 5\n        b.append(4)\n        check = False\n    else:\n         check = True\n         a.append(4)\n         n -= 4\n         b.append(5)\n\nif m != 1:\n    a.append(5)\n    b.append(6)\nelse:\n    a.append(5)\n    b.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")","output":"constant"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    if n==1:\n        return 0\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matridigit[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matridigit[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matridigit[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matridigit[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matridigit[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,mod = mi()\n\nN = 1000\ng1 = [1]*(N+1)\ng2 = [1]*(N+1)\ninverse = [1]*(N+1)\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\npow_2 = [1 for i in range(1001)]\nfor i in range(1,1001):\n    pow_2[i] = (pow_2[i-1] * 2) % mod\n\ndp = [[1]]\n\nfor i in range(n):\n    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]\n    for s in range(i+1):\n        for k in range(i+1):\n            if not dp[s][k]:\n                continue\n\n            if k!=0:\n                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod\n                ndp[s+k][0] %= mod\n\n    dp = ndp\n\nres = 0\nfor s in range(n+1):\n    for k in range(1,n+1):\n        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod\n        res %= mod\n\nprint(res)","output":"cubic"},{"instruction":"if __name__ == '__main__':\n    nums = input().split()\n    n = int(nums[0])\n    v = int(nums[1])\n\n    if n < v+2:\n        print(n - 1)\n    else:\n        print(int(v-1 + (n-v)*(n-v+1)\/2))","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\nN, Q = map(int, input().split())\nque = deque([int(a) for a in input().split()])\nma = max(que)\n\nX = []\nk = -1\nc = 0\nwhile c <= k+N+5:\n    a = deque.popleft(que)\n    b = deque.popleft(que)\n\n    X.append((a, b))\n    c += 1\n    if a > b:\n        a, b = b, a\n    if k < 0 and b == ma:\n        k = c\n    deque.appendleft(que, b)\n    deque.append(que, a)\n\nfor _ in range(Q):\n    i = int(input()) - 1\n    if i <= k:\n        print(*X[i])\n    else:\n        i = (i-k)%(N-1)+k\n        print(*X[i])","output":"linear"},{"instruction":"if __name__ == \"__main__\":\n    n = int(input())\n    nums = [int(a) for a in input().strip().split()]\n    counts = 0\n\n    for i in range(n-1):\n        for j in range(i + 1, n):\n            if nums[i] > nums[j]:\n                counts += 1\n\n    ans = counts % 2\n    ans_tmp = []\n    m = int(input())\n    for i in range(m):\n        l, r = [int(a) for a in input().strip().split()]\n\n        tmp = r - l + 1\n        tmp_count = (tmp * (tmp - 1) \/\/ 2)\n        if tmp_count % 2 == 1:\n            ans = (ans + 1) % 2\n        ans_tmp.append(ans)\n\n    for i in range(m):\n        ans = ans_tmp[i]\n        if ans % 2 == 1:\n            print(\"odd\")\n        else:\n            print(\"even\")","output":"quadratic"},{"instruction":"import os, sys, atexit\nfrom cStringIO import StringIO as BytesIO\n\nsys.stdout = BytesIO()\natexit.register(lambda: os.write(1, sys.stdout.getvalue()))\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nrints = lambda: [int(x) for x in input().split()]\nrstr = lambda: input().strip()\nrstr_2d = lambda n: [rstr() for _ in range(n)]\n\nn, m = rints()\ngrid = rstr_2d(n)\nrow = [[[] for _ in range(m)] for _ in range(n)]\ncol = [[[] for _ in range(m)] for _ in range(n)]\nvisr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0\nvisc = [[-1 for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    be, en = -1, -1\n    for j in range(m):\n        if grid[i][j] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    row[i][k] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            row[i][k] = [be, en]\n\nfor i in range(m):\n    be, en = -1, -1\n    for j in range(n):\n        if grid[j][i] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    col[k][i] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            col[k][i] = [be, en]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '*':\n            all += 1\n            hor = min(row[i][j][1] - j, j - row[i][j][0])\n            ver = min(col[i][j][1] - i, i - col[i][j][0])\n            if hor <= ver:\n                ver = hor\n            else:\n                hor = ver\n\n            if hor > 0 and ver > 0:\n                out.append('%d %d %d' % (i + 1, j + 1, hor))\n                visr[i][j - ver] = j + ver\n                visc[i - hor][j] = i + hor\n\ndis = set()\nfor i in range(n):\n    j, ma = 0, -1\n    while j < m:\n        ma = max(ma, visr[i][j])\n        if ma >= j:\n            dis.add((i, j))\n\n        j += 1\n\nfor i in range(m):\n    j, ma = 0, -1\n    while j < n:\n        ma = max(ma, visc[j][i])\n        if ma >= j:\n            dis.add((j, i))\n\n        j += 1\n\nif len(dis) != all:\n    print(-1)\nelse:\n    sys.stdout.write('%d\\n%s' % (len(out), '\\n'.join(out)))","output":"quadratic"},{"instruction":"def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2,n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\nprime = get_prime(3162)\n\ndef get_mask (num):\n\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num \/\/ p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\treturn num\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = nrs()\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\ta = get_mask(a)\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))","output":"cubic"},{"instruction":"n = int(input())\nar = []\nfor i in range(n):\n    ar.append(input())\nsortedAr = sorted(ar,key=len)\nflag = False\nfor i in range(n-1):\n    if sortedAr[i+1].find(sortedAr[i]) == -1:\n        print('NO')\n        flag = True\n        break\nif not flag:\n    print('YES')\n    for i in sortedAr:\n        print(i)","output":"nlogn"},{"instruction":"a = input()\nb = input()\n\nif len(a) < len(b):\n    a = sorted(a)[::-1]\n    print(''.join(a))\n    exit(0)\n\ndef check(res, j, a):\n    added = False\n    tmp = \"\"\n    for i in a:\n        if i == j and not added:\n            added = True\n        else:\n            tmp += i\n    tmp = res + j + tmp[::-1]\n    return tmp <= b\n\nres = \"\"\nn = len(a)\na = sorted(list(a))[::-1]\nfor i in range(n):\n    for j in a:\n        if check(res, j, a):\n            res += j\n            a.remove(j)\n            break\nprint(res)","output":"cubic"},{"instruction":"def gns():\n    return  list(map(int,input().split()))\nn=int(input())\nns=gns()\na='cslnb'\nb='sjfnb'\nns.sort()\nans=[]\nfor i in range(1,n):\n    if ns[i]==ns[i-1]:\n        ans.append(i)\nif len(ans)>=2 or sum(ns)==0:\n    print(a)\n    quit()\nif len(ans)==1:\n    i=ans[0]\n    if ns[i]==0 or ns[i]-1 in ns:\n        print(a)\n        quit()\n    r=sum(ns)-n*(n-1)\/\/2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)\n        quit()\nelse:\n    r=sum(ns)-n*(n-1)\/\/2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)","output":"nlogn"},{"instruction":"from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = defaultdict(int)\nfor x in a:\n    d[x] += 1\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)","output":"cubic"},{"instruction":"def main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*(nSquares\/\/2) + '0'\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]\n    possible_nSquares.sort()\n\n    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]\n\nif __name__ == '__main__':\n    print(main())","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nprint((k + n - 1) \/\/ n)","output":"constant"},{"instruction":"from sys import stdin, stdout, maxsize\nfrom math import inf\n\nR = lambda : stdin.readline().strip()\nRL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))\n\noutput = lambda x: stdout.write(str(x) + '\\n')\noutput_list = lambda x: output(' '.join(map(str, x)))\n\nn, m, K = RL(int)\n\nif K%2:\n    for i in range(n):\n        print( *(m*[-1]) )\n    exit()\n\nhor = [ RL(int) +[inf] for i in range(n) ]\nvert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]\n\nK = K\/\/2\ndp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]\n\ndp[0] = [m*[0] for i in range(n)]\n\ndef valid(i, j):\n    if -1 < i < n and  -1 < j < m:\n        return True\n    return False\n\nfor k in range(1, K+1):\n    for i in range(n):\n        for j in range(m):\n            if valid(i, j+1):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])\n            if valid(i+1, j):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])\n            if valid(i-1, j):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])\n            if valid(i, j-1):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])\n\nfor i in dp[-1]:\n    print(*i)","output":"cubic"},{"instruction":"from sys import stdin\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    a = round((n \/ 2) ** 0.5)\n    b = round((n \/ 4) ** 0.5)\n    if 2*a**2 == n or 4*b**2 == n:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"i = int(input())\ns = input().split()\n\nl = []\nfor j in s:\n    if not l or  int(j)%2 != l[-1]:\n        l.append(int(j)%2)\n    else:\n        l.pop()\n\nif len(l) < 2:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"n, m, k = map(int, input().strip().split())\n\na = list(map(int, input().strip().split()))\na = [0] + a\ndp = [0] * 300005\nans = 0\nfor i in range(1, n + 1):\n    a[i] += a[i - 1]\n    for j in range(1, m + 1):\n        if i - j >= 0:\n            dp[i] = max(dp[i], a[i] - a[i - j] - k)\n    if i - m >= 0:\n        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)\n    ans = max(ans, dp[i])\n\nprint(ans)","output":"quadratic"},{"instruction":"from sys import stdin\ninput = stdin.readline\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])\n    if i < 3: input()\nb = []\nfor i in range(4):\n    b.append([])\n    for j in range(2):\n        c = 0\n        for y in range(n):\n            for x in range(n):\n                if j == 1:\n                    z = (x + y) % 2\n                else:\n                    z = 1 - (x + y) % 2\n                c += a[i][y][x] != z\n        b[-1].append(c)\nans = float(\"inf\")\nfor i in (3, 5, 6, 9, 10, 12):\n    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])\nprint(ans)","output":"quadratic"},{"instruction":"import sys, math\ndebug = 0\nif debug:\n    f = open(\"input.txt\", \"r\")\n    input = f.readline\ndef mp():\n    return list(map(int,input().split()))\n\nm = 1000000007\n\ndef pow(k):\n    if k == 0:\n        return 1;\n    z = pow(k \/\/ 2)\n    if k % 2 == 1:\n        return (2 * z * z) % m\n    else:\n        return (z * z) % m\n\ndef _main():\n    x, k = mp()\n    if(x == 0):\n        print(0)\n        return\n    t = pow(k)\n    a = x * t\n    b = a - t + 1;\n    print((a + b) % m)\n\n_main()","output":"logn"},{"instruction":"n, capacity = map(int,input().split())\na = [(0, 0)]*n\n\nfor i in range(n):\n    x, y = map(int,input().split())\n    a[i] = (x, y)\n\na.sort(key=lambda x: max(0, x[0] - x[1]))\n\ncurrent_sum = 0; i = n - 1; ans = 0\nfor x in a:\n    current_sum += x[0]\n\nwhile i >= 0 and current_sum > capacity:\n    ans += 1\n    current_sum -= max(0, a[i][0] - a[i][1])\n    i -= 1\n\nif current_sum <= capacity:\n    print(ans)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"n = int(input())\nimport math\nprint(math.ceil(n\/2) * (math.floor(n\/2)+1))","output":"linear"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\ns=input()\nwater=0\ngrass=0\ncgrass=0\ntime=0\nseen=False\nfor i in range(n):\n    if s[i]==\"G\":\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n            cgrass+=dist\n        else:\n            dist-=water\n            time+=2*water\n            cgrass+=water\n            water=0\n            time+=3*dist\n            grass+=dist\n    elif s[i]==\"W\":\n        water+=l[i]\n        time+=2*l[i]\n        seen=True\n    else:\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n        else:\n            dist-=water\n            time+=2*water\n            water=0\n            if cgrass>=dist:\n                cgrass-=dist\n                grass+=dist\n                time+=3*dist\n            else:\n                dist-=cgrass\n                grass+=cgrass\n                time+=3*cgrass\n                cgrass=0\n                if grass>=dist:\n                    grass-=dist\n                    time+=3*dist\n                else:\n                    dist-=grass\n                    time+=3*grass\n                    grass=0\n                    if seen:\n                        time+=4*dist\n                    else:\n                        time+=6*dist\nprint(time)","output":"linear"},{"instruction":"def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nre = int(input())\na = [list(input()) for i in range(re)]\nb = [list(input()) for i in range(re)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(re)] for u in range(re)]\n    for t in range(re):\n        for u in range(re):\n            c[t][u] = b[u][re - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')","output":"quadratic"},{"instruction":"from sys import stdin, stdout\n\nn = int(stdin.readline())\nvalues = list(map(int, stdin.readline().split()))\n\ncnt = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if values[i] > values[j]:\n            cnt += 1\n\nm = int(stdin.readline())\nfor i in range(m):\n    l, r = map(int, stdin.readline().split())\n    n = r - l + 1\n\n    cnt += n * (n - 1) \/\/ 2\n    cnt &= 1\n\n    if cnt == 1:\n        stdout.write('odd\\n')\n    else:\n        stdout.write('even\\n')","output":"quadratic"},{"instruction":"def check(j):\n    if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x:\n        return 1\n    return 0\n\nfrom itertools import combinations\nn,l,r,x=list(map(int,input().split()))\nc=list(map(int,input().rstrip().split()))\ncount=0\nfor i in range(2,n+1):\n    a=list(combinations(c,i))\n    for j in a:\n\n        if check(j):\n            count+=1\nprint(count)","output":"np"},{"instruction":"from collections import deque\nn = int(input())\ngraph = [set() for i in range(n + 1)]\ngraph[0].add(1)\ngraph[1].add(0)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    graph[x].add(y)\n    graph[y].add(x)\na = list(map(int, input().split()))\nq = deque()\nq.append(0)\ni = 0\npar = [0] * (n + 1)\nwhile len(q):\n    v = q.popleft()\n    graph[v].discard(par[v])\n    l = len(graph[v])\n    if graph[v] != set(a[i:i + l]):\n        print(\"No\")\n        break\n    for j in range(i, i + l):\n        q.append(a[j])\n        par[a[j]] = v\n    i += l\nelse:\n    print(\"Yes\")","output":"linear"},{"instruction":"import sys, string\n\nn, m = map(int, sys.stdin.readline().split())\ns = list(sys.stdin.readline().rstrip())\nt = list(sys.stdin.readline().rstrip())\nidx = -1\nfor i in range(n):\n    if s[i] == '*':\n        idx = i\nif idx == -1:\n    if s == t:\n        print('YES')\n    else:\n        print('NO')\nelse:\n    if m < n - 1:\n        print('NO')\n    else:\n        s_left = s[0 : idx]\n        s_right = s[idx + 1 : n]\n        a = len(s_left)\n        b = len(s_right)\n        t_left = []\n        t_right = []\n        for i in range(a):\n            t_left.append(t[i])\n            t[i] = ''\n        for i in range(b):\n            t_right.append(t[m - i - 1])\n        if s_left == t_left and s_right == t_right[::-1]:\n            print('YES')\n        else:\n            print('NO')","output":"linear"},{"instruction":"n,m,k,l=map(int,input().split())\nc=(k+l)\/\/m\nif (k+l)%m!=0:\n    c+=1\nif n>=m*c:\n    print(c)\nelse :\n    print(-1)","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,m=map(int,input().split())\na=[]\ndef bs(a,mid,ans):\n    global n,m\n    can=[0 for i in range(1<<m)]\n    for i in range(n):\n        t=0\n        for j in range(m):\n            t=(t<<1)|(a[i][j]>=mid)\n\n        can[t]=i+1\n\n    for i in range(1<<m):\n        if(not can[i]):\n            continue\n        for j in range(1<<m):\n            if not can[j]:\n                continue\n            if i|j==(1<<m)-1:\n\n                ans[0]=can[i]\n                ans[1]=can[j]\n                return 1\n    return 0\n\nfor i in range(n):\n    p=[int(x) for x in input().split()]\n    a.append(p)\nl=0\nr=100000000000\nans=[1,1]\nwhile l<=r:\n    mid=(l+r)\/\/2\n    if bs(a,mid,ans):\n        l=mid+1\n    else:\n        r=mid-1\n\nprint(*ans)","output":"np"},{"instruction":"def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []):\n    if picked == size:\n        if max(combination) - min(combination) >= x and l <= sum(combination) <= r:\n            total += 1\n    else:\n        for i in range(start,n-(size-picked-1)):\n            combination.append(diff[i])\n            picked += 1\n            total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination)\n            picked -= 1\n            combination.pop()\n    return total\n\ndef prog():\n    n,l,r,x = map(int,input().split())\n    diff = list(map(int,input().split()))\n    suitable_problemsets = 0\n    for size in range(1,n+1):\n        suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x)\n    print(suitable_problemsets)\nprog()","output":"np"},{"instruction":"n,m = input().split()\nn=int(n)\nm=int(m)\n\nsongs=list()\n\nfor i in range(n):\n    songs.append([int(c) for c in input().split()])\n\ndef sumList(lista,inx):\n    sum=0\n    for i in range(len(lista)):\n        sum+=lista[i][inx]\n    return sum\n\nsongs=sorted(songs,key=lambda x: x[1]-x[0])\n\nsuma = sumList(songs,0)\n\nfor i in range(n):\n    if(suma<=m):\n        print(i)\n        exit()\n    suma-= songs[i][0]-songs[i][1]\n\nif(suma<=m):\n    print(n)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"T = int(input())\nfor ti in range(T):\n    s, t = input().strip(), input().strip()\n    N = len(t)\n    for i in range(1, N+1):\n        dp = [0]+[-1]*i\n        for l, c in enumerate(s):\n            for j in range(i, -1, -1):\n                tmp = dp[j]\n                if dp[j] != -1 and i + dp[j] < N and \\\n                   t[i + dp[j]] == c:\n                    tmp = dp[j] + 1\n                if j != 0 and t[j-1] == c:\n                    tmp = max(tmp, dp[j-1])\n                dp[j] = tmp\n        if dp[i] == N-i:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"def sum(num):\n\n    return (num * (num + 1)) \/\/ 2\n\ndef sum_from_to(fromm, to):\n    if fromm <= 1:\n        return sum(to)\n    return sum(to) - sum(fromm)\n\ndef min_splitters():\n    start = 1\n    end = k\n    while start < end:\n        mid = (start + end) \/\/ 2\n        mid_val = sum_from_to(mid, k)\n        if mid_val == n:\n            return k - mid + 1\n        elif mid_val > n:\n            start = mid + 1\n        else:\n            end = mid\n    return k - start + 1\n\nn, k = (int(i) for i in input().split())\n\nif n == 1:\n    print(0)\n\nelif n <= k:\n    print(1)\nelse:\n    k -= 1\n    n -= 1\n\n    if sum(k) < n:\n        print(-1)\n    else:\n        print(min_splitters())","output":"logn"},{"instruction":"Q = int(input())\nfor _ in range(Q):\n    N, K = map(int, input().split())\n    S = input()\n    X = [{\"R\":0, \"G\":1, \"B\":2}[s] for s in S]\n    mi = K\n    for i in range(3):\n        d = 0\n        for j in range(N):\n            if X[j] != (i+j) % 3:\n                d += 1\n            if j >= K and X[j-K] != (i+j-K) % 3:\n                d -= 1\n            if j >= K-1:\n                mi = min(mi, d)\n    print(mi)","output":"linear"},{"instruction":"if __name__ == \"__main__\":\n    x,k = map(int, input().split())\n\n    if x==0:\n    else:\n        y=pow(2,k,1000000007)*(2*x-1)+1\n        result=int(y%(1000000007))","output":"logn"},{"instruction":"N, K = map(int, input().split())\n\nprint((K+N-1)\/\/N)","output":"constant"},{"instruction":"def fastio():\n\timport sys\n\tfrom io import StringIO\n\tfrom atexit import register\n\tglobal input\n\tsys.stdin = StringIO(sys.stdin.read())\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\tsys.stdout = StringIO()\n\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\n\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\n\nt, = I()\nwhile t:\n\tt -= 1\n\tn, = I()\n\ta = I()\n\ta.sort()\n\tif n == 2:\n\t\tprint(0)\n\telse:\n\t\tprint(min(n-2, a[-2]-1))","output":"nlogn"},{"instruction":"import sys, os\nfrom io import BytesIO, IOBase\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef ceil(a, b): return (a+b-1)\/\/b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nn, k = mp()\nif n==0:\n    print(0)\n    exit()\nx = (n*pow(2, k+1, mod))%mod\nprint((x-pow(2, k, mod)+1)%mod)","output":"logn"},{"instruction":"from collections import namedtuple\n\nPoint = namedtuple(\"Point\", \"x y\")\nSquare = namedtuple(\"Square\", \"left right top bottom\")\nTriangle = namedtuple(\"Triangle\", \"left top\")\n\na = [int(v) for v in input().split()]\nb = [int(v) for v in input().split()]\n\na = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)]\nb = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)]\n\nbc = Point(sum(p.x for p in b) \/\/ 4, sum(p.y for p in b) \/\/ 4)\nbb = [None] * 4\nfor p in b:\n    if p.x < bc.x:\n        bb[0] = p\n    elif p.y > bc.y:\n        bb[1] = p\n    elif p.x > bc.x:\n        bb[2] = p\n    elif p.y < bc.y:\n        bb[3] = p\n    else:\n        assert False\n\ndef in_sqr(sqr, pt):\n    return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top\n\ndef in_tri(tri, pt):\n    return (\n        tri.left.x <= pt.x <= tri.top.x and\n        tri.left.y <= pt.y <= tri.top.y and\n        pt.y - tri.left.y <= pt.x - tri.left.x\n    )\n\ndef solve_sqr_tri(sqr, tri):\n    return (\n        in_sqr(sqr, tri.left) or\n        in_sqr(sqr, tri.top) or\n        in_sqr(sqr, Point(tri.top.x, tri.left.y)) or\n        in_tri(tri, Point(sqr.left, sqr.top)) or\n        in_tri(tri, Point(sqr.right, sqr.top)) or\n        in_tri(tri, Point(sqr.right, sqr.bottom)) or\n        in_tri(tri, Point(sqr.left, sqr.bottom))\n    )\n\ndef rotate90(pt):\n    return Point(-pt.y, pt.x)\n\ndef iterate_rot(pt, times):\n    for _ in range(times):\n        pt = rotate90(pt)\n    return pt\n\ndef solve_sqr_sqr45(sqr_pts, sqr45):\n    for i in range(4):\n        tri_pts = sqr45[i], sqr45[(i + 1) % 4]\n        left, top = [iterate_rot(pt, i) for pt in tri_pts]\n\n        assert left.x < top.x\n        assert left.y < top.y\n\n        tri = Triangle(left=left, top=top)\n\n        sqr = Square(\n            left=min(p.x for p in sqr_pts),\n            right=max(p.x for p in sqr_pts),\n            top=max(p.y for p in sqr_pts),\n            bottom=min(p.y for p in sqr_pts),\n        )\n\n        if solve_sqr_tri(sqr, tri):\n            return True\n\n        sqr_pts = [rotate90(pt) for pt in sqr_pts]\n\n    return False\n\nprint([\"NO\", \"YES\"][solve_sqr_sqr45(a, bb)])","output":"constant"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\nmex = -1\nfor i in range(n):\n    if a[i] <= mex:\n        continue\n    elif a[i] == mex + 1:\n        mex += 1\n    else:\n        print(i+1)\n        exit()\nprint(-1)","output":"linear"},{"instruction":"import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\n\nn,k = map(int,input().split())\nt = []\nfor _ in [0]*n:\n    t.append(list(map(int,input().split())))\nt.sort(key=lambda x:(-x[0],x[1]))\n\npt = t[k-1]\n\nprint(t.count(pt))","output":"nlogn"},{"instruction":"from queue import Queue\nimport datetime\n\nwith open(\"input.txt\", 'r') as in_file:\n    n, m = (int(i) for i in in_file.readline().split(\" \"))\n    k = int(in_file.readline())\n    ints = [int(i) for i in in_file.readline().split(\" \")]\n\npairs = []\nfor i in range(0, len(ints), 2):\n    x = ints[i]\n    y = ints[i+1]\n    pairs.append((x, y))\n\nlast_tree = (1, 1)\nmaxd = 0\nmult = m * n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        md = mult\n\n        for pair in pairs:\n            x, y = pair\n            d = abs(i-x)+abs(j-y)\n\n            md = min(md, d)\n\n        if md > maxd:\n\n            last_tree = (i, j)\n            maxd = md\n\nwith open(\"output.txt\", 'w') as out_file:\n    out_file.write(f\"{last_tree[0]} {last_tree[1]}\")","output":"cubic"},{"instruction":"import math\na,b=map(int,input().split())\nc=[]\ne=[]\nf=0\nfor i in range(a):\n    d=str(input())\n    for j in range(b):\n        if d[j]==\"B\":\n            c=c+[i]\n            e=e+[j]\np=min(c)\np1=min(e)\np2=max(c)\nplus=(max(c)-min(c))\/\/2\np3=p+plus+1\np4=p1+plus+1\nprint(p3,p4)","output":"quadratic"},{"instruction":"n = int(input().strip())\na = list(map(int,input().strip().split()))\nb = list(map(int,input().strip().split()))\npos_of = [-1 for i in range(2*10**5+1)]\n\nfor i,ele in enumerate(a):\n    pos_of[ele]=i+1\n\ncurrent_pos = 0\nans=[]\nfor i in b:\n    if(pos_of[i]>current_pos):\n        ans.append(pos_of[i]-current_pos)\n        current_pos=pos_of[i]\n    else:\n        ans.append(0)\n\nprint(' '.join(list(map(str,ans))))","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import ceil\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfrom math import inf\n\nfor _ in range(int(input()) if not True else 1):\n\n    n, m = map(int, input().split())\n\n    a = []\n    for i in range(n):\n        a += [list(map(int, input().split()))]\n\n    alpha, omega = 0, 10**9\n    def solve(mid):\n        index = [-1] * (1 << m)\n        for i in range(n):\n            val = 0\n            for j in range(m):\n                if a[i][j] >= mid:\n                    val += (1 << j)\n            index[val] = i + 1\n        is_subset = list(index)\n        for i in range(m):\n            for mask in range(1 << m):\n                if mask & (1 << i):\n                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])\n        pos = False\n        for mask in range(1 << m):\n            if index[mask] == -1: continue\n            mask2 = ((1 << m) - 1) ^ mask\n            if is_subset[mask2] != -1:\n                pos = (index[mask], is_subset[mask2])\n                break\n        return pos\n    while alpha < omega:\n        mid = (alpha + omega + 1) \/\/ 2\n        if solve(mid):\n            alpha = mid\n        else:\n            omega = mid - 1\n    print(*solve(alpha))","output":"np"},{"instruction":"n = int(input())\nqueen_x, queen_y = list(map(int, input().strip().split()))\nking_x, king_y = list(map(int, input().strip().split()))\ntar_x, tar_y = list(map(int, input().strip().split()))\n\nmin_x, max_x = sorted([king_x, tar_x])\nmin_y, max_y = sorted([king_y, tar_y])\n\nif max_x > queen_x > min_x or max_y > queen_y > min_y:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n","output":"nlogn"},{"instruction":"n=int(input())\nf=[input().strip()==\"f\" for ii in range(n)]\nmod=10**9+7\ndef summ(a,b):\n return (a+b)%mod\ndp=[1]\nfor ii in range(1,n):\n pf=f[ii-1]\n if pf:\n  dp.insert(0,0)\n else:\n  for jj in reversed(range(1,len(dp))):\n   dp[jj-1]=summ(dp[jj-1],dp[jj])\nans=0\nfor vv in dp:\n ans=summ(ans,vv)\nprint(ans)","output":"quadratic"},{"instruction":"def valid(k, mid):\n    return (2*k - mid - 1) * mid \/\/ 2 + 1\n\ndef binary_search(n, k):\n    l, r = 0, k-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(k, mid) < n):\n            l = mid+1\n        else:\n            r = mid-1\n    return r+1\n\ndef main():\n    n, k = map(int, input().split())\n    res = binary_search(n, k)\n    print(-1 if res == k else res)\n\nmain()","output":"logn"},{"instruction":"a = list(input())\na = [int(x) for x in a]\n\nb = list(input())\nb = [int(x) for x in b]\n\nn = len(a)\nm = len(b)\n\nans = 0\nfor i in range(n):\n    ans+=a[i]^b[i]\nones = [0 for i in range(m)]\nzeros = [0 for i in range(m)]\n\nfor i in range(m):\n    if b[i]:\n        ones[i]=1\n    else:\n        zeros[i]=1\n\nfor i in range(1,m):\n    ones[i]+=ones[i-1]\n    zeros[i]+=zeros[i-1]\n\nfor i in range(n):\n    if a[i]==1:\n        ans+=zeros[m-n+i]-zeros[i]\n    else:\n        ans+=ones[m-n+i]-ones[i]\nprint(ans)","output":"linear"},{"instruction":"import itertools\n\nn , l , r , x = map(int,input().split())\n\nproblems = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(2 , n + 1 ):\n    for j in itertools.combinations(problems ,i):\n        if (l <= sum(j) <= r and max(j) - min(j) >= x):\n            ans +=1\n\nprint(ans)","output":"np"},{"instruction":"s=input()\n\nwhile(1):\n        if(len(s)==1):\n                print(0)\n                break\n\n        elif(s==s[::-1]):\n\n            s=s[1:]\n\n        else:\n            print(len(s))\n            break","output":"linear"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn,m=zzz()\narr = zzz()\ns = sum(arr)\nidx = [[] for i in range(m)]\nfor i in range(n):\n    idx[arr[i]%m].append(i)\nj=0\nfor i in range(m):\n    while len(idx[i])>n\/\/m:\n        while j<i or len(idx[j%m])>=n\/\/m:j+=1\n        last = idx[i].pop()\n        arr[last]+=(j-i)%m\n        idx[j%m].append(last)\nprint(sum(arr)-s)\nprint(*arr)","output":"linear"},{"instruction":"import sys\n\ndef set(mask, pos):\n    return mask | (1 << pos)\n\ndef isOn(mask, pos):\n    return mask & ( 1 << pos) > 0\n\nn, l, r, x = map(int, input().split(' '))\ndif = list(map(int, input().split(' ')))\n\ncount, mask = 0, 0\n\nwhile mask <= 2**n:\n    summ, bit = [], 0\n\n    while bit < n:\n\n        if isOn(mask, bit):\n            summ.append(dif[bit])\n\n        bit += 1\n\n    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:\n        count += 1\n\n    mask += 1\n\nprint(count)","output":"np"},{"instruction":"n,s=map(int,input().split())\nx=s\/\/n\nif x*n<s:\n    x+=1\nprint(x)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nPLACE=[None]*(n+1)\nfor i in range(n):\n    PLACE[A[i]]=i\n\nal=n\n\nWINLIST=[None]*(n+1)\n\ndef move(n,al):\n    place=PLACE[n]\n    for i in range(place,-1,-n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return\n\n    for i in range(place,al,n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return\n\n    else:\n        WINLIST[n]=\"B\"\n        return\n\nfor j in range(n,0,-1):\n    move(j,al)\n\nANS=\"\"\nfor i in A:\n    ANS+=WINLIST[i]\n\nprint(ANS)","output":"linear"},{"instruction":"from sys import *\nn = int(stdin.readline())\nans = 0\nfor i in range(2,n+1):\n    for j in range(i*2,n+1,i):\n        ans += 4 * (j \/\/ i)\nprint(ans)","output":"nlogn"},{"instruction":"i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s \/ g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))","output":"linear"},{"instruction":"n , m=map(int,input().split())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nl3=[]\nfor i in range(n):\n    for j in range(m):\n        if l1[i]==l2[j]:\n            if l1[i] is not l3:\n                l3.append(l1[i])\nprint(*l3)","output":"quadratic"},{"instruction":"class edge(object):\n\tdef __init__(self,ne,to,fl):\n\t\tself.ne=ne\n\t\tself.to=to\n\t\tself.fl=fl\n\ndef add(x,y,z):\n\tglobal tot\n\ttot+=1\n\te.append(edge(he[x],y,z))\n\the[x]=tot\n\ndef addedge(x,y,z):\n\tadd(x,y,z)\n\tadd(y,x,0)\n\ndef bfs():\n\tglobal deep\n\tdeep=[0 for i in range(T+1)]\n\tq=[]\n\tq.append(S)\n\tdeep[S]=1\n\twhile (len(q)>0):\n\t\tx=q[0]\n\t\tdel(q[0])\n\t\ti=he[x]\n\t\twhile (i):\n\t\t\ty=e[i].to\n\t\t\tif ((deep[y]==0)and(e[i].fl!=0)):\n\t\t\t\tdeep[y]=deep[x]+1\n\t\t\t\tq.append(y)\n\t\t\ti=e[i].ne\n\treturn deep[T]!=0\n\ndef dfs(x,flow):\n\tglobal deep\n\tif ((x==T)or(flow==0)):\n\t\treturn flow\n\tused=0\n\ti=he[x]\n\twhile (i):\n\t\ty=e[i].to\n\t\tif ((deep[y]==deep[x]+1)and(e[i].fl!=0)):\n\t\t\tnow=dfs(y,min(flow-used,e[i].fl))\n\t\t\tused+=now\n\t\t\te[i].fl-=now\n\t\t\te[i^1].fl+=now\n\t\t\tif (flow==used):\n\t\t\t\tbreak;\n\t\ti=e[i].ne\n\tif (used==0):\n\t\tdeep[x]=-1\n\treturn used\n\ndef dinic():\n\tres=0\n\twhile (bfs()):\n\t\tres+=dfs(S,INF)\n\treturn res\n\nn,m=map(int,input().split())\nans=0\nweight=[0]+list(map(int,input().split()))\n\ne=[0,0]\ntot=1\nS=n+m+1\nT=S+1\nhe=[0 for i in range(T+1)]\nINF=1000000007\n\nfor i in range(1,n+1):\n\taddedge(S,i,weight[i]);\nfor i in range(1,m+1):\n\tx,y,w=map(int,input().split())\n\taddedge(n+i,T,w)\n\taddedge(x,n+i,INF)\n\taddedge(y,n+i,INF)\n\tans+=w\nans-=dinic()\nprint(ans)","output":"cubic"},{"instruction":"def solution():\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        p = s.find('C')\n\n        if s[0] == 'R' and s[1].isdigit() and p > 1:\n            r = int(s[1:p])\n            c = int(s[(p + 1):])\n\n            v = list()\n            while c > 0:\n                if c % 26 == 0:\n                    v.append('Z')\n                    c = (c - 1) \/\/ 26\n                else:\n                    v.append(chr(ord('A') + (c % 26 - 1)))\n                    c \/\/= 26\n\n            v.reverse()\n            print(\"%s%d\" % (\"\".join(v), r))\n\n        else:\n            p = 0\n            while p < len(s):\n                if s[p].isdigit():\n                    break\n                p += 1\n\n            sr = s[:p]\n            sc = s[p:]\n\n            c = 0\n            for x in sr:\n                c = c * 26 + (ord(x) - ord('A') + 1)\n\n            print(\"R%sC%d\" % (sc, c))\n\nif __name__ == \"__main__\":\n    solution()","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom collections import *\n\ndef judge(x):\n    ins = [0]*n\n    outs = defaultdict(list)\n\n    for u, v, c in edges:\n        if c>x:\n            ins[v] += 1\n            outs[u].append(v)\n\n    q = deque([v for v in range(n) if ins[v]==0])\n    cnt = 0\n\n    while q:\n        v = q.popleft()\n        cnt += 1\n\n        for nv in outs[v]:\n            ins[nv] -= 1\n\n            if ins[nv]==0:\n                q.append(nv)\n\n    return cnt==n\n\ndef binary_search():\n    l, r = 0, 10**9+10\n\n    while l<=r:\n        m = (l+r)\/\/2\n\n        if judge(m):\n            r = m-1\n        else:\n            l = m+1\n\n    return l\n\nn, m = map(int, input().split())\nedges = []\nidx = defaultdict(lambda : deque([]))\n\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges.append((u, v, c))\n    idx[10**6*u+v].append(i+1)\n\nk = binary_search()\nins = [0]*n\nouts = defaultdict(list)\nremoved = []\n\nfor u, v, c in edges:\n    if c>k:\n        ins[v] += 1\n        outs[u].append(v)\n    else:\n        removed.append((u, v))\n\nq = deque([v for v in range(n) if ins[v]==0])\norder = [-1]*n\ncnt = 0\n\nwhile q:\n    v = q.popleft()\n    order[v] = cnt\n    cnt += 1\n\n    for nv in outs[v]:\n        ins[nv] -= 1\n\n        if ins[nv]==0:\n            q.append(nv)\n\nchange = []\n\nfor u, v in removed:\n    if order[v]<order[u]:\n        change.append(idx[10**6*u+v].popleft())\n\nprint(k, len(change))\nprint(*change)","output":"nlogn"},{"instruction":"from collections import defaultdict as di\n\nn = int(input())\na = list(map(int, input().split()))\nd = di(int)\nres, sum = 0, 0\nfor i in range(n):\n\tres += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]\n\tsum += a[i]\n\td[a[i]] += 1\nprint(res)","output":"nlogn"},{"instruction":"k1,k2,k3=map(int,input().split())\na=[k1,k2,k3];a=sorted(a)\nif a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(\"YES\")\nelif a.count(4)==2 and a.count(2)==1:print(\"YES\")\nelse:print(\"NO\")","output":"constant"},{"instruction":"import os,sys;from io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno();self.buffer = BytesIO();self.writable = \"x\" in file.mode or \"r\" not in file.mode;self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:break\n            ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b\"\\n\") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(\"ascii\"));self.read = lambda: self.buffer.read().decode(\"ascii\");self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ntry:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w')\nexcept:pass\nii1=lambda:int(sys.stdin.readline().strip())\nis1=lambda:sys.stdin.readline().strip()\niia=lambda:list(map(int,sys.stdin.readline().strip().split()))\nisa=lambda:sys.stdin.readline().strip().split()\n\nfrom functools import lru_cache\nfrom collections import defaultdict\nfrom math import inf\n\nn,m,k = iia()\nA = [[0] * (m) for _ in range(n)]\nB = [[0] * (m) for _ in range(n)]\nfor i in range(n):\n    tmp = iia()\n    for j in range(m - 1):\n        A[i][j + 1] = tmp[j]\nfor i in range(n - 1):\n    tmp = iia()\n    for j in range(m):\n        B[i + 1][j] = tmp[j]\n\nif k%2:\n    [print(*[-1]*m) for i in range(n)]\n    sys.exit()\nans = [[0] * m for _ in range(n)]\nlim = k \/\/ 2\ndp = [[[inf] * (lim + 1) for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor k in range(1, lim + 1):\n    for i in range(n):\n        for j in range(m):\n            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])\n            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])\n            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])\n            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])\nfor i in range(n):\n    for j in range(m):\n        ans[i][j] = dp[i][j][-1] * 2\n[print(*a) for a in ans]","output":"cubic"},{"instruction":"def possible(a,index,a1,b):\n    rem = []\n    for i in range(len(a)):\n        if i != index:\n            rem.append(a[i])\n\n    a3 = a1[:]\n    rem.sort()\n    a3.append(a[index])\n    a3.extend(rem)\n    a2 = ''\n    for i in a3:\n        a2 += str(i)\n\n    if int(a2) <= b:\n        return True\n\n    return False\n\ndef main():\n    a = list(map(int,input()))\n    b = int(input())\n\n    a.sort(reverse = True)\n    a1 = []\n    for pos in range(len(a)):\n        for i in range(len(a)):\n            if possible(a,i,a1,b):\n                a1.append(a[i])\n                a.pop(i)\n                break\n\n    for i in a1:\n        print(i,end = '')\n\nmain()","output":"cubic"},{"instruction":"import math\nfrom decimal import Decimal\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) \/ 2\n\nline = input().split()\nn = Decimal(line[0])\nk = Decimal(line[1])\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    tmp = discriminant \/ 2\n    const = Decimal(3\/2)\n    res1 = math.floor(const + tmp)\n    res2 = math.floor(const - tmp)\n    res1 = max(res1, res2)\n    print(k - res1 + 1);","output":"logn"},{"instruction":"from sys import stdin\ninput = stdin.readline\n\nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort(reverse=True)\n\nd={}\nfor i in range(n):\n    if arr[i] in d:\n        d[arr[i]].append(i)\n    else:\n        d[arr[i]]=[i]\n\ncnt=0\nvis=[-1]*n\nfor i in range(n):\n    s=bin(arr[i])\n    s=s[2:]\n    s=s[::-1]\n    l=len(s)\n    x=0\n    for j in range(l):\n        if s[j]==\"0\":\n            x=x+(2**j)\n    x=x+1\n\n    if x in d:\n        if x==arr[i] and len(d[x])==1:\n            if vis[i]==-1:\n                cnt=cnt+1\n        else:\n            if vis[d[x][0]]==-1:\n                for j in d[x]:\n                    vis[j]=1\n    else:\n        if vis[i]==-1:\n            cnt=cnt+1\n    vis[i]=1\n\nprint(cnt)","output":"nlogn"},{"instruction":"import time\nfrom decimal import Decimal\nn,k = map(int,raw_input().split())\n\ncomputeSum = lambda x: Decimal(((Decimal(x)\/Decimal(2)) * Decimal(k-x+1 + k)) - (x-1))\n\ndef minSplitters():\n    if n == 1:\n        return 0\n    elif n <= k:\n        return 1\n    max_sum = computeSum(k)\n    if n > max_sum:\n        return -1\n    else:\n        low = 0\n        high = k\n        while low < high:\n            mid = (low+high)\/2\n            previousSum = computeSum(mid-1)\n            currentSum = computeSum(mid)\n            if currentSum == n:\n                return mid\n            elif currentSum < n:\n                low = mid + 1\n            elif currentSum > n:\n                if previousSum >= n:\n                    high = mid-1\n                else:\n                    return mid\n        return low\nprint(minSplitters())","output":"logn"},{"instruction":"n, M = map(int, input().split())\nA = list(map(int, input().split()))\nA = [0]+A+[M]\nD = []\nfor i in range(n+1):\n    D.append(A[i+1]-A[i])\n\nE = []\nO = []\nfor i, d in enumerate(D):\n    if i%2 == 0:\n        E.append(d)\n        O.append(0)\n    else:\n        O.append(d)\n        E.append(0)\nfrom itertools import accumulate\nCE = [0]+E\nCE = list(accumulate(CE))\nCO = [0]+O\nCO = list(accumulate(CO))\n\nans = CE[-1]\nfor i in range(n+1):\n    if D[i] == 1:\n        continue\n    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]\n\n    ans = max(ans, temp)\nprint(ans)","output":"linear"},{"instruction":"I = lambda: map(int,input().split())\nn,l,r,x=I()\nC,k=[*I()],0\nfor i in range(2**n):\n    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']\n\n    if l <= sum(W) <= r and max(W)-min(W) >= x:\n        k += 1\nprint(k)","output":"np"},{"instruction":"from sys import stdin, stdout, setrecursionlimit\nfrom collections import deque, defaultdict\nfrom bisect import bisect_left\n\ndef check(temp):\n\tif len(temp) < 2:\n\t\treturn False\n\telse:\n\t\ts = sum(temp)\n\t\tif s >= l and s <= r:\n\t\t\tif temp[-1] - temp[0] >= x:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n\ndef brute(index, temp):\n\tglobal count\n\n\tif index == n:\n\t\tif check(temp):\n\t\t\tcount += 1\n\n\telse:\n\t\ttemp.append(arr[index])\n\t\tbrute(index + 1, temp)\n\t\ttemp.pop()\n\t\tbrute(index + 1, temp)\n\nn, l, r, x = list(map(int, stdin.readline().split()))\narr = list(map(int, stdin.readline().split()))\narr.sort()\ncount = 0\ntemp = []\nbrute(0, temp)\nprint(count)","output":"np"},{"instruction":"def get_kth_digit(i):\n    if i < 10:\n        return i\n\n    batch = 9\n    count = 9\n    width = 1\n\n    while i >  10 * batch * (width + 1) + count:\n        batch *= 10\n        width += 1\n        count += batch * width\n\n    k = i - count - 1\n    num = 10 ** width + k\/\/ (width + 1)\n    return str(num)[k % (width + 1)]\n\ndef main():\n    i = int(input())\n\n    print(get_kth_digit(i))\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nn,k=map(int,sys.stdin.readline().split())\n\nmod=998244353\ndp=[[0,0,0,0] for x in range(k+3)]\ndp[1][0]=1\ndp[1][1]=1\ndp[2][2]=1\ndp[2][3]=1\nnewdp=[[0,0,0,0] for x in range(k+3)]\nfor i in range(n-1):\n\n    for j in range(k+1):\n        newdp[j+1][1]+=dp[j][0]\n        newdp[j+1][3]+=dp[j][0]\n        newdp[j+1][2]+=dp[j][0]\n        newdp[j][0]+=dp[j][0]\n        newdp[j][1]+=dp[j][1]\n        newdp[j+1][3]+=dp[j][1]\n        newdp[j+1][2]+=dp[j][1]\n        newdp[j+1][0]+=dp[j][1]\n        newdp[j][1]+=dp[j][2]\n        newdp[j+2][3]+=dp[j][2]\n        newdp[j][2]+=dp[j][2]\n        newdp[j][0]+=dp[j][2]\n        newdp[j][1]+=dp[j][3]\n        newdp[j][3]+=dp[j][3]\n        newdp[j+2][2]+=dp[j][3]\n        newdp[j][0]+=dp[j][3]\n\n        for a in range(3):\n            for b in range(4):\n                newdp[a+j][b]%=mod\n    for a in range(k+3):\n        for b in range(4):\n            dp[a][b]=newdp[a][b]\n            newdp[a][b]=0\n\nans=sum(dp[k])\nans%=mod\nprint(ans)","output":"np"},{"instruction":"from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nx = [0] * (n + 1)\nfor i in range(n):\n    if p[i] < m:\n        x[i + 1] = -1\n    elif p[i] > m:\n        x[i + 1] = 1\n    else:\n        l = i\nfor i in range(1, n + 1):\n    x[i] += x[i - 1]\ncnt = [defaultdict(lambda : 0) for _ in range(2)]\nfor i in range(l + 1):\n    cnt[i % 2][x[i]] += 1\nans = 0\nfor i in range(l + 1, n + 1):\n    xi = x[i]\n    ans += cnt[i % 2][xi - 1]\n    ans += cnt[i % 2 ^ 1][xi]\nprint(ans)","output":"nlogn"},{"instruction":"from math import inf\n\na=[0,0]\na[0]=[str(c)for c in list(input().strip()) ]\na[1]=[str(X) for X in list(input().strip())]\n\nan = [-inf,-inf,-inf]\nif a[0][0]==a[1][0]=='0':\n    an[0]=0\nelif  a[0][0]!=a[1][0]:\n    an[1]=0\nx=0\nfor i in range(1,len(a[0])) :\n\n    if an[0]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n\n            an=[-inf,0 ,-inf]\n        elif a[0][i]!=a[1][i]:\n            x+=1\n            an=[-inf]*3\n        else:\n            an = [-inf, -inf, -inf]\n    elif an[1]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n            an=[-inf,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            pass\n        else:\n            an=[-inf,-inf ,-inf]\n    else:\n        if a[0][i]==a[1][i]=='0':\n\n            an=[0,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            an=[-inf,0,-inf]\n        else:\n            an=[-inf,-inf ,-inf]\n\nprint(x)","output":"constant"},{"instruction":"n, k = map(int, input().split())\nvalues, single, l, r = [int(i) for i in input().split()], set(), -1, -1\nfor i in range(n):\n    single.add(values[i])\n    if len(single) == k:\n        l, r = 1, i + 1\n        break\nsingle = set()\nfor i in range(r - 1, max(-1, l - 2), -1):\n    single.add(values[i])\n    if len(single) == k:\n        l = i + 1\n        break\n\nif len(single) < k:\n    print(-1, -1)\nelse:\n    print(l, r)","output":"linear"},{"instruction":"class node:\n    def __init__(self,l,r,u,d):\n        self.u = u\n        self.d = d\n        self.l = l\n        self.r = r\n        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:\n            self.marr = [20000001 for i in range(11)]\n        else:\n            self.marr = [0 for i in range(11)]\n            self.marr[1] = min(l,r,u,d)\n    def mo(self,st):\n        return self.marr[st-1]\n\nn,m,s = (int(i) for i in input().split())\nhor = [[20000001 for i in range(m+3)] for j in range(n+2)]\nver = [[20000001 for i in range(m+2)] for j in range(n+3)]\nfor i in range(1,n+1):\n    hor[i][2:1+m] = [int(i) for i in input().split()]\nfor i in range(2,1+n):\n    ver[i][1:m+1] = [int(i) for i in input().split()]\nif s%2 == 0 :\n    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]\n    for st in range(2,s\/\/2+1):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                x = nds[i][j].marr[1]\n                l = nds[i][j].l\n                r = nds[i][j].r\n                u = nds[i][j].u\n                d = nds[i][j].d\n                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))\n    ans = [[nds[i][j].marr[s\/\/2]*2 for j in range(1,m+1)] for i in range(1,n+1)]\n    for i in range(n):\n        print(*tuple(ans[i]))\nelse :\n    a = [[-1 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        print(*tuple(a[i]))","output":"cubic"},{"instruction":"from collections import defaultdict\nimport sys\nimport bisect\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\na=[int(i) for i in input().split()if i!='\\n']\nrem=[[] for i in range(m)]\nreq=n\/\/m\nans=0\nfor i in range(n):\n    rem[a[i]%m].append([a[i],i])\nind=m-1\nfor i in range(m):\n    size=len(rem[i])\n    if size>req:\n        ind=i\n    if size<req:\n        ok=False\n        for j in range(ind,-1,-1):\n            while len(rem[j])>req:\n                pop,_=rem[j].pop()\n                rem[i].append([pop+(i-j)%m,_])\n                if len(rem[i])==req:\n                    ok=True\n                    break\n            if ok:\n                break\n            ind-=1\n        else:\n            ind=m-1\n            for j in range(ind,-1,-1):\n                while len(rem[j])>req:\n                    pop,_=rem[j].pop()\n                    rem[i].append([pop+(i-j)%m,_])\n                    if len(rem[i])==req:\n                        ok=True\n                        break\n                if ok:\n                    break\n                ind-=1\n\nout=[0]*(n)\nfor i in rem:\n    for j in i:\n        out[j[1]]=j[0]\nprint(sum(out)-sum(a))\nout=' '.join(map(str,out))\nprint(out)","output":"linear"},{"instruction":"import sys\n\na, b = input(), input()\n\nif len(a) < len(b):\n    print(*sorted(a, reverse=True), sep='')\n    exit()\n\ncnt = [0]*10\n\nfor x in a:\n    cnt[int(x)] += 1\n\ndef rec(res, digit, rem):\n    if digit == len(b):\n        return res\n    if rem[int(b[digit])]:\n        r = rem[:]\n        r[int(b[digit])] -= 1\n        x = rec(res + b[digit], digit+1, r)\n        if x:\n            return x\n    for d in range(int(b[digit])-1, -1, -1):\n        if rem[d]:\n            res += str(d)\n            rem[d] -= 1\n            suf = []\n            for i in range(10):\n                suf += [str(i)] * rem[i]\n            return res + ''.join(sorted(suf, reverse=True))\n    return ''\n\nans = rec('', 0, cnt[:])\nprint(ans)","output":"cubic"},{"instruction":"n = int(input())\nk = set(\"47\")\np = False\nfor i in range(1, n+1):\n    if n%i == 0:\n        if set(str(i)) <= k:\n            p = bool(set(str(i)))\n            break\nif p == True:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"from sys import  stdin\ninput=stdin.readline\nfrom  collections import defaultdict\ndef num(s):\n    l,r=0,0\n    for i in s:\n        if l==0 and i==\")\":\n            r+=1\n        elif i==\"(\":\n            l+=1\n        elif l and i==\")\":\n            l-=1\n    return (l,r)\n\ndef f(mp,cnt):\n    ans=0\n    for l in cnt:\n        if l.count(0)<1:\n            continue\n        t=mp[l[::-1]]\n        ans+=t\n        if t and l!=l[::-1]:\n            mp[l]-=1\n    return ans\n\ncnt=[]\nmp=defaultdict(int)\nfor i in range(int(input())):\n    s=input()\n    l=num(s)\n    cnt.append(l)\n    mp[l]+=1\nprint(f(mp,cnt))","output":"linear"},{"instruction":"from collections import defaultdict, Counter\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef lcm(a, b): return (a * b) \/\/ gcd(a, b)\n\ndef main():\n\n    s = li()\n    n = len(s)\n    cnt = 0\n    sm = 0\n    for i in range(n):\n        s[i] = int(s[i]) % 3\n    i = 0\n    while i < n:\n        if s[i] == 0:\n            cnt += 1\n            sm = 0\n            i += 1\n        else:\n            sm += s[i]\n            if sm % 3 == 0:\n                sm = 0\n                cnt += 1\n                i += 1\n            else:\n                if i + 1 < n and s[i] + s[i + 1] == 3:\n                    i += 2\n                    cnt += 1\n                    sm = 0\n                else:\n                    i += 1\n    print(cnt)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"n,m=map(int,input().split())\nseq=[int(i) for i in input().split()][:n]\nf=[int(i) for i in input().split()][:m]\na=[]\nfor i in range(n):\n    for j in range(m):\n        if(seq[i]==f[j]):\n            a.append(seq[i])\n\nfor i in range(len(a)):\n    print(a[i],end=' ')","output":"quadratic"},{"instruction":"def check(x: int) -> (int, int):\n    vis = {}\n    for i, array in enumerate(a):\n        t = 0\n        for j, val in enumerate(array):\n            if val >= x:\n                t |= 1 << j\n        vis[t] = i\n    if (1 << m) - 1 in vis:\n        return vis[(1 << m) - 1], vis[(1 << m) - 1]\n    for i in range(1, (1 << m) - 1):\n        for j in range(1, (1 << m) - 1):\n            if i in vis and j in vis and i | j == (1 << m) - 1:\n                return vis[i], vis[j]\n    return -1, -1\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    l = 0\n    r = int(1e9)\n    while l <= r:\n        mid = l + r >> 1\n        if check(mid) != (-1, -1):\n            l = mid + 1\n        else:\n            r = mid - 1\n    ans = check(r)\n    print(\"%d %d\" % (ans[0] + 1, ans[1] + 1))","output":"np"},{"instruction":"n, m = map(int,input().split())\nX = []\nfor i in range(n):\n    a = input()\n    U = [char for char in a]\n    X.append(U)\nnums = []\nfor i in range(m):\n    t = 0\n    for j in range(n):\n        t += int(X[j][i])\n    nums.append(t)\n\nfor i in range(n):\n    ok = True\n    for j in range(m):\n        if X[i][j] == '1':\n            if nums[j]>1:\n                continue\n            else:\n                ok = False\n    if ok == True:\n        print(\"YES\")\n        quit()\nprint(\"NO\")","output":"quadratic"},{"instruction":"from sys import stdin\ninput = stdin.buffer.readline\n\nn,m=map(int,input().split())\narr=[int(x) for x in input().split()]\n\ndp=[[] for i in range(m)]\nfor i in range(n):\n    dp[arr[i]%m].append(i)\n\nres=0\nk=n\/\/m\nans=arr.copy()\ns=[]\nfor t in range(2):\n    for i in range(m):\n        if len(dp[i])<k:\n            while len(s)!=0 and len(dp[i])<k:\n                x=s.pop()\n                y=arr[x]%m\n                if i>y:\n                    ans[x]=ans[x]+(i-y)\n                    res=res+(i-y)\n                else:\n                    ans[x]=ans[x]+(m-1-y)+(i+1)\n                    res=res+(m-1-y)+(i+1)\n                dp[i].append(\"xxx\")\n        if len(dp[i])>k:\n            while len(dp[i])>k:\n                s.append(dp[i].pop())\n\nprint(res)\nprint(*ans)","output":"linear"},{"instruction":"import sys\nLI=lambda:list(map(int, sys.stdin.readline().split()))\nMI=lambda:map(int, sys.stdin.readline().split())\nSI=lambda:sys.stdin.readline().strip('\\n')\nII=lambda:int(sys.stdin.readline())\n\nn=II()\ns=SI()\nc=set(s)\nln=[0]*n\nfor d in c:\n\tlast=-1\n\n\tfor i, v in enumerate(s):\n\t\tif v==d:\n\t\t\tlast=i\n\t\tif last==-1:\n\t\t\tln[i]=int(1e9)\n\t\telse:\n\t\t\tln[i]=max(ln[i], i-last+1)\n\nprint(min(ln))","output":"linear"},{"instruction":"R=lambda:map(int,input().split())\na,b=R()\nx,y,z=R()\nprint(max(0,2*x+y-a)+max(0,y+3*z-b))","output":"constant"},{"instruction":"M = 10**9 + 7\nR = lambda: map(int, input().split())\nx,k = R()\nif x == 0:\n    print(0)\n    quit()\nprint(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)","output":"logn"},{"instruction":"from sys import stdout\n\nask_count = 0\n\nn = int(input())\n\ndef ask(num):\n    global ask_count\n    print(\"? \" + str(num))\n    stdout.flush()\n    ask_count += 1\n    return int(input())\n\ndef ans(num):\n    print(\"! \" + str(num))\n    stdout.flush()\n\ndef opposite(num):\n    return num + n \/\/ 2\n\nlow = 1\nhigh = opposite(low)\nlval = ask(low)\nhval = ask(high)\nprev_l_less_h = (lval < hval)\n\nwhile high - low > 1:\n\n    mid = (low + high) \/\/ 2\n\n    lval = ask(mid)\n    hval = ask(opposite(mid))\n    l_less_h = (lval < hval)\n\n    if abs(lval - hval) % 2 == 1:\n        ans(-1)\n        exit(0)\n    elif hval == lval:\n        ans(mid)\n        exit(0)\n    else:\n        if l_less_h == prev_l_less_h:\n            low = mid\n        else:\n            high = mid\nans(-1)","output":"logn"},{"instruction":"a,b = list(input()),int(input())\nans = \"\"\na.sort(reverse=True)\nwhile len(a)>0:\n    for i in range(len(a)):\n        num = ans+a[i]+\"\".join(sorted(a[:i]+a[i+1:]))\n        if int(num)<=b:\n            ans += a[i]\n            a = a[:i]+a[i+1:]\n            break\nprint(ans)","output":"cubic"},{"instruction":"from sys import exit\nN, M = map(int, input().split())\nB = list(map(int, input().split()))\nG = list(map(int, input().split()))\nB.sort()\nmB = B[-1]\nm2B = B[-2]\nmG = min(G)\nif mB > mG:\n    print(-1)\n    exit()\nif mB == mG:\n    print(sum(B)*M + sum(G) - mB * M)\n    exit()\nprint(sum(B)*M + sum(G) - mB * M + mB - m2B)","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\n\nar=[-1 for i in range(256)]\nls=list(map(int,input().split()))\n\nfor e in ls:\n    if ar[e]==-1:\n        tmp=max(0,e-k+1)\n        for i in range(tmp,e+1):\n            if ar[i]!=-1 and ar[i]!=i:\n                tmp+=1\n                continue\n            else:\n                while i<=e:\n                    ar[i]=tmp\n                    i+=1\n    print(ar[e],end=\" \")","output":"quadratic"},{"instruction":"n = int(input())-1\nx = 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = 10 ** (x - 1)\na += n \/\/ x\nprint(str(a)[n % x])","output":"logn"},{"instruction":"n = int(input())\narr = list(map(int,input().strip().split()))[:n]\n\nnew = sorted(arr)\ncount = 0\n\nfor i in range(n):\n    if arr[i] != new[i]:\n        count += 1\n\nif count <= 2:\n    print('YES')\nelse:\n    print('NO')","output":"nlogn"},{"instruction":"import bisect\nxzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]\nk=int(input())\ndigits=bisect.bisect_left(xzy,k)\nif k==10:\n    print(1)\nelif k>10:\n    apu=k-xzy[digits-1]\n    modulo=apu%(digits+1)\n    dlj=apu\/\/(digits+1)\n    output=10**(digits)+dlj\n    list1=[i for i in str(output)]\n    print(list1[modulo])\nelse:\n    print(k)","output":"logn"},{"instruction":"from math import floor\nimport re\n\nz = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef convert_num(x):\n    output = \"\"\n    row, col = [int(x) for x in re.split(\"(\\d+)\", x) if x.isnumeric()]\n    while col > 0:\n        y = (col - 1) % 26\n        output += z[y]\n        col = floor((col - 1) \/ 26)\n    return f\"{output[::-1]}{row}\"\n\ndef convert_alpha(x):\n    output = 0\n    word = (\"\".join([i for i in x if i.isalpha()]))[::-1]\n    for i in range(0, len(word)):\n        output += (z.index(word[i]) + 1) * 26 ** i\n    ending = x[len(word) :]\n\n    return f\"R{ending}C{output}\"\n\ni = int(input())\noutput = \"\"\nfor x in range(i):\n    hehexd = input()\n    if hehexd.startswith(\"R\") and hehexd[1].isnumeric() and \"C\" in hehexd:\n        output += f\"{convert_num(hehexd)}\\n\"\n    else:\n        output += f\"{convert_alpha(hehexd)}\\n\"\nprint(output)","output":"linear"},{"instruction":"import sys, os\n\nnumbs = [int(x) for x in sys.stdin.buffer.read().split()]\nn = numbs.pop(0)\n\nbase = []\nout = []\n\nfor i in range(n):\n    x = numbs[i]\n    how = 0\n\n    for b,rep in base:\n        if x.bit_length() == b.bit_length():\n            x ^= b\n            how ^= rep\n\n    if x:\n        how |= 1 << i\n\n        a = 0\n        b = len(base)\n        while a < b:\n            c = a + b >> 1\n            if base[c][0] > x:\n                a = c + 1\n            else:\n                b = c\n        base.insert(a, (x, how))\n\n        out.append(0)\n    else:\n        outind = len(out)\n        out.append(-1)\n\n        y = bin(how).encode('ascii')\n        ylen = len(y)\n        for i in range(2,len(y)):\n            if y[i] == 49:\n                out.append(ylen - 1 - i)\n        out[outind] = len(out) - 1 - outind\n\nos.write(1, b'\\n'.join(str(x).encode('ascii') for x in out))","output":"np"},{"instruction":"import sys\ninput=sys.stdin.readline\n\ndef count_bits(x):\n    cnt=0\n    for i in range(n):\n        if((1<<i)&x):\n            cnt+=1\n    return(cnt)\n\nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\ndp=[0 for i in range(1<<n)]\ndp[-1]=1\n\nfor mask in range((1<<n)-1,-1,-1):\n    val=count_bits(mask)\n    total=val*(val-1)\/\/2\n    for i in range(n):\n        if(mask&(1<<i)==0):\n            continue\n        for j in range(n):\n            if(mask&(1<<j)==0 or i==j):\n                continue\n            dp[mask^(1<<j)]+=dp[mask]*a[i][j]\/total\nfor i in range(n):\n    print(dp[1<<i])","output":"np"},{"instruction":"a, b= list(map(int, input().split()))\nc = 1\nresult = a^b\nwhile c <= result:\n    c *= 2\nc -= 1\n\nprint(c)","output":"logn"},{"instruction":"from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nn, d, k = map(int, input().split())\nif n == 1 or n <= d:\n    ans = \"NO\"\nelif k == 1:\n    ans = \"YES\" if n == 2 and d == 1 else \"NO\"\n    e = [(1, 2)]\nelse:\n    e = [(i + 1, i + 2) for i in range(d)]\n    q = deque()\n    l, r = 1, d + 1\n    if k > 2:\n        for i in range(2, d + 1):\n            q.append((i, 2, min(i - l, r - i)))\n    ans = \"YES\"\n    for i in range(d + 2, n + 1):\n        if not q:\n            ans = \"NO\"\n            break\n        j, k0, d0 = q.popleft()\n        e.append((j, i))\n        if k0 + 1 < k:\n            q.append((j, k0 + 1, d0))\n        if d0 - 1 > 0:\n            q.append((i, 1, d0 - 1))\nprint(ans)\nif ans == \"YES\":\n    for u, v in e:\n        print(u, v)","output":"quadratic"},{"instruction":"n,k = map(int,input().split())\na = list(map(int,input().split()))\n\ncount = 0\nb = {}\nfor i in range(n):\n    if a[i] in b:\n        b[a[i]] += 1\n    else:\n        b[a[i]] =1\n    if b[a[i]] == 1:\n        count += 1\n    if count == k:\n        break\n\nfor j in range(n):\n  if a[j] in b:\n    b[a[j]] -= 1\n\n  if b[a[j]] == 0:\n    break\n\nif count != k:\n    print(\"-1 -1\")\nelse:\n  if n == 1:\n    print(1,1)\n  elif n == 2 and count == 2:\n    print(1,2)\n  else:\n    print(j+1,i+1)","output":"linear"},{"instruction":"from itertools import groupby\n\nn = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nsums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))]\nsums.sort()\nanswer = [None] * n\ncurr_candies = n\nfor key, group in groupby(sums, key=lambda i: i[0]):\n    for elem in group:\n        answer[elem[1]] = curr_candies\n    curr_candies -= 1\ntl = []\nfor i in range(n):\n    cnt = 0\n    for j in range(i):\n        if answer[j] > answer[i]:\n            cnt += 1\n    tl.append(cnt)\ntr = []\nfor i in range(n):\n    cnt = 0\n    for j in range(i + 1, n):\n        if answer[j] > answer[i]:\n            cnt += 1\n    tr.append(cnt)\nif tl != l or tr != r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(' '.join(map(str, answer)))","output":"quadratic"},{"instruction":"import sys, copy\n\nn, m = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = [0] * (max(arr) + 1)\nfor i in arr:\n    res[i] += 1\nans = 0\nfor d in range(1, m + 1):\n    temp = copy.deepcopy(res)\n    cnt = 0\n    for i in range(len(temp)):\n        while temp[i] >= d:\n            temp[i] -= d\n            cnt += 1\n    if cnt >= n:\n        ans = max(ans, d)\nprint(ans)","output":"nlogn"},{"instruction":"def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) \/\/ i\n    i += 1\n\nprint(str(sum + (n + i - 1) \/\/ i)[n % i - 1])","output":"constant"},{"instruction":"n, k = map(int, input().split())\np = (k - 1) \/\/ n + 1\nprint(p)","output":"constant"},{"instruction":"from sys import stdin\nfrom collections import Counter\n\nclass Node:\n    def __init__(self,val):\n        self.val=val\n        self.forw=set()\n        self.cou=0\n\n    def __str__(self):\n        return f'{self.val} {self.forw} {self.cou}'\n\nn=int(stdin.readline())\narr=[Node(i) for i in range(1,n+1)]\nc=2\nfor x in map(int,stdin.readline().split()):\n    arr[x-1].forw.add(c)\n    c+=1\n\ndct=Counter()\nlst = [1]\nwhile len(lst):\n    fl = 0\n    for i in arr[lst[-1]-1].forw:\n        lst.append(i)\n        fl = 1\n        break\n    if fl:\n        arr[lst[-2]-1].forw.remove(i)\n    if not fl:\n        if arr[lst[-1]-1].cou ==0:\n            arr[lst[-1]-1].cou=1\n        dct[arr[lst[-1]-1].cou]+=1\n        k=arr[lst.pop()-1].cou\n        if len(lst):arr[lst[-1]-1].cou+=k\n\ny=1\nfor _ in range(n):\n    while not dct[y]:\n        y+=1\n    dct[y]-=1\n    print(y,end=' ')","output":"linear"},{"instruction":"n = int(input())\nA = [int(a) for a in input().split()]\nB = A.copy()\nB.sort()\nc = 0\nfor i in range(n):\n    a = A[i]\n    b = B[i]\n    if a == b:\n        continue\n    else:\n        c += 1\nif c == 0 or c == 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n = int(input())\n\nif(n>=0):\n    print(n)\n    exit()\nelse:\n    n=str(abs(n))\n    n1=int(n[:len(n)-1])\n\n    temp=n[len(n)-1]\n\n    n2=n[:len(n)-2]\n\n    n2=int(n2+temp)\n\nif(n1<=n2):\n    if(n1!=0):\n        print('-'+str(n1))\n    else:\n        print(0)\nelse:\n    if(n2!=0):\n        print('-'+str(n2))\n    else:\n        print(0)","output":"constant"},{"instruction":"import collections,sys,functools,heapq,bisect,math\n\ndef binary(s):\n    ans = set()\n    for i in range(2**len(s)):\n        x = []\n        for j in range(len(s)):\n            if (i>>j) & 1:\n                x.append(s[j])\n            else:\n                x.append('_')\n        ans.add(''.join(x))\n    return ans\n\nseen = set()\nvisited = set()\nans = []\ndef dfs(i):\n    visited.add(i)\n    seen.add(i)\n    for j in graph[i]:\n        if j in visited:\n            return True\n        if j in seen:\n            continue\n        if dfs(j):\n            return True\n    ans.append(str(i))\n    visited.remove(i)\n    return False\n\ndef topo(graph):\n    seen.clear()\n    for i in range(1,n+1):\n        if i in seen:\n            continue\n        if dfs(i):\n            return False\n    return True\n\ninput = sys.stdin.readline\nmod = 10**9 + 7\n\nfor _ in range(1):\n    n,m,k = map(int,input().strip().split())\n    d = {}\n    dop = {}\n    for i in range(1,n+1):\n        d[i] = input().strip()\n        dop[d[i]] = i\n\n    graph = collections.defaultdict(list)\n    for i in range(m):\n        s = input().strip().split()\n        ind = int(s[1])\n        sset = binary(s[0])\n\n        if d[ind] not in sset:\n            print('NO')\n            break\n        for i in sset:\n            if i in dop and dop[i] != ind :\n                graph[dop[i]].append(ind)\n    else:\n\n        if topo(graph):\n            print('YES')\n            print(' '.join(ans))\n        else:\n            print('NO')","output":"np"},{"instruction":"import sys\nimport math\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, sys.stdin.readline().strip().split())\ndef listinput(): return list(map(int, sys.stdin.readline().strip().split()))\nn,m=minput()\nx=listinput()\ny=listinput()\nxx=set(x)\nyy=set(y)\ncommon=xx.intersection(yy)\nfor i in x:\n    if i in common:\n        print(i,end=' ')","output":"quadratic"},{"instruction":"def suma_o_resta(a, b):\n\treturn (a & (1<<b))\n\ndef diferencia(s1, d):\n\tif s1:\n\t\ts1.sort()\n\n\t\tif s1[-1] - s1[0] >= d:\n\n\t\t\treturn s1\n\t\telse:\n\t\t\treturn diferencia(s1.remove(s1[-1]), d)\n\treturn s1\n\ndef no_sets(v, n, l, r, d):\n\ts = []\n\tcont = 0\n\tfor x in range(1<<n):\n\t\tfor i in range(n):\n\n\t\t\tif suma_o_resta(x, i) > 0:\n\n\t\t\t\ts.append(v[i])\n\t\ts = diferencia(s, d)\n\t\tif s:\n\t\t\tif sum(s) >= l and sum(s) <= r:\n\t\t\t\tcont += 1\n\t\ts = []\n\treturn cont;\n\nn, l, r, x = map(int, input().split())\n\nv = list(map(int, input().split()))\n\nprint(str(no_sets(v, n, l, r, x)))","output":"np"},{"instruction":"from math import factorial\ns1 = input()\ns2 = input()\np = 0\nm = 0\nblank = 0\nfor i in range(len(s1)):\n    if (s1[i] == \"+\"):\n        p += 1\n    else:\n        m += 1\n    if (s2[i] == \"+\"):\n        p -= 1\n    elif (s2[i]==\"-\"):\n        m -= 1\n    else:\n        blank += 1\nif (m<0 or p<0):\n    print(0)\nelse:\n    if (m==0):\n        print(0.5 ** p)\n    elif (p==0):\n        print(0.5 ** m)\n    else:\n        b = blank\n        print((factorial(b)\/factorial(p)\/factorial(m))*(0.5**b))","output":"np"},{"instruction":"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))\nextensions = list(map(int, input().split()))\nextensions.sort(reverse=True)\ndevices_left = n_dvics - n_sokts\nextnson_used = 0\ni = 0\nwhile devices_left > 0 and n_extnson > 0:\n    devices_left += 1\n    extnson_siez = extensions[i]\n    devices_left -= extnson_siez\n    extnson_used += 1\n    n_extnson -= 1\n    i += 1\n\nif devices_left > 0:\n    print(-1)\nelse:\n    print(extnson_used)","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\nl = [0 for i in range(n)]\nfor i in range(n-1):\n\ta, b = map(int, input().split())\n\tl[a-1]+=1\n\tl[b-1]+=1\ncount = 0\nfor i in range(n):\n\tif(l[i]==1):\n\t\tcount+=1\nprint((s\/count)*2)","output":"linear"},{"instruction":"import functools\nimport time\nfrom collections import Counter\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        n = int(input())\n        minv = n + 1\n        mini = n\n        for l in range(1, n + 1):\n            v = l + (n + l - 1) \/\/ l\n            if v < minv:\n                minv = v\n                mini = l\n\n        ref = [i + 1 for i in range(n)]\n        l = mini\n        res = list()\n        p = n - 1\n        while p >= 0:\n            pp = max(0, p - l + 1)\n            res.extend(ref[pp:p + 1])\n            p = pp - 1\n        print(' '.join(map(str, res)))\n\nsolver()()","output":"linear"},{"instruction":"r,g,b = map(int,input().split())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl3 = list(map(int,input().split()))\nl1.sort(reverse=True)\nl2.sort(reverse=True)\nl3.sort(reverse=True)\ndp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]\nans = 0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n            if j == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])\n            else:\n                if i>0 and j>0:\n                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]\n                elif i>0 and k>0:\n                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]\n                elif j>0 and k>0:\n                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]\n            ans = max(ans,dp[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"n,m,k=map(int,input().split())\narr=list(map(int,input().split()))\narr.sort()\narr=arr+[k]\nans=0\ns=0\nwhile ans<n+1:\n    s+=arr[-ans-1]\n    if s>=m:\n        break\n    ans+=1\n    s-=1\nif s>=m:\n    print(ans)\nelse:\n    print(\"-1\")","output":"nlogn"},{"instruction":"l,r=map(int,input().split())\nx=l^r\na=2\nif(l==r):\n    print(0)\nelse:\n    while(a<=x):\n        a=a*2\n\n    print(a-1)","output":"logn"},{"instruction":"n, m = map(int, input().split())\n\nl=[]\ns1 = s2 = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    s1+=a\n    s2+=b\n    l.append(a-b)\n\nif s1<=m: print(0)\nelif s2>m: print(-1)\nelse:\n    r=0\n    l.sort(reverse=True)\n    for i in l:\n        r+=1\n        s1-=i\n        if s1<=m:\n            print(r)\n            break","output":"nlogn"},{"instruction":"import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nelse:\n    input = sys.stdin.readline\n\nn = int(input())\n\nif(n == 2 or n == 3 or n == 4 or n == 5):\n    print(-1)\nelse:\n    print(1,2)\n    print(2,3)\n    print(2,4)\n    for i in range(5,n + 1):\n        print(4,i)\n\nfor i in range(2,n + 1):\n    print(1,i)","output":"linear"},{"instruction":"import sys\nimport io, os\ninput = sys.stdin.buffer.readline\n\nfrom collections import defaultdict\n\nn, a, b = map(int, input().split())\nXV = []\nfor i in range(n):\n    x, vx, vy = map(int, input().split())\n    XV.append((x, vx, vy))\nif a != 0:\n    ans = 0\n    d = defaultdict(lambda:0)\n    dvx = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        k = -a*vx+vy\n        ans += max(0, d[k]-dvx[(k, vx)])\n        d[k] += 1\n        dvx[(k, vx)] += 1\n    print(ans*2)\nelse:\n    ans = 0\n    d = defaultdict(lambda:defaultdict(lambda:0))\n    ds = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        ans += max(0, ds[vy]-d[vy][vx])\n        d[vy][vx] += 1\n        ds[vy] += 1\n    print(ans*2)","output":"linear"},{"instruction":"import sys,os,io,time,copy\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\nimport math\n\ndef main():\n\n    n=int(input())\n    print(0,0,n)\n\nmain()","output":"constant"},{"instruction":"input()\na=list(map(int,input().split()))\nn=len(a)\nu=n\nfor i in range(n):\n\tj=i\n\tk=0\n\twhile a[j]>0:\n\t\tk+=1\n\t\tt=j\n\t\tj=a[j]-1\n\t\ta[t]=0\n\tif k>0:\n\t\tu+=1-k%2\ns='Petr'\nif u%2>0:\n\ts='Um_nik'\nprint(s)","output":"nlogn"},{"instruction":"r,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"n = int(input())\nans = []\nmult = 1\nwhile n > 3:\n    ans += [mult]*(n-n\/\/2)\n    n \/\/= 2\n    mult *= 2\nif n == 3:\n    ans += [mult, mult, mult*3]\nelif n == 2:\n    ans += [mult, mult*2]\nelse:\n    ans += [mult]\nprint(*ans)","output":"logn"},{"instruction":"n,U=list(map(int, input().split(' ')))\na=list(map(int, input().split(' ')))\n\nimport bisect\ndef max_eligible(a,x):\n    ind=bisect.bisect_right(a,x)\n    if ind <= len(a):\n        return a[ind-1]\n    else:\n        return -1\n\nmax_val=-1\nfor i in range(n-2):\n    x = a[i]+U\n    val1 = max_eligible(a,x)\n\n    if val1!=-1 and val1!=a[i+1] and val1!=a[i]:\n\n        val = (val1-a[i+1]) \/ (val1-a[i])\n\n        max_val=max(max_val,val)\n\nprint(max_val)","output":"nlogn"}]