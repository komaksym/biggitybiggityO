[{"instruction":"def maxXORInRange(L, R):\n    LXR = L ^ R\n\n    msbPos = 0\n    while (LXR):\n        msbPos += 1\n        LXR >>= 1\n\n    maxXOR, two = 0, 1\n\n    while (msbPos):\n        maxXOR += two\n        two <<= 1\n        msbPos -= 1\n\n    return maxXOR\n\nL, R = map(int, input().split())\nprint(maxXORInRange(L, R))","output":"logn"},{"instruction":"import sys\n\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline().rstrip()\ninf = 10**16\nmd = 10**9+7\n\nn, k = LI()\ns = [-1 if c == \"?\" else ord(c)-97 for c in SI()]\n\ndef ok(m):\n    nxt = [[n]*(n+1) for _ in range(k)]\n    for j in range(k):\n        cnt = 0\n        ni = n\n        nxtj = nxt[j]\n        for i in range(n)[::-1]:\n            if s[i] == -1 or s[i] == j: cnt += 1\n            else: cnt = 0\n            if cnt >= m: ni = i\n            nxtj[i] = ni\n    dp = [n+1]*(1 << k)\n    dp[0] = 0\n    for bit in range(1 << k):\n        l = dp[bit]\n        if l+m > n: continue\n        for j in range(k):\n            if bit >> j & 1: continue\n            i = nxt[j][l]\n            if i+m <= n:\n                nbit = bit | 1 << j\n                dp[nbit] = min(dp[nbit], i+m)\n    return dp[-1] <= n\n\nl, r = 0, n\/\/k+1\nwhile l+1 < r:\n    m = (l+r)\/\/2\n    if ok(m): l = m\n    else: r = m\n\nprint(l)","output":"np"},{"instruction":"import math\n\nk,n,s,p = input().split()\nk = int(k)\nn = int(n)\ns = int(s)\np = int(p)\n\nsheet_for_each_person = math.ceil(n\/s)\n\ntotal_sheets_required = k*sheet_for_each_person\n\nno_of_packs = math.ceil( total_sheets_required\/p )\nprint(no_of_packs)","output":"constant"},{"instruction":"from math import *\na, vm = map(int, input().split())\nl, d, vd = map(int, input().split())\nif vm <= vd or sqrt(2 * a * d) <= vd:\n    if vm ** 2 \/ (2 * a) >= l:\n        ans = sqrt(2 * l \/ a)\n    else:\n        ans = vm \/ a + (l - vm ** 2 \/ (2 * a)) \/ vm\nelse:\n    s1 = (vm ** 2 - vd ** 2) \/ (2 * a)\n    if s1 >= (l - d):\n        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) \/ (2 * a)\n    else:\n        ans = (vm - vd) \/ a + (l - d - s1) \/ vm\n    v1 = sqrt((2 * a * d + vd ** 2) \/ 2)\n    if v1 <= vm:\n        ans = ans + v1 \/ a + (v1 - vd) \/ a\n    else:\n        s1 = d - (vm ** 2 - vd ** 2) \/ (2 * a) - (vm ** 2) \/ (2 * a)\n        ans = ans + vm \/ a + (vm - vd) \/ a + s1 \/ vm\nprint('%.12f' % ans)","output":"constant"},{"instruction":"n, m = map(int, input().split())\n\nnp1 = n + 1\nmp1 = m + 1\n\nfor i in range(1, 1 + n \/\/ 2):\n  for j in range(1, mp1):\n\n    print('%d %d\\n%d %d' % (i,j,np1-i,mp1-j))\n\nif n & 1:\n  i = 1 + n \/\/ 2\n  for j in range(1, 1 + m \/\/ 2):\n\n    print('%d %d\\n%d %d' % (i,j,i,mp1-j))\n\n  if m & 1:\n    print(i, 1 + m \/\/ 2)","output":"quadratic"},{"instruction":"n = int(input())\na = [int(s) for s in input().split()]\nans = [None]*n\n\ndef get(p):\n\n    if ans[p] is not None:\n        return ans[p]\n    elif a[p] == 1:\n        ans[p] = \"A\"\n    elif a[p] == n:\n        ans[p] = \"B\"\n    else:\n        for i in range(p+a[p], n, a[p]):\n            if a[i] > a[p]:\n                if get(i) == \"B\":\n                    ans[p] = \"A\"\n                    return ans[p]\n        for i in range(p-a[p], -1, -a[p]):\n            if a[i] > a[p]:\n                if get(i) == \"B\":\n                    ans[p] = \"A\"\n                    return ans[p]\n        ans[p] = \"B\"\n    return ans[p]\n\nif n == 1:\n    print(\"B\")\nelse:\n    for i in range(n-1, -1, -1):\n        get(i)\n    print(''.join(ans))","output":"linear"},{"instruction":"from math import factorial\ns=input()\ns1=input()\nplus=s.count('+')-s1.count('+')\nminus=s.count('-')-s1.count('-')\nn=s1.count('?')\nif plus<0 or minus<0:\n    print(0)\nelse:\n    print((factorial(n)\/factorial(n-plus)\/factorial(plus))*(0.5**n))","output":"np"},{"instruction":"import sys\ncoins = []\ncoinsValueTotal = 0\nn = int(sys.stdin.readline())\ninputs = sys.stdin.readline().split()\nfor i in range(len(inputs)):\n    coin = int(inputs[i])\n    coins.append(coin)\n    coinsValueTotal += coin\ncoins.sort(reverse = True)\nminCoins = 0\nhalfCoinsValueTotal = coinsValueTotal \/ 2\nfor i in range(len(coins)):\n    minCoins +=  coins[i]\n    if(minCoins > halfCoinsValueTotal):\n        print(i+1)\n        break","output":"nlogn"},{"instruction":"class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:\n            stack.append((target - p) \/ s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)","output":"nlogn"},{"instruction":"n = int(input())\n\nif n==1:\n    a = input()\n    print(a)\nelse:\n    a = list(map(int, input().split()))\n    b = [abs(i) for i in a]\n    if min(a)*max(a) > 0:\n        print(sum(b)-2*min(b))\n    else:\n        print(sum(b))","output":"linear"},{"instruction":"import sys\n\ndef main():\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u - v) ** 2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x & val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i + 1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0] + [1e8] * (1 << N)\n    pres = [None] * (1 << N)\n    allb = (1 << N) - 1\n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                             + alld[p[0]][0] \\\n                             + alld[p[1]][0]\n\n    for stt in range(1 << N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt & allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit] + 1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\nmain()","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nn, k = map(int, input().split())\nb = []\nd=dict()\ne=dict()\nfor i in range(n):\n    a, t = map(int, input().split())\n    b.append([a,t,i+1])\nb.sort(key= lambda x:x[1])\nans = 0\nj = 0\ncurr = 1\ncurrsum = 0\nl=0\nwhile(curr<=n):\n    if curr-1 in d.keys():\n        currsum-=d[curr-1]\n        l-=e[curr-1]\n\n    p=0\n    while (j < n):\n        if b[j][0] >= curr:\n            currsum += b[j][1]\n            if b[j][0] in d.keys():\n                d[b[j][0]]+=b[j][1]\n                e[b[j][0]]+=1\n            else:\n                d[b[j][0]] = b[j][1]\n                e[b[j][0]] = 1\n\n            l+=1\n        if l==curr:\n            j+=1\n            break\n        j+=1\n\n    if j<=n and l==curr and currsum<=k:\n        ans+=1\n    else:\n        break\n    curr+=1\nc=[]\nj=0\nl=0\nwhile(j<n):\n    if l==ans:\n        break\n    if b[j][0] >= ans:\n        c.append(b[j][2])\n        l+=1\n    j+=1\n\nprint(ans)\nprint(ans)\nprint(*c)","output":"nlogn"},{"instruction":"a,b = map(int,input().split())\n\nx,y,z=map(int,input().split())\n\nr = 0\n\nyellow = 2*x\nblue = 3*z\ngreen = y\n\nif a > yellow:\n    a -= yellow\nelse:\n    r += abs(a-yellow)\n    a=0\n\nif b > blue:\n    b -= blue\nelse:\n    r += abs(b-blue)\n    b=0\n\nif a > green:\n    a-= green\nelse:\n    r += abs(a-green)\n\nif b > green:\n    b-=green\nelse:\n    r += abs(b-green)\n\nprint(r)","output":"constant"},{"instruction":"from math import sin, pi\nn, r = map(int, input().split())\nR = r*sin(pi\/n)\/(1-sin(pi\/n))\nprint(R)","output":"constant"},{"instruction":"import sys\n\nn = int(sys.stdin.readline().rstrip())\nnums = list(map(int, sys.stdin.readline().split()))\n\nswaps = 0\nvisited = set()\nfor index in range(n):\n    if index in visited:\n        continue\n    else:\n        visited.add(index)\n        length = 0\n        value = nums[index]\n        while (value != index + 1):\n           visited.add(value - 1)\n           value = nums[value - 1]\n           length += 1\n        swaps += length\n\nif ((3 * n - swaps) % 2):\n    print(\"Um_nik\")\nelse:\n    print(\"Petr\")","output":"nlogn"},{"instruction":"s1=input()\ns2=input()\narr=list(s1)\narr.sort(reverse=True)\nif(len(s2)>len(s1)):\n  t=\"\"\n  for i in arr:\n    t+=i\n  print(t)\nelse:\n  t=\"\"\n  l =len(s1)\n  for i in range(l):\n    index=-1\n    ma = -1\n    for j in range(len(arr)):\n      temp = arr[j]\n      tt=[]\n      for k in range(len(arr)):\n        if(k!=j):\n          tt.append(arr[k])\n      tt.sort()\n      for k in tt:\n        temp+=k\n      temp = t+temp\n\n      if(int(s2)>=int(temp)):\n\n        if(int(arr[j])>ma):\n          ma = int(arr[j])\n          index = j\n    t+=arr[index]\n    del arr[index]\n\n  print(t)","output":"cubic"},{"instruction":"import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\nfrom collections import defaultdict as dd\n\nflush = lambda: stdout.flush()\nstdstr = lambda: stdin.readline()\nstdint = lambda: int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdmap = lambda: map(int, stdstr().split())\nstdarr = lambda: list(map(int, stdstr().split()))\n\nmod = 1000000007\n\ndef sieve(n):\n\n    prime = [True for _ in range(n+1)]\n    p = 2\n\n    while(p*p <= n):\n        if(prime[p] == True):\n\n            for i in range(p*p, n+1, p):\n                prime[i] = False\n\n        p += 1\n\n    return prime\n\nn,k = stdmap()\n\nall = sieve(n)\n\nprimes = []\n\nfor i in range(1, len(all)):\n    if(all[i] == True):\n        primes.append(i)\n\ns = Counter(primes)\n\nres = 0\n\nfor i in range(len(primes)-1):\n    toCheck = primes[i]+primes[i+1]+1\n\n    if(toCheck in s):\n        res += 1\n\nif(res >= k):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n\nelse:\n    sys.stdin = open('input.txt')\n\nn = ria()[0]\nx, y = ria()\nbx, by = ria()\ncx, cy = ria()\n\nx1, y1 = x - bx, y - by\nx2, y2 = x - cx, y - cy\n\nif abs(x2) == abs(y2):\n    print('NO')\n    exit(0)\nif math.copysign(x2, x1) != x2:\n    print('NO')\n    exit(0)\nif math.copysign(y2, y1) != y2:\n    print('NO')\n    exit(0)\nprint('YES')","output":"constant"},{"instruction":"def func():\n    count = 0\n    for i in range(1 << n):\n        temp = []\n        for j in range(n):\n            if 1 << j & i:\n                temp.append(c[j])\n\n        if l <= sum(temp) <= r and temp[-1] - temp[0] >= x:\n            count += 1\n    print(count)\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\nc.sort()\nfunc()","output":"np"},{"instruction":"n, d, k = map(int, input().split())\nnum = d+2\n\ndef solve():\n  global num\n  if n == 1: return 'NO'\n  if n == 2:\n    if d != 1:\n      return 'NO'\n    else:\n      return \"YES\\n1 2\"\n  if k < 2: return 'NO'\n  if d > n-1: return 'NO'\n\n  depth = [min(i, d-i) for i in range(d+1)]\n  ans = [(i+1, i+2) for i in range(d)]\n\n  def dfs(v, depth):\n    global num\n    if depth == 0: return\n    for i in range(k-1):\n      if len(ans) == n-1: return\n      v2 = num\n      num += 1\n      ans.append((v, v2))\n      dfs(v2, depth-1)\n\n  for v in range(d+1):\n    if depth[v] == 0: continue\n    for i in range(k-2):\n      if len(ans) == n-1: break\n      v2 = num\n      num += 1\n      ans.append((v+1, v2))\n      if depth[v] > 1: dfs(v2, depth[v]-1)\n\n  if len(ans) < n-1: return \"NO\"\n  return \"YES\\n%s\"%\"\\n\".join([\"%d %d\"%i for i in ans])\n\nprint(solve())","output":"quadratic"},{"instruction":"n = int(input())\nans = 0\nif n==1:\n    print(1)\n    exit()\nif n==2:\n    print(2)\n    exit()\nif n==3:\n    print(6)\n    exit()\nif n%2==0:\n    if n%3==0:\n        ans=(n-1)*(n-2)*(n-3)\n    else:\n        ans=n*(n-1)*(n-3)\nelse:\n    ans=n*(n-1)*(n-2)\n\nprint(ans)","output":"constant"},{"instruction":"def solution():\n    v = list()\n\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        p = s.find('C')\n\n        if s[0] == 'R' and s[1].isdigit() and p > 1:\n            r = int(s[1:p])\n            c = int(s[(p + 1):])\n\n            v.clear()\n            while c > 0:\n                if c % 26 == 0:\n                    v.append('Z')\n                    c = (c - 1) \/\/ 26\n                else:\n                    v.append(chr(ord('A') + (c % 26 - 1)))\n                    c \/\/= 26\n\n            v.reverse()\n            print(\"%s%d\" % (\"\".join(v), r))\n\n        else:\n            c = 0\n            p = 0\n            while p < len(s):\n                if s[p].isdigit():\n                    break\n                c = c * 26 + (ord(s[p]) - ord('A') + 1)\n                p += 1\n\n            print(\"R%sC%d\" % (s[p:], c))\n\nif __name__ == \"__main__\":\n    solution()","output":"linear"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninp = reader.__next__\n\nn, m = map(int, inp().split())\narr = tuple(tuple(map(int, inp().split())) for i in range(n))\nlower_bound = 0\nupper_bound = int(1e9) + 1\nmask = (1 << m) - 1\n\nans = (0, 0)\n\ndef can_upper(mid):\n\tglobal ans\n\n\td = dict()\n\tfor i in range(n):\n\t\tbit = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= mid:\n\t\t\t\tbit += 1 << j\n\t\td[bit] = i\n\n\tkeys = tuple(d.keys())\n\tfor i in range(len(keys)):\n\t\ta1 = keys[i]\n\t\tfor j in range(i, len(keys)):\n\t\t\ta2 = keys[j]\n\t\t\tif a1 | a2 == mask:\n\t\t\t\tans = (d[a1], d[a2])\n\t\t\t\treturn True\n\treturn False\n\nwhile upper_bound - lower_bound > 1:\n\tmiddle = (upper_bound + lower_bound) >> 1\n\tif can_upper(middle):\n\t\tlower_bound = middle\n\telse:\n\t\tupper_bound = middle\n\nprint(ans[0] + 1, ans[1] + 1)","output":"np"},{"instruction":"m=1000000007\ndef power(x, y, p=1000000007):\n    res = 1\n    x = x % p\n    while (y > 0) :\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\nx,k=list(map(int,input().split()))\nif(x==0):\n    print(0)\nelif(k==0):\n    print((x*2)%m)\nelse:\n    temp=power(2,k)\n    maxi=(((x*temp)%m)*2)%m\n    mini=(m+maxi-(2*(temp-1))%m)%m\n    print((((maxi+mini)%m)*500000004)%m)","output":"logn"},{"instruction":"x, k = map(int, input().split())\n\ntwoPow = pow(2, k, 1000000007)\n\nminQ = max(0, (x * twoPow - twoPow + 1))\nminQ *= 2\n\nmaxQ = (x * twoPow * 2)\n\nprint(((maxQ*(maxQ+1)\/\/2 - minQ*(minQ+1)\/\/2 + minQ) \/\/ (maxQ-minQ+1)) % 1000000007)","output":"logn"},{"instruction":"import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n\nint1 = lambda x: int(x) - 1\n\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\ndef fun(A):\n    for i in range(len(A)):\n        if A[i] == 0:\n            return i\n    return 1\n\ndp = [0]*10\nA = aj();A.sort()\nk1,k2,k3 = A\nfor i in range(0,10,k1):\n    dp[i] = 1\nfor i in range(fun(dp),10,k2):\n    dp[i] = 1\nfor i in range(fun(dp),10,k3):\n    dp[i] = 1\nY(0 not in dp)","output":"constant"},{"instruction":"l,r = map(int, input().split())\nans = 0\na,b,c = [],[],[]\nif l==r:\n    print(0)\n    exit()\n\nfor i in range(63, -1, -1):\n    if (r^l) & (1<<i):\n        for j in range(i,-1,-1):\n            ans|= 1<<j\n        break\nprint(ans)","output":"logn"},{"instruction":"n=int(input())\nd,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nfor i in range(1,n+1):\n    if m[i]==0:\n        d[l[i]]+=1\nfor i in range(1,n+1):\n    if m[i]>0 and d[i]<3:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")","output":"linear"},{"instruction":"N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp1 = defaultdict(lambda :-1)\nM=1001\ndef ec(i,j):\n    return i*M+j\n\nfor i in range(N):\n    dp1[ec(i,i+1)] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]\n            if u != -1 and v != -1 and u == v:\n                dp1[ec(j,j+i)] = u+1\n                break\n\ndp2 = [10**18]*(N+1)\ndp2[0] = 0\nfor i in range(N):\n    for j in range(i+1):\n        if dp1[ec(j,i+1)] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])","output":"cubic"},{"instruction":"import math\n\ndef solve(n) :\n    if not n%2 and math.sqrt(n\/\/2) == int(math.sqrt(n\/\/2)) :\n        print('YES')\n        return\n    if not n%4 and math.sqrt(n\/\/4) == int(math.sqrt(n\/\/4)) :\n        print('YES')\n        return\n    print('NO')\n\nt = int(input())\nfor i in range(t) :\n    n = int(input())\n    solve(n)","output":"constant"},{"instruction":"n = int(input())\nw = list(map(int, input().split()))\nintro = [[v, i] for i, v in enumerate(w, 1)]\nintro.sort(key=lambda x: x[0])\ns = input()\ni = -1\nli = []\nans = []\nfor j in s:\n    if j == \"0\":\n        i += 1\n        ans.append(intro[i][1])\n        li.append(intro[i][1])\n    else:\n        ans.append(li.pop(-1))\nprint(\" \".join(map(str, ans)))","output":"nlogn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,d=map(int,input().split())\nx=list(map(int,input().split()))\nans=0\nfor i in range(1,n):\n    diff=x[i]-x[i-1]\n\n    if diff >= 2*d:\n        ans+=min(2,(x[i]-d)-(x[i-1]+d)+1)\n\nans+=2\nprint(ans)","output":"linear"},{"instruction":"from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef mapin():\n    return map(int, input().split())\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nx, k = mapin()\np = 1000000007\nif(x == 0):\n    print(0)\nelse:\n    a = power(2, k, p)\n\n    b = x+x-1\n    b %= p\n    a = (a*b) % p\n    a += 1\n    a %= p\n    print(a)","output":"logn"},{"instruction":"n=int(input())\na=[*map(int,input().split())]\nb=[0]*n\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))","output":"quadratic"},{"instruction":"def read_data():\n    n = int(input().strip())\n    a = []\n    for i in range(n):\n        line = tuple(map(int, input().strip().split()))\n        a.append(line)\n    return n, a\n\ndef is_on_line(a,b,c):\n    return 1 if (a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1])) == 0 else 0\n\ndef solve():\n    if n <= 4:\n        return 1\n    line1 = []\n    line2 = []\n    ok = 1\n    for i in range(n):\n        if not is_on_line(a[0],a[1],a[i]):\n            if len(line2) < 2:\n                line2.append(i)\n            else:\n                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])\n                if ok == 0:\n                    break\n    if ok:\n        return 1\n    line1 = []\n    line2 = []\n    ok = 1\n    for i in range(n):\n        if not is_on_line(a[0],a[2],a[i]):\n            if len(line2) < 2:\n                line2.append(i)\n            else:\n                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])\n                if ok == 0:\n                    break\n    if ok:\n        return 1\n    line1 = []\n    line2 = []\n    ok = 1\n    for i in range(n):\n        if not is_on_line(a[1],a[2],a[i]):\n            if len(line2) < 2:\n                line2.append(i)\n            else:\n                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])\n                if ok == 0:\n                    break\n    if ok:\n        return 1\n    return 0\n\nn, a = read_data()\nprint(\"Yes\" if solve() == 1 else \"No\")","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\ndef possible(x):\n    days=n-x\n    tot=days*(days+1)\/\/2\n\n    return tot-x<=k\n\nn,k=value()\n\nlow=0\nhigh=n\n\nwhile(low<=high):\n\n    mid=(low+high)\/\/2\n\n    if(possible(mid)):\n        high=mid-1\n    else:\n        low=mid+1\n\nprint(low)","output":"logn"},{"instruction":"from collections import Counter\nimport string\nimport math\nimport sys\n\nfrom fractions import Fraction\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\ndef vary(arrber_of_variables):\n    if arrber_of_variables==1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables>=2:\n        return map(int,sys.stdin.readline().split())\ndef makedict(var):\n    return dict(Counter(var))\ntestcases=1\nfor _ in range(testcases):\n    n=vary(1)\n    indices=array_int()\n    cost=array_int()\n    ans=float('inf')\n    mint=[]\n    for i in range(n):\n        ans=float('inf')\n        total=cost[i]\n        flag=0\n        for j in range(i):\n            if indices[i]>indices[j]:\n                ans=min(ans,cost[j])\n                flag=1\n        if flag!=0:\n            total+=ans\n            ans=float('inf')\n            flag=0\n            for k in range(i+1,n):\n                if indices[k]>indices[i]:\n                    ans=min(ans,cost[k])\n                    flag=1\n            if flag!=0:\n                total+=ans\n                mint.append(total)\n            else:\n                continue\n        else:\n            continue\n    if len(mint)>0:\n        print(min(mint))\n    else:\n        print(-1)","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\n\nvert=[]\n\nfor i in range(n):\n    v=int(input())\n    vert.append(v)\n\nhorz=[]\n\nfor i in range(m):\n    x1,x2,y=map(int,input().split())\n    if x1==1:\n        horz.append(x2)\n\nvert.sort()\nhorz.sort()\n\nvert.append(1000000000)\n\ndef next(k,a,x):\n    while k<len(a) and a[k]<x:\n        k+=1\n    return k\n\nnum=next(0,horz,vert[0])\n\nans=len(horz)-num\n\nfor i in range(1,len(vert)):\n    num2=next(num,horz,vert[i])\n    t=i+len(horz)-num2\n    if t<ans: ans=t\n    num=num2\n\nprint(ans)","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nl=list(map(int,input().split()))\np=[]\na=sorted(l)\nfor i in a:\n    if(i%k==0):\n        if(i\/\/k in p):\n            pass\n        else:\n            p.append(i)\n    else:\n        p.append(i)\nprint(len(set(p)))","output":"nlogn"},{"instruction":"def main():\n  N, M = map(int, input().split())\n  L = [tuple(map(int, input().split())) for _ in range(N)]\n  maxi = max(max(t) for t in L)+1\n  mini, res = max((min(t), i) for i, t in enumerate(L))\n  res = res, res\n  BITMASK = (1 << M)\n  while True:\n    mid = (maxi+mini)\/\/2\n\n    if mid == mini:\n      break\n    masks = [None]*BITMASK\n    for i, t in enumerate(L):\n      tmask = 0\n      for v in t:\n        tmask *= 2\n        if v >= mid:\n          tmask += 1\n      if masks[tmask] is not None:\n        continue\n      masks[tmask] = i\n      for k in range(BITMASK):\n        if masks[k] is not None and k | tmask == BITMASK-1:\n          res = masks[k], i\n          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))\n          break\n      else:\n        continue\n      break\n    else:\n      maxi = mid\n\n  print(res[0]+1, res[1]+1)\n\nmain()","output":"np"},{"instruction":"import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree1:\n    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None\n        self.right = None\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n\nn,m=map(int,input().split())\nl=[]\npm=2**m-1\nfor i in range(n):\n    l.append(list(map(int,input().split())))\ndef find (x):\n    s=set()\n    d=defaultdict(int)\n    for i in range(n):\n        a=\"\"\n        for j in range(m):\n            if l[i][j]>=x:\n                a+='1'\n            else:\n                a+='0'\n        d[int(a,2)]=i\n        s.add(int(a,2))\n    s=list(s)\n\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            if s[i]|s[j]==pm:\n                return [d[s[i]]+1,d[s[j]]+1]\n    return [-1,-1]\nst=0\nend=10**9\nans=(0,0)\nwhile(st<=end):\n    mid=(st+end)\/\/2\n    s=find(mid)\n    if s[0]!=-1:\n        ans=s\n        st=mid+1\n    else:\n        end=mid-1\nprint(*ans)","output":"np"},{"instruction":"n,m,k=[int(x) for x in input().split()]\nleft=[];right=[]\nfor i in range(n):\n    temp=[int(x) for x in input().split()]\n    left.append(temp)\nfor i in range(n-1):\n    temp=[int(x) for x in input().split()]\n    right.append(temp)\ndp_old=[[0 for x in range(m)] for x in range(n)]\nif k%2!=0:\n    for i in range(n):\n        print(*[-1 for x in range(m)])\nelse:\n    k\/\/=2\n    for k1 in range(k):\n        dp=[[0 for x in range(m)] for x in range(n)]\n        for row in range(n):\n            for col in range(m):\n                t=float(\"inf\")\n                if 0<col:\n                    t=min(t,dp_old[row][col-1]+2*left[row][col-1])\n                if m-1>col:\n                    t=min(t,dp_old[row][col+1]+2*left[row][col])\n                if 0<row:\n                    t=min(t,dp_old[row-1][col]+2*right[row-1][col])\n                if n-1>row:\n                    t=min(t,dp_old[row+1][col]+2*right[row][col])\n                dp[row][col]=t\n        for row in range(n):\n            for col in range(m):\n                dp_old[row][col]=dp[row][col]\n    for i in range(n):\n        print(*dp_old[i])","output":"cubic"},{"instruction":"import itertools\nn,l,r,x=map(int,input().split())\nproblems=[int(x) for x in input().split()]\nresult=0\nfor i in range(2,n+1):\n    for comb in itertools.combinations(problems,i):\n        summ = sum(comb)\n        mini = min(comb)\n        maxx = max(comb)\n        if l <= summ <=r and maxx-mini>=x:\n            result+=1\nprint(result)","output":"np"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda pair: pair[1])\n        prevEnd = intervals[0][1]\n        res = 0\n\n        for i in range(1, len(intervals)):\n            if prevEnd > intervals[i][0]:\n                res += 1\n            else:\n                prevEnd = intervals[i][1]\n\n        return res","output":"nlogn"},{"instruction":"n = int(input())\n\nL = list(map(int, input().split(\" \")))\nR = list(map(int, input().split(\" \")))\n\nLR = list(zip(L,R))\n\nindex_to_candies = {}\ncandy = n\n\nfor nn in range(n,0,-1):\n    if(len(index_to_candies) == n):\n        break\n\n    zero_index = []\n    for idx, (l,r) in enumerate(LR):\n        if (l,r) == (0,0) and not idx in index_to_candies:\n            index_to_candies[idx] = nn\n            zero_index.append(idx)\n\n    if len(zero_index) == 0:\n        print(\"NO\")\n        exit()\n\n    dec_left = 0\n    dec_right = len(zero_index)\n    zero_index_idx = 0\n\n    for idx, (l,r) in enumerate(LR):\n        if zero_index_idx < len(zero_index) and zero_index[zero_index_idx] == idx:\n\n            zero_index_idx += 1\n            dec_left += 1\n            dec_right -= 1\n\n        if (l,r) != (0,0):\n            LR[idx] = (l-dec_left,r-dec_right)\n            if LR[idx][0] < 0 or LR[idx][1] < 0:\n                print(\"NO\")\n                exit()\nprint(\"YES\")\nj = []\nfor i in range(n):\n    j.append(str(index_to_candies[i]))\nprint(\" \".join(j))","output":"quadratic"},{"instruction":"l, r = [{'0': 1, 'X': 0}[c] for cc in zip(input(), input()) for c in cc], 0\nfor i in range(0, len(l) - 3, 2):\n    s = 7 - sum(l[i:i + 4])\n    if s < 5:\n        r += 1\n        l[i:i + s] = [0] * s\nprint(r)","output":"constant"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import defaultdict as ddc\n\ndef main():\n    n, m, k = map(int,input().split())\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = ''\n            for j in range(k):\n                if i>>j&1:\n                    ans = ''.join([ans, s[j]])\n                else:\n                    ans = ''.join([ans, '_'])\n            Ans.add(ans)\n        return Ans\n\n    D = ddc(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    from collections import deque\n    def topological_sort(In, Out):\n\n        dq = deque()\n        L = []\n        for i, I in enumerate(In):\n            if not I:\n                dq.append(i)\n        while dq:\n            v = dq.popleft()\n            L.append(v)\n            for w in Out[v]:\n                In[w].remove(v)\n                if not In[w]:\n                    dq.append(w)\n        if len(L) < len(In):\n            return False\n        return L\n\n    T = topological_sort(In, Out)\n    if flag == 0 or not T:\n        print('NO')\n    else:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n\nmain()","output":"np"},{"instruction":"from math import factorial\n\ndef lol(n):\n    if n == 1:\n        yield [0]\n        yield [1]\n    else:\n        for p in lol(n - 1):\n            p.append(0)\n            yield p\n            p[-1] = 1\n            yield p\n            p.pop()\n\ndef sp(g1, g2, g3, f):\n    if g1 == 0:\n        if g2 == g3:\n            return 2\n        elif abs(g2 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g2 == 0:\n        if g1 == g3:\n            return 2\n        elif abs(g1 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g3 == 0:\n        if g2 == g1:\n            return 2\n        elif abs(g2 - g1) == 1:\n            return 1\n        else:\n            return 0\n    else:\n        if f == 1:\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return b + c\n        elif f == 2:\n            a = sp(g1 - 1, g2, g3, 1)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + c\n        elif f == 3:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            return a + b\n        else:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + b + c\n\nn, T = map(int, input().split())\nS = []\ncnt = 0\nM = 10 ** 9 + 7\nfor i in range(n):\n    S.append(list(map(int, input().split())))\nfor p in lol(n):\n    d = 0\n    g1, g2, g3 = 0, 0, 0\n    for i in range(n):\n        if p[i]:\n            d += S[i][0]\n            if S[i][1] == 1:\n                g1 += 1\n            elif S[i][1] == 2:\n                g2 += 1\n            elif S[i][1] == 3:\n                g3 += 1\n    if d == T:\n        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)\n        cnt %= M\nprint(cnt)","output":"np"},{"instruction":"ri,gi,bi=map(int,input().split())\nrr=sorted(list(map(int,input().split())))\ngr=sorted(list(map(int,input().split())))\nbr=sorted(list(map(int,input().split())))\ndp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]\ndef area(r,g,b):\n\tif dp[r+1][g+1][b+1]!=-1:\n\t\treturn dp[r+1][g+1][b+1]\n\tans=0\n\tif r>=0 and g>=0:\n\t\tans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))\n\tif r>=0 and b>=0:\n\t\tans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))\n\tif b>=0 and g>=0:\n\t\tans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))\n\tdp[r+1][g+1][b+1]=ans\n\treturn ans\nprint(area(ri-1,gi-1,bi-1))","output":"cubic"},{"instruction":"n,k = map(int,input().split())\ns = input()\nc=0\nfor i in range(len(s)):\n\tif s[:i]==s[-i:]:\n\t\tc=i\nprint(s+s[c:]*(k-1))","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\nboys = list(map(int, input().split()))\ngirls = list(map(int, input().split()))\nboys.sort(reverse=True)\ngirls.sort(reverse=True)\ns = sum(boys)\nma = max(boys)\n\nres = 0\nfor i in range(0, m):\n\n    if girls[i] < ma:\n        print(-1)\n        exit(0)\n    res += s\n    if (girls[i] == ma):\n        girls[i] = 0\nj = 0\nusage = 0\nfor i in range(0, m):\n    if (usage == m - 1):\n        j += 1\n    if (j >= n):\n        print(-1)\n        exit(0)\n\n    res += max(0, girls[i] - boys[j])\n    usage += 1\nprint(res)","output":"nlogn"},{"instruction":"s = input()\nk = []\nfor i in range(len(s)):\n    for j in range(i+1,len(s)+2):\n        x = s[i:j]\n        for t in range(i+1,len(s)):\n            if x == s[t:t+j-i]:\n                k += [j-i]\nprint(max(k) if k != [] else 0)","output":"cubic"},{"instruction":"import sys\n\nv, h = list(map(lambda x: int(x), sys.stdin.readline().split(' ')))\nvs = []\nhs = []\nfor i in range(v):\n\tvs.append(int(sys.stdin.readline()))\nvs.sort()\nvs.append(10 ** 9)\nfor i in range(h):\n\tx1, x2, y = list(map(lambda x: int(x), sys.stdin.readline().split(' ')))\n\tif x1 == 1:\n\t\ths.append([x1, x2, y])\n\ndef sort_x2(val):\n\treturn val[1]\n\nhs.sort(key=sort_x2)\n\nhsl = len(hs)\nvsl = len(vs)\n\nres = v + h\nhi = 0\nfor vi, v in enumerate(vs, start=0):\n\twhile hi < hsl and hs[hi][1] < v:\n\t\thi += 1\n\tres = min(res, vi + hsl - hi)\n\nprint(res)","output":"nlogn"},{"instruction":"def go():\n    n = int(input())\n    a = [i for i in input()]\n    x = 0\n    for i in a:\n        if i == '-':\n            x = max(0, x - 1)\n        else:\n            x += 1\n    return x\n\nprint(go())","output":"linear"},{"instruction":"def crear_intervalo(x,a):\n    lim_inf = x-a\/2\n    lim_sup = x+a\/2\n    intervalo = (lim_inf, lim_sup)\n    return intervalo\n\ndef calcular_posibles_posiciones(i1, i2, t):\n    espacio_disponible = i2[0] - i1[1]\n    espacio_sobrante = espacio_disponible - t\n    if espacio_sobrante > 0:\n        return 2\n    elif espacio_sobrante == 0:\n        return 1\n    else:\n        return 0\n\nintervalos = []\nposibilidades = 2\n\ndatos = input().split()\nn,t = int(datos[0]), int(datos[1])\n\nfor i in range(n):\n    casas = input().split()\n    x, a = int(casas[0]), int(casas[1])\n    intervalo = crear_intervalo(x,a)\n    intervalos.append(intervalo)\n\nintervalos.sort()\n\nfor i in range(n-1):\n    posibilidades = posibilidades + calcular_posibles_posiciones(intervalos[i], intervalos[i+1],t)\n\nprint(posibilidades)","output":"nlogn"},{"instruction":"from sys import stdin\ninput=stdin.readline\ndef answer():\n    dp=[[[1e9 for i in range(k\/\/2 + 1)] for j in range(m)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n\n    for x in range(1,k\/\/2 + 1):\n\n        for i in range(n):\n            for j in range(m):\n\n                if(i > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])\n                if(j > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])\n                if(i + 1 < n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])\n                if(j + 1 < m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j][-1],end=' ')\n\n        print()\n\nn,m,k=map(int,input().split())\n\nr=[list(map(int,input().split())) for i in range(n)]\nc=[list(map(int,input().split())) for i in range(n-1)]\n\nif(k & 1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=' ')\n\nelse:answer()","output":"cubic"},{"instruction":"import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ndef li(): return [int(i) for i in input().split()]\ndef lli(rows): return [li() for _ in range(rows)]\ndef si(): return input()\ndef ii(): return int(input())\ndef ins(): return input().split()\n\nn,m=MI()\nposf=(n*(n-1))\/\/2\nif(n%2!=0):\n    negf=(n\/\/2)*(n\/\/2+1)\nelse:\n    negf=(n\/\/2)*(n\/\/2-1)+n\/\/2\nans=0\nfor i in range(m):\n    x,d=MI()\n    ans+=n*x\n    if(d>=0):\n        ans+=posf*d\n    else:\n        ans+=negf*d\nprint(ans\/n)","output":"linear"},{"instruction":"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\nn,k=map(int,input().split())\nc=0\nfor i in range(len(l)-1):\n    if(l[i]+l[i+1]+1 in l and l[i]+l[i+1]+1<=n):\n        c+=1\nif(c>=k):\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    def intersection(l1,r1,l2,r2):\n        if l1>r2 or r1<l2:\n            return [0,0]\n        else:\n            return [max(l1,l2),min(r1,r2)]\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        pref=[]\n        suff=[]\n        z=[]\n        for i in range(n):\n            z.append(ria())\n\n        pix,piy=intersection(z[0][0],z[0][1],z[0][0],z[0][1])\n        six,siy=intersection(z[-1][0],z[-1][1],z[-1][0],z[-1][1])\n        for i in range(n):\n            pix,piy=intersection(pix,piy,z[i][0],z[i][1])\n            pref.append([pix,piy])\n        for i in range(n-1,-1,-1):\n            six,siy=intersection(six,siy,z[i][0],z[i][1])\n            suff.append([six,siy])\n        suff=suff[::-1]\n        ans=max(suff[1][1]-suff[1][0],pref[n-2][1]-pref[n-2][0])\n        for i in range(1,n-1):\n            intersect=intersection(pref[i-1][0],pref[i-1][1],suff[i+1][0],suff[i+1][1])\n            ans=max(ans,intersect[1]-intersect[0])\n\n        wi(ans)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"n,k=map(int, input().split())\na=list(map(int, input().split()))\ni=0\nd=0\nx=-1\ny=-1\ns=[0]*(10**5+1)\nfor j in range (len(a)):\n    s[a[j]]+=1\n    i+=1\n    if s[a[j]]==1:\n        d+=1\n    if i==1:\n        x=j+1\n    if d==k:\n        y=j+1\n        break\nwhile k!=1 and s[a[x-1]]-1!=0:\n    s[a[x-1]]-=1\n    x+=1\nif x==-1 or y==-1:\n    x=-1\n    y=-1\nprint(x,y)","output":"linear"},{"instruction":"from sys import stdin\n\ndef quadratic(a, b, c):\n    num = (b * b) - (4 * a * c)\n    if num >= 0:\n        return [(-b + (num ** .5)) \/ (2.0 * a), (-b - (num ** .5)) \/ (2.0 * a)]\n    else:\n        return [.5, .5]\n\nn, k = map(int, stdin.readline().split())\nfor root in quadratic(1, 3, -2 * n - 2 * k):\n    ans = n - root\n    if ans > -1:\n        print(int(ans))\n        exit()","output":"logn"},{"instruction":"from math import ceil\ndef main():\n    n=int(input())\n    a=list(map(int,input().split( )))\n    ans=10**6\n    value=10**9+7\n    for i in range(n):\n        t=ceil((a[i]-i)\/n)\n        tmp=i+n*t\n        if tmp<value:\n            value=tmp\n            ans=i+1\n    print(ans)\nmain()","output":"linear"},{"instruction":"def check(s,t1,t2):\n    s1 = len(t1)\n    s2 = len(t2)\n    n = len(s)\n    dp = [[-1] * (s1+1) for i in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(s1+1):\n            if dp[i][j] >= 0:\n                if  j < s1 and t1[j] == s[i]:\n                    dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j])\n                if dp[i][j] < s2 and t2[dp[i][j]] == s[i]:\n                    dp[i+1][j] = max(dp[i+1][j],dp[i][j]+1)\n            dp[i+1][j] = max(dp[i+1][j],dp[i][j])\n\n    if dp[n][s1] == s2:\n        return True\n    else:\n        return False\n\ndef solve():\n    s = input()\n    t = input()\n    le = len(t)\n\n    for i in range(le):\n        t1 = t[:i]\n        t2 = t[i:]\n        if check(s,t1,t2) == True:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nT = int(input())\nwhile T:\n    T -= 1\n    solve()","output":"cubic"},{"instruction":"n = list(map(int, input().split()))\nu = []\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu[0].sort(reverse=True)\nu[1].sort(reverse=True)\nu[2].sort(reverse=True)\nres = 0\ndp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]\nfor i in range(n[0]+1):\n    for j in range(n[1]+1):\n        for k in range(n[2]+1):\n            if i<n[0] and j<n[1]:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])\n            if j<n[1] and k<n[2]:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])\n            if i<n[0] and k<n[2]:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])\nres = max(x for u1 in dp for u2 in u1 for x in u2)\nprint(res)","output":"cubic"},{"instruction":"from math import gcd\n\ndef t_prime(n):\n    if n == 1:\n        return False\n    for p in [2,3,5,7,11,13,17,19,23]:\n        if p < n and pow(p,n-1,n) != 1:\n            return False\n    return True\n\nprimes = [i for i in range(2,10**5) if t_prime(i)]\npset = set(primes)\n\nn, k = map(int, input().split())\nl = list(map(int, input().split()))\n\nif k == 1:\n    print(0)\n    exit()\n\nfor i in range(n):\n    for j in range(i):\n        u, v = l[i], l[j]\n        poss = gcd(u,v)\n        poss2 = max(u,v)\/\/poss\n        smol = min(poss,poss2)\n        if t_prime(smol) and smol not in pset:\n            primes.append(smol)\n            pset.add(smol)\n\npowers = set()\n\ncount = 0\noutLs = []\npgood = []\nfor p in primes:\n    curr = []\n    fp = [v for v in l if v % p == 0]\n    for v in fp:\n        v2 = v\n        while v2 % p == 0:\n            v2 \/\/= p\n        if v2 == 1:\n            curr.append(v)\n            powers.add(v)\n    if len(curr) > 1:\n        count += len(curr)\n        outLs.append(curr)\n        pgood.append(p)\n\norder = [(len(lis), lis) for lis in outLs]\norder.sort(key = lambda x: x[0])\n\nif len(order) == 0:\n    print(0)\n    exit()\n\nif order[-1][0] == 2 and k % 2 and count > k:\n    extra = -1\n    need = -1\n    last = []\n\n    for v in l:\n        if v in powers:\n            continue\n\n        v2 = v\n        primesn = []\n        for p in pgood:\n            add = 1\n            while v2 % p == 0:\n                v2 \/\/= p\n                if add:\n                    primesn.append(p)\n                add = 0\n        if v2 == 1 and (need == -1 or need > len(primesn)):\n            extra = v\n            last = primesn\n            need = len(last)\n            assert need >= 2\n\n    if need == -1 or 2 * need + 1 > k:\n        print(0)\n        exit()\n\n    other = []\n    out = [extra]\n\n    for a,b in outLs:\n        works = False\n        for p in last:\n            if a % p == 0:\n                works = True\n                break\n        if works:\n            out.append(a)\n            out.append(b)\n        else:\n            other.append(a)\n            other.append(b)\n\n    assert len(out) == 2 * need + 1\n    assert (k - 2 * need - 1) % 2 == 0\n\n    ret = out + other[:(k - 2*need - 1)]\n    assert len(ret) == k\n\n    print(' '.join(map(str,ret)))\n    exit()\n\nout = []\nneed = k\nfor i in range(len(order)):\n    assert need != 1\n\n    lis = order[i][1]\n    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):\n        out += lis\n        need -= len(lis)\n    elif len(lis) == need - 1:\n        if len(lis) > 2:\n            out += lis[:-1]\n            need -= (len(lis) - 1)\n            assert need == 2\n    else:\n        out += lis[:need]\n        need = 0\n\nassert need + len(out) == k\nassert need >= 0\nassert need == 0 or len(out) == count\n\nfor v in l:\n    if need == 0:\n        break\n\n    if v in powers:\n        continue\n\n    v2 = v\n    for p in pgood:\n        while v2 % p == 0:\n            v2 \/\/= p\n    if v2 == 1:\n        out.append(v)\n        need -= 1\n\nif need == 0:\n    print(' '.join(map(str,out)))\n    exit()\nelse:\n    print(0)","output":"np"},{"instruction":"n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nfrom itertools import combinations\nways_to_choose = 0\nfor length in range(2, n + 1):\n    for p in combinations(c, length):\n        problemset = sorted(p)\n        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:\n            ways_to_choose += 1\n\nprint(ways_to_choose)","output":"np"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    if n==1:\n        return 0\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matridigit[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matridigit[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matridigit[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matridigit[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matridigit[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nN = int(input())\nA = li()\n\ndp = [[False for r in range(N)] for l in range(N)]\nfor l in range(N):\n    tmp = [A[l]]\n    dp[l][l] = True\n    for r in range(l+1,N):\n        val = A[r]\n        while tmp and tmp[-1]==val:\n            val = tmp[-1] + 1\n            tmp.pop()\n        tmp.append(val)\n        if len(tmp)==1:\n            dp[l][r] = True\n\nres = [i for i in range(N+1)]\nfor r in range(1,N+1):\n    for l in range(1,r+1):\n        if dp[l-1][r-1]:\n            res[r] = min(res[r],1+res[l-1])\n\nprint(res[N])","output":"cubic"},{"instruction":"n, m = map(int, input().split())\n\nfor i in range(n):\n    s = input()\n    left = s.find('B')\n    if left != -1:\n        right = s.rfind('B')\n        c = (right - left) \/\/ 2 + 1\n        print(i + c, left + c)\n        break","output":"quadratic"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nT, = getIntList()\n\ndef isin( x,y, M):\n    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:\n        return True\n    return False\n\nfor _ in range(T):\n    N, M = getIntList()\n    m1 = getIntList()\n    m2 = getIntList()\n    zx = [0, M]\n    zx += [m1[0]-1, m1[2]]\n    zx += [m2[0]-1, m2[2]]\n    zx.sort()\n    zy = [0, N]\n    zy += [m1[1]-1, m1[3]]\n    zy += [m2[1]-1, m2[3]]\n    zy.sort()\n    totB = 0\n    for i0 in range(5):\n        if zx[i0] == zx[i0+1]: continue\n        for i1 in range(5):\n            if zy[i1] == zy[i1+1]: continue\n\n            x0 = zx[i0]+1\n            y0 = zy[i1]+1\n            dprint('x0,y0', x0,y0)\n            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1])\n            if isin(x0,y0, m2):\n                dprint('black')\n                totB += size\n            elif isin(x0,y0, m1):\n                dprint('white')\n                pass\n            else:\n                totB+= size\/\/2\n                if size%2==1:\n                    if (x0+y0)%2==1:\n                        dprint('extra black')\n                        totB+=1\n    print(N*M - totB, totB)","output":"constant"},{"instruction":"import math\nk, n, s, p = map(int, input().split())\nsheets = math.ceil(n\/s) * k\nprint(math.ceil(sheets\/p))\n","output":"constant"},{"instruction":"import sys, heapq\n\nn = int(sys.stdin.readline())\nkey = []\nfor i in ['S', 'M', 'L']:\n    for j in range(4):\n        key.append(j * 'X' + i)\nprev = dict().fromkeys(key, 0)\nnow = dict().fromkeys(key, 0)\nfor _ in range(n):\n    prev[sys.stdin.readline().rstrip()] += 1\nfor _ in range(n):\n    now[sys.stdin.readline().rstrip()] += 1\nfor i in key:\n    temp = min(prev[i], now[i])\n    prev[i] -= temp\n    now[i] -= temp\nans = 0\nfor i in key:\n    ans += now[i]\nprint(ans)","output":"linear"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):\n    print(\"NO\")\n    exit()\nres = [[0] * n for _ in range(n)]\nfor i in range(0, n - max(a, b)):\n    res[i][i + 1] = res[i + 1][i] = 1\nif a == 1:\n    res = [[e ^ 1 for e in l] for l in res ]\n\nprint(\"YES\")\nfor i in range(n):\n    res[i][i] = 0\n    print(*res[i], sep='')","output":"quadratic"},{"instruction":"n, s = map(int, input().strip().split())\n\nnum = ''\ndiv = 9\n\nif s\/\/10 != 0:\n\n    div = 9\n    while (s\/\/div)\/\/10 != 0:\n        div = div*10+9\n    while div:\n        rem = str(s\/\/div)\n        if int(rem) > 9:\n            num = str(int(num)+1) + '0'*len(str(div))\n            div = 0\n            s = 0\n            break\n        else:\n            num += rem\n        s = s%div\n        div \/\/= 10\n    num += str(s)\nelse:\n    num = str(s)\nmini = int(num)\nif mini%10 != 0:\n    mini += 10\n    mini -= mini%10\n\nprint(max(0, n-mini+1))","output":"logn"},{"instruction":"import math,sys,bisect,heapq,os\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n\nint1 = lambda x: int(x) - 1\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\ndef solve():\n\tG = defaultdict(list)\n\n\tdef addEdge(a,b):\n\t\tG[a].append(b)\n\n\tdef Kahn(N):\n\t    in_degree = [0]*(N+1)\n\t    for i in G.keys():\n\t        for j in G[i]:\n\t            in_degree[j] += 1\n\t    queue = deque()\n\t    for i in range(1,N+1):\n\t        if in_degree[i] == 0:\n\t            queue.append(i)\n\t    cnt =0\n\t    top_order = []\n\t    while queue:\n\t        u = queue.popleft()\n\t        top_order.append(u)\n\t        for i in G.get(u,[]):\n\t            in_degree[i] -= 1\n\t            if in_degree[i] == 0:\n\t                queue.append(i)\n\t        cnt += 1\n\t    if cnt != N:\n\t        Y(0);exit(0)\n\t    else:\n\t        Y(1);print(*top_order)\n\n\tn,m,k = aj()\n\tmark= {}\n\tfor i in range(n):\n\t\ts = input()\n\t\tmark[s] = i+1\n\n\tB = []\n\tfor i in range(2**k):\n\t\tf = bin(i)[2:]\n\t\tf = '0'*(k - len(f)) + f\n\t\tB.append(f)\n\n\tfor i in range(m):\n\t\ts,mt = input().split(\" \")\n\t\tmt = int(mt)\n\t\tst = set()\n\t\tfor j in B:\n\t\t\tss = ['']*k\n\t\t\tfor l in range(k):\n\t\t\t\tif j[l] == '1':\n\t\t\t\t\tss[l] = s[l]\n\t\t\t\telse:\n\t\t\t\t\tss[l] = '_'\n\t\t\tss = \"\".join(ss)\n\t\t\tif ss in mark:\n\t\t\t\tst.add(mark[ss])\n\n\t\tif mt not in st:\n\t\t\tY(0);exit(0)\n\t\tst.discard(mt)\n\t\tfor j in st:\n\t\t\taddEdge(mt,j)\n\n\tKahn(n)\n\ntry:\n\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nexcept:\n\tpass\n\nsolve()","output":"np"},{"instruction":"v = input().split()\nn = int(v[0])\nk = int(v[1])\n\ns = input()\nap = 0\n\ni = 1\nwhile i < n:\n    if s[:i] == s[-i:]:\n        ap = i\n\n    i += 1\n\nprint(s + s[ap:]*(k-1))","output":"quadratic"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\n\na,b,c=input().split()\n\ns=[]\np=[]\nm=[]\n\nif a[1]=='p':\n\tp.append(int(a[0]))\nelif a[1]=='s':\n\ts.append(int(a[0]))\nelse:\n\tm.append(int(a[0]))\n\nif b[1]=='p':\n\tp.append(int(b[0]))\nelif b[1]=='s':\n\ts.append(int(b[0]))\nelse:\n\tm.append(int(b[0]))\n\nif c[1]=='p':\n\tp.append(int(c[0]))\nelif c[1]=='s':\n\ts.append(int(c[0]))\nelse:\n\tm.append(int(c[0]))\n\ns.sort()\np.sort()\nm.sort()\n\ncur=2\nif len(s)==3:\n\tif s[0]==s[1] and s[1]==s[2]:\n\t\tcur=0\n\telif s[0]==s[1] or s[1]==s[2]:\n\t\tcur=1\n\telse:\n\t\tif s[0]+1==s[1] and s[1]+1==s[2]:\n\t\t\tcur=0\n\t\telif s[0]+1==s[1] or s[1]+1==s[2]:\n\t\t\tcur=1\n\t\telif s[0]+2==s[1] or s[1]+2==s[2]:\n\t\t\tcur=1\n\t\telse:\n\t\t\tcur=2\nelif len(s)==2:\n\tif s[0]==s[1]:\n\t\tcur=1\n\telif s[0]+1==s[1]:\n\t\tcur=1\n\telif s[0]+2==s[1]:\n\t\tcur=1\n\telse:\n\t\tcur=2\nelse:\n\tcur=2\n\nx=2\nif len(p)==3:\n\tif p[0]==p[1] and p[1]==p[2]:\n\t\tx=0\n\telif p[0]==p[1] or p[1]==p[2]:\n\t\tx=1\n\telse:\n\t\tif p[0]+1==p[1] and p[1]+1==p[2]:\n\t\t\tx=0\n\t\telif p[0]+1==p[1] or p[1]+1==p[2]:\n\t\t\tx=1\n\t\telif p[0]+2==p[1] or p[1]+2==p[2]:\n\t\t\tx=1\n\t\telse:\n\t\t\tx=2\nelif len(p)==2:\n\tif p[0]==p[1]:\n\t\tx=1\n\telif p[0]+1==p[1]:\n\t\tx=1\n\telif p[0]+2==p[1]:\n\t\tx=1\n\telse:\n\t\tx=2\nelse:\n\tx=2\n\ny=2\nif len(m)==3:\n\tif m[0]==m[1] and m[1]==m[2]:\n\t\ty=0\n\telif m[0]==m[1] or m[1]==m[2]:\n\t\ty=1\n\telse:\n\t\tif m[0]+1==m[1] and m[1]+1==m[2]:\n\t\t\ty=0\n\t\telif m[0]+1==m[1] or m[1]+1==m[2]:\n\t\t\ty=1\n\t\telif m[0]+2==m[1] or m[1]+2==m[2]:\n\t\t\ty=1\n\t\telse:\n\t\t\ty=2\nelif len(m)==2:\n\tif m[0]==m[1]:\n\t\ty=1\n\telif m[0]+1==m[1]:\n\t\ty=1\n\telif m[0]+2==m[1]:\n\t\ty=1\n\telse:\n\t\ty=2\nelse:\n\ty=2\n\nprint(min(cur,x,y))","output":"nlogn"},{"instruction":"import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\nfrom collections import defaultdict as dd\nfrom collections import deque\n\nflush = lambda: stdout.flush()\nstdstr = lambda: stdin.readline()\nstdint = lambda: int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdmap = lambda: map(int, stdstr().split())\nstdarr = lambda: list(map(int, stdstr().split()))\n\nmod = 1000000007\n\nn,m = stdmap()\narr =  stdarr()\n\nif(n > m):\n    print(0)\nelse:\n    c = Counter(arr)\n    d1 = list(sorted(c.values()))\n\n    days = 0\n    for i in range(1, 101):\n        br = False\n        d = d1.copy()\n\n        people = 0\n        done = False\n\n        while(1):\n            if(people >= n):\n\n                days = i\n                done = True\n                break\n            else:\n                if(len(d) == 0):\n                    break\n                curr = d[-1]\/\/i\n\n                d.pop()\n\n                people += curr\n\n        if(done):\n            days = i\n\n    print(days)","output":"nlogn"},{"instruction":"n = int(input())\nl = list( map( int, input().split() ) )\nans = max(l)\nfor i in range(n):\n    ans = min( ans, l[ i ] \/\/ max( i, n - i - 1 ))\nprint( ans )","output":"linear"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\n\nn=L()[0]\nif n<6:\n    print(-1)\nelse:\n    print(1,2)\n    print(1,3)\n    print(1,4)\n    for i in range(5,n+1):\n        print(2,i)\nfor i in range(1,n):\n    print(i,i+1)\n\nendtime = time.time()","output":"linear"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn = inp()\ns = []\nfor _ in range(4):\n    tmp = [input() for i in range(n)]\n    if _<3: input()\n    s.append(tmp)\nres = INF\nfor pt in itertools.combinations(range(4),2):\n    cnt = 0\n    for k in range(4):\n        f = 1 if k in pt else 0\n        for i in range(n):\n            for j in range(n):\n                if (i+j+f)%2 != int(s[k][i][j]): cnt += 1\n    res = min(res, cnt)\nprint(res)","output":"quadratic"},{"instruction":"import sys\ndef ask(x,y,rev):\n\tif (rev==0):\n\t\tprint(\"? %d %d\"%(x,y))\n\telse:\n\t\tprint(\"? %d %d\"%(y,x))\n\tsys.stdout.flush()\n\tif (rev==1):\n\t\treturn -int(input())\n\telse:\n\t\treturn int(input())\n\ncomp=ask(0,0,0)\nnowa=0\nnowb=0\nrev=0\nfor i in range(29,-1,-1):\n\tif (comp<0):\n\t\trev^=1\n\t\tnowa,nowb=nowb,nowa\n\t\tcomp=-comp\n\tif comp>=0:\n\t\tcomp=ask(nowa|(1<<i),nowb|(1<<i),rev)\n\t\tif (comp<0):\n\t\t\tnowa|=1<<i\n\t\t\tcomp=ask(nowa,nowb,rev)\n\t\telse:\n\t\t\ttmp=ask(nowa|(1<<i),nowb,rev)\n\t\t\tif (tmp<0):\n\t\t\t\tnowa|=1<<i\n\t\t\t\tnowb|=1<<i\nif (rev==1):\n\tnowa,nowb=nowb,nowa\nprint(\"! %d %d\"%(nowa,nowb))","output":"constant"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    inf = -float(\"inf\")\n    for _ in range(int(input())):\n        n,m = map(int,input().split())\n        a = [list(map(int,input().split())) for _ in range(n)]\n        y = 1<<n\n        dp = [[0]+[inf]*(y-1) for _ in range(m+1)]\n        for i in range(1,m+1):\n            for shift in range(n):\n                for mask1 in range(y):\n                    for mask2 in range(y):\n                        new = mask1^mask2\n                        if new&mask1:\n                            continue\n                        mm,add = 1,0\n                        for x in range(n):\n                            if mm&new:\n                                tt = x+shift\n                                if tt >= n:\n                                    tt -= n\n                                add += a[tt][i-1]\n                            mm <<= 1\n                        dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add)\n        print(dp[m][y-1])\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import math\nimport time\nfrom collections import defaultdict,deque,Counter\nfrom sys import stdin,stdout\nfrom bisect import bisect_left,bisect_right\nfrom queue import PriorityQueue\nimport sys\nt=1\n\nfor _ in range(t):\n    r,g,b=map(int,stdin.readline().split())\n    ra=list(map(int,stdin.readline().split()))\n    ga=list(map(int,stdin.readline().split()))\n    ba=list(map(int,stdin.readline().split()))\n    ra.sort()\n    ga.sort()\n    ba.sort()\n    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]\n    for i in range(r+1):\n        for j in range(g+1):\n            for k in range(b+1):\n                if(i and j>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])\n                if(i and k>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])\n                if(k and j>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])\n    print(dp[r][g][b])","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\n\nMIN=0\nMAX=n\n\nwhile True:\n    ANS=(MIN+MAX)\/\/2\n\n    if (n-ANS)*(n-ANS+1)\/\/2-ANS>k:\n        MIN=ANS+1\n    elif (n-ANS)*(n-ANS+1)\/\/2-ANS<k:\n        MAX=ANS-1\n    else:\n        print(ANS)\n        break","output":"logn"},{"instruction":"N = int(input())\nbeg = 0\nend = 9\ni = 0\n\nwhile N > end:\n    i += 1\n    beg, end = end, end + (i + 1) * 9 * 10**i\n\nn = N - beg - 1\nlvl = i - n % (i + 1)\nperiod = (i + 1) * 10**lvl\n\nres = n\/\/period % 10\nif lvl == i:\n    res += 1\nprint(res)","output":"logn"},{"instruction":"S = input()\nsLen, ans = len(S), 0\nfor i in range(sLen):\n    for till1 in range(i + 1, sLen):\n        till2 = till1 + 1\n        for j in range(i + 1, sLen):\n            if till2 > sLen:\n                break\n            sub1 = S[i:till1]\n            sub2 = S[j:till2]\n            subLen = len(sub1)\n            if sub1 == sub2 and ans < subLen:\n                ans = subLen\n            till2 += 1\n\nprint(ans)","output":"cubic"},{"instruction":"import sys\nimport string\n\nfrom collections import Counter, defaultdict\nfrom math import fsum, sqrt, gcd, ceil, factorial\nfrom operator import *\nfrom itertools import accumulate, count\n\ninf = float(\"inf\")\n\nflush = lambda: sys.stdout.flush\ncomb = lambda x, y: (factorial(x) \/\/ factorial(y)) \/\/ factorial(x - y)\n\nip = lambda: input()\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\narr = ip()\nn = len(arr)\nms = \"\"\nmn = 0\n\ndef counter(s, x):\n    p = len(x)\n    px = 0\n    for i in range(len(s)):\n        if s[i : i + p] == x:\n            px += 1\n\n    return px\n\nfor i in range(n):\n    s = \"\"\n    for j in range(i, n):\n        s += arr[j]\n        c = counter(arr, s)\n        if c > 1 and len(s) > mn:\n            ms = s\n            mn = len(s)\n\nprint(mn)","output":"cubic"},{"instruction":"allcolor=['purple','green','blue','orange','red','yellow']\nop=['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']\nn=int(input())\nipcolor=[]\nfor i in range(0,n):\n    color=input()\n    ipcolor.append(color)\ndiff=list(set(allcolor) - set(ipcolor))\nprint(len(diff))\nfor i in range(0,len(diff)):\n    print(op[allcolor.index(diff[i])])","output":"constant"},{"instruction":"def almost_difference():\n    n = int(input())\n    if n == 1:\n        return 0\n\n    dict_equal = dict()\n    array = [int(el) for el in input().split()]\n    ad_sum = 0\n    prev_sum = 0\n    for i in range(n):\n        if not array[i] in dict_equal.keys():\n            dict_equal[array[i]] = 0\n        if not array[i]-1 in dict_equal.keys():\n            dict_equal[array[i]-1] = 0\n        if not array[i]+1 in dict_equal.keys():\n            dict_equal[array[i]+1] = 0\n\n        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]\n        dict_equal[array[i]] += 1\n        prev_sum += array[i]\n\n    return ad_sum\n\nprint(almost_difference())","output":"nlogn"},{"instruction":"def rotate_90(a):\n    b=[]\n    for x in range(len(a)):\n        l=[]\n        for y in range(len(a)-1,-1,-1):\n            l.append(a[y][x])\n        b.append(l)\n    return b\ndef flip(a):\n    b=[]\n    for x in range(len(a)):\n        l=[]\n        for y in range(len(a)-1,-1,-1):\n            l.append(a[x][y])\n        b.append(l)\n    return b\nn=int(input())\nl=[]\nfor i in range(n):\n    a=input()\n    l2=[]\n    for i2 in a:\n        l2.append(i2)\n    l.append(l2)\nl2=[]\nfor i in range(n):\n    a=input()\n    l3=[]\n    for i2 in a:\n        l3.append(i2)\n    l2.append(l3)\nd='no'\nfor i in range(4):\n    l = rotate_90(l)\n    if l==l2:\n        d='yes'\nl=flip(l)\nfor i in range(4):\n    l = rotate_90(l)\n    if l==l2:\n        d='yes'\nprint(d)","output":"quadratic"},{"instruction":"import itertools\n\nn, k = [int(i) for i in input().split()]\n\nkas = [[0,0,0,0],[1,0,0,1],[0,1,1,0]]\n\nmmm = 998244353\n\ndef count_k(ka, k, t):\n    if t == 0:\n        return ka[k][0] + ka[k][1] + ka[k][2] + ka[k-1][3]\n    if t == 1:\n        return ka[k-1][0] + ka[k][1] + ka[k-2][2] + ka[k-1][3]\n    if t == 2:\n        return ka[k-1][0] + ka[k-2][1] + ka[k][2] + ka[k-1][3]\n    if t == 3:\n        return ka[k-1][0] + ka[k][1] + ka[k][2] + ka[k][3]\n\nfor i in range(1, n):\n    if len(kas) < k + 1:\n        kas.append([0,0,0,0])\n        kas.append([0,0,0,0])\n    for kk in range(min(len(kas)-1, k), 1, -1):\n        kas[kk] = [count_k(kas, kk, t) % mmm for t in range(4)]\n\nprint(sum(kas[k]) % mmm if k < len(kas) else 0)","output":"np"},{"instruction":"import sys\nimport math\nimport bisect\nimport heapq\nfrom bisect import bisect_right\nfrom sys import stdin, stdout\n\ndef get_ints_in_variables(): return map(\n    int, sys.stdin.readline().strip().split())\n\ndef get_int(): return int(sys.stdin.readline())\n\ndef get_ints_in_list(): return list(\n    map(int, sys.stdin.readline().strip().split()))\ndef get_list_of_list(n): return [list(\n    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\ndef get_string(): return sys.stdin.readline().strip()\n\ndef myceil(x, y): return (x + y - 1) \/\/ y\n\ndef Solution(td, n, k):\n\n    mxHeap = []\n    td = sorted(td, key=lambda x: x[0])\n    prefix = []\n    tmp = 0\n    for v in td:\n        b = v[1]\n        tmpAns = tmp+b\n        if len(mxHeap) == k:\n            if len(mxHeap) and b > mxHeap[0]:\n                t = heapq.heappop(mxHeap)\n                heapq.heappush(mxHeap, b)\n                tmp -= t\n                tmp += b\n        elif len(mxHeap) < k:\n            tmp += b\n            heapq.heappush(mxHeap, b)\n        prefix.append([tmpAns, v[2]])\n\n    ans = [0 for _ in range(n)]\n    for v in prefix:\n        ans[v[1]] = v[0]\n    print(*ans)\n\ndef main():\n\n    n, k = get_ints_in_variables()\n    a = get_ints_in_list()\n    b = get_ints_in_list()\n    td = [[a[i], b[i], i] for i in range(n)]\n    Solution(td, n, k)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"s = input()\nans = 0\nfor i in range(len(s)):\n    for j in range(i + 1, len(s)):\n        cur = s[i:j]\n        if cur in s[:(j - 1)] or cur in s[(i + 1):]:\n            ans = max(ans, j - i)\nprint(ans)","output":"cubic"},{"instruction":"n = int(input())\n*a, = map(int, input().split())\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(n - i + 1):\n        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]\nfor i in range(1, n):\n    for j in range(n - i):\n        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])\nfor i in range(int(input())):\n    l, r = map(int, input().split())\n    print(dp[r - l][l - 1])","output":"quadratic"},{"instruction":"def f(x):\n\tdig, cnt = 1, 9\n\tans = 0\n\twhile dig != len(str(x)):\n\t\tans += dig * cnt\n\t\tdig += 1\n\t\tcnt *= 10\n\tans += (x - (cnt \/\/ 9) + 1) * dig\n\treturn ans\nk = int(input())\nl, r = 1, 1000000000000\nif k == 1:\n    print(1)\n    exit(0)\nwhile l < r:\n\tmid = (l + r + 1) >> 1\n\tif f(mid) < k:\n\t\tl = mid\n\telse:\n\t\tr = mid - 1\nk -= f(l)\nl += 1\nprint(str(l)[k - 1])","output":"logn"},{"instruction":"import sys;input=sys.stdin.readline\n\ndef solve():\n    n, l, r, x = map(int,input().split())\n    lis = list(map(int,input().split()))\n    lis = sorted(lis)\n    dp = [0]\n    dp_low = [0]\n    dp_high = [0]\n    for i in range(len(lis)):\n        for j in range(len(dp)):\n            if dp_low[j]==0:\n                dp_low.append(lis[i])\n            else:\n                dp_low.append(dp_low[j])\n            dp_high.append(lis[i])\n            dp = dp+[dp[j]+lis[i]]\n    count = 0\n    for i in range(len(dp)):\n        if dp[i]>=l and dp[i]<=r and dp_high[i]-dp_low[i]>=x:\n            count+=1\n    print(count)\n\nsolve()","output":"np"},{"instruction":"def normal_sum(N):\n\treturn (N ** 2 + N) \/\/ 2\n\ndef sum(i, j):\n\n\treturn normal_sum(j) - 1 - (normal_sum(i-1) - 1)\n\ndef bs_sum(start, end, k, n):\n\n\tmid = (start+end) \/\/ 2\n\n\tif(n - sum(mid, k) >= mid):\n\t\treturn bs_sum(start, mid - 1, k, n)\n\tif(n - sum(mid, k) < 0):\n\t\treturn bs_sum(mid+1, end, k, n)\n\n\treturn k-mid+2 if (n - sum(mid, k)) != 0 else k-mid+1\n\nn, k = [int(n) for n in input().split()]\nif (n == 1):\n\tprint( 0 )\nelif n <= k :\n\tprint( 1 )\nelif normal_sum(k) - 1 - (k-2) < n:\n\tprint( -1 )\nelse:\n\tn-=1\n\tk-=1\n\n\tanswer = (bs_sum(1, k, k, n))\n\tprint(answer)","output":"logn"},{"instruction":"a,b = map(int,input().split())\nif a == b:\n    print(0)\n    exit()\n\ne1 = bin(a)[2:]\ne2 = bin(b)[2:]\ndiff = len(e2)-len(e1)\ne1 = (\"0\"*diff)+e1\ne1 = e1[::-1]\ne2 = e2[::-1]\nans = [\"0\"]*len(e2)\nfor i in range(len(e2)):\n    if b-a >= 2**i:\n        ans[i] = \"1\"\n\n    else:\n        if int(e1[i])^int(e2[i]) == 1:\n            ans[i] = \"1\"\n\nprint(int(\"\".join(ans[::-1]),2))","output":"logn"},{"instruction":"def find(curr_pos, max_pos, curr_s, choose):\n    if curr_pos == 0:\n        if curr_s <= 0:\n            return True\n        else:\n            return False\n    if curr_pos == max_pos:\n        low = 1\n    else:\n        low = 0\n    high = 9\n    for d in range(low, high + 1):\n        curr_val = d * (10 ** curr_pos -  1)\n        if curr_val + p[curr_pos - 1] < curr_s:\n            continue\n        choose[curr_pos] = d\n        return find(curr_pos - 1, max_pos, curr_s - curr_val, choose)\n    return False\n\nn, s = map(int, input().split())\np = [0]\nfor i in range(1, 19):\n    p.append(p[-1] + 9 * (10 ** i - 1))\nchoose = [0] * 19\nans = n + 1\nfor num_digit in range(1, 19):\n    for i in range(1, num_digit + 1):\n        choose[i] = 0\n    if find(num_digit, num_digit, s, choose):\n        res = 0\n        for i in range(num_digit, -1, -1):\n            res = res * 10 + choose[i]\n        ans = min(ans, res)\n        break\nprint(n - ans + 1)","output":"logn"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = MDArray([total_nodes, k+2], -1)\n\n  for i in range(n*m):\n    dp.set((i, 0), 0)\n  for t in range(1, k\/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))\n      dp.set((i, t), ans)\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp.get((node, k\/2)) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"n=int(input())\nprint((n\/\/2)+1)","output":"constant"},{"instruction":"n=int(input())\nl=[]\nfor i in range(n):\n    s=str(input())\n    l.append(s)\nprint(6-n)\nif \"purple\" not in l:\n    print(\"Power\")\nif \"green\" not in l:\n    print(\"Time\")\nif \"red\" not in l:\n    print(\"Reality\")\nif \"blue\" not in l:\n    print(\"Space\")\nif \"orange\" not in l:\n    print(\"Soul\")\nif \"yellow\" not in l:\n    print(\"Mind\")","output":"constant"},{"instruction":"def smallest(d):\n    out = \"\"\n    for j in range(0, 10):\n        out += (\"%d\" % j)*d[j]\n    return out\n\ndef largest(d):\n    out = \"\"\n    for j in range(9, -1, -1):\n        out += (\"%d\" % j)*d[j]\n    return out\n\nsa = input()\nsb = input()\nb = int(sb)\n\nh = int(sa)\ndigits_a = [0]*10\nwhile h > 0:\n    digits_a[h % 10] += 1\n    h \/\/= 10\n\nout = \"\"\nif len(sb) > len(sa):\n    print(largest(digits_a))\n    exit()\n\nout = 0\nfor i in range(len(sa)-1, -1, -1):\n    for j in range(9, -1, -1):\n        if digits_a[j] == 0:\n            continue\n\n        if j < (b % (10 ** (i+1))) \/\/ (10 ** i):\n            digits_a[j] -= 1\n            if out > 0:\n                print(\"{}{}{}\".format(out, j, largest(digits_a)))\n                exit()\n            else:\n                print(\"{}{}\".format(j, largest(digits_a)))\n                exit()\n\n        if j == (b % (10 ** (i+1))) \/\/ (10 ** i):\n            if i == 0:\n                out = 10*out + j\n                print(out)\n                exit()\n            digits_a[j] -= 1\n            if int(smallest(digits_a)) <= b % (10 ** i):\n                out = 10*out + j\n                break\n            else:\n                digits_a[j] += 1\n\nprint(out)","output":"cubic"},{"instruction":"ans=[\"sjfnb\",\"cslnb\"]\nn=int(input())\nl=list(map(int,input().split()))\nl.sort()\nd=set()\ne=0\ns=0\nfor i in range(n):\n    if l[i] in d:\n        e+=1\n        s=l[i]\n    d.add(l[i])\nif e>1 or l.count(0)>1 or s-1 in d:\n    print(ans[1])\n\nelse:\n    l=[l[i]-i for i in range(n)]\n\n    print(ans[1-sum(l)%2])","output":"nlogn"},{"instruction":"fact=[1]\ntemp=1\nMOD=10**9+7\nfor i in range(1,10**5+5):\n    temp*=i\n    temp%=MOD\n    fact+=[temp]\ndef bino(a,b):\n    up=fact[a]\n    down=pow(fact[b]*fact[a-b],MOD-2,MOD)\n    return (up*down)%MOD\n\ndef find(A):\n    MOD=10**9+7\n\n    dp=[0]*(10**5+2)\n    for x in A:\n        dp[x]+=1\n    for i in range(2,len(dp)):\n        for j in range(2,len(dp)):\n            if i*j>len(dp)-1:\n                break\n            dp[i]+=dp[i*j]\n    for i in range(2,len(dp)):\n        dp[i]=(pow(2,dp[i],MOD)-1)%MOD\n\n    for i in range(len(dp)-1,1,-1):\n        for j in range(2,len(dp)):\n            if i*j>=len(dp):\n                break\n            dp[i]-=dp[i*j]\n            dp[i]%=MOD\n\n    ans=0\n    for i in range(2,len(dp)):\n        ans+=dp[i]\n        ans%=MOD\n\n    return (pow(2,len(A),MOD)-ans-1)%MOD\ninput()\nprint(find(list(map(int,input().strip().split(' ')))))","output":"np"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\nb = [0 for i in range(1<<20)]\nfor i in range(n):\n  b[a[i]] += 1\nfor i in range(20):\n  for j in range(1<<20):\n    if j&1<<i == 0:\n      b[j] += b[j|1<<i]\nans = 0\nfor i in range(1<<20):\n  cnt = str(bin(i)).count(\"1\")\n  if cnt%2 == 0:\n    ans += pow(2,b[i],mod)-1\n  else:\n    ans -= pow(2,b[i],mod)-1\n  ans %= mod\nprint(ans)","output":"np"},{"instruction":"n=int(input())\n\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ns=[0]*n\n\nans=True\n\nfor i in range(n):\n    ans=ans and a[i]<=i and b[i]<=(n-i-1)\n    s[i]=n-a[i]-b[i]\n\ndef qwe(s,j):\n    l,r=0,0\n    for i in range(len(s)):\n        if i<j and s[i]>s[j]: l+=1\n        elif i>j and s[i]>s[j]: r+=1\n    return l,r\n\nif ans:\n    for i in range(n):\n        l,r=qwe(s,i)\n        ans=ans and a[i]==l and b[i]==r\n\nif ans:\n    print('YES')\n    for i in range(n):\n        print(n-a[i]-b[i],end=' ')\nelse: print('NO')","output":"quadratic"},{"instruction":"def parse():\n    s, i = input().split()\n    i = int(i) - 1\n    return s, i\n\ndef match(p, s):\n    for a, b in zip(p, s):\n        if a != '_' and a != b:\n            return False\n    return True\n\ndef main():\n    from itertools import product\n\n    n, m, k = [int(t) for t in input().split()]\n    P = [input() for _ in range(n)]\n    S = [parse() for _ in range(m)]\n\n    index_of = dict()\n    for i, p in enumerate(P):\n        index_of[p] = i\n\n    G = [[] for _ in range(n)]\n    for s, i in S:\n        if not match(P[i], s):\n            print(\"NO\")\n            return\n\n        for mask in product(range(2), repeat=k):\n            sp = ['_' if bit else c for bit, c in zip(mask, s)]\n            sp = ''.join(sp)\n\n            try:\n                j = index_of[sp]\n                if i != j:\n                    G[i].append(j)\n            except:\n                pass\n\n    tp = toposort(G)\n    if tp is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*[x+1 for x in tp])\n\ndef toposort(graph):\n    res, found = [], [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\nimport sys, os, io\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nstdout = io.BytesIO()\nsys.stdout.write = lambda s: stdout.write(s.encode(\"ascii\"))\n\nmain()\n\nos.write(1, stdout.getvalue())","output":"np"},{"instruction":"s1, s2 = [str(j) for j in input().split()]\noutput = s1 + s2\nfor j in range(len(s1)):\n    s = s1[:j + 1]\n    for k in range(len(s2)):\n        s += s2[k]\n        if sorted([s, output])[0] == s:\n            output = s\nprint(output)","output":"linear"},{"instruction":"from sys import stdin\ninp = lambda : stdin.readline().strip()\n\nnr, ng, nb = [int(x) for x in inp().split()]\n\nr = [int(x) for x in inp().split()]\ng = [int(x) for x in inp().split()]\nb = [int(x) for x in inp().split()]\nr.sort()\ng.sort()\nb.sort()\ndp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]\nfor i in range(nr+1):\n    for j in range(ng+1):\n        for k in range(nb+1):\n            if i and j:\n                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);\n            if i and k:\n                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);\n            if j and k:\n                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);\n\nprint(dp[nr][ng][nb])","output":"cubic"},{"instruction":"n,k = list(map(int,input().split()))\nlimit = 998244353\n\nif k > 2*n:\n    print(0)\nelif k == 1 or k == 2*n:\n    print(2)\nelse:\n    same = [0] * (k+1)\n    same[1] = 2\n\n    diff = [0] * (k+1)\n    diff[2] = 2\n\n    for i in range(2, n+1):\n        for j in range(min(k, 2*i), 1, -1):\n\n            same[j] = same[j] + 2*diff[j] + same[j-1]\n            same[j] %= limit\n\n            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]\n            diff[j] %= limit\n\n    print((same[k] + diff[k]) % limit)","output":"np"},{"instruction":"def s(n):\n    return (n*(n+1))\/\/2\n\ndef diff(st,en):\n    return s(en) - s(st-1)\n\ndef bs(k,n):\n    st = 1\n    en = k\n    while(st < en):\n        mid = (st+en)\/\/2\n        sum = diff(mid,k)\n        if sum == n:\n             return k-mid+1\n        if sum > n:\n            st = mid+1\n        else:\n            en = mid\n    return k-st+2\n\nif __name__ == '__main__':\n   n,k = map(int,input().split())\n   if n == 1:\n       print(0)\n   elif n <= k:\n       print(1)\n   else:\n       n-=1\n       k-=1\n       if s(k) < n:\n            print(-1)\n       else:\n           print(bs(k,n))","output":"logn"},{"instruction":"k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)\/\/i)+10**(i-1))[(k-r)%i]\nprint(ans)","output":"constant"},{"instruction":"import sys\nn,a,b = list(map(int, input().split()))\n\nif a>1 and b>1:\n\tprint('NO')\n\tsys.exit(0)\n\nif n==3 and a==1 and b==1:\n\tprint('NO')\n\tsys.exit(0)\n\nif n==2 and a==1 and b==1:\n\tprint('NO')\n\tsys.exit(0)\n\nt = [[0 for i in range(n)] for j in range(n)]\n\ncomp = max(a,b)\n\nfor i in range(comp-1, n-1):\n\tt[i][i+1] = 1\n\tt[i+1][i] = 1\n\nif b>1:\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif i!=j:\n\t\t\t\tt[i][j] = 1-t[i][j]\nprint('YES')\nfor i in range(n):\n\tprint(\"\".join(map(str, t[i])))","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\ndef main():\n\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    d={}\n    if n==1:\n        print('YES')\n        return\n    vis=[0]*n\n    for i in range(1,n):\n        num=abs(a[i][1]-a[0][1])\n        den=abs(a[i][0]-a[0][0])\n        k=1\n        k=gcd(num, den)\n        num\/\/=k\n        den\/\/=k\n        if ((a[i][1]-a[0][1])*(a[i][0]-a[0][0]))<0:\n            num*=-1\n        if (num, den) in d:\n            d[(num, den)].append(i)\n        else:\n            d[(num, den)]=[i]\n    maxx=0\n\n    for i in d.keys():\n        if len(d[i])>maxx:\n            maxx=len(d[i])\n            ki=i\n    vis[0]=1\n    for i in d[ki]:\n        vis[i]=1\n    t=[]\n    for i in range(n):\n        if not vis[i]:\n            t.append(i)\n    f=1\n    if len(t)>1:\n        num=abs(a[t[0]][1]-a[t[1]][1])\n        den=abs(a[t[0]][0]-a[t[1]][0])\n        k = 1\n        k=gcd(num, den)\n        num\/\/=k\n        den\/\/=k\n        if (a[t[0]][1]-a[t[1]][1])*(a[t[0]][0]-a[t[1]][0])<0:\n            num*=-1\n        m=(num, den)\n        for i in range(2, len(t)):\n            num = abs(a[t[i]][1] - a[t[0]][1])\n            den = abs(a[t[i]][0] - a[t[0]][0])\n            k=gcd(num, den)\n            num \/\/= k\n            den \/\/= k\n            if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:\n                num *= -1\n            if (num,den)!=m:\n                f=0\n    if f:\n        print('YES')\n    else:\n        d = {}\n        if n == 1:\n            print('YES')\n            return\n        vis = [0] * n\n        a[0], a[1]=a[1], a[0]\n        for i in range(1, n):\n            num = abs(a[i][1] - a[0][1])\n            den = abs(a[i][0] - a[0][0])\n            k = 1\n            k = gcd(num, den)\n            num \/\/= k\n            den \/\/= k\n            if ((a[i][1] - a[0][1]) * (a[i][0] - a[0][0])) < 0:\n                num *= -1\n            if (num, den) in d:\n                d[(num, den)].append(i)\n            else:\n                d[(num, den)] = [i]\n        maxx = 0\n\n        for i in d.keys():\n            if len(d[i]) > maxx:\n                maxx = len(d[i])\n                ki = i\n        vis[0] = 1\n        for i in d[ki]:\n            vis[i] = 1\n        t = []\n        for i in range(n):\n            if not vis[i]:\n                t.append(i)\n        f = 1\n        if len(t) > 1:\n            num = abs(a[t[0]][1] - a[t[1]][1])\n            den = abs(a[t[0]][0] - a[t[1]][0])\n            k = 1\n            k=gcd(num, den)\n            num \/\/= k\n            den \/\/= k\n            if (a[t[0]][1] - a[t[1]][1]) * (a[t[0]][0] - a[t[1]][0]) < 0:\n                num *= -1\n            m = (num, den)\n            for i in range(2, len(t)):\n                num = abs(a[t[i]][1] - a[t[0]][1])\n                den = abs(a[t[i]][0] - a[t[0]][0])\n                k = 1\n                k=gcd(num, den)\n                num \/\/= k\n                den \/\/= k\n                if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:\n                    num *= -1\n                if (num, den) != m:\n                    f = 0\n        if f:\n            print('YES')\n        else:\n            print('NO')\n\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"import math\nimport sys\n\ndef minPut(n):\n    return math.ceil((-1 + math.sqrt(1-4*(-n*2))) \/ 2)\ndef nCandies(n):\n    return int(n*(n+1)\/2)\n\nactions, candies = map(int, sys.stdin.readline().split())\n\nput = minPut(candies)\nputCandies = nCandies(put)\n\neat = putCandies - candies\n\nwhile put + eat < actions:\n    eat += put + 1\n    put += 1\n\nprint(eat)","output":"logn"},{"instruction":"import sys\n\nn = sys.stdin.readline()\nn = int(n)\ndef get_graph(n):\n    graph = []\n    for _ in range(n):\n        entries = list(map(lambda x : int(x), sys.stdin.readline().split(\" \")[1:]))\n        graph.append(entries)\n    return graph\n\ndef chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):\n    mask = 2**bucket_num\n    mem = []\n    buckets_seen = set({bucket_num})\n\n    og_bucket = bucket_num\n    og_val = val\n    for _ in range(len(buckets)):\n        rem = target - sum_bucket[bucket_num] + val\n        if rem not in reverse_bucket:\n            return None, []\n\n        new_bucket = reverse_bucket[rem]\n        if new_bucket == og_bucket and rem != og_val:\n            return None, []\n        elif new_bucket == og_bucket and rem == og_val:\n            mem.append((rem, bucket_num))\n            return mask | 2**new_bucket, mem\n        elif new_bucket in buckets_seen:\n            return None, []\n\n        buckets_seen.add(new_bucket)\n        mask = mask | 2**new_bucket\n\n        mem.append((rem, bucket_num))\n        bucket_num = new_bucket\n        val = rem\n    return None, []\n\ndef helper(chains, mask, mem):\n    if mask == 0:\n        return []\n    if mask in mem:\n        return mem[mask]\n\n    for i, chain in enumerate(chains):\n        if (mask >> i) & 0:\n            continue\n        for key in chain:\n            if key | mask != mask:\n                continue\n\n            future = helper(chains, ~key & mask, mem)\n            if future is not None:\n                mem[mask] = chain[key] + future\n                return mem[mask]\n    mem[mask] = None\n    return None\ndef solve(n):\n    buckets = get_graph(n)\n    reverse_bucket = {}\n    sum_bucket = [0]* len(buckets)\n    total_sum = 0\n    for i, bucket in enumerate(buckets):\n        for x in bucket:\n            total_sum += x\n            sum_bucket[i] += x\n            reverse_bucket[x] = i\n\n    target = total_sum \/ len(buckets)\n\n    chains = []\n    for i, bucket in enumerate(buckets):\n        seto = {}\n        for x in bucket:\n            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)\n            if key is not None:\n                seto[key] = val\n        chains.append(seto)\n    mem = {}\n    for i in range (2**len(buckets)-1):\n        helper(chains, i, mem)\n    return helper(chains, 2 ** len(buckets) - 1, mem), reverse_bucket\n\ndef result(n):\n    res, reverse_bucket = solve(n)\n    if res is None:\n        sys.stdout.write(\"No\\n\")\n    else:\n        res = sorted(res, key = lambda x : reverse_bucket[x[0]])\n        sys.stdout.write(\"Yes\\n\")\n        for x, y in res:\n            x = int(x)\n            y = int(y) + 1\n            stuff = \" \".join([str(x), str(y), \"\\n\"])\n            sys.stdout.write(stuff)\nresult(n)","output":"np"},{"instruction":"n = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif (bx > ax, by > ay) != (cx > ax, cy > ay):\n    print(\"NO\")\n    exit(0)\n\nprint(\"YES\")","output":"constant"},{"instruction":"n,m,k = list(map(int,input().split()))\na = list(map(int,input().split()))\ndp = [[float('-inf')]*m for i in range(n)]\ndp[0][0] = a[0]\nfor i in range(1,n):\n    for j in range(1,m):\n        dp[i][j] = dp[i-1][j-1] + a[i]\n    dp[i][0] = max(dp[i-1][m-1]-k, 0)+a[i]\n\nprint(max(max([max(x) for x in dp])-k,0))","output":"quadratic"},{"instruction":"def solve():\n\tc,d = 0,0\n\tprint(\"?\",c,d,flush=True)\n\tans = int(input())\n\tif ans==0:\n\n\t\tnum = 0\n\t\tfor i in range(29,-1,-1):\n\t\t\tc = 1<<i\n\t\t\td = 0\n\t\t\tprint(\"?\",c,d,flush=True)\n\t\t\tans =int(input())\n\t\t\tif ans ==-2:\n\t\t\t\treturn\n\t\t\tif ans == -1:\n\t\t\t\tnum+=(1<<i)\n\t\tprint(\"!\",num,num)\n\telse:\n\t\tl = [0,0]\n\t\tif ans == 1:\n\t\t\tcur = 0\n\t\telse:\n\t\t\tcur = 1\n\n\t\tprev = ans\n\n\t\tfor i in range(29,-1,-1):\n\t\t\ttc = c|(1<<i)\n\t\t\ttd = d|(1<<i)\n\t\t\tprint(\"?\",tc,td,flush=True)\n\t\t\tans = int(input())\n\t\t\tif ans ==-2:\n\t\t\t\treturn\n\t\t\tif ans ==0:\n\t\t\t\tbreak\n\t\t\tif ans !=prev:\n\t\t\t\tl[cur] += (1<<i)\n\t\t\t\tif cur ==0:\n\t\t\t\t\tc = tc\n\t\t\t\telse:\n\t\t\t\t\td = td\n\t\t\t\tprint(\"?\",c,d,flush=True)\n\t\t\t\ttemp = int(input())\n\t\t\t\tprev = temp\n\t\t\t\tif temp == 1:\n\t\t\t\t\tcur = 0\n\t\t\t\telse:\n\t\t\t\t\tcur = 1\n\t\tc = l[0]\n\t\td = l[1]\n\n\t\tfor i in range(29,-1,-1):\n\t\t\tif c&(1<<i) != 0 or d&(1<<i) !=0 :\n\t\t\t\tcontinue\n\t\t\ttc = c|(1<<i)\n\t\t\tprint(\"?\",tc,d,flush=True)\n\t\t\tans = int(input())\n\t\t\tif ans==-2:\n\t\t\t\treturn\n\t\t\tif ans==-1:\n\t\t\t\tl[0]|=(1<<i)\n\t\t\t\tl[1]|=(1<<i)\n\t\tprint(\"!\",l[0],l[1])\n\treturn\n\nt = 1\n\nwhile t>0:\n\tt-=1\n\tsolve()","output":"logn"},{"instruction":"import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\ntestcase=int(sys.stdin.readline())\nA=[list(map(int,input().split())) for i in range(testcase*2)]\n\nfor t in range(testcase):\n    counter=Counter(A[t*2+1])\n    LIST=[]\n    for c in counter:\n        if counter[c]>=4:\n            print(c,c,c,c)\n            break\n        elif counter[c]>=2:\n            LIST.append(c)\n    else:\n        LIST.sort()\n\n        ANS=[LIST[0],LIST[1],LIST[1]\/LIST[0]]\n        for i in range(2,len(LIST)):\n            if LIST[i]\/LIST[i-1]<ANS[2]:\n                ANS=[LIST[i-1],LIST[i],LIST[i]\/LIST[i-1]]\n\n        print(ANS[0],ANS[0],ANS[1],ANS[1])","output":"nlogn"},{"instruction":"from math import gcd\ndef t_prime(n):\n    if n == 1:        return False\n    for p in [2,3,5,7,11,13,17,19,23]:\n        if p < n and pow(p,n-1,n) != 1:            return False\n    return True\nprimes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))\nif k == 1: print(0);exit()\nfor i in range(n):\n    for j in range(i):\n        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)\/\/poss;smol = min(poss,poss2)\n        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)\npowers = set();count = 0;outLs = [];pgood = []\nfor p in primes:\n    curr = [];    fp = [v for v in l if v % p == 0]\n    for v in fp:\n        v2 = v\n        while v2 % p == 0:            v2 \/\/= p\n        if v2 == 1:   curr.append(v);   powers.add(v)\n    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)\n\norder = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])\n\nif len(order) == 0:    print(0); exit()\n\nif order[-1][0] == 2 and k % 2 and count > k:\n    extra = -1\n    need = -1\n    last = []\n\n    for v in l:\n        if v in powers:\n            continue\n\n        v2 = v\n        primesn = []\n        for p in pgood:\n            add = 1\n            while v2 % p == 0:\n                v2 \/\/= p\n                if add:\n                    primesn.append(p)\n                add = 0\n        if v2 == 1 and (need == -1 or need > len(primesn)):\n            extra = v\n            last = primesn\n            need = len(last)\n            assert need >= 2\n\n    if need == -1 or 2 * need + 1 > k:\n        print(0)\n        exit()\n\n    other = []\n    out = [extra]\n\n    for a,b in outLs:\n        works = False\n        for p in last:\n            if a % p == 0:\n                works = True\n                break\n        if works:\n            out.append(a)\n            out.append(b)\n        else:\n            other.append(a)\n            other.append(b)\n\n    assert len(out) == 2 * need + 1\n    assert (k - 2 * need - 1) % 2 == 0\n\n    ret = out + other[:(k - 2*need - 1)]\n    assert len(ret) == k\n\n    print(' '.join(map(str,ret)))\n    exit()\n\nout = []\nneed = k\nfor i in range(len(order)):\n    assert need != 1\n\n    lis = order[i][1]\n    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):\n        out += lis\n        need -= len(lis)\n    elif len(lis) == need - 1:\n        if len(lis) > 2:\n            out += lis[:-1]\n            need -= (len(lis) - 1)\n            assert need == 2\n    else:\n        out += lis[:need]\n        need = 0\n\nassert need + len(out) == k\nassert need >= 0\nassert need == 0 or len(out) == count\n\nfor v in l:\n    if need == 0:        break\n    if v in powers:        continue\n    v2 = v\n    for p in pgood:\n        while v2 % p == 0:            v2 \/\/= p\n    if v2 == 1:        out.append(v);        need -= 1\n\nif need == 0:\n    print(' '.join(map(str,out)))\n    exit()\nelse:\n    print(0)","output":"np"},{"instruction":"import sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\nORDA = 97\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) \/\/ math.gcd(a, b)\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=2):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n \/ i == i):\n                r.append(i)\n            else:\n                r.extend([i, n \/\/ i])\n    return r\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n \/\/= i\n        divs_number *= t\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number \/\/= base\n    return newnumber\ndef cdiv(n, k): return n \/\/ k + (n % k != 0)\n\ns = input()\nlens = len(s)\nmax_ = 0\nfor i in range(1, lens):\n    d = {}\n    for j in range(lens - i + 1):\n        if s[j: j + i] in d:\n            d[s[j: j + i]] += 1\n        else:\n            d[s[j: j + i]] = 1\n    maxd = max(d.values())\n    if max(d.values()) > 1:\n        max_ = i\nprint(max_)","output":"cubic"},{"instruction":"import math\nn=int(input())\ncolumns=list(map(int, input().rstrip().split()))\n\nmodcolumns=[i%2 for i in columns]\n\ntest=0\n\npreviouslist=[]\n\nfor i in range(0,n):\n    if len(previouslist)==0:\n        previouslist.append(modcolumns[i])\n\n    elif modcolumns[i]==previouslist[-1]:\n        previouslist.pop()\n\n    else:\n        previouslist.append(modcolumns[i])\n\nif len(previouslist)<=1:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]\nif abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\n\ndef second_largest(numbers):\n    count = 0\n    m1 = m2 = float('-inf')\n    for x in numbers:\n        count += 1\n        if x > m2:\n            if x >= m1:\n                m1, m2 = x, m1\n            else:\n                m2 = x\n    return m2 if count >= 2 else None\n\nn, m = map(int, input().split())\nboys = list(map(int, input().split()))\ngirls = list(map(int, input().split()))\nfirstMax = max(boys)\nsecondMax = second_largest(boys)\nminGrills = min(girls)\nminSum = 0\nif firstMax > minGrills:\n    print(-1)\n    sys.exit()\nelif firstMax == minGrills:\n    minSum = m * (sum(boys) - firstMax) + sum(girls)\nelif n == 1:\n    print(-1)\n    sys.exit()\nelse:\n    minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax\nprint(minSum)","output":"linear"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0\n\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            ans = max(ans, dp[i][j][k])\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\nprint(ans)","output":"cubic"},{"instruction":"import sys\nimport bisect\n\nl=input().split()\na=l[0]\nb=l[1]\np=[]\nfor i in range(len(a)):\n    for j in range(len(b)):\n        ok=a[:i+1]+b[:j+1]\n        p.append(ok)\nprint(min(p))","output":"linear"},{"instruction":"n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))","output":"quadratic"},{"instruction":"import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n\nn,k=nninp()\ns=ssinp()\nans=[]\nlb=k\/\/2\nrb=k\/\/2\nfor c in s:\n    if(lb>0):\n        if(c==\"(\"):\n            lb-=1\n        else:\n            rb-=1\n        ans.append(c)\n    elif(rb>0):\n        if(c==\")\"):\n            ans.append(c)\n            rb-=1\n    elif(lb==0 and rb==0):\n        break\np(lts(ans))","output":"linear"},{"instruction":"n = int(input())\n\nprint('0','0',n)","output":"constant"},{"instruction":"import sys, heapq\n\nn, x = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = dict().fromkeys(set(arr), 0)\nfor i in arr:\n    res[i] += 1\ncan = False\nfor i in res:\n    if res[i] >= 2:\n        can = True\n        break\nif can:\n    print(0)\nelse:\n    res = dict().fromkeys([i for i in range(max(arr) + 1)])\n    for i in res:\n        res[i] = []\n    for i in range(n):\n        temp = set()\n        now = arr[i]\n        cnt = 0\n        while True:\n            added = False\n            before = len(temp)\n            temp.add(now)\n            after = len(temp)\n            if before == after:\n                break\n            heapq.heappush(res[now], cnt)\n            now = now & x\n            cnt += 1\n    ans = 9876543210\n    for i in res:\n        if len(res[i]) >= 2:\n            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))\n    print(ans if ans != 9876543210 else -1)","output":"linear"},{"instruction":"n = int(input())\na = sorted(set(map(int, input().split())))\n\nif len(a) > 1:\n    x = iter(a)\n    next(x)\n    print(next(x))\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"import sys\nn = int(input())\n\na = list(map(int,input().split()))\n\nfor i in range(n):\n    a[i] = [i,a[i]]\n\na.sort(key=lambda x: x[1],reverse=True)\n\nans = []\n\nindex = 0\ncnt = 0\ntmp = 1\nright_bool = False\nleft_bool = False\n\nfor i in range(1,n):\n    if a[index][1] == 0:\n        print('NO')\n        sys.exit()\n    if a[i][1] >= 2:\n        ans.append([a[i-1][0],a[i][0]])\n        cnt += 1\n        a[i-1][1] -= 1\n        a[i][1] -= 1\n    else:\n        if right_bool == False:\n            ans.append([a[i-1][0],a[i][0]])\n            a[i-1][1] -= 1\n            a[i][1] -= 1\n            cnt += 1\n            right_bool = True\n        else:\n            ans.append([a[index][0],a[i][0]])\n            a[index][1] -= 1\n            a[i][1] -= 1\n            if left_bool == False:\n                cnt += 1\n                left_bool = True\n            if a[index][1] == 0:\n                index += 1\n\nprint('YES', cnt)\nprint(n-1)\nfor i in range(n-1):\n    print(ans[i][0]+1,ans[i][1]+1)","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\nfrom math import cos, sin\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmod = 10 ** 9 + 7\n\ndef ask(x, y):\n    print('?', x, y, flush=True)\n    return int(input())\n\na = b = 0\ncond = ask(a, b)\nfor i in range(29, -1, -1):\n    if cond:\n        x = a + (1 << i)\n        y = b + (1 << i)\n        n_cond = ask(x, y)\n        if cond == n_cond:\n            if cond == 1:\n                n_cond1 = ask(x, b)\n            else:\n                n_cond1 = ask(a, y)\n\n            if cond != n_cond1:\n                a = x\n                b = y\n\n        else:\n            if cond == 1:\n                a = x\n            else:\n                b = y\n            cond = ask(a, b)\n    else:\n        x = a + (1 << i)\n        y = b + (1 << i)\n        n_cond = ask(x, b)\n        if n_cond == -1:\n            a = x\n            b = y\nprint('!', a, b, flush=True)","output":"logn"},{"instruction":"import math\ns = input()\ns1 = input()\nplus=s.count('+')-s1.count('+')\nminus=s.count('-')-s1.count('-')\nv = s1.count('?')\nif plus<0 or minus<0:\n    print(0)\n    exit()\nprint((math.factorial(v)\/math.factorial(v-plus)\/math.factorial(plus))*(0.5**v))","output":"np"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,m = mi()\na = li()\nsize = [0 for i in range(n)]\nfor i in range(m):\n    size[a[i]-1] += 1\nprint(min(size))","output":"quadratic"},{"instruction":"n, r = map(int, input().split())\ny = []\nx = list(map(int, input().split()))\nfor xi in x:\n    yi = r\n    for tx, ty in zip(x, y):\n        if xi - 2 * r <= tx <= xi + 2 * r:\n            dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5\n            yi = max(yi, ty + dy)\n    y.append(yi)\nprint(*y)","output":"quadratic"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\na = [tuple(mi()) for i in range(3)]\na.sort()\n\nup1 = a[1][1] >= a[0][1]\nup2 = a[2][1] >= a[0][1]\nans = {a[0]}\nx, y = a[0]\nif up1 and up2:\n    while y < min(a[1][1], a[2][1]):\n        y += 1\n        ans.add((x, y))\n    while x < a[2][0]:\n        x += 1\n        ans.add((x, y))\n    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]\n    while hy > y:\n        ans.add((hx, hy))\n        hy -= 1\nelse:\n    dn1 = a[1][1] <= a[0][1]\n    dn2 = a[2][1] <= a[0][1]\n    ans = {a[0]}\n    x, y = a[0]\n    if dn1 and dn2:\n        while y > max(a[1][1], a[2][1]):\n            y -= 1\n            ans.add((x, y))\n        while x < a[2][0]:\n            x += 1\n            ans.add((x, y))\n        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]\n        while ly < y:\n            ans.add((lx, ly))\n            ly += 1\n    else:\n        x, y = a[0]\n        ans = {a[0]}\n        while x < a[2][0]:\n            x += 1\n            ans.add((x, y))\n        dy = 1 if a[1][1] <= a[0][1] else -1\n        xx, yy = a[1]\n        while yy != a[0][1]:\n            ans.add((xx, yy))\n            yy += dy\n        dy = 1 if a[2][1] <= a[0][1] else -1\n        xx, yy = a[2]\n        while yy != a[0][1]:\n            ans.add((xx, yy))\n            yy += dy\n\nans = sorted(ans)\nprint(len(ans))\nprint('\\n'.join('%d %d' % (x, y) for x, y in ans))","output":"constant"},{"instruction":"import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n, k = mp()\n    a = [2, 5, 8]\n    s = 0\n    for i in a:\n        s += (n * i - 1) \/\/ k + 1\n    print(s)\n\ndebug = 0\nif debug:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nmain()\nif debug:\n    file.close()","output":"constant"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\narr.sort()\nif arr[-1] == 1:\n    arr[-1] = 2\nelse:\n    arr[-1] = 1\narr.sort()\nprint(*arr)","output":"nlogn"},{"instruction":"n, k = map( int, input().split() )\n\nd = n - k\nd = d \/\/ 2\n\nl = []\n\nwhile n > 0:\n    i = min(n,d)\n    while i>0:\n        l.append('1')\n        i -= 1\n        n -= 1\n    if n > 0:\n        l.append('0')\n        n -= 1\n\nprint( \"\".join( l ) )","output":"quadratic"},{"instruction":"a,b = map(int,input().split())\na,b = min(a, b), max(a, b)\nA = bin(a)[2:]\nB = bin(b)[2:]\nA = \"0\" * (len(B) - len(A)) + A\ndiff = 0\nfor i in range(len(A)):\n    if(A[i]!=B[i]):\n        diff = len(A) - i\n        break\nprint((2**diff) - 1)","output":"logn"},{"instruction":"x,k=map(int,input().split())\nmod=1000000007\nif x==0: print(0)\nelse:\n    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)","output":"logn"},{"instruction":"from collections import defaultdict as dd\nd=dd(int)\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\nhas=False\ncount=0\nd[0] =1\ntotal=0\nfor i in range(n):\n    if arr[i] >m:\n        count  +=1\n    if arr[i] <m:\n        count -=1\n    if arr[i] ==m:\n        has=True\n    if has:\n        total +=d[count] +d[count-1]\n    else:\n        d[count] +=1\nprint(total)","output":"nlogn"},{"instruction":"n,m = int(input()),int(input())\nif n < 27:\n    print(m%2**n)\nelse:\n    print(m)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nA=list(map(int,input().split()))\nA.append(n+1)\nCOMP=[]\nNOW=0\nfor a in A:\n    if a-NOW-1!=0:\n        if a-NOW-1>2*k:\n            COMP.append([(a-NOW-1)%k+k,0])\n        else:\n            COMP.append([a-NOW-1,0])\n    COMP.append([1,1])\n    NOW=a\n\nCOMP.pop()\n\nANS=0\nNOW_PAGE=0\nNOW_SCORE=0\n\npa=0\nLEN=len(COMP)\nwhile pa<LEN:\n    i,j=COMP[pa]\n\n    if NOW_PAGE+i<=k:\n        NOW_PAGE += i\n        NOW_SCORE += j\n        pa+=1\n\n    else:\n        if NOW_SCORE>0:\n\n            COMP[pa][0]-=k-NOW_PAGE\n            NOW_PAGE=k-NOW_SCORE\n\n            ANS+=1\n            NOW_SCORE=0\n\n        else:\n            if NOW_PAGE==k:\n                NOW_PAGE=0\n\n            else:\n                COMP[pa][0]-=k-NOW_PAGE\n                NOW_PAGE=k-NOW_SCORE\n\nif NOW_SCORE>0:\n    ANS+=1\n\nprint(ANS)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\nimport time\n\nfrom types import GeneratorType\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\n\nstart_time = time.time()\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\ndef getMat(n):\n    return [getInts() for _ in range(n)]\ndef get_ints():return map(int, sys.stdin.readline().split())\n\nn,k=map(int,input().split())\nknight=list(map(int,input().split()))\ncoins=list(map(int,input().split()))\nd={};ans=[0]*n\nfor i in range(n):\n  knight[i]=[knight[i],i]\nfor i in coins:\n  d[i]=d.get(i,0)+1\nc=coins[:]\n\nknight=sorted(knight,key=lambda x:x[0])\n\nans2=[];ans=coins[:]\nif k==0:print(*ans)\nelse:\n for i in range(n):\n  ans1=0\n  if len(ans2)<k:ans1=sum(ans2)\n  else:ans2=sorted(ans2)[-k:];ans1+=sum(ans2)\n\n  ans[knight[i][1]]+=ans1\n  ans2.append(coins[knight[i][1]])\n print(*ans)","output":"nlogn"},{"instruction":"z,zz=input,lambda:list(map(int,z().split()))\nfast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=1\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\nn=int(z())\n\narr=zzz()\n\nnew_arr=sorted([ (i,j) for j,i in enumerate(arr) ])\n\nlst=fast()\n\nstack=[]\nans=[]\n\nsize=0\nleft=0\nright=n-1\n\nfor i,j in enumerate(lst):\n    if j=='0':\n        ans.append(new_arr[left][1]+1)\n        stack.append(new_arr[left][1]+1)\n        size+=1\n        left+=1\n\n    if j=='1':\n        if size==0:\n            ans.append(new_arr[right][1]+1)\n            stack.append(new_arr[right][1]+1)\n            right-=1\n        if size>0:\n            ans.append(stack[-1])\n            stack.pop()\n            size-=1\n\nprint(*ans)","output":"nlogn"},{"instruction":"k=int(input(''))\na=[9]\ni=1\nif k<10:\n    print(k)\nelse:\n    while k>a[-1]:\n        a.append((10**(i+1)-10**(i))*(i+1)+a[i-1])\n        i+=1\n\n    cat=len(a)\n    diff=k-a[-2]\n    step=int(diff\/(cat))\n    rem=diff%(cat)\n\n    if rem==0:\n        number=(10**(cat-1)-1)+step\n\n        print(str(number)[-1])\n    else:\n        number=10**(cat-1)+step\n\n        print(str(number)[rem-1])","output":"logn"},{"instruction":"a, b, c, d, e, f = list(map(int, input().split()))\nn, n2 = 1, a * b + c * d + e * f\nwhile n ** 2 < n2:\n    n += 1\nif n ** 2 > n2:\n    print(-1)\n    exit()\nl = sorted([[max(a, b), min(a, b), 'A'], [max(c, d), min(c, d), 'B'], [max(e, f), min(e, f), 'C']])\nif l[2][0] != n:\n    print(-1)\n    exit()\nv = str(n) + '\\n' + (l[2][2] * n + '\\n') * l[2][1]\nif l[0][0] == n and l[1][0] == n:\n    for i in range(2):\n        v += (l[i][2] * n + '\\n') * l[i][1]\nelse:\n    s = n - l[2][1]\n    if s not in l[0] or s not in l[1]:\n        print(-1)\n        exit()\n    x, y = l[0][1] if l[0][0] == s else l[0][0], l[1][1] if l[1][0] == s else l[1][0]\n    v += (l[0][2] * x + l[1][2] * y + '\\n') * s\nprint(v)","output":"np"},{"instruction":"from itertools import combinations\nn, l, r, x = map(int, input().split())\na = [int(x) for x in input().split()]\nans = 0\nfor i in range(2, n+1):\n    for p in combinations(a, i):\n        if l<=sum(p)<=r and max(p)-min(p)>=x:\n            ans += 1\nprint(ans)","output":"np"},{"instruction":"l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = list(bin(r)[2:]), list(bin(l)[2:])\nbinl = ['0'] * (len(binr) - len(binl)) + binl\n\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        binl = '1' * (len(binl[i:]))\n        break\n\nprint(int(binl, 2))","output":"logn"},{"instruction":"from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport math\nfrom collections import deque\n\ndef read():\n    return int(input())\n\ndef readmap():\n    return map(int, input().split())\n\ndef readlist():\n    return list(map(int, input().split()))\n\nN = read()\nLIST = []\nleft = 0\nright = 1\nfor i in range(N):\n    l, r = readmap()\n    LIST.append((l, left))\n    LIST.append((r, right))\n\nLIST.sort()\n\ncnt = [0] * (N+1)\n\nn = 1\nx = LIST[0][0]\ndir = left\nfor item in LIST[1:]:\n    if item[1] == left:\n        if dir == left:\n            cnt[n] += item[0] - x\n            n += 1\n            x = item[0]\n            dir = left\n        else:\n            cnt[n] += item[0] - x - 1\n            n += 1\n            x = item[0]\n            dir = left\n    else:\n        if dir == left:\n            cnt[n] += item[0] - x + 1\n            n -= 1\n            x = item[0]\n            dir = right\n        else:\n            cnt[n] += item[0] - x\n            n -= 1\n            x = item[0]\n            dir = right\n\nprint(\" \".join(list(map(str, cnt[1:]))))","output":"nlogn"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\nn = int(stdin.readline())\na = map(int, stdin.readline().split())\nassert n == len(a)\ncap = [0] + a[:]\n\nones = []\nothers = []\n\nfor i in range(n):\n    if a[i] == 1:\n        ones.append(i + 1)\n    else:\n        others.append(i + 1)\n\nif len(others) == 0:\n    if len(ones) == 1:\n        write(\"YES 0\")\n        write(\"0\")\n    else:\n        write(\"NO\")\n    exit()\n\ndia = len(others)\ngraph = []\n\nfor j in range(len(others) - 1):\n    graph.append((others[j], others[j + 1]))\n    cap[others[j]] -= 1\n    cap[others[j + 1]] -= 1\n\nif len(ones) > 0:\n    this = ones.pop()\n    graph.append((this, others[0]))\n    cap[others[0]] -= 1\n    dia += 1\n\nif len(ones) > 0:\n    this = ones.pop()\n    graph.append((this, others[-1]))\n    cap[others[-1]] -= 1\n    dia += 1\n\ndone = False\nfor j in range(len(others)):\n    while cap[others[j]] > 0:\n        if len(ones) > 0:\n            this = ones.pop()\n            graph.append((this, others[j]))\n            cap[others[j]] -= 1\n        else:\n            done = True\n            break\n\n    if done:\n        break\nif len(ones) > 0:\n    write(\"NO\")\nelse:\n    write(\"YES \" + str(dia - 1))\n    write(len(graph))\n    for a,b in graph:\n        write(str(a) + \" \" + str(b))","output":"linear"},{"instruction":"n, m = [int(v) for v in input().split()]\n\na = []\nfor _ in range(n):\n    a.append([int(v) for v in input()])\n\ncolsums = [sum(a[i][j] for i in range(n)) for j in range(m)]\n\nfor row in a:\n    if all(rv < sv for (rv, sv) in zip(row, colsums)):\n        print(\"YES\")\n        exit()\n\nprint(\"NO\")\n","output":"quadratic"},{"instruction":"from os import path\nfrom io import BytesIO, IOBase\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,Counter,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('0')\n\nfile = 1\ndef ceil(a,b):\n    return (a+b-1)\/\/b\n\ndef solve():\n\n    l,r = mi()\n    s1 = bin(l)[2:]\n    s2 = bin(r)[2:]\n    if len(s1) != len(s2):\n      print((1<<len(s2))-1)\n      return\n\n    x = 0\n    for i in range(62,-1,-1):\n      if ((l>>i)&1)^((r>>i)&1):\n        x +=(1<<(i+1))\n        x -=1\n        break\n    print(x)\n\nif __name__ ==\"__main__\":\n\n    if(file):\n\n       if path.exists('input.txt'):\n           sys.stdin=open('input.txt', 'r')\n           sys.stdout=open('output.txt','w')\n       else:\n           input=sys.stdin.readline\n    solve()","output":"logn"},{"instruction":"n, s = map(int, input().split())\n\nbig = s \/\/ n\nr = s - big * n\nif r > 0:\n    print(big + 1)\nelse:\n    print(big)","output":"constant"},{"instruction":"import sys;input = sys.stdin.readline\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\n\nr,g,b = ip()\nR = [0]+ip()\nG = [0]+ip()\nB = [0]+ip()\nR.sort()\nG.sort()\nB.sort()\ndp = [[[0]*201 for i in range(201)] for j in range(201)]\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0\n            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0\n            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0\n            dp[i][j][k] = max(dp[i][j][k],x,y,z)\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef mapin():\n    return map(int, input().split())\n\ndef solve(final, n):\n    fifi = [[final[j][i] for j in range(n)] for i in range(n)]\n\n    k = []\n    for i in range(n):\n        k.append(sum(final[i]))\n    a = max(k)-min(k)\n\n    a = a*a\n    k = []\n    for i in range(n):\n        k.append(sum(fifi[i]))\n    b = max(k)-min(k)\n\n    b = b*b\n\n    return a+b\n\ndef inte(a, b, c, d):\n    a = max(a, c)\n    b = min(b, d)\n\n    return [a, b]\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn = int(input())\nl = []\nfor i in range(n):\n    a, b = mapin()\n    l.append([a, b])\n\nf= []\nff = []\na = 0\nb = 10000000000000\nf.append([a, b])\nfor i in range(n):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    f.append([a, b])\na = 0\nb = 10000000000000\nff = [[] for i in range(n)]\nfor i in reversed(range(n)):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    ff[i] = [a, b]\nff.append([0, 100000000000000])\nans = 0\nfor i in range(n):\n    a = f[i]\n    b = ff[i+1]\n    y = inte(a[0], a[1], b[0], b[1])\n    if(y[1]>= y[0]):\n        ans = max(ans, y[1]-y[0])\n\nprint(ans)","output":"linear"},{"instruction":"n=int(input())\nfor i in range(n\/\/3):\n    print(2*i,0)\n    print(2*i+1,0)\n    print(2*i+1,3)\nfor i in range(n%3):\n    print(2*(n\/\/3)+i,0)","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\nfrom collections import deque, Counter,defaultdict as dft\nfrom heapq import heappop ,heappush\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor\nfrom bisect import bisect,bisect_left,bisect_right\nfrom decimal import *\nimport sys,threading\nfrom itertools import permutations, combinations\nfrom copy import deepcopy\ninput = sys.stdin.readline\n\nii = lambda: int(input())\nsi = lambda: input().rstrip()\nmp = lambda: map(int, input().split())\nms=  lambda: map(str,input().strip().split(\" \"))\nml = lambda: list(mp())\nmf = lambda: map(float, input().split())\n\nalphs = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef solve():\n\n    def seq(nd,i):\n        case=0\n        vis[nd]=1\n        for lnk in d[nd]:\n\n            if not vis[lnk]:\n                i,case=seq(lnk,i)\n                if case:return i,case\n            else:\n                if lnk not in seen:\n\n                    case=1\n                    break\n\n        order[i]=nd\n        seen.add(nd)\n\n        return i-1,case\n\n    def chk(word,dct,i):\n        if i==k:\n            res.append(dct['\n        else:\n            if word[i] in dct:\n                chk(word,dct[word[i]],i+1)\n            if '_' in dct:\n                chk(word,dct['_'],i+1)\n\n    n,m,k=map(int,input().split())\n    trie={}\n    global case\n    case=0\n    for i in range(n):\n        word=input()\n        dct=trie\n        for w in word:\n            if w not in dct:\n                dct[w]={}\n            dct=dct[w]\n        dct['\n    d=dft(list)\n    for i in range(m):\n\n        word,idx=input().split()\n        idx=int(idx)\n        res=[]\n        chk(word,trie,0)\n\n        temp=0\n        for num in res:\n            if num!=idx:\n                d[idx].append(num)\n            else:\n                temp=1\n        if not temp:\n            case=1\n\n    order=[0]*(n+1)\n    vis=[0]*(n+1)\n    seen=set()\n    idx=n\n\n    for i in range(1,n+1):\n        if not vis[i]:\n            idx,tp=seq(i,idx)\n            if tp:\n                case=1\n                break\n\n    if case:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*order[1:])\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    tc=1\n\n    for i in range(tc):\n    \tsolve()","output":"np"},{"instruction":"def process(a):\n    assert len(a) >= 2\n\n    n    = len(a)\n    min_ = float('inf')\n\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            min_ = min(min_, cnt)\n        else:\n            min_ = min(min_, (cnt+1) \/\/2)\n\n    b    = []\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            remain = cnt - min_\n        else:\n            remain = cnt - min_ * 2\n\n        if remain <= 0:\n            continue\n\n        if len(b) == 0 or c != b[-1][1]:\n            b.append([remain, c])\n        else:\n            pre_cnt, pre_c  = b.pop()\n            b.append([pre_cnt+remain, c])\n\n    return b, min_\n\nS   = input() + ' '\ncur = []\n\ncnt = 0\npre = ''\nfor x in S:\n    if cnt == 0:\n        cnt+= 1\n        pre = x\n    elif x!=pre:\n        cur.append([cnt, pre])\n        cnt = 1\n        pre = x\n    else:\n        cnt+=1\n\ncnt = 0\nwhile len(cur) not in [0, 1]:\n    cur, min_ = process(cur)\n    cnt+=min_\n\nprint(cnt)","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\nfrom math import inf\n\ndef main():\n    n = int(input())\n    a = [0]+list(map(int,input().split()))\n    dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)]\n\n    for i in range(1,n+1):\n        dp[i][i][0],dp[i][i][1] = a[i],1\n    for i in range(n-1,0,-1):\n        for j in range(i+1,n+1):\n            for k in range(j-i):\n                a,b = dp[i][i+k],dp[i+k+1][j]\n                if a[1] and b[1] and a[0] == b[0]:\n                    dp[i][j][0],dp[i][j][1] = a[0]+1,1\n                    break\n    val = [0,0]+[inf]*n\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if dp[i][j][1]:\n                val[j+1] = min(val[j+1],val[i]+1)\n    print(val[-1])\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"from math import *\n\nn=int(input())\nA = list(map(int,input().split()))\nans =-1\nmaxs = 0\nfor j in range(n):\n    if(A[j] > maxs):\n        ans = j+1\n        break\n    else:\n        maxs = max(maxs,A[j]+1)\nprint(ans)","output":"linear"},{"instruction":"def factorial(n) :\n    ans = 1\n    if (n == 0) :\n        return 1\n    for i in range(1, n + 1) :\n        ans *= i\n    return ans\ndef ncr(n , r) :\n    n = abs(n)\n    if r > n :\n        return 0\n    ans = factorial(n)\n    ans = ans\/\/(factorial(n-r))\n    ans = ans\/\/(factorial(r))\n    return ans\n\nif __name__ == \"__main__\" :\n    A = input()\n    B = input()\n    QMarks = B.count('?')\n    TotalA = A.count('+') - A.count('-')\n    TotalB = B.count('+') - B.count('-')\n    denominator = 2**QMarks\n    if QMarks < abs(TotalA - TotalB) :\n        print(0)\n    else :\n        x = (QMarks - abs(TotalA - TotalB))\/\/2\n        x += abs(TotalA - TotalB)\n        num = ncr(QMarks,x)\n        print(num\/denominator)","output":"np"},{"instruction":"numeros = [int(i) for i in input().split(' ')]\n\nl = bin(numeros[0])\nr = bin(numeros[1])\n\np = -1\n\nif (len(r) == len(l)):\n    for i in range (len(l)):\n        if (l[i] != r[i]):\n            p = i\n            break\n    if(numeros[0] != numeros[1]):\n        saida = 2**(len(r) - p) - 1\n        print(saida)\n    else:\n        print(0)\n\nelse:\n    if(numeros[0] != numeros[1]):\n        saida = 2**(len(r) - 2) - 1\n        print(saida)\n    else:\n        print(0)","output":"logn"},{"instruction":"import atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    t = []\n    g={}\n    for x in p:\n        if x in g:\n            t.append(g[x])\n            continue\n        kk = x - 1\n        while True:\n            if kk in g:\n                if x - g[kk] < k:\n                    ttt = g[kk]\n                else:\n                    ttt= kk + 1\n                for i in range(kk +1 , x + 1):\n                    g[i] = ttt\n                t.append(g[x])\n                break\n            elif kk<0 or x - kk == k:\n                for i in range(kk +1 , x + 1):\n                    g[i] = kk + 1\n                t.append(g[x])\n                break\n            kk -= 1\n\n    print(' '.join((str(x) for x in t)))\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from sys import stdin,stdout\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\ndef fn(p):\n    turns=b[p]\/\/14\n    a=b.copy();sm=0\n    a[p]=0\n    for i in range(1,15):\n        a[(p+i)%14]+=turns\n    rem=b[p]%14\n    for i in range(p+1,p+rem+1,1):\n        a[(i%14)]+=1\n    for i in range(14):\n        if a[i]&1==0:\n            sm+=a[i]\n\n    return sm\nfor _ in range(1):\n    b=lst()\n    ans=0\n    for i in range(14):\n        if b[i]!=0:ans=max(ans,fn(i))\n    print(ans)","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\nmod = int(1e9) + 7\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n \/\/ 2)\n    return (t * t) % mod\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n \/\/= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n \/\/= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\ndef main():\n    n, m=map(int, input().split())\n    a=list(map(int, input().split()))\n    k=a.index(m)\n    t=[0]\n    for i in range(k-1, -1, -1):\n        z=-1 if a[i]<a[k] else 1\n        t.append(t[-1]+z)\n    d={0:1}\n    now=0\n    for i in range(k+1, n):\n        now+=-1 if a[i]<a[k] else 1\n        if now not in d.keys():\n            d[now]=0\n        d[now]+=1\n\n    ans=0\n    for i in t:\n        if -i in d.keys():\n            ans+=d[-i]\n        if 1-i in d.keys():\n            ans+=d[1-i]\n    print(ans)\n\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom math import *\n\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n\n    return True\n\ndef mhd(a,b,x,y):\n\n    return abs(a-x)+abs(b-y)\n\nn = int(input())\na,b = map(int,input().split())\nif(mhd(a,b,1,1)<=mhd(a,b,n,n)):\n    print('White')\nelse:\n    print('Black')","output":"constant"},{"instruction":"k = int(input().split()[1])\nl = sorted(map(int, input().split()))\n\nres = set()\nfor i in l:\n    if i % k != 0 or i \/ k not in res:\n        res.add(i)\n\nprint(len(res))","output":"nlogn"},{"instruction":"t = int(input())\nans = ''\nfor j in range(t):\n    ab = input().split()\n    a = int(ab[0])\n    b = int(ab[1])\n    k = 0\n    while a > 0 and b > 0:\n        if a >= b:\n            k += a \/\/ b\n            a %= b\n        else:\n            k += (b \/\/ a)\n            b %= a\n    ans += str(k) + '\\n'\nprint(ans)","output":"constant"},{"instruction":"import math\n\nn,r = [int(x) for x in input().split()]\n\nx = math.sin(math.pi\/n)\n\ny = (x*r)\/(1-x)\n\nprint(y)","output":"constant"},{"instruction":"n = int(input())\n\nnums = list(map(int, input().split()))\ncosts = list(map(int, input().split()))\n\nk = -1\n\nfor i in range(n):\n\n    kc = -1\n    for c in range(i + 1, n):\n        if nums[i] < nums[c] and (kc == -1 or kc > costs[c]):\n            if kc == -1:\n                kc = costs[c]\n            kc = costs[c]\n\n    if kc > -1:\n        nat = kc\n        kc = -1\n        for c in range(i):\n            if nums[i] > nums[c] and (kc == -1 or kc > costs[c]):\n                if kc == -1:\n                    kc = costs[c]\n\n                kc = costs[c]\n\n        if kc > -1:\n            if k == -1:\n                k = nat + kc + costs[i]\n            k = min(nat + kc + costs[i], k)\n\nprint(k)","output":"quadratic"},{"instruction":"def mul(a, b, md) :\n    if(b == 1) :\n        return a\n    if(b % 2 == 0) :\n        t = mul(a, b \/\/ 2, md)\n        return (2 * t) % md\n    return (mul(a, b - 1, md) + a) % md;\n\ndef pows(a, b, md) :\n    if(b == 0) :\n        return 1\n    if(b % 2 == 0) :\n        t = pows(a, b \/\/ 2, md)\n        return mul(t, t, md) % md\n    return (mul(pows(a, b - 1, md) , a, md)) % md;\n\nx, k = map(int, input().split())\nch = pows(2, k, 1000000007)\nans = pows(2, k + 1, 1000000007) * x - ch + 1\nans = ans % (1000000007)\nif(x == 0) :\n    ans = 0\nprint(ans)","output":"logn"},{"instruction":"import sys, string\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\narr.sort()\nst = []\nfor i in arr:\n    if not st:\n        st.append(i)\n    else:\n        while st:\n            if 0 < abs(st[-1] - i) <= k:\n                st.pop()\n            else:\n                break\n        st.append(i)\nprint(len(st))","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\ndef ok(a,b,c):\n\n    n = a[0][-1]\n    ans = []\n    for i in range(a[0][0]): ans.append([a[1]]*n)\n\n    l = n\n    r = n - a[0][0]\n\n    for i in range(2):\n        for j in range(2):\n\n            l1,r1 = b[0]\n            l2,r2 = c[0]\n\n            if(i): l1,r1 = r1,l1\n            if(j): l2,r2 = r2,l2\n\n            if(l1 == l):\n                if(l2 != l or r1 + r2 != r): continue\n\n                for k in range(r1): ans.append([b[1]]*n)\n                for k in range(r2): ans.append([c[1]]*n)\n                return ans\n\n            if(l1 == r):\n                if(l2 != r or r1 + r2 != l): continue\n\n                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)\n                return ans\n\n    return False\n\nl1,r1,l2,r2,l3,r3 = value()\n\na = [sorted((l1,r1)),'A']\nb = [sorted((l2,r2)),'B']\nc = [sorted((l3,r3)),'C']\n\nA = ok(a,b,c)\nB = ok(b,a,c)\nC = ok(c,a,b)\n\nif(A):\n    print(len(A))\n    for i in A: print(*i,sep=\"\")\nelif(B):\n    print(len(B))\n    for i in B: print(*i,sep=\"\")\nelif(C):\n    print(len(C))\n    for i in C: print(*i,sep=\"\")\nelse:\n    print(-1)","output":"np"},{"instruction":"import os\n\nimport string\n\nfrom math import inf\nfrom functools import lru_cache\n\nif os.getcwd() == 'C:\\\\Users\\\\User\\\\Desktop\\\\python\\\\Prog\\\\CodeForces' \\\n        or os.environ['COMPUTERNAME'] == 'USER145':\n    import pdb\n\n    import sys\n\n    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    from pprint import pprint\n    from hypothesis import given, settings\n    from hypothesis import strategies as st\n\ndef ri():\n    return [int(i) for i in input().split()]\n\ndef to_bits(l):\n    ans = 0\n    for i in l:\n        ans |= (1 << i - 1)\n    return ans\n\nuser_masks = [0 for i in range(1 << 10)]\npizzas = [[] for i in range(1 << 10)]\n\n@lru_cache()\ndef count_sat_users(mask):\n    ans = 0\n    cmask = mask\n    while cmask:\n        ans += user_masks[cmask]\n        cmask = (cmask - 1) & mask\n    return ans\n\ndef main():\n    n, m = ri()\n    for _ in range(n):\n        k, *a = ri()\n        bits = to_bits(a)\n        user_masks[bits] += 1\n\n    ans = (float(-inf), float(inf), -1, -1)\n\n    for i in range(m):\n        c, k, *a = ri()\n        bits = to_bits(a)\n        pizzas[bits].append((c, i + 1, bits))\n        pizzas[bits].sort()\n        while len(pizzas[bits]) > 2:\n            pizzas[bits].pop()\n\n    for mask_F in range(1 << 9):\n        for mask_S in range(1 << 9):\n            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \\\n                    and mask_F != mask_S:\n\n                mask = mask_F | mask_S\n\n                satisfied_users = count_sat_users(mask)\n\n                f_pizza = next(iter(pizzas[mask_F]))\n                s_pizza = next(iter(pizzas[mask_S]))\n\n                summary_cost = 0\n                summary_cost += f_pizza[0]\n                summary_cost += s_pizza[0]\n\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n\n                bmask = mask\n                while bmask:\n                    satisfied_users += user_masks[bmask]\n                    bmask = (bmask - 1) & mask\n\n            if len(pizzas[mask_F]) == 2:\n                satisfied_users = count_sat_users(mask_F)\n\n                it = iter(pizzas[mask_F])\n\n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n\n            if len(pizzas[mask_S]) == 2:\n                satisfied_users = count_sat_users(mask_S)\n\n                it = iter(pizzas[mask_S])\n\n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n\n    aans = [ans[2],ans[3]]\n    aans.sort()\n    print(*aans, sep=' ')\n\nmain()","output":"np"},{"instruction":"n, mod = map(int, input().split())\n\nle = 500\n\ndef pow(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = (ans * x) % mod\n        x = (x**2) % mod\n        y \/\/= 2\n    return ans\n\ndef inv(x):\n    return pow(x, mod-2)\n\nM = [1]\nmul = 1\nfor i in range(1, le):\n    mul = (mul * i) % mod\n    M.append(mul)\n\nL0 = n\/\/2+3\nL1 = n+1\n\nD = [[0 for i in range(L1)] for j in range(L0)]\n\nND = [[0 for i in range(L1)] for j in range(L0)]\n\nINVS = [0] + [inv(i) for i in range(1, n+1)]\n\nD[1][1] = 1\nfor z in range(2, n+1):\n\n    l0 = z\/\/2+3\n    l1 = z+1\n\n    for i in range(l0):\n        for j in range(l1):\n            ND[i][j] = 0\n\n    for i in range(l0):\n        if i >= 1:\n            ND[i][1] += D[i-1][0] * (z-(i-1))\n            ND[i][1] %= mod\n\n    for i in range(l0):\n        for j in range(1, n+1):\n            ND[i][0] += D[i][j]\n            ND[i][0] %= mod\n\n    for i in range(l0):\n        for j in range(l1):\n            if j >= 2:\n                p = D[i][j-1]\n                p *= (z-(i-1))\n                p %= mod\n                p *= INVS[j] * 2\n                p %= mod\n                ND[i][j] += p\n                ND[i][j] %= mod\n\n    for i in range(l0):\n        for j in range(l1):\n            D[i][j] = ND[i][j]\n\nans = 0\nfor i in range(L0):\n    for j in range(1, L1):\n        ans += D[i][j]\n        ans %= mod\nprint(ans)","output":"cubic"},{"instruction":"from math import sin\npi = 3.141592653589793238462643383279502884197\nn, r = map(int,input().split())\ntheta = 2*pi \/ n\nR = r \/ (1-sin(theta\/2))\nprint(R-r)","output":"constant"},{"instruction":"import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bisearch_max(mn, mx, func):\n\n    ok = mn\n    ng = mx\n    while ok+1 < ng:\n        mid = (ok+ng) \/\/ 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef check(m):\n    ok = [0] * N\n    S = set()\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] >= m:\n                ok[i] |= 1<<j\n        S.add(ok[i])\n    full = (1<<M) - 1\n    for bit1 in range(1<<M):\n        for bit2 in range(bit1, 1<<M):\n            if bit1 in S and bit2 in S:\n                if bit1 | bit2 == full:\n                    return True\n    return False\n\nN, M = MAP()\nA = [None] * N\nfor i in range(N):\n    A[i] = LIST()\n\nres = bisearch_max(0, 10**9+1, check)\nok = [0] * N\nS = set()\nD = {}\nfor i in range(N):\n    for j in range(M):\n        if A[i][j] >= res:\n            ok[i] |= 1<<j\n    S.add(ok[i])\n    D[ok[i]] = i + 1\nfull = (1<<M) - 1\nfor bit1 in range(1<<M):\n    for bit2 in range(bit1, 1<<M):\n        if bit1 in S and bit2 in S:\n            if bit1 | bit2 == full:\n                print(D[bit1], D[bit2])\n                exit()","output":"np"},{"instruction":"chores = [int(x) for x in input().split()]\ncomplexity = [int(x) for x in input().split()]\ncomplexity.sort()\nprint(complexity[chores[2]]-complexity[chores[2]-1])","output":"nlogn"},{"instruction":"import sys\n\nprint('? %d %d' % (0, 0))\nsys.stdout.flush()\nagtb = int(input())\n\na, b = 0, 0\nops = 29\nfor i in range(ops, -1, -1):\n    c = a | (1 << i)\n    d = b\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    x = int(input())\n\n    c = a\n    d = b | (1 << i)\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    y = int(input())\n\n    if x != y:\n        if y == 1:\n            a = a | (1 << i)\n            b = b | (1 << i)\n    else:\n        if agtb == 1:\n            a = a | (1 << i)\n        else:\n            b = b | (1 << i)\n        agtb = x\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()","output":"logn"},{"instruction":"def onseg(p,q,r):\n    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \\\n           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])\n\ndef orientation(p,q,r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n\n    if (val == 0): return 0\n    return 1 if val > 0 else 2\n\ndef doint(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and onseg(p1, p2, q1): return True\n    if o2 == 0 and onseg(p1, q2, q1): return True\n    if o3 == 0 and onseg(p2, p1, q2): return True\n    if o4 == 0 and onseg(p2, q1, q2): return True\n\n    return False\n\nx0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())\nx4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())\n\nA = x0,y0\nB = x1,y1\nC = x2,y2\nD = x3,y3\na = x4,y4\nb = x5,y5\nc = x6,y6\nd = x7,y7\n\nif doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \\\n   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \\\n   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \\\n   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \\\n   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \\\n   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"import sys\n\ndef num_ops(low, high):\n    if high % low == 0:\n        return high \/\/ low\n    else:\n        return (high \/\/ low) + num_ops(high % low, low)\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    for _ in range(n):\n        low, high = [int(i) for i in sys.stdin.readline().strip().split()]\n        print(num_ops(low, high))\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"import sys, math, cmath, time, collections\nfrom collections import deque, Counter, OrderedDict, defaultdict\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\nfrom math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi\nfrom bisect import bisect_left, bisect_right\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nstart_time = time.time()\n\ndef solve(s):\n\n    mx = 0\n    visited = set()\n    for left in range(len(s)):\n        for right in range(left, len(s)):\n            substring = s[left : right + 1]\n            if substring not in visited:\n                visited.add(substring)\n            elif substring in visited:\n                mx = max(mx, len(substring))\n    print(mx)\n\ndef main():\n\n    s = input()\n    solve(s)\n\nif __name__ == \"__main__\":\n    LOCAL = False\n\n    if LOCAL:\n        sys.stdin = open(\"..\/io\/data.in\", \"r\")\n        sys.stdout = open(\"..\/io\/data.out\", \"w\")\n\n    testcases = 1\n    for i in range(testcases):\n        main()\n\n    if LOCAL:\n        print(f\"Time Elapsed: {time.time() - start_time} seconds\")\n        sys.stdout.close()","output":"cubic"},{"instruction":"inputS=input()\nans=0\n\nfor i in range (0,len(inputS)-1):\n    for count in range(1,len(inputS)):\n        for j in range(i+1, len(inputS)-count+1):\n            A=inputS[i: i+count]\n            B=inputS[j: j+count]\n            if A==B:\n                ans=count if count>ans else ans\n\nprint(ans)","output":"cubic"},{"instruction":"import sys\n\ninput=sys.stdin.readline\ndef  f(r,g,b,n,m,k):\n\n    if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)):\n\n        a1=mat[n][m][k]\n        if(a1!=-1):\n            return a1\n        else:\n            a1=0\n            b1=0\n            c1=0\n\n            if(n>=1 and m>=1):\n\n                a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k)\n            if(k>=1 and m>=1):\n                b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1)\n            if(n>=1 and k>=1):\n                c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1)\n\n            mat[n][m][k]=max(a1,b1)\n            mat[n][m][k]=max(mat[n][m][k],c1)\n\n            return mat[n][m][k]\n    return 0\n\nn,m,k=list(map(int,input().split(\" \")))\nmat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)]\n\nr=list(map(int,input().split(\" \")))\ng=list(map(int,input().split(\" \")))\nb=list(map(int,input().split(\" \")))\nr.sort()\ng.sort()\nb.sort()\n\nd={}\nprint(f(r,g,b,n,m,k))","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import deque\n\ndef main():\n    with open('input.txt') as fp:\n        input=fp.readline\n        n, m = map(int, input().split())\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, -1, 1]\n        q =deque()\n        k = int(input())\n        a = list(map(int, input().split()))\n        v = [[1] * (m + 2) for _ in range(n + 2)]\n        for i in range(m + 2):\n            v[0][i] = 0\n            v[-1][i] = 0\n        for i in range(n + 2):\n            v[i][0] = 0\n            v[i][-1] = 0\n        for i in range(0, 2 * k, 2):\n            q.append((a[i],a[i + 1]))\n            v[a[i]][a[i + 1]] = 0\n        while 1:\n            x, y =q.popleft()\n            for i in range(4):\n                xx, yy = x + dx[i], y + dy[i]\n                if v[xx][yy]:\n                    q.append((xx, yy))\n                    v[xx][yy] = 0\n            if not q:\n                with open('output.txt', mode='w') as fpp:\n                    fpp.write(f'{x} {y}')\n                break\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\ndef main():\n    n,r=map(int, input().split())\n    a=list(map(int, input().split()))\n    ans=[]\n    ans.append(r)\n    for i in range(1,n):\n        ymax=r\n        for j in range( i):\n            if abs(a[j]-a[i])<=2*r:\n                ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5)\n        ans.append(ymax)\n    print(*ans)\n\n    return\n\nif __name__==\"__main__\":\n    main()","output":"quadratic"},{"instruction":"import math\ndef getdt():\n    return map(int, input().split())\ndef calc(v0, v, a, x):\n    t = (v - v0) \/ a\n    x0 = v0 * t + 0.5 * a * t * t\n    if x0 >= x:\n        return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) \/ a)\n    return (x0, t)\ndef go(v0, v, a, x):\n    x0, t = calc(v0, v, a, x)\n    return t + (x - x0) \/ v\na, v = getdt()\nl, d, w = getdt()\nif w > v:\n    w = v\nx, t = calc(0, w, a, d)\nif x == d:\n    print(go(0, v, a, l))\nelse:\n    print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))","output":"constant"},{"instruction":"M = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x == 0: print(0); exit(0)\nP = pow(2, k, M)\nr = (P * x) % M - (0.5 * (-1 + P)) % M\nprint(int((2 * r + M) % M))","output":"logn"},{"instruction":"a, b = map(int, input().split())\nc = input()\nsu = 0\ncnt = 0\nj = -2\ni = 0\nlis = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and cnt < b:\n    if lis[i] in c and i-2 >= j:\n        su += i+1\n        cnt += 1\n        j = i\n    i += 1\nif cnt < b:\n    print(-1)\nelse:\n    print(su)","output":"linear"},{"instruction":"from sys import stdin\n\nn = int(stdin.readline())\n\nstones = sorted([int(x) for x in stdin.readline().split()])\n\nif n == 1:\n    if stones[0]%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n\nelse:\n    chilly = -1\n    chill = 2\n    prev = stones[0]\n\n    for x in stones[1:]:\n        if x == prev:\n            chill -= 1\n            chilly = x\n        else:\n            streak = 1\n            prev = x\n\n    s = sum(stones)\n\n    if n%4 == 0 or n%4 == 1:\n        s += 1\n\n    if chill <= 0 or stones.count(0) > 1:\n        print('cslnb')\n    elif chill == 1 and chilly-1 in stones:\n        print('cslnb')\n    elif s%2 == 1:\n        print('cslnb')\n    else:\n        print('sjfnb')","output":"nlogn"},{"instruction":"x,k=[int(i) for i in input().split()]\nif x!=0:\n    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)\nelse:\n    print(0)","output":"logn"},{"instruction":"n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,s=map(int,input().split())\nl=0;r=n+1\nwhile r-l>1:\n    x=(l+r)\/\/2\n    cs=0\n    m=x\n    while m>0:\n        cs+=m%10\n        m\/\/=10\n    if x-cs>=s:\n        r=x\n    else:\n        l=x\nprint(n-l)","output":"logn"},{"instruction":"n,val=map(int,input().split());\na=[0]+list(map(int,input().split()));\nsuma=[0 for i in range(n+1)];\nmx=0;\ntarget=0;\nfor i in range(1,n+1):\n\tsuma[i]=suma[i-1];\n\tmx=max(mx,a[i]);\n\tif (a[i]==val):\n\t\ttarget+=1;\n\t\tsuma[i]+=1;\n\nans=0;\npre=[0 for i in range(mx+1)];\ndp=[0];\nfor i in range(1,n+1):\n\tdp.append(max(1,1+dp[pre[a[i]]]-suma[i]+suma[pre[a[i]]]));\n\tif (a[i]!=val):\n\t\tans=max(ans,dp[i]);\n\tpre[a[i]]=i;\nprint(ans+target);","output":"linear"},{"instruction":"n = int(input())\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\nif (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"N = int(input())\nS = [input() for i in range(3)]\nbu = []\nfor s in S:\n    cnt = {}\n    mx = 0\n    for c in s:\n        if c not in cnt:\n            cnt[c] = 0\n        cnt[c] += 1\n        mx = max(mx, cnt[c])\n    if mx == len(s) and N == 1:\n        bu.append(mx - 1)\n    else:\n        bu.append(min(len(s), mx + N))\n\nans = -1\nansmx = -1\nfor i in range(3):\n    if bu[i] > ansmx:\n        ans = i\n        ansmx = bu[i]\n    elif bu[i] == ansmx:\n        ans = -1\n\nif ans == -1:\n    print('Draw')\nelif ans == 0:\n    print('Kuro')\nelif ans == 1:\n    print('Shiro')\nelse:\n    print('Katie')","output":"linear"},{"instruction":"sp = 10**9 + 7;\n\ndef power(number,n):\n    res = 1\n    while(n != 0):\n        if n % 2 != 0:\n            res *= number\n            res %= sp\n            n-= 1\n        number *= number\n        number %= sp\n        n \/\/= 2\n    return res % sp\n\nx,k = map(int,input().split())\nif x == 0:\n    print(0)\nelse:\n    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)","output":"logn"},{"instruction":"print('?', 0, 0, flush=True)\nt = int(input())\ns = [0]*31\nif t == 1:\n    s[30] = 1\nelse:\n    s[30] = -1\n\na = 0\nb = 0\nfor i in range(30, 0, -1):\n    c = (1 << (i-1)) + a\n    d = b\n    print('?', c, d, flush=True)\n    ans1 = int(input())\n    c = a\n    d = (1 << (i-1)) + b\n    print('?', c, d, flush=True)\n    ans2 = int(input())\n    if ans1 == -1 and ans2 == 1:\n        a += 1 << (i-1)\n        b += 1 << (i-1)\n        s[i-1] = s[i]\n    elif ans1 == 1 and ans2 == -1:\n        a += 0 << (i-1)\n        b += 0 << (i-1)\n        s[i-1] = s[i]\n    else:\n        s[i-1] = ans1\n        if s[i] == 1:\n            a += 1 << (i-1)\n            b += 0 << (i-1)\n        else:\n            a += 0 << (i-1)\n            b += 1 << (i-1)\nprint('!', a, b)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nans = float('inf')\nfor i in range(n):\n    ans = min(ans, a[i] \/\/ max(i,  n - i - 1))\nprint(ans)","output":"linear"},{"instruction":"def get_input_list():\n\treturn list(map(int, input().split()))\n\nn = int(input())\nl = get_input_list()\nr = get_input_list()\n\na = [0 for _ in range(n)]\nm = []\nm_ = []\nfor i in range(n):\n\tm.append(l[i] + r[i])\n\tm_.append(l[i] + r[i])\nm.sort()\nma = m[-1] + 1\n\nfor i in range(n):\n\ta[i] = ma - m_[i]\n\nl_ = []\nr_ = []\nfor i in range(n):\n\tc = 0\n\td = 0\n\tfor j in range(i+1):\n\t\tif a[j] > a[i]:\n\t\t\tc += 1\n\tfor j in range(i,n):\n\t\tif a[j] > a[i]:\n\t\t\td += 1\n\tl_.append(c)\n\tr_.append(d)\nres = True\nfor i in range(n):\n\tif l[i] != l_[i] or r[i] != r_[i]:\n\t\tres = False\n\t\tbreak\nif res:\n\tprint(\"YES\")\n\tfor i in range(n):\n\t\ta[i] = str(a[i])\n\tprint(\" \".join(a))\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"n = int(input())\nls= [list(map(int, input().split())) for i in range(n)]\n\nlsr = [[max(ls[i][0]-ls[i][1], 0), ls[i][0]+ls[i][1]] for i in range(n)]\nlsr.sort(key=lambda x: x[1])\nidx = 0\nans = 0\n\nfor l in lsr:\n    if idx <= l[0]:\n        idx = l[1]\n        ans+=1\n\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\ns = 0\ncount = dict()\nfor x in a:\n\tcount[x] = count.get(x, 0) + 1\n\ts += x\n\nanswer = 0\nfor i in range(n):\n\ttrash = 0\n\ttrash += count.get(a[i] - 1, 0) * (a[i] - 1)\n\ttrash += count.get(a[i]) * a[i]\n\ttrash += count.get(a[i] + 1, 0) * (a[i] + 1)\n\n\txcount = n - i\n\txcount -= count.get(a[i] - 1, 0)\n\txcount -= count.get(a[i], 0)\n\txcount -= count.get(a[i] + 1, 0)\n\n\tanswer += (s - trash) - (xcount * a[i])\n\n\tcount[a[i]] -= 1\n\ts -= a[i]\n\nprint(answer)","output":"nlogn"},{"instruction":"import sys\nimport string\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nn, k = ria()\nmp = {}\nfor i in string.ascii_uppercase[:k]:\n    mp[i] = 0\nfor i in input():\n    if i in mp:\n        mp[i] += 1\nprint(min(mp.values())*k)","output":"linear"},{"instruction":"import math\n\ndef sequence_split_up(sequence):\n    ans=[0,0,0]\n    for i in sequence:\n        if i=='+':\n            ans[0]+=1\n        elif i=='-':\n            ans[1]+=1\n        elif i=='?':\n            ans[2]+=1\n    return ans\n\ndef probability():\n    actual_sequence=sequence_split_up(drazil_send)\n    sequence_received=sequence_split_up(dreamoon_received)\n    total_len=sum(actual_sequence)\n    actual_ans=actual_sequence[0]-actual_sequence[1]\n    ans_received=sequence_received[0]-sequence_received[1]\n    difference=actual_ans-ans_received\n    no_of_blanks=sequence_received[2]\n    if no_of_blanks==0:\n        if actual_ans!=ans_received:\n            return 0\n        return 1\n    if abs(difference)>no_of_blanks:\n        return 0\n    ans_set=[0,0]\n    if difference>0:\n        ans_set[0]+=difference\n    elif difference<0:\n        ans_set[1]+=abs(difference)\n    blanks_left=no_of_blanks-abs(difference)\n    ans_set[0]=ans_set[0]+blanks_left\/\/2\n    ans_set[1]=ans_set[1]+blanks_left\/\/2\n    x = (math.factorial(no_of_blanks)\/\/(math.factorial(ans_set[0])*math.factorial(ans_set[1])))\/math.pow(2,no_of_blanks)\n    return x\n\ndrazil_send=input()\ndreamoon_received=input()\nprint(\"%.12f\"%probability())","output":"np"},{"instruction":"s = input()\nn = len(s)\nAns = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        L = i\n        R = j\n        while L < R and s[L] == s[R]:\n            L += 1\n            R -= 1\n        if L < R and Ans < j - i + 1:\n            Ans = j - i + 1\nprint(Ans)","output":"linear"},{"instruction":"import io,os,bisect\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue\n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0:\n            flag = True\n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num \/\/ prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1\n\n    if num>1: output.append(num)\n\n    return tuple(output)\n\nfor _ in range(int(input())):\n    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:            bisect.insort(stack,fact[factor]+1)\n        fact[factor] = i\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)\n    print(dp[-1][-1])","output":"cubic"},{"instruction":"N,L,H,d = map(int, input().split())\n\nl = list(map(int, input().split()))\ne = 0\nfor i in range(1 << N ):\n    k = []\n    for j in range(N):\n        if i >> j & 1:\n            k.append(l[j])\n    if len(k)>0:\n        maz = max(k)\n        mins = min(k)\n        sums = sum(k)\n        if sums >= L and sums <=H:\n            if maz - mins >=d:\n                e+=1\nprint(e)","output":"np"},{"instruction":"N, M, K, L = list(map(int, input().split()))\n\neach = (K + L) \/\/ M\n\nif (K + L) % M != 0:\n    each += 1\n\nif each * M > N:\n    print(-1)\nelse:\n    print(each)","output":"constant"},{"instruction":"N=int(input())\nintervals = []\nfor i in range(N):\n    x,w = map(int,input().split())\n    left = x-w\n    right = x+w\n    intervals.append((left,right))\nintervals.sort(key=lambda x: x[1])\n\nleft = -1000000007\nans = 0\nfor i in range(N):\n    if intervals[i][0] >= left:\n        ans += 1\n        left = intervals[i][1]\nprint(ans)","output":"nlogn"},{"instruction":"import math\nfrom collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef process(s):\n    b=[]\n    for j in s:\n        b.append(j)\n    return b\n\nfor _ in range(1):\n\n    n,m,k=map(int,input().split())\n    d1=[[float(\"inf\") for i in range(m+1)] for j in range(n+1)]\n    d2 = [[float(\"inf\") for i in range(m+1)] for j in range(n+1)]\n\n    for i in range(n):\n        l=list(map(int,input().split()))\n        for j in range(m-1):\n            d1[i][j]=l[j]\n\n    for i in range(n-1):\n        l=list(map(int,input().split()))\n        for j in range(m):\n            d2[i][j]=l[j]\n\n    if k%2!=0:\n        ans=[[-1 for j in range(m)] for i in range(n)]\n\n    else:\n        ans = [[float('inf') for j in range(m+1)] for i in range(n+1)]\n        for i in range(n):\n            for j in range(m):\n                ans[i][j]=min(2*d1[i][j],2*d1[i][j-1],2*d2[i-1][j],2*d2[i][j])\n\n        curr=2\n\n        while(curr!=k):\n            new = [[float('inf') for j in range(m+1)] for i in range(n+1)]\n            for i in range(n):\n                for j in range(m):\n\n                    new[i][j] = min(ans[i][j-1]+2 * d1[i][j-1], ans[i][j+1]+2 * d1[i][j], ans[i-1][j]+2*d2[i-1][j], ans[i+1][j]+2 *d2[i][j])\n\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = new[i][j]\n\n            curr+=2\n\n    for i in range(n):\n        print(*ans[i][:m])","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom bisect import bisect_left as bsl\ndef main():\n    cur=9;count=1;tot=0\n    num=[];cc=[]\n    for s in range(11):\n        num.append(cur*count)\n        tot+=cur\n        cc.append(tot)\n        cur*=10;count+=1\n    ans=[num[0]]\n    for s in range(1,11):\n        ans.append(ans[-1]+num[s])\n    k=int(input())\n    ind=min(bsl(ans,k),10)\n    left=k\n    if ind>0:\n        left-=ans[ind-1]\n\n    nums=left\/\/(ind+1);rem=left%(ind+1)\n    if left%(ind+1)!=0:\n        nums+=1\n    if ind>0:\n        nums+=cc[ind-1]\n    answer=[int(k) for k in str(nums)]\n    print(answer[rem-1])\nmain()","output":"logn"},{"instruction":"def main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        for i in range(n - k + 1):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            for j in range(k):\n                if (i + j) % 3 == 0:\n                    if s[i + j] != \"R\":\n                        count1 += 1\n                    if s[i + j] != \"G\":\n                        count2 += 1\n                    if s[i + j] != \"B\":\n                        count3 += 1\n                if (i + j) % 3 == 1:\n                    if s[i + j] != \"G\":\n                        count1 += 1\n                    if s[i + j] != \"B\":\n                        count2 += 1\n                    if s[i + j] != \"R\":\n                        count3 += 1\n                if (i + j) % 3 == 2:\n                    if s[i + j] != \"B\":\n                        count1 += 1\n                    if s[i + j] != \"R\":\n                        count2 += 1\n                    if s[i + j] != \"G\":\n                        count3 += 1\n            min_ans = min(min_ans, count1, count2, count3)\n        print(min_ans)\nmain()","output":"quadratic"},{"instruction":"import sys\n\ninput=sys.stdin.readline\ninf = 1e10\nmod = int(1e9 + 7)\nt=1;\n\nfor _ in range(t):\n\n    s=input()\n    c=s.count('1')\n    c1, i=0, 0\n    while(i<len(s) and s[i]!='2'):\n        if(s[i]=='0'):c1+=1\n        i+=1\n    print('0'*c1, end=\"\")\n    print('1'*c, end=\"\")\n    while(i<len(s)):\n        if(s[i]!='1'):\n            print(s[i], end=\"\")\n        i+=1","output":"linear"},{"instruction":"n,k=[int(x) for x in input().split()]\nlst1=[int(x) for x in input().split()]\nlst2=[int(x) for x in input().split()]\nlst3={}\nans=[]\nfor i in lst2:\n    if(i in lst1):\n\n        lst3[i]=lst1.index(i)\nfor i in sorted(lst3,key=lst3.get):\n    ans.append(i)\n\nprint(*ans,sep=\" \")","output":"quadratic"},{"instruction":"import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\n\nfrom collections import defaultdict\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree1:\n    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] <=key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None\n        self.right = None\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n\nn,a1,b=map(int,input().split())\nl=[]\nans=0\nd=defaultdict(int)\ne=defaultdict(list)\ne1=defaultdict(int)\nfor i in range(n):\n    a,b,c=map(int,input().split())\n    d[(b,c)]+=1\nfor i in d:\n    b,c=i\n    e[c-a1*b].append(d[i])\n    e1[c-a1*b]+=d[i]\nfor i in e:\n    for j in e[i]:\n        ans+=j*(e1[i]-j)\nprint(ans)","output":"linear"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nimport random\nimport time\nrandom.seed( int(time.time()) )\n\nbb = random.randint(0, 2**30-1)\n\nhat1 = 0\nhat2 = 0\nlastresult = None\nfor i in range(29, -1, -1):\n    g1 = hat1 + (1<<i)\n    g2 = hat2 + (1<<i)\n\n    if lastresult is None:\n        print('?',hat1^ bb,hat2)\n        t1 = int(input())\n    else:\n        t1 = lastresult\n    if t1!=0:\n        print('?',g1^ bb,g2)\n        t2 = int(input())\n        if t1!=t2:\n            if t1==1:\n                hat1+= (1<<i)\n            else:\n                hat2+= (1<<i)\n            lastresult = None\n            continue\n    lastresult = t1\n    print('?',g1^ bb,hat2)\n    t3 = int(input())\n    if t3==1:\n        pass\n    else:\n        hat1+= (1<<i)\n        hat2+= (1<<i)\n\nprint('!', hat1^bb% (2**30), hat2)","output":"logn"},{"instruction":"r,g,b=map(int,input().split())\nrs=sorted(list(map(int,input().split())))\ngs=sorted(list(map(int,input().split())))\nbs=sorted(list(map(int,input().split())))\ndp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]\nans=0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i>0 and k>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])\n            if i>0 and j>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])\n            if j>0 and k>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])\n            ans=max(ans,dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"n=int(input())\nle=[int(i) for i in input().split()]\nri=[int(i) for i in input().split()]\nnotp = False\ncheck=[]\nfor i in range(n):\n    check.append(n-le[i]-ri[i])\nfor i in range(n):\n    tot=0\n    for j in range(i-1,-1,-1):\n        if(check[j]>check[i]):\n            tot+=1\n    if(tot!=le[i]):\n        notp=True\n        break\nif(notp==False):\n    for i in range(n):\n        tot=0\n        for j in range(i+1,n):\n            if(check[j]>check[i]):\n                tot+=1\n        if(tot!=ri[i]):\n            notp=True\n            break\nif(notp):\n    print('NO')\nelse:\n    print('YES')\n    print(*check)","output":"quadratic"},{"instruction":"n,k = map(int,input().split())\nprint(-(-k\/\/n))\n","output":"constant"},{"instruction":"S = input()\nbest = 0\nfor i in range(len(S)):\n    for j in range(i+1, len(S)+1):\n        s = S[i:j]\n        c = 0\n        for k in range(len(S)):\n            if S[k:].startswith(s): c += 1\n\n        if c >= 2:\n            best = max(best, len(s))\nprint(best)","output":"cubic"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write('\\n'.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\nfrom decimal import Decimal\nfrom fractions import Fraction\n\nINF = float('inf')\nmod = int(1e9)+7\n\ndef recur(r,g,b):\n    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:\n        return 0\n    if dp[r][g][b]:\n        return dp[r][g][b]\n    if r>0 and g>0:\n        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))\n    if r>0 and b>0:\n        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))\n    if b>0 and g>0:\n        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))\n    return dp[r][g][b]\n\nr,g,b=mdata()\nR=sorted(mdata())\nG=sorted(mdata())\nB=sorted(mdata())\ndp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]\nout(recur(r,g,b))","output":"cubic"},{"instruction":"import sys\nimport string\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nn = ria()[0]\nar = ria()\n\nif n == 1:\n    print(ar[0])\n    exit(0)\n\nonlyNegs = True\nonlyPos = True\n\nif max(ar) >= 0:\n    onlyNegs = False\nif min(ar) <= 0:\n    onlyPos = False\n\nif onlyNegs:\n    print(abs(sum(ar)) + max(ar) * 2)\n    exit(0)\n\nif onlyPos:\n    print(abs(sum(ar)) - min(ar) * 2)\n    exit(0)\n\nprint(sum([abs(i) for i in ar]))","output":"linear"},{"instruction":"def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    s = read()\n    stones = 0\n    for c in s:\n        if c == '+':\n            stones += 1\n        else:\n            stones -= 1\n            if stones < 0:\n                stones = 0\n    write(stones)\n\nmain()","output":"linear"},{"instruction":"n,m,k=map(int,input().split())\n\nMOD=1000000009\n\nx=m-(n\/\/k*(k-1)+(n%k))\n\nif (x<=0):exit(print(m%MOD))\n\nprint(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)","output":"logn"},{"instruction":"def wins(mem, l, pos):\n\n\tif mem[pos] != 0:\n\t\treturn mem[pos] == 1\n\n\tval = l[pos]\n\n\tlo = pos - val\n\twhile lo >= 0:\n\t\tif l[lo] > val and not wins(mem, l, lo):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\tlo -= val\n\n\thi = pos + val\n\twhile hi < len(l):\n\t\tif l[hi] > val and not wins(mem, l, hi):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\thi += val\n\n\tmem[pos] = 2\n\treturn False\n\nn = int(input())\nl = list(map(int, raw_input().split()))\n\nmem = [0 for i in range(n)]\nans = \"\"\nfor i in range(n):\n\tans += \"A\" if wins(mem, l, i) else \"B\"\n\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\nm = int(input())\n\nprint(m % pow(2, n))","output":"constant"},{"instruction":"import sys\nn,s=map(int,input().split())\nif 2*s>n*(n+1) or s<2*n-1:\n  print('NO')\n  sys.exit()\nfor i in range(n,-1,-1):\n  if i==0:\n    branch=1\n    break\n  tmp=0\n  tmpn=n\n  j=1\n  while tmpn-i**(j-1)>=0:\n    tmp+=j*(i**(j-1))\n    tmpn-=i**(j-1)\n    j+=1\n  tmp+=j*(tmpn)\n  if tmp>s:\n    branch=i+1\n    break\ntmp=0\ntmpn=n\nj=1\ni=branch\ndic={}\nwhile tmpn-i**(j-1)>=0:\n  tmp+=j*(i**(j-1))\n  dic[j]=(i**(j-1))\n  tmpn-=i**(j-1)\n  j+=1\ntmp+=j*(tmpn)\ndic[j]=tmpn\nmaxi=j\nwhile tmp<s:\n  for j in range(maxi,-1,-1):\n    while dic[j]>1:\n      if s-tmp+j<=maxi:\n        dic[j]-=1\n        dic[s-tmp+j]+=1\n        tmp=s\n      else:\n        dic[j]-=1\n        dic[maxi+1]=1\n        tmp+=maxi+1-j\n        maxi+=1\n      if tmp==s:\n        break\n    if tmp==s:\n      break\nb=[]\nfor i in dic:\n  for j in range(dic[i]):\n    b.append(i)\nb.sort()\nprint('YES')\nchildren=[0]*n\nans=[-1]*n\ncurr=0\npointer=0\nfor i in range(1,n):\n  while b[i]>b[curr]+1:\n    curr+=1\n  ans[i]=curr\n  children[curr]+=1\n  if children[curr]==branch:\n    curr+=1\nfinans=[]\nfor i in range(1,n):\n  finans.append(ans[i]+1)\nprint(' '.join(map(str,finans)))","output":"nlogn"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,k = map(int,input().split())\n    card = list(map(int,input().split()))\n    fav = list(map(int,input().split()))\n    joy = [0]+list(map(int,input().split()))\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n    for i in range(len(joy)):\n        dp[1][i] = joy[i]\n    for i in range(len(joy),n*k+1):\n        dp[1][i] = joy[-1]\n    for i in range(2,n+1):\n        for j in range(1,n*k+1):\n            for kk in range(min(k+1,j+1)):\n                dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk])\n    tot = [0]*(10**5+1)\n    for i in card:\n        tot[i] += 1\n    tot1 = [0]*(10**5+1)\n    for i in fav:\n        tot1[i] += 1\n    ans = 0\n    for i in range(10**5+1):\n        ans += dp[tot1[i]][tot[i]]\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"import sys\nimport heapq\n\nn, k = list(map(int,sys.stdin.readline().strip().split(' ')))\np = list(map(int,sys.stdin.readline().strip().split(' ')))\nc = list(map(int,sys.stdin.readline().strip().split(' ')))\n\nsortedp = sorted([(pi,i) for (i,pi) in enumerate(p)])\n\nans = [0 for i in range(n)]\nacc_coins = 0\nacc = []\n\nif k == 0:\n\tprint(' '.join(map(str,c)))\nelse:\n\tfor i in range(n):\n\t\tcoins = c[sortedp[i][1]]\n\t\tans[sortedp[i][1]] += acc_coins + coins\n\t\tif len(acc) < k:\n\t\t\tacc_coins += coins\n\t\t\theapq.heappush(acc,coins)\n\t\telse:\n\t\t\tsmallest_coin = heapq.nsmallest(1,acc)[0]\n\t\t\tif smallest_coin < coins:\n\t\t\t\tacc_coins -= smallest_coin\n\t\t\t\theapq.heappop(acc)\n\t\t\t\theapq.heappush(acc,coins)\n\t\t\t\tacc_coins += coins\n\tprint(' '.join(map(str,ans)))","output":"nlogn"},{"instruction":"import  math\ns=str(input())\ns2=str(input())\np,m,res,ans,temp,i=0,0,0,0,0,0\np=s.count(\"+\")\nm=s.count(\"-\")\nq=s2.count(\"+\")\nw=s2.count(\"-\")\npr,mr=p-q,m-w\nif pr <0 or mr<0:\n    print(\"%.12f\"%0)\nelse:\n    temp=pr+mr\n    if temp==0:\n        print('%.12f'%1)\n    else:\n        i=pow(2,temp)\n        res=math.factorial(temp)\/(math.factorial(pr)*math.factorial(mr))\n        ans=res\/i\n        print(\"%.12f\"%ans)","output":"np"},{"instruction":"import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n\/\/2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()","output":"logn"},{"instruction":"mod=1000000007\ndef fastexp(base,exp):\n    if(exp==0):\n        return 1;\n    if(exp==1):\n        return base%mod;\n    t=fastexp(base,exp\/\/2);\n    if(exp%2==0):\n        return (t%mod*t%mod)%mod;\n    else:\n        return (t%mod*t%mod*base%mod)%mod;\nx,k=map(int,input().split())\nif(x==0):\n    print(0);\nelse:\n    t=fastexp(2,k)%mod;\n    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod\n    while(before<0):\n        before+=mod;\n    before=before%mod;\n    print(before)","output":"logn"},{"instruction":"n, p = map(int, input().split())\na = list(map(int, input().split()))\nt = 0\nk = 0\nfor i in range(n):\n    k += a[i]\ns = 0\nfor i in range(0, n-1):\n    s += a[i]\n    t = max(t, s%p + (k - s)%p)\nprint(t)","output":"linear"},{"instruction":"n, p = map(int, input().split())\na = list(map(int, input().split()))\na = [c % p for c in a]\ns = sum(a)\nsp = s % p\nif sp == s or sp + 1 == p:\n    print(sp)\nelse:\n    print(sp + p)","output":"linear"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10 ** 6, func=lambda a, b: min(a, b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\nmod = 10 ** 9 + 7\nomod = 998244353\n\nprime = [True for i in range(10)]\npp = [0] * 10\n\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c = 0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c += 1\n            for i in range(p, n + 1, p):\n                pp[i] += 1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) \/\/ 2\n        if (arr[mid] >= key):\n            res = arr[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    return res\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) \/\/ 2\n        if (arr[mid]>=key):\n            right = mid - 1\n        else:\n            res = arr[mid]\n            left = mid + 1\n    return res\n\nn,k=map(int,input().split())\nprev=defaultdict(int)\nfor ik in range(k):\n    cur=int(input())\n    s=list(input())\n    t=2\n    while(cur%t==0):\n        t*=2\n    t\/\/=4\n    for i in range(len(s)):\n        if cur==(n+1)\/\/2:\n            if s[i]=='U':\n                continue\n            else:\n                if s[i]=='L':\n                    cur-=t\n                else:\n                    cur+=t\n                t\/\/=2\n        elif cur%2==1:\n            if s[i]==\"U\":\n                if cur&2==0:\n                    cur+=1\n                else:\n                    cur-=1\n                t=1\n        else:\n            if s[i] == 'L':\n                cur-=t\n                t\/\/=2\n            elif s[i]==\"U\":\n                if cur&t*4==0:\n                    cur+=t*2\n                else:\n                    cur-=t*2\n                t*=2\n            else:\n                cur+=t\n                t\/\/=2\n    print(cur)","output":"np"},{"instruction":"def check():\n\tf = True\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif map1[i][j] != map2[i][j]:\n\t\t\t\tf = False\n\t\t\t\tbreak\n\tif f:\n\t\treturn True\n\n\tf = True\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif map1[i][j] != map2[n - 1 - i][j]:\n\t\t\t\tf = False\n\t\t\t\tbreak\n\tif f:\n\t\treturn True\n\n\tf = True\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif map1[i][j] != map2[i][n - 1 - j]:\n\t\t\t\tf = False\n\t\t\t\tbreak\n\tif f:\n\t\treturn True\n\ndef rotate():\n\twk1=[]\n\tfor i in range(n):\n\t\twk1.append([])\n\t\tfor j in range(n):\n\t\t\twk1[i].append(map1[i][j])\n\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tmap1[i][j] = wk1[j][n - 1 - i]\n\nn = int(input())\nmap1 = []\nfor i in range(n):\n\tst = input()\n\tmap1.append([])\n\tfor j in st:\n\t\tmap1[i].append(j)\n\nmap2 = []\nfor i in range(n):\n\tst = input()\n\tmap2.append([])\n\tfor j in st:\n\t\tmap2[i].append(j)\n\nf = False\nfor k in range(4):\n\tif check():\n\t\tf = True\n\t\tbreak\n\trotate()\n\nif f:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\nm += 1\n\ndef calc(l, r, eq, eq_i):\n    if l > r:\n        return 1\n    key = l, eq, eq_i\n    if key in f:\n        return f[key]\n\n    t = 0\n    for x in (['0', '1'] if s[l] == '?' else [s[l]]):\n        if l == r:\n            a = [x]\n        else:\n            a = ['0', '1'] if s[r] == '?' else [s[r]]\n        for y in a:\n            if not((eq and x > y) or (eq_i and x == y == '1')):\n                t += calc(l + 1, r - 1, eq and x == y, eq_i and x != y)\n    f[key] = t\n    return t\n\ns = ['?'] * n\nfor i in range(n):\n    s[i] = '0'\n    f = {}\n    p = calc(0, n - 1, True, True)\n    if m > p:\n        m -= p\n        s[i] = '1'\n\nif s[0] == '0':\n    print(''.join(s))\nelse:\n    print(-1)","output":"cubic"},{"instruction":"n = int(input())\nl = list(map(int, input().split(\" \")))\nr = list(map(int, input().split(\" \")))\n\nslr = [l[i]+r[i] for i in range(n)]\nans = [n-slr[i] for i in range(n)]\n\nflag = True\nif l[0]!=0 or r[n-1]!=0:\n\tflag= False\n\nfor i in range(n):\n\tgreat = 0\n\tfor j in range(i+1, n):\n\t\tif ans[i]<ans[j]:\n\t\t\tgreat = great + 1\n\tif r[i]!=great:\n\t\tflag = False\n\t\tbreak\nfor i in range(n-1, -1, -1):\n\tgreat = 0\n\tfor j in range(i-1, -1, -1):\n\t\tif ans[i]<ans[j]:\n\t\t\tgreat = great + 1\n\tif l[i]!=great:\n\t\tflag = False\n\t\tbreak\n\nif flag:\n\tprint(\"YES\")\n\tfor i in range(0, n-1):\n\t\tprint(ans[i], end=\" \")\n\tprint(ans[n-1])\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"a, b = input().split()\nli = []\nfor i in range(len(a)):\n    li.append(a[:i + 1] + b[0])\nli.sort()\nprint(li[0])","output":"linear"},{"instruction":"n=int(input())\nfa=[0,0]+list(map(int,input().split()))\ndelta=[0]*(n+1)\nsuml=[0]*(n+1)\nfor i in range(n,0,-1):\n\tif suml[i]==0:\n\t\tsuml[i]=1\n\tdelta[suml[i]]+=1\n\tsuml[fa[i]]+=suml[i]\n\nfor i in range(1,n+1):\n\tdelta[i]+=delta[i-1]\nans=0\nfor i in range(1,n+1):\n\twhile delta[ans]<i:\n\t\tans+=1\n\tprint(\"%d \"%ans,end=\"\")\nprint(\"\\n\")","output":"linear"},{"instruction":"_=input()\nn=input()\nnum=int(n)\n\nlist_n=list(n)\nlist_n_int=list(map(int,n))\n\nlower=max(list_n_int)\ntotal=sum(list_n_int)\nupper=int(total\/2)\n\nflag=False\nif lower == 0:\n    print(\"YES\")\nelse:\n    for i in range(lower,upper+1):\n        flag=True\n        p=0\n        temp=0\n        each=i\n        seg=total\/each\n        if seg.is_integer():\n            while p < len(n):\n\n                temp+=list_n_int[p]\n                if temp < each:\n                    p+=1\n                elif temp == each:\n                    temp=0\n                    p+=1\n                else:\n                    flag=False\n                    break\n            if flag:\n                print(\"YES\")\n                break\n        else:\n            flag=False\n    if not flag:\n        print(\"NO\")","output":"quadratic"},{"instruction":"a,b=map(int,input().split())\nprint((1<<(a^b).bit_length())-1)","output":"logn"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    mod = 998244353\n    n,k = map(int,input().split())\n    dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)]\n    dp[0][1] = [0,1,1,0]\n    dp[0][0] = [1,0,0,1]\n    for i in range(1,n):\n        for r in range(k):\n            dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod\n            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod\n            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod\n            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod\n            dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod\n            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod\n            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod\n            dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod\n            dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod\n            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod\n            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod\n            dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod\n            dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod\n            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod\n            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod\n            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod\n    print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"from os import path\nimport sys,time, collections as c , math , pprint as p , itertools as it , operator as op\nmaxx , localsys , mod = float('inf'), 0 , int(1e9 + 7)\nif (path.exists('input.txt')):  sys.stdin=open('input.txt','r') ;   sys.stdout=open('output.txt','w')\ninput = sys.stdin.readline\nn = int(input()) ; s = list(map(int , input().split())) ; c = list(map(int , input().split()))\nans = maxx\nfor mid in range(1 , n - 1):\n    l = [maxx] + [c[i] for i in range(mid) if s[i] < s[mid]]\n    r = [maxx] + [c[i] for i in range(mid+1 , n) if s[i] > s[mid]]\n    ans = min(ans , min(l) + c[mid] + min(r))\nprint(ans if ans != float('inf') else -1)","output":"quadratic"},{"instruction":"import bisect\nn,q=map(int,input().split())\nstrength=list(map(int,input().split()))\narrows=list(map(int,input().split()))\nfor i in range(1,n):\n    strength[i]+=strength[i-1]\nNo_arrows=0\nn-=1\nfor i in range(q):\n    No_arrows+=arrows[i]\n    if(No_arrows>=strength[-1]):\n        No_arrows=0\n        print(n+1)\n    else:\n        it=bisect.bisect_left(strength,No_arrows)\n        if(strength[it]==No_arrows):\n            print(n-it)\n        else:\n            print(n-it+1)","output":"nlogn"},{"instruction":"n,k= map(int,input().split(' '))\nl= list(map(int,input().split(' ')))\nf =list(map(int,input().split(' ')))\nh=list(map(int,input().split(' ')))\nd1=dict({(a,0) for a in f})\nd2=dict({(a,0) for a in f})\nfor a in l:\n\tif(a in d1):d1[a]+=1\nfor a in f:\n\td2[a]+=1\n\ndp = [[0 for i in range(520*12)] for j in range(520)]\n\nfor x in range(n+1):\n\tfor y in range(n*k+1):\n\t\tfor i in range(k+1):\n\t\t\t\tdp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )\nss=0\nfor i in d1:\n\n\tss+=dp[d2[i]][d1[i]]\nprint(ss)","output":"cubic"},{"instruction":"l=list(map(int,input().split()))\ns1,s2,s3,s4=0,0,0,0\nfor i in l:\n\tif i==1:\n\t\ts1+=1\n\tif i==2:\n\t\ts2+=1\n\tif i==3:\n\t\ts3+=1\n\tif i==4:\n\t\ts4+=1\n\nif s3>2 or s2>1 or s1>0 or (s4==2 and s2==1):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"constant"},{"instruction":"N, M, K = map(int, raw_input().split())\nA = [int(a) for a in raw_input().split()]\nS = [0]\nfor a in A:\n    S.append(S[-1]+M*a-K)\nMI = [(10**50)] * M\nans = 0\nfor i in range(N+1):\n    MI[i%M] = min(MI[i%M], S[i])\n    for j in range(M):\n        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))\/\/M)\nprint(ans)","output":"quadratic"},{"instruction":"input()\np = list(map(int, input().split()))\nx = max(p)\nif p[p.index(x)] == 1:\n    p[p.index(x)] = 2\nelse:\n    p[p.index(x)] = 1\np.sort()\nprint(' '.join(str(i) for i in p))","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef inv_cnt(b):\n    c = 0\n    visited = set()\n    for i in range(len(b)):\n        if i + 1 in visited:\n            pass\n        else:\n            visited.add(i)\n            path = [i + 1]\n            while b[path[-1] - 1] != path[0]:\n                visited.add(b[path[-1] - 1])\n                path.append(b[path[-1] - 1])\n            c += len(path) - 1\n    return c % 2\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    x = inv_cnt(a)\n    m = int(input())\n    for query in range(m):\n        l, r = [int(x) for x in input().split(' ')]\n        x = (x + (r - l + 1) \/\/ 2) % 2\n        if x:\n            print(\"odd\")\n        else:\n            print(\"even\")\n\nsolve()","output":"quadratic"},{"instruction":"import sys, string\n\nn, m = map(int, sys.stdin.readline().split())\nprint('4' * 2229)\nprint('5' * 2228 + '6')","output":"constant"},{"instruction":"import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n\nwhile left < right:\n    mid = right - (right - left) \/\/ 2;A = [[0] * (n + 2) for _ in range(k)]\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1;L = 0\n        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]\n    dp = [n + 1] * (1 << k);dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)","output":"np"},{"instruction":"s = input()\none = s.count('1')\nzero = 0\nind = -1\nfor i in range(len(s)):\n    if s[i]=='2':\n        ind=i\n        break\n    if s[i]=='0':\n        zero+=1\nd = \"\"\nif ind==-1:\n    print(\"0\"*zero+\"1\"*one)\n    exit()\nd =  d + \"0\"*zero+\"1\"*one\nfor i in s[ind:]:\n    if i!='1':\n        d+=i\nprint(d)","output":"linear"},{"instruction":"import sys\nfrom collections import deque\nimport bisect\ndef chk(l,r,total):\n    b = len(l)\n    prev = 0\n    i = 0\n    f = 1\n    cnt = 0\n    while i < b:\n        prev = prev+l[i]\n        if cnt == total and prev == r:\n            i = i+1\n            continue\n\n        if prev == r:\n            cnt += 1\n            if cnt != total:\n                prev = 0\n\n        i = i+1\n\n    if cnt < total or i != b:\n        f = 0\n\n    return f\n\nfor _ in range(1):\n    n = int(input())\n    s = input()\n    l = []\n    som = 0\n    for i in s:\n        l.append(int(i))\n        som += int(i)\n\n    flag = 0\n    for i in range(2,n+1):\n        if som%i == 0:\n            r = som\/\/i\n            if chk(l,r,i):\n                flag = 1\n                break\n\n        if flag:\n            break\n\n    if flag:\n        print(\"YES\")\n\n    else:\n        print(\"NO\")","output":"quadratic"},{"instruction":"n,a,b=map(int,input().split())\nif a>n:\n    print('NO')\n    exit()\nif b>n:\n    print(\"NO\")\n    exit()\nif a==1  and b==1:\n    if n==2 or n==3:\n        print('NO')\n        exit()\nif n==1 and a>1 or n==1 and b>1:\n    print('NO')\n    exit()\nif min(a,b)>1:\n    print('NO')\n    exit()\n\ndef check(mat):\n    vis=[0]*n\n    cnt=0\n    for i in range(n):\n        if vis[i]==0:\n            q=[i]\n            cnt+=1\n            vis[i]=1\n            while q:\n                t=q.pop(0)\n                for j in range(n):\n                    if mat[t][j]==1 and vis[j]==0:\n                        vis[j]=1\n                        q.append(j)\n        return cnt\nmat=[[0 for i in range(n)] for j in range(n)]\nm=max(a,b)\nj=1\nfor i in range(n):\n    if j<n:\n        mat[i][j]=1\n        mat[j][i]=1\n    j+=1\nfor i in range(m-1):\n    curr=n-i-1\n    for j in range(n):\n        if mat[curr][j]==1:\n            mat[curr][j]=0\n            mat[j][curr]=0\nif b==1:\n    print('YES')\n    for i in range(n):\n        print(*mat[i],sep='')\n\nelse:\n    print('YES')\n    for i in range(n):\n        for j in range(n):\n            mat[i][j]=1-mat[i][j]\n    for i in range(n):\n        mat[i][i]=0\n    for i in range(n):\n        print(*mat[i],sep='')","output":"quadratic"},{"instruction":"n = int(input())\nd = {'red':'Reality', 'purple': 'Power', 'yellow':'Mind', 'orange':'Soul','blue':'Space','green':'Time'}\nstones = ['Reality', 'Power', 'Mind', 'Soul', 'Space', 'Time']\nst=[]\nfor _ in range(n):\n    st.append(d[input()])\nb=[]\nfor a in stones:\n    if a not in st:\n        b.append(a)\nprint(len(b))\nfor k in b:\n    print(k)","output":"constant"},{"instruction":"n=int(input())\nprint(int(n\/2)+1)","output":"constant"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=None):\n        self.BIT=[0]*(n+1)\n        self.num=n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        self.mod = mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\na = li()\n\ninv = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            inv += 1\ninv %= 2\n\nm = int(input())\nfor _ in range(m):\n    l,r = mi()\n    L = r-l+1\n\n    all = L*(L-1)\/\/2\n    if all%2==1:\n        inv = 1 - inv\n\n    print(\"odd\" if inv else \"even\")","output":"quadratic"},{"instruction":"n=int(input())\nprint(n**2+(n-1)**2)","output":"constant"},{"instruction":"from sys import stdin\n\nrstr = lambda: stdin.readline().strip()\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nn, m, k = rints()\na = [rstr() for _ in range(n)]\nmem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]\n\nfor i in range(n):\n    ixs = []\n    for j in range(m):\n        if a[i][j] == '1':\n            ixs.append(j)\n\n    for j in range(k + 1):\n        tem = 0\n        if j < len(ixs):\n            tem, c = float('inf'), 0\n            for j1 in range(len(ixs) - j - 1, len(ixs)):\n                tem = min(tem, ixs[j1] - ixs[c] + 1)\n                c += 1\n\n        for j1 in range(k + 1 - j):\n            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)\n\nprint(mem[n][k])","output":"cubic"},{"instruction":"from math import ceil\n\nn, k = map(int, input().split())\n\nprint(ceil((8 * n) \/ k) + ceil((5 * n) \/ k) + ceil((2 * n) \/ k))","output":"constant"},{"instruction":"n,k = map(int,input().split())\nr = 0\nfor _ in range(n):\n    h,m = map(int,input().split())\n    t = 60*h+m\n    if(t>r+k):\n        break\n    r = t+k+1\nprint(r\/\/60,r%60)","output":"linear"},{"instruction":"n=input()\nans=0\nr,c=0,0\nfor i in n:\n    r+=int(i)\n    c+=1\n    if int(i)%3==0 or r%3==0 or c==3:\n        ans+=1\n        r,c=0,0\nprint(ans)","output":"linear"},{"instruction":"read = lambda: map(int, input().split())\nn, k = read()\ns = input()\nc = [0] * 26\nfor i in range(n):\n    if s[i] <= chr(ord('A') + k - 1):\n        c[ord(s[i]) - ord('A')] += 1\nprint(min(c[:k]) * k)","output":"linear"},{"instruction":"a=''.join(reversed(sorted(input())))\nb=int(input())\nr=''\nwhile len(a)>0:\n    for i in range(len(a)):\n        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))\n        if int(n)<=b:\n            r+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(r)","output":"cubic"},{"instruction":"n = int(input())\na = input().split()\nd = {}\nk = 0\nfor i in range(len(a)):\n    d[a[i]] = i\nfor s in input().split():\n    if d[s] != -1:\n        c = d[s]\n        print(c - k + 1, end=' ')\n        for i in range(k, c + 1):\n            d[a[i]] = -1\n        k = c + 1\n    else:\n        print(0, end=' ')","output":"linear"},{"instruction":"n=int(input())\nif n==1:\n    exit(print(1))\ny=n\ni=1\nwhile n!=0:\n    j=n\/\/2+n%2\n    if i*2>y and n==1:\n        i=i>>1\n        x=y\/\/i\n        print(i*x)\n    else:\n        print((str(i)+' ')*j,end='')\n    i=i<<1\n    n=n\/\/2","output":"nlogn"},{"instruction":"q = int(input())\nfor _ in range(q):\n\tl, r = map(int, input().split())\n\tsign = -1 if l % 2 else 1\n\tif (r-l) % 2:\n\t\tprint(-sign*(r-l+1)\/\/2)\n\telse:\n\t\tprint(sign*(l+(r-l)\/\/2))","output":"constant"},{"instruction":"n, a, b = map(int, input().split())\nghosts = [(vx, vy) for x, vx, vy in (map(int, input().split()) for i in range(n))]\nspeeds = {}\nfor vx, vy in ghosts:\n    vl = a * vx - vy\n    k = vx + a * vy\n    ss = speeds.setdefault(vl, {})\n    ss[k] = ss.get(k, 0) + 1\n\nresult = 0\nfor vl, ss in speeds.items():\n    group_size = sum(ss.values())\n    for sss in ss.values():\n        result += sss * (group_size - sss)\nprint(result)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nout = sys.stdout\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            out.write(str(mx)+\" \"+str(mx)+\" \"+str(mx)+\" \"+str(mx)+\"\\n\")\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            out.write(str(res[minj])+\" \"+str(res[minj])+\" \"+str(res[minj+1])+\" \"+str(res[minj+1])+\"\\n\")","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nchet = 0\nne_chet = 0\nchet1 = []\nne_chet1 = []\nfor i in range(len(a)):\n    if a[i] % 2 == 0:\n        chet += 1\n        chet1.append(a[i])\n    else:\n        ne_chet += 1\n        ne_chet1.append(a[i])\n    if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1):\n        break\nif chet == 1:\n    print(a.index(chet1[0]) + 1)\nelif ne_chet == 1:\n    print(a.index(ne_chet1[0]) + 1)","output":"linear"},{"instruction":"import zlib, base64\nexec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX\/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg\/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli\/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ\/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO\/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k\/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n\/z5clv\/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9\/df\/zyfL\/7p\/Hrz19P76fp6OqrcPD\/Od38BvToehw==')))","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom functools import *\nfrom math import *\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nA = [int(n) for n in input().split()]\nN = len(A)\ndp = [0] * N\nfor i in range(N):\n    B = A.copy()\n    each = B[i] \/\/ N\n    curr = B[i]\n    B[i] = 0\n    for j in range(N):\n        B[j] += each\n    for j in range(1, (curr - each * N) + 1):\n        B[(i + j) % N] += 1\n    for M in B:\n        if M % 2 == 0:\n            dp[i] += M\nprint(max(dp))","output":"constant"},{"instruction":"x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\npoints = [(x1, y1), (x2, y2), (y3, x3)]\n\ndef gen_points(A, B):\n\n\treturn [(A[0], B[1]), (B[0], A[1])]\n\npoints += gen_points([x1, y1], [x2, y2])\npoints += gen_points([x2, y2], [x3, y3])\npoints += gen_points([x1, y1], [x3, y3])\n\npoints = list(set(points))\n\nans = 1e9\nans_l = []\n\ndef mark_points(A, B):\n\tA = list(A)\n\tB = list(B)\n\td = set()\n\tx_s = 1 if A[0] < B[0] else -1\n\ty_s = 1 if A[1] < B[1] else -1\n\td.add((A[0], A[1]))\n\twhile A[0] != B[0]:\n\t\tA[0] += x_s\n\t\td.add((A[0], A[1]))\n\twhile A[1] != B[1]:\n\t\tA[1] += y_s\n\t\td.add((A[0], A[1]))\n\treturn d\n\nfor el in points:\n\td = mark_points([x1, y1], el).union(mark_points([x2, y2], el))\n\td = d.union(mark_points([x3, y3], el))\n\tif len(d) < ans:\n\t\tans = len(d)\n\t\tans_l = d\n\nprint(ans)\nfor el in ans_l:\n\tprint(*el)","output":"quadratic"},{"instruction":"import sys\nimport copy\n\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nMAT=[list(map(int,input().split())) for i in range(n)]\n\nif n==1:\n    ANS=10**10\n    for i in range(1,m):\n        if ANS>abs(MAT[0][i]-MAT[0][i-1]):\n            ANS=abs(MAT[0][i]-MAT[0][i-1])\n    print(ANS)\n    sys.exit()\n\nEDGE0=[[10**10]*n for i in range(n)]\nEDGE1=[[10**10]*n for i in range(n)]\nMAX=0\nMIN=0\n\nif m!=1:\n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n\n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n\n            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])\nelse:\n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n\n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n\ndef Hamilton(start,USED,rest,last,weight):\n\n    if MEMO[last*(1<<n)+USED]!=2:\n        return MEMO[last*(1<<n)+USED]\n    if rest==1:\n        for i in range(n):\n            if USED & (1<<i)==0:\n                final=i\n                break\n\n        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:\n\n            MEMO[last*(1<<n)+USED]=1\n            return 1\n        else:\n\n            MEMO[last*(1<<n)+USED]=0\n            return 0\n\n    for j in range(n):\n        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:\n\n            NEXT=USED+(1<<j)\n            if Hamilton(start,NEXT,rest-1,j,weight)==1:\n\n                MEMO[last*(1<<n)+USED]=1\n                return 1\n    else:\n\n        MEMO[last*(1<<n)+USED]=0\n        return 0\n\nwhile MAX!=MIN:\n\n    aveweight=(MAX+MIN+1)\/\/2\n\n    for start in range(n):\n        MEMO=[2]*(n*1<<(n+1))\n        START=1<<start\n        if Hamilton(start,START,n-1,start,aveweight)==1:\n            MIN=aveweight\n            break\n    else:\n        MAX=aveweight-1\n\nprint(MAX)","output":"np"},{"instruction":"r, g, b = map(int, input().split())\nred = list(map(int, input().split()))\ngreen = list(map(int, input().split()))\nblue = list(map(int, input().split()))\nred.sort()\ngreen.sort()\nblue.sort()\nred = red[::-1]\ngreen = green[::-1]\nblue = blue[::-1]\n\ndp = []\nfor i in range(r + 1):\n    temp = [[0] * (b + 1) for j in range(g + 1)]\n    dp.append(temp)\n\nanswer = 0\n\nfor i in range(0, r + 1):\n    for j in range(0, g + 1):\n        for k in range(0, b + 1):\n            if i > 0 and j > 0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])\n            if i > 0 and k > 0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])\n            if j > 0 and k > 0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])\n\n            answer = max(answer, dp[i][j][k])\nprint(answer)","output":"cubic"},{"instruction":"from math import ceil\nn=int(input())\nif n<=9:\n    print(n)\nelse:\n    d=2\n    ov=9\n    while n>d*9*(10**(d-1))+ov:\n        ov=d*9*(10**(d-1))+ov\n        d+=1\n    v=ceil((n-ov)\/d)+int('9'*(d-1))\n    print(str(v)[(n-ov-1)%d])","output":"logn"},{"instruction":"def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    nums = read_int_array()\n    out = nums[0]\n    first = nums[0]\n    for i in range(1, n):\n        out = min(out, min(nums[i], first) \/\/ i)\n    last = nums[-1]\n    for i in range(n-2, 0, -1):\n        out = min(out, min(nums[i], last) \/\/ (n-1 - i))\n    write(out)\n\nmain()","output":"linear"},{"instruction":"a,b,c,n = map(int,input().split())\na-=c\nb-=c\nif a>=0 and b>=0:\n    if (a+b+c)<n:\n        n-=(a+b+c)\n        print(n)\n    else:\n        print(-1)\nelse:\n    print(-1)","output":"constant"},{"instruction":"def main():\n    n = int(input())\n    arr = []\n\n    for i in range(n):\n        arr.append(input())\n\n    arr = sorted(arr, key=lambda x : len(x))\n\n    for i in range(n-1):\n        if arr[i] not in arr[i+1]:\n            print('NO')\n            return;\n\n    print('YES')\n    for pal in arr:\n        print(pal)\n\nmain()","output":"nlogn"},{"instruction":"from collections import Counter\n\ndef solve():\n    n, k = tuple( map( lambda x: int(x), input().split()) )\n\n    low, high = 0, n\n\n    while low <= high:\n        eaten = (low+high)\/\/2\n        added = (n-eaten)* (n-eaten+1)\/2\n\n        if added - eaten >= k:\n            low = eaten + 1\n        else:\n            high = eaten - 1\n\n    print(high)\n\nif __name__ == \"__main__\":\n    solve()","output":"logn"},{"instruction":"import math\n\nif __name__ == '__main__':\n\n\tn,q = [int(x) for x in raw_input().split()]\n\tqq = str(raw_input())\n\ts = [ int(x) for x in qq]\n\tprefix = [0]*n\n\tprefix[0]= s[0]\n\ttemp = [0]*(n+1)\n\ttemp[0]=1\n\tmod = (pow(10,9)\/\/1)+7\n\tfor i in range(1,n):\n\t\tprefix[i] += prefix[i-1] + s[i]\n\t\ttemp[i] =( 2*(temp[i-1]%mod) )%mod\n\n\ttemp[n] = (2*(temp[n-1]%mod))%mod\n\tansarr=[]\n\twhile q> 0:\n\t\tq-=1\n\t\tl,r = [int(x)-1 for x in raw_input().split()]\n\t\ta = prefix[r]-prefix[l]+s[l]\n\t\td = r-l+1\n\t\tval1 = temp[d]\n\t\tval2 = temp[d-a]\n\n\t\tansarr.append((val1-val2)%mod)\n\tprint('\\n'.join(map(str, ansarr)))","output":"linear"},{"instruction":"import math\n\ndef get_line(x1, y1, x2, y2):\n    a = x2 - x1\n    b = y1 - y2\n    c = x1 * (y2 - y1) - y1 * (x2 - x1)\n\n    g = math.gcd(math.gcd(a, b), c)\n    a \/\/= g\n    b \/\/= g\n    c \/\/= g\n    return a, b, c\n\nn = int(input())\nxy = []\n\nfor i in range(n):\n    x, y = [int(x) for x in input().split()]\n    xy.append((x, y))\n\nif n <= 3:\n    print(\"YES\")\n    exit()\n\ndef check(x1, y1, x2, y2, xy):\n    a1, b1, c1 = get_line(x1, y1, x2, y2)\n    other_point = None\n    cnt_other = 0\n    a2, b2, c2 = 0, 0, 0\n    for i in range(len(xy)):\n        x, y = xy[i]\n\n        if a1 * y + b1 * x + c1 != 0:\n            if other_point is None:\n                other_point = x, y\n                cnt_other = 1\n            elif cnt_other == 1:\n                cnt_other = 2\n                a2, b2, c2 = get_line(*other_point, x, y)\n            else:\n                if a2 * y + b2 * x + c2 != 0:\n                    return False\n    return True\n\nif check(*xy[0], *xy[1], xy[2:]):\n    print(\"YES\")\nelif check(*xy[1], *xy[2], [xy[0]] + xy[3:]):\n    print(\"YES\")\nelif check(*xy[0], *xy[2], [xy[1]] + xy[3:]):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n,s=map(int,input().split())\nr=10**18+1\nl=0\ndef f(m):\n  res=0\n  while m>0:\n    res+=m%10\n    m\/\/=10\n  return res\nwhile r-l>1:\n  mid=(r+l)\/\/2\n  if mid-f(mid)>=s:\n    r=mid\n  else:\n    l=mid\nprint(max(n-r+1,0))","output":"logn"},{"instruction":"import sys\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    n,m,k=map(int,input().split())\n    n=abs(n)\n    m=abs(m)\n    if max(n,m)>k:\n        print(\"-1\")\n    else:\n\n        bad1=((n+k)%2==1)\n        bad2=((m+k)%2==1)\n        print(k-bad1-bad2)","output":"constant"},{"instruction":"n=int(input())\nls=list(map(int,input().split()))\nls.sort()\nif ls.count(min(ls))==len(ls):\n\tprint('NO')\nfor i in range(n):\n\tif ls[i]!=min(ls):\n\t\tprint(ls[i])\n\t\tbreak\n","output":"nlogn"},{"instruction":"from math import log\nimport random\nspaces = (\" \",\"\\n\",\"\\t\")\nstops = (\"\",\" \",\"\\n\",\"\\t\")\nextendedPoints = set()\nstartingPoints = set()\ninterestPoints = []\n\nclass TPoint:\n\tdef __init__(self,x,y):\n\t\tself.x=x\n\t\tself.y=y\n\tdef __str__(self):\n\t\treturn \"(\"+str(self.x)+\",\"+str(self.y)+\")\"\n\tdef __eq__(self, other):\n\t\treturn self.x == other.x and self.y == other.y\n\tdef __hash__(self):\n\t\treturn self.x*20000 + self.y\n\tx=0\n\ty=0\n\th=0\ndef sortKey(p):\n\treturn p.h\ndef heuristic(p, otherPoints):\n\tminH = float(\"inf\")\n\tfor point in otherPoints:\n\t\tcurrentH = abs(point.x - p.x) + abs(point.y - p.y)\n\t\tif currentH < minH:\n\t\t\tminH = currentH\n\treturn minH\n\ndef addPoint(p,pointList):\n\tif not p in extendedPoints:\n\t\tp.h = heuristic(p,startingPoints)\n\t\textendedPoints.add(p)\n\t\tpointList.append(p)\n\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef extend(point,n,m,poinList):\n\tok = False\n\tif point.x>1:\n\t\tok = addPoint(TPoint(point.x-1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok\n\tif point.x<n:\n\t\tok = addPoint(TPoint(point.x+1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok\n\tif point.y>1:\n\t\tok = addPoint(TPoint(point.x,point.y-1),poinList) or ok\n\tif point.y<m:\n\t\tok = addPoint(TPoint(point.x,point.y+1),poinList) or ok\n\n\treturn ok\n\ndef ReadNext(fileObject):\n\tcurrentBuffer = \"\"\n\tcurrentRead=fileObject.read(1)\n\twhile currentRead in spaces:\n\t\tcurrentRead=fileObject.read(1)\n\tcurrentBuffer = currentBuffer + currentRead\n\twhile not currentRead in stops:\n\t\tcurrentRead=fileObject.read(1)\n\t\tcurrentBuffer = currentBuffer + currentRead\n\treturn currentBuffer.strip()\n\nw, r= open('output.txt', 'w'), open('input.txt', 'r')\n\nn = int(ReadNext(r))\nm = int(ReadNext(r))\nk = int(ReadNext(r))\nmscale = 5\n\nfor i in range(k):\n\tx = int(ReadNext(r))\n\ty = int(ReadNext(r))\n\tp = TPoint(x,y)\n\tstartingPoints.add(p)\n\textendedPoints.add(p)\n\ntmpPoints = []\ntmpPoints.append(TPoint(1,1))\ntmpPoints.append(TPoint(1,m))\ntmpPoints.append(TPoint(n,1))\ntmpPoints.append(TPoint(n,m))\nif n>2 and m>2:\n\ttmpPoints.append(TPoint(int(n\/2),1))\n\ttmpPoints.append(TPoint(1,int(m\/2)))\n\ttmpPoints.append(TPoint(int(n\/2),m))\n\ttmpPoints.append(TPoint(n,int(m\/2)))\n\ttmpPoints.append(TPoint(int(n\/2),int(m\/2)))\n\nfor p in tmpPoints:\n\taddPoint(p,interestPoints)\n\nfor p in startingPoints:\n\textend(p,n,m,interestPoints)\n\ninterestPoints.sort(reverse=True, key=sortKey)\nwhile len(interestPoints) > 3*mscale:\n\tinterestPoints.pop(len(interestPoints)-1)\n\nrandom.seed()\n\nif(len(interestPoints)>0):\n\tmaxPoint = interestPoints[0]\n\tfor p in interestPoints:\n\t\tcurrentBeam = [p]\n\t\tcanExtend = True\n\t\twhile canExtend:\n\t\t\taddPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)\n\t\t\tcanExtend = False\n\t\t\tfor i in range(len(currentBeam)):\n\t\t\t\tif extend(currentBeam[i],n,m,currentBeam):\n\t\t\t\t\tcanExtend = True\n\t\t\tcurrentBeam.sort(reverse=True, key=sortKey)\n\t\t\twhile len(currentBeam) > mscale:\n\t\t\t\tcurrentBeam.pop(len(currentBeam)-1)\n\t\tif currentBeam[0].h>maxPoint.h:\n\t\t\tmaxPoint = currentBeam[0]\n\n\tw.write(str(maxPoint.x)+\" \"+str(maxPoint.y)+\"\\n\")\nelse:\n\tw.write(str(n)+\" \"+str(m)+\"\\n\")","output":"cubic"},{"instruction":"import sys, heapq\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\npf = [0] * (n + 1)\npf[0] = arr[0]\nfor i in range(1, n):\n    pf[i] = pf[i - 1] + arr[i]\nans = 0\nfor i in range(n):\n    for j in range(n):\n        left = i\n        right = j\n        if right - left + 1 >= k:\n            temp = pf[right] - pf[left - 1]\n            ans = max(ans, temp \/ (right - left + 1))\nprint(ans)","output":"quadratic"},{"instruction":"index = int(input())\n\ntotal = 9\nn = 1\n\nwhile index > total:\n    total += (n + 1) * (10**n) * 9\n    n += 1\nlast = 10**(n - 1)\ntotal -= n * 9 * last\nindex = index - total\n\nr = index % (n)\nk = index \/\/ n\n\nnumber = last + k\n\nif r == 0:\n    print(str(number - 1)[n-1])\nelse:\n    print(str(number)[r - 1])","output":"constant"},{"instruction":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        def dfs(l, r):\n            if l > r:\n                return float(\"-inf\")\n\n            m = (l + r) >> 1\n            leftSum = rightSum = curSum = 0\n            for i in range(m - 1, l - 1, -1):\n                curSum += nums[i]\n                leftSum = max(leftSum, curSum)\n\n            curSum = 0\n            for i in range(m + 1, r + 1):\n                curSum += nums[i]\n                rightSum = max(rightSum, curSum)\n\n            return (max(dfs(l, m - 1),\n                        dfs(m + 1, r),\n                        leftSum + nums[m] + rightSum))\n\n        return dfs(0, len(nums) - 1)","output":"nlogn"},{"instruction":"n, m, k = map(int, input().split())\na = sorted(map(int, input().split()))\nr = [x for x in range(n + 1) if sum(a[n - x :]) + k >= m + x]\nprint(min(r) if r else -1)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\n\ntop = [-1, -1]\nbottom = [-1, -1]\n\nmatrix = list()\nfor i in range(n):\n    s = input()\n    matrix.append(s)\n\nfor i in range(n):\n    left = matrix[i].find('B')\n    if left != -1:\n        top[0] = i\n        top[1] = left\n        break\n\nfor i in range(n-1, -1, -1):\n    right = matrix[i].rfind('B')\n    if right != -1:\n        bottom[0] = i\n        bottom[1] = right\n        break\n\nprint(1 + top[0] + (bottom[0] - top[0]) \/\/ 2, 1 + top[1] + (bottom[1] - top[1]) \/\/ 2)","output":"quadratic"},{"instruction":"k=int(input())\na=[]\nfor i in range(0,12):\n    s=9*pow(10,i)*(i+1)\n    if k<=s:\n        break\n    else:\n        k-=s\npos=i+1\nnum=(pow(10,pos-1)+(k\/\/pos)-1)\nif k%pos==0:\n    print(str(num)[-1])\nelse:\n    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])","output":"constant"},{"instruction":"n = int(input())\nl = list(map(int, input().split(\" \")))\nl2 = list(map(int, input().split(\" \")))\ndp_1 = l2.copy()\ndp_2 = [9999999999]*n\ndp_3 = [9999999999]*n\nfor i in range(1, n):\n    for j in range(i):\n        if l[i] > l[j]:\n            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])\n\nfor i in range(1,n):\n    for j in range(i):\n        if l[i] > l[j]:\n            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])\n\nx = min(dp_3)\nif x == 9999999999:\n    print(-1)\nelse:\n    print(x)","output":"quadratic"},{"instruction":"n=int(input())\ns=list(input())\nt=list(input())\n\ncnt=0\nans=[]\nf1=0\nfor i in range(n):\n    if s[i]==t[i]:\n        continue\n    f=0\n    for j in range(i+1,n):\n        if s[j]==t[i]:\n            f=1\n            for k in range(j,i,-1):\n                s[k-1],s[k]=s[k],s[k-1]\n                ans.append(k)\n            break\n    if f==0:\n        print(-1)\n        exit()\n\nprint(len(ans))\nprint(*ans)","output":"quadratic"},{"instruction":"t=int(input())\nl=list(map(int,input().split()))\nb_sum=0\nl.sort()\nfor i in l:\n  b_sum += i\n\nm_sum=0\nc=0\nfor i in l[::-1]:\n  m_sum += i\n  c += 1\n  if m_sum > (b_sum\/2):\n    break\nprint(c)","output":"nlogn"},{"instruction":"l, r = [int(x) for x in input().split()]\n\nr = bin(r)[2:]\nl = bin(l)[2:]\n\nr = r[::-1]\nl = l[::-1]\n\nif l == r:\n    print(0)\nelse:\n\n    l += '0' * (len(r) - len(l))\n    p = -1\n    for i in range(len(r)):\n        if r[i] != l[i]:\n            p = i\n\n    a = '1' * p + '0'\n    b = '0' * p + '1'\n\n    print(int(a, 2) ^ int(b, 2))","output":"logn"},{"instruction":"import math\na, b = map(int, input().split())\nif a % b == 0:\n    print(int(a\/b))\nelse:\n    c = 0\n    while b:\n        c += a\/\/b\n        temp = a\n        a = b\n        b = temp % b\n    print(c)","output":"constant"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n\nmod = int(1e9) + 7\nINF=float('inf')\n\nn=int(data())\nl=mdata()\nc=mdata()\nd=dict()\nfor i in range(n):\n    if d.get(l[i]):\n        d[l[i]]=min(d[l[i]],c[i])\n    else:\n        d[l[i]]=c[i]\nfor i in l:\n    lis=list(d.keys())\n    for j in lis:\n        g = math.gcd(i, j)\n        if d.get(g):\n            d[g]=min(d[g],d[i]+d[j])\n        else:\n            d[g] = d[i] + d[j]\nif 1 in d:\n    out(d[1])\nelse:\n    out(-1)","output":"np"},{"instruction":"import math\n\nn, m, k = list(map(lambda i: int(i), input().split(sep=' ')))\np = list(map(lambda i: int(i), input().split(sep=' ')))\np.sort()\npage_max = k\naction_count = 0\nindex = 0\nwhile index < m:\n    while index < m and p[index] <= page_max:\n        count = 0\n        while index < m and p[index] <= page_max:\n            index += 1\n            count += 1\n        if count > 0:\n            action_count += 1\n        page_max += count\n\n    pc = 1 if index >= m else math.ceil((p[index] - page_max) \/ k)\n    page_max += k * pc\n\nprint(action_count)","output":"nlogn"},{"instruction":"n,d,k = [int(x) for x in input().strip().split(' ')]\nl = []\ni = 1\nif n<=d:\n\tprint(\"NO\")\nelif k==1:\n\tif n>2:\n\t\tprint(\"NO\")\n\telif n==2:\n\t\tprint(\"YES\")\n\t\tprint(1,2)\nelse:\n\tn+=1\n\tflag = False\n\twhile i<min(d+1,n):\n\t\tl.append(str(i)+\" \"+str(i+1))\n\t\ti+=1\n\ti+=1\n\tcnt1=0\n\tcnt2=1\n\tse=[[2,d+1,1]]\n\twhile cnt1<cnt2:\n\t\tstart = se[cnt1][0]\n\t\tend = se[cnt1][1]\n\t\tmode = se[cnt1][2]\n\n\t\tkk = 3\n\t\twhile (i<n) and (kk<=k):\n\t\t\tif i<n and not flag:\n\t\t\t\tj = start\n\n\t\t\t\twhile i<n and j<end:\n\t\t\t\t\tif mode==1:\n\t\t\t\t\t\tc = min(j-start+1,end-j)\n\t\t\t\t\telse:\n\t\t\t\t\t\tc = min(end-j,d-end+j)\n\t\t\t\t\tif c>1:\n\t\t\t\t\t\tse.append([i,i+c-1,2])\n\t\t\t\t\t\tcnt2+=1\n\t\t\t\t\tki=j\n\t\t\t\t\twhile i<n and c>0:\n\t\t\t\t\t\tl.append(str(ki)+\" \"+str(i))\n\n\t\t\t\t\t\tc-=1\n\t\t\t\t\t\tki=i\n\t\t\t\t\t\ti+=1\n\t\t\t\t\tj+=1\n\n\t\t\telse:\n\t\t\t\tflag = True\n\t\t\t\tbreak\n\t\t\tkk+=1\n\t\tcnt1+=1\n\tif i<n or flag:\n\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\tprint('\\n'.join(l))","output":"quadratic"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\nladder = abs(x - y) * t1\nelevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2\nif elevator > ladder:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")","output":"constant"},{"instruction":"import sys, collections\n\nn, k = map(int, sys.stdin.readline().split())\nleft = 0\nright = n + 1\nwhile left < right:\n    mid = (left + right) \/\/ 2\n    candy = n - mid\n    total = (candy * (candy + 1)) \/\/ 2 - mid\n    if total < k:\n        right = mid\n    elif total > k:\n        left = mid + 1\n    else:\n        print(mid)\n        break","output":"logn"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz\/\"\nM = 1000000007\nEPS = 1e-6\n\ndef Ceil(a, b):\n    return a \/\/ b + int(a % b > 0)\n\ndef value():\n    return tuple(map(int, input().split()))\n\ndef array():\n    return [int(i) for i in input().split()]\n\ndef Int():\n    return int(input())\n\ndef Str():\n    return input()\n\ndef arrayS():\n    return [i for i in input().split()]\n\nn = int(input())\ns = input()\nans = 0\ncnt = 0\nfor x in s:\n    if x == \"x\":\n        cnt += 1\n        if cnt >= 3:\n            ans += 1\n    else:\n        cnt = 0\nprint(ans)","output":"linear"},{"instruction":"turns = int(input())\ns0 = input()\ns1 = input()\ns2 = input()\n\nd0 = dict()\nd1 = dict()\nd2 = dict()\n\nalphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nfor char in alphabet:\n\td0[char] = 0\n\td1[char] = 0\n\td2[char] = 0\n\nfor char in s0:\n\td0[char] += 1\nfor char in s1:\n\td1[char] += 1\nfor char in s2:\n\td2[char] += 1\n\nm0 = max([d0[char] for char in alphabet])\nm1 = max([d1[char] for char in alphabet])\nm2 = max([d2[char] for char in alphabet])\n\nl0 = len(s0)\nl1 = len(s1)\nl2 = len(s2)\n\nif turns == 1 and m0 == l0:\n\tscore0 = m0 - 1\nelse:\n\tscore0 = min(l0,m0+turns)\n\nif turns == 1 and m1 == l1:\n\tscore1 = m1 - 1\nelse:\n\tscore1 = min(l1,m1+turns)\n\nif turns == 1 and m2 == l2:\n\tscore2 = m2 - 1\nelse:\n\tscore2 = min(l2,m2+turns)\n\nscores = [score0,score1,score2]\nbestscore = max(scores)\n\nwinnerlist = [i for i in range(3) if scores[i] == bestscore]\nif len(winnerlist) > 1:\n\tprint('Draw')\nelse:\n\tprint(['Kuro','Shiro','Katie'][winnerlist[0]])","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a,b,c,n = map(int,input().split())\n    if a+b-c > n-1 or min(a,b) < c:\n        print(-1)\n    else:\n        print(n-(a+b-c))\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"k1, k2, k3  = sorted(map(int, input().split()))\n\nif 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \\\n    or (k1 == 2 and k2 == 4 and k3 == 4):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"s=input()\nans=0\nm=set()\nfor i in range(len(s)):\n    for j in range(i,-1,-1):\n        if(s[j:i+1] in m):\n            ans=max(ans,i-j+1)\n        else:\n            m.add(s[j:i+1])\nprint(ans)","output":"cubic"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nimport functools\nimport random\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nEPS = 10**-12\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass CycleFindDirected(object):\n\n  def __init__(self, n):\n\n    self.n = n\n    self.adj = [[] for _ in range(n)]\n\n  def add_edge(self, u, v):\n\n    assert 0 <= u < self.n\n    assert 0 <= v < self.n\n    self.adj[u].append(v)\n\n  @bootstrap\n  def dfs(self, node):\n    self.color[node] = 1\n    for i in self.adj[node]:\n      if self.color[i] == 0:\n\n        self.parent[i] = node\n        if (yield self.dfs(i)):\n          yield True\n\n      elif self.color[i] == 1:\n        self.cycle_end = node\n        self.cycle_start = i\n        yield True\n\n    self.color[node] = 2\n    yield False\n\n  def find(self):\n    self.color = [0] * self.n\n    self.parent = [-1] * self.n\n    self.cycle_end = -1\n    self.cycle_start = -1\n\n    for i in range(self.n):\n      if not self.color[i] and self.dfs(i):\n        answer = []\n        node_begin = self.cycle_start\n        node_end = self.cycle_end\n        answer.append(node_begin)\n        while node_end != node_begin:\n          answer.append(node_end)\n          node_end = self.parent[node_end]\n\n        answer.reverse()\n        if len(answer) == 1:\n\n          return [node_begin, node_begin]\n        return answer\n\n    return None\n\ndef main(inp, out):\n\n  n, m = map(int, inp.rawInput().split())\n  edges = []\n  base = CycleFindDirected(n)\n  for _ in range(m):\n    u, v = map(int, inp.rawInput().split())\n    u -= 1\n    v -= 1\n    edges.append((u, v))\n    base.add_edge(u, v)\n\n  cycle = base.find()\n  if not cycle:\n    out.writeLine(\"YES\")\n    return\n\n  cycle.append(cycle[0])\n\n  bad_edges = set()\n  cycle_edges = []\n  for u, v in zip(cycle[:-1], cycle[1:]):\n    bad_edges.add((u, v))\n    cycle_edges.append((u, v))\n\n  cf = CycleFindDirected(n)\n  for edge in edges:\n    if edge not in bad_edges:\n      cf.add_edge(edge[0], edge[1])\n\n  for edge in cycle_edges:\n    for toadd in cycle_edges:\n      if toadd != edge:\n        cf.adj[toadd[0]].append(toadd[1])\n\n    if not cf.find():\n      out.writeLine('YES')\n      return\n\n    for toadd in cycle_edges:\n      if toadd != edge:\n        cf.adj[toadd[0]].pop()\n\n  out.writeLine('NO')\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"quadratic"},{"instruction":"import sys\nfrom operator import itemgetter\nreadline = sys.stdin.readline\n\ndef topological_sort(E, D):\n    D = D[:]\n    n = len(E)\n    Q = [i for i in range(n) if D[i] == 0]\n    L = []\n    while Q:\n        p = Q.pop()\n        L.append(p)\n        for vf in E[p]:\n            D[vf] -= 1\n            if not D[vf]:\n                Q.append(vf)\n\n    if len(L) != n:\n        return False\n    return L\n\nN, M = map(int, readline().split())\n\nEdge = [None]*M\nfor m in range(M):\n    a, b, c = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[m] = (c, m+1, a, b)\n\nEdge.sort(key = itemgetter(0), reverse = True)\n\nok = 0\nng = M+1\nwhile abs(ok-ng) > 1:\n    med = (ok+ng)\/\/2\n    Edge2 = [[] for _ in range(N)]\n    Dim2 = [0]*N\n    for i in range(med):\n        _, _, a, b = Edge[i]\n        Edge2[a].append(b)\n        Dim2[b] += 1\n    if topological_sort(Edge2, Dim2):\n        ok = med\n    else:\n        ng = med\n\nEdge2 = [[] for _ in range(N)]\nDim = [0]*N\nfor i in range(ok):\n    _, _, a, b = Edge[i]\n    Edge2[a].append(b)\n    Dim[b] += 1\n\nL = topological_sort(Edge2, Dim)\nLinv = [None]*N\nfor i in range(N):\n    Linv[L[i]] = i\n\nAns = []\nans = 0\nif ok < M:\n    ans = Edge[ok][0]\n    for i in range(ok, M):\n        c, m, a, b = Edge[i]\n        if Linv[a] > Linv[b]:\n            Ans.append(m)\nprint(ans, len(Ans))\nprint(*Ans)","output":"nlogn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn = int(input())\n*a, = map(int, input().split())\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(n - i + 1):\n        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]\nfor i in range(1, n):\n    for j in range(n - i):\n        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])\nfor i in range(int(input())):\n    l, r = map(int, input().split())\n    print(dp[r - l][l - 1])","output":"quadratic"},{"instruction":"a,b=list(map(int,input().split()))\nc,d=(((b+1)\/\/2)-1,(b-a-1))\nprint(c if d<0 else c-d if c>d else 0)","output":"constant"},{"instruction":"import sys\n\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n\nif __name__ == '__main__':\n\n    n,q = mi()\n    a = lmi()\n    i = 0\n    max_a = max(a)\n    t = a.index(max_a)\n    last = a[0]\n    Lis = []\n    tmp = []\n    for i in range(1, t + 1):\n        Lis.append((last,a[i]))\n        if last < a[i]:\n            tmp.append(last)\n            last = a[i]\n        else:\n            tmp.append(a[i])\n\n    anslist = a[t+1:] + tmp\n\n    for i in range(q):\n        tm = ii()\n        if 1 <= tm <= t:\n            print(Lis[tm - 1][0],Lis[tm - 1][1])\n        else:\n            print(max_a,anslist[(tm-t-1)%len(anslist)])","output":"linear"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\ndef main():\n\n\ta = input().split(\" \")\n\tn = int(a[0])\n\td = int(a[1])\n\tk = int(a[2])\n\n\tif d > n - 1:\n\t\tsys.stdout.write(\"NO\\n\")\n\t\treturn\n\n\tpar = [-1 for i in range(n)]\n\tprevlevel = [0]\n\tbad = [False for i in range(n)]\n\tclevel = []\n\tcdep = 1\n\tcallow = k\n\tcnode = 1\n\tfirstchild = 1\n\n\tfor i in range(1, n):\n\n\t\tif len(clevel) == callow:\n\t\t\tprevlevel = clevel\n\t\t\tclevel = []\n\t\t\tcdep += 1\n\t\t\tcallow *= (k - 1)\n\t\t\tfirstchild *= (k - 1)\n\n\t\tcdiv = k\n\t\tif cdep > 1:\n\t\t\tcdiv -= 1\n\t\tif cdiv == 0:\n\t\t\tsys.stdout.write(\"NO\\n\")\n\t\t\treturn\n\n\t\tpar[cnode] = prevlevel[len(clevel) \/\/ cdiv]\n\t\tclevel.append(cnode)\n\n\t\tcnode += 1\n\n\tmdep = d \/\/ 2\n\n\tif cdep > mdep + 1:\n\t\tsys.stdout.write(\"NO\\n\")\n\t\treturn\n\n\tif cdep == mdep + 1 and ((d % 2 == 0)):\n\t\tsys.stdout.write(\"NO\\n\")\n\t\treturn\n\n\tif cdep == mdep + 1 and len(clevel) > firstchild:\n\t\tsys.stdout.write(\"NO\\n\")\n\t\treturn\n\n\tattach1 = -1\n\tattach2 = -1\n\n\td1 = cdep\n\td2 = cdep\n\n\tattach1 = clevel[0]\n\tif len(clevel) > firstchild:\n\t\tattach2 = clevel[-1]\n\telse:\n\t\tattach2 = prevlevel[-1]\n\t\td2 -= 1\n\n\tte = attach1\n\twhile te != -1:\n\t\tbad[te] = True\n\t\tte = par[te]\n\tte = attach2\n\twhile te != -1:\n\t\tbad[te] = True\n\t\tte = par[te]\n\n\tcptr = n - 1\n\twhile d1 + d2 < d:\n\t\tif bad[cptr]:\n\t\t\tcptr -= 1\n\t\t\tcontinue\n\n\t\tif d2 < d1:\n\t\t\tpar[cptr] = attach2\n\t\t\tattach2 = cptr\n\t\t\td2 += 1\n\t\telse:\n\t\t\tpar[cptr] = attach1\n\t\t\tattach1 = cptr\n\t\t\td1 += 1\n\n\t\tcptr -= 1\n\n\tsys.stdout.write(\"YES\\n\")\n\tfor i in range(1, n):\n\t\tsys.stdout.write(str(i + 1) + \" \" + str(par[i] + 1) + \"\\n\")\n\nmain()","output":"quadratic"},{"instruction":"import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef main():\n\tn, m = mints()\n\tres = []\n\ta = [None]*n\n\tl = [None]*n\n\tr = [None]*n\n\ts = [0]*n\n\tfor i in range(n):\n\t\ta[i] = list(minp())\n\t\tl[i] = [i for i in range(m)]\n\t\tr[i] = [i for i in range(m)]\n\t\ts[i] = [0]*m\n\tfor i in range(n):\n\t\tj = 0\n\t\tb = a[i]\n\t\tll = l[i]\n\t\trr = r[i]\n\t\twhile j < m:\n\t\t\tif b[j] == '*':\n\t\t\t\tjj = j+1\n\t\t\t\twhile jj < m and b[jj] == '*':\n\t\t\t\t\tjj += 1\n\t\t\t\tjj -= 1\n\t\t\t\tfor k in range(j,jj+1):\n\t\t\t\t\tll[k] = j\n\t\t\t\t\trr[k] = jj\n\t\t\t\tj = jj + 1\n\t\t\telse:\n\t\t\t\tj += 1\n\tfor i in range(m):\n\t\tj = 0\n\t\twhile j < n:\n\t\t\tif a[j][i] == '*':\n\t\t\t\tjj = j+1\n\t\t\t\twhile jj < n and a[jj][i] == '*':\n\t\t\t\t\tjj += 1\n\t\t\t\tjj -= 1\n\t\t\t\tfor k in range(j,jj+1):\n\t\t\t\t\tx = min(i-l[k][i],r[k][i]-i,k-j,jj-k)\n\t\t\t\t\ts[k][i] = x\n\t\t\t\t\tif x > 0:\n\t\t\t\t\t\tres.append((k+1,i+1,x))\n\t\t\t\tj = jj + 1\n\t\t\telse:\n\t\t\t\tj += 1\n\tfor i in range(n):\n\t\tj = 0\n\t\tss = s[i]\n\t\trr = r[i]\n\t\tc = -1\n\t\twhile j < m:\n\t\t\tif ss[j] > 0 and c < ss[j]:\n\t\t\t\tc = ss[j]\n\t\t\tif c >= 0:\n\t\t\t\trr[j] = '*'\n\t\t\telse:\n\t\t\t\trr[j] = '.'\n\t\t\tj += 1\n\t\t\tc -= 1\n\t\tj = m-1\n\t\tc = -1\n\t\twhile j >=0:\n\t\t\tif ss[j] > 0 and c < ss[j]:\n\t\t\t\tc = ss[j]\n\t\t\tif c >= 0:\n\t\t\t\trr[j] = '*'\n\t\t\tc -= 1\n\t\t\tj -= 1\n\tfor i in range(m):\n\t\tj = 0\n\t\tc = -1\n\t\twhile j < n:\n\t\t\tx = s[j][i]\n\t\t\tif x > 0 and c < x:\n\t\t\t\tc = x\n\t\t\tif c >= 0:\n\t\t\t\tr[j][i] = '*'\n\t\t\tj += 1\n\t\t\tc -= 1\n\t\tj = n-1\n\t\tc = -1\n\t\twhile j >=0:\n\t\t\tx = s[j][i]\n\t\t\tif x > 0 and c < x:\n\t\t\t\tc = x\n\t\t\tif c >= 0:\n\t\t\t\tr[j][i] = '*'\n\t\t\tif r[j][i] != a[j][i]:\n\t\t\t\tprint(-1)\n\t\t\t\texit(0)\n\t\t\tc -= 1\n\t\t\tj -= 1\n\tprint(len(res))\n\tfor i in res:\n\t\tprint(*i)\nmain()","output":"quadratic"},{"instruction":"M=10**9+7\ndef pw(x,y):\n\tr=1\n\tx=x%M\n\twhile y:\n\t\tif y&1:\n\t\t\tr=(r*x)%M\n\t\ty=y>>1\n\t\tx=(x*x)%M\n\treturn r\nx,k=map(int,input().split())\nans=pw(2,k+1)*x-pw(2,k)+1+M\nif x==0:\n\tans=0\nprint(ans%M)","output":"logn"},{"instruction":"M = 10**9+7\nx,k=[int(i) for i in input().split()]\nif(x==0):\n    print(0)\nelif(k==0):\n    print((x*2)%M)\nelse:\n    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1\n    print(top_sum%M)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\nq = int(input())\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    R, G, B = 0, 0, 0\n    ans = float('inf')\n    for j in range(n):\n        if j % 3 == 0:\n            if s[j] == 'R':\n                G += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                B += 1\n            else:\n                R += 1\n                G += 1\n        elif j % 3 == 1:\n            if s[j] == 'R':\n                G += 1\n                R += 1\n            elif s[j] == 'G':\n                G += 1\n                B += 1\n            else:\n                R += 1\n                B += 1\n        else:\n            if s[j] == 'R':\n                R += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                G += 1\n            else:\n                G += 1\n                B += 1\n        if j >= k - 1:\n            ans = min(ans, R, G, B)\n            if (j - k + 1) % 3 == 0:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    G -= 1\n            elif (j - k + 1) % 3 == 1:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    R -= 1\n                elif s[j - k + 1] == 'G':\n                    G -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    B -= 1\n            else:\n                if s[j - k + 1] == 'R':\n                    R -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    G -= 1\n                else:\n                    G -= 1\n                    B -= 1\n\n    print(ans)","output":"linear"},{"instruction":"t=int(input())\ng=list(map(int,input().split()))\nk=max(g)\nflag=True\ni=0\nwhile g[i]!=k:\n    if i!=0 and g[i]<g[i-1]:\n        print(\"NO\")\n        exit()\n    i+=1\ni+=1\nwhile i<t and g[i]!=k:\n    if i!=0 and g[i]>g[i-1]:\n        print(\"NO\")\n        exit()\n    i+=1\nprint(\"YES\")","output":"linear"},{"instruction":"n,m=map(int,input().split())\ns=input()\nt=input()\nif n==1:\n\tif s==t or s=='*':\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif s.count('*')==0:\n\tif s==t:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif n>m+1:\n\tprint('NO')\nelse:\n\tl=s.split('*')\n\tx=t[:len(l[0])]\n\ty=t[-len(l[1]):]\n\tif (l[0]==x and l[1]==y) or (s[:1]=='*' and l[1]==y) or (l[0]==x and s[-1:]=='*'):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')","output":"linear"},{"instruction":"from itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N)\n    pres = [None]*(1<<N)\n    allb = (1 << N)-1\n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0]\n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\nif __name__ == '__main__':\n    import sys\n    st = time()\n    main()\n    print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)","output":"np"},{"instruction":"n,k=map(int,input().split())\nl=input()\nl=sorted(l)\nans=l[0]\nsum=ord(l[0])\nindex=0\nfor j in range(1,n):\n    if len(ans)<k:\n        if ord(l[j])-ord(l[index])>1:\n            ans=ans+l[j]\n            sum=sum+ord(l[j])\n            index=j\n    else:\n        break\nif len(ans)==k:\n    sum=sum-96*k\n    print(sum)\nelse:\n    print(-1)","output":"linear"},{"instruction":"n, m = map(int, input().split())\n\na = []\nb = []\n\nif n <= 8:\n    a = [4]\n    b = [5]\n\nwhile n > 8:\n    a += [4,5]\n    b += [5,4]\n    n -= 8\n\nprint(*a + [5], sep=\"\")\nprint(*b + [5], sep=\"\")","output":"constant"},{"instruction":"import math\n\ndef gaosi(x):\n    if (x==1):\n        return 1\n    else:\n        return ((1+x)*x)\/2\n\ndef calc(mid, total, left):\n    return gaosi(mid) - (total - mid) - left\n\ndef main():\n    x, left = map(int, input().split())\n    if (x == 1 and left == 1):\n        print(0)\n    else:\n        l = 1\n        r = x\n        while (True):\n            mid = math.floor((l + r) \/ 2)\n            result = calc(mid, x, left)\n            if (result == 0):\n                print(x - mid)\n                break\n            elif (result > 0):\n                r = mid\n            elif (result  < left):\n                l = mid\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"def getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\n\nfrom collections import deque\n\nn, m = getList()\nnums = getList()\nmxnum = max(nums)\nd = deque(nums)\n\nqr = []\nfor i in range(m):\n    qr.append(getN())\n\nlog = []\n\nrot = 0\nwhile(True):\n\n    a = d.popleft()\n    b = d.popleft()\n    log.append((a, b))\n    if a > b:\n        a, b = b, a\n\n    d.append(a)\n    d.appendleft(b)\n\n    rot += 1\n\n    if b == mxnum:\n        break\n\nfor q in qr:\n    if q <= rot:\n        print(log[q - 1][0], log[q - 1][1])\n    else:\n        res = q -  rot - 1\n        print(b, d[res % (n-1) + 1  ])","output":"linear"},{"instruction":"import math,io,os,sys\n\nn,s=map(int,input().split())\nc=0\ni=n\nfor i in range(s,min(s+1000,n+1)):\n    if i-sum(map(int,str(i)))>=s:\n        c+=1\nc+=max(0,n-i)\nprint(c)","output":"logn"},{"instruction":"n, k = map(int, input().split())\nl = list(map(int, input().split()))\n\no = 2\nfor i in range(n):\n    if i+1 == n:\n        break\n\n    d = abs(l[i] - l[i+1]) \/ k\n    if d ==  2:\n        o += 1\n    elif d > 2:\n        o += 2\n\nprint(o)","output":"linear"},{"instruction":"t=int(input())\nfor ca in range(t):\n    asd=input().split()\n    n=int(asd[0])\n    k=int(asd[1])\n    if n>=40:\n        print(\"YES \"+str(n-1))\n    else:\n        ans=-1\n        for m in range(1,n+1):\n            asd=(4**m-1)\/\/3\n            asd2=(2**m-1)**2\n            asd2*=(4**(n-m)-1)\/\/3\n            asd+=asd2\n            if asd>=k and m*m<=k:\n                ans=n-m\n                break\n        if ans==-1:\n            print(\"NO\")\n        else:\n            print(\"YES \"+str(ans))","output":"logn"},{"instruction":"from sys import stdin\n\ndef iinput(): return int(stdin.readline())\ndef minput(): return map(int, stdin.readline().split())\ndef linput(): return list(map(int, stdin.readline().split()))\n\nn, k = minput()\nl, r = 0, n\nwhile l<r:\n    mid = (l+r)\/\/2\n    if ((n-mid)*(n-mid+1))\/\/2 - mid == k:\n        print(mid)\n        break\n    elif ((n-mid)*(n-mid+1))\/\/2 - mid > k:\n        l = mid\n    else:\n        r = mid","output":"logn"},{"instruction":"pfs=[i*i for i in range(1,3163)]\np=[i for i in range(0,10000001)]\nfor i in range(1,10000001):\n    if(p[i]==i):\n        for j in pfs:\n            if(i*j>10000000): break\n            p[i*j]=i\nt=int(input())\nfor lll in range(0,t):\n    n,k=map(int,input().split())\n    zc=list(map(int,input().split()))\n    s=[p[zc[i]] for i in range(0,len(zc))]\n    dp=[n]*(k+1)\n    dp[0]=1\n    ys=[{}]*(n+1)\n    for i in range(0,len(s)):\n        for j in range(k,-1,-1):\n            if(dp[j]==n): continue\n            if(ys[j].get(s[i],-1)!=-1):\n                if(j<k and dp[j]<dp[j+1]):\n                    dp[j+1]=dp[j]\n                    ys[j+1]=ys[j]\n                dp[j]+=1\n                ys[j]={}\n            ys[j][s[i]]=1\n    print(min(dp))","output":"cubic"},{"instruction":"n,m=map(int,input().split())\nlist1=list(map(int,input().split()))\nlist2=list(map(int,input().split()))\nfor i in list1:\n    if i in list2:\n        print(i,end=' ')","output":"quadratic"},{"instruction":"q = int(input())\n\nfor i in range(q):\n    (x, y, k) = map(int, input().split())\n\n    if max(x, y) > k:\n        print(-1)\n    elif x == y and k == x + 1:\n        print(k - 2)\n        continue\n    elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0:\n        print(k - 2)\n        continue\n    elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1:\n        print(k - 2)\n        continue\n    elif (x + y) % 2 == 0:\n        print(k)\n    else:\n        print(k - 1)","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nmxm=sys.maxsize\n\ndef solve(p,q,r):\n\n    if p<0 or p>=n or q<0 or q>=m:\n        return mxm\n\n    if dp[r][p][q]!=-1:\n        return dp[r][p][q]\n\n    if r==0:\n        return 0\n\n    z=int()\n    a,b,c,d=0,0,0,0\n    a=dp[r-1][p][q-1]\n    b=dp[r-1][p][q+1]\n    c=dp[r-1][p-1][q]\n    d=dp[r-1][p+1][q]\n\n    if a==-1:\n        a=row[p][q-1]+solve(p,q-1,r-1)\n    else:\n        a+=row[p][q-1]\n\n    if b==-1:\n        b=row[p][q]+solve(p,q+1,r-1)\n    else:\n        b+=row[p][q]\n\n    if c==-1:\n        c=col[p-1][q]+solve(p-1,q,r-1)\n    else:\n        c+=col[p-1][q]\n\n    if d==-1:\n        d=col[p][q]+solve(p+1,q,r-1)\n    else:\n        d+=col[p][q]\n\n    z=min([a,b,c,d])\n\n    dp[r][p][q]=z\n    return z\n\nn,m,k=map(int,input().split())\nrow=[]\ncol=[]\nfor i in range(n):\n\n    row.append(list(map(int,input().split()))+[0])\n\nfor _ in range(n-1):\n\n    col.append(list(map(int,input().split())))\n\ncol.append([0 for i in range(m)])\n\nans=[[-1 for _ in range(m)] for _ in range(n)]\n\ndp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]\n\ndef main():\n\n    if k%2:\n        for item in ans:\n            print(*item)\n        exit()\n\n    for r in range(n):\n        for c in range(m):\n            ans[r][c]=2*solve(r,c,k\/\/2)\n\n    for item in ans:\n        print(*item)\n\ndef nouse0():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\ndef nouse1():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\ndef nouse2():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\ndef nouse3():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\ndef nouse4():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\ndef nouse5():\n\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)\/\/2}')\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"k = int(input())\nprev=0\nnextt=0\nNumofDigits=0\n\nwhile(True):\n    prev = nextt\n    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)\n    if(k>= prev and k<=nextt):\n        break\n    NumofDigits=NumofDigits+1\nif(NumofDigits==1):\n    print(k)\nelse:\n    result = (10**(NumofDigits-1))+int((k-(prev+1))\/NumofDigits)\n    i=0\n    while(True):\n        if (k-int(prev+1))%NumofDigits == i:\n            break\n        i=i+1\n    result = str(result)\n    print(result[i])","output":"logn"},{"instruction":"n = int(input())\n\nax, ay = list(map(int, input().split()))\nbx, by = list(map(int, input().split()))\ncx, cy = list(map(int, input().split()))\n\nx = [ax, bx, cx]\ny = [ay, by, cy]\n\nx.sort()\ny.sort()\n\nif (x[1] != ax) and (y[1] != ay):\n        print('YES')\nelse:\n        print('NO')","output":"constant"},{"instruction":"a=input()\nn=len(a)\nfor i in range(n-1,-1,-1):\n    b=sorted([a[j:j+i] for j in range(n-i+1)])\n    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:\n        print(i)\n        break","output":"cubic"},{"instruction":"n=int(input())\nprint((n\/\/2)+1)","output":"constant"},{"instruction":"import sys\n\nn, k = [int(i) for i in sys.stdin.readline().split()]\n\nleft = 0\nright = n - 1\n\nwhile left <=  right:\n    mid = left + (right - left)\/\/2\n    fmid = (mid+1)*(mid +2)\/2  - (n  - (mid + 1))\n    if fmid == k:\n\n        print(n - 1 - mid )\n    if fmid > k:\n        right = mid - 1\n    else:\n        left = mid + 1","output":"logn"},{"instruction":"def bina(bi):\n    binary1 = bi\n    decimal, i, n = 0, 0, 0\n    while(bi != 0):\n        dec = bi % 10\n        decimal = decimal + dec * pow(2, i)\n        bi = bi\/\/10\n        i += 1\n    return decimal\ndef con(n):\n   return bin(n).replace(\"0b\", \"\")\nl,r=map(int,input().split())\nk=con(l)\nm=con(r)\nk=list(str(k))\nm=list(str(m))\nj=len(m)-len(k)\nk=['0']*j + k\n\nc=0\nfor i in range(len(m)):\n    if k[i]!=m[i]:\n        c=1\n    if k[i]==m[i] and k[i]=='1' and c==1:\n        k[i]='0'\n    elif k[i]==m[i] and k[i]=='0' and c==1:\n        k[i]='1'\nk=int(''.join(k))\nm=int(''.join(m))\nprint(bina(k)^bina(m))","output":"logn"},{"instruction":"l,r=map(int,input().split())\nfor i in range(61)[::-1]:\n  if (l>>i)&1!=(r>>i)&1:\n    print((1<<(i+1))-1)\n    exit()\nprint(0)","output":"logn"},{"instruction":"import math\n\ndef find_nCr(n, r):\n\treturn (math.factorial(n) \/ (math.factorial(r)*math.factorial(n-r)) )\n\nsent = input()\nreceived = input()\n\nfinal_pos = 0\ncurrent_pos = 0\nuncertain = 0\n\nfor s in sent:\n\tif s == \"+\":\n\t\tfinal_pos += 1\n\telse:\n\t\tfinal_pos -= 1\n\nfor s in received:\n\tif s == \"+\":\n\t\tcurrent_pos += 1\n\telif s == \"-\":\n\t\tcurrent_pos -= 1\n\telse:\n\t\tuncertain += 1\n\nif uncertain == 0:\n\tif final_pos == current_pos:\n\t\tprint(1)\n\telse:\n\t\tprint(0)\nelse:\n\n\tpositions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2))\n\n\ttry:\n\t\tpos_index = positions.index(final_pos)\n\t\ta = find_nCr(uncertain, pos_index)\n\t\tb = math.pow(2, uncertain)\n\t\tprint(a\/b)\n\texcept:\n\t\tpos_index = -1\n\t\tprint(0)","output":"np"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 998244353;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    B();\n\ndp = [];\ndef D():\n    [n,k] = ti();\n    a = ti();\n    a = sorted(a);\n    cnt = [0 for i in range(n)];\n    for i in range(n):\n        c = 0;\n        for j in range(i,n):\n            if a[j]-a[i] <= 5: c+=1;\n            else:break;\n        cnt[i] = c;\n\n    global dp;\n    dp = [[0 for j in range(k+1)] for i in range(n+1)];\n    ans = 0;\n    for i in range(n):\n        for j in range(k+1):\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n            if j+1 <= k:\n                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);\n    print(dp[n][k]);\n\ndef B():\n    n = pi();\n    a = ti();\n    q = pi();\n\n    mat = [[0 for j in range(n)] for i in range(n)];\n    dp = [[0 for i in range(n)] for j in range(n)];\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                mat[i][j] = a[i];\n                dp[i][j] = a[i];\n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];\n            j += 1;\n            i += 1;\n        x += 1;\n\n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);\n            j += 1;\n            i += 1;\n        x += 1;\n\n    for i in range(q):\n        [l,r] = ti();\n        print(dp[l-1][r-1]);\n\nmain();","output":"quadratic"},{"instruction":"from sys import stdin\n\nEPS = 1e-6\nn = int(stdin.readline())\nm = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\nb = list(map(int, stdin.readline().split()))\nb.append(b[0])\n\ndef check(f):\n    fuel_left = f\n    total_weight = float(m + fuel_left)\n    for i in range(n):\n        cost = total_weight \/ a[i]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n\n        cost = total_weight \/ b[i + 1]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n        if fuel_left < 0:\n            return False\n    return True\n\ndef binary_search(left, right):\n    mid = (left + right) \/ 2\n    if abs(left - right) < EPS:\n        return mid\n    if check(mid):\n        return binary_search(left, mid)\n    else:\n        return binary_search(mid, right)\n\nres = binary_search(0, 1e9 + 1)\n\nif res - 1e9 > EPS:\n    print(-1)\nelse:\n    print(\"%.10f\" % res)","output":"linear"},{"instruction":"s = input()\nslen = len(s)\nans = 0\nfor st1 in range(slen - 1):\n    for end1 in range(st1 + 1, slen):\n        end2 = end1 + 1\n        sub1 = s[st1:end1]\n        for st2 in range(st1 + 1, slen):\n            if end2 > slen:\n                break\n\n            sub2 = s[st2:end2]\n            subLen = len(sub1)\n            if sub1 == sub2 and ans < subLen:\n                ans = subLen\n            end2 += 1\n\nprint(ans)","output":"cubic"},{"instruction":"a,b=map(int,input().split(' '))\nprint((b+a-1)\/\/a)","output":"constant"},{"instruction":"N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp = defaultdict(lambda :-1)\nfor i in range(N):\n    dp[i+1001] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp[j+1001*k], dp[j+k+1001*(i-k)]\n            if u == -1 or v == -1 or u != v:\n                continue\n            dp[j+1001*i] = u+1;break\n\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    if dp[1001*(i+1)] != -1:\n        dp2[i+1] = 1\n        continue\n    for j in range(i+1):\n        if dp[j+(i+1-j)*1001] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])","output":"cubic"},{"instruction":"from collections import defaultdict\n\nn, k = map(int, input().split())\n\nconnections = defaultdict(set)\n\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tconnections[u].add(v)\n\tconnections[v].add(u)\n\nleafs = set()\nfor node in connections:\n\tif len(connections[node])==1:\n\t\tleafs.add(node)\n\nsteps = 0\nis_correct = True\nwhile is_correct and steps<=k:\n\tnew_leafs = set()\n\tfor x in leafs:\n\t\tif len(connections[x])>1:\n\t\t\tis_correct = False\n\n\t\t\tbreak\n\t\troot = list(connections[x])[0]\n\t\tif len(connections[root])<4 and len(leafs)!=3:\n\t\t\tis_correct = False\n\n\t\t\tbreak\n\tif not is_correct:\n\t\tbreak\n\tfor x in leafs:\n\t\troot = list(connections[x])[0]\n\t\tnew_leafs.add(root)\n\t\tconnections[root].remove(x)\n\tleafs = new_leafs\n\tsteps += 1\n\tif len(leafs)==1 and len(connections[list(leafs)[0]])==0:\n\t\tbreak\n\nif is_correct and steps==k:\n\tprint(\"Yes\")\nelse:\n\tprint('No')","output":"nlogn"},{"instruction":"x,k=map(int,input().split())\nif x==0:print(\"0\")\nelse:\n    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)\n    print(ans)","output":"logn"},{"instruction":"X, K = map(int, input().split())\nmod = 1000000007\nres = X*pow(2, K+1, mod)-pow(2, K, mod)+1;\nwhile(res < 0):\n   res += mod\nif(X == 0):\n   print(0)\nelse:\n   print(res%mod)","output":"logn"},{"instruction":"n, m = list(map(int,input().split()))\np = list(map(int,input().split()))\nmindex = p.index(m)\nldict = {}\nrdict = {}\ndiff = 0\nans = 0\nldict[0] = 1\nrdict[0] = 1\nfor i in range(mindex-1,-1,-1):\n\tif p[i] < m:\n\t\tdiff-=1\n\telse:\n\t\tdiff+=1\n\tif diff in ldict.keys():\n\t\tldict[diff] += 1\n\telse:\n\t\tldict[diff] = 1\ndiff = 0\nfor i in range(mindex+1,n):\n\tif p[i] < m:\n\t\tdiff-=1\n\telse:\n\t\tdiff+=1\n\tif diff in rdict.keys():\n\t\trdict[diff] += 1\n\telse:\n\t\trdict[diff] = 1\nldictkey = ldict.keys()\nfor num in ldictkey:\n\tif -num in rdict.keys():\n\t\tans += ldict[num] * rdict[-num]\n\tif -num+1 in rdict.keys():\n\t\tans += ldict[num] * rdict[-num+1]\nprint(ans)","output":"nlogn"},{"instruction":"MOD = 10 ** 9 + 7\n\nx, k = map(int, input().split())\nprint(((2 * x - 1) * pow(2, k, MOD) + 1) % MOD if x else 0)","output":"logn"},{"instruction":"a,b,c,d,e,f=map(int,input().split())\nif a<b:a,b=b,a\nif c<d:c,d=d,c\nif e<f:e,f=f,e\nsides=[[a,b,'A'],[c,d,'B'],[e,f,'C']]\nsides.sort(reverse=True)\nc1,c2,c3=sides[0][2],sides[1][2],sides[2][2]\narea=a*b+c*d+e*f\nif int(area**0.5)**2!=area:\n\tprint(-1)\nelse:\n\tl=int(area**0.5)\n\tif l not in sides[0]:\n\t\tprint(-1)\n\telif l in sides[1] and l in sides[2]:\n\t\tprint(l)\n\t\tfor i in range(3):sides[i].remove(l)\n\t\tfor i in range(3):\n\t\t\tfor _ in range(sides[i][0]):\n\t\t\t\tprint([c1,c2,c3][i]*l)\n\telse:\n\t\tr=l-sides[0][1]\n\t\tif r in sides[1] and r in sides[2]:\n\t\t\tprint(l)\n\t\t\tfor i in range(1,3):sides[i].remove(r)\n\t\t\tfor _ in range(sides[0][1]):\n\t\t\t\tprint(c1*l)\n\t\t\tfor _ in range(r):\n\t\t\t\tprint(c2*sides[1][0]+c3*sides[2][0])\n\t\telse:\n\t\t\tprint(-1)","output":"np"},{"instruction":"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()]\nx11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()]\n\nmin_x1 = min(x1, x2, x3, x4)\nmin_y1 = min(y1, y2, y3, y4)\nmax_x1 = max(x1, x2, x3, x4)\nmax_y1 = max(y1, y2, y3, y4)\n\nmin_x11 = min(x11, x22, x33, x44)\nmin_y11 = min(y11, y22, y33, y44)\nmax_x11 = max(x11, x22, x33, x44)\nmax_y11 = max(y11, y22, y33, y44)\n\na = (max_x11 + min_x11) \/ 2\nb = (max_y11 + min_y11) \/ 2\nd2 = (max_x11 - min_x11) \/ 2\n\nfor x in range(min_x1, max_x1 + 1):\n    for y in range(min_y1, max_y1 + 1):\n        if abs(x - a) + abs(y - b) <= d2:\n            print(\"yes\")\n            exit(0)\nprint(\"no\")","output":"constant"},{"instruction":"import itertools\n\nn, l, r, x = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\n\ncounter = 0\nfor i, val in enumerate([\"\".join(seq) for seq in itertools.product(\"01\", repeat=n)]):\n    if val.count('1') < 2:\n        continue\n    dif = 0; mx = float(\"-inf\"); mn = float(\"inf\")\n    for i, bit in enumerate(val):\n        if bit == '1':\n            dif += c[i]\n            mx = max(c[i], mx)\n            mn = min(c[i], mn)\n    if l <= dif <= r and  mx - mn >= x:\n        counter += 1\n\nprint(counter)","output":"np"},{"instruction":"n = int(input())\na = input()\nb = input()\n\nc = [10**10 for i in range(n + 10)]\n\nc[0] = 0 if a[0] == b[0] else 1\n\nfor i in range(1, n):\n    if a[i] == b[i]:\n        c[i] = c[i - 1]\n    elif a[i] == b[i - 1] and a[i - 1] == b[i]:\n        c[i] = (1 + c[i - 2] if i > 1 else 1)\n    c[i] = min(c[i], c[i - 1] + 1)\n\nprint(c[n - 1])","output":"linear"},{"instruction":"n, m, q = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\ndp = [[[0] * 201 for _ in range(201)] for _ in range(201)]\nfor ijk in range(n + m + q + 1):\n    for i in range(min(n + 1, ijk + 1)):\n        for j in range(min(m + 1, ijk - i + 1)):\n            k = ijk - i - j\n            if k < 0 or k > q:\n                continue\n            if i + 1 <= n:\n                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])\n            if j + 1 <= m:\n                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])\n            if k + 1 <= q:\n                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])\n            if i + 1 <= n and j + 1 <= m:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])\n            if i + 1 <= n and k + 1 <= q:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])\n            if j + 1 <= m and k + 1 <= q:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])\nprint(dp[n][m][q])","output":"cubic"},{"instruction":"from sys import stdin,stdout\ninput=stdin.readline\nfor _ in range(int(input())):\n    x=10**5\n    n,k=map(int,input().split())\n    s=input()\n    ans=10**9\n    for i in range(n-k+1):\n        x=s[i:i+k]\n        m=0\n        curr=['R','G','B']\n        for l in range(3):\n            m=0\n            z=l\n            for j in x:\n                if j!=curr[z]:\n                    m+=1\n                z+=1\n                z%=3\n            ans=min(ans,m)\n    print(ans)","output":"quadratic"},{"instruction":"import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):\n        d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"n,k=map(int,input().split())\np=list(map(int,input().split()))\n\narr=[[] for i in range(256)]\nans=[]\nfor i in p:\n    j=i\n    if len(arr[i])==0:\n        c=0\n        while c<k and j>=0:\n            if len(arr[j])+c>k:\n                break\n\n            if len(arr[j])!=0:\n                arr[i].extend(arr[j])\n                break\n            arr[j]=arr[i]\n            arr[j].append(j)\n            j-=1\n            c+=1\n        arr[i].sort()\n    ans.append(arr[i][0])\nprint(*ans)","output":"quadratic"},{"instruction":"M = 998244353\nn = int(input())\nl = sorted(map(int, input().split()))[::-1]\nout = [0] * n\nbig = 0\nif l[0] >= 2 * l[1]:\n    out[1] = 1\n    big = 1\nfor i in range(2, n):\n    new = [0] * n\n    bigN = 0\n    for j in range(i):\n        if l[j] >= 2 * l[i]:\n            big += out[j]\n        else:\n            new[j] += out[j] * (i - 1)\n            new[j] %= M\n\n    new[i] = big\n    bigN = (i * big) % M\n\n    out = new\n    big = bigN\nprint((big + sum(out))%M)","output":"cubic"},{"instruction":"class Solution:\n    def reverse(self, x: int) -> int:\n        org = x\n        x = abs(x)\n        res = int(str(x)[::-1])\n        if org < 0:\n            res *= -1\n        if res < -(1 << 31) or res > (1 << 31) - 1:\n            return 0\n        return res","output":"constant"},{"instruction":"import math\n\ndef solutions(a,b,c):\n    d = (b**2) - (4*a*c)\n    sol1 = (-b-math.sqrt(d))\/(2*a)\n    sol2 = (-b+math.sqrt(d))\/(2*a)\n    if sol1<0 and sol2>0:\n        return sol2\n    elif sol1>0 and sol2<0:\n        return sol1\n    else:\n        return 0\n\nx = input()\nx=x.split(\" \")\nc = int(x[0])\nm = int(x[1])\n\nprint(int(c-solutions(1,3,-(2*c+2*m))))","output":"logn"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\n\nINF = 10**3\ndp = [[INF]*(n+1) for _ in range(n+1)]\n\nval = [[0]*(n+1) for _ in range(n+1)]\n\nfor i in range(n):\n    dp[i][i+1] = 1\n\nfor i in range(n):\n    val[i][i+1] = A[i]\n\nfor d in range(2, n+1):\n    for i in range(n+1-d):\n        j = i+d\n        for k in range(i+1, j):\n            if dp[i][k] == 1 and dp[k][j] == 1 and val[i][k] == val[k][j]:\n                dp[i][j] = min(dp[i][j], 1)\n                val[i][j] = val[i][k]+1\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])\n\nprint(dp[0][n])","output":"cubic"},{"instruction":"n = int(input())\nd = list(map(int, input().split()))\nodd = 0\nfor i in range(n):\n    for j in range(i, n):\n        if(d[i]>d[j]): odd ^= 1\n\nm = int(input())\nans = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    k = r-l+1\n    if( (k*(k-1)\/2) %2): odd ^= 1\n    ans.append( \"odd\" if odd else \"even\")\n\nprint('\\n'.join(ans))","output":"quadratic"},{"instruction":"n = int(input())\nprint(25)","output":"constant"},{"instruction":"import sys\n\nmod=(10**9)+7\n\nfrom sys import stdin, stdout\nimport bisect\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport collections\nimport math\nimport heapq\nfrom random import randint as rn\nfrom Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():\n    return map(int,sin().split())\ndef sin():\n    return stdin.readline().strip()\ndef GCD(x,y):\n    while(y):\n        x, y = y, x % y\n    return x\ndef isprime(x):\n    if(x==1):\n        return False\n    elif(x<4):\n        return True\n    for i in range(2,int(math.sqrt(x))+1):\n        if(x%i==0):\n            return False\n    return True\n\nn,q=ain()\na=ain()\ng=max(a)\nd=collections.deque(a)\nf=0\nan1=[]\nwhile(d[0]!=g):\n    f+=1\n    x=d.popleft()\n    y=d.popleft()\n    an1.append(str(x)+\" \"+str(y))\n    if(y==g):\n        d.appendleft(y)\n        d.append(x)\n        break\n    if(x<y):\n        d.appendleft(y)\n        d.append(x)\n    else:\n        d.appendleft(x)\n        d.append(y)\nr=[]\nans=[]\nfor i in range(n):\n    r.append(str(d.popleft()))\nfor i in range(q):\n    b=int(sin())\n    if(b<=f):\n        ans.append(an1[b-1])\n    else:\n        b-=f\n        b-=1\n        b%=(n-1)\n        ans.append(r[0]+\" \"+r[b+1])\nstdout.write(\"\\n\".join(ans))","output":"linear"},{"instruction":"import sys\nimport io, os\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nA = [input().rstrip() for i in range(n)]\nC = [0]*m\nfor i in range(n):\n    a = A[i]\n    for j, c in enumerate(a):\n        C[j] += int(c)\n\nfor i in range(n):\n    a = A[i]\n    for j, c in enumerate(a):\n        C[j] -= int(c)\n    for j in range(m):\n        if C[j] == 0:\n            break\n    else:\n        print('YES')\n        exit()\n        continue\n    for j, c in enumerate(a):\n        C[j] += int(c)\nprint('NO')","output":"quadratic"},{"instruction":"def solve():\n  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n  for i in range(r+1):\n    for j in range(g+1):\n      for k in range(b+1):\n        if i+j+k<2:continue\n        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])\n        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])\n        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])\n  return dp[r][g][b]\nprint(solve())","output":"cubic"},{"instruction":"def factorial(n):\n    if n<=1:\n        return 1\n    return n*factorial(n-1)\n\noriginal = input()\nreceived = input()\n\noriginalNum = original.count('+') - original.count('-')\nreceivedNum = received.count('+') - received.count('-')\n\nvariance = received.count('?')\n\ndifference = abs(originalNum - receivedNum)\n\nif variance==0:\n    if difference==0:\n        print(1.)\n    else:\n        print(0.)\nelif difference > variance or difference%2!=variance%2:\n    print(0.)\nelse:\n    difference += variance\n    difference\/\/=2\n\n    c = factorial(variance)\/(factorial(difference)*factorial(variance-difference))\n    print(c\/(2**variance))","output":"np"},{"instruction":"n,s = map(int,input().split())\n\nif s%n==0:\n\tprint(s\/\/n)\nelse:\n\tprint(s\/\/n+1)","output":"constant"},{"instruction":"import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n\nn,m=nninp()\nans=0\ncnt=f=0\nfor i in range(n):\n    s=ssinp()\n    r=stl(s)\n    cnt=0\n    for c in range(len(r)):\n        if(r[c]==\"W\" and f==0):\n            pass\n        elif(r[c]==\"B\" and f==0):\n            cnt+=1\n            f=1\n        elif(r[c]==\"B\" and f==1):\n            cnt+=1\n        elif(r[c]==\"W\" and f==1):\n            f=0\n            if(cnt%2==1):\n                print(i+1+(cnt\/\/2),c-(cnt\/\/2))\n                exit()\n    if(cnt%2==1):\n        print(i+1+cnt\/\/2,c+1-cnt\/\/2)\n        exit()","output":"quadratic"},{"instruction":"def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) \/\/ i\n    i += 1\n\nprint(str(sum + (n + i - 1) \/\/ i)[n % i - 1])","output":"logn"},{"instruction":"str1,str2=map(str,input(\"\").split())\nlst=[]\nlst_ans=[]\nl_count=0\ncount=0\nfor i in str2:\n    if(count<1):\n        lst.append(i)\n    else:\n        break\nfor i in str1:\n    if(count==0):\n        lst_ans.append(i)\n        count+=1\n    elif(ord(i)<ord(lst[0])):\n        lst_ans.append(i)\n    else:\n        lst_ans.append(lst[0])\n        break\nelse:\n    lst_ans.append(lst[0])\nprint(''.join(lst_ans))","output":"linear"},{"instruction":"import sys\ndef ask(i):\n    print('?', i + 1)\n    sys.stdout.flush()\n    a_i = int(input())\n    return a_i\ndef answer(i):\n    print('!', i + 1 if i != -1 else -1)\n    sys.exit()\n\ndef has_intersection(l1, r1, l2, r2):\n    if l1 <= l2 and r2 <= r1:\n        return True\n    if l2 <= l1 and r1 <= r2:\n        return True\n    return False\n\nn = int(input())\nassert n >= 2 and n % 2 == 0\nif (n \/\/ 2) % 2 == 1:\n    answer(-1)\nelse:\n    assert n % 4 == 0\n    l1 = 0\n    r1 = n \/\/ 2\n    a_l1 = ask(l1)\n    a_r1 = ask(r1)\n    if a_l1 == a_r1:\n        answer(0)\n    a_l2 = a_r1\n    a_r2 = a_l1\n\n    while True:\n        m1 = (l1 + r1) \/\/ 2\n        m2 = (m1 + n \/\/ 2) % n\n        a_m1 = ask(m1)\n        a_m2 = ask(m2)\n        if a_m1 == a_m2:\n            answer(m1)\n        if has_intersection(a_l1, a_m1, a_l2, a_m2):\n            r1 = m1\n            a_r1 = a_m1\n            a_r2 = a_m2\n        else:\n            assert has_intersection(a_m1, a_r1, a_m2, a_r2)\n            l1 = m1\n            a_l1 = a_m1\n            a_l2 = a_m2\n\nassert False","output":"logn"},{"instruction":"tt=int(input())\nfor _ in range(tt):\n    s=input()\n    t=input()\n    flag='NO'\n    j=0\n    ptr=0\n    while(j<len(s) and ptr<len(t)):\n        if(s[j]==t[ptr]):\n            ptr+=1\n            j+=1\n        else:\n            j+=1\n    if(ptr==len(t)):\n        flag='YES'\n    else:\n        pos=[0]*26\n        for i in range(len(s)):\n            pos[ord(s[i])-97]+=1\n        for i in range(0,len(t)):\n            h=[]\n            for j in range(0,len(pos)):\n                h.append(pos[j])\n            j=0\n            ptr=0\n            temp1=0\n            while(ptr<=i and j<len(s)):\n                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):\n                    h[ord(s[j])-97]-=1\n                    ptr+=1\n                    j+=1\n                else:\n                    j+=1\n            if(ptr==i+1):\n                temp1=1\n\n            j=0\n            ptr=i+1\n            temp2=0\n            while(ptr<len(t) and j<len(s)):\n                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):\n                    h[ord(s[j])-97]-=1\n                    ptr+=1\n                    j+=1\n                else:\n                    j+=1\n            if(ptr==len(t)):\n                temp2=1\n\n            if(temp1==1 and temp2==1):\n                flag='YES'\n                break\n    if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')):\n        flag='NO'\n    print(flag)","output":"cubic"},{"instruction":"n = int(input())\nif n == 0:\n    print(0)\nelse:\n    if n % 2 == 0:\n        print(n+1)\n    else:\n        print((n+1)\/\/2)","output":"constant"},{"instruction":"from math import sin, pi\n\nn, r = map(int, input().split())\n\nprint(r * sin(pi \/ n) \/ (1 - sin(pi \/ n)))","output":"constant"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    arr[i] = (arr[i]-i)\/\/n + (1 if (arr[i]-i)%n>0 else 0)\nprint(arr.index(min(arr))+1)","output":"linear"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nk=min(a[0],a[-1])\/\/(n-1)\nfor i in range(1,n-1):\n    k=min(k,min(a[0],a[i])\/\/i,min(a[i],a[-1])\/\/(n-1-i))\nprint(k)","output":"linear"},{"instruction":"from collections import defaultdict\nn, k = map(int, input().split())\na = [0] + list(map(int, input().split()))\nh = defaultdict(int)\nfor i in range(n):\n\ta[i + 1] ^= a[i]\nfor i in range(n + 1):\n\th[min(a[i] ^ ((1 << k) - 1), a[i])] += 1\nans = 0\nfor x, t in h.items():\n\ta = t \/\/ 2\n\tb = t - a\n\tans += a * (a - 1) \/\/ 2 + b * (b - 1) \/\/ 2\nans = (n * (n + 1)) \/\/ 2 - ans\nprint(ans)","output":"linear"},{"instruction":"n,m=map(int,input().split())\ns=[]\nfor i in range(n):\n\ts.append(list(map(str,input().strip())))\n\nt=[]\nfor i in range(n):\n\tp=['.']*m\n\tt.append(p)\n\nfor i in range(1,n-1):\n\tfor j in range(1,m-1):\n\t\tf=0\n\t\tif s[i-1][j-1]=='\n\t\t\tf=1\n\t\tif f==1:\n\t\t\tt[i-1][j-1]='\n\t\t\tt[i-1][j]='\n\t\t\tt[i-1][j+1]='\n\t\t\tt[i][j-1]='\n\t\t\tt[i][j+1]='\n\t\t\tt[i+1][j-1]='\n\t\t\tt[i+1][j]='\n\t\t\tt[i+1][j+1]='\nf=1\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j]=='\n\t\t\tf=0\n\t\t\tbreak\n\tif f==0:\n\t\tbreak\nif f==1:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"import sys\nfrom random import *\nfrom bisect import *\n\npl=1\nfrom math import gcd,sqrt\nfrom copy import *\nsys.setrecursionlimit(10**5)\nif pl:\n\tinput=sys.stdin.readline\nelse:\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('outpt.txt','w')\n\ndef li():\n\treturn [int(xxx) for xxx in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\ndef mi():\n\treturn \tmap(int,input().split())\n\nt=1\n\nwhile t>0:\n\tt-=1\n\tn=fi()\n\tmod=10**9+7\n\tdp=[[0 for i in range(n+5)] for j in range(n+5)]\n\tprev=\"-1\"\n\n\tfor i in range(n):\n\t\tp=input().rstrip()\n\t\tif i==0:\n\t\t\tdp[i][0]=1\n\t\telse:\n\n\t\t\tc=0\n\t\t\tif prev=='f':\n\t\t\t\tfor j in range(n):\n\t\t\t\t\tdp[i][j+1]=dp[i-1][j]\n\t\t\telse:\n\t\t\t\tfor j in range(n,-1,-1):\n\t\t\t\t\tc=(c+dp[i-1][j])%mod\n\t\t\t\t\tdp[i][j]=c\n\n\t\tprev=p\n\n\tprint(sum(dp[n-1])%mod)","output":"quadratic"},{"instruction":"n=int(input())\nd={\"purple\":\"Power\",\"green\":\"Time\",\"blue\":\"Space\",\"orange\":\"Soul\",\"red\":\"Reality\",\"yellow\":\"Mind\"}\nl=[]\nfor i in range(n):\n    s=input()\n    l.append(s)\nprint(6-n)\nfor i in d:\n    if i not in l:\n        print(d[i])","output":"constant"},{"instruction":"import sys\ninput=lambda: sys.stdin.readline().rstrip()\nimport copy\nn=int(input())\nA=[int(i) for i in input().split()]\ninf=float(\"inf\")\nDP=[[inf]*(n+1) for _ in range(n+1)]\n\nfor j in range(1,n+1):\n  for i in range(n):\n    if i+j>n:\n      continue\n    else:\n      if j==1:\n        DP[i][i+1]=A[i]\n      else:\n        for k in range(i+1,i+j):\n          if DP[i][k]<10000 and DP[k][i+j]<10000:\n            if DP[i][k]==DP[k][i+j]:\n              DP[i][i+j]=DP[i][k]+1\n            else:\n              DP[i][i+j]=20000\n          else:\n            if DP[i][k]<10000:\n              DP[i][i+j]=min(DP[i][i+j],10000+DP[k][i+j])\n            elif DP[k][i+j]<10000:\n              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+10000)\n            else:\n              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+DP[k][i+j])\nprint(DP[0][n]\/\/10000 if DP[0][n]>=10000 else 1)","output":"cubic"},{"instruction":"import sys\nn,m=map(int,input().split())\ns=list(map(int,input().split()))\ntry:\n    ind=s.index(m)\nexcept:\n    print(0)\n    sys.exit()\ndp=[0 for i in range(n)]\nfor i in range(ind+1,n):\n    if s[i]<m:\n        dp[i]=dp[i-1]-1\n    elif s[i]>m:\n        dp[i]=dp[i-1]+1\nfor i in range(ind-1,-1,-1):\n    if s[i]<m:\n        dp[i]=dp[i+1]-1\n    elif s[i]>m:\n        dp[i]=dp[i+1]+1\nd=dict()\nfor i in range(ind+1,n):\n    try:\n        d[dp[i]]+=1\n    except:\n        d.update({dp[i]:1})\n\nans=0\nfor i in range(ind+1):\n    x=-dp[i]\n    try:\n        ans+=d[x]\n    except:\n        True\n    try:\n        ans+=d[x+1]\n    except:\n        True\n    if dp[i]==0 or dp[i]==1:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin\nfrom bisect import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\nn, mem, pos, power = int(input()), [1], [], []\na = sorted(rints_2d(n))\n\nfor x, y in a:\n    pos.append(x)\n    power.append(y)\n\nfor i in range(1, n):\n    ix = bisect_left(pos, pos[i] - power[i]) - 1\n    if ix == -1:\n        mem.append(1)\n    else:\n        mem.append(mem[ix] + 1)\n\nprint(n - max(mem))","output":"linear"},{"instruction":"import math\n\nn, k = input().split()\nn = int(n)\nk = int(k)\n\nsolfound = 0\nm = 0\nx0 = 0\n\nif (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))\/2 < n:\n    m1 = (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))\/2\nelse:\n    m1 = (3+2*n-math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))\/2\n\nprint(int(m1))","output":"logn"},{"instruction":"import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\nQ = int(input())\nans = []\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    if l % 2 == 0 and r % 2 == 0:\n        ans.append((r-l)\/\/2 + l)\n    elif l % 2 == 1 and r % 2 == 0:\n        ans.append((r-l+1)\/\/2)\n    elif l % 2 == 1 and r % 2 == 1:\n        ans.append(0-(r-l)\/\/2-l)\n    else:\n        ans.append(0-(r-l+1)\/\/2)\n\nprint('\\n'.join(map(str, ans)))","output":"constant"},{"instruction":"n,l,r,x = map(int,input().split())\nnums = sorted(list(map(int,input().split())))\nans = 0\ndef recurse(i,sum, dif, cnt):\n    global ans\n    if i == n:\n        if not cnt:\n            return\n        if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x:\n            ans += 1\n        return\n    recurse(i+1,sum,dif,cnt[:])\n    cnt.append(nums[i])\n    recurse(i+1,sum+nums[i],dif,cnt[:])\nrecurse(0,0,0,[])\nprint(ans)","output":"np"},{"instruction":"a = list(map(int, input().split()))\nb = list(map(int, input().split()))\na1 = min(a[::2])\nb1 = max(a[::2])\nc1 = min(a[1::2])\nd1 = max(a[1::2])\ng  = sum(b[::2]) \/ 4\nh  = sum(b[1::2]) \/ 4\nr  = abs(b[0] - g) + abs(b[1] - h)\nfor i in range(a1, b1+1) :\n    for j in range(c1, d1+1) :\n        if abs(i-g) + abs(j-h) <= r:\n            print(\"YES\")\n            exit()\nprint(\"NO\")","output":"constant"},{"instruction":"n = int(input())\nl = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    l += [(x + y, x - y)]\nl.sort()\nr = -2000000000\na = 0\nfor u in l:\n    if u[1] >= r:\n        a += 1\n        r = u[0]\nprint(a)","output":"nlogn"},{"instruction":"from sys import stdin, stdout\n\nn,m = [int(x) for x in stdin.readline().split()]\n\nif n == 2:\n    c = 1\n    way = []\n    mult = 1\n    for x in range(m-1,-1,-1):\n        way.append(c)\n        c += x*mult\n        mult *= -1\n    for x in way:\n        print(1, x)\n    for x in way[::-1]:\n        print(2,x)\n\nelif n == 1:\n    c = 1\n    way = []\n    mult = 1\n    for x in range(m-1,-1,-1):\n        way.append(c)\n        c += x*mult\n        mult *= -1\n    for x in way:\n        print(1, x)\n\nelif m == 2:\n    c = 1\n    way = []\n    mult = 1\n    for x in range(n-1,-1,-1):\n        way.append(c)\n        c += x*mult\n        mult *= -1\n    for x in way:\n        print(x,1)\n    for x in way[:-1:-1]:\n        print(x,2)\n\nelif m == 1:\n    c = 1\n    way = []\n    mult = 1\n    for x in range(n-1,-1,-1):\n        way.append(c)\n        c += x*mult\n        mult *= -1\n    for x in way:\n        print(x,1)\nelse:\n    outStr = ''\n    for x in range(n\/\/2):\n        for y in range(1,m+1):\n            stdout.write(str(x+1) + ' ' + str(y)+'\\n')\n            stdout.write(str(n-x) + ' ' + str(m+1-y)+'\\n')\n    if n%2 == 1:\n        c = 1\n        way = []\n        mult = 1\n        for x in range(m-1,-1,-1):\n            way.append(c)\n            c += x*mult\n            mult *= -1\n        for x in way:\n            stdout.write(str(n\/\/2+1)+' ' + str(x)+'\\n')","output":"quadratic"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\n\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef lcm(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nn = getInt()\n\narr = listStr()\n\nfor i in range(n):\n    arr[i]=int(arr[i])\n\nokk=0\ns=0\nfor i in range(n-1):\n    s+=arr[i]\n    cnt=0\n    ok=1\n    sss=0\n    for j in range(i+1,n):\n        cnt+=arr[j]\n        if cnt==s:\n            cnt=0\n            sss+=1\n        if cnt>s:\n            ok=0\n\n    if cnt==0 and sss :\n        okk=1\n        break\nprint(\"YES\" if okk else \"NO\")","output":"quadratic"},{"instruction":"n, m = map(int,input().split())\nb = []\nd = []\nfor x in range(n):\n\tif x == 0:\n\t\ta,c = map(int,input().split())\n\t\tif (a * 60) + c > m:b.append(\"0 0\")\n\t\td.append((a * 60) + c)\n\telse:\n\t\ta ,c = map(int,input().split())\n\t\tif ((a * 60) + c) - d[-1] > (m * 2) + 1:\n\t\t\tf = d[-1] + m + 1\n\t\t\tb.append(str(f \/\/ 60) + \" \" + str((f % 60)))\n\t\td.append((a * 60) + c)\nif len(b) == 0:\n\tf = d[-1] + m + 1\n\tb.append(str(f \/\/ 60) + \" \" + str((f % 60)))\nprint(b[0])","output":"linear"},{"instruction":"n = int(input())\nm = int(input())\nprint(m % (2**n ))","output":"constant"},{"instruction":"x, k = map(int, input().split())\nmod = 1000000007\nif (k == 0):\n    print((2 * x) % mod)\nelif (x == 0):\n    print(0)\nelse:\n    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod\n    print(ans)","output":"logn"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = li()\n\ndone = set()\nj = 0\nans = []\nfor i in range(n):\n    if b[i] in done:\n        ans.append(0)\n    else:\n        c = 0\n        while a[j] != b[i]:\n            done.add(a[j])\n            j += 1\n            c += 1\n        done.add(a[j])\n        j += 1\n        ans.append(c + 1)\nprint(*ans)","output":"linear"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\na=abs(x-y)*t1\nb=abs(x-z)*t2+abs(x-y)*t2+3*t3\nif b<=a:print(\"YES\")\nelse:print(\"NO\")","output":"constant"},{"instruction":"from itertools import accumulate\nn,m,k = map(int,input().split())\na = list(map(int,input().split()))\nals = []\nfor i in range(m):\n  ls = a[:]\n  for j in range(n):\n    if j%m == i:\n      ls[j] -= k\n  als.append(list(accumulate(ls)))\nans = 0\nfor i in range(m):\n  ls = als[i]\n  mn = 0\n  anstmp = 0\n  for j in range(n):\n    if mn > ls[j]:\n      mn = ls[j]\n    if j%m == i:\n      anstmp = max(anstmp,ls[j]-mn)\n  ans = max(ans,anstmp)\nprint(ans)","output":"quadratic"},{"instruction":"import sys\n\nn,k = map(int, input().split())\nk -= 1\nlo,hi = 0,int(1e9)\nwhile lo < hi:\n\tm = (lo + hi + 1) \/\/ 2\n\tif 1 + k*(k+1)\/\/2 - m*(m+1)\/\/2 >= n:\n\t\tlo = m;\n\telse:\n\t\thi = m - 1\nif 1 + k*(k+1)\/\/2 - lo*(lo+1)\/\/2 >= n:\n\tlo = k - lo\nelse:\n\tlo = -1\nprint(lo)","output":"logn"},{"instruction":"def user99():\n    text = 'RGB' * 2222\n    for _ in range(int(input())):\n        n, k = map(int, input().split())\n        s = input()\n        ans = 2222\n        for i in range(3):\n            p = text[i: k + i]\n\n            for j in range(n - k + 1):\n                diff = 0\n\n                for l in range(j, j + k):\n                    if s[l] != p[l - j]:\n                        diff += 1\n                ans = min(ans, diff)\n        print(ans)\n\nuser99()","output":"quadratic"},{"instruction":"from sys import stdin\n\ndef solve(tc):\n    k = int(stdin.readline().strip())\n    cmp = 9\n    ndigit = 1\n\n    while k>(cmp*ndigit):\n        k -= cmp*ndigit\n        cmp *= 10\n        ndigit += 1\n\n    num = (10**(ndigit-1)) + ((k-1) \/\/ ndigit)\n    pos = (k-1) % ndigit\n\n    print(str(num)[pos])\n    pass\n\nLOCAL_TEST = not __debug__\nif LOCAL_TEST:\n    infile = __file__.split('.')[0] + \"-test.in\"\n    stdin = open(infile, 'r')\n\ntcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)\ntc = 1\nwhile tc <= tcs:\n    solve(tc)\n    tc += 1","output":"constant"},{"instruction":"import sys, math, queue\n\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[-10**20 for i in range(m)] for i in range(n)]\n\nfor i in range(n):\n    for j in range(min(m, i+1)):\n        if j == 0:\n            dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k\n        else:\n            dp[i][j] = dp[i-1][j-1]+a[i]\n\nans = 0\nfor i in range(n):\n\tans = max(ans, max(dp[i]))\nprint(ans)","output":"quadratic"},{"instruction":"import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\nfrom itertools import permutations\n\nI=sys.stdin.readline\n\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\ndef ncr(n, r, p):\n\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef valid(row,col,rows,cols,rcross,lcross):\n \treturn rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0\n\ndef div(n):\n\tif n==1:\n\t\treturn 1\n\tcnt=2\n\tfor i in range(2,int(n**.5)+1):\n\t\tif n%i==0:\n\t\t\tif i!=n\/\/i:\n\t\t\t\tcnt+=2\n\t\t\telse:\n\t\t\t\tcnt+=1\n\treturn cnt\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\t\tflag=True\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\tflag=False\n\t\t\t\tbreak\n\t\treturn flag\n\ndef s(b):\n\tans=[]\n\twhile b>0:\n\t\ttmp=b%10\n\t\tans.append(tmp)\n\t\tb=b\/\/10\n\treturn ans\n\ndef main():\n\tn,k=mi()\n\tarr=[]\n\tfor _ in range(n):\n\t\tx,y=mi()\n\t\tarr.append((-x,y))\n\n\tarr.sort()\n\n\tcnt=arr.count(arr[k-1])\n\tprint(cnt)\n\nif __name__ == '__main__':\n\tmain()","output":"nlogn"},{"instruction":"n = int(input())\np = list(map(lambda x: int(x) - 1, input().split()))\n\nvis = [False] * n\nodd = 0\nfor x in range(n):\n    if vis[x]:\n        continue\n    odd ^= 1\n    while not vis[x]:\n        odd ^= 1\n        vis[x] = True\n        x = p[x]\n\nprint('Petr' if (n + odd) % 2 == 0 else 'Um_nik')","output":"nlogn"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef check(mid,arr,m,n):\n    ls = [[] for _ in range(1<<m)]\n    for i in range(n):\n        ans = 0\n        for j in range(m):\n            if arr[i][j] >= mid:\n                ans += 1<<j\n        ls[ans].append(i+1)\n    for i in range(len(ls)):\n        for j in range(len(ls)):\n            if len(ls[i]) and len(ls[j]) and i|j == (1<<m)-1:\n                return ls[i][0],ls[j][0]\n    return 0\n\ndef main():\n    n,m = map(int,input().split())\n    arr = [list(map(int,input().split())) for _ in range(n)]\n    hi,lo,ind1 = 10**9,0,(1,1)\n    while hi >= lo:\n        mid = (hi+lo)\/\/2\n        ind = check(mid,arr,m,n)\n        if ind:\n            ind1 = ind\n            lo = mid+1\n        else:\n            hi = mid-1\n    print(*ind1)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n = int(input())\nfst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]\ncnt = 0\n\ndef add(u, v) :\n\tglobal cnt\n\tcnt += 1\n\tif fst[u] == 0 :\n\t\tfst[u] = cnt\n\telse :\n\t\tnxt[lst[u]] = cnt\n\tlst[u], des[cnt] = cnt, v\n\nfor i in range(1, n) :\n\tu, v = map(int, input().split())\n\n\tadd(u, v)\n\tadd(v, u)\n\na = list(map(int, input().split()))\ndeep = [0 for i in range(n + 1)]\ndeep[1] = 1\nnow, res = 1, 1\nAns = 0\n\nfor i in range(0, n) :\n\tif deep[a[i]] == 0 :\n\t\tAns = 1\n\t\tbreak\n\telif deep[a[i]] < now :\n\t\tAns = 1\n\t\tbreak\n\telse :\n\t\tb = fst[a[i]]\n\t\tres += 1\n\t\twhile b > 0 :\n\t\t\tif deep[des[b]] == 0 :\n\t\t\t\tdeep[des[b]] = res\n\t\t\tb = nxt[b]\n\t\tnow = deep[a[i]]\n\nif Ans == 0 :\n\tprint(\"Yes\")\nelse :\n\tprint(\"No\")","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nk = list(map(int, input().split()))\np = list(map(int, input().split()))\na = 0\nb = 0\nans = 0\nwhile a != n and b != m:\n    if p[b] >= k[a]:\n        ans += 1\n        a += 1\n        b += 1\n    else:\n        a += 1\nprint(ans)","output":"linear"},{"instruction":"import math\n\nn=int(input())\nk=1\nwhile(n > 9*k*(10**(k-1))):\n    n = n - 9*k*(10**(k-1))\n    k = k + 1\nremainder = n%k\nif remainder == 0:\n    remainder = k\nif k==1:\n    quoteint = math.ceil(n\/k)\nelse:\n    adder = \"9\"*(k-1)\n    adder = int(adder)\n    quoteint = math.ceil(n\/k) + adder\nprint(str(quoteint)[remainder-1])","output":"logn"},{"instruction":"import sys\nfrom array import array\nfrom itertools import product\nfrom collections import deque\n\ndef input():\n    with open('input.txt') as fp:\n        return fp.readlines()\n\ndef output(ans: str):\n    with open('output.txt', mode='w') as fp:\n        fp.write(ans)\n\ns = input()\nn, m = map(int, s[0].split())\nk = int(s[1])\na = [[0] * m for _ in range(n)]\ndq = deque()\nline = list(map(lambda x: int(x) - 1, s[2].split()))\nfor i in range(0, 2 * k, 2):\n    a[line[i]][line[i + 1]] = 1\n    dq.append((line[i], line[i + 1]))\n\nx, y = -1, -1\nwhile dq:\n    x, y = dq.popleft()\n    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:\n            a[tx][ty] = 1\n            dq.append((tx, ty))\n\noutput(f'{x+1} {y+1}')","output":"cubic"},{"instruction":"n, x, y = int(input())-1, 1, 9\nwhile n > x*y :\n\tn, x, y = n-x*y, x+1, 10*y\nprint(str(10**(x-1)+n\/\/x)[n%x])","output":"logn"},{"instruction":"n = int(input())\ns = input()\nt = input()\np = [-1, -1]\na = [[-1] * 26 for i in range(26)]\nk = 0\nfor i in range(n):\n    if t[i] != s[i]:\n        k += 1\nfor i in range(n):\n    if t[i] != s[i]:\n        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:\n            print(k - 2)\n            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)\n            exit()\n        a[ord(s[i]) - 97][ord(t[i]) - 97] = i\nfor i in range(n):\n    if t[i] != s[i]:\n        for j in range(26):\n            if a[j][ord(s[i]) - 97] != -1:\n                print(k - 1)\n                print(a[j][ord(s[i]) - 97] + 1, i + 1)\n                exit()\n        a[ord(s[i]) - 97][ord(t[i]) - 97] = i\nprint(k)\nprint(-1, -1)","output":"linear"},{"instruction":"def main():\n    N, M, K = map(int, input().split())\n    HEdge = [list(map(int, input().split())) for _ in range(N)]\n    VEdge = [list(map(int, input().split())) for _ in range(N - 1)]\n    if K % 2:\n        for i in range(N):\n            print(*[-1] * M)\n        return\n    dp = [[[0] * M for _ in range(N)] for _ in range(K \/\/ 2 + 1)]\n    for i in range(1, K \/\/ 2 + 1):\n        for j in range(N):\n            for k in range(M):\n                Val1 = Val2 = Val3 = Val4 = 10 ** 9\n                if j > 0:\n                    Val1 = dp[i - 1][j - 1][k] + VEdge[j - 1][k]\n                if j < N - 1:\n                    Val2 = dp[i - 1][j + 1][k] + VEdge[j][k]\n                if k > 0:\n                    Val3 = dp[i - 1][j][k - 1] + HEdge[j][k - 1]\n                if k < M - 1:\n                    Val4 = dp[i - 1][j][k + 1] + HEdge[j][k]\n                dp[i][j][k] = min(Val1, Val2, Val3, Val4)\n    for i in dp[K \/\/ 2]:\n        print(*list(map(lambda x: x * 2, i)))\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"s, ans, = input(), 0\nsLen = len(s)\n\nfor i in range(sLen):\n    for till1 in range(i + 1, sLen + 1):\n        till2 = till1 + 1\n        for j in range(i + 1, sLen + 1):\n            if till2 > sLen:\n                break\n            sub1 = s[i:till1]\n            sub2 = s[j:till2]\n            subLen = len(sub1)\n            if sub1 == sub2 and ans < subLen:\n                ans = subLen\n            till2 += 1\n\nprint(ans)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\nmaxn = int(1e5 + 10)\nST = [0] * (4 * maxn)\ndef update(id, l, r, val):\n    if l == r == val:\n        ST[id] = 1\n        return\n    if l > val or r < val:\n        return\n    mid = int((l + r) \/ 2)\n    update(id * 2, l, mid, val)\n    update(id * 2 + 1, mid + 1, r, val)\n    ST[id] = ST[id * 2] + ST[id * 2 + 1]\n    return\ndef get(id, l, r, x, y):\n    if l > y or r < x:\n        return 0\n    if x <= l and r <= y:\n        return ST[id]\n    mid = int((l + r) \/ 2)\n    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)\nn, res = int(input()), 0\nfor x in list(map(int, input().split())):\n    res ^= get(1, 1, n, x + 1, n) % 2\n    update(1, 1, n, x)\nfor i in range (int(input())):\n    x, y = list(map(int, input().split()))\n    if int((y - x) * (y - x + 1) \/ 2) & 1:\n        res ^= 1\n    if res:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\nl=list()\nr=list()\nfor _ in range(m):\n    a,b=map(int,input().split())\n    l.append(a)\n    r.append(b)\nfor i in range(n):\n    if(i%2==0):\n        print(0,end='')\n    else:\n        print(1,end='')","output":"linear"},{"instruction":"n = int(input())\n\none_seat = []\n\ntwo_seats = []\n\nj = 1\n\nfor item in input().split():\n    two_seats.append((int(item), j))\n    j += 1\n\ntwo_seats.sort(key=lambda x: -x[0])\n\nfor person in input():\n    if person == '0':\n        q = two_seats.pop()\n        print(q[1], end=' ')\n        one_seat.append(q)\n    else:\n        print(one_seat.pop()[1], end=' ')","output":"nlogn"},{"instruction":"n= int(input())\nt=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    v = int(input())\n    t[v].append(i+2)\n\nflag=True\nfor l in t:\n    if l!=[]:\n        cnt=0\n        for ele in l:\n            if t[ele]==[]:\n                cnt+=1\n        if cnt<3:\n            flag=False\n            break\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m=map(int,input().split())\n    s,e,ans=[1,1],[n,m],[]\n    for i in range(n*m\/\/2):\n        ans.append(s[:])\n        ans.append(e[:])\n        s[1],e[1]=s[1]+1,e[1]-1\n        if s[1]==m+1:\n            s=[s[0]+1,1]\n        if not e[1]:\n            e=[e[0]-1,m]\n    if (n*m)&1:\n        ans.append([s[0],s[1]])\n    for i in ans:\n        print(*i)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"quadratic"},{"instruction":"def prime(n):\n    if n < 2:\n        return False\n    elif n % 2 == 0 and n != 2:\n        return False\n    for j in range(3, int(pow(n, 0.5) + 1), 2):\n        if n % j == 0:\n            return False\n    return True\nn = int(input())\nfor j in range(2, int(n \/ 2) + 1):\n    if prime(j) == False and prime(n - j) == False:\n        print(j, n - j)\n        break","output":"constant"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nv=[False for i in range(n)]\nans=0\ni=0\nwhile i<n:\n\tif v[i]==False:\n\t\tans+=1\n\t\tfor j in range(i+1,n):\n\t\t\tif l[j]%l[i]==0:\n\t\t\t\tv[j]=True\n\ti+=1\nprint(ans)","output":"quadratic"},{"instruction":"def rr(): return input().rstrip()\ndef rri(): return int(rr())\ndef rrm(): return list(map(int, rr().split()))\nfrom collections import defaultdict\ndef mus(d=0): return defaultdict(defaultdict(d))\ndef ms(x, y, d=0): return [[d]*y for i in range(x)]\ndef ar(x, d=0): return [d]*x\ndef ppm(m, n=0, x=0, y=0): print(\"\\n\".join((\"\\t\".join((str(m[j][i]) for j in range(y or n))) for i in range(x or n))))\ndef ppa(a, n): print(\"\\t\".join(map(str, a[0:n])))\ndef ppl(): print(\"\\n+\"+\"- -\"*20+\"+\\n\")\nINF = float(\"inf\")\n\ndef fake_input():\n    return ...\n\ndp = ms(501, 501)\ndp2 = ar(501, INF)\n\ndef read():\n    n = rri()\n    global arr\n    arr = rrm()\n    return arr, n\n\ndef calc_dp(l, r):\n    assert l < r\n\n    if l+1 == r:\n        dp[l][r] = arr[l]\n        return dp[l][r]\n    if dp[l][r] != 0:\n        return dp[l][r]\n\n    dp[l][r] = -1\n\n    for i in range(l+1, r):\n        lf = calc_dp(l, i)\n        rg = calc_dp(i, r)\n        if (lf > 0 and lf == rg):\n            dp[l][r] = lf + 1\n            return dp[l][r]\n\n    return dp[l][r]\n\ndef solve(arr, n):\n    dp2[0] = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            v = calc_dp(i, j)\n\n            if (v > 0):\n                dp2[j] = min(dp2[j], dp2[i]+1)\n\n    ans = dp2[n]\n    return ans\n\nif __name__ == \"__main__\":\n\n    input_data = read()\n\n    result = solve(*input_data)\n    print(result)","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\ndef main():\n    n=int(input())\n    if n<6:\n        print(-1)\n    else:\n        for i in range(2, n-2+1):\n            print(1, i)\n        print(2, n-1)\n        print(2, n)\n    for i in range(1,n):\n        print(i, i+1)\n\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp = defaultdict(lambda :-1)\nM=1000\nfor i in range(N):\n    dp[i+M] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp[j+M*k], dp[j+k+M*(i-k)]\n            if u == -1 or v == -1 or u != v:\n                continue\n            dp[j+M*i] = u+1;break\n\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    for j in range(i+1):\n        if dp[j+(i+1-j)*M] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = [0 for i in range(n)]\nl, r = 0, n - 1\nm -= 1\n\nfor i in range(1, n + 1):\n    cur = 2**(n - i - 1)\n\n    if (m >= cur):\n        m -= cur\n        a[r] = i\n        r -= 1\n    else:\n        a[l] = i\n        l += 1\n\nprint(*a)","output":"np"},{"instruction":"def lvl(val):\n    tot=1\n    curr=-1\n    while(val%tot==0):\n        curr+=1\n        tot*=2\n    return [curr,val*2\/\/(tot),tot\/\/2]\n\nn,q=map(int,input().split())\nfor _ in range(q):\n    curr=int(input())\n    l,v,pw=lvl(curr)\n    s=input()\n    for j in s:\n\n        if j==\"U\":\n            if v%4==3:\n                curr=curr-pw\n            else:\n                if curr+pw<=n:\n                    curr=curr+pw\n\n        elif j==\"R\":\n            if l>0:\n                curr=curr+pw\/\/2\n\n        elif j == \"L\":\n            if l > 0:\n                curr = curr - pw \/\/ 2\n\n        l, v, pw = lvl(curr)\n\n    print(curr)","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nr,g,b = map(int,input().split())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl3 = list(map(int,input().split()))\nl1.sort(reverse=True)\nl2.sort(reverse=True)\nl3.sort(reverse=True)\ndp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]\nans = 0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n            if j == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])\n            else:\n                if i>0 and j>0:\n                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]\n                elif i>0 and k>0:\n                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]\n                elif j>0 and k>0:\n                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]\n            ans = max(ans,dp[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"from math import factorial\n\ndef calc_arrangement(n, m):\n    return(factorial(n) \/ factorial(n - m))\n\ndef calc_combination(n, m):\n    return(calc_arrangement(n, m) \/ factorial(m))\n\nstr1 = list(input())\nstr2 = list(input())\n\nn = 0\ndiff = 0\n\nfor i in range(len(str1)):\n\tif str1[i] == '+':\n\t\tdiff += 1\n\telse:\n\t\tdiff -= 1\n\tif str2[i] == '+':\n\t\tdiff -= 1\n\telif str2[i] == '-':\n\t\tdiff += 1\n\telse:\n\t\tn += 1\n\nif n == 0:\n\tif diff == 0:\n\t\tprint(1.0)\n\telse:\n\t\tprint(0.0)\nelif n < abs(diff):\n\tprint(0.0)\nelse:\n\tres = calc_combination(n, (n - diff) \/ 2) * (0.5 ** n)\n\tprint(res)","output":"np"},{"instruction":"def get(g):\n    s = [str(i) for i in g]\n    num = int(\"\".join(s))\n    return num\n\na = input()\nb = input()\nbb = int(b)\nmark = [0 for i in range(len(a))]\nc = a\nf = []\ng = []\n\nfor i in range(0 , len(a)):\n    g.append(a[i])\n\ng.sort()\ng.reverse()\nnum = get(g)\n\nindex = []\n\nif num <= bb:\n    print(num)\n    exit(0)\n\nfor i in range(0 , min(len(a) , len(b))):\n    mx = '-1'\n    idx = 0\n    for j in range(0 , len(a)):\n        if mark[j] == 0 and a[j] <= b[i]:\n            if a[j] > mx:\n                mx = a[j]\n                idx = j\n\n    if mx == '-1':\n        rem = []\n\n        while True and len(f) > 0:\n            ma = '-1'\n            id = 0\n            for j in range(0 , len(a)):\n                if mark[j] == 0 and a[j] < f[-1]:\n                    if a[j] > ma:\n                        ma = a[j]\n                        id = j\n\n            if ma == '-1':\n                mark[index.pop()] = 0\n                f.pop()\n                continue\n            else:\n                mark[index.pop()] = 0\n                f.pop()\n                f.append(ma)\n                mark[id] = 1\n                break\n\n        for j in range(0, len(a)):\n            if mark[j] == 0:\n                rem.append(a[j])\n\n        rem.sort()\n        rem.reverse()\n\n        for j in rem:\n            f.append(j)\n\n        print(get(f))\n        exit(0)\n\n    f.append(mx)\n    mark[idx] = 1\n    index.append(idx)\n\n    if mx < b[i] and mx != '-1':\n        break\n\nrem = []\n\nfor i in range(0 , len(a)):\n    if mark[i] == 0:\n        rem.append(a[i])\n\nrem.sort()\nrem.reverse()\nfor i in rem:\n    f.append(i)\n\nprint(get(f))","output":"cubic"},{"instruction":"from math import ceil\nn, k = map(int, input().split())\ncou = 0\ncou += ceil(n*2\/k)\ncou += ceil(n*5\/k)\ncou += ceil(n*8\/k)\nprint(cou)","output":"constant"},{"instruction":"n,k=map(int,input().split())\nn,k=n-1,k-1\nl=0\nr=k\ng=k*(k+1)\/\/2\nans=-1\nwhile l<=r:\n\tm=(l+r)\/\/2\n\n\tif (g-m*(m+1)\/\/2)>=n:\n\t\tans=k-m\n\t\tl=m+1\n\telse:\n\t\tr=m-1\nprint(ans)","output":"logn"},{"instruction":"import re\n\ninputs = int(input())\n\nfor x in range(inputs):\n    coordinates = input()\n    match = re.match(\"R(\\d+)C(\\d+)\", coordinates)\n    if match:\n        rows = int(match.group(1))\n        columns = int(match.group(2))\n\n        output = \"\"\n        i = 0\n        while columns > 0:\n            alpha_index = (columns \/\/ (26 ** i) - 1) % 26\n            output = chr(65 + alpha_index) + output\n\n            columns -= (alpha_index + 1) * (26 ** i)\n            i += 1\n        output += str(rows)\n        print(output)\n    else:\n        match = re.match(\"(\\D+)(\\d+)\", coordinates)\n        letters = match.group(1)\n        rows = match.group(2)\n        columns = 0\n        for i in range(len(letters), 0, -1):\n            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))\n        output = f\"R{rows}C{columns}\"\n        print(output)","output":"linear"},{"instruction":"def f(ch):\n    if ch=='0':\n        return 0\n    else:\n        return 1\n\nU=[ [f(i) for i in list(input())],\n    [f(i) for i in list(input())]]\ni=0\nsize=len(U[0])\nans=0\nwhile i+1<size:\n    if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1:\n        i+=1\n        continue\n    elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1:\n        U[0][i]=1\n        U[0][i+1]=1\n        U[1][i]=1\n        U[1][i+1]=1\n        ans+=1\n    else:\n        U[0][i]=1\n        U[0][i+1]=1\n        U[1][i]=1\n        ans+=1\n\n    i+=1\n\nprint(ans)","output":"constant"},{"instruction":"ans={}\nfor _ in range(int(input())):\n    a,b=map(int,input().split())\n    ans[a]=b\nfor _ in range(int(input())):\n    a,b=map(int,input().split())\n    if a in ans:\n        ans[a]=max(ans[a],b)\n    else:\n        ans[a]=b\nprint(sum(ans.values()))","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\n\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])","output":"quadratic"},{"instruction":"def main():\n\ts = list(input())\n\tt = list(input())\n\tif len(s) < len(t):\n\t\ts.sort(reverse=True)\n\t\tprint(''.join(s))\n\telse:\n\t\tcount = [0] * 10\n\t\tfor elm in s:\n\t\t\tcount[ord(elm) - ord('0')] += 1\n\t\tans = []\n\t\tless = False\n\t\tfor i in range(len(s)):\n\t\t\tfor j in range(9, -1, -1):\n\t\t\t\tif not less:\n\t\t\t\t\tif j <= ord(t[i]) - ord('0') and count[j] > 0:\n\t\t\t\t\t\tif j < ord(t[i]) - ord('0'):\n\t\t\t\t\t\t\tans.append(chr(j + ord('0')))\n\t\t\t\t\t\t\tcount[j] -= 1\n\t\t\t\t\t\t\tless = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcurr_num = 0\n\t\t\t\t\t\t\tfor k in range(10):\n\t\t\t\t\t\t\t\tif j == k:\n\t\t\t\t\t\t\t\t\tfor tmp in range(count[k] - 1):\n\t\t\t\t\t\t\t\t\t\tcurr_num = curr_num * 10 + k\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tfor tmp in range(count[k]):\n\t\t\t\t\t\t\t\t\t\tcurr_num = curr_num * 10 + k\n\t\t\t\t\t\t\trest_num = 0\n\t\t\t\t\t\t\tfor k in range(i + 1, len(s)):\n\t\t\t\t\t\t\t\trest_num = rest_num * 10 + (ord(t[k]) - ord('0'))\n\t\t\t\t\t\t\tif rest_num >= curr_num:\n\t\t\t\t\t\t\t\tans.append(chr(j + ord('0')))\n\t\t\t\t\t\t\t\tcount[j] -= 1\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tif count[j] > 0:\n\t\t\t\t\t\tans.append(chr(j + ord('0')))\n\t\t\t\t\t\tcount[j] -= 1\n\t\t\t\t\t\tbreak\n\t\tprint(''.join(ans))\n\nif __name__ == '__main__':\n\tmain()","output":"cubic"},{"instruction":"n, m = map(int, input().split())\nA = list(map(int, input().split()))\nL = [0]*n\nfor i in range(m):\n    L[A[i]-1] += 1\nprint(min(L))","output":"quadratic"},{"instruction":"class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(n - 1, -1, -1):\n            new_dp = [False] * (n + 1)\n            for open in range(n):\n                if s[i] == '*':\n                    new_dp[open] = (dp[open + 1] or\n                                    (open > 0 and dp[open - 1]) or\n                                    dp[open])\n                elif s[i] == '(':\n                    new_dp[open] = dp[open + 1]\n                elif open > 0:\n                    new_dp[open] = dp[open - 1]\n            dp = new_dp\n\n        return dp[0]","output":"quadratic"},{"instruction":"from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\ndef check(mid, m):\n    d = defaultdict(int)\n    for idx, i in enumerate(a):\n        string = ''\n        for j in i:\n            if j >= mid:\n                string+='1'\n            else:\n                string+='0'\n        d[int(string, 2)] = idx\n    for i in d.keys():\n        for j in d.keys():\n            if i|j == 2**m - 1:\n                 return [d[i], d[j]]\n    return []\ndef binarySearch(lo, hi, m):\n    ans = []\n    while lo < hi:\n        mid = lo + (hi-lo+1)\/\/2\n        x = check(mid, m)\n        if x:\n            lo = mid\n            ans = [x[0]+1, x[1]+1]\n        else:\n            hi = mid-1\n    mid = lo + (hi-lo+1)\/\/2\n    x = check(mid, m)\n    if x:\n        ans = [x[0]+1, x[1]+1]\n    return ans\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nprint(*binarySearch(0, 10**9, m))","output":"np"},{"instruction":"n = int(input())\na = sorted(map(int , input().split()))\nans = 0\nfor i in range(n):\n    f = 1\n    for j in range(i):\n        if a[i] % a[j] == 0:\n            f = 0\n            break\n    ans += f\nprint(ans)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nA.sort()\n\nfrom collections import Counter\nC=Counter(A)\ndou=0\n\nfor c in C:\n    dou+=C[c]-1\n\n    if C[c]>=2 and C[c-1]!=0:\n        print(\"cslnb\")\n        sys.exit()\n\nif dou>=2:\n    print(\"cslnb\")\n    sys.exit()\n\nANS=0\nfor i in range(n):\n    if A[i]<i:\n        print(\"cslnb\")\n        sys.exit()\n    ANS+=(A[i]-i)%2\n\nif ANS%2==0:\n    print(\"cslnb\")\n    sys.exit()\nelse:\n    print(\"sjfnb\")\n    sys.exit()","output":"nlogn"},{"instruction":"n=int(input())\nif n >= 0:\n\n    print(n)\n\nelse:\n\n    a = int(n \/ 10)\n    b=int(n\/100)*10 - abs(n)%10\n\n    print(max(a,b))","output":"constant"},{"instruction":"import sys\nimport threading\n\ndef dfs(g, i, p):\n    global ans\n    count = 0\n    for j in g[i]:\n        if j == p:\n            continue\n        count += dfs(g, j, i)\n    if count == 0:\n        count = 1\n    ans.append(count)\n    return count\n\ndef solve():\n\n    n = int(input())\n    l = list(map(int, input().split()))\n    g = [[] for i in range(n+1)]\n\n    for i in range(1, n):\n        g[i+1].append(l[i-1])\n        g[l[i-1]].append(i+1)\n\n    dfs(g, 1, 0)\n    ans.sort()\n    st = ' '.join(map(str, ans))\n    print(st)\n\nans = []\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\n\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()","output":"quadratic"},{"instruction":"import sys\nfrom collections import deque\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nn = inp()\nedges = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = inpl()\n    a,b = a-1,b-1\n    edges[a].append(b)\n    edges[b].append(a)\ndist = [-1] * n\ndist[0] = 0\npa = [-1] * n\nse = set()\npq = []\nq = deque()\nq.append(0)\nwhile q:\n    now = q.popleft()\n    for nx in edges[now]:\n        if dist[nx] != -1:\n            continue\n        pa[nx] = now\n        dist[nx] = dist[now] + 1\n        if dist[nx] > 2:\n            se.add(nx)\n            pq.append((dist[nx], nx))\n        q.append(nx)\npq = pq[::-1]\nres = 0\nind = 0\nwhile se:\n    d,v = pq[ind]\n    ind += 1\n    if not v in se:\n        continue\n    res += 1\n    pv = pa[v]\n    se.discard(pv)\n    for nv in edges[pv]:\n        se.discard(nv)\nprint(res)","output":"linear"},{"instruction":"import math\nn,m,k=map(int,input().split())\nhorz=[]\nvert=[]\nif k & 1:\n    for i in range(n):\n        temp=[-1 for j in range(m)]\n        print(*temp)\n\nelse:\n    for i in range(n):\n        temp=list(map(int,input().split()))\n        horz.append(temp)\n    for i in range(n-1):\n        temp=list(map(int,input().split()))\n        vert.append(temp)\n    dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)]\n    for x in range(2,k+1,2):\n        for i in range(n):\n            for j in range(m):\n                dp[i][j][x]=math.inf\n                if i>0:\n                     dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j])\n                if i<n-1:\n                      dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j])\n                if j>0:\n                     dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1])\n                if j<m-1:\n                     dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j])\n    for i in range(n):\n        temp=[]\n        for j in range(m):\n            temp.append(dp[i][j][k])\n        print(*temp)","output":"cubic"},{"instruction":"x,k=map(int,input().split())\nif x==0:\n  print(0)\nelse:\n    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007\n    print(int(u))","output":"logn"},{"instruction":"casas, tubos = map(int, input().strip().split())\n\ndef bs(c, t):\n    l, r = 0, t-1\n    while l <= r:\n        mid = l+r >> 1\n        if ((2*t - mid - 1)*mid)\/\/2+1 < c:\n            l = mid+1\n        else:\n            r = mid-1\n    return r+1\n\nres = bs(casas, tubos)\nprint(-1 if res == tubos else res)","output":"logn"},{"instruction":"import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n\nn,k=nninp()\nnos=math.floor(math.sqrt(2*k))\nfor i in range(nos,12309123):\n    if((i*(i+1))\/\/2-k+i==n):\n        print((i*(i+1))\/\/2-k)\n        exit()","output":"logn"},{"instruction":"def main():\n    n = int(input())\n    s = input()\n    for i in range(n+1):\n        flag = True\n        stones = i\n        for j in s:\n            if j == '-':\n                if stones > 0:\n                    stones -= 1\n                else:\n                    flag = False\n                    break\n            else:\n                stones += 1\n\n        if flag:\n            n = i\n            break\n\n    stones = n\n    for i in s:\n        if i == '-':\n            stones -= 1\n        else:\n            stones += 1\n\n    print(stones)\n\nmain()","output":"quadratic"},{"instruction":"first = [int(i) for i in input()]\nsecond = [int(i) for i in input()]\n\npref_dists = [\n    [0] + [int(0 != c) for c in second],\n    [0] + [int(1 != c) for c in second]\n]\nfor i in range(1, len(second) + 1):\n    pref_dists[0][i] += pref_dists[0][i - 1]\n    pref_dists[1][i] += pref_dists[1][i - 1]\n\ntotal = 0\nfor i, c in enumerate(first):\n    end = len(second) - (len(first) - i)\n    total += pref_dists[c][end + 1] - pref_dists[c][i]\nprint(total)","output":"linear"},{"instruction":"def is_good(x, n, k):\n    y = k - x + 1\n    return (y + k * (k - 1) \/\/ 2 - y * (y - 1) \/\/ 2) >= n\n\nif __name__ == '__main__':\n    n, k = [int(x) for x in input().split()]\n    if n == 1:\n        print(0)\n    elif (k + (k - 2) * (k - 1) \/\/ 2) < n:\n        print(-1)\n    elif k >= n:\n        print(1)\n    else:\n        l = 0\n        r = k\n        while r > l + 1:\n            m = (l + r) \/\/ 2\n\n            if is_good(m, n, k):\n                r = m\n            else:\n                l = m\n        print(r)","output":"logn"},{"instruction":"from math import inf\nn, m, k = map(int, input().split())\nhorizontal = []\nvertical = []\nfor _ in range(n):\n    horizontal.append(list(map(int, input().split())))\nfor _ in range(n - 1):\n    vertical.append(list(map(int, input().split())))\nif k & 1:\n    ans = [\"-1\"] * m\n    for _ in range(n):\n        print(*ans)\nelse:\n    grid = [[0 for i in range(m)] for j in range(n)]\n    for _ in range(k \/\/ 2):\n        X = [[inf for i in range(m)] for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i >= 1:\n                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])\n                if i < n - 1:\n                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])\n                if j >= 1:\n                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])\n                if j < m - 1:\n                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])\n\n        grid = X[:]\n    for _ in range(n):\n        print(*grid[_])","output":"cubic"},{"instruction":"import sys\n\ndef dp(ri, gi, bi):\n    if ri>r or gi>g or bi>b:\n        return 0\n\n    if not list_memo[ri][gi][bi]==-1:\n        return list_memo[ri][gi][bi]\n\n    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])\n    return list_memo[ri][gi][bi]\n\nr, g, b = map(int, sys.stdin.readline().split())\n\nr_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\ng_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\nb_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\n\nlist_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n\nprint(dp(0, 0, 0))","output":"cubic"},{"instruction":"import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,m=read()\na=[]\nfor i in range(n):\n    a.append(read())\nsm=0\ncur=0\nfor x, y in a:\n    sm+=y\n    cur+=x\nif sm>m:\n    print(-1)\n    quit()\ncnt=0\na.sort(key=lambda x: -x[0]+x[1])\ni = 0\nwhile cur>m and i < n:\n    cur -= a[i][0]-a[i][1]\n    cnt += 1\n    i += 1\nprint(cnt)","output":"nlogn"},{"instruction":"a = int(input())\nc = [1] * 30\nfor i in range (1,20):\n\tc[i] = 9 * i * pow(10,i-1)\nfor i in range (1,15):\n\tif (a > c[i]):\n\t\ta -= c[i]\n\telse:\n\t\td = int((a-1) \/ i + pow(10,i-1) - 1)\n\t\te = (a-1) % i + 1\n\t\tf = str(d+1)\n\t\tprint(f[e-1])\n\t\texit()","output":"logn"},{"instruction":"def my_cmp(x):\n    if x[0] == 0:\n        return float('inf')\n    return x[1]\/x[0]\n\ndef dis(a, b):\n    return a*a + b*b\n\nn = int(input())\nv = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    v.append((x, y, i))\nv.sort(key = my_cmp)\nx, y = 0, 0\nans = [0]*n\nfor i in range(n):\n    if dis(x+v[i][0], y+v[i][1]) < dis(x-v[i][0], y-v[i][1]):\n        ans[v[i][2]] = 1\n    else:\n        ans[v[i][2]] = -1\n    x += v[i][0]*ans[v[i][2]]\n    y += v[i][1]*ans[v[i][2]]\nfor x in ans:\n    print(x, end = ' ')","output":"nlogn"},{"instruction":"n = int(input())\ngraph = [set() for tr in range(n+2)]\ni = 1\nwhile i < n:\n\tx, y = map(int, input().split())\n\tgraph[x].add(y)\n\tgraph[y].add(x)\n\ti += 1\na = iter(map(int, input().split()))\ntry:\n\tassert next(a) == 1\n\tq = [1]\n\tfor v in q:\n\t\tgv = graph[v]\n\t\tgv1 = tuple(gv)\n\t\tfor tr2 in gv1:\n\t\t\tu = next(a)\n\t\t\tassert u in gv\n\t\t\tgv.remove(u)\n\t\t\tgraph[u].remove(v)\n\t\t\tq.append(u)\n\tprint(\"Yes\")\nexcept AssertionError:\n\tprint(\"No\")","output":"linear"},{"instruction":"def max_profit(n,k,l,d):\n    a=[]\n    p,i=0,-1\n    while(len(a)!=k-1):\n        p+=1\n        i+=1\n        if l[i] in d:\n            a.append(p)\n            p=0\n            d.remove(l[i])\n    a.append(n-sum(a))\n    print(*a)\n\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nd=sorted(l,reverse=True)[:k]\nprint(sum(d))\nmax_profit(n,k,l,d)","output":"nlogn"},{"instruction":"from heapq import heappop, heappush\n\nn, m, k = [int(i) for i in input().split()]\nif k % 2 == 1:\n    for _ in range(n):\n        print(\" \".join([\"-1\"] * m))\n    exit()\n\nE_right = []\nfor i in range(n):\n    E_right.append([int(j) for j in input().split()])\n\nE_down = []\nfor i in range(n - 1):\n    E_down.append([int(j) for j in input().split()])\n\nP = [[0 for _ in range(m)] for _ in range(n)]\nnew_P = [[0 for _ in range(m)] for _ in range(n)]\n\nfor k in range(k \/\/ 2 + 1):\n    for i in range(n):\n        for j in range(m):\n            possible = []\n            if i - 1 >= 0:\n                e = E_down[i - 1][j]\n                possible.append(P[i - 1][j] + e)\n\n            if i + 1 < n:\n                e = E_down[i][j]\n                possible.append(P[i + 1][j] + e)\n\n            if j - 1 >= 0:\n                e = E_right[i][j - 1]\n                possible.append(P[i][j - 1] + e)\n\n            if j + 1 < m:\n                e = E_right[i][j]\n                possible.append(P[i][j + 1] + e)\n\n            new_P[i][j] = min(possible)\n\n    tmp = P\n    P = new_P\n    new_P = tmp\n\nfor i in range(n):\n    print(\" \".join(str(s * 2) for s in new_P[i]))","output":"cubic"},{"instruction":"n,a,b=list(map(int,input().split()))\nd=[]\nfor i in range(n):\n    d.append([\"1\"]*n)\n    d[i][i]=\"0\"\nif [n,a,b]==[2,1,1]:\n    print(\"NO\")\nelif [n,a,b]==[3,1,1]:\n    print(\"NO\")\nelif a==1:\n    c=n-b\n    for i in range(c):\n        d[i][i+1]=\"0\"\n        d[i+1][i]=\"0\"\n    print(\"YES\")\n    for i in range(n):\n        print(\"\".join(d[i]))\nelif a!=1 and b!=1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(a-1):\n        for j in range(n):\n            d[i][j]=\"0\"\n        for j in range(n):\n            d[j][i]=\"0\"\n    for i in range(n):\n        print(\"\".join(d[i]))","output":"quadratic"},{"instruction":"n,k = [int(s) for s in input().split()]\np = [int(s) for s in input().split()]\n\nmap = {}\nres = []\n\nfor pi in p:\n    if map.get(pi) is None:\n        key = pi\n        for j in range(pi, pi-k, -1):\n            if j < 0: break\n            if map.get(j) is None:\n                key = j\n            else:\n                if map[j] >= pi-k+1: key = map[j]\n                break\n        for j in range(pi, key-1, -1):\n            if map.get(j):\n                break\n            map[j] = key\n    res.append(map[pi])\n\nprint(*res, sep=\" \")","output":"quadratic"},{"instruction":"import math\nfrom sys import stdin\n\nI=stdin.readline\n\ns=I()\nt=I()\n\np=0\nfor c in s:\n\tif(c=='+'): p+=1\n\npt,qt=0,0\n\nfor c in t:\n\tif(c=='+'):pt+=1\n\telif(c=='?'): qt+=1\n\nreq=p-pt\nif(req>qt or req<0): ans=0\n\nelse:\n\tans=(math.factorial(qt)\/math.factorial(req))\n\tans\/=math.factorial(qt-req)\n\tans\/=pow(2,qt)\n\nprint(ans)","output":"np"},{"instruction":"a=input()\nn=len(a)\nfor l in range(n,0,-1):\n  for i in range(n-l+1):\n    if a[i:i+l] in a[i+1:]:\n      print(l)\n      exit(0)\nprint(0)","output":"cubic"},{"instruction":"k=int(input())\n\nnum_digits=1\nnum_numbers=9\n\nk-=1\nwhile k>num_digits*num_numbers:\n\n    k -= num_numbers*num_digits\n    num_digits += 1\n    num_numbers *= 10\n\nnumber = 10**(num_digits - 1) + k \/\/ num_digits\n\nindex = k % num_digits\nanswer = str(number)[index]\nprint(answer)","output":"constant"},{"instruction":"test=int(input())\nwhile test:\n\ttest=test-1\n\tn,k = input().split()\n\tn=int(n)\n\tk=int(k)\n\ts=0\n\tcurr=1\n\tct=0\n\twhile s<k:\n\t\ts=s+curr\n\t\tcurr=4*curr\n\t\tct=ct+1\n\tif n>=35:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\tval=[]\n\tval.append(0)\n\tfor i in range(1,n):\n\t\tval.append(1+4*val[i-1])\n\ts=0\n\tt=2\n\trem=0\n\twhile n>0:\n\t\ts=s+t-1\n\t\tt*=2\n\t\tp=3\n\t\trem=rem+(t-3)*(val[n-1])\n\t\trem=int(rem)\n\t\tif rem+s>=k and s<=k:\n\t\t\tprint(\"YES\",n-1)\n\t\t\tn=-2\n\t\t\tbreak\n\t\tn=n-1\n\tif n != -2:\n\t\tprint(\"NO\")","output":"logn"},{"instruction":"first,last=input().split()\nusername=first[0]\nfirst=first[1:]\nwhile first!=\"\" and first[0]<last[0]:\n    username=username+first[0]\n    first=first[1:]\nprint(username+last[0])","output":"linear"},{"instruction":"n, m = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\ni = 1\nfor x in arr:\n\tif len(d) == m:\n\t\tbreak\n\td[x] = i\n\ti += 1\nif len(d) == m:\n\tprint(min(d.values()), max(d.values()))\nelse:\n\tprint(-1,-1)","output":"linear"},{"instruction":"n = int(input())\nax, ay = list(map(int, input().split(' ')))\nbx, by = list(map(int, input().split(' ')))\ncx, cy = list(map(int, input().split(' ')))\n\nif ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,m=map(int,input().split())\nl=[]\nfor i in range(n):\n    l.append([int(i) for i in input().split()])\nleft=0\nright=10**9+1\nwhile left<right:\n    mid=(left+right)\/\/2\n    dicta={}\n    for i in range(n):\n        mask=0\n        for j in range(m):\n            mask<<=1\n            if l[i][j]>=mid:\n                mask+=1\n        dicta[mask]=i\n    ok=False\n    for i in dicta:\n        for j in dicta:\n            if i|j==(2**m-1):\n                ok=True\n                ans=(dicta[i]+1,dicta[j]+1)\n                break\n        if ok ==True:\n            break\n    if ok==True:\n        left=mid+1\n    else:\n        right=mid\n\nprint(*ans)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit()\n\nA = [None]*n\n\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n\ndef is_colinear(a1,a2,a3):\n    if a1 == a2 or a2 == a3 or a1 == a3:\n        return True\n\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = a3\n\n    if x1 == x2 or x1 == x3 or x2 == x3:\n        return x1 == x2 == x3\n    if y1 == y2 or y1 == y3 or y2 == y3:\n        return y1 == y2 == y3\n    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\nX,Y,Z = A[0],A[1],A[2]\n\ndef good(X,Y):\n\n    bad = []\n    for i in range(n):\n        if not is_colinear(X,Y,A[i]):\n            bad.append(A[i])\n\n    if len(bad) <= 2:\n        return True\n\n    U,V = bad[0],bad[1]\n    for i in range(len(bad)):\n        if not is_colinear(U,V,bad[i]):\n            return False\n    return True\n\nif good(X,Y) or good(Y,Z) or good(X,Z):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")\nexit()","output":"nlogn"},{"instruction":"def ch_x(stri, n):\n    res = ''\n    for i in range(len(stri)):\n        if i != n:\n            res += stri[i]\n        else:\n            res += 'x'\n    return res\n\na = input()\nb = input()\nn = 0\nfor i in range(0, len(a)):\n    if a[i] == '0' and b[i] == '0':\n        c = [i-1, i+1]\n        for e in c:\n            if 0 <= e < len(a):\n                if a[e] == '0':\n                    n += 1\n                    a = ch_x(a, e)\n                    break\n                if b[e] == '0':\n                    n += 1\n                    b = ch_x(b, e)\n                    break\n        a = ch_x(a, i)\n        b = ch_x(b, i)\nprint(n)","output":"constant"},{"instruction":"nab = [int(i) for i in input().split()]\nn = nab[0]\na = nab[1]\nb = nab[2]\nh = sorted([int(i) for i in input().split()])\nprint(h[b] - h[b-1])","output":"nlogn"},{"instruction":"q = int(input())\nfor rquer in range(q):\n\tc, r = map(int, input().split())\n\tmatt = [list(map(int,input().split())) for i in range(c)]\n\tmat = [[matt[i][j] for i in range(c)] for j in range(r)]\n\tfor i in range(r):\n\t\tmat[i].append(max(mat[i]))\n\t\tmat[i].reverse()\n\tmat.sort()\n\tmat.reverse()\n\twork = mat[:min(4, r)]\n\tfor t in work:\n\t\tt.pop(0)\n\tr = min(4, r)\n\twyn = 0\n\tfor num in range(c**r):\n\t\tshif = [(num\/\/(c**i))%c for i in range(r)]\n\t\tnew = 0\n\t\tfor i in range(c):\n\t\t\tkol = [work[j][(i + shif[j])%c] for j in range(r)]\n\t\t\tnew += max(kol)\n\t\twyn = max(wyn, new)\n\tprint(wyn)","output":"np"},{"instruction":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        output = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (-nums[i], i))\n            if i >= k - 1:\n                while heap[0][1] <= i - k:\n                    heapq.heappop(heap)\n                output.append(-heap[0][0])\n        return output","output":"nlogn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nb=[]\nmaxi=0\nfor i in range(n):\n    maxi=max(maxi,a[i]+1)\n    b.append(maxi)\nc=[]\ncount=b[-1]\nfor i in range(n-1,-1,-1):\n    if count-1>=b[i]:\n        count-=1\n        c.append(count)\n    else:\n        c.append(count)\nc=c[::-1]\nans=0\nfor i in range(n):\n    ans+=(c[i]-a[i]-1)\nprint(ans)","output":"linear"},{"instruction":"a = list(input())\nb = list(input())\nn = len(a)\na.sort()\n\ndef listtostring(string):\n    return ''.join([str(ele) for ele in string])\n\nfor i in range(0,n):\n    for j in range(0,n):\n        t = a.copy()\n        t[i],t[j] = t[j],t[i]\n        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):\n\n            a[i],a[j] = a[j],a[i]\n\nprint(listtostring(a))","output":"cubic"},{"instruction":"a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\nb=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nprint(a)\nprint(b)","output":"constant"},{"instruction":"import math\nn, k = map(int, input().split())\n\nq = int(-3 + math.sqrt(9 + 8*(n+k)))\/\/2\n\nr = n-q\n\nprint(r)","output":"constant"},{"instruction":"inp = input().split()\nn = int(inp[0])\nk = int(inp[1])\n\na = input().split()\nfor i in range(n):\n    a[i] = int(a[i])\n\nbank  = {}\n\nfor i in range(n):\n    arg = (len(str(a[i])),a[i]%k)\n\n    bank[arg] = bank.get(arg,0)+1\n\nans = 0\n\nfor i in range(n):\n    ten = 1\n    for j in range(1,11):\n        ten*=10\n        frontMod = (a[i]*ten)%k\n\n        req = (k-frontMod)%k\n\n        got = bank.get((j,req),0)\n        ans += got\n\nfor i in range(n):\n    cur = str(a[i])\n    cur = cur*2\n    tst = int(cur)\n    if(tst%k==0):\n        ans-=1\n\nprint(ans)","output":"nlogn"},{"instruction":"n,s=map(int,input().split())\nh=list()\nm=list()\nl=list()\nl.append(0)\nfor _ in range(n):\n    x,y=map(int,input().split())\n    h.append(x)\n    m.append(y)\n    l.append((x*60)+y)\nif(l[1]!=0 and (l[1]-l[0])>=s+1):\n    print(0,0)\nelse:\n    k=2*s+2\n    r=0\n    for i in range(n):\n        if(l[i+1]-l[i]>=k):\n            r=l[i]+s+1\n            break\n        else:\n            continue\n    if(r==0):\n        r=l[n]+s+1\n    print(r\/\/60,r%60)","output":"linear"},{"instruction":"def roll(i,j):\n    ways = []\n    if j:\n        ways.append(2*hor[i][j-1] + grid[i][j-1])\n    if m-1-j:\n        ways.append(2*hor[i][j] + grid[i][j+1])\n    if i:\n        ways.append(2*ver[i-1][j] + grid[i-1][j])\n    if n-1-i:\n        ways.append(2*ver[i][j] + grid[i+1][j])\n    return min(ways)\n\nn , m , k = map(int, input().split())\nhor = [list(map(int, input().split())) for _ in range(n)]\nver = [list(map(int, input().split())) for _ in range(n-1)]\n\ngrid = [[0]*m for _ in range(n)]\nif k%2:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\nelse:\n    for _ in range(k\/\/2):\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\n        grid = new_grid[:]\n    for i in range(n):\n        print(\" \".join(map(str,grid[i])))","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nYOKO=[list(map(int,input().split())) for i in range(n)]\nTATE=[list(map(int,input().split())) for i in range(n-1)]\n\nif k%2==1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\n\nDP=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n\n        MIN=1<<30\n\n        if j-1>=0:\n            MIN=min(MIN,YOKO[i][j-1]*2)\n        if j<m-1:\n            MIN=min(MIN,YOKO[i][j]*2)\n\n        if i-1>=0:\n            MIN=min(MIN,TATE[i-1][j]*2)\n        if i<n-1:\n            MIN=min(MIN,TATE[i][j]*2)\n\n        DP[i][j]=MIN\n\nDP0=DP[:]\n\nfor tests in range(k\/\/2-1):\n    NDP=[[0]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            MIN=DP[i][j]+DP0[i][j]\n\n            if 0<=i+1<n:\n                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])\n\n            if 0<=i-1<n:\n                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])\n\n            if 0<=j+1<m:\n                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])\n\n            if 0<=j-1<m:\n                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])\n\n            NDP[i][j]=MIN\n    DP=NDP\n\nfor dp in DP:\n    print(*dp)","output":"cubic"},{"instruction":"n,kk=map(int,input().split())\ns=input()\nif(s==s[::-1] or s!=s[::-1]):\n    k=\"\"\n    l=0\n    for i in reversed(range(1,n)):\n        k=s[i]+k\n\n        if(s.startswith(k)):\n            l=len(k)\n    ss=s[l:]\n    fs=s+(ss*(kk-1))\n    print(fs)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nrr, gg, bb = map(int, input().split())\ninf = 114514\nr = list(map(int, input().split())) + [inf]\ng = list(map(int, input().split())) + [inf]\nb = list(map(int, input().split())) + [inf]\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\ndp = []\nfor _ in range(rr + 1):\n    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])\nans = 0\nfor i in range(rr + 1):\n    ri = r[i]\n    for j in range(gg + 1):\n        gj = g[j]\n        for k in range(bb + 1):\n            bk = b[k]\n            if (i + j + k) % 2:\n                continue\n            dpijk = 0\n            if i > 0 and j > 0:\n                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)\n            if j > 0 and k > 0:\n                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)\n            if k > 0 and i > 0:\n                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)\n            dp[i][j][k] = dpijk\n            if ans < dpijk:\n                ans = dpijk\nprint(ans)","output":"cubic"},{"instruction":"R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\ndp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]\ndef recurser(x,y,z):\n    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):\n        return 0\n    if dp[x][y][z]!=-1:\n        return dp[x][y][z]\n    maxi=0\n    if x<R and y<G:\n        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z))\n    if y<G and z<B:\n        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1))\n    if z<B and x<R:\n        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))\n    dp[x][y][z]=maxi\n    return maxi\nprint(recurser(0,0,0))","output":"cubic"},{"instruction":"from math import *\na, vm = map(int, input().split())\nl, d, vd = map(int, input().split())\nif vm <= vd or sqrt(2 * a * d) <= vd:\n    if vm ** 2 \/ (2 * a) >= l:\n        ans = sqrt(2 * l \/ a)\n    else:\n        ans = vm \/ a + (l - vm ** 2 \/ (2 * a)) \/ vm\nelse:\n    s1 = (vm ** 2 - vd ** 2) \/ (2 * a)\n    if s1 >= (l - d):\n        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) \/ (2 * a)\n    else:\n        ans = (vm - vd) \/ a + (l - d - s1) \/ vm\n    v1 = sqrt((2 * a * d + vd ** 2) \/ 2)\n    if v1 <= vm:\n        ans = ans + v1 \/ a + (v1 - vd) \/ a\n    else:\n        s1 = d - (vm ** 2 - vd ** 2) \/ (2 * a) - (vm ** 2) \/ (2 * a)\n        ans = ans + vm \/ a + (vm - vd) \/ a + s1 \/ vm\nprint('%.12f' % ans)","output":"constant"},{"instruction":"def check_combination(v):\n    sm = sum(v)\n    if l <= sm <= r:\n        if max(v) - min(v) >= x:\n            global ans\n            ans += 1\n\ndef go(offset, k):\n\n    if k == 0:\n        check_combination(combination)\n        return\n    for i in range(offset, len(problems) - k + 1):\n        combination.append(problems[i])\n        go(i+1, k-1)\n        combination.pop()\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nproblems = list()\ncombination = list()\n\nans = 0\n\nfor i in range(2, len(c) + 1):\n    problems = c.copy()\n    go(0, i)\n\nprint(ans)","output":"np"},{"instruction":"import sys\nimport math\n\nt=1\nfor _ in range(t):\n\n    a=input()\n    b=input()\n    dp=[0]*(11)\n    for i in a:\n        dp[int(i)]+=1\n\n    if len(b)>len(a):\n        ans=''\n        for i in range(len(a)):\n            for j in range(9,-1,-1):\n                if dp[j]!=0:\n                    ans+=str(j)\n                    dp[j]-=1\n                    break\n    elif len(a)==len(b):\n        ans=''\n        a1=[]\n        cmpr=''\n        i=0\n        while i<len(a):\n            cmpr+=b[i]\n\n            if i==0:\n                flag=0\n                for j in range(9,0,-1):\n                    if ans+str(j)<=cmpr and dp[j]!=0:\n                        flag=1\n                        dp[j]-=1\n                        ans+=str(j)\n                        a1.append(j)\n                        break\n                if flag==0:\n                    dp[1]-=1\n                    a1.append(1)\n                    ans+='1'\n            else:\n                flag=0\n                for j in range(9,-1,-1):\n                    if ans+str(j)<=cmpr and dp[j]!=0:\n                        flag=1\n                        ans+=str(j)\n                        a1.append(j)\n                        dp[j]-=1\n                        break\n\n                if flag==0:\n                    ch=0\n                    for i1 in range(i-1,-1,-1):\n                        if ch==1:\n                            break\n                        for j1 in range(int(ans[i1])-1,-1,-1):\n                            if i1==0:\n                                if j1>0 and dp[j1]!=0:\n                                    dp[a1[i1]]+=1\n                                    dp[j1]-=1\n                                    index=i1\n                                    a1.pop()\n                                    a1.append(j1)\n                                    ch=1\n                                    break\n                            else:\n                                if  dp[j1]!=0:\n                                    dp[a1[i1]]+=1\n                                    dp[j1]-=1\n                                    a1.pop()\n                                    index=i1\n\n                                    a1.append(j1)\n                                    ch=1\n                                    break\n                            if ch==1:\n                                break\n                        if ch==1:\n                            break\n                        val=a1.pop()\n                        dp[val]+=1\n\n                    ans=''\n                    cmpr=''\n\n                    dp=[0]*11\n                    for i1 in range(len(a)):\n                        dp[int(a[i1])]+=1\n\n                    for i1 in range(len(a1)):\n                        dp[a1[i1]]-=1\n\n                    for i1 in range(len(a1)):\n                        ans+=str(a1[i1])\n                        cmpr+=b[i1]\n                    i=index\n\n            i+=1\n    print(ans)","output":"cubic"},{"instruction":"import math\ndef getdt():\n    return map(int,input().split())\ndef calc(v0,v,a,x):\n    t = (v - v0)\/a\n    x0 = v0 * t + 0.5*a*t*t\n    if x0>=x:\n        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)\/a)\n    return (x0,t)\ndef go(v0,v,a,x):\n    x0,t = calc(v0,v,a,x)\n    return t + (x-x0)\/v\na,v = getdt()\nl,d,w = getdt()\nif w>v:\n    w = v\nx,t = calc(0,w,a,d)\nif x==d:\n    print(go(0,v,a,l))\nelse:\n    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))","output":"constant"},{"instruction":"import math\ns1=input()\ns2=input()\nif(s2.count('?')==0):\n    if(s1.count('+')==s2.count('+') and s1.count('-')==s2.count('-')):\n        p=1\n    else:\n        p=0\nelse:\n    if((s1.count('+')< s2.count('+')!=0) or (s1.count('-')==0<s2.count('-')!=0)):\n        p=0\n    else:\n        pl=s1.count('+')-s2.count('+')\n        mi=s1.count('-')-s2.count('-')\n        p=(math.factorial((pl+mi))\/math.factorial(pl)\/math.factorial(mi))\/2**(pl+mi)\nprint('%1.9f'%p)","output":"np"},{"instruction":"nab=input().split()\nl=input().split()\nnab=[int(i) for i in nab]\nl=[int(i) for i in l]\nl.sort()\nif(l[nab[2]-1]==l[nab[2]]):\n    print(0)\nelse:\n    print(l[nab[2]]-l[nab[2]-1])","output":"nlogn"},{"instruction":"import sys\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solve(N, S, C):\n    dp = [float('inf')] * N\n    for i in range(1, N):\n        for j in range(i):\n            if S[j] < S[i]:\n                dp[i] = min(dp[i], C[j] + C[i])\n\n    dp2 = [float('inf')] * N\n    for i in range(N - 1, 0, -1):\n        for j in range(i + 1, N, 1):\n            if S[i] < S[j]:\n                dp2[j] = min(dp2[j], dp[i] + C[j])\n\n    ans = min(dp2)\n    if ans == float('inf'):\n        return -1\n    return ans\n\nN = int(input())\nS = get_ints()\nC = get_ints()\n\nprint(solve(N, S, C))","output":"quadratic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n\n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n\n    return powerset_orderred\ndef fastPlrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n\nfor _ in range(t):\n    n,k = li()\n    if k<=n:\n        print((k-1)\/\/2)\n    else:\n        print(max((2*n-k+1)\/\/2,0))","output":"constant"},{"instruction":"import math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num \/\/ i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())","output":"np"},{"instruction":"def luckynumber(n):\n    a=[]\n    for i in range(4,n+1):\n        r=i\n        c=0\n        while(r>0):\n            x=r%10\n            if x!=4 and x!=7:\n                c=1\n                break\n            r=r\/\/10\n        if c==0:\n            a.append(i)\n    return a\nn=int(input())\na=luckynumber(n)\nfor i in a:\n    if n==i or n%i==0:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        rotated = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            for j in range(n):\n                rotated[j][n - 1 - i] = matrix[i][j]\n\n        for i in range(n):\n            for j in range(n):\n                matrix[i][j] = rotated[i][j]","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nmx = -1\nfor step, elem in enumerate(a):\n    if elem > mx + 1:\n        print(step + 1)\n        exit(0)\n    else:\n        mx = max(mx, elem)\nprint(-1)","output":"linear"},{"instruction":"import math\n\na=input()\nb=input()\nx1=a.count('+')\ny1=a.count('-')\nx2=b.count('+')\ny2=b.count('-')\nl=b.count('?')\nif l==0 and(x1==x2 and y1==y2):\n\tprint(float(1))\nelif x1>(x2+l) or y1>(y2+l):\n\tprint(float(0))\nelse:\n\tw=math.factorial(l)\n\tm=math.factorial(x1-x2)\n\tn=math.factorial(l-(x1-x2))\n\tprint((w\/(m*n)) \/2**(x1+y1-x2-y2))","output":"np"},{"instruction":"n = int(input())\n\nx, y = map(int, input().split())\n\nans = (x - 1) + (y - 1) <= (n - x) + (n - y)\nprint('White' if ans else 'Black')","output":"constant"},{"instruction":"n = int(input())\nprint(n * n + (n - 1) **2)","output":"constant"},{"instruction":"n = int(input())\nAb = input().split()\nUn = []\nAl = [0]\nr = 0\nfor i in range(n):\n    Ab[i] = int(Ab[i])\n    Al.append(max(Ab[i]+1,Al[i]))\nfor i in range(n,-1,-1):\n    if Al[i-1] < Al[i] - 1:\n        Al[i-1] = Al[i] - 1\nfor i in range(n):\n    Un.append(Al[i+1]-Ab[i]-1)\n    r += Un[-1]\nprint(r)","output":"linear"},{"instruction":"import sys\nfrom math import sqrt,log2\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn=input()\nct=0\ni=0\ns=[]\nwhile i <len(n):\n    if not int(n[i])%3:\n        ct+=1\n        s.clear()\n    else:\n        t=int(n[i])%3\n        if 3-t in s:\n            ct+=1\n            s.clear()\n        else:\n            s.append(t)\n    if len(s)==3:\n        ct+=1\n        s.clear()\n    i+=1\n\nprint(ct)","output":"linear"},{"instruction":"n, k = map(int, input().split())\n\na, b, c = 0, k, 0\n\nwhile a < b:\n    c = (a + b) \/\/ 2\n    if c * n < k:\n        a = c + 1\n    else:\n        b = c\n\nprint(a)","output":"logn"},{"instruction":"r,g,b = map(int,input().split())\nrs = list(map(int,input().split()))\ngs = list(map(int,input().split()))\nbs = list(map(int,input().split()))\nrs.sort()\ngs.sort()\nbs.sort()\nrs.reverse()\ngs.reverse()\nbs.reverse()\ndp = [[[0]*201 for x in range(201)] for y in range(201)]\nfor i in range(min(r,g)+1):\n    for j in range(min(g,b)+1):\n        for k in range(min(b,r)+1):\n            options = []\n\n            if i == 0:\n                pass\n            elif i+k-1 < r and i+j-1 < g:\n                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])\n            else:\n                options.append(dp[i-1][j][k])\n            if j == 0:\n                pass\n            elif i+j-1 < g and j+k-1 < b:\n                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])\n            else:\n                options.append(dp[i][j-1][k])\n            if k == 0:\n                pass\n            elif j+k-1 < b and i+k-1 < r:\n                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])\n            else:\n                options.append(dp[i][j][k-1])\n            if len(options) == 0:\n                continue\n            dp[i][j][k] = max(options)\nprint(dp[min(r,g)][min(g,b)][min(r,b)])","output":"cubic"},{"instruction":"global fact,inv_fact\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n\tglobal fact, inv_fact\n\n\tmax_n = min(max_n, mod - 1)\n\n\tfact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n\tfact[0] = 1\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\nmake_nCr_mod()\ndef comb(n, r):\n\tmod=10**9+7\n\tglobal fact,inv_fact\n\tres = 1\n\twhile n or r:\n\t\ta, b = n % mod, r % mod\n\t\tif a < b:\n\t\t\treturn 0\n\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\tn \/\/= mod\n\t\tr \/\/= mod\n\treturn res\ndef f():\n\tdp=[0]*(1000+100)\n\tdp[1]=1\n\n\tfor i in range(2,len(dp)):\n\t\to=bin(i).count(\"1\")\n\t\tif o==1:\n\t\t\tdp[i]=2\n\t\telse:\n\t\t\tdp[i]+=dp[o]+1\n\treturn dp\n\ndef bit(s,k):\n\tdp=f()\n\tl=[]\n\tans=0\n\tll=len(s)\n\tans=0\n\tones=0\n\tif k==0:\n\t\treturn 1\n\tfor i  in range(ll):\n\t\tif s[i]==\"0\":\n\t\t\tcontinue\n\t\telse:\n\t\t\tfor j in range(max(ones,1),1000):\n\t\t\t\tif dp[j]==k:\n\t\t\t\t\tans=(ans+comb(ll-i-1,j-ones))%(10**9+7)\n\t\t\t\t\tif i==0 and k==1:\n\t\t\t\t\t\tans-=1\n\t\tones+=1\n\tif dp[ones]==k:\n\t\tans+=1\n\treturn (ans)%(10**9+7)\n\ns=input().strip()\nk=int(input())\nprint(bit(s,k))","output":"linear"},{"instruction":"import math\n\nn, m, k, l = map(int, input().split())\n\nx = (l + k) \/\/ m\nif x * m < l + k:\n    x += 1\nassert x * m >= l + k\n\nif m * x > n:\n    print(-1)\nelse:\n    print(x)","output":"constant"},{"instruction":"n=int(input())\ns=input()\nans=0\nfor i in s:\n    if(i=='+'):\n        ans+=1\n    else:\n        ans-=1\n    if(ans<0):\n        ans=0\nprint(ans)","output":"linear"},{"instruction":"n,m=map(int,input().split())\na=[int(input(),2)for _ in range(n)]\n\ns=t=0\nfor x in a:\n    t|=s&x\n    s|=x\nprint(('YES','NO')[all(x&s&~t for x in a)])","output":"quadratic"},{"instruction":"x, k = map(int, input().split())\n\nif x == 0:\n    print(0)\n    exit()\n\nmod = 10 ** 9 + 7\n\na = ((x % mod) * pow(2, k + 1, mod)) % mod\n\nprint((a - (pow(2, k, mod) - 1)) % mod)","output":"logn"},{"instruction":"from queue import Queue\nimport datetime\n\nwith open(\"input.txt\", 'r') as in_file:\n    n, m = (int(i) for i in in_file.readline().split(\" \"))\n    k = int(in_file.readline())\n    ints = [int(i) for i in in_file.readline().split(\" \")]\n\npairs = []\nfor i in range(0, len(ints), 2):\n    x = ints[i]\n    y = ints[i+1]\n    pairs.append((x, y))\n\nlast_tree = (1, 1)\nmaxd = 0\nmult = m * n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        md = mult\n\n        for pair in pairs:\n            x, y = pair\n            d = abs(i-x)+abs(j-y)\n\n            md = min(md, d)\n\n        if md > maxd:\n\n            last_tree = (i, j)\n            maxd = md\n\nwith open(\"output.txt\", 'w') as out_file:\n    out_file.write(f\"{last_tree[0]} {last_tree[1]}\")","output":"cubic"},{"instruction":"n=int(input())-1\nprint(2*n*(n+1)+1)","output":"constant"},{"instruction":"def gen(n):\n    if n == 1:\n        yield '0'\n        yield '1'\n    else:\n        for s in gen(n - 1):\n            yield s+'0'\n            yield s +'1'\n\nn, l, r, x = map(int, input().split())\ncnt = 0\nC = list(map(int, input().split()))\nfor pos in gen(n):\n    A = []\n    for i in range(n):\n        if pos[i] == '1':\n            A.append(C[i])\n    A.sort()\n    if len(A):\n        if l <= sum(A) <= r and A[-1] - A[0] >= x:\n            cnt += 1\nprint(cnt)","output":"np"},{"instruction":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        def dfs(i, target):\n            if i >= len(nums):\n                return target == 0\n            if target < 0:\n                return False\n\n            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])\n\n        return dfs(0, sum(nums) \/\/ 2)","output":"np"},{"instruction":"inp = list(map(int, input().strip().split()))\nmoves = inp[0]\ncandiesAtTheEnd = inp[1]\n\ndef find(moves, candiesAtTheEnd):\n  result = -1\n  start = 0\n  end = moves-1\n  while result!=candiesAtTheEnd:\n\n    mid=((end-start+1)\/\/2)+start\n\n    pluses=moves-mid\n    minuses=mid\n\n    result=((pluses+1)\/2)*pluses\n    result=result-minuses\n\n    if result==candiesAtTheEnd:\n      return minuses\n    elif result>candiesAtTheEnd:\n      start=mid\n    else:\n      end=mid\n\nresult_final=find(moves,candiesAtTheEnd)\nprint(result_final)","output":"logn"},{"instruction":"def main():\n    n = int(input())\n    a = list(map(lambda x: int(x), input().split(\" \")))\n    b = list(map(lambda x: int(x), input().split(\" \")))\n    now = 0\n    ans = []\n    h = set()\n    for i in range(n):\n        count = 0\n        while b[i] not in h:\n            h.add(a[now])\n            now += 1\n            count += 1\n        ans.append(str(count))\n    print(\" \".join(ans))\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"def dig(d):\n    return ord(d) - ord('0')\n\ndef biggest_left(counts):\n    res = ''\n    for i in range(9, -1, -1):\n        res += str(i) * counts[i]\n    return res\n\ndef ok(d, _counts, rest):\n    if rest == '':\n        return True\n\n    counts = _counts.copy()\n    counts[d] -= 1\n\n    r = ''\n    for i in range(10):\n        r += str(i) * counts[i]\n\n    return int(r) <= int(rest)\n\ndef main():\n    a, b = input(), input()\n\n    counts = [0] * 10\n    for d in a:\n        counts[dig(d)] += 1\n\n    ans = ''\n    if len(a) < len(b):\n        print(biggest_left(counts))\n        return\n\n    n = len(a)\n    for i in range(n):\n        d = dig(b[i])\n\n        if counts[d] and ok(d, counts, b[i+1:]):\n            ans += b[i]\n            counts[d] -= 1\n        else:\n            for s in range(d-1, -1, -1):\n                if counts[s] > 0:\n                    ans += str(s)\n                    counts[s] -= 1\n                    ans += biggest_left(counts)\n                    print(ans)\n                    return\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\n\ndupes = 0\ndupeVal = -1\nd = set()\nfor el in a:\n    if el in d:\n        dupes += 1\n        dupeVal = el\n    else:\n        d.add(el)\n\ninPlay = True\nif dupes > 1:\n    print('cslnb')\n    inPlay = False\nelif dupes == 1:\n    if dupeVal == 0 or (dupeVal - 1) in d:\n        print('cslnb')\n        inPlay = False\n\nif inPlay:\n    finalSum = (n*(n-1))\/\/2\n    Sum = sum(a)\n    if (Sum - finalSum) % 2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')","output":"linear"},{"instruction":"n = int(input())\nn+=1\nif n==1:\n\tprint(0)\nelif n%2==0:\n\tprint(n\/\/2)\nelif n%2!=0 and n!=1:\n\tprint(n)","output":"constant"},{"instruction":"n, a, b = map(int,input().split())\nif a>1 and b>1: print(\"NO\"); exit()\nif 2<=n<=3 and a == b == 1: print(\"NO\"); exit()\nprint(\"YES\")\n\nif b == 1:\n    adj = [[0]*n for i in range(n)]\n    conn = n\n    for i in range(n):\n        if conn == a: break\n        adj[i][i+1] = adj[i+1][i] = 1\n        conn-= 1\n        if conn == a: break\nelif a == 1:\n    adj = [[1]*n for i in range(n)]\n    conn = n\n    for i in range(n): adj[i][i] = 0\n    for i in range(n):\n        if conn == b: break\n        adj[i][i+1] = adj[i+1][i] = 0\n        conn-= 1\n        if conn == b: break\n\nfor row in adj:\n    print(*row, sep='')","output":"quadratic"},{"instruction":"from collections import Counter\nmp = Counter()\nn = int(input())\narr = list(map(int,input().split()))\n\ntot , cnt, ans = 0, 0, 0\nfor i in arr:\n\tncnt = cnt - mp[i] - mp[i+1] - mp[i-1]\n\tntot = tot - (i * mp[i]) - ((i-1)*mp[i-1]) - ((i+1)*mp[i+1])\n\tnsum = (ncnt * i) - ntot\n\tans += nsum\n\tmp[i] += 1\n\tcnt += 1\n\ttot += i\nprint(ans)","output":"nlogn"},{"instruction":"n,m=[int(x) for x in input().split()]\nans1=\"1\"*1500\nans2=\"8\"*1499+\"9\"\nprint(ans1)\nprint(ans2)","output":"constant"},{"instruction":"n,m=map(int,input().split())\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\nout=[]\nfirst=11\nfor a in range(len(x)):\n    for b in range(len(y)):\n\n        if y[b]==x[a]:\n            if first<a:\n                first=a;\n                out.append(y[b])\n\n                b+=1\n\n            else:\n                out.insert(0,y[b])\n\n                b+=1\n\n        else:\n\n            b+=1\nout.reverse()\nfor a in out:\n    print(a)","output":"quadratic"},{"instruction":"import pprint\nnr, ng, nb = map(int, input().split())\n*r, = map(int, input().split())\n*g, = map(int, input().split())\n*b, = map(int, input().split())\ndp = []\nfor _ in range(nr + 1):\n    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])\n\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\nmx = 0\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if i and j:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            if i and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])\n            if j and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])\n\nmx_i = mx_j = mx_k = -1\n\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if dp[i][j][k] > mx:\n                mx_i = i\n                mx_j = j\n                mx_k = k\n                mx = dp[i][j][k]\n\nprint(mx)","output":"cubic"},{"instruction":"q = int(input())\n\nfor _ in range(q):\n    n, m, k = map(int, input().split())\n    if k == 0:\n        if n == 0 and m == 0:\n            print(0)\n        else:\n            print(-1)\n    elif k == 1:\n        if max(abs(n), abs(m)) != 1:\n            print(-1)\n        elif abs(n) == abs(m) == 1:\n            print(1)\n        else:\n            print(0)\n    else:\n        if max(abs(n), abs(m)) > k:\n            print(-1)\n        elif abs(n) == abs(m):\n            if (k - abs(n)) % 2 == 0:\n                print(k)\n            else:\n                print(k - 2)\n        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:\n            if (k - max(abs(n), abs(m))) % 2 == 0:\n                print(k)\n            else:\n                print(k - 2)\n        else:\n            print(k - 1)","output":"constant"},{"instruction":"def solve(n,k):\n    print(1*k,end = ' ')\n    if n==2:\n        print(2*k,end = ' ')\n    if n == 3:\n        print(k,3*k,end = ' ')\n    else:\n        temp = n\/\/2\n        if(n%2 == 0): temp -= 1\n        print((str(k)+' ')*temp,end='')\n        if(n>3):\n            solve(n\/\/2,k*2)\n\nn = int(input())\nsolve(n,1)","output":"linear"},{"instruction":"n,m,k,l=map(int,input().split())\nq=(l+k-1)\/\/m+1\nif q*m>n:print(-1)\nelse:print(q)","output":"constant"},{"instruction":"def aburrimin(x, y, n, m, costder, costaba, dp):\n    dists = []\n    vals = []\n    if x != 0:\n        dis = costder[y][x-1]\n        dists.append(dis)\n        vals.append(dis+dp[y][x-1])\n    if y != 0:\n        dis = costaba[y-1][x]\n        dists.append(dis)\n        vals.append(dis+dp[y-1][x])\n    if y < n-1:\n        dis = costaba[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y+1][x])\n    if x < m-1:\n        dis = costder[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y][x+1])\n\n    mindis = min(dists)\n    return min(mindis+dp[y][x],min(vals))\n\ndef solvecaso():\n    n,m,k = map(int,input().split())\n    costder = [[int(x) for x in input().split()] for _ in range(n)]\n    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]\n    if k%2:\n        for i in range(n):\n            for j in range(m):\n                print(-1, end=' ')\n            print()\n        return -1\n    k \/\/= 2\n\n    for ren in range(len(costder)):\n        for col in range(len(costder[ren])):\n            costder[ren][col] *= 2\n    for ren in range(len(costaba)):\n        for col in range(len(costaba[ren])):\n            costaba[ren][col] *= 2\n\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dptemp = [[0 for _ in range(m)] for _ in range(n)]\n\n    for i in range(k):\n        for y in range(n):\n            for x in range(m):\n                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)\n        dp, dptemp = dptemp, dp\n\n    for ren in dp:\n        for num in ren:\n            print(num, end=' ')\n        print()\n\n    return 0\n\nif __name__ == \"__main__\":\n\n    solvecaso()","output":"cubic"},{"instruction":"print(int(input()) \/\/ 2 + 1)","output":"constant"},{"instruction":"class Combi():\n\n    def __init__(self, N, mod=10**9 + 7):\n        self.power = [1 for _ in range(N+1)]\n        self.rev = [1 for _ in range(N+1)]\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n\n    def com(self, K, R):\n        if not (0 <= R <= K):\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n\n    def perm(self, K, R):\n        if not (0 <= R <= K):\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n\ndef bitcnt(X):\n    res = 0\n    v = X\n    while v:\n        res += v & 1\n        v >>= 1\n    return res\n\nc = Combi(10000)\nNL = list(map(int, list(input())))[::-1]\nN = len(NL)\nK = int(input())\nMOD = 10**9 + 7\n\ndp = [[0]*(1020) for i in range(1020)]\n\ndp[0][0] = 1\nfor pos, bit in enumerate(NL):\n    if bit == 1:\n        for bit in range(1010):\n            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD\n        continue\n    else:\n        for bit in range(1010):\n            dp[pos + 1][bit] = dp[pos][bit]\n        continue\n\nINF = 1 << 60\ncnt = [INF]*(1010)\n\ncnt[1] = 0\nMOD = 10**9 + 7\n\nfor i in range(2, 1010):\n    cnt[i] = 1 + cnt[bitcnt(i)]\n\nif K == 0:\n    print(dp[N][0])\n    exit()\nelse:\n    ans = 0\n    for bitcnt in range(1010):\n        if cnt[bitcnt] == K - 1:\n            ans += dp[N][bitcnt]\n    if K == 1:\n        ans -= 1\n    print(ans % MOD)\n    exit()","output":"linear"},{"instruction":"from itertools import *\nn,least,highest,x = map(int,input().split())\nl = [*map(int,input().split())]\ncnt = 0\nfor i in range(2,n + 1):\n    combination = [*map(list,combinations(l,i))]\n    for j in range(len(combination)):\n        combination[j].sort()\n\n        total = sum(combination[j])\n        if(total >= least and total <= highest and combination[j][-1] - combination[j][0] >= x):\n            cnt += 1\nprint(cnt)","output":"np"},{"instruction":"import random\nfor _ in range(int(input())):\n    N, M = map(int, input().split())\n    X = [[int(a) for a in input().split()] for _ in range(N)]\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    for t in range(99):\n        for i in range(M):\n            a = random.randrange(N)\n            Y[i] = [Y[i][j-a] for j in range(N)]\n        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))\n    print(ma)","output":"np"},{"instruction":"import math\n\nn, r = (int(x) for x in input().split())\n\ns = math.sin(math.pi\/n)\nans = (r*s)\/(1-s)\n\nprint(\"%.7f\" % ans)","output":"constant"},{"instruction":"a,b=map(int,input().split())\nif max(a,b)-min(a,b) +1<=2:\n    print(-1)\nelif max(a,b)-min(a,b) +1==3:\n    if a % 2==1 and b %2==1:\n        print(-1)\n    else:\n        print(min(a,b),min(a,b)+1,min(a,b)+2)\nelse:\n    ans=0\n    for i in range(a,b+1):\n        if i%2==0:\n            ans=i\n            break\n    print(ans,ans+1,ans+2)","output":"constant"},{"instruction":"for _ in range(int(input())):\n\tdef get(n):\n\t\treturn (4**n-1)\/\/3\n\tn,k = map(int,input().split())\n\tif n<32 and 4**n < 1*3*k:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tnow = 1\n\tp = 2\n\tans = n\n\tsq = 0\n\tbuff = 0\n\td = 4\n\twhile k>=now:\n\t\tk -= now\n\t\tp *= 2\n\t\tnow = p-1\n\t\tans -= 1\n\n\t\tsq = sq*4 + d-3\n\t\td *= 2\n\t\tif n < 60:\n\t\t\tbuff += sq * (4**ans-1)\/\/3\n\t\telse:\n\t\t\tbuff = 10**19\n\n\t\tif ans == 0: break\n\n\tif buff < k: print(\"NO\")\n\telse: print(\"YES\",max(ans,0))","output":"logn"},{"instruction":"MOD = 10**9 + 7\nx, k = map(int, input().split())\ny = (2*x - 1) % MOD\nmult = pow(2, k, MOD)\nif x:\n    print((y * mult + 1) % MOD)\nelse:\n    print(0)","output":"logn"},{"instruction":"n = int(input())\nls1 = [int(i) for i in input().split()]\nls2 = [int(i) for i in input().split()]\n\nans = float('inf')\n\nfor i in range(1, n - 1):\n    l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]]\n    r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]]\n\n    if len(l) and len(r):\n        ans = min(ans, min(l) + min(r) + ls2[i])\n\nprint([-1 , ans][ans != float('inf')])","output":"quadratic"},{"instruction":"from sys import maxsize, stdout, stdin,stderr\nmod = int(1e9+7)\nimport sys\ndef I(): return int(stdin.readline())\ndef lint(): return [int(x) for x in stdin.readline().split()]\ndef S(): return input().strip()\ndef grid(r, c): return [lint() for i in range(r)]\nfrom collections import defaultdict, Counter, deque\nimport math\nimport heapq\nfrom heapq import heappop , heappush\nimport bisect\nfrom itertools import groupby\ndef gcd(a,b):\n    while b:\n        a %= b\n        tmp = a\n        a = b\n        b = tmp\n\n    return a\n\ndef lcm(a,b):\n    return a  \/\/ gcd(a, b) * b\n\ndef check_prime(n):\n    for i in range(2, int(n ** (1 \/ 2)) + 1):\n        if not n % i:\n            return False\n    return True\ndef Bs(a, x):\n    i=0\n    j=0\n    left = 1\n    right = x\n    flag=False\n    while left<right:\n\n        mi = (left+right)\/\/2\n\n        if a[mi]<=x:\n            left = mi+1\n            i+=1\n\n        else:\n\n            right = mi\n            j+=1\n\n    if left>0 and a[left-1]==x:\n        return i-1, j\n    else:\n        return -1, -1\ndef nCr(n, r):\n\n    return (fact(n) \/\/ (fact(r)\n                * fact(n - r)))\n\ndef fact(n):\n\n    res = 1\n\n    for i in range(2, n+1):\n        res = res * i\n\n    return res\ndef primefactors(n):\n    num=0\n\n    while n % 2 == 0:\n        num+=1\n        n = n \/ 2\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n        while n % i== 0:\n            num+=1\n            n = n \/\/ i\n\n    if n > 2:\n        num+=1\n    return num\n\ndef ask(a):\n    print('? {}'.format(a),flush=True)\n    n=I()\n\n    return n\n\ndef dfs(i,p):\n\n    a,tmp=0,0\n    for j in d[i]:\n        if j!=p:\n            a+=1\n            tmp+=dfs(j,i)\n\n    if a==0:\n        return 0\n\n    return tmp\/a + 1\ndef primeFactors(n):\n    l=[]\n\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/\/ 2\n\n    if n > 2:\n        l.append(n)\n    return l\na = sorted(input())\nb = int(input())\na = a[::-1]\np = ''\ncnt = [0]*10\n\nwhile a :\n    for i, d in enumerate(a):\n        n = p + d + \"\".join(sorted(a[:i]+a[i+1:]))\n\n        if int(n) <= b :\n            p += d\n            a.pop(i)\n\n            break\n\nprint(p)","output":"cubic"},{"instruction":"n,v = map(int,input().split())\n\nif n <= v + 1:\n    print( n - 1 )\nelse:\n    b = n - v\n    print( v - 1 + ((b*(b+1))\/\/2))","output":"constant"},{"instruction":"n, l, r, x = list(map(int, input().split()))\ns = list(map(int, input().split()))\nolmps = []\nc = []\nv = 0\nfor i in range(1<<n):\n    olmps.append([])\n    for j in range(n):\n        if i & (1<<j):\n            olmps[-1].append(s[j])\nfor o in olmps:\n    if l <= sum(o) <= r:\n        c.append(o)\nfor z in c:\n    if max(z) - min(z) >= x:\n        v+=1\nprint(v)","output":"np"},{"instruction":"from collections import Counter\nn, k = map(int, input().split())\nc = Counter(input())\nans = min(c[chr(ord('A') + i)] for i in range(k))\nprint(k * ans)\n","output":"linear"},{"instruction":"import math\nn=int(input())\n\na=[9]\nfor i in range(2,20):\n    a.append(10**i   - 10**(i-1) )\nb=[0]\nfor i in range(1,20):\n    b.append(b[-1]+ i*a[i-1])\nfor i in range(20):\n    if n<=b[i]:\n        break\np=b[i-1]\nk=n-p\n\nans=10**(i-1) - 1 + math.ceil(k\/(i))\n\nif k%i==0:\n    print(('0'+str(ans))[i])\nelse:\n    print(('0'+str(ans))[k%i])","output":"constant"},{"instruction":"from sys import stdin, stdout\n\ndef pair_of_lines(n, xy_a):\n    if len(xy_a) <= 3:\n        return 'YES'\n\n    p1, p2, p3 = xy_a[0], xy_a[1], xy_a[2]\n    if judge(p1, kstr(p1, p2),xy_a):\n        return 'YES'\n    if judge(p1, kstr(p1, p3),xy_a):\n        return 'YES'\n    if judge(p2, kstr(p2, p3), xy_a):\n        return 'YES'\n    return 'NO'\n\ndef kstr(xy1, xy2):\n    cx, cy = xy1[0], xy1[1]\n    x, y = xy2[0], xy2[1]\n    dx = x - cx\n    dy = y - cy\n    k = ''\n    if dx == 0:\n        k = str(x) + '\/y'\n    elif dy == 0:\n        k = 'x\/' + str(y)\n    else:\n        g = gcd(dx, dy)\n        dx \/\/= g\n        dy \/\/= g\n        k = str(dx) + '\/' + str(dy)\n    return k\n\ndef judge(p, k, xy_a):\n\n    rl = []\n    for xy in xy_a:\n        if p[0] == xy[0] and p[1] == xy[1]:\n            continue\n        if kstr(p, xy) != k:\n            rl.append(xy)\n\n    if len(rl) > 2:\n        ck = kstr(rl[0], rl[1])\n        for i in range(2, len(rl)):\n            if ck != kstr(rl[0], rl[i]):\n                return False\n\n    return True\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ntry:\n    n = int(stdin.readline())\n    xy_a = []\n    for _ in range(n):\n        xy_a.append(list(map(int, stdin.readline().split())))\n    res = pair_of_lines(n, xy_a)\n    stdout.write(res)\nexcept Exception as e:\n  print(e)","output":"nlogn"},{"instruction":"from itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N)\n    pres = [None]*(1<<N)\n    allb = (1 << N)-1\n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0]\n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\nimport sys\nst = time()\nmain()\nprint('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)","output":"np"},{"instruction":"n, m, k = map(int, input().split());\na = list(map(int, input().split()));\na.sort(reverse = True);\nif sum(a)+k-n < m:\n    print(-1);\nelif k >= m:\n    print(0);\nelse:\n    for i in range (1, n+1):\n        if sum(a[:i])+k-i >= m:\n            print(i)\n            break;","output":"nlogn"},{"instruction":"m,n=[int(ele) for ele in input().split()]\na=[]\nfor i in range(m):\n    a.append(list(map(int, input().split())))\n\nina,mo=0,10**9+1\npos1,pos2=0,0\nmask=(1<<n)-1\ndef check(tang):\n    key=set()\n    dic=dict()\n    for i in range(m):\n        temp=0\n        for j in range(n):\n            if a[i][j]>=tang:\n\n                temp+=(1<<j)\n\n        if temp in key:\n            continue\n        key.add(temp)\n        tempk=temp\n        while tempk>=0:\n            tempk &= temp\n            dic[tempk]=i\n            tempk-=1\n\n        tocheck = mask ^ temp\n\n        if tocheck in dic:\n            return dic[tocheck],i,True\n\n    return -1,-1,False\n\nwhile ina<mo-1:\n\n    tang=(ina+mo)\/\/2\n\n    temppos1,temppos2,status=check(tang)\n\n    if status:\n        pos1,pos2=temppos1,temppos2\n        ina=tang\n    else:\n        mo=tang\nprint(pos1+1,pos2+1)","output":"np"},{"instruction":"from itertools import permutations\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([list(map(int, list(input()))) for j in range(n)])\n    if i < 3:\n        input()\n\nans = 10 ** 10\nfor i in permutations(a, 4):\n    cnt = 0\n    total = 0\n    for j in i:\n        if cnt < 2:\n            cnt2 = 0\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        else:\n            cnt2 = 1\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        cnt += 1\n\n    ans = min(ans, total)\n\nprint(ans)","output":"quadratic"},{"instruction":"def solve(a):\n    aa = sorted(a)\n    maxr = aa[0]\n    for ai in aa:\n        if ai[2] != maxr[2]:\n            if ai[1] <= maxr[1] and ai[0] >= maxr[0]:\n                return(ai[2], maxr[2])\n            if ai[1] >= maxr[1] and ai[0] <= maxr[0]:\n                return(maxr[2], ai[2])\n        if ai[1] > maxr[1]:\n            maxr = ai\n    return(-1, -1)\n\nn = int(input())\na = []\nfor i in range(n):\n    l,r = [int(s) for s in input().split()]\n    a.append((l, r, i+1))\ni,j = solve(a)\nprint(i,j)","output":"nlogn"},{"instruction":"MAXN = 200001\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))\n\nf = [0 for i in range(n+1)]\ncount = [0 for i in range(-MAXN, MAXN+1)]\n\nf[0] = 0\n\nlast = 0\nres = 0\n\nfor i in range(1, n+1):\n    if s[i-1] == m:\n        for j in range(last, i):\n            count[f[j]] += 1\n        last = i\n\n    if s[i-1] > m:\n        f[i] = f[i-1] - 1\n    else:\n        f[i] = f[i-1] + 1\n\n    res += count[f[i]] + count[f[i]-1]\n\nprint(res)","output":"nlogn"},{"instruction":"from sys import stdin,stdout\nfrom collections import deque\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\nPI=float('inf')\nM=10**9+7\nfor _ in range(1):\n    n=nmbr()\n    s=[input() for _ in range(n)]\n    dp=[[0 for _ in range(n+1)] for _ in range(n+1)]\n    dp[0][0]=1\n    for i in range(1,n):\n        for j in range(n):\n            if i>=1 and s[i-1]=='f':\n                if j>=1:dp[i][j]=dp[i-1][j-1]-(dp[i-1][j])\n            elif i>=1:\n                dp[i][j]=dp[i-1][j]\n            dp[i][j]%=M\n        for k in range(n-1,-1,-1):\n            dp[i][k]=(dp[i][k]+dp[i][k+1])%M\n\n    print(dp[n-1][0]%M)","output":"quadratic"},{"instruction":"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n\n        for start, end in intervals:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nc = [-1]*256\n\nans = [0]*n\nfor i in range(n):\n    if c[a[i]] == -1:\n        for j in range(a[i], max(-1, a[i]-k), -1):\n            if c[j] != -1:\n                if (c[j] +k) > a[i]:\n                    c[a[i]] = c[j]\n                else:\n                    c[a[i]] = j+1\n                break\n        if c[a[i]] == -1:\n            c[a[i]] = max(0, a[i]-k+1)\n        for xx in range(c[a[i]], a[i]):\n            c[xx] = c[a[i]]\n    ans[i] = str(c[a[i]])\n\nprint(' '.join(ans))","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ndef next(k,a):\n    i=k+1\n    while a[i]!=1: i+=1\n    return i\n\nans=[0]*(m+1)\n\nk=-1\nk=next(k,b)\nans[1]=k\nfor i in range(2,m+1):\n    kk=next(k,b)\n    for j in range(k+1,kk):\n        if a[j]-a[k]<=a[kk]-a[j]:\n            ans[i-1]+=1\n        else:\n            ans[i]+=1\n    k=kk\n\nans[m]+=(n+m-1-k)\n\nfor i in range(1,m+1):\n    print(ans[i],end=' ')","output":"quadratic"},{"instruction":"def f(a,b):\n\tr=list(bin(b).lstrip(\"0b\"))\n\tl=list((len(bin(b))-len(bin(a)))*(\"0\")+bin(a).lstrip(\"0b\"))\n\tfor i in range(len(r)):\n\t\tif (r[i]==\"1\" and l[i]==\"1\"):\n\t\t\tr[i]=\"0\"\n\t\t\tif int(\"\".join(r),2)>=a:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tr[i]=\"1\"\n\t\tif l[i]==\"0\" and r[i]==\"0\":\n\t\t\tl[i]=\"1\"\n\t\t\tif int(\"\".join(l),2)<=b:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tl[i]=\"0\"\n\tl=int(\"\".join(l),2)\n\tr=int(\"\".join(r),2)\n\treturn l^r\n\na,b=map(int,input().strip().split())\nprint(f(a,b))","output":"logn"},{"instruction":"def solve():\n\tr,g,b=map(int,input().split())\n\tR=list(map(int,input().split()))\n\tG=list(map(int,input().split()))\n\tB=list(map(int,input().split()))\n\tR.sort(reverse=True)\n\tG.sort(reverse=True)\n\tB.sort(reverse=True)\n\tdp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)]\n\tfor i in range(r+1):\n\t\tfor j in range(g+1):\n\t\t\tfor k in range(b+1):\n\t\t\t\tif i<r and j<g:\n\t\t\t\t\tdp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])\n\t\t\t\tif i<r and k<b:\n\t\t\t\t\tdp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])\n\t\t\t\tif j<g and k<b:\n\t\t\t\t\tdp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j])\n\tans=0\n\tfor i in range(r+1):\n\t\tfor j in range(g+1):\n\t\t\tfor k in range(b+1):\n\t\t\t\tans=max(ans,dp[i][j][k])\n\treturn ans\nprint(solve())","output":"cubic"},{"instruction":"n = int(input())\n\nl = list(map(int,input().split()))\n\ns = list(set(l))\n\ns.sort()\n\nif len(s)>1:\n    ans = s[1]\nelse:\n    ans='NO'\n\nprint(ans)","output":"nlogn"},{"instruction":"n, m, k, l = [int(x) for x in input().split()]\nif (l + k) % m == 0:\n    c = (l + k)\/\/m\nelse:\n    c = (l + k)\/\/m + 1\nif m * c > n:\n    print(-1)\nelse:\n    print(c)","output":"constant"},{"instruction":"n = int(input())\na = n * (n + 1) \/\/ 2\nprint(4 * a - 4 * n + 1)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\ndef main():\n\n    n = getN()\n    nums = getList()\n    nums.sort()\n    margins = [num - i for i, num in enumerate(nums)]\n    for m in margins:\n        if m < 0:\n            print(\"cslnb\")\n            return\n    flag = False\n    if len(nums) > 1:\n        if nums[0] == nums[1]:\n                flag = True\n    for a, b, c in zip(nums, nums[1:], nums[2:]):\n        if b == c:\n            if a == b or b - a == 1:\n                print(\"cslnb\")\n                return\n            if flag:\n                print(\"cslnb\")\n                return\n            flag = True\n\n    margin = sum(margins)\n\n    if margin % 2 == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  r=range(i%x,n,x)\n  if s[i]==0:\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))","output":"quadratic"},{"instruction":"n, v = map(int, input().split())\ncur = 0\ntotal = 0\nfor i in range(n):\n    while cur < n - i - 1:\n        cur += 1\n        total += (i + 1)\n        if cur == v:\n            break\n    cur -= 1\nprint(total)","output":"quadratic"},{"instruction":"def get_path_hv(A, B):\n\tx, y = A\n\n\tpath = [(x, y)]\n\n\twhile x < B[0]:\n\t\tx += 1\n\t\tpath.append((x, y))\n\n\twhile x > B[0]:\n\t\tx -= 1\n\t\tpath.append((x, y))\n\n\twhile y < B[1]:\n\t\ty += 1\n\t\tpath.append((x, y))\n\n\twhile y > B[1]:\n\t\ty -= 1\n\t\tpath.append((x, y))\n\n\treturn path\n\ndef get_path_vh(A, B):\n\tx, y = A\n\n\tpath = [(x, y)]\n\n\twhile y < B[1]:\n\t\ty += 1\n\t\tpath.append((x, y))\n\n\twhile y > B[1]:\n\t\ty -= 1\n\t\tpath.append((x, y))\n\n\twhile x < B[0]:\n\t\tx += 1\n\t\tpath.append((x, y))\n\n\twhile x > B[0]:\n\t\tx -= 1\n\t\tpath.append((x, y))\n\n\treturn path\n\nA = tuple(map(int, input().split()))\nB = tuple(map(int, input().split()))\nC = tuple(map(int, input().split()))\n\npaths = []\npaths.append([get_path_vh(A, B), get_path_hv(A, B)])\npaths.append([get_path_vh(C, B), get_path_hv(C, B)])\npaths.append([get_path_vh(A, C), get_path_hv(A, C)])\n\nans = 10 ** 8\nans_path = []\n\nfor i in range(3):\n\tfor j in range(3):\n\t\tif i != j:\n\t\t\tfor a in paths[i]:\n\t\t\t\tfor b in paths[j]:\n\t\t\t\t\tX = list(set([*a, *b]))\n\n\t\t\t\t\tif len(X) < ans:\n\t\t\t\t\t\tans = len(X)\n\t\t\t\t\t\tans_path = X\n\nprint(ans)\nfor p in ans_path:\n\tprint(*p)","output":"constant"},{"instruction":"n,pos,l,r = map(int,input().split())\nif(r-l+1 == n):\n    print(0)\n    exit(0)\nif(pos>l and pos<r):\n    if(n>r and l>1):\n        x = pos-l+1+r-l+1\n        y = r-pos+1+r-l+1\n        ans = min(x,y)\n    else:\n        if(n==r):\n            ans = pos-l+1\n        elif(l==1):\n            ans = r-pos+1\nelif(pos>=r):\n    if(n>r):\n        ans = pos-r+1\n    else:\n        ans = 0\n    if(l>1):\n        ans+=r-l+1\nelif(pos<=l):\n    if(l>1):\n        ans = l-pos+1\n    else:\n        ans = 0\n    if(n>r):\n        ans+=r-l+1\nprint(ans)","output":"constant"},{"instruction":"n, m = map(int, input().split())\nbuf = []\nfor i in range(n\/\/2):\n    for j in range(m):\n        buf.append(f'{i + 1} {j + 1}\\n')\n        buf.append(f'{n - i} {m - j}\\n')\n\nif n % 2 == 1:\n    for j in range(m \/\/ 2):\n        buf.append(f'{n \/\/ 2 + 1} {j + 1}\\n')\n        buf.append(f'{n \/\/ 2 + 1} {m - j}\\n')\n    if m % 2 == 1:\n        buf.append(f'{n\/\/2 + 1} {m\/\/2 + 1}\\n')\nprint(*buf, sep='')","output":"quadratic"},{"instruction":"import math as m\na=input()\nb=input()\ntotal_sum=0\nreq_pos=0\nunreco=0\nfor i in a:\n    if i=='+':\n        total_sum+=1\n        req_pos+=1\n\n    elif i=='-':\n        total_sum-=1\nfor i in b:\n    if i=='+':\n        total_sum-=1\n        req_pos-=1\n\n    elif i=='-':\n        total_sum+=1\n    else:\n        unreco+=1\n\nif (total_sum==0 and unreco==0):\n    print(1.000000000)\nelif (abs(total_sum)>unreco or req_pos<0):\n    print(0.000000000)\nelse:\n    ans=m.factorial(unreco)\/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco))\n    print(ans)","output":"np"},{"instruction":"n,m = map(int,input().split())\nx = [0]*(n+1)\nfor i in range(n):\n    x[i] = int(input())\nx[n] = 1000000000\nvert = []\nfor i in range(m):\n    x1,x2,y = map(int,input().split())\n    if x1 == 1:\n        vert.append(x2)\nvert.sort()\nx.sort()\ncur = 0\nminicount = n+m\nk = len(vert)\nfor i in range(n+1):\n    while cur < k:\n        if x[i] <= vert[cur]:\n            break\n        cur += 1\n    minicount = min(minicount,k-cur+i)\nprint(minicount)","output":"nlogn"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\n\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s.rstrip()))\ndef invr():\n    return(map(int,input().split()))\nn, m, k=inlt()\nM=[[[] for i in range(m)] for j in range(n)]\nS=[[-1]*m for i in range(n)]\nfor y in range(n):\n\tL=inlt()\n\tfor x in range(m-1):\n\t\tM[y][x].append(((y, x+1), L[x]))\n\t\tM[y][x+1].append(((y, x), L[x]))\n\nfor y in range(n-1):\n\tL=inlt()\n\n\tfor x in range(m):\n\t\tM[y][x].append(((y+1, x), L[x]))\n\t\tM[y+1][x].append(((y, x), L[x]))\nif k%2==0:\n\tfor l in range(k\/\/2):\n\t\tS2=[[0]*m for i in range(n)]\n\t\tfor y in range(n):\n\t\t\tfor x in range(m):\n\t\t\t\tMi=10000000000000000000000\n\t\t\t\tfor ((a, b), p) in M[y][x]:\n\t\t\t\t\tMi=min(Mi,max(0,S[a][b])+p)\n\t\t\t\tS2[y][x]=Mi\n\t\tS=S2\n\tfor y in range(n):\n\t\tfor x in range(m):\n\t\t\tS[y][x]*=2\n\nfor y in range(n):\n\tprint(' '.join(list(map(str, S[y]))))","output":"cubic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(200001)]\npp=[0]*200001\ndef SieveOfEratosthenes(n=200000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\nxors = defaultdict(int)\nxors[0]=1\ncomp = (1<<k)-1\nans = n*(n+1)\/\/2\nxor = 0\nfor a in arr:\n\txor^=a\n\tif xors[xor]>xors[comp^xor]:\n\t\txor^=comp\n\tans-=xors[xor]\n\txors[xor]+=1\nprint(ans)","output":"linear"},{"instruction":"import io\nimport os\nimport sys\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef prdbg(*args, **kwargs):\n    print(*args, **kwargs)\n    pass\n\ndef get_str():\n    return input().decode().strip()\n\ndef rint():\n    return map(int, input().split())\n\ndef oint():\n    return int(input())\n\ndef valid(i1,i2,i3):\n    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\\\n            or i2 > i1 + i3 or i1 > i2 + i3:\n        return False\n    return True\n\ndef dfs(i1,i2,i3):\n\n    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \\\n                or i2 > i1 + i3 or i1 > i2 + i3:\n        return -2\n    if dp[i1][i2][i3] != -1:\n        return dp[i1][i2][i3]\n    ret1 = dfs(i1-1, i2-1, i3)\n    if ret1 >= 0 :\n        ret1 += a1[i1]*a2[i2]\n    ret2 = dfs(i1-1, i2, i3-1)\n    if ret2 >= 0:\n        ret2 += a1[i1]*a3[i3]\n    ret3 = dfs(i1, i2-1, i3-1)\n    if ret3 >= 0:\n        ret3 += a2[i2]*a3[i3]\n    ret = max(ret1, ret2, ret3)\n    dp[i1][i2][i3] = ret\n    return ret\n\nn1, n2, n3 = rint()\na1, a2, a3 = list(rint()), list(rint()), list(rint())\na1.sort(reverse=True)\na2.sort(reverse=True)\na3.sort(reverse=True)\na1 = [0] + a1\na2 = [0] + a2\na3 = [0] + a3\nn1 += 1\nn2 += 1\nn3 += 1\n\ndp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]\ndp[1][1][0] = a1[1]*a2[1]\ndp[1][0][1] = a1[1]*a3[1]\ndp[0][1][1] = a2[1]*a3[1]\ndp[0][0][0] = -2\n\nfor i1 in range(n1):\n    for i2 in range(n2):\n        for i3 in range(n3):\n            dfs(i1, i2, i3)\nans = -1\nfor i1 in range(n1):\n    for i2 in range(n2):\n        for i3 in range(n3):\n            ans = max(ans, dp[i1][i2][i3])\n\nprint(ans)","output":"cubic"},{"instruction":"n,m = list(map(int,input().split()))\nl = []\nfor i in range(n) :\n    s = input()\n    l.append(s)\nx1=0\nx2=0\ny1=0\ny2=0\nfor i in range (n) :\n    for j in range(m) :\n        if l[i][j]=='B' :\n            if x1==0 and y1==0 :\n                x1,y1 = [i+1,j+1]\n            else :\n                x2,y2 = [i+1,j+1]\nres = []\nx=0\ny=0\nif x2!=0 :\n    x = (x2 - x1) \/\/ 2\n    y = (y2 - y1) \/\/ 2\nres.append(x1+x)\nres.append(y1+y)\nprint(*res)","output":"quadratic"},{"instruction":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n\n        def matrix_mult(A, B):\n            return [[A[0][0] * B[0][0] + A[0][1] * B[1][0],\n                     A[0][0] * B[0][1] + A[0][1] * B[1][1]],\n                    [A[1][0] * B[0][0] + A[1][1] * B[1][0],\n                     A[1][0] * B[0][1] + A[1][1] * B[1][1]]]\n\n        def matrix_pow(M, p):\n            result = [[1, 0], [0, 1]]\n            base = M\n\n            while p:\n                if p % 2 == 1:\n                    result = matrix_mult(result, base)\n                base = matrix_mult(base, base)\n                p \/\/= 2\n\n            return result\n\n        M = [[1, 1], [1, 0]]\n        result = matrix_pow(M, n)\n        return result[0][0]","output":"logn"},{"instruction":"from collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef A():\n    n = I()\n    a = LI()\n    a.sort()\n    f = [1]*n\n    p = 0\n    ans = 0\n    while p < n:\n        while p < n and not f[p]:\n            p += 1\n        if p == n:\n            break\n        ans += 1\n        for i in range(n):\n            if a[i]%a[p] == 0:\n                f[i] = 0\n    print(ans)\n    return\n\ndef B():\n\n    return\n\ndef C():\n\n    return\n\ndef D():\n\n    return\n\ndef E():\n\n    return\n\ndef F():\n\n    return\n\ndef G():\n\n    return\n\ndef H():\n\n    return\n\nif __name__ == \"__main__\":\n    A()","output":"quadratic"},{"instruction":"t = int(input())\n\nfor iter in range(t):\n    n, k = map(int, input().split())\n    if n >= 50:\n        if k == 0:\n            print(\"YES \" + str(n))\n        else:\n            print(\"YES \" + str(n - 1))\n    else:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        c = [0] * (n + 1)\n        a[0] = 0\n        b[n] = 1\n        c[n] = 0\n\n        for i in range(1, n + 1):\n            a[i] = 4 * a[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            b[i] = b[i + 1] * 2 + 1\n        for i in range(n - 1, -1, -1):\n            c[i] = c[i + 1] + b[i + 1]\n\n        res = -1\n        for d in range(n + 1):\n            if c[d] <= k and k <= a[n] - a[d] * b[d]:\n                res = d\n\n        if res == -1:\n            print(\"NO\")\n        else:\n            print(\"YES \" + str(res))","output":"logn"},{"instruction":"n, K = map(int, input().split())\ndp = [[[0] * 4 for j in range(K + 2)] for i in range(n)]\nMOD = 998244353\ndp[0][1][0] = 1\ndp[0][1][1] = 1\ndp[0][2][2] = 1\ndp[0][2][3] = 1\nfor i in range(n - 1):\n    for j in range(1, K + 1):\n        if j < K + 1:\n            for k in range(4):\n                    dp[i + 1][j][k] += dp[i][j][k]\n                    dp[i + 1][j][k] %= MOD\n\n            for k in range(2):\n                dp[i + 1][j][k] += dp[i][j][2]\n                dp[i + 1][j][k] %= MOD\n\n            for k in range(2):\n                dp[i + 1][j][k] += dp[i][j][3]\n                dp[i + 1][j][k] %= MOD\n\n    for j in range(1, K):\n        for k in range(4):\n            if k != 0:\n                dp[i + 1][j + 1][k] += dp[i][j][0]\n                dp[i + 1][j + 1][k] %= MOD\n\n        for k in range(4):\n            if k != 1:\n                dp[i + 1][j + 1][k] += dp[i][j][1]\n                dp[i + 1][j + 1][k] %= MOD\n\n        if j + 2 < K + 1:\n            dp[i + 1][j + 2][2] += dp[i][j][3]\n            dp[i + 1][j + 2][2] %= MOD\n            dp[i + 1][j + 2][3] += dp[i][j][2]\n            dp[i + 1][j + 2][3] %= MOD\n\nnum = 0\nfor i in range(4):\n    num += dp[n - 1][K][i]\n    num %= MOD\n\nprint(num)","output":"np"},{"instruction":"class MinStack:\n    def __init__(self):\n        self.min = float('inf')\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n\n        pop = self.stack.pop()\n\n        if pop < 0:\n            self.min = self.min - pop\n\n    def top(self) -> int:\n        top = self.stack[-1]\n        if top > 0:\n            return top + self.min\n        else:\n            return self.min\n\n    def getMin(self) -> int:\n        return self.min","output":"constant"},{"instruction":"n, t = [int(item) for item in input().split(' ')]\ncont, ans = [], 2\nfor i in range(n):\n    hcenter, hlen = [float(item) for item in input().split(' ')]\n\n    cont.append([hcenter - hlen \/ 2, hcenter + hlen \/ 2])\n\ncont.sort(key=lambda it: it[0])\n\nfor i in range(n - 1):\n    gap = cont[i + 1][0] - cont[i][1]\n    if gap > t:\n        ans += 2\n    elif gap == t:\n        ans += 1\nprint(ans)","output":"nlogn"},{"instruction":"def comp(arr):\n    for i in range(len(arr)-1):\n        for j in range(0, len(arr)-i-1):\n            if(arr[j] in arr[j+1]):\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n    return arr[::-1]\n\nt = int(input())\nans = 1\narr = []\nfor j in range(t):\n    arr.append(input())\n\narr = comp(arr);\n\nfor j in range(0,t-1):\n    if arr[j] not in arr[j+1]:\n        ans = 0\n        break;\n\nif(ans == 0):\n    print(\"NO\")\n\nelse:\n    print(\"YES\")\n    for j in arr:\n        print(j)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = input()\nb = input()\nflag = 0\nfor c in a:\n    if(c == '*'):\n        flag = 1\nif(flag == 1):\n    a1, a2 = a.split('*')\n    Len1 = len(a1)\n    Len2 = len(a2)\n    b1 = b[:Len1]\n    b2 = ''\n    if(Len2):\n        b2 = b[-Len2:]\n    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):\n        print('YES')\n    else:\n        print('NO')\nelse:\n    if(a == b):\n        print('YES')\n    else:\n        print('NO')","output":"linear"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor _ in range(ii()):\n    l, r = mi()\n    l -= 1\n    sr = r \/\/ 2 + (r % 2) * -r\n    sl = l \/\/ 2 + (l % 2) * -l\n    print(sr - sl)","output":"constant"},{"instruction":"def maxXORInRange(L, R):\n\tLXR = L ^ R\n\tmsbPos = 0\n\twhile(LXR):\n\t\tmsbPos += 1\n\t\tLXR >>= 1\n\n\tmaxXOR = (1<<msbPos)-1\n\treturn maxXOR\n\nl,r=map(int,input().split())\nprint(maxXORInRange(l, r))","output":"logn"},{"instruction":"from sys import stdin\nfrom itertools import permutations\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nx1, y1, x2, y2, x3, y3 = rints()\n\nfor x in [[x1, y1], [y1, x1]]:\n    for y in [[x2, y2], [y2, x2]]:\n        for z in [[x3, y3], [y3, x3]]:\n            if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]:\n                print(x[1])\n                print('\\n'.join(\n                    ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in\n                                                                                             range(z[0])]))\n                exit()\n\nfor per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3):\n    for x in per[0][:-1]:\n        for y in per[1][:-1]:\n            for z in per[2][:-1]:\n                if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]:\n                    print(x[1])\n                    print('\\n'.join(\n                        [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in\n                                                                    range(y[0])]))\n                    exit()\n\nprint(-1)","output":"np"},{"instruction":"import sys\n\ngot=[10**18]*100005\n\ndef getnum(i):\n    if got[i]==10**18:\n        print(\"? %d\"%i)\n        sys.stdout.flush()\n        got[i]=int(input())\n    return got[i]\n\nn=int(input())\nif n%4==2:\n\n    print(\"! -1\")\nelse:\n    lo=1\n    hi=n\/\/2+1\n    t1=getnum(lo)\n    t2=getnum(hi)\n    lo2=t1-t2\n    hi2=t2-t1\n    if lo2==0:\n        print(\"! 1\")\n    else:\n\n        while lo<hi:\n            mid=(lo+hi)\/\/2\n\n            mid2=getnum(mid)-getnum(mid+n\/\/2)\n            if mid2==0:\n                print(\"! %d\"%mid)\n                break\n            if (lo2>0) == (mid2>0):\n                lo=mid+1\n            else:\n                hi=mid-1\n        else:\n            print(\"! %d\"%lo)\nsys.stdout.flush()","output":"logn"},{"instruction":"k = int(input())\nn = 1\nup_bnd = 9\nwhile(k > up_bnd):\n    n += 1\n    up_bnd += (9*n)*(10**(n-1))\nlow_bnd = 0\nfor i in range(1, n):\n    low_bnd += (9*i)*(10**(i-1))\nnum = int((k-low_bnd)\/n)\nlb_val = 0\nfor i in range(n-1):\n    lb_val = (lb_val*10)+9\nnum += lb_val\nrm = (k-low_bnd) % n\nif(rm != 0):\n    num += 1\nans = 0\nif(rm == 0):\n    ans = num % 10\nelse:\n    for i in range(n-rm+1):\n        j = (num % 10)\n        num = int(num\/10)\n        ans = j\nprint(int(ans))","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = effect[j][i+4-4]\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"import sys\nimport bisect\nimport heapq\n\nfrom collections import defaultdict as dd\nfrom collections import deque\nfrom collections import Counter as c\nfrom itertools import combinations as comb\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\n\ndef out(var): sys.stdout.write(var)\n\ndef l(): return list(map(int, data().split()))\n\ndef sl(): return list(map(str, data().split()))\n\ndef sp(): return map(int, data().split())\n\ndef ssp(): return map(str, data().split())\n\ndef l1d(n, val=0): return [val for i in range(n)]\n\ndef l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]\n\nn = int(data())\narr = l()\ndp = [[0 for j in range(500)] for i in range(500)]\ndp2 = [0 for i in range(501)]\nfor i in range(n):\n    dp[i][i] = arr[i]\ni = n-2\nwhile ~i:\n    j = i+1\n    while j < n:\n        dp[i][j] = -1\n        for k in range(i, j):\n            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:\n                dp[i][j] = dp[i][k]+1\n        j += 1\n    i -= 1\nfor i in range(1, n+1):\n    dp2[i] = pow(10, 9)\n    for j in range(i):\n        if ~dp[j][i-1]:\n            dp2[i] = min(dp2[i], dp2[j]+1)\nout(str(dp2[n]))","output":"cubic"},{"instruction":"n = int(input())\nl = [int(i) for i in input().split()]\nl.sort()\ns = set([l[0]])\nres = 1\nfor i in l:\n    f = 1\n    for j in s:\n        if(i%j == 0):\n            f = 0\n            break\n    if(f):\n        s.add(i)\n        res += 1\nprint(res)","output":"quadratic"},{"instruction":"n = int(input())\nans = 1\nif n == 1:\n    ans = 1\nelif n == 2:\n    ans = 2\nelif n == 3:\n    ans = 6\nelif n%2 == 0:\n    if n%3 == 0:\n        ans = (n-1)*(n-2)*(n-3)\n    else:\n        ans = n*(n-1)*(n-3)\nelse:\n    ans = n*(n-1)*(n-2)\n\nprint(ans)","output":"constant"},{"instruction":"t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")","output":"linear"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn = int(z())\na = zzz()\n\nd = {}\npower = [2**i for i in range(31)]\nans = []\nfor i in a:\n    d[i] = 0\n\nfor num in d.keys():\n    for p in power:\n        if num+p in d:\n            ans = [num, num+p]\n            if num+p+p in d:\n                print(3)\n                ans.append(num+p+p)\n                print(*ans)\n                exit()\nif ans:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(a[0])","output":"nlogn"},{"instruction":"def construct_tree(n,d, k):\n    nodes = []\n    edges = []\n\n    if d > n - 1:\n        return None\n\n    if k == 1 and n > 2:\n        return None\n\n    for i in range(1, d+2):\n        current_deg = k - 1 if i == 1 or i == d + 1 else k - 2\n        current_depth =  min(i-1, d-i+1)\n        if current_depth and current_deg:\n            nodes.append([i, min(i-1, d-i+1), current_deg])\n        if i < d + 1:\n            edges.append([i, i+1])\n\n    current_nodes_count = d + 2\n    pos = 0\n    while current_nodes_count < n + 1:\n\n        if pos >= len(nodes):\n            return None\n\n        current = nodes[pos]\n\n        if not current[2]:\n            pos += 1\n            if pos == len(nodes):\n                break\n            continue\n\n        if current[1] - 1 and k - 1:\n            nodes.append([current_nodes_count, current[1] - 1, k - 1])\n        edges.append([current[0], current_nodes_count])\n        current[2] -= 1\n        current_nodes_count += 1\n\n    if current_nodes_count == n + 1:\n        return edges\n    return None\n\nn, d, k = [int(val) for val in input().split()]\nedges = construct_tree(n, d, k)\nif edges:\n    print('YES')\n    print('\\n'.join(['{0} {1}'.format(e[0], e[1]) for e in edges]))\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n, m = [int(i) for i in input().split()]\nA = []\nct = []\nfor i in range(n):\n    x = list(input())\n    y = [0]*m\n    A.append(x)\n    ct.append(y)\nok = 1\nfor i in range(n-2):\n    for j in range(m-2):\n        if A[i][j]=='\n            ct[i][j] = 1\n            ct[i][j+1] = 1\n            ct[i][j+2] = 1\n            ct[i+1][j] = 1\n            ct[i+1][j+2] = 1\n            ct[i+2][j] = 1\n            ct[i+2][j+1] = 1\n            ct[i+2][j+2] = 1\n\nxct = 0\nxhs = 0\n\nfor i in range(len(ct)):\n    for j in range(len(ct[i])):\n        if ct[i][j] == 1:\n            xct+=1\n        if A[i][j] == '\n            xhs+=1\nif xhs==xct:\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\na = map(int, input().split())\nb = list(map(int, input().split()))\nfor x in a:\n    if x in b:\n        print(x, end=' ')\n","output":"quadratic"},{"instruction":"def solve(x, y, n):\n    return \"White\" if (x-1 + y-1) <= (n-x + n-y) else \"Black\"\n\ndef main():\n    n = int(input())\n    x, y = [int(i) for i in input().split()]\n    print(solve(x, y, n))\n\nmain()","output":"constant"},{"instruction":"from collections import Counter\nimport string\nimport math\nimport sys\n\nfrom fractions import Fraction\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\ndef vary(arrber_of_variables):\n    if arrber_of_variables==1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables>=2:\n        return map(int,sys.stdin.readline().split())\ndef makedict(var):\n    return dict(Counter(var))\ntestcases=1\nfor _ in range(testcases):\n    n,k=vary(2)\n    num=array_int()\n    maxi=0.0\n    for i in range(n):\n        count=1\n        sumt=num[i]\n\n        for j in range(i+1,n):\n            sumt+=num[j]\n            count+=1\n            if count>=k:\n\n                maxi=max(maxi,sumt\/count)\n\n    if k==1:\n        print(max(maxi,max(num)))\n    else:\n        print(maxi)","output":"quadratic"},{"instruction":"class DisjointSet:\n    def __init__(self, n):\n        self._fa = list(range(n))\n\n    def union(self, x, y):\n        x = self.get_father(x)\n        y = self.get_father(y)\n        self._fa[x] = y\n        return y\n\n    def get_father(self, x):\n        y = self._fa[x]\n        if self._fa[y] == y:\n            return y\n        else:\n            z = self._fa[y] = self.get_father(y)\n            return z\n\n    def __repr__(self):\n        return repr([self.get_father(i) for i in range(len(self._fa))])\n\ndef solve(n, a, b, xs):\n    h = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        if all(a - x in h for x in xs):\n            return [0] * n\n        return False\n    g1 = n\n    g2 = n + 1\n    ds = DisjointSet(n + 2)\n\n    for i, x in enumerate(xs):\n        for t in (a, b):\n            if t - x in h:\n                ds.union(i, h[t - x])\n\n    for i, x in enumerate(xs):\n        b1 = (a - x) in h\n        b2 = (b - x) in h\n        if b1 + b2 == 0:\n            return False\n        if b1 + b2 == 1:\n            if b1:\n                ds.union(i, g1)\n            else:\n                ds.union(i, g2)\n            if ds.get_father(g1) == ds.get_father(g2):\n                return False\n    group = [None] * n\n    for i, x in enumerate(xs):\n        f = ds.get_father(i)\n        if f < n:\n            return False\n        group[i] = f - n\n    return group\n\nn, a, b = map(int, input().split())\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')","output":"linear"},{"instruction":"from math import *\nfrom collections import *\nfrom random import *\nfrom decimal import Decimal\nfrom heapq import *\nfrom bisect import *\nimport sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**5)\ndef lis():\n    return list(map(int,input().split()))\ndef ma():\n    return map(int,input().split())\ndef inp():\n    return int(input())\ndef st1():\n    return input().rstrip('\\n')\nt=1\nwhile(t):\n    t-=1\n    r,g,b=ma()\n    rl=lis()\n    gl=lis()\n    bl=lis()\n    rl.sort()\n    bl.sort()\n    gl.sort()\n    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]\n    for i in range(r+1):\n        for j in range(g+1):\n            for k in range(b+1):\n                if(i+j+k<2):\n                    continue\n                if(i and j):\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])\n                if(j and k):\n                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])\n                if(i and k):\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])\n    print(dp[r][g][b])","output":"cubic"},{"instruction":"x, k = map(int, input().split())\nmod = 10**9+7\ne = (x * pow(2, k, mod)) % mod\ns = (e - pow(2, k, mod)) % mod\nf = lambda x: (x*(x+1))%mod\nans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod\nprint(ans if x != 0 else 0)","output":"logn"},{"instruction":"from collections import *\nn = int(input())\na = list(map(int,input().split()))\nd = Counter(a)\nans = 0\nfor i in range(n):\n    for j in range(31):\n        s = 1<<j\n        s = s-a[i]\n        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):\n            break\n    else:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\ns = list(input())\na = ord('A')\ncnt = [0] * k\nfor ch in s:\n    cnt[ord(ch) - a] += 1\nprint(k * min(cnt))","output":"linear"},{"instruction":"n=int(input())\nl1=[]\nl2=[]\nfor _ in range(n):\n    l1.append(input())\nfor _ in range(n):\n    l2.append(input())\nc=0\nfor i in range(n):\n    if(l1[i]  in l2):\n        l2.remove(l1[i])\n    else:\n        c+=1\n\nprint(c)","output":"linear"},{"instruction":"from sys import stdin\n\nn, m = map(int, stdin.readline().split())\nbe, en, ans = 1, n, n + 1\nwhile be <= en:\n    md = (be + en) >> 1\n    if md - sum(int(x) for x in str(md)) >= m:\n        en = md - 1\n        ans = md\n    else:\n        be = md + 1\n\nprint(n - ans + 1)","output":"logn"},{"instruction":"from sys import stdin\ninput=lambda : stdin.readline().strip()\nlin=lambda :list(map(int,input().split()))\niin=lambda :int(input())\nmain=lambda :map(int,input().split())\nfrom math import ceil,sqrt,factorial,log\nfrom collections import deque\nfrom bisect import bisect_left\ndef gcd(a,b):\n\ta,b=max(a,b),min(a,b)\n\twhile a%b!=0:\n\t\ta,b=b,a%b\n\treturn b\ndef solve():\n\ta,b,c=main()\n\tx,y,z=lin(),lin(),lin()\n\tx.sort(reverse=True)\n\ty.sort(reverse=True)\n\tz.sort(reverse=True)\n\tans=0\n\tdp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)]\n\tfor i in range(a+1):\n\t\tfor j in range(b+1):\n\t\t\tfor k in range(c+1):\n\t\t\t\tif i<a and j<b:\n\t\t\t\t\tdp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j])\n\t\t\t\tif i<a and k<c:\n\t\t\t\t\tdp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k])\n\t\t\t\tif k<c and j<b:\n\t\t\t\t\tdp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j])\n\t\t\t\tans=max(ans,dp[i][j][k])\n\tprint(ans)\nqwe=1\n\nfor _ in range(qwe):\n\tsolve()","output":"cubic"},{"instruction":"l, r = map(int, input().split(' '))\nn1 = bin(l)[2:]\nn2 = bin(r)[2:]\nif l==r:\n    print(0)\nelif len(n1) < len(n2):\n    print(int(len(n2)*'1', 2))\nelse:\n    index = 0\n    for i in range(len(n1)):\n        if n1[i] != n2[i]:\n            index = i\n            break\n    print(int((len(n1)-index)*'1', 2))","output":"logn"},{"instruction":"def main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    array = []\n    array.append(a)\n\n    for i in range(n - 1):\n        aux = []\n        for j in range(1, len(array[-1])):\n            xor = array[-1][j-1] ^ array[-1][j]\n            aux.append(xor)\n        array.append(aux)\n\n    for j in range(1, len(array)):\n        for k in range(len(array[j])):\n            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])\n            array[j][k] = maximo\n\n    q = int(input())\n    aux2 = []\n    for i in range(q):\n        l, r = map(int, input().split(' '))\n        aux2.append((l,r))\n\n    for i in aux2:\n        l, r = i[0], i[1]\n        print(str(array[r - l][l - 1]))\n\nmain()","output":"quadratic"},{"instruction":"n,m = map(int,input().split())\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nr = []\n\nfor i in a:\n    if i in b:\n        r.append(i)\nprint(' '.join(map(str, r)))\n","output":"quadratic"},{"instruction":"n = int(input())\nleft = []\nright = []\nfor i in range(n):\n\tdata = input().split()\n\tleft.append(int(data[0]))\n\tright.append(int(data[1]))\n\nleft.sort()\nright.sort()\ni = 0\nj = 0\ncount = 1\nans = [0] * (n + 1)\nleft += [max(right) + 1]\nright += [max(right) + 2]\nwhile (i < n) and (j < n):\n\twhile left[i + 1] <= right[j]:\n\t\tans[count] += (left[i + 1] - left[i])\n\t\tcount += 1\n\t\ti += 1\n\tans[count] += (right[j] - left[i] + 1)\n\ti += 1\n\tcount -= 1\n\n\twhile ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):\n\t\tans[count] += (right[j + 1] - right[j])\n\t\tcount -= 1\n\t\tj += 1\n\tans[count] += (left[i] - right[j] - 1)\n\tj += 1\n\tcount += 1\n\nfor i in range(1, n + 1):\n\tprint(ans[i], end = \" \")\nprint()","output":"nlogn"},{"instruction":"n, c = map(int, input().split())\ncnt = [0] * 500005\nans = 0\nfor v in map(int, input().split()):\n    if v == c:\n        cnt[c] = cnt[c] + 1\n    else:\n        if cnt[v] < cnt[c]:\n            cnt[v] = cnt[c]\n        cnt[v] += 1\n    ans = max(ans, cnt[v] - cnt[c])\nprint(ans + cnt[c])","output":"linear"},{"instruction":"n = int(input())\nar = [int(i) for i in input().split()]\nans = 0\nfor i in range(2*n):\n    for j in range(i+1,2*n):\n        if ar[i]==ar[j]:\n            while j!=i+1:\n                ar[j],ar[j-1]=ar[j-1],ar[j]\n                j-=1\n                ans+=1\nprint(ans)","output":"quadratic"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nfor x in r:\n    print(*x, sep='')\njohnny=0","output":"quadratic"},{"instruction":"def summing(number):\n    summa = 0\n    while number > 0:\n        summa += number % 10\n        number = number \/\/ 10\n    return summa\n\ndef result(n, s):\n    z = min(s, n)\n    while z <= n and z - summing(z) < s:\n        z += 1\n    return n - z + 1\n\na, b = [int(i) for i in input().split()]\nprint(result(a, b))","output":"logn"},{"instruction":"n = int(input())\ncoins = list(map(int, input().split()))\ncoins.sort(reverse=True)\ntarget = (sum(coins)+2)\/\/2\n\ncount = 1\ntotal = coins[count-1]\nwhile total < target:\n    count += 1\n    total += coins[count-1]\n\nprint(count)","output":"nlogn"},{"instruction":"import math\ns1 = input().strip()\ns2 = input().strip()\nps1 = 0\nms1 = 0\nps2 = 0\nms2 = 0\nqs2 = 0\nfor i in s1:\n    if i=='+':\n        ps1+=1\n    if i=='-':\n        ms1+=1\nfor i in s2:\n    if i=='+':\n        ps2+=1\n    if i=='-':\n        ms2+=1\n    if i == '?':\n        qs2+=1\nif ps2<=ps1 and ms2<=ms1:\n    print(math.factorial(qs2)\/math.factorial(ps1-ps2)\/math.factorial(ms1-ms2)*(0.5**qs2))\nelse:\n    print(0.00000000)","output":"np"},{"instruction":"def size_of_group(i):\n    return long(9 * 10**(i - 1)) * i\n\ndef find_group_data(k, i = 1):\n    diff = long(k - (size_of_group(i)))\n    if diff <= 0:\n        return k, i\n    return find_group_data(diff, i + 1)\n\ndef get_sequence_number(num):\n\n    k, g = find_group_data(num)\n    return str(long(10**(g - 1)) + (k - 1) \/ g)[(k - 1) % g]\n\nif __name__ == \"__main__\":\n    print(get_sequence_number(long(input())))","output":"logn"},{"instruction":"def Fast_power(x , y):\n    res = 1\n    while y > 0 :\n        if (y % 2 != 0):\n            res = res * x\n\n        y = y \/\/ 2\n        x = x * x\n\n    return res\n\nn = int(input())\nm = int(input())\n\nif n <= 40 :\n    print(m % Fast_power(2 , n))\nelse:\n    print(m)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nANS=[]\n\nfor i in range(1,n\/\/2+1):\n    for j in range(1,m+1):\n        sys.stdout.write((str(i)+\" \"+str(j)+\"\\n\"))\n        sys.stdout.write((str(n-i+1)+\" \"+str(m-j+1)+\"\\n\"))\n\nif n%2==1:\n    for j in range(1,m\/\/2+1):\n        sys.stdout.write((str(n\/\/2+1)+\" \"+str(j)+\"\\n\"))\n        sys.stdout.write((str(n\/\/2+1)+\" \"+str(m-j+1)+\"\\n\"))\n\n    if m%2==1:\n        sys.stdout.write((str(n\/\/2+1)+\" \"+str(m\/\/2+1)+\"\\n\"))","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    from math import sqrt\n    for _ in range(int(input())):\n        n = int(input())\n        if (round(sqrt(n)) ** 2 == n and n % 2 == 0) or round(sqrt(n * 2)) ** 2 == 2 * n:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\n\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) \/\/ b\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass masks:\n    def all_masks_sos(self,arr,lim=22):\n        lim = 22\n        maxbits = lim\n        self.masks=masks = 1 << lim\n        self.dp = [-1] * masks\n        for i in arr:\n            self.dp[i] = i\n        for i in range(masks):\n            for j in range(maxbits):\n                if self.dp[i] == -1 and i & (1 << j):\n                    self.dp[i] = self.dp[i - (1 << j)]\n\nt=1\nm=masks()\nfor i in range(1):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    m.all_masks_sos(l,22)\n    ans = [m.dp[i ^ (m.masks - 1)] for i in l]\n    print(*ans)","output":"np"},{"instruction":"from sys import exit\n\ndef bad():\n    print(\"NO\")\n    exit()\n\nnode = 1\ndef make_branch(u, d, deg, g, n, k):\n    global node\n    while deg[u] < k and d > 0 and node < n:\n        node += 1\n        deg[u] += 1\n        deg[node] = 1\n        g[u].append(node)\n        make_branch(node, d - 1, deg, g, n, k)\n\ndef main():\n    global node\n    n, d, k = map(int, input().split())\n    if d >= n or (k == 1 and n > 2):\n        bad()\n\n    g = [[] for _ in range(n + 5)]\n    deg = [0 for _ in range(n + 5)]\n\n    for i in range(1, d + 1):\n        g[i].append(i + 1)\n        deg[i] += 1\n        deg[i + 1] += 1\n\n    node = d + 1\n\n    LD = 1\n    RD = d - 1\n    for u in range(2, d + 1):\n        make_branch(u, min(LD, RD), deg, g, n, k)\n        LD += 1\n        RD -= 1\n\n    used = [False for _ in range(n + 5)]\n    q = [[1, 1]]\n    used[1] = True\n    while len(q) > 0:\n        u, p = q.pop()\n        for v in g[u]:\n            if v != p:\n                used[v] = True\n                q.append([v, u])\n\n    for i in range(1, n + 1):\n        if used[i] == False:\n            bad()\n\n    print(\"YES\")\n    for u in range(1, n + 1):\n        for v in g[u]:\n            print(u, v)\n\nmain()","output":"quadratic"},{"instruction":"def main():\n    R, G, B = map( int, input().split())\n    Rs = list( map( int, input().split()))\n    Gs = list( map( int, input().split()))\n    Bs = list( map( int, input().split()))\n\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n\n    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]\n    ans = 0\n    for i in range(R+1):\n        for j in range(G+1):\n            for k in range(B+1):\n                t = 0\n                if i > 0 and j > 0:\n                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:\n                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]\n                if j > 0 and k > 0:\n                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:\n                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]\n                if k > 0 and i > 0:\n                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:\n                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]\n                dp[i][j][k] = t\n                if ans < t:\n                    ans = t\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"def solve(matrix, col, N, M):\n    if col == M:\n\n        ans = 0\n        for row in matrix:\n            if len(row) == 1:\n                ans += row[0]\n            else:\n                ans += max(*row)\n\n        return ans\n\n    if N == 1:\n        return solve(matrix, col + 1, N, M)\n\n    ans = solve(matrix, col + 1, N, M)\n    for _ in range(N-1):\n        tmp = matrix[0][col]\n        for n in range(1, N):\n            matrix[n-1][col] = matrix[n][col]\n        matrix[N-1][col] = tmp\n\n        local_ans = solve(matrix, col + 1, N, M)\n        if local_ans > ans:\n            ans = local_ans\n\n    return ans\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N, M = list(map(lambda x: int(x), input().split()))\n\n        matrix = []\n        for n in range(N):\n            matrix.append(\n                list(map(lambda x: int(x), input().split()))\n            )\n\n        elements = []\n        for n in range(N):\n            for m in range(M):\n                elements.append((matrix[n][m], m))\n\n        elements.sort(reverse=True)\n\n        candidates = []\n        for t in elements:\n            if t[1] not in candidates:\n                candidates.append(t[1])\n                if len(candidates) == N:\n                    break\n\n        simplified = []\n        for n in range(N):\n            row = []\n            for m in candidates:\n                row.append(matrix[n][m])\n            simplified.append(row)\n\n        ans = solve(simplified, 0, N, min(N, M))\n        print(ans)\n\nmain()","output":"np"},{"instruction":"n = int(input())\nl = sorted(map(int, input().split()))\nseen = [False] * n\nres = 0\nfor i in range(n):\n    if seen[i]: continue\n    res += 1\n    for j in range(i, n):\n        seen[j] |= l[j] % l[i] == 0\nprint(res)","output":"quadratic"},{"instruction":"l, r = [int(x) for x in input().split()]\n\nq = l ^ r\na = 1\nwhile q:\n    q \/\/=2\n    a <<= 1\nprint(a-1)","output":"logn"},{"instruction":"n, k = map(int, input().split())\nr_n = n * 2\ng_n = n * 5\nb_n = n * 8\nt = 0\nt += r_n \/\/ k\nif r_n % k != 0:\n    t += 1\nt += g_n \/\/ k\nif g_n % k != 0:\n    t += 1\n\nt += b_n \/\/ k\nif b_n % k != 0:\n    t += 1\nprint(t)","output":"constant"},{"instruction":"def  getc():\n    f = [[0]*500 for i in range(500)]\n    for i in range(500):\n        f[i][0] = 1\n    f[1][0] = 1\n    f[1][1] = 1\n    for i in range(2,411):\n        for j in range(1, i+1):\n            f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod\n    return f\nn, mod = map(int, input().split())\nf = [[0]*500 for i in range(500)]\nc = getc()\nmi_2 = [0]*500\nmi_2[0] = 1\nfor i in range(1, 500):\n    mi_2[i] = mi_2[i-1]*2%mod\nfor i in range(1, n+1):\n    for j in range(0, i\/\/2+1):\n        if j == 0:\n            f[i][j] = mi_2[i-1]\n        else:\n            for k in range(2, i):\n                f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod\nans = 0\nfor i in range(0,n+1):\n    ans = (ans + f[n][i])%mod\nprint(ans)","output":"cubic"},{"instruction":"def fun(grid,counter,n,m):\n    for i in range(n):\n        possible=True\n        for j in range(m):\n            if grid[i][j]=='1' and counter[j]==1:\n                possible=False\n                break\n        if possible:\n            return True\n    return False\n\nn,m=[int(_) for _ in input().split(\" \")]\ngrid,counter=[],[0]*m\nfor _ in range(n):\n    s=input()\n    for i in range(m):\n        if s[i]=='1':\n            counter[i]+=1\n    grid.append(s)\nif fun(grid,counter,n,m):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"s=input()\nwhile(len(s)>0):\n    if s!=s[::-1]:\n        break\n    else:\n        s=s[1:]\nprint(len(s))","output":"linear"},{"instruction":"x, k = map(int, input().split())\n\nif x==0:\n    print(0)\n    exit()\n\nMOD = 10**9+7\nans = (pow(2, k+1, MOD)*x%MOD-(pow(2, k, MOD)-1))%MOD\n\nprint(ans)","output":"logn"},{"instruction":"def lr(a):\n    l = [0] * len(a)\n    r = [0] * len(a)\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            if a[j] > a[i]:\n                r[i] += 1\n            if a[i] > a[j]:\n                l[j] += 1\n    return l, r\n\nn = int(input())\nl = [int(i) for i in input().split()]\nr = [int(i) for i in input().split()]\na = [0] * n\nfor i in range(n):\n    for j in range(n):\n        if l[j] + r[j] == i:\n            a[j] = n-i\nl1, r1 = lr(a)\nif l1 != l or r1 != r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(' '.join([str(i) for i in a]))","output":"quadratic"},{"instruction":"n = int(input())\n\narr = list(map(int, input().split()))\n\nmemo = [-1 for i in range(n+1)]\ndef can_win(idx):\n\tif memo[idx] != -1: return memo[idx]\n\tres = False\n\n\tdelta = arr[idx]\n\n\tnidx = idx + delta\n\twhile nidx < n:\n\t\tif arr[nidx] > arr[idx] and not can_win(nidx):\n\t\t\tres = True\n\t\t\tbreak\n\t\tnidx += delta\n\n\tnidx = idx - delta\n\twhile not res and nidx >= 0:\n\t\tif arr[nidx] > arr[idx] and not can_win(nidx):\n\t\t\tres = True\n\t\t\tbreak\n\t\tnidx -= delta\n\n\tmemo[idx] = res\n\treturn res\n\nans = ['A' if can_win(i) else 'B' for i in range(n)]\nprint(''.join(ans))","output":"quadratic"},{"instruction":"k = 1000001\na = [True] * k\na[0] = a[1] = False\n\nfor i in range(k):\n    if a[i]:\n        j = 2 * i\n        while j < k:\n            a[j] = False\n            j += i\n\nn = int(input())\nfor i in range(4, n):\n    if not a[i] and not a[n-i]:\n        print(i, n-i)\n        exit()","output":"constant"},{"instruction":"q = int(input())\nfor i in range(q):\n    n, m, k = map(int, input().split())\n    m, n = abs(m), abs(n)\n    mx = max(m, n)\n    remaining = k - mx\n    if remaining < 0:\n        print(-1)\n    elif m == n == 0:\n        if k == 1:\n            print(-1)\n        elif k % 2:\n            print(k - 1)\n        else:\n            print(k)\n    elif abs(m - n) % 2 == 0:\n        if remaining % 2 == 0:\n            print(k)\n        else:\n            print(k - 2)\n    else:\n        if not remaining:\n            print(k - 1)\n        elif remaining % 2 == 0:\n            print(k - 1)\n        else:\n            print(k - 1)","output":"constant"},{"instruction":"from sys import stdin\nimport time\n\nr,g,b = map(int,stdin.readline().split())\n\nred = list(map(int,stdin.readline().split()))\ngreen = list(map(int,stdin.readline().split()))\nblue = list(map(int,stdin.readline().split()))\nred.sort()\ngreen.sort()\nblue.sort()\n\ndp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]\n\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i>0 and j>0:\n                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])\n            if i>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])\n            if j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])\n\nprint(dp[-1][-1][-1])","output":"cubic"},{"instruction":"import math\nn = int(input())\nm = 0\nfor i in range(min(100,n)):\n\tfor ii in range(min(100,n)):\n\t\tfor iii in range(min(100,n)):\n\t\t\ti1 = n-i\n\t\t\tii1 = n-ii\n\t\t\tiii1 = n-iii\n\t\t\tr1 = (i1*ii1)\/\/math.gcd(i1,ii1)\n\t\t\tr2 = (r1*iii1)\/\/math.gcd(iii1,r1)\n\t\t\tm = max(m,r2)\nprint(m)","output":"constant"},{"instruction":"m = 1000000007\nx, k = map(int, input().split())\nup = (x * pow(2, k + 1, m)) % m\ndown = pow(2, k, m) - 1\nif (x == 0):\n    print(0)\nelse:\n    print((up - down) % m)","output":"logn"},{"instruction":"import math\nfrom math import factorial\n\ndef combination(n,r):\n    return float(factorial(n)) \/ float(factorial(r)) \/ float(factorial(n-r))\n\na = input()\nap = a.count('+')\nam = a.count('-')\nb = input()\nbp = b.count('+')\nbm = b.count('-')\nn = b.count('?')\nx = float(ap - bp)\ny = float(am - bm)\nif (x < 0 or y < 0 or x+y != n):\n    print(0.0)\nelse:\n    print(combination(n,x)\/(1<<n))","output":"np"},{"instruction":"n,m=[int(i) for i in input().split(\" \")]\narrmv=[]\nfor i in range(n):\n    arrmv.append([int(i) for i in input().split(\" \")])\nx=0\ny=int(1e9+1)\nsucls=[0,0]\n\ntols=[]\nmstr=\"\"\n\npowls=[int(pow(2,i)) for i in range(10)]\ntwodarray=[0  for i in range(257)]\nwhile x+1<y:\n    mid = x+(y-x)\/\/2\n\n    for idx,ele in enumerate(twodarray):twodarray[idx]=0\n    tols.clear()\n    for topidx, eletop in enumerate(arrmv):\n        tmp=0\n        for idx,ele in enumerate(eletop):\n            if ele>=mid:tmp+=powls[idx]\n\n        if not twodarray[tmp]:\n\n            twodarray[tmp]=1\n            tols.append((tmp,topidx))\n    sz=len(tols)\n    suc=0\n    no=int(pow(2,m))\n    for i in range(sz):\n        for j in range(i,sz):\n            if tols[i][0] | tols[j][0] == no-1:\n                sucls[0],sucls[1]=tols[i][1],tols[j][1]\n\n                suc=1;\n                break;\n        if suc:break\n    if suc:x=mid\n    else:y=mid\n\nprint(sucls[0]+1,sucls[1]+1)","output":"np"},{"instruction":"n = int(input())\nx, y = list(map(int,input().split()))\nif x-1+y-1 <= n-x+n-y:\n    print('White')\nelse:\n    print('Black')","output":"constant"},{"instruction":"input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n\n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)","output":"linear"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) \/\/ 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1","output":"logn"},{"instruction":"from copy import deepcopy\nx,k=map(int,input().split(' '))\nif(x==0):\n\tprint(0)\nelse:\n\tprint((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)","output":"logn"},{"instruction":"n=int(input())\ndict1={}\nfor i in range(n-1):\n    x,y=map(int,input().split())\n    try:\n        dict1[y].append(x)\n    except:\n        KeyError\n        dict1[y]=[x]\n    try:\n        dict1[x].append(y)\n    except:\n        KeyError\n        dict1[x]=[y]\narr=list(map(int,input().split()))\nif(arr[0]!=1):\n    print(\"No\")\nelse:\n    j=0\n    i=1\n    flag=0\n    while(i<n and j<n):\n        if(arr[j] in dict1[arr[i]]):\n            i+=1\n        else:\n            j+=1\n    if(i!=n and j==n):\n        print('No')\n    else:\n        print('Yes')","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n\nimport random\n\ndef main():\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n \/ i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n \/\/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n \/\/ i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n \/ i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n \/\/ i)\n    return (n)\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n \/\/= 2\n        c += 1\n    return c\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n \/\/= 10\n    return s\ndef chk1(i):\n\n    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==\"0\"):\n        l1[i] = l2[i] = l2[i + 1] = \"X\"\n        return True\n    return False\ndef chk2(i):\n\n    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==\"0\"):\n        l1[i] = l1[i + 1] = l2[i] = \"X\"\n        return True\n    return False\ndef chk3(i):\n    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == \"0\"):\n        l1[i] = l1[i + 1] = l2[i+1] = \"X\"\n        return True\n    return False\ndef chk4(i):\n    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == \"0\"):\n        l1[i] = l1[i + 1] = l2[i] = \"X\"\n        return True\n    return False\n\ndef check1(i):\n    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [\"0\",\"0\",\"0\"]):\n        for j in range(i,i+3):\n            l1[j]=l2[j]=\"X\"\n        return True\n\ndef check2(i):\n    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):\n        return True\n    return False\n\nl1=list(input())\nl2=list(input())\n\nn=len(l1)\ni=0\nans=0\nwhile(i<n):\n    if(check1(i)):\n\n        ans+=2\n        i+=3\n    else:\n        if(check2(i)):\n            ans+=1\n            i+=2\n        else:\n            i+=1\nprint(ans)","output":"constant"},{"instruction":"x, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    mod = 1000000007\n    ans = x * pow(2, k + 1, mod) - pow(2, k, mod) + 1\n    print(ans % mod)","output":"logn"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom heapq import *\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM = 998244353\nEPS = 1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\nfor _ in range(1):\n\n    n,k = value()\n\n    rep = [1] + [0]*((n-k)\/\/2)\n    cur = 0\n\n    ans = []\n    j = 0\n    for i in range(n):\n        ans.append(rep[j])\n        j = (j + 1)%len(rep)\n\n    if(k == 1): ans = [1] + [0]*(n - 1)\n    print(*ans,sep = '')","output":"linear"},{"instruction":"def get(g):\n    s = [str(i) for i in g]\n    num = int(\"\".join(s))\n    return num\n\na = input()\nb = input()\nbb = int(b)\nmark = [0 for i in range(len(a))]\nc = a\nf = []\ng = []\n\nfor i in range(0 , len(a)):\n    g.append(a[i])\n\ng.sort()\ng.reverse()\nnum = get(g)\n\nindex = []\nif num <= bb:\n    print(num)\n    exit(0)\n\nfor i in range(0 , min(len(a) , len(b))):\n    mx = '-1'\n    idx = 0\n    for j in range(0 , len(a)):\n        if mark[j] == 0 and a[j] <= b[i]:\n            if a[j] > mx:\n                mx = a[j]\n                idx = j\n\n    if mx == '-1':\n        rem = []\n\n        while True and len(f) > 0:\n            ma = '-1'\n            id = 0\n            for j in range(0 , len(a)):\n                if mark[j] == 0 and a[j] < f[-1]:\n                    if a[j] > ma:\n                        ma = a[j]\n                        id = j\n\n            if ma == '-1':\n                mark[index.pop()] = 0\n                f.pop()\n                continue\n            else:\n                mark[index.pop()] = 0\n                f.pop()\n                f.append(ma)\n                mark[id] = 1\n                break\n\n        for j in range(0, len(a)):\n            if mark[j] == 0:\n                rem.append(a[j])\n\n        rem.sort()\n        rem.reverse()\n\n        for j in rem:\n            f.append(j)\n\n        print(get(f))\n        exit(0)\n\n    elif mx < b[i] and mx != '-1':\n        f.append(mx)\n        mark[idx] = 1\n        index.append(idx)\n        break\n    elif mx == b[i] and mx != '-1':\n        f.append(mx)\n        mark[idx] = 1\n        index.append(idx)\n\nrem = []\n\nfor i in range(0 , len(a)):\n    if mark[i] == 0:\n        rem.append(a[i])\n\nrem.sort()\nrem.reverse()\n\nfor i in rem:\n    f.append(i)\n\nprint(get(f))","output":"cubic"},{"instruction":"USE_STDIO = False\n\nif not USE_STDIO:\n    try: import mypc\n    except: pass\n\ndef main():\n    q,  = map(int, input().split(' '))\n    for _ in range(q):\n        n, m, k = map(int, input().split(' '))\n        if n > k or m > k:\n            print(-1)\n        elif (n - m) % 2:\n            print(k - 1)\n        elif (n - k) % 2:\n            print(k - 2)\n        else:\n            print(k)\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\nif l[0]!=0 or r[n-1]!=0:\n    print(\"NO\")\n    exit(0)\ns=[(l[i]+r[i]) for i in range(n)]\nm=max(s)+1\nk=[]\nfor i in s:\n    k.append(m-i)\nl1=[]\nr1=[]\n\nfor i in range(n):\n    c=0\n    d=0\n    for j in range(0,i):\n        if k[j]>k[i]:\n            c+=1\n    l1.append(c)\n    for j in range(i+1,n):\n        if k[j]>k[i]:\n            d+=1\n    r1.append(d)\nif l1!=l or r1!=r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*k)","output":"quadratic"},{"instruction":"n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\ncount=0\nfor i in range(2**n):\n    maxc=-1\n    minc=-1\n    c=0\n    for j in range(n):\n        if i>>j&1==1:\n            c+=a[j]\n            maxc=max(maxc,a[j])\n            if minc==-1:\n                minc=a[j]\n            else:\n                minc=min(a[j],minc)\n    if c>=l and c<=r and maxc - minc >=x:\n        count+=1\nprint(count)","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq\nimport math, string\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 998244353\n\ndef solve():\n    N = getInt()\n    A = getInts()\n    dp = [[-1 for j in range(N)] for i in range(N)]\n    for i in range(N):\n        dp[i][i] = A[i]\n    for X in range(2,N+1):\n        for i in range(N-X+1):\n            j = i+X-1\n            for k in range(i,j):\n                if dp[i][k] == dp[k+1][j] and dp[i][k] != -1:\n                    dp[i][j] = dp[i][k] + 1\n                    break\n\n    ans = [10**9+1]*(N+1)\n    ans[0] = 0\n    for i in range(1,N+1):\n        for k in range(1,i+1):\n            if dp[k-1][i-1] != -1:\n                ans[i] = min(ans[i],ans[k-1]+1)\n\n    return ans[N]\n\nprint(solve())","output":"cubic"},{"instruction":"import copy\nn = int(input())\nflg=0\nmat1 = []\nmat2 = []\n\nmats = []\nfor i in range(0, n): mat1.append(tuple(input().strip()))\nfor i in range(0, n): mat2.append(tuple(input().strip()))\nmats.append(mat2)\nmatu = copy.copy(mat2)\nmatv = copy.copy(mat2)\nmatv = list(zip(*matv))\nmats.append(matv)\n\nmattem = copy.copy(matu)\nfor i in range(0, 3):\n\tmattem = list(zip(*list(reversed(mattem))))\n\tmats.append(mattem)\nmattem = copy.copy(matv)\nfor i in range(0, 3):\n\tmattem = list(zip(*list(reversed(mattem))))\n\tmats.append(mattem)\n\nflg = 0\nfor cmat in mats:\n\tflg2 = 1\n\tfor ri in range(0, n):\n\t\tif cmat[ri]!=mat1[ri]:\n\t\t\tflg2=0\n\t\t\tbreak\n\tif flg2==1:\n\t\tflg=1\n\t\tbreak\nif flg==1: print(\"Yes\")\nelse: print(\"No\")","output":"quadratic"},{"instruction":"n = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if  abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n\nprint(ans)","output":"nlogn"},{"instruction":"def sm(n):\n    return int(int(n*(n+1))\/int(2));\ndef summ(en, st):\n    if(st <= 1):\n        return sm(en);\n    return sm(en) - sm(st-1);\n\ndef bs(n, k):\n    st = 1;\n    en = k;\n    while (st < en):\n        md = int(int((st+en)) \/int(2));\n        s = summ(k,md);\n        if(s == n):\n            return k - md + 1;\n        elif (s>n):\n            st = md + 1;\n        else :\n            en = md;\n    return k - st + 2;\nn, k = input().split();\nn = int(n);\nk = int(k);\n\nif(n == 1):\n    print(0);\nelif (n <= k):\n    print(1);\nelse:\n    n -= 1;\n    k -= 1;\n    if(sm(k) < n ):\n        print(-1);\n    else:\n        print(int(bs(n,k)));","output":"logn"},{"instruction":"def digisum(n):\n    count = 0\n    while(n>0):\n        count+=n%10\n        n = n\/\/10\n    return count\n\nn,s = list(map(int,input().split()))\nl,r = 1,n\nflag = 0\nwhile l<r:\n    m = l+(r-l)\/\/2\n    digi_sum = digisum(m)\n    num = m\n    if num-digi_sum>=s:\n        flag = 1\n        cur = m\n        r = m\n    else:\n        l = m+1\n    if r-l==1:\n        digi_sum = digisum(l)\n        num = l\n        if num-digi_sum>=s:\n            flag = 1\n            cur = l\n            break\n        digi_sum = digisum(r)\n        num = r\n        if num-digi_sum>=s:\n            flag = 1\n            cur = r\n            break\nif flag==0:\n    digi_sum = digisum(l)\n    num = l\n    if num-digi_sum>=s:\n        flag = 1\n        cur = l\nif flag==0:\n    print(0)\nelse:\n    print(n-cur+1)","output":"logn"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 1000000007;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if n < 0 or r < 0 or r > n: return 0;\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    C();\n\ndef D():\n    [n,m,k] = ti();\n    w = [[] for i in range(n)];\n    for i in range(n):\n        w[i] = ts();\n\n    mn = [[0 for j in range(k+1)] for i in range(n+1)];\n    for i in range(1,n+1):\n        for j in range(k+1):\n            c = 0;\n            st,en = -1,-1;\n            for x in range(m):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;\n            st,en = -1,-1;\n            c = 0;\n            for x in range(m-1,-1,-1):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            if st != -1 and en != -1 >= 0:\n                mn[i][j] = min(mn[i][j], st-en+1);\n\n    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];\n    for i in range(k+1):\n        dp[0][i] = 0;\n    for i in range(1,n+1):\n        for j in range(k+1):\n            for x in range(k+1):\n                if j-x >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);\n\n    print(dp[n][k]);\n\ndef C():\n    n = pi();\n    s = [];\n    mxI = 0;\n    for i in range(n):\n        c = input();\n        s.append(c[:len(c)-1]);\n        if s[len(s)-1] == 'f': mxI += 1;\n    dp = [[0 for j in range(mxI+1)] for i in range(n)];\n    dp[0][0] = 1;\n    preSum = [1 for i in range(mxI+1)];\n    pre = 1;\n    for i in range(1,n):\n        sm = 0;\n        pre = 0;\n        for j in range(mxI+1):\n            if s[i-1] == 'f':\n                dp[i][j] = dp[i-1][j-1]%mod;\n            else:\n                dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod;\n            pre = preSum[j];\n            preSum[j] = ((preSum[j-1] if j != 0 else 0)%mod+dp[i][j]%mod)%mod;\n\n    print(preSum[mxI]%mod);\n\nmain();","output":"quadratic"},{"instruction":"q = int(input())\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > y: x, y = y, x\n    m = y\n    d = y\n    if (y - x) % 2 == 1:\n        d -= 1\n    if k < m:\n        print(-1)\n        continue\n    r = k - m\n    if r % 2 != 0:\n        r -= 1\n        if d != m:\n            d += 1\n        else:\n            d -= 1\n    d += r\n    print(d)","output":"constant"},{"instruction":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        res = 0\n        store = set(nums)\n\n        for num in nums:\n            streak, curr = 0, num\n            while curr in store:\n                streak += 1\n                curr += 1\n            res = max(res, streak)\n        return res","output":"quadratic"},{"instruction":"def power(x, y, p) :\n    res = 1\n\n    x = x % p\n\n    while (y > 0) :\n\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\n\nd,n=map(int,input().split())\nans =power(2,n+1,1000000007);\nans1=power(2,n,1000000007);\nif(d==0):\n    print(0)\nelse:\n    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)","output":"logn"},{"instruction":"import math\nn=int(input())\nif n==1:\n\tprint(1)\n\texit()\na=[]\nfor i in range(1,n+1,2):\n\ta.append(1)\nb=[]\nfor i in range(2,n+1,2):\n\tb.append(i)\np=len(b)\nk=2\n\nwhile p>0:\n\tc=[]\n\n\tfor i in range(p):\n\t\tif b[i]%k==0 and b[i]%(k*2)!=0:\n\n\t\t\ta.append(k)\n\t\t\tp-=1\n\n\t\telse:\n\t\t\tc.append(b[i])\n\tb=c[:]\n\tk=k*2\n\np=a[-1]\/\/2\na.pop()\nq=p\nfor i in range(p,n+1):\n\tif i%p==0 and i>q:\n\t\tq=i\na.append(q)\n\nfor i in a:\n\tprint(i,end=\" \")","output":"nlogn"},{"instruction":"class Solution:\n    def binary_search(self, l: int, r: int, nums: List[int], target: int) -> int:\n        if l > r:\n            return -1\n        m = l + (r - l) \/\/ 2\n\n        if nums[m] == target:\n            return m\n        if nums[m] < target:\n            return self.binary_search(m + 1, r, nums, target)\n        return self.binary_search(l, m - 1, nums, target)\n\n    def search(self, nums: List[int], target: int) -> int:\n        return self.binary_search(0, len(nums) - 1, nums, target)","output":"logn"},{"instruction":"for _ in range(int(input())):\n    n,m = sorted(map(int,input().split()))\n    count = 0\n    while n> 0:\n        count+= m\/\/n\n        m = m%n\n        n,m = sorted([n,m])\n    print(count)","output":"constant"},{"instruction":"from operator import xor\n\nr = list(map(int, input().split()))\n\nms = xor(r[0], r[1])\n\nmax = 0\nsum = 1\n\nwhile ms > 0:\n    ms >>= 1\n    max += sum\n    sum <<= 1\n\nprint(max)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nb = []\nc = []\ne = []\nfor i in range(n):\n\tif a[i] == 1:\n\t\tb += [i]\nfor i in range(n):\n\tif a[i] != 1:\n\t\tc += [[a[i], i]]\nif not c:\n\tprint(\"NO\")\n\texit(0)\nans = len(c)\nfor i in range(len(c) - 1):\n\te += [(c[i][1], c[i + 1][1])]\n\tc[i][0] -= 1\n\tc[i + 1][0] -= 1\nif b:\n\te += [(b[-1], c[-1][1])]\n\tc[-1][0] -= 1\n\tb.pop()\n\tans += 1\nif b:\n\te += [(b[-1], c[0][1])]\n\tc[0][0] -= 1\n\tb.pop()\n\tans += 1\ni = 0\nwhile b:\n\twhile i < len(c) and c[i][0] == 0:\n\t\ti += 1\n\tif i == len(c):\n\t\tprint(\"NO\")\n\t\texit(0)\n\te += [(b[-1], c[i][1])]\n\tc[i][0] -= 1\n\tb.pop()\n\nprint(\"YES\", ans - 1)\nprint(len(e))\nfor (x, y) in e:\n\tprint(x + 1, y + 1)","output":"linear"},{"instruction":"rd = lambda: map(int, input())\ndef f(n, t):\n    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))\n    if t < 3:\n        rd()\n    return a\nn = int(input())\nm = sorted([f(n, i) for i in range(4)])\nprint(2 * n * n + m[0] + m[1] - m[2] - m[3])","output":"quadratic"},{"instruction":"from copy import copy\n\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(14):\n    b = copy(a)\n    b[i] = 0\n\n    for j in range(1, 14 + 1):\n        b[(i + j) % 14] += (a[i] - 1) \/\/ 14 + ((a[i] - 1) % 14 + 1 > j - 1)\n\n    ans = max(ans, sum(el * (el % 2 == 0) for el in b))\n\nprint(ans)","output":"constant"},{"instruction":"n,m=map(int,input().split())\nlst=list(map(int,input().split()))\narr=lst.copy()\narr.sort(reverse=True)\nvis=[0]*n\nsumm=0\nfor i in range(m):\n    temp=arr[i]\n    summ+=temp\n    for j in range(n):\n        if vis[j]==0 and lst[j]==temp:\n            vis[j]=1\n\n            break\n\nprint(summ)\ncnt=0\nans=[]\nfor i in range(n):\n    if vis[i]==1:\n        ans.append(cnt+1)\n        cnt=0\n    else:\n        cnt+=1\nans[-1]+=cnt\nprint(*ans)","output":"nlogn"},{"instruction":"from math import *\nk,n=map(int,input().split())\nprint(ceil(n\/k))","output":"constant"},{"instruction":"from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) \/\/ b\nlim=22\npo=[1<<j for j in range(lim+1)]\nmaxbits=lim\nmasks=po[lim]\ndp=[-1]*masks\nt=1\n\nfor i in range(1):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    for i in l:\n        dp[i]=i\n    for i in range(masks):\n        for j in range(maxbits):\n            if dp[i]==-1 and i&(1<<j):\n                dp[i]=dp[i-(1<<j)]\n    ans=[dp[i^(masks-1)] for i in l]\n    print(*ans)","output":"np"},{"instruction":"n = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx:\n    print(\"NO\")\nelif cx < ax < bx:\n    print(\"NO\")\nelif by < ay < cy:\n    print(\"NO\")\nelif cy < ay < by:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"constant"},{"instruction":"n=int(input())\nif(n<3):\n    print(n)\nelse:\n\n    if(n%2!=0):\n        print(n*(n-1)*(n-2))\n    elif(n%3==0):\n        print((n-1)*(n-2)*(n-3))\n    else:\n        print(n*(n-1)*(n-3))","output":"constant"},{"instruction":"class DFS:\n    def __init__(self):\n        self.G= []\n        self.leave_tree= []\n\n    def take_input(self):\n        k = int(input())\n        if(k>1):\n            graph =[int(node)-1 for (node) in input().split(' ')]\n            self.G = [[] for _ in range(len(graph)+1)]\n            for i in range(len(graph)):\n                self.G[graph[i]].append(i+1)\n            self.visited = [0]*k\n            self.leave_tree = [0]*k\n            for i in range(k-1,-1,-1):\n                if len(self.G[i])==0:\n                    self.leave_tree[i]=1\n                else:\n                    for j in self.G[i]:\n                        self.leave_tree[i]+=self.leave_tree[j]\n            self.leave_tree.sort()\n            print(*self.leave_tree)\n        else:\n            print(k)\n\nx = DFS()\nx.take_input()","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\nfrom collections import defaultdict as dd\nn=int(input())\nd=dd(int)\nfor i in range(n):\n    l,r=map(int,input().split())\n    d[l] +=1\n    d[r+1] -=1\narr=list(d.keys())\narr.sort()\nans=[0 for i in range(n+1)]\ncount =0\nl=len(arr)\narr.append(arr[-1])\nfor i in range(l):\n    count +=d[arr[i]]\n    ans[count] +=arr[i+1] -arr[i]\nprint(*ans[1:])","output":"nlogn"},{"instruction":"MOD = int(1e9)+7\n\ndef fast_power(x, y):\n    res = 1\n    x %= MOD\n    while y > 0:\n        if y % 2 == 1:\n            res = (res * x) % MOD\n        x = (x * x) % MOD\n        y = y >> 1\n    return res\n\nx, k = map(int, input().split())\nif(x == 0):\n    print(0)\nelse:\n    a = fast_power(2, k)\n    b = (2 * x - 1) % MOD\n    c = (a * b) % MOD + 1\n    print(c % MOD)","output":"logn"},{"instruction":"n,t=map(int,input().split())\nlist=[]\nfor i in range (n):\n    x,a=map(int,input().split())\n    list.append((x-a\/2,x+a\/2))\nlist.sort()\nans=2\nfor i in range(n-1):\n    dis=list[i+1][0]-list[i][1]\n    if dis>t:\n        ans+=2\n    elif dis==t:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"from collections import deque as de\nimport math\nfrom math import sqrt as sq\nfrom math import floor as fl\nfrom math import ceil as ce\nfrom sys import stdin, stdout\nimport re\nfrom collections import Counter as cnt\nfrom functools import  reduce\n\nfrom itertools import groupby as gb\n\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef binarytodecimal(n):\n    return int(n,2)\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n    return prime_factors\n\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef getProduct(n):\n\n    product = 1\n\n    while (n != 0):\n        product = product * (n % 10)\n        n = n \/\/ 10\n\n    return product\n\ndef lcm(x,y):\n   lcm = (x*y)\/\/math.gcd(x,y)\n   return lcm\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\ndef checkisap(list):\n    d=list[1]-list[0]\n    for i in range(2,len(list)):\n        temp=list[i]-list[i-1]\n        if temp !=d:\n            return False\n    return True\n\ndef primes_method5(n):\n    out ={}\n    sieve = [True] * (n+1)\n    for p in range(2, n+1):\n        if (sieve[p]):\n            out[p]=1\n            for i in range(p, n+1, p):\n                sieve[i] = False\n    return out\n\ndef getSum(n):\n\n    strr = str(n)\n    list_of_number = list(map(int, strr.strip()))\n    return sum(list_of_number)\n\ndef ceildiv(x,y):\n    return (x+y-1)\/\/y\n\ndef di():return map(int, input().split())\ndef ii():return int(input())\ndef li():return list(map(int, input().split()))\ndef si():return list(map(str, input()))\ndef indict():\n    dic = {}\n    for index, value in enumerate(input().split()):\n        dic[int(value)] = int(index)+1\n    return dic\ndef frqdict():\n\n    dic={}\n    for index, value in enumerate(input()):\n        if value not in dic:\n            dic[value] =1\n        else:\n            dic[value] +=1\n    return dic\n\nn=ii()\na=sorted(li())\nif a[n-1]==1:\n    a[n-1]=2\nelse:\n    a[n-1]=1\na.sort()\nprint(*a)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\ni = 0\nfor bill in a:\n    try:\n        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1\n        ans += 1\n    except StopIteration:\n        break\n\nprint(ans)","output":"linear"},{"instruction":"import math\nimport sys\n\nn=int(input())\ns=list(map(int,input().split()))\nce=list(map(int,input().split()))\n\nbest=10**9\nfor j in range(1,n-1):\n    a=ce[j];b=10**9;c=10**9\n    for i in range(j-1,-1,-1):\n        if s[i]<s[j]:\n            b=min(b,ce[i])\n    for k in range(j+1,n):\n        if s[k]>s[j]:\n            c=min(c,ce[k])\n    best=min(best,a+b+c)\n\nif best>=10**9:\n    print(-1)\nelse:\n    print(best)","output":"quadratic"},{"instruction":"n,s=list(map(int,input().split()))\nif n-sum([int(x) for x in str(n)])<s:\n    print(0)\nelse:\n    def check(n):\n\n        return (n-sum([int(x) for x in str(n)]))>=s\n    start=1\n    end=n\n    mid=(start+end)\/\/2\n    while mid !=end and mid!=start:\n\n        if check(mid):\n            end=mid\n            mid=(start+end)\/\/2\n        else:\n            start=mid\n            mid = (start + end) \/\/ 2\n\n    print(n-end+1)","output":"logn"},{"instruction":"import sys\nfrom array import array\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    fullbit = (1 << m) - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}\n        keys = tuple(dp.keys())\n\n        for i in range(len(keys)):\n            for j in range(i, len(keys)):\n                if keys[i] | keys[j] == fullbit:\n                    return dp[keys[i]], dp[keys[j]]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"def check(e,value,pre):\n    global maxi,count\n    e[str(value)]-=1\n    pre+=str(value)\n    arr=[]\n    for i in e:\n        for j in range(e[i]):\n            arr.append(i)\n    arr.sort(reverse=True)\n    st=''\n    for i in arr:\n        st+=str(i)\n    alpha=int(pre+st)\n    if alpha<=int(b):\n        maxi=max(maxi,int(pre+st))\n\na=input()\nb=input()\nmaxi=0\nd={}\nfor i in a:\n    if i not in d:\n        d[i]=1\n    else:\n        d[i]+=1\nmaxi=0\nnum=\"\"\ncount=0\nif len(a)<len(b):\n    check(d.copy(),max(d),'')\nelse:\n    for i in b:\n        if i in d and d[i]>0:\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            check(d.copy(),i,num)\n            num+=i\n            d[i]-=1\n\n        else:\n            j=0\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            break\nprint(maxi)","output":"cubic"},{"instruction":"n = int(input())\ns = input()\nt = input()\ndic, diff = {}, []\nres, res1, res2 = 0, -1, -1\nfor i in range(n) :\n    if s[i] != t[i] :\n        res += 1\n        diff.append(i)\n        dic[t[i]] = i\nswap1, swap2 = False, False\nfor i in diff :\n    if s[i] in dic:\n        swap1 = True\n        res1 = i+1\n        j = dic[s[i]]\n        res2 = j+1\n        if s[j] == t[i] :\n            swap2 = True\n            break\nprint(res - (2 if swap2 else 1 if swap1 else 0))\nprint(res1, res2)","output":"linear"},{"instruction":"n=int(input())\nif(n<3):\n\tprint(n)\n\texit(0)\nif n%2==1:\n\tprint(n*(n-1)*(n-2))\nelse:\n\tg=0;\n\tif n%3==0:\n\t\tg=n-2\n\telse:g=n;\n\tprint((n-1)*(n-3)*(g))","output":"constant"},{"instruction":"cards=list(input().split())\nlm=[0]*9\nlp=[0]*9\nls=[0]*9\nfor item in cards:\n    if item[1]=='m':\n        lm[int(item[0])-1]+=1\n    elif item[1]=='p':\n        lp[int(item[0])-1]+=1\n    else :\n        ls[int(item[0])-1]+=1\nif max(lm)==3 or max(lp)==3 or max(ls)==3:\n    print(0)\nelse :\n    flag=0\n    def seq_checker(li):\n        flag=0\n        for i in range(9):\n            if flag==0:\n                if lm[i]==1:\n                    flag=1\n            else :\n                if lm[i]==1:\n                    flag+=1\n                else :\n                    break\n        return flag\n    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:\n        print(0)\n    elif max(lm)==2 or max(lp)==2 or max(ls)==2:\n        print(1)\n    else :\n        m=0\n        for i in range(0,7):\n            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)\n        print(3-m)","output":"linear"},{"instruction":"from itertools import combinations\nn,l,r,x=map(int,input().split())\narr=list(map(int,input().split()))\nans=0\nfor i in range(2,n+1):\n\tbrr=list(combinations(arr,i))\n\tfor j in brr:\n\t\ts=sum(j)\n\t\tif l<=s<=r and max(j)-min(j)>=x:\n\t\t\tans+=1\nprint(ans)","output":"np"},{"instruction":"def add(a,b):\n\ta = a%(1000000000+7)\n\tb=b%(1000000000+7)\n\treturn (a+b)%(1000000000+7)\n\nn  =int(input())\ni=1\nstatements = []\ndp = [[0 for i in range(n)] for i in range(n)]\nprefix = [[0 for i in range(n)] for i in range(n)]\nwhile(i<=n):\n\ts = input()\n\tstatements.append(s)\n\ti+=1\n\ndp[0][0]=1\nprefix[0][0]=1\nj=1\nwhile(j<n):\n\tdp[0][j]=0\n\tprefix[0][j] = dp[0][j] + prefix[0][j-1]\n\tj+=1\n\ni=1\nwhile(i<n):\n\tif(statements[i-1]=='f'):\n\t\tj=1\n\t\twhile(j<n):\n\t\t\tdp[i][0]=0\n\t\t\tprefix[i][0]=0\n\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\n\t\t\tj+=1\n\telse:\n\t\tj=0\n\t\twhile(j<n):\n\t\t\tif(j==0):\n\t\t\t\tdp[i][j] = prefix[i-1][n-1]\n\t\t\telse:\n\t\t\t\tdp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\t\t\tj+=1\n\n\ti+=1\n\nans = 0\nj=0\nwhile(j<n):\n\tans=add(ans,dp[n-1][j])\n\tj+=1\n\nprint(ans%(1000000000+7))","output":"quadratic"},{"instruction":"from sys import stdin\nfrom collections import deque\nn=int(stdin.readline())\ng=dict()\nfor i in range(n-1):\n    a,b=map(int,stdin.readline().split())\n    g.setdefault(a, set()).add(b)\n    g.setdefault(b, set()).add(a)\na=[int(x) for x in stdin.readline().split()]\nans = True\nif n > 1 and a[0] == 1:\n    q=deque()\n    m=[0]*(n+1)\n    q.append(1)\n    m[1]=1\n    right=1\n    while len(q) > 0 and ans:\n        first = q.popleft()\n        cnt = 0\n        for v in g[first]:\n            if m[v] == 0:\n                cnt += 1\n        for i in range(right, right+cnt):\n            if m[a[i]] == 0 and a[i] in g[first]:\n                m[a[i]] = 1\n                q.append(a[i])\n            else:\n                ans = False\n                break\n        right += cnt\nelse:\n    ans = a[0] == 1\nif ans:\n    print(\"Yes\")\nelse:\n    print(\"No\")","output":"linear"},{"instruction":"def iscollinear(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n    ans = bool(cross)\n    return not ans\n\ndef checkfortwolines(a, b, points):\n    set1 = set(points)\n    for i in range(n):\n        if iscollinear(a, b, points[i]): set1.remove(points[i])\n\n    if len(set1) <= 2: return True\n    else:\n        pts1 = list(set1)\n        for i in range(len(pts1)):\n            if not iscollinear(pts1[0], pts1[1], pts1[i]): return False\n        return True\n\nn = int(input())\nif n <= 4: print(\"YES\")\nelse:\n    points = [0 for i in range(n)]\n    for i in range(n):\n        points[i] = tuple(map(int, input().split()))\n    a = points[0]\n    b = points[1]\n    c = points[2]\n    if checkfortwolines(a, b, points) or checkfortwolines(b, c, points) or checkfortwolines(c, a, points):\n        print(\"YES\")\n    else: print(\"NO\")","output":"nlogn"},{"instruction":"import sys\n\ndef get_new_edges(graph):\n    n = len(graph)\n    far_vertex = []\n    pi = [None]*n\n    visit = [False]*n\n    visit[0]\n    queue = [[0,0]]\n    i = 0\n    while True:\n        if i >= len(queue): break\n        current, d = queue[i]\n        i += 1\n        visit[current] = True\n        for v in graph[current]:\n            if not visit[v]:\n                u = [v, d+1]\n                pi[v] = current\n                queue.append(u)\n                if d+1 > 2:\n                    far_vertex.append(u)\n\n    far_vertex.sort(key=lambda x: -x[1])\n\n    pos = [None]*n\n    for i, e in enumerate(far_vertex):\n        pos[e[0]] = i\n\n    count = 0\n    for i in range(len(far_vertex)):\n        if not far_vertex[i]: continue\n        vertex, depth = far_vertex[i]\n        father = pi[vertex]\n        count += 1\n        if pos[father]:\n            far_vertex[pos[father]] = None\n        for u in graph[father]:\n            if pos[u]:\n                far_vertex[pos[u]] = None\n\n    return count\n\ndef read_int_line():\n    return map(int, sys.stdin.readline().split())\n\nvertex_count = int(input())\ngraph = [[] for _ in range(vertex_count)]\n\nfor i in range(vertex_count - 1):\n    v1, v2 = read_int_line()\n    v1 -= 1\n    v2 -= 1\n    graph[v1].append(v2)\n    graph[v2].append(v1)\n\nprint(get_new_edges(graph))","output":"linear"},{"instruction":"n = int(input())\nlis = list(map(int, input(). split()))\nsor = sorted(lis)\ncnt = 0\nfor i in range(n):\n    if lis[i] != sor[i]:\n        cnt += 1\nif cnt > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"import math\ndef lucky(x):\n    return (list(set(list(str(x)))) in [[\"4\"],[\"7\"],[\"4\",\"7\"],[\"7\",\"4\"]])\na = int(input())\ntrue = False\nfor i in range(1, math.ceil(math.sqrt(a))+1):\n    if a % i == 0:\n        if lucky(i) or lucky(a\/\/i):\n            true = True\n            break\nprint(\"YES\" if true else \"NO\")","output":"constant"},{"instruction":"n=int(input())\nl1=list(map(int,input().split()))\nif n%2==0:\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\nelse :\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\n    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1\nprint(' '.join(str(x) for x in l1))","output":"linear"},{"instruction":"class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for row in range(9):\n            seen = set()\n            for i in range(9):\n                if board[row][i] == \".\":\n                    continue\n                if board[row][i] in seen:\n                    return False\n                seen.add(board[row][i])\n\n        for col in range(9):\n            seen = set()\n            for i in range(9):\n                if board[i][col] == \".\":\n                    continue\n                if board[i][col] in seen:\n                    return False\n                seen.add(board[i][col])\n\n        for square in range(9):\n            seen = set()\n            for i in range(3):\n                for j in range(3):\n                    row = (square\/\/3) * 3 + i\n                    col = (square % 3) * 3 + j\n                    if board[row][col] == \".\":\n                        continue\n                    if board[row][col] in seen:\n                        return False\n                    seen.add(board[row][col])\n        return True","output":"quadratic"},{"instruction":"class vec():\n    def __init__(self, x, y=None):\n        if y is None:\n            x, y = x\n        self.x = x\n        self.y = y\n    def __mod__(self, other):\n        return self.x*other.y - self.y*other.x\n    def __sub__(self, other):\n        return vec(self.x - other.x, self.y - other.y)\n    def __repr__(self):\n        return 'vec({}, {})'.format(self.x, self.y)\n\ndef lines_cross(a, b, c, d):\n    ab, ac, ad = b - a, c - a, d - a\n    cd, ca, cb = d - c, a - c, b - c\n    return (ab % ac) * (ab % ad) <= 0 and (cd % ca) * (cd % cb) <= 0\n\ndef rot(a):\n    return vec(a.x-a.y, a.x+a.y)\n\nax, ay, bx, by, cx, cy, dx, dy = map(int, input().split())\nkx, ky, lx, ly, mx, my, nx, ny = map(int, input().split())\nc, b, d, a = map(vec, sorted([(ax, ay), (bx, by), (cx, cy), (dx, dy)]))\nm, n, l, k = map(vec, sorted([(kx, ky), (lx, ly), (mx, my), (nx, ny)]))\nres = False\ns1 = [a, b, c, d]\ns2 = [k, l, m, n]\nfor i in range(4):\n    for j in range(4):\n        if lines_cross(s1[i], s1[(i+1)%4], s2[j], s2[(j+1)%4]):\n            res = True\n            break\n    if res:\n        break\nif all([b.x <= p.x <= a.x and c.y <= p.y <= b.y for p in [k, l, m ,n]]):\n    res = True\nif all([rot(l).x <= rot(p).x <= rot(k).x and rot(m).y <= rot(p).y <= rot(l).y for p in [a, b, c ,d]]):\n    res = True\nprint('YES' if res else 'NO')","output":"constant"},{"instruction":"import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\nn = mint()\na = [0]*n\ndp = [0]*n\nfor i in range(n):\n\ta[i] = tuple(mints())\na.sort()\nfor i in range(n):\n\tx, p = a[i]\n\tl = -1\n\tr = n\n\tv = x-p\n\twhile r-l > 1:\n\t\tc = (l + r)\/\/2\n\t\tif a[c][0] >= v:\n\t\t\tr = c\n\t\telse:\n\t\t\tl = c\n\t\tif l == -1:\n\t\t\tdp[i] = i-l-1\n\t\telse:\n\t\t\tdp[i] = i-l-1+dp[l]\n\nz = 1e9\nfor i in range(n):\n\tz = min(z,dp[i]+n-i-1)\nprint(z)","output":"linear"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\nn = INT()\narr = LIST()\nk = []\ni = 0\nwhile 2 ** i <= 10**18 :\n    k.append(2 ** i)\n    i+=1\n\nd = {}\ns1 = set()\nfor i in arr:\n    s1.add(i)\n    if i not in d :\n        d[i] = 1\n    else:\n        d[i]+=1\n\ns2 = set()\nfor i in s1 :\n    flag = False\n    for j in k :\n        x = j - i\n        y = -1\n        try:\n            y = d[x]\n        except:\n            y = -1\n        if y != -1:\n            if x == i and d[i] == 1:\n                continue\n            flag = True\n            break\n    if flag==False:\n        s2.add(i)\n\nres = 0\nfor i in s2 :\n    res+=d[i]\nprint(res)","output":"nlogn"},{"instruction":"import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\nr, g, b = nm()\nR = nl()\nG = nl()\nB = nl()\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i==0 and j==0 and k==0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"n,m,k = map(int,input().split())\nwh=[]\n\nfor j in range(n):\n    l=list(map(int,input().split()))\n    wh.append(l)\n\nwv=[]\n\nfor j in range(n-1):\n    l=list(map(int,input().split()))\n    wv.append(l)\n\nif(k%2!=0):\n    ans = [[-1 for _ in range(m)]for j in range(n)]\n    for res in ans:\n        print(*res)\nelse:\n    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]\n    for x in range(1,k+1):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                dp[i][j][x]=1234567890\n                if(i!=n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])\n                if(i!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])\n                if(j!=m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])\n                if(j!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans = 1234567890\n            for x in range(1,k+1):\n                if(k%x==0 and (k\/\/x)%2==0 ):\n                    ans = min(ans,dp[i][j][x]*(k\/\/x))\n            print(ans,end=\" \")\n        print()","output":"cubic"},{"instruction":"n, m = map(int, input().split())\nc = []\nfor j in range(n):\n    d = []\n    s = input()\n    for i in s:\n        d.append(i)\n    c.append(d)\na = []\nb = []\ne=[]\ng=[]\n\nfor j in range(n):\n    k=[0]*(m)\n    e.append(k)\nfor j in range(n):\n    k=[0]*(m)\n    g.append(k)\n\ndpu = []\nfor j in range(n):\n    k=[0]*(m)\n    dpu.append(k)\ndpd = []\nfor j in range(n):\n    k=[0]*(m)\n    dpd.append(k)\ndpl = []\nfor j in range(n):\n    k=[0]*(m)\n    dpl.append(k)\ndpr = []\nfor j in range(n):\n    k=[0]*(m)\n    dpr.append(k)\nfor i in range(n):\n    for j in range(m):\n        if c[i][j] == \"*\":\n            if i>0:\n                dpu[i][j]+=dpu[i-1][j]+1\n            else:\n                dpu[i][j]=1\n            if j>0:\n                dpl[i][j]=dpl[i][j-1]+1\n            else:\n                dpl[i][j]=1\ni=n-1\nwhile(i>=0):\n    j=m-1\n    while(j>=0):\n        if c[i][j] == \"*\":\n            if i<(n-1):\n                dpd[i][j] += dpd[i + 1][j] + 1\n            else:\n                dpd[i][j] = 1\n            if j<(m-1):\n                dpr[i][j] = dpr[i][j + 1] + 1\n            else:\n                dpr[i][j] = 1\n        j+=-1\n    i+=-1\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if c[i][j] == \"*\":\n            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)\n            if k==0:\n                pass\n            elif k>0:\n                a.append([i+1,j+1,k])\n                e[i-k][j]+=1\n                if (i+k)<(n-1):\n                    e[i+k+1][j]+=-1\n                g[i][j-k] += 1\n                if (j + k) < (m - 1):\n                    g[i][j+k+1] += -1\nfor i in range(m):\n    for j in range(1,n):\n        if c[j-1][i]==\"*\":\n            e[j][i]+=e[j-1][i]\nfor i in range(n):\n    for j in range(1,m):\n        if c[i][j-1]==\"*\":\n            g[i][j]+=g[i][j-1]\nf=0\nfor i in range(n):\n    for j in range(m):\n        if c[i][j]==\"*\" and e[i][j]<=0 and g[i][j]<=0:\n            f=1\n            break\nif f==1:\n    print(-1)\nelse:\n    print(len(a))\n    for j in a:\n        print(*j)","output":"quadratic"},{"instruction":"class SortedList:\n    def __init__(self, iterable=None, _load=200):\n\n        if iterable is None:\n            iterable = []\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\nn,x,y=map(int,input().split())\nxx=[]\nfor i in range(n):\n    xx.append(tuple(map(int,input().split())))\n\nxx.sort()\n\nmod=10**9+7\ntv=SortedList()\nend=[]\nc=0\nan=0\nfor i in xx:\n\n    if not len(tv):\n        tv.add(i[1])\n        an+=x+(i[1]-i[0])*y\n    else:\n        if tv[0]>=i[0]:\n            tv.add(i[1])\n            an =(an+ x + (i[1] - i[0]) * y)%mod\n        else:\n            pp=tv.bisect_left(i[0])-1\n            tt=tv[pp]\n            del tv[pp]\n            tv.add(i[1])\n            an=(an+min(x,(i[0]-tt)*y)+(i[1]-i[0])*y)%mod\n\nprint(an)","output":"nlogn"},{"instruction":"from math import factorial, pow\n\ndef wifi(s1, s2):\n    count1, count2, count3 = 0, 0, 0\n    for i in range(len(s1)):\n        if s1[i] == '+':\n            count1 += 1\n        elif s1[i] == '-':\n            count2 += 1\n        if s2[i] == \"+\":\n            count1 -= 1\n        elif s2[i] == '-':\n            count2 -= 1\n        else:\n            count3 += 1\n    if count1 < 0 or count2 < 0:\n        return '{:.9f}'.format(0)\n    q = factorial(count1 + count2) \/ (factorial(count1) * factorial(count2))\n    r = q \/ pow(2, count3)\n    return r\n\nt1 = input()\nt2 = input()\nprint(wifi(t1, t2))","output":"np"},{"instruction":"def case(mid):\n    res=0\n    for k,x in enumerate(str(mid)):\n        res+=int(x)\n    return res\nn,s=map(int,input().split())\ni,j=0,n\nwhile i+1<j:\n    mid=(i+j)\/\/2\n    result=case(mid)\n    if mid-case(mid)<s:i=mid\n    else:j=mid\nif i-case(i)>=s:print(n-i+1)\nelse:\n    if j==n:\n        if j-case(j)>=s:print(1)\n        else:print(0)\n    else:print(n-j+1)","output":"logn"},{"instruction":"n = int(input())\ndp = [1]\nfor IND in range(n):\n    c = input()\n    if c == \"f\":\n        dp.insert(0,0)\n    else:\n        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007\nprint(dp[0])","output":"quadratic"},{"instruction":"import math\nfrom collections import defaultdict\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n\/\/m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii\/\/=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii\/\/=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,input().split())\nS=[input() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\nfor i in range(n):\n    a, b, c = [int(el) for el in input().split()]\n    if ( a > c or b > c):\n        print(-1)\n    else:\n        if (a% 2 + b % 2 == 1):\n            print(c - 1)\n        elif (a%2 == b%2 == c%2):\n            print(c)\n        else:\n            print(c - 2)","output":"constant"},{"instruction":"from sys import stdin, stdout\nn = int(stdin.readline())\nm = int(stdin.readline())\nstdout.write(str(m%(1<<n)))","output":"constant"},{"instruction":"def mp():return map(int,input().split())\ndef it():return int(input())\n\nn,k=mp()\nl=list(mp())\nans=0\nfor i in range(n):\n\tavg,count=0,0\n\tfor j in range(i,n):\n\t\tcount+=l[j]\n\t\tif j-i+1>=k:\n\t\t\tavg=count\/(j-i+1)\n\t\tans=max(avg,ans)\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\ncurpow, t, mx2pow = 1, 1, 0\nwhile t < n:\n    t <<= 1\n    mx2pow += 1\n\nif t > n:\n    mx2pow -= 1\n\nlast = 1 << (mx2pow-1) if mx2pow else 1\nadd = last\n\nwhile last < n:\n    last += add\n\nif last > n:\n    last -= add\n\nwhile n:\n    if n == 1:\n        print(last)\n        break\n    print((str(curpow)+' ') * ((n+1)\/\/2), end='')\n    curpow *= 2\n    n \/\/= 2","output":"nlogn"},{"instruction":"n = int(input())\n\nt = list(map(int,input().split()))\n\nt.sort()\n\nif t[-1]==1:\n    t[-1]=2\nelse:\n    t[-1]=1\nt.sort()\nprint(*t)","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\nb=list(a)\nb.sort()\nc=[]\nsum=0\nfor i in range(1,k+1):\n\tc.append(b[-i])\n\tsum+=b[-i]\nprint(sum)\nd=[]\nfor i in range(n):\n\tif a[i] in c:\n\t\td.append(i)\n\t\tc.remove(a[i])\n\telse:\n\t\tpass\nd.insert(0,-1)\nd[-1]=n-1\ne=[]\nfor i in range(1,len(d)):\n    e.append(d[i]-d[i-1])\nprint(\" \".join(map(str,e)))","output":"nlogn"},{"instruction":"n,k = map(int,input().split(' '))\n\narr = [n];\nk = k+1\nz = 1000000007\nc = (n*pow(2,k,z)-pow(2,k-1,z)+1)%z\nif n==0:\n    print(0)\nelse:\n    print(c)","output":"logn"},{"instruction":"import math\ndef maxor(bawah, atas):\n\tif bawah == atas:\n\t\treturn 0\n\txor = bawah^atas\n\tpangkat2 = math.log(xor, 2)\n\treturn 2**int(math.floor(pangkat2)+1) - 1\na=input().split()\nprint(maxor(int(a[0]),int(a[1])))","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef cord(c):\n    return ord(c)-ord('a')\n\ndef main():\n    n, m = RL()\n    s = input()\n    ct = [0]*(1<<m)\n\n    for i in range(n-1):\n        now, nex = cord(s[i]), cord(s[i+1])\n        if now==nex: continue\n        ct[1<<now | 1<<nex]+=1\n\n    for i in range(m):\n        for j in range(1<<m):\n            if (1<<i) & j:\n                ct[j]+=ct[(1<<i) ^ j]\n\n    dp = [INF]*(1<<m)\n    dp[0] = 0\n    for i in range(1<<m):\n\n        for j in range(m):\n\n            if i & 1<<j == 0:\n                sm = ct[-1]-ct[i]-ct[~i]\n                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)\n\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import sys, math\nimport io, os\n\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.buffer.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n\nmod = int(1e9)+7\n\ndef cal(x):\n    l1=set()\n    d=dd(int)\n    a=[]\n    for i in range(n):\n        k=0\n        for j in range(m):\n            if A[i][j]>=x:\n                k+=1<<j\n        l1.add(k)\n        d[k]=i+1\n    l1=list(l1)\n    s=(1<<m)-1\n    for i in l1:\n        for j in l1:\n            if i|j == s:\n                a=[d[i],d[j]]\n    return a\n\nn,m=mdata()\nA=[mdata() for i in range(n)]\nl,r=0,10**9\nwhile l<=r:\n    mid=(l+r)\/\/2\n    if cal(mid):\n        l=mid+1\n    else:\n        r=mid-1\na=cal(mid)\nif a:\n    outl(a)\nelse:\n    outl(cal(mid-1))","output":"np"},{"instruction":"n, k = [int(a) for a in input().split()]\npower = [int(a) for a in input().split()]\ncoins = [int(a) for a in input().split()]\n\ndp = [0 for i in range(n)]\n\ndef takeSecond(elem):\n    return elem[1]\n\ndef takeFirst(elem):\n    return elem[0]\n\npeople = [(power[i], coins[i], i) for i in range(n)]\n\npeople.sort(key=takeFirst)\n\ndp[0] = []\n\nfor i, p in enumerate(people):\n    if i == 0:\n        continue\n    kills = [i for i in dp[i - 1]]\n    kills.append(people[i - 1][1])\n    x = []\n\n    if len(kills) > k:\n        kills.remove(min(kills))\n\n    dp[i] = kills\n\nx = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]\n\nx.sort(key=takeFirst)\n\nprint(\" \".join([z[1] for z in x]))","output":"nlogn"},{"instruction":"import math\n\nclass Read:\n    @staticmethod\n    def int():\n        return int(input())\n\n    @staticmethod\n    def list(sep=' '):\n        return input().split(sep)\n\n    @staticmethod\n    def list_int(sep=' '):\n        return list(map(int, input().split(sep)))\n\ndef solve():\n    n, k = Read.list_int()\n    s = input()\n\n    sf = 'RGB' * (k + 2)\n\n    max_s = 0\n    for i in range(n - k + 1):\n        for j in range(3):\n            count = 0\n            for b in range(k):\n                if sf[j + b] == s[i + b]:\n                    count += 1\n            if count > max_s:\n                max_s = count\n\n    print(k - max_s)\n\nquery_count = Read.int()\nfor j in range(query_count):\n    solve()","output":"quadratic"},{"instruction":"import math\nfrom math import gcd,floor,sqrt,log\ndef iin(): return int(input())\ndef sin(): return input().strip()\ndef listin(): return list(map(int,input().strip().split()))\ndef liststr(): return list(map(str,input().strip().split()))\ndef ceill(x): return  int(x) if(x==int(x)) else int(x)+1\ndef ceilldiv(x,d): x\/\/d if(x%d==0) else x\/\/d+1\ndef LCM(a,b): return (a*b)\/\/gcd(a,b)\n\ndef solve():\n\tn = iin()\n\tcf = dict()\n\ttc = dict()\n\tfor i in range(n):\n\t\tz = listin()\n\t\tcf[z[0]] = z[1]\n\tm = iin()\n\tfor i in range(m):\n\t\tz = listin()\n\t\ttc[z[0]] = z[1]\n\n\tsett = set(list(cf.keys()) + list(tc.keys()))\n\n\tsumm = 0\n\tfor i in sett:\n\t\ttemp = 0\n\t\ttry:\n\t\t\ttemp = max(tc[i],cf[i])\n\t\texcept:\n\t\t\ttry:\n\t\t\t\ttemp = cf[i]\n\t\t\texcept:\n\t\t\t\ttemp = tc[i]\n\t\tsumm += temp\n\tprint(summ)\n\nt = 1\n\nfor hula in range(t):\n\tsolve()","output":"nlogn"},{"instruction":"n,M=map(int,input().split())\na=[0]+[int(x) for x in input().split()]+[M]\n\nt1=[]\nt2=[]\nfor i in range(n+1):\n    if i%2==0:\n        t1.append(a[i+1]-a[i])\n    else:\n        t2.append(a[i+1]-a[i])\nt2.append(0)\n\nimport math\nans=sum(t1)\np=0\nq=sum(t2)\nfor i in range(math.ceil(n\/2)):\n    p=p+t1[i]\n    q=q-t2[i-1]\n    ans=max(ans,p+q-1)\nprint(ans)","output":"linear"},{"instruction":"from collections import Counter\nimport copy\n\ndef solve():\n    a,b=list(map(int,input().split()))\n    count=0\n    if a==b:\n        return 1\n    while a!=0 and b!=0:\n        if a<b:\n            count+=(b\/\/a)\n            b-=a*(b\/\/a)\n        else:\n            count+=a\/\/b\n            a-=b*(a\/\/b)\n    return count\n\nfor i in range(int(input())):\n        print(solve())","output":"constant"},{"instruction":"import math\n\nn_r = list(map(int, input().split()))\n\nn = n_r[0]\nradii = n_r[1]\n\nx_list = list(map(int, input().split()))\n\ntemp_arr = []\nfor i in range(n):\n    temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j]\n                    for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii])\n                    )\n\nfor i in temp_arr:\n    print(i, end= \" \")","output":"quadratic"},{"instruction":"q = int(input())\nfor t in range(q):\n    n, k = map(int, input().split())\n    rgb = input()\n    dp = [0] * 3\n    dp[0] = [0] * (n + 1)\n    dp[1] = [0] * (n + 1)\n    dp[2] = [0] * (n + 1)\n    for i in range(0, n):\n        if rgb[i] == 'R':\n            dp[0][i + 1] = dp[2][i]\n            dp[1][i + 1] = dp[0][i] + 1\n            dp[2][i + 1] = dp[1][i] + 1\n        if rgb[i] == 'G':\n            dp[0][i + 1] = dp[2][i] + 1\n            dp[1][i + 1] = dp[0][i]\n            dp[2][i + 1] = dp[1][i] + 1\n        if rgb[i] == 'B':\n            dp[0][i + 1] = dp[2][i] + 1\n            dp[1][i + 1] = dp[0][i] + 1\n            dp[2][i + 1] = dp[1][i]\n    repl = k\n    dif = k % 3\n    for j in range(3):\n        for i in range(1, n - k + 2):\n            repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1])\n    print(repl)","output":"linear"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nvis=[0]*n\nans=0\nfor i in range(n):\n    if(vis[i]==0):\n        ans+=1\n        x=l[i]\n        for j in range(n):\n            if l[j]%x==0:\n                vis[j]=1\nprint(ans)","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\no=0\nc=0\ndiff=[]\nwhile n:\n    n-=1\n    a,b=map(int,input().split())\n    diff.append(a-b)\n    o+=a\n    c+=b\n\nif m >=o:\n    print(0)\nelif m <c:\n    print(-1)\nelse:\n    diff.sort(reverse=True)\n    nd=o-m\n\n    for i in range(len(diff)):\n\n        nd-=diff[i]\n        if nd<=0:\n            print(i+1)\n            break","output":"nlogn"},{"instruction":"import math\nn,d=map(int,input().split())\np=list(map(int,input().split()))\nq=[]\nfor i in range(len(p)-1):\n    q.append(abs(p[i+1]-p[i]))\ncount=0\n\nfor k in q:\n    if k==2*d:\n        count+=1\n    elif k>=2*d:\n        count+=2\n\nprint(count+2)","output":"linear"},{"instruction":"a=list(input())\nb=int(input())\na.sort()\na=a[::-1]\nprefix=\"\"\nwhile(len(a)>0):\n    for i in range(len(a)):\n        num=prefix+a[i]+\"\".join(sorted(a[:i]+a[i+1:]))\n        if(int(num)<=b):\n            prefix+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(prefix)","output":"cubic"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\nn = int(stdin.readline())\nout = 0\nfor i in range(2, n + 1):\n    out += 4 * (n \/\/ i - 1) * i\n\nwrite(out)","output":"linear"},{"instruction":"a = list(map(int,input().split()))\nif a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    n,k=inar()\n    arr=inar()\n    new=arr.copy()\n    new=[]\n    ans=0\n    for i in range(n):\n        new.append((arr[i],i))\n    new.sort(reverse=True)\n    check=[0]*n\n    for i in range(k):\n        ans+=new[i][0]\n        check[new[i][1]]=1\n    count=0\n    res=[]\n\n    for i in range(n):\n        if check[i]==1:\n            count+=1\n            res.append(count)\n            count=0\n        else:\n            count+=1\n    res[-1]+=count\n    print(ans)\n    print(*res)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"n = int(input())\n\nr = []\nfor _ in range(n):\n    a,b,c,d = map(int,input().split())\n    r.append(sum([a,b,c,d]))\n\nthomas = r[0]\nprint(sorted(r, reverse=True).index(thomas)+1)","output":"linear"},{"instruction":"from math import factorial\na = input()\nb = input()\nplus, minus, ques = '+', '-', '?'\nops1 = {plus:0, minus:0}\nops2 = {plus:0, minus:0, ques:0}\nfor ai,bi in zip(a,b):\n    ops1[ai] += 1\n    ops2[bi] += 1\nfinal_pos = ops1[plus]-ops1[minus]\ninitial_pos = ops2[plus]-ops2[minus]\ndiff = final_pos-initial_pos\nabs_diff = abs(diff)\nif abs_diff > ops2[ques]:\n    print(0.0)\nelif (ops2[ques]-abs_diff) % 2 != 0:\n    print(0.0)\nelse:\n    total = 2**(ops2[ques])\n    one_type = (ops2[ques]-abs_diff) \/\/ 2\n    other_type = abs_diff + one_type\n    numerator = factorial(ops2[ques])\/(factorial(one_type)*factorial(other_type))\n    print(numerator\/total)","output":"np"},{"instruction":"def min_sub_array(day, k):\n    if not day:\n        return [0] * (k + 1)\n    n = len(day)\n    best = [float('inf')] * (n + 1)\n    best[0] = 0\n    best[1] = 1\n    for size in range(2, n + 1):\n        for i in range(n + 1 - size):\n            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)\n    output = [0] * (k + 1)\n    for i in range(k + 1):\n        if n - i > 0:\n            output[i] = best[n - i]\n    return output\n\nN, M, K = map(int, input().split())\n\nday = [i for i, val in enumerate(input()) if val == '1']\nbest = min_sub_array(day, K)\n\nfor _ in range(N - 1):\n    day = [i for i, val in enumerate(input()) if val == '1']\n    new_day_best = min_sub_array(day, K)\n\n    new_best = [float('inf')] * (K + 1)\n    for i in range(K + 1):\n        for j in range(i + 1):\n            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])\n    best = new_best\nprint(best[K])","output":"cubic"},{"instruction":"def main():\n    l,r = map(int,input().split())\n\n    if l == r:\n        print(0)\n        return\n\n    l = bin(l)[2:]\n    r = bin(r)[2:]\n\n    if len(l) == len(r):\n        i = 1\n        while l[i] == r[i]:\n            i += 1\n        tam = len(l)-i\n    else:\n        tam = len(r)\n\n    num = \"\"\n    for i in range(tam):\n        num += '1'\n\n    print(int(num,2))\n\nmain()","output":"logn"},{"instruction":"def go():\n    n = int(input())\n    x, y = [int(i) for i in input().split(' ')]\n    a = 1 + 1\n    b = n + n\n    c = x + y\n    distance_w = c - a\n    distance_b = b - c\n    if distance_w == distance_b:\n        return 'White'\n    if distance_w < distance_b:\n        return 'White'\n    return 'Black'\n\nprint(go())","output":"constant"},{"instruction":"n = int(input())\nwyn = 1\nx = 4\nfor i in range(n - 1):\n\twyn += x\n\tx += 4\nprint(wyn)","output":"linear"},{"instruction":"import sys,io,os,time\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\nimport bisect,math,heapq\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\ninput = sys.stdin.readline\n\ndef solve():\n  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n  for i in range(r+1):\n    for j in range(g+1):\n      for k in range(b+1):\n        if i+j+k<2:continue\n        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])\n        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])\n        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])\n  return dp[r][g][b]\nprint(solve())","output":"cubic"},{"instruction":"import math\n\np2 =[1] * 64\n\nfor i in range(1, 64):\n    p2[i] = p2[i-1] * 2\n\ndef find_level(x):\n    x0 = 1\n\n    for i in range(max_level+1):\n        if (x-x0) % (x0*2) == 0:\n            return i\n        x0 *=2\n\ndef move_U(number):\n    cur_lv    =  find_level(number)\n\n    if cur_lv == max_level:\n        return number\n\n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2\n    index   =  (number - x0) \/\/ seg\n\n    return (x0*2) + (index \/\/ 2) * (seg * 2)\n\ndef move_L(number):\n    cur_lv    =  find_level(number)\n\n    if cur_lv == 0:\n        return number\n\n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2\n    index   =  (number - x0) \/\/ seg\n\n    return (x0 \/\/ 2) + (index * 2) * (seg \/\/ 2)\n\ndef move_R(number):\n    cur_lv    =  find_level(number)\n\n    if cur_lv == 0:\n        return number\n\n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2\n    index   =  (number - x0) \/\/ seg\n\n    return (x0 \/\/ 2) + (index * 2 + 1) * (seg \/\/ 2)\n\ndef move(s,num):\n    if s == 'U':\n        return move_U(num)\n\n    if s == 'L':\n        return move_L(num)\n\n    return move_R(num)\n\ndef process(S, num):\n    for s in S:\n        num = move(s, num)\n    return num\n\nn, q = map(int, input().split())\nmax_level = int(math.log2(n+1)) - 1\nans  = ''\n\nfor _ in range(q):\n    num  = int(input())\n    S    = input()\n    ans += str(process(S, num)) + '\\n'\n\nprint(ans)","output":"np"},{"instruction":"a, b = [int(x) for x in input().split(' ')]\nidx = 0\nif(a == b):\n    print(0)\nelse:\n    for i in range(63,-1,-1):\n        set1 = (a >> i) & 1\n        set2 = (b >> i) & 1\n        if(set1!=set2):\n            idx = i\n            break\n    print((1<<(idx+1))-1)","output":"logn"},{"instruction":"b = list(map(int, input().split()))\nn = 14\nans = 0\nfor i in range(n):\n    a = b.copy()\n    if a[i] == 0:\n        continue\n    x = a[i]\n    a[i] = 0\n    full = x \/\/ n\n    xex = x % n\n    for j in range(n):\n        a[j] += full\n    for j in range(xex):\n        a[(i + j + 1) % n] += 1\n    pot = 0\n    for j in a:\n        if j % 2 == 0:\n            pot += j\n    ans = max(ans, pot)\nprint(ans)","output":"constant"},{"instruction":"import sys\nimport os\n\ndef solve(slimes):\n    if len(slimes) == 1:\n        return slimes[0]\n\n    havePos = False\n    haveNeg = False\n\n    for s in slimes:\n        if s > 0:\n            havePos = True\n        elif s < 0:\n            haveNeg = True\n\n    if havePos and haveNeg:\n        return sum(map(abs, slimes))\n    elif not havePos:\n        m = max(slimes)\n        return sum(list(map(abs, slimes))) + 2 * m\n    elif not haveNeg:\n        m = min(slimes)\n        return sum(list(map(abs, slimes))) - 2 * m\n    else:\n        return 0\n\ndef main():\n    n = int(input())\n    slimes = list(map(int, input().split()))\n    print(solve(slimes))\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"def gen(n, b):\n\ta = [(x + b) % 3 for x in range(n)]\n\ts = \"\"\n\tfor i in range(n):\n\t\tif a[i] == 0:\n\t\t\ts += \"R\"\n\t\tif a[i] == 1:\n\t\t\ts += \"G\"\n\t\tif a[i] == 2:\n\t\t\ts += \"B\"\n\treturn s\n\nq = int(input())\nfor _ in range(q):\n\tn, k = map(int, input().split())\n\ts = input()\n\tans = n\n\tfor xi in range(3):\n\t\tt = gen(n, xi)\n\t\tdiff = 0\n\t\tfor i in range(k):\n\t\t\tif s[i] != t[i]:\n\t\t\t\tdiff += 1\n\t\tans = min(ans, diff)\n\t\tfor j in range(k, n):\n\t\t\tif s[j - k] != t[j - k]:\n\t\t\t\tdiff -= 1\n\t\t\tif s[j] != t[j]:\n\t\t\t\tdiff += 1\n\t\t\tans = min(ans, diff)\n\tprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\nc = [0] + [int(j) for j in input().split()]\na = [0] + [int(j) for j in input().split()]\nvis = [0] * (n + 1)\nans = 0\nfor i in range(1, n + 1):\n    x = i\n    while vis[x] == 0:\n        vis[x] = i\n        x = a[x]\n    if vis[x] != i:\n        continue\n    v = x\n    mn = c[x]\n    while a[x] != v:\n        x = a[x]\n        mn = min(mn, c[x])\n    ans += mn\nprint(ans)","output":"linear"},{"instruction":"def main():\n    n, m, k, l = map(int, input().split())\n    d = (l + k) \/\/ m\n    if (l + k) % m:\n        d += 1\n    if m * d > n or n - k < l:\n        print(-1)\n    else:\n        print(d)\n\nmain()","output":"constant"},{"instruction":"R,G,B = list(map(int, input().split()))\nr = sorted(list(map(int, input().split())), reverse =True)\ng = sorted(list(map(int, input().split())), reverse =True)\nb = sorted(list(map(int, input().split())), reverse =True)\ndef f(x,y,z):\n    m1 = 0\n    m2 = 0\n    m3 = 0\n    if(x<R and y<G):\n        if(dpt[x+1][y+1][z]==-1):\n            dpt[x+1][y+1][z] = f(x+1,y+1,z)\n        m1 = r[x]*g[y] + dpt[x+1][y+1][z]\n    if(y<G and z<B):\n        if(dpt[x][y+1][z+1]==-1):\n            dpt[x][y+1][z+1] = f(x,y+1,z+1)\n        m2 = g[y]*b[z] + dpt[x][y+1][z+1]\n    if(z<B and x<R):\n        if(dpt[x+1][y][z+1]==-1):\n            dpt[x+1][y][z+1] = f(x+1,y,z+1)\n        m3 = r[x]*b[z] + dpt[x+1][y][z+1]\n    dpt[x][y][z] = max(m1,m2,m3)\n    return dpt[x][y][z]\ndpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]\nprint(f(0,0,0))","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom heapq import *\n\ndef main():\n    n,x,y=map(int,input().split())\n    a,b=[],[]\n    for i in range(n):\n        u,v=map(int,input().split())\n        a.append((u,1))\n        a.append((v,-1))\n    a.sort(key=lambda x:x[0]*10000000000-x[1])\n    mod=10**9+7\n    t,z,ans=1,1,x\n    for i in range(1,len(a)):\n        z+=a[i][1]\n        if z<t:\n            ans=(ans+t*(a[i][0]-a[i-1][0])*y)%mod\n            heappush(b,-a[i][0])\n        else:\n            if b:\n                if x<(a[i][0]+b[0])*y:\n                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+x)%mod\n                else:\n                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+(a[i][0]+b[0])*y)%mod\n                    heappop(b)\n            else:\n                ans = (ans + t * (a[i][0] - a[i - 1][0]) * y + x) % mod\n        t=z\n    print(ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n, M = map(int, input().strip().split())\na = list(map(int, input().strip().split()))\n\na.insert(0, 0)\nn += 1\n\nlit = [0] * (n + 1)\nfor i in range(1, n):\n    if i % 2 == 0:\n        lit[i] = lit[i - 1]\n    else:\n        lit[i] = lit[i - 1] + a[i] - a[i - 1]\nif n % 2 == 0:\n    lit[n] = lit[n - 1]\nelse:\n    lit[n] = lit[n - 1] + M - a[n - 1]\n\nans = lit[n]\nfor i in range(n):\n    pre_lit = lit[i]\n    post_lit = M - a[i] - (lit[n] - lit[i])\n\n    if i > 0 and a[i - 1] + 1 < a[i]:\n        if i % 2 == 0:\n            ans = max(ans, pre_lit + 1 + post_lit)\n        else:\n            ans = max(ans, pre_lit - 1 + post_lit)\n    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):\n        if i % 2 == 0:\n            ans = max(ans, pre_lit + post_lit + 1)\n        else:\n            ans = max(ans, pre_lit + post_lit - 1)\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\n\nfirst = list(input())\nsecond = list(input())\n\nswap = list()\ncan = True\n\nfor i in range(n):\n    if first[i] != second[i]:\n        cont = -1\n        for j in range(i,n):\n            if first[j] == second[i]:\n                cont = j\n                break\n\n        if cont != -1:\n            for j in range(cont, i, -1 ):\n                first[j], first[j-1] = first[j-1], first[j]\n                swap.append(j)\n        else:\n            can = False\n\nif can:\n    print(len(swap))\n    print(*swap, end=' ')\n\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, a, b = [int(i) for i in input().split()]\nh = sorted([int(i) for i in input().split()])\nVasya = h[:b]\nPetya = h[b:]\nprint(Petya[0] - Vasya[-1])","output":"nlogn"},{"instruction":"def func(n,i):\n        if n==3:\n                return (str(1*i)+' ')+(str(1*i)+' ')+(str(3*i))\n        if n%2==0:\n                odd=n\/\/2\n        else:\n                odd=n\/\/2+1\n        q=1*i\n        s= (str(q)+' ')*odd\n        return s\n\nfrom math import log\nn=int(input())\nif n==3:\n        s='1 1 3'\nelse:\n        s=''\n        z=1\n        while(n>0):\n                s=s+func(n,z)\n                z=z*2\n                if n==3:\n                        break\n                if n%2==0:\n                        odd=n\/\/2\n                else:\n                        odd=n\/\/2+1\n                n=n-odd\nprint(s)","output":"logn"},{"instruction":"import sys\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef rinput():   return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\nn=iinput()\nd={}\nfor i in range(n - 1):\n    u,v=rinput()\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")","output":"linear"},{"instruction":"import sys\nsys.setrecursionlimit(int(1e7))\n\ndef main():\n    n = int(input().strip())\n    print(2*(n*(n-1))+1)\n    return\n\nwhile 1:\n    try: main()\n    except EOFError: break","output":"constant"},{"instruction":"import math\nk,n,s,p=[int(x) for x in input().split()]\nx=math.ceil(n\/s)\ny=math.ceil(x*k\/p)\nprint(y)","output":"constant"},{"instruction":"from os import path\nimport sys,time\n\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import *\n\nmaxx = float('inf')\n\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().replace('\\n', '').strip()\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n\nn = I()\nls = [int(i) for i in S()]\npre , s =[] , 0\nfor i in ls:\n\ts+=i\n\tpre.append(s)\nfor i in range(n-1):\n\tcnt =0\n\tsu =0\n\tfor j in range(i+1 , n):\n\t\tsu+=ls[j]\n\t\tif su == pre[i]:\n\t\t\tcnt+=1\n\t\t\tsu =0\n\tif cnt and su ==0:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"quadratic"},{"instruction":"import math\n\ndef main():\n    n,m,k,l = map(int, input().strip().split())\n\n    t = int(k + l + m - 1) \/\/ m\n\n    if k + l > n:\n        print(-1)\n        return\n\n    if m * t > n:\n        print(-1)\n        return\n\n    print(t)\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"def win1():\n    if n==k or r[k+1]==n or l[n-k]==1:\n        return True\n    for i in range(2,n-k+1):\n        if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]:\n            return True\n    return False\n\ndef win2():\n    if 2*k<n:\n        return False\n    for i in range(2,n-k+1):\n        if l[i-1]!=1 or r[i+k]!=n:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    s=input().split()\n    n,k=int(s[0]),int(s[1])\n    s=input().split()\n    a=[0]\n    l=[0 for i in range(n+1)]\n    r=[0 for i in range(n+1)]\n    for c in s[0]:\n        a.append(int(c))\n    l[1],r[n]=1,n\n    for i in range(2,n+1):\n        if a[i-1]==a[i]:\n            l[i]=l[i-1]\n        else:\n            l[i]=i\n        if a[n-i+1]==a[n-i+2]:\n            r[n-i+1]=r[n-i+2]\n        else:\n            r[n-i+1]=n-i+1\n\n    if win1():\n        print(\"tokitsukaze\")\n    elif win2():\n        print(\"quailty\")\n    else:\n        print(\"once again\")","output":"linear"},{"instruction":"if __name__ == '__main__':\n    cin = input\n    n, m = map(int, cin().split())\n    s, l, f = [[] for _ in range(n)], [0] * m, 0\n\n    for i in range(n):\n        t = cin()\n        for j in range(m):\n            if t[j] == \"1\":\n                l[j] += int(t[j])\n                s[i].append(j)\n    for i in range(n):\n        r = set(l[c] - 1 for c in s[i])\n        if not 0 in r:\n            f = not f\n            break\n    print(\"YNEOS\"[not f::2])","output":"quadratic"},{"instruction":"x, k = [int(v) for v in input().split()]\nmod = 10**9 + 7\n\nif x == 0:\n    print(0)\nelse:\n    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)","output":"logn"},{"instruction":"a , b , c , d , e , f = map(int,input().split())\nn , n1 = 1 , a * b + c * d + e * f\nwhile n ** 2 < n1 :\n    n += 1\nif n ** 2 > n1 :\n    print(-1)\n    exit()\nl = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])\nif l[2][0] != n:\n    print(-1)\n    exit()\nv = str(n) + '\\n' + (l[2][2] * n + '\\n') * l[2][1]\nif l[0][0] == n and l[1][0] == n:\n    for i in range(2):\n        v += (l[i][2] * n + '\\n') * l[i][1]\nelse:\n    s = n - l[2][1]\n    if s not in l[0] or s not in l[1] :\n        print(-1)\n        exit()\n    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]\n    v += (l[0][2] * x + l[1][2] * y + '\\n') * s\nprint(v)","output":"np"},{"instruction":"n = [int(x) for x in input().split(' ')]\nM = 1000000007\n\ndef a(k):\n\tM = 1000000007\n\tif(k>0):\n\t\tl = a(k\/\/2)\n\t\treturn (l*l*(k%2+1))%M\n\telse:\n\t\treturn 1\n\nif n[0]==0:\n\tprint(0)\nelse:\n\tl = a(n[1])\n\tprint((2*(n[0]%M)*l-l+1)%M)","output":"logn"},{"instruction":"from math import *\n\nn,k = map(int,input().split())\nans = [0] * n\n\nlul = 2**k - 1\nA = list(map(int,input().split()))\nans[0]  = A[0]\nfor j in range(1, n):\n    ans[j] = ans[j-1]^A[j]\n\nd = dict()\nfor j in range(n):\n    if ans[j] in d:\n        d[ans[j]]+=1;\n    else:\n        d[ans[j]] = 1\n\nans =0\ndef huy(n):\n    return n*(n-1)\/\/2\nfor j in d:\n    now = d[j]\n\n    xor = lul^j\n    cur = now\n\n    if xor in d :\n\n        now2 = d[xor]\n\n        cur += now2\n\n        ans += huy(cur\/\/2+cur%2)\n        ans+=huy(cur\/\/2)\n        if j ==0:\n            ans+=2*(cur\/\/2)\n    else:\n        if(j==0 or xor ==0):\n            ans+= 2*(cur\/\/2)\n        ans += 2*huy(cur \/\/ 2 + cur % 2)\n        ans += 2*huy(cur \/\/ 2)\nprint(huy(n+1) - ans\/\/2)","output":"linear"},{"instruction":"import math\ndef f(n,k):\n    if k==1:\n        return (n*(n+1))\/\/2\n    a=math.floor(math.log(n,k))\n    b=sum(k**i for i in range(a+1))\n    c=sum((i+1)*k**i for i in range(a+1))\n    if n<b:\n        return c-(b-n)*(a+1)\n    else:\n        return c+(n-b)*(a+2)\nn,s=map(int,input().split())\nif s==(n*(n+1))\/\/2:\n    print(\"Yes\")\n    a=[str(i+1) for i in range(n-1)]\n    print(\" \".join(a))\nelif s>(n*(n+1))\/\/2:\n    print(\"No\")\nelif s<2*n-1:\n    print(\"No\")\nelse:\n    mini=1\n    maxi=n-1\n    curr=1\n    while True:\n        a,b=f(n,curr),f(n,curr+1)\n        if b>s:\n            mini=curr+1\n            curr=math.ceil((curr+maxi)\/2)\n        elif a<=s:\n            maxi=curr-1\n            curr=(curr+mini)\/\/2\n        else:\n            opt=curr+1\n            break\n    depths=[0,1]+[0]*(n-1)\n    ins=1\n    ind=2\n    while True:\n        a=min(opt**(ind-1),n-ins)\n        depths[ind]=a\n        ind+=1\n        ins+=a\n        if ins==n:\n            break\n    left=s-b\n    far=ind-1\n    bulk=ind-1\n    if depths[bulk]==1:\n        bulk-=1\n    while left>0:\n        if far+1-bulk<=left:\n            far+=1\n            left-=far-bulk\n            depths[far]+=1\n            depths[bulk]-=1\n            if depths[bulk]==1:\n                bulk-=1\n        else:\n            depths[bulk]-=1\n            depths[bulk+left]+=1\n            left=0\n    verts=[None]*far\n    sumi=0\n    for i in range(far):\n        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))\n        sumi+=depths[i+1]\n    out=\"\"\n    for i in range(1,far):\n        for j in range(len(verts[i])):\n            out+=str(verts[i-1][j\/\/opt])+\" \"\n    print(\"Yes\")\n    print(out)","output":"linear"},{"instruction":"n = int(input())\nans = 1+n\/\/2\nprint(ans)","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,q=map(int,input().split())\nx=n+1\nl=0\nwhile x>1:\n    x\/\/=2\n    l+=1\nfor i in range(q):\n    a=int(input())\n    s=input()\n    for j in s:\n        lv=1\n        a1=a\n        while a1%2==0:\n            a1=a1\/\/2\n            lv+=1\n        x=2**lv\n        q=x\/\/2\n        p=q\/\/2\n        y=(a-q)\/\/x+1\n        if j=='U':\n            if lv==l:\n                pass\n            else:\n                if y%2:\n                    a=(2*a+x)\/\/2\n                else:\n                    a=(2*a-x)\/\/2\n        elif j=='L':\n            if lv==1:\n                pass\n            else:\n                z=2*(y-1)\n                a=p+z*q\n        else:\n            if lv==1:\n                pass\n            else:\n                z=2*(y-1)\n                a=p+(z+1)*q\n    print(a)","output":"np"},{"instruction":"n, k = [int(x) for x in input().split()]\nif k == 1:\n    print(\"1\" + \"0\"*(n-1))\nelse:\n    tmp = \"0\" * ((n-k)\/\/2) + \"1\"\n    s = tmp\n    s = tmp * (n \/\/ len(tmp) + 1)\n    s = s[:n]\n    print(s)","output":"constant"},{"instruction":"n = int(input())\nprint(\"0 0 {}\".format(n))","output":"constant"},{"instruction":"def read():\n    return int(input())\n\ndef readlist():\n    return list(map(int, input().split()))\n\ndef readmap():\n    return map(int, input().split())\n\nN, A, B = readmap()\n\nif N == 1:\n    print(\"YES\")\n    print(0)\n\nelif N == 2:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"01\")\n        print(\"10\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"00\")\n        print(\"00\")\n    else:\n        print(\"NO\")\n\nelif N == 3:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"011\")\n        print(\"100\")\n        print(\"100\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"001\")\n        print(\"000\")\n        print(\"100\")\n    elif A == 1 and B == 3:\n        print(\"YES\")\n        print(\"011\")\n        print(\"101\")\n        print(\"110\")\n    elif A == 3 and B == 1:\n        print(\"YES\")\n        print(\"000\")\n        print(\"000\")\n        print(\"000\")\n    else:\n        print(\"NO\")\n\nelse:\n    if A != 1 and B != 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if B == 1 and A != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= A:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= A:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        elif A == 1 and B != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= B:\n                            vec.append(0)\n                        else:\n                            vec.append(1)\n                    vec[i] = 0\n                    mat.append(vec)\n                else:\n                    vec = [1] * N\n                    if i >= B:\n                        vec[0] = 0\n                    vec[i] = 0\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        else:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= 2:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= 2:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            mat[1][2] = 1\n            mat[2][1] = 1\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))","output":"quadratic"},{"instruction":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        for i in range(len(prices)):\n            buy = prices[i]\n            for j in range(i + 1, len(prices)):\n                sell  = prices[j]\n                res = max(res, sell - buy)\n        return res","output":"quadratic"},{"instruction":"t=int(input())\nfor i in range(t):\n    n,k=map(int,input().split())\n    if n>32:\n        print(\"YES\",n-1)\n    else:\n        max_splits=(4**n-1)\/\/3\n        if k>max_splits or (n,k)==(2,3):\n            print(\"NO\")\n        else:\n            done=False\n            for i in range(n):\n                if k<2**(i+2)-i-3:\n                    print(\"YES\",n-i)\n                    done=True\n                    break\n            if not done:\n                print(\"YES\",0)","output":"logn"},{"instruction":"n,s=map(int,input().split())\narr=[]\nfor i in range(n):\n    arr.append([])\n    arr[i]=[int(i) for i in input().split()]\narr=sorted(arr,reverse=True,key=lambda x:x[0])\nans,c=0,0\nfor i in range(n):\n    if i!=0:\n       c=arr[i-1][0]\n    if i==0:\n       ans=ans+s-arr[i][0]\n    else:\n       ans=ans+c-arr[i][0]\n    if arr[i][1]>=ans:\n        ans=ans+(arr[i][1]-ans)\nans=ans+arr[n-1][0]\nprint(ans)","output":"linear"},{"instruction":"n, m = [int(x) for x in input().split()]\nmat = []\nv = []\n\nfor i in range(n):\n    mat.append([x == '\n    v.append([False]*m)\n\ndef check(m, v, x, y):\n    for i in (-1,0,1):\n        for j in (-1,0,1):\n            if (i,j) == (0,0):\n                continue\n            if not m[x+i][y+j]:\n                return\n\n    for i in (-1,0,1):\n        for j in (-1,0,1):\n            if (i,j) != (0,0):\n                v[x+i][y+j] = True\n\nfor x in range(1, n-1):\n    for y in range(1,m-1):\n        check(mat, v, x, y)\n\nflag = True\nfor i in range(0,n):\n    for j in range(0,m):\n        if mat[i][j] and (not v[i][j]):\n            flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"def push(d, u, v):\n    if u not in d:\n        d[u] = []\n    if v not in d:\n        d[v] = []\n    d[u].append(v)\n    d[v].append(u)\n\ndef push_v(d, u, val):\n    if u not in d:\n        d[u] = 0\n    d[u] += val\n\nn, k = map(int, input().split())\ng    = {}\n\nfor _ in  range(n-1):\n    u, v = map(int, input().split())\n    push(g, u, v)\n\ndeg1 = []\nused = [0] * (n+1)\n\nfor u in g:\n    if len(g[u]) == 1:\n        used[u]  = 1\n        deg1.append(u)\n\nflg = True\nwhile k > 0:\n    if k >= 1 and len(deg1) < 3:\n        flg=False\n        break\n\n    cnt = {}\n    for u in deg1:\n        for v in g[u]:\n            if used[v] == 0:\n                push_v(cnt, v, 1)\n\n    for v in deg1:\n        used[v] = 1\n\n    deg1 = []\n\n    for v, val in cnt.items():\n        if val < 3:\n            flg=False\n            break\n        deg1.append(v)\n\n    if flg==False:\n        break\n    k-=1\n\nif flg==True and len(deg1) > 1:\n    flg=False\n\nif flg==False:\n    print('NO')\nelse:\n    print('YES')","output":"nlogn"},{"instruction":"n, l, r, x = map(int, input().split())\nC = sorted(list(map(int, input().split())))\nANS = 0\nfor i in range(2 ** n):\n    s = bin(i)[2:]\n    s = '0' * (n - len(s)) + s\n    L = []\n    for j in range(n):\n        if s[j] == '1':\n            L.append(C[j])\n    if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x:\n        continue\n    ANS += 1\nprint(ANS)","output":"np"},{"instruction":"n=int(input())\nL=list(map(int,input().split()))\nans=['']*n\nrevL=[0]*n\nans[-1]='B'\nfor i in range(n):\n    revL[L[i]-1]=i+1\nfor i in range(n-2,-1,-1):\n    t=revL[i]-1\n    counter='B'\n    for j in range(t,-1,-i-1):\n        if j==t:continue\n        if ans[L[j]-1]=='B':\n            counter='A'\n            break\n    if counter!='A':\n        for k in range(t,n,i+1):\n            if k==t:continue\n            if ans[L[k]-1]=='B':\n                counter='A'\n                break\n    ans[i]=counter\nfor i in range(n):\n    print(ans[L[i]-1],sep='',end='')","output":"quadratic"},{"instruction":"from math import *\na,v=list(map(int,input().split()))\nl,d,w=list(map(int,input().split()))\nif v>w:\n    s1=w**2\/2\/a\n    if d<=s1:\n        s=min(v**2\/2\/a,l)\n        t=sqrt(2*s\/a)+(l-s)\/v\n    else:\n        t=sqrt(2*s1\/a)\n        s2=min((d-s1)\/2,(v**2-w**2)\/(2*a))\n        if s2==(d-s1)\/2:\n            t+=2*(sqrt(2*(s1+s2)\/a)-sqrt(2*s1\/a))\n        else:\n            t+=2*(v-w)\/a+(d-s1-2*s2)\/v\n        s3=min((v**2-w**2)\/2\/a,l-d)\n        t+=sqrt(2*(s3+s1)\/a)-sqrt(2*s1\/a)+(l-d-s3)\/v\nelse:\n    s=min(v**2\/2\/a,l)\n    t=sqrt(2*s\/a)+(l-s)\/v\nprint(t)","output":"constant"},{"instruction":"from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\ndef dp(r1, g1, b1):\n    if mem[r1][g1][b1] != -1:\n        return mem[r1][g1][b1]\n\n    v1, v2, v3 = 0, 0, 0\n\n    if r1 < r:\n        if g1 < g:\n            v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1)\n        if b1 < b:\n            v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1)\n\n    if g1 < g and b1 < b:\n        v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1)\n\n    mem[r1][g1][b1] = max(v1, v2, v3)\n\n    return mem[r1][g1][b1]\n\nr, g, b = rints()\nar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]\nmem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]\nprint(dp(0, 0, 0))","output":"cubic"},{"instruction":"n, k = map(int, input().split())\nps = list(map(int, input().split()))\n\ng = [None for i in range(256)]\nf = [None for i in range(256)]\nans = []\nfor i in range(n):\n    p = ps[i]\n    if g[p] is not None:\n        ans.append(g[p])\n        f[p] = 1\n    else:\n        gb= 0\n        for j in range(k):\n            ind = p - j\n            if f[ind] is not None:\n                gb = ind +1\n                break\n            if ind <= 0:\n                break\n            if j == k-1:\n                gb = ind\n        ans.append(gb)\n        for j in range(k):\n            if gb+j >= 256:\n                break\n            if f[gb + j] is None:\n                g[gb+j] = gb\n            else:\n                break\n        f[gb] = 1\n        f[p] = 1\nprint(' '.join([str(i) for i in ans]))","output":"quadratic"},{"instruction":"n  = int(input())\n\na  = list(map(int, input().strip()))\nb  = list(map(int, input().strip()))\n\nres = 0\n\nfor j in range(n-1):\n    if (a[j]== 0) and (a[j+1 ] == 1 ) and (b[j] == 1) and (b[j+1 ] == 0):\n        res +=1\n        a[j ] = 1\n        a[j+1] = 0\n\n    elif  (a[j]== 1) and (a[j+1] ==0 ) and (b[j] == 0) and (b[j+1 ] == 1):\n        res +=1\n        a[j ] = 0\n        a[j+ 1] = 1\n\nfor j in range(n):\n    if a[j] != b[j]:\n        res += 1\n\nprint(res)","output":"linear"},{"instruction":"n, m, k, l = map(int, input().split())\nk += l\nx = (k + m - 1) \/\/ (m);\nif m * x > n:\n    print(-1)\nelse:\n    print(x)","output":"constant"},{"instruction":"n = int(input())\n\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\ncnt = 0\nwhile a:\n    f = a.pop()\n    rm = []\n    for x in a:\n        if x % f == 0:\n            rm.append(x)\n    for x in rm:\n        a.remove(x)\n    cnt += 1\n\nprint(cnt)","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\n\nfor _ in range(1):\n    r, c=lst()\n    a=[input() for i in range(r)]\n    pre=[[0 for i in range(c)] for i in range(r)]\n    suf=[[0 for i in range(c)] for i in range(r)]\n    for i in range(c):\n        pre[0][i]=int(a[0][i])\n        suf[r-1][i]=int(a[r-1][i])\n    for i in range(1, r):\n        for j in range(c):\n            pre[i][j]=pre[i-1][j]+int(a[i][j])\n\n    for i in range(r-2, -1 ,-1):\n        for j in range(c):\n            suf[i][j]=suf[i+1][j]+int(a[i][j])\n    ans='NO'\n    for i in range(r):\n        f=1\n        for j in range(c):\n            up=down=0\n            if i-1>=0:up=pre[i-1][j]\n            if i+1<r:down=suf[i+1][j]\n            if up+down==0:\n                f=0\n                break\n        if f:\n            ans=\"YES\"\n            break\n    print(ans)","output":"quadratic"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):\n    print(\"NO\")\n    exit()\nres = [[0] * n for _ in range(n)]\nfor i in range(0, n - max(a, b)):\n    res[i][i + 1] = res[i + 1][i] = 1\nif a == 1:\n    res = [[e ^ 1 for e in l] for l in res]\n\nprint(\"YES\")\nfor i in range(n):\n    res[i][i] = 0\n    print(*res[i], sep='')","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\ns=[]\nst=set()\ncst=set()\nfor i in range(n):\n    s.append(input())\n    for j in range(len(s[i])):\n        if s[i][j]=='\n            st.add((i,j))\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if s[i-1][j-1]!='\n            continue\n        if s[i - 1][j ] != '\n            continue\n        if s[i-1][j+1]!='\n            continue\n        if s[i][j-1]!='\n            continue\n        if s[i][j+1]!='\n            continue\n        if s[i+1][j-1]!='\n            continue\n        if s[i+1][j]!='\n            continue\n        if s[i+1][j+1]!='\n            continue\n        cst.add((i-1,j))\n        cst.add((i - 1, j-1))\n        cst.add((i - 1, j+1))\n        cst.add((i + 1, j))\n        cst.add((i + 1, j-1))\n        cst.add((i + 1, j+1))\n        cst.add((i , j+1))\n        cst.add((i , j-1))\nif len(cst)==len(st):\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"def getsum(a, b):\n    if a % 2 == 0:\n        return (a + b) * ((b - a) \/\/ 2 + 1) \/\/ 2\n    else:\n        return -(a + b) * ((b - a) \/\/ 2 + 1) \/\/ 2\n\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l == r:\n        print(l if l % 2 == 0 else -l)\n    else:\n        print(\n            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) +\n            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)\n        )","output":"constant"},{"instruction":"from sys import stdin, stdout\nmod=(10**9)+7\nmod1=mod-1\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p\n    return t\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\ndef BS(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l)\/2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return BS(arr, l, mid-1, x)\n        else:\n            return BS(arr, mid+1, r, x)\n    else:n -1\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport math\nfrom Queue import Queue as Q\nimport heapq\nfrom random import randint as rn\ndef comp(x,y):\n    if(x[0]<y[0]):\n        return -1\n    elif(x[0]==y[0]):\n        if(x[1]<y[1]):\n            return -1\n        else:\n            return 1\n    else:\n        return 1\n\nq=[]\nfor _ in range(input()):\n    a=int(stdin.readline())\n    b=map(int,stdin.readline().split())\n    w={}\n    for i in range(a):\n        if(w.has_key(b[i])):\n            w[b[i]]+=1\n        else:\n            w[b[i]]=1\n    s=-1\n    l=0\n    mi=2325234324324234\n    d=[]\n    for i in w:\n        if(w[i]>=4):\n            t=[str(i),str(i),str(i),str(i)]\n            q.append(\" \".join(t))\n            l=1\n            break\n        if(w[i]>=2):\n            d.append(i)\n    if(l==1):\n        continue\n    d.sort()\n    for i in range(len(d)):\n        if(s==-1):\n            s=d[i]\n        else:\n            r=float(s)\/float(d[i])\n            r+=float(d[i])\/float(s)\n            if(r<mi):\n                p=[str(d[i]),str(s)]\n                mi=r\n            s=d[i]\n    p=p*2\n    q.append(\" \".join(p))\nstdout.write(\"\\n\".join(q))","output":"nlogn"},{"instruction":"from math import ceil\nn,k = map(int,input().split())\nprint(ceil(n*2\/k)+ceil(n*5\/k)+ceil(n*8\/k))","output":"constant"},{"instruction":"try:\n    odd, even, oddIndex, evenIndex = 0, 0, 0, 0\n    n = int(input())\n    s = list(map(int, input().split()))\n    counter = 0\n    for i in s:\n        if i % 2 == 0:\n            even += 1\n            evenIndex = counter\n        else:\n            odd += 1\n            oddIndex = counter\n        counter += 1\n    ans = evenIndex + 1 if even == 1 else oddIndex + 1\n    print(ans)\nexcept EOFError as e:\n    pass","output":"linear"},{"instruction":"n = int(input())\nar = list(map(int, input().split()))\nrev = ar[::-1]\nfrom collections import Counter\ndef d(ar):\n\tme = Counter()\n\ts = 0\n\tfor i in range (n) :\n\t\ts+=(i*ar[i])\n\t\ts-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])\n\t\tme[ar[i]]+=1\n\treturn s\nprint(d(ar) - d(rev))","output":"nlogn"},{"instruction":"k1,k2,k3=map(int,input().split())\nfl=0\nfor i1 in range(5):\n    for i2 in range(5):\n        for i3 in range(5):\n            flak=1\n            for i in range(8):\n                if (i-i1)%k1==0 or (i-i2)%k2==0 or (i-i3)%k3==0:\n                    continue\n                else:\n                    flak=0\n            if flak==1:\n                fl=1\nif fl==1:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"index = int(input())\n\ntotal = 9\nn = 1\n\nwhile index > total:\n    total += (n + 1) * (10**n) * 9\n    n += 1\nlast = 10**(n - 1)\ntotal -= n * 9 * last\nindex = index - total\n\nr = index % (n)\nk = index \/\/ n\n\nnumber = last + k\n\nif r == 0:\n    print(str(number - 1)[n-1])\nelse:\n    print(str(number)[r - 1])","output":"logn"},{"instruction":"l,r = [int(x) for x in input().split()]\nif l==r or l+1==r:\n    print(-1)\nelif l%2==0:\n    print(l,l+1,l+2)\nelif l%2!=0 and r-l+1>3:\n    print(l+1,l+2,l+3)\nelse:\n    print(-1)","output":"constant"},{"instruction":"import math\nn = int(input())\ns = list(map(int, input().split()))\nd = dict()\nfor i in range(n):\n    d[s[i]] = d.get(s[i], 0)+1\n\nrem = 0\nfor i in range(n):\n\n    ok = False\n    for j in range(31):\n        x = 2** j - s[i]\n        c = d.get(x , 0)\n        if c > 1 or (c == 1 and s[i] != x):\n            ok = True\n            break\n\n    if ok == False:\n        rem += 1\n\nprint(rem)","output":"nlogn"},{"instruction":"n, x = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\ns = set(a)\nmv = 999\nif len(s) < n:\n    print(0)\nelse:\n    for i in a:\n        if i & x != i and i & x in s:\n            print(1)\n            break\n    else:\n        k = [i & x for i in a]\n        if len(set(k)) < n:\n            print(2)\n        else:\n            print(-1)","output":"linear"},{"instruction":"n,x=list(map(int,input().split()))\nb=list(map(int,input().split()))\nd={}\nflag=0\nfor i in b:\n    if d.get(i):\n        flag=1\n        break\n    else:\n        d[i]=1\nif flag:\n    print(0)\nelse:\n    flag=0\n    c=set()\n    for i in b:\n        a=i&x\n        c.add(a)\n        if d.get(a) and a!=i:\n            flag=1\n            break\n    if flag:\n        print(1)\n    elif len(c)<n and flag==0:\n        print(2)\n    else:\n        print(-1)","output":"linear"},{"instruction":"s = input()\nsLen, ans = len(s), 0\n\nfor i in range(sLen - 1):\n    for till1 in range(i + 1, sLen):\n        till2 = till1 + 1\n        for j in range(i + 1, sLen):\n            if till2 > sLen:\n                break;\n            sub1 = s[i:till1]\n            sub2 = s[j:till2]\n            subLen = len(sub1)\n            if sub1 == sub2 and subLen > ans:\n                ans = subLen\n            till2 += 1\n\nprint(ans)","output":"cubic"},{"instruction":"def fn(n):\n\treturn (n * (n + 1)) \/ 2\n\ndef search(x, n):\n\tleft, right = 0, n\n\twhile left <= right:\n\t\tmiddle = left + (right - left) \/\/ 2\n\t\tif fn(middle) - (n - middle) == x: return (n - middle)\n\t\telif fn(middle) - (n - middle) > x: right = middle - 1\n\t\telse: left = middle + 1\n\treturn -1\n\nif __name__ == '__main__':\n\tn, k = [int(i) for i in input().split()]\n\tprint(search(k, n))","output":"logn"},{"instruction":"from collections import defaultdict as dd, deque\nimport sys,atexit\nfrom io import BytesIO\ninp = BytesIO(sys.stdin.buffer.read())\ninput = lambda:inp.readline().decode('ascii')\nbuf = BytesIO()\nsys.stdout.write = lambda s: buf.write(s.encode('ascii'))\natexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))\n\nn,q = map(int,input().split())\nS = [int(x) for x in input().split()]\nQ = deque(S)\n\nn = len(Q)\nres = []\nfor i in range(n):\n    a = Q.popleft()\n    b = Q.popleft()\n    Q.appendleft(max(a,b))\n    Q.append(min(a,b))\n    res.append((a,b))\n\nA = list(Q)\n\ndef solve(t):\n    if t < len(res):\n        return res[t-1]\n    t -= len(res) + 1\n    t %= n-1\n    return A[0],A[t+1]\n\nfor _ in range(q):\n    t = int(input())\n    print(*solve(t))","output":"linear"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\ns = STR()\n\nif len(set(s)) == len(s):\n    print('0')\n    exit(0)\n\nd = []\n\nfor i in range(len(s)):\n    for j in range(i+1 , len(s)):\n        x = ''\n        for k in range(i , j+1):\n            x += s[k]\n\n        d.append(x)\n\nv = {}\nfor i in range(len(s)):\n    if s[i] not in v :\n        v[s[i]] = 1\n    else:\n        v[s[i]] +=1\n\nfor i in d :\n    if i not in v :\n        v[i] = 1\n    else:\n        v[i]+=1\n\nmx = -1\nans = ''\n\nfor i in v :\n    if v[i] >= 2 :\n        if len(i) > mx :\n            mx = max(mx , len(i))\n\nprint(mx)","output":"cubic"},{"instruction":"z,x=map(int,input().split())\nz-=1;x-=1\nif x*(x+1)\/2 < z :\n  print(-1)\nelif z==0:\n    print(0)\nelif z==x:\n    print(1)\nelse:\n    import sys\n    start = 1 ; end = x\n    while end > start:\n        mid = (end +start)\/\/2\n        ans =(x*(x+1)\/\/2)-((mid-1)*(mid)\/\/2 )\n        if ans == z:\n            print(x-mid+1)\n            sys.exit(0)\n        elif ans > z:\n            start = mid+1\n        elif ans < z:\n            end = mid\n    print(x-end+2)","output":"logn"},{"instruction":"import sys\nk=int(input())\nif type(k)!=int or k<=0 or k>pow(10,12) :\n        print(\"wrong input. try again\")\n        sys.exit()\nlim_init=lim=decimal=9\nc=0\nwhile True:\n        c+=1\n        if k<=lim:\n                diff=lim-k\n                pos=diff%c\n                diff=int(diff\/c)\n                diff=decimal-diff\n                print(''.join(list(reversed(str(diff))))[pos])\n                break\n        else:\n                decimal = int(str(lim_init)*(c+1))\n                lim+=int(str(lim_init)+'0'*c)*(c+1)","output":"constant"},{"instruction":"from itertools import combinations_with_replacement\nimport sys\nfrom sys import stdin\nimport math\nimport bisect\n\ndef BinarySearch(a, x):\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    else:\n        return -1\ndef iinput():\n    return int(input())\ndef minput():\n    return map(int,input().split())\ndef linput():\n    return list(map(int,input().split()))\n\ndef fiinput():\n    return int(stdin.readline())\ndef fminput():\n    return map(int,stdin.readline().strip().split())\ndef flinput():\n    return list(map(int,stdin.readline().strip().split()))\n\nx,k=minput()\n\nif(x==0):\n    print(0)\nelse:\n    mod=(10**9)+7\n    a=pow(2,k,mod)\n    b=((2*x)%mod-1)%mod\n    ans=((a*b)%mod+1)%mod\n    print(ans)","output":"logn"},{"instruction":"n,l,r,x=map(int,input().split())\na=list(map(int,input().split()))\ncount=0\nt=0\nans=[]\nfor i in range(3,(2**n)+1):\n    c=i\n    ans=[]\n    sum=0\n    while c!=0:\n        c=c&(c-1)\n        count+=1\n    if count>1:\n        for j in range(n):\n            if i & (1 << j):\n                sum+=a[j]\n                ans.append(a[j])\n        if l<=sum<=r and (max(ans)-min(ans))>=x:\n            t+=1\nprint(t)","output":"np"},{"instruction":"def givestringsk(k):\n    t=[\"R\",\"G\",\"B\"]\n    ans=[]\n    for i in range(3):\n        temp=\"\"\n        for j in range(i,i+k):\n            temp+=t[j%3]\n        ans.append(temp)\n    return ans\ndef countdifferences(a,b):\n    cnt=0\n    for i in range(len(a)):\n        if a[i]!=b[i]:cnt+=1\n    return cnt\nfor _ in range(int(input())):\n    n,k=list(map(int,input().split()))\n    s=input()\n    temp=givestringsk(k)\n    ans=10000000000000\n    for i in range(k,n+1):\n        for j in range(3):\n            ans=min(ans,countdifferences(s[i-k:i],temp[j]))\n    print(ans)","output":"quadratic"},{"instruction":"def tonum(count):\n    return (count - 1) \/\/ 3\n\ndef check(n, k, logdivl):\n    divl = 2**logdivl\n\n    min_k = 2**(logdivl+1) - 2 - logdivl\n\n    max_k = tonum(divl * divl + (divl * divl - (2*divl - 1)) * ((2**(n-logdivl))**2 - 1))\n\n    return min_k <= k <= max_k\n\ndef main(n, k):\n    if k == 1:\n        return n - 1\n\n    if n > 100:\n        return n - 1\n\n    if ((2 ** (n-1)) ** 2 - 1) \/\/ 3 + 1 >= k:\n        return n -1\n\n    for logdivl in range(1, n+1):\n        if check(n, k, logdivl):\n            return n - logdivl\n\n    return None\n\nt = int(input())\nfor i in range(t):\n    n, k  = list(map(int, input().split()))\n    ans = main(n, k)\n    if ans is not None:\n        print(\"YES {}\".format(ans))\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"n,k = map(int, input().strip().split(' '))\nlst = list(map(int, input().strip().split(' ')))\ns=sum(lst)\ns2=0\nm=0\nfor i in range(n-1):\n    s2+=lst[i]\n    s-=lst[i]\n    if (s2%k)+(s%k)>m:\n        m=(s2%k)+(s%k)\nprint(m)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n, MOD = map(int, input().split())\n    factorial = [1]\n    for i in range(2, n + 1):\n        factorial.append(factorial[-1] * i % MOD)\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    DP = []\n    for i in range(n):\n        DP.append([0] * n)\n    for i in range(n):\n        DP[i][0] = pow(2, i, MOD) * factorial[i]\n        for j in range(1, i \/\/ 2 + 1):\n            for k in range(0, i - 1):\n                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]\n            DP[i][j] %= MOD\n    ans = 0\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    for i in range(n):\n        ans += DP[n - 1][i] * factorial[n - i - 1]\n    print(ans % MOD)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n=int(input())\na=input()\nb=a.count('T')\nc=-1\nfor i in range(n):\n    d=0\n    for j in range(b):\n        d+=int(a[(i+j)%n]=='H')\n    if c==-1 or d<c:\n        c=d\nprint(c)","output":"linear"},{"instruction":"a = int(input())\nb = input()\ns = 0\nfor i in range(a-2):\n    if b[i:i+3] == 'xxx':\n        s = s + 1\nprint(s)","output":"linear"},{"instruction":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        maxArea = 0\n\n        for i in range(n):\n            height = heights[i]\n\n            rightMost = i + 1\n            while rightMost < n and heights[rightMost] >= height:\n                rightMost += 1\n\n            leftMost = i\n            while leftMost >= 0 and heights[leftMost] >= height:\n                leftMost -= 1\n\n            rightMost -= 1\n            leftMost += 1\n            maxArea = max(maxArea, height * (rightMost - leftMost + 1))\n        return maxArea","output":"quadratic"},{"instruction":"k = int(input())\ns = k\ni = 1\nnumber_digits = 1\nwhile s - (i * (9 * 10 ** (i - 1))) > 0:\n    number_digits = number_digits + 1\n    s = s - (i * (9 * 10 ** (i - 1)))\n    i += 1\nv = (s - 1) \/\/ number_digits\ns = s - v * number_digits\nans = 10 ** (number_digits - 1) + v\nans = str(ans)\nfans = ans[s - 1]\nprint(fans)","output":"logn"},{"instruction":"a0 = (1 << 30) - 1\n\na0 = 3\nb0 = 1\n\ndef mock_query(c, d):\n    res = (a0 ^ c) - (b0 ^ d)\n    if res > 0:\n        return 1\n    elif res < 0:\n        return -1\n    else:\n        return 0\n\ndef query2(c, d):\n    ans = mock_query(c, d)\n    print('? {:08b} {:08b} --> {}'.format(c, d, ans))\n    return ans\n\ndef query(c, d):\n    print('?', c, d)\n    return int(input())\n\ndef solve():\n    a = 0\n    b = 0\n    last_ans = query(0, 0)\n\n    pos = 29\n    while pos >= 0:\n        bit = 1 << pos\n\n        ans = query(a + bit, b + bit)\n        if (last_ans, ans) == (1, -1):\n            a += bit\n            last_ans = query(a, b)\n        elif (last_ans, ans) == (-1, 1):\n            b += bit\n            last_ans = query(a, b)\n\n        else:\n            last_ans = ans\n            ans = query(a + bit, b)\n            if ans == -1:\n                a += bit\n                b += bit\n\n        pos -= 1\n\n    print('!', a, b)\n\nsolve()","output":"constant"},{"instruction":"class edge(object):\n\tdef __init__(self,ne,to,fl):\n\t\tself.ne=ne\n\t\tself.to=to\n\t\tself.fl=fl\n\ndef add(x,y,z):\n\tglobal tot\n\ttot+=1\n\te.append(edge(he[x],y,z))\n\the[x]=tot\n\ndef addedge(x,y,z):\n\tadd(x,y,z)\n\tadd(y,x,0)\n\ndef bfs():\n\tglobal deep\n\tdeep=[0 for i in range(T+1)]\n\tq=[]\n\tq.append(S)\n\tdeep[S]=1\n\tlp=0\n\twhile (len(q)>lp):\n\t\tx=q[lp]\n\t\tlp+=1\n\t\ti=he[x]\n\t\twhile (i):\n\t\t\ty=e[i].to\n\t\t\tif ((deep[y]==0)and(e[i].fl!=0)):\n\t\t\t\tdeep[y]=deep[x]+1\n\t\t\t\tq.append(y)\n\t\t\ti=e[i].ne\n\treturn deep[T]!=0\n\ndef dfs(x,flow):\n\tglobal deep\n\tif ((x==T)or(flow==0)):\n\t\treturn flow\n\tused=0\n\ti=he[x]\n\twhile (i):\n\t\ty=e[i].to\n\t\tif ((deep[y]==deep[x]+1)and(e[i].fl!=0)):\n\t\t\tnow=dfs(y,min(flow-used,e[i].fl))\n\t\t\tused+=now\n\t\t\te[i].fl-=now\n\t\t\te[i^1].fl+=now\n\t\t\tif (flow==used):\n\t\t\t\tbreak;\n\t\ti=e[i].ne\n\tif (used==0):\n\t\tdeep[x]=-1\n\treturn used\n\ndef dinic():\n\tres=0\n\twhile (bfs()):\n\t\tres+=dfs(S,INF)\n\treturn res\n\nn,m=map(int,input().split())\nans=0\nweight=[0]+list(map(int,input().split()))\n\ne=[0,0]\ntot=1\nS=n+m+1\nT=S+1\nhe=[0 for i in range(T+1)]\nINF=1000000007\n\nfor i in range(1,n+1):\n\taddedge(S,i,weight[i]);\nfor i in range(1,m+1):\n\tx,y,w=map(int,input().split())\n\taddedge(n+i,T,w)\n\taddedge(x,n+i,INF)\n\taddedge(y,n+i,INF)\n\tans+=w\nans-=dinic()\nprint(ans)","output":"cubic"},{"instruction":"def prime(n):\n    j = 3\n    while j * j <= n:\n        if n % j == 0:\n            return False\n        j += 2\n    return True\nref = [2]\nfor j in range(3, 1000, 2):\n    if prime(j) == True:\n        ref.append(j)\ndef check(n):\n    for j in range(1, len(ref) - 1):\n        v = n - ref[j] - 1\n        if ref[j - 1] == v or ref[j + 1] == v:\n            return True\n        if j > n:\n            break\n    return False\narr = []\nfor j in range(3, 1001, 2):\n    if prime(j) == True and check(j) == True:\n        arr.append(j)\nn, k = [int(j) for j in input().split()]\ncount = 0\nfor j in range(2, n + 1):\n    if j in arr:\n        count += 1\nif count >= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"n = int(input())\n\na = list(map(lambda i: int(i), input().split(sep=' ')))\na.sort()\na_count = len(a)\n\nb = list(filter(lambda i: i > 0, a))\nb_count = len(b)\n\ndef resh():\n    idx = 1\n    while idx < a_count:\n        if a[idx] == a[idx - 1] and (a[idx] - 1) in a:\n            return 'cslnb'\n        idx += 1\n\n    b_sum = sum(b)\n    v_sum = sum(range(1, b_count if a_count == b_count else b_count + 1))\n    t = max(b_sum - v_sum, 0)\n    return 'cslnb' if t % 2 == 0 else 'sjfnb'\n\nif b_count == 0 or  b_count - len(set(b)) > 1 or a_count - b_count > 1:\n    print('cslnb')\nelse:\n    print(resh())","output":"nlogn"},{"instruction":"n = int(input())\nl = [input() for _ in range(n)]\nl.sort(key=lambda x: len(x))\n\nok = True\nfor i in range(n-1):\n  if l[i] not in l[i+1]:\n    ok = False\n    break\n\nif ok:\n  print(\"YES\")\n  print(*l, sep='\\n')\nelse:\n  print(\"NO\")","output":"nlogn"},{"instruction":"def main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        l = []; board = []\n        for i in range(n):\n            li = list(map(int, input().split()))\n            board.append(li)\n            for j in range(m):\n                l.append((li[j], j))\n        l.sort(key = lambda x : x[0], reverse = True)\n        idxs = set()\n        z = 0\n        while len(idxs) < min(n, m):\n            curr = l[z]\n            idxs.add(curr[1])\n            z += 1\n        idxs = list(idxs)\n        total = 0\n        for i in range(n ** n):\n            rotations = []; num = i\n            for j in range(n - 1, -1, -1):\n                nj = n ** j\n                q = num \/\/ nj\n                num -= q * nj\n                rotations.append(q)\n            subtotal = 0\n\n            for k in range(n):\n\n                subtotal += max(board[(k + rotations[col]) % n][idxs[col]] for col in range(min(n, m)))\n            total = max(total, subtotal)\n        print(total)\nmain()","output":"np"},{"instruction":"import sys\n\ninput=sys.stdin.readline\n\nn=int(input())\n\nc=list(map(int,input().split()))\nans=0\n\nfor i in range(n):\n\n    f=c.pop(0)\n    g=c.index(f)\n    c.pop(g)\n    ans+=g\n\nprint(ans)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m,k=map(int,input().split())\ny_axis=[list(map(int,input().split())) for i in range(n)]\nx_axis=[list(map(int,input().split())) for i in range(n-1)]\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=\" \")\n        print()\nelse:\n    inf=10**9\n    dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if(i>0):\n                if(i<n-1):\n                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j])\n                else:\n                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j])\n            else:\n                dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j])\n            if(j>0):\n                if(j<m-1):\n                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i][j-1])\n                else:\n                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j-1])\n            else:\n                dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j])\n    for z in range(4,k+1,2):\n        for i in range(n):\n            for j in range(m):\n                if(i>0):\n                    if(i<n-1):\n                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j],dp[i+1][j][z-2]+2*x_axis[i][j])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j])\n                else:\n                    dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-2]+2*x_axis[i][j])\n                if(j>0):\n                    if(j<m-1):\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1],dp[i][j+1][z-2]+2*y_axis[i][j])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1])\n                else:\n                    dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*y_axis[i][j])\n    for i in range(n):\n        for j in range(m):\n            if(dp[i][j][k]==inf):\n                print(-1,end=\" \")\n            else:\n                print(dp[i][j][k],end=\" \")\n        print()","output":"cubic"},{"instruction":"from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\ndef flush():\n    return sys.stdout.flush()\n\ndef fac(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans*=i\n        ans%=MOD\n    return ans\n\nn = int(input())\na = arrIN()\na.sort()\nf = [1]*n\ncnt = 0\nfor i in range(n):\n    if f[i]:\n        cnt+=1\n        for j in range(i,n):\n            if f[j] and a[j]%a[i]==0:\n                f[j] = 0\n        f[i] = 0\nprint(cnt)","output":"quadratic"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=99999999999999999999999999999999\n\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        n=ri()\n        s=ria()\n        c=ria()\n        ans=INF\n        for i in range(n):\n            mid=s[i]\n            mcl=INF\n            mrl=INF\n            for j in range(i-1,-1,-1):\n                if s[j]<mid:\n                    mcl=min(mcl,c[j])\n            for j in range(i+1,n):\n                if s[j]>mid:\n                    mrl=min(mrl,c[j])\n            ans=min(ans,c[i]+mcl+mrl)\n        if ans==INF:\n            wi(-1)\n        else:\n            wi(ans)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"quadratic"},{"instruction":"import sys\n\nfrom bisect import bisect_left as lb\nfrom collections import deque\n\nfrom queue import PriorityQueue as pq\nfrom math import *\ninput_ = lambda: sys.stdin.readline().strip(\"\\r\\n\")\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab,bc,cd : ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x : print(x)\nprinT = lambda x : print(x)\nf = lambda : sys.stdout.flush()\ninv =lambda x:pow(x,mod-2,mod)\nmod = 10**9 + 7\n\nfor _ in range (1) :\n    n = ii()\n\n    x = 1\n    i = 0\n\n    while (x <= n) :\n        x += (9*(i+1)*(10**i))\n        i += 1\n\n    x -= 9*i*(10**(i-1))\n\n    y = str(10**(i-1) + (n-x)\/\/i)\n\n    print(y[(n-x)%i])","output":"logn"},{"instruction":"n=int(input())\na,b=map(int,input().split())\nb1,b2=map(int,input().split())\nc1,c2=map(int,input().split())\nb1-=a\nb2-=b\nc1-=a\nc2-=b\nif b1==0 or b2==0 or c1==0 or c2==0:print('NO')\nelse:\n    if b1*c1<0 or b2*c2<=0:print('NO')\n    else:print('YES')","output":"constant"},{"instruction":"import math\n\ntypes_of_toy , toy_pair = map(int,input().split())\n\nif(toy_pair <= types_of_toy ):\n    print(math.floor( ( toy_pair - 1 ) \/2))\nelif( toy_pair <= 2*types_of_toy - 1):\n    print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )\/ 2))\nelse:\n    print(0)","output":"constant"},{"instruction":"n = int(input())\ns = list(input())\nd = list(input())\nif(sorted(s) != sorted(d)):\n    print(-1)\nelse:\n    ans = []\n    for i in range(n):\n        if(s[i] != d[i]):\n            for u in range(i+1,n):\n                if(s[u] == d[i]):\n                    ind = u\n                    break\n\n            cnt = abs(ind - i)\n            s.pop(ind)\n            s.insert(i,d[i])\n\n            for k in range(cnt):\n                if(ind > 0):\n                    ans.append(ind)\n                else:\n                    ans.append(1)\n                ind -= 1\n    print(len(ans))\n    print(*ans)","output":"quadratic"},{"instruction":"R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr.sort()\ng.sort()\nb.sort()\n\ndp = [[[0]*202 for i in range(202)] for j in range(202)]\nfor i in range(R+1):\n       for j in range(G+1):\n              for k in range(B+1):\n                     if i and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n                     if i and k:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n                     if k and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\nprint(dp[R][G][B])","output":"cubic"},{"instruction":"from sys import stdin, stdout\nimport gc\ngc.disable()\ninput = stdin.readline\nfrom collections import defaultdict\n\ndef check(num):\n\tbitmask = set()\n\tfor i in range(n):\n\t\tb = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= num:\n\t\t\t\tb ^= 1 << j\n\t\tbitmask.add(b)\n\n\ttarget = 2** m  - 1\n\tfor i in bitmask:\n\t\tfor j in bitmask:\n\t\t\tif i | j ==  target:\n\t\t\t\treturn True\n\treturn False\n\nn, m = list(map(int, input().split()))\narr = []\nfor _ in range(n):\n\tarr.append(list(map(int, input().split())))\n\nstart = 0\nend = 10 ** 9\nans = -1\nwhile start <= end:\n\tmid = (start + end) \/\/ 2\n\tif check(mid):\n\t\tans = mid\n\t\tstart = mid + 1\n\telse:\n\t\tend = mid - 1\n\nbitmask = defaultdict(list)\nfor i in range(n):\n\tb = 0\n\tfor j in range(m):\n\t\tif arr[i][j] >= ans:\n\t\t\tb  += 1<< j\n\tbitmask[b].append(i + 1)\ntarget = 2 ** m - 1\nfor i in bitmask:\n\tfor j in bitmask:\n\t\tif i | j == target:\n\t\t\tprint(bitmask[i][0], bitmask[j][0])\n\t\t\texit()","output":"np"},{"instruction":"def d(n):\n    ret = 0\n    n = list(str(n))\n    for i in range(len(n)):\n        ret += int(n[i])\n    return ret\n\ndef main():\n    n, s = map(int, input().split())\n\n    l, h = 0, n\n    for i in range(2000):\n\n        m = (l + h) \/\/ 2\n        if m - d(m) >= s:\n            h = m\n        else:\n            l = m\n\n    for i in range(-100, 100):\n        t = m + i\n\n        if t < 0 or t > n:\n            continue\n        if abs(t - d(t)) >= s:\n            print(n - t + 1)\n            exit()\n    print(0)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")","output":"logn"},{"instruction":"from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nr, g, b = rints()\nar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]\nmem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]\nans = 0\n\nfor r1 in range(r + 1):\n    for g1 in range(g + 1):\n        for b1 in range(b + 1):\n            if r1 < r:\n                if g1 < g:\n                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])\n                if b1 < b:\n                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])\n\n            if g1 < g and b1 < b:\n                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])\n\n            ans = max(ans, mem[r1][g1][b1])\n\nprint(ans)","output":"cubic"},{"instruction":"import sys\n\nn=int(input())\nA=list(map(int,input().split()))\n\nif sum(A)<2*n-2:\n    print(\"NO\")\n    sys.exit()\n\nONES=A.count(1)\nprint(\"YES\",min(n-1,n-ONES+1))\n\nNOONE=[]\nfor i in range(n):\n    if A[i]!=1:\n        NOONE.append([A[i],i+1])\n\nANS=[]\nfor i in range(1,len(NOONE)):\n    ANS.append((NOONE[i-1][1],NOONE[i][1]))\n    NOONE[i-1][0]-=1\n    NOONE[i][0]-=1\n\nNOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]]\n\nLENNO=len(NOONE)\n\nj=0\nfor i in range(n):\n    while j<LENNO and NOONE[j][0]==0:\n        j+=1\n    if A[i]!=1:\n        continue\n    ANS.append((i+1,NOONE[j][1]))\n    NOONE[j][0]-=1\n\nprint(len(ANS))\nfor a,b in ANS:\n    print(a,b)","output":"linear"},{"instruction":"import sys\ndef read():\n    return int(input())\ndef reads():\n    return [int(x) for x in input().split()]\nN,M=reads()\ntable=[reads() for i in range(N)]\nA=[[0]*N for i in range(N)]\nB=[[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        res=10**9+7\n        for k in range(M):\n            res=min(res,abs(table[i][k]-table[j][k]))\n        A[i][j]=res\n        A[j][i]=res\n        res=10**9+7\n        for k in range(M-1):\n            res=min(res,abs(table[i][k]-table[j][k+1]))\n        B[i][j]=res\n\ndp=[[-1]*N for i in range((1<<N) )]\ndef calc(mask,v):\n    if dp[mask][v]!=-1:\n        return dp[mask][v]\n    res =0\n    for u in range(N):\n        if (mask & 1<<u) and u!=v:\n            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))\n    dp[mask][v]=res\n    return dp[mask][v]\nans=0\nfor i in range(N):\n    dp = [[-1] * N for _ in range((1 << N))]\n    for k in range(N):\n        if k==i:\n            dp[1<<k][k]=10**9+7\n        else:\n            dp[1<<k][k]=0\n    for j in range(N):\n        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))\nprint(ans)","output":"np"},{"instruction":"n = int(input())\nm = int(input())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\nlow = 1\nhigh = 1000000000\nans = -1\n\nwhile low<=high:\n\tif high-low < 0.000001: low = high\n\tmid = low+(high-low)\/2\n\ttry_val = mid\n\tinit_wt = m+try_val\n\tisPossible = True\n\tfor i in range(n):\n\t\treq1 = init_wt\/a[i]\n\t\ttry_val -= req1\n\t\tif try_val<=0:\n\t\t\tisPossible = False\n\t\t\tbreak\n\t\tj=(i+1)%n\n\t\tinit_wt -= req1\n\t\treq2 = init_wt\/b[j]\n\t\ttry_val -= req2\n\t\tif try_val<0 or (i<n-1 and try_val==0):\n\t\t\tisPossible = False\n\t\t\tbreak\n\t\tinit_wt -= req2\n\tif isPossible:\n\t\tans = mid\n\t\thigh = mid-0.000001\n\telse: low = mid+0.000001\n\nif (ans==-1):\n\tisPossible = True\n\ttry_val = 1000000000.000001\n\tinit_wt = m+try_val\n\tfor i in range(n):\n\t\treq1 = init_wt\/(a[i])\n\t\ttry_val -= req1\n\t\tif try_val<=0:\n\n\t\t\tisPossible = False\n\t\t\tbreak\n\t\tj=(i+1)%n\n\t\tinit_wt -= req1\n\t\treq2 = init_wt\/(b[j])\n\t\ttry_val -= req2\n\t\tif try_val<0 or (i<n-1 and try_val==0):\n\t\t\tisPossible = False\n\t\t\tbreak\n\t\tinit_wt -= req2\n\tif isPossible: ans = 1000000000\nprint(ans)","output":"linear"},{"instruction":"import sys\nimport logging\nlogging.root.setLevel(level=logging.DEBUG)\nimport re\n\ns = sys.stdin.readline().strip()\n\nfrom collections import defaultdict\nsubstr = defaultdict(int)\nfor left in range(len(s)):\n    for right in range(left+1,len(s)+1):\n        substr[s[left:right]] += 1\nmax_len = 0\nfor segment,times in substr.items():\n    if times >= 2:\n        max_len = max(max_len,len(segment))\nprint(max_len)","output":"cubic"},{"instruction":"n,k=map(int,input().split())\nprint((-(-n*2\/\/k))+(-(-n*5\/\/k))+(-(-n*8\/\/k)))","output":"constant"},{"instruction":"q = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l % 2 == 0:\n        count = -((r - l + 1) \/\/ 2)\n    else:\n        count = ((r - l + 1) \/\/ 2)\n    if (r - l + 1) % 2 == 0:\n        print(count)\n    else:\n        if r % 2 == 0:\n            print(count + r)\n        else:\n            print(count - r)","output":"constant"},{"instruction":"from sys import stdin, stdout, setrecursionlimit\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nsetrecursionlimit(100000)\nmod = 1000000007\n\nR, G, B = iia()\nr, g, b = sorted(iia()), sorted(iia()), sorted(iia())\ndp = [[[0 for i in range(B + 1)] \\\n    for j in range(G + 1)] for k in range(R + 1)]\n\nfor i in range(R + 1):\n    for j in range(G + 1):\n        for k in range(B + 1):\n            if i > 0 and j > 0:\n                dp[i][j][k] = max(dp[i][j][k], \\\n                    dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            if i > 0 and k > 0:\n                dp[i][j][k] = max(dp[i][j][k], \\\n                    dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])\n            if j > 0 and k > 0:\n                dp[i][j][k] = max(dp[i][j][k], \\\n                    dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])\nprint(dp[-1][-1][-1])","output":"cubic"},{"instruction":"import sys\nm,n=map(int,sys.stdin.readline().split())\nres=m^n\ns=bin(res)\ns=s[2:]\ns=int(s)\nif(s==0):\n    print(0)\nelse:\n    s=str(s)\n    res=(2**len(s))-1\n    print(res)","output":"logn"},{"instruction":"x, n = map(int, input().split())\nMOD = 10**9 + 7\nc = 4*x\nif c == 0:\n    ans = 0\nelif n == 0:\n    ans = 2 * x\nelse:\n    ans = (((c - 2) * pow(2, n -1, MOD) + 1) + MOD) % MOD\nprint(ans % MOD)","output":"logn"},{"instruction":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        n, res = len(nums), nums[0]\n        for i in range(n):\n            cur = 0\n            for j in range(i, n):\n                cur += nums[j]\n                res = max(res, cur)\n        return res","output":"quadratic"},{"instruction":"MAX = 1000\nf = [0]\nfor i in range(1, MAX):\n    f.append(f[i - 1] + (1 << (2 * i - 2)))\n\ng = [0]\nfor i in range(1, MAX):\n    g.append(g[i - 1] + (1 << i) - 1)\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split(' '))\n    ans = False\n    for i in range(1, n + 1):\n        if k >= g[i]:\n            if n >= MAX:\n                print(\"YES %d\" % (n - i))\n                ans = True\n            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:\n                print(\"YES %d\" % (n - i))\n                ans = True\n        if ans == True:\n            break\n    if ans == False:\n        print(\"NO\")","output":"logn"},{"instruction":"def ask(a, b):\n    print(\"?\", a, b, flush=True)\n    return int(input()) <= 0\n\ndef solve(M):\n    a, b = 0, 0\n    less = ask(0, 0)\n\n    for i in range(M - 1, -1, -1):\n        bit = 1 << i\n\n        if less:\n            if not ask(a | bit, b | bit):\n                b |= bit\n                less = ask(a, b)\n            elif ask(a | bit, b):\n                a |= bit\n                b |= bit\n        else:\n            if ask(a | bit, b | bit):\n                a |= bit\n                less = ask(a, b)\n            elif ask(a | bit, b):\n                a |= bit\n                b |= bit\n\n    print(\"!\", a, b, flush=True)\n\nif __name__ == '__main__':\n    solve(30)","output":"logn"},{"instruction":"import sys\nimport copy\nlines = iter(sys.stdin)\n\ndef nexts():\n    return next(lines)\n\ndef nextint():\n    return int(nexts())\n\ndef snexts():\n    return next(lines).split(' ')\n\ndef snextint():\n    return map(int, snexts())\n\ndef array(length, base=0):\n    return [base] * length\n\ndef matrix(length, width, base=0):\n    return [[base] * width for _ in range(length)]\n\nn, m = snextint()\ngrid = array(n, [])\n\nfor i in range(n):\n    grid[i] = list(nexts())\n\ngrid2 = copy.deepcopy(grid)\n\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n\n        if grid[i - 1][j] == '\n            grid2[i - 1][j] = '.'\n            grid2[i - 1][j + 1] = '.'\n            grid2[i][j + 1] = '.'\n            grid2[i + 1][j + 1] = '.'\n            grid2[i + 1][j] = '.'\n            grid2[i + 1][j - 1] = '.'\n            grid2[i][j - 1] = '.'\n            grid2[i - 1][j - 1] = '.'\n\nmatch = True\nfor i in grid2:\n    for ch in i:\n        if ch == '\n            match = False\n            break\n\nif match:\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef topological_sorted(digraph):\n    n = len(digraph)\n    indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] += 1\n\n    tp_order = [i for i in range(n) if indegree[i] == 0]\n    stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:\n                stack.append(nxt_v)\n                tp_order.append(nxt_v)\n\n    return len(tp_order) == n, tp_order\n\nn, m, k = map(int, input().split())\np = [input()[:-1] for i in range(n)]\ns = [list(input().split()) for i in range(m)]\n\nmemo = {}\nfor idx, ptn in enumerate(p):\n    val = 0\n    for i in range(k):\n        if ptn[i] == \"_\":\n            continue\n        val += (ord(ptn[i]) - 96) * (27 ** i)\n    memo[val] = idx\n\nfor i, (string, idx) in enumerate(s):\n    s[i] = tuple(map(ord, string)), int(idx)\n\ngraph = [[] for i in range(n)]\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:\n        print(\"NO\")\n        exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:\n    print(\"YES\")\n    print(*[i + 1 for i in res])\nelse:\n    print(\"NO\")","output":"np"},{"instruction":"n,u=map(int,input().split())\narr=list(map(int,input().split()))\n\nj,i=1,0\nmaxi=-1\nflag=0\nfor i in range(n-1):\n\tif arr[i+1]-arr[i]<=u:\n\t\tflag=1\nif flag==0:\n\tprint(\"-1\")\n\texit()\ni=0\nwhile(i<n-2):\n\twhile(1):\n\t\tif j>=n:\n\t\t\tj=n-1\n\t\t\tbreak\n\t\tif arr[j]-arr[i]>u:\n\t\t\tj-=1\n\t\t\tbreak\n\t\tj+=1\n\tif i==j:\n\t\tj+=1\n\telif arr[j]==arr[i]:\n\t\tpass\n\telif arr[j]-arr[i]<=u:\n\n\t\tmaxi=max(maxi,(arr[j]-arr[i+1])\/(arr[j]-arr[i]))\n\ti+=1\nif maxi==0:\n\tprint(\"-1\")\nelse:\n\tprint(maxi)","output":"nlogn"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        dp = [0] * n\n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i):\n                if intervals[j][1] <= intervals[i][0]:\n                    dp[i] = max(dp[i], 1 + dp[j])\n\n        max_non_overlapping = max(dp)\n        return n - max_non_overlapping","output":"quadratic"},{"instruction":"if input()=='1':\n print(input())\nelse:\n x,*a,y=sorted(map(int,input().split()))\n print(y-x+sum(map(abs,a)))","output":"nlogn"},{"instruction":"from math import pow\ndef modularExponentiation(x,n,M):\n\n    if n==0:\n        return 1\n    elif n%2 == 0:\n        return modularExponentiation((x*x)%M,n\/\/2,M)\n    else:\n        return (x%M*modularExponentiation((x*x)%M,(n-1)\/\/2,M)%M)%M\n\nc=10**9+7\nn,k=map(int,input().split())\na=(n%c*(modularExponentiation(2,k+1,c))%c)%c\nb=(modularExponentiation(2,k,c)%c-1%c+c)%c\nif n==0:\n    print(\"0\")\nelse:\n    print((a%c-b%c+c)%c)","output":"logn"},{"instruction":"n, k = map(int , input().split())\ns = k \/\/ n\nif k % n != 0:\n    s += 1\nprint(s)","output":"constant"},{"instruction":"inf=10**9\n\nn=int(input())\nt=[0]*n\nm={}\nfor j in range(n):\n\n    s=input()\n\n    bal=0\n    req=0\n\n    for i in s:\n        if i==\")\":\n            bal-=1\n        else:\n            if bal<0:\n                req+=bal\n                bal=1\n            else:\n                bal+=1\n\n    if req<0:\n        if bal>0:\n            req=inf\n        else:\n            req+=bal\n    else:\n        req=bal\n\n    t[j]=req\n\n    if req not in m:\n        m[req]=1\n    else:\n        m[req]+=1\n\nres=0\n\nfor i in t:\n    if i>=0:\n        if -i in m:\n            res+=m[-i]\n\nprint(res)","output":"linear"},{"instruction":"n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(1,(2**n)+1):\n    j = bin(i)\n    j = j[2:]\n    if len(j)<n:\n        j = '0'*(n-len(j))+j\n\n    c = 0\n    temp = []\n    for k in j:\n        if k=='1':\n            temp.append(a[c])\n        c+=1\n    s = sum(temp)\n\n    if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x:\n        ans+=1\n\nprint(ans)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\nimport heapq\n\nR, G, B = map(int, input().split())\nr = [int(item) for item in input().split()]\ng = [int(item) for item in input().split()]\nb = [int(item) for item in input().split()]\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\nnr = len(r)\nng = len(g)\nnb = len(b)\n\ndp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]\nans = 0\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if (i + j + k) % 2 == 1:\n                continue\n            if i > 0 and j > 0:\n\n                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])\n            if j > 0 and k > 0:\n\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])\n            if i > 0 and k > 0:\n\n                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])\n            ans = max(ans, dp[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"import bisect\nfrom collections import defaultdict,Counter\nimport math\n\ndef solve(a):\n    count=0\n    mp=Counter(a)\n    for i in range(len(a)):\n        flag=0\n        for j in range(31):\n            x=int(1<<j)-a[i]\n            if (x in mp) and (x==a[i] and mp[x]>1):\n\n                flag=1\n                break\n            elif (x in mp) and (x!=a[i] and mp[x]>0):\n                flag=1\n                break\n        if flag==0:\n            count+=1\n\n    return count\n\nn=int(input(''))\na=list(map(int,input('').split()))\nprint(solve(a))","output":"nlogn"},{"instruction":"k = int(input())\n\nfor i in range(20):\n    if k > 10**i * 9 * (i+1):\n        k -= 10**i * 9 * (i+1)\n    else:\n        a, b = (k-1) \/\/ (i+1) + 10**i, (k-1) % (i+1)\n        print(str(a)[b])\n        break","output":"logn"},{"instruction":"l,r = [int(i) for i in input().split()]\nbitafter=-1;\nfor i in range(60,-1,-1):\n    if(l&(1<<i)!=r&(1<<i)):\n        bitafter = i\n        break\nres = 0\nwhile(bitafter>=0):\n    res+=1<<bitafter\n    bitafter-=1\nprint(res)","output":"logn"},{"instruction":"import sys\nimport math\nimport collections\nimport operator as op\nfrom collections import deque\nfrom math import gcd, inf, sqrt, pi, cos, sin, ceil, log2, floor, log\nfrom bisect import bisect_right, bisect_left, bisect\n\nfrom functools import reduce\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(2**20)\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer \/\/ denom\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n \/\/= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return (list(factors))\n\ndef isPowerOfTwo(x):\n    return (x and (not(x & (x - 1))))\n\nMOD = 1000000007\nPMOD = 998244353\nN = 10**18 + 1\nLOGN = 30\nalp = 'abcdefghijklmnopqrstuvwxyz'\nT = 1\n\nfor _ in range(T):\n    n, k = list(map(int, stdin.readline().rstrip().split()))\n\n    det = (int(sqrt(9 + 8 * (n + k)) - 3)) \/\/ 2\n    print(n - det)","output":"logn"},{"instruction":"import math\n\nv = [int(x) for x in input().split()]\nn = len(v)\nval = 0\nfor i in range(n):\n    a = v[i] \/\/ n\n    arr = v.copy()\n    arr[i] = 0\n    for j in range(n):\n        arr[j] += a\n    b = v[i] % n\n    k = i + 1\n    l = 0\n    while l < b:\n        if k > n - 1:\n            k = 0\n        arr[k] += 1\n        k += 1\n        l += 1\n\n    count = 0\n    for j in range(n):\n        if arr[j] % 2 == 0:\n            count += arr[j]\n    val = max(val, count)\nprint(val)","output":"constant"},{"instruction":"n = int(input())\n\ndp = [0] * 1000007\n\nmajak = [0] * 1000007\n\nq = 1000007\n\np = 0\n\nfor i in range(n):\n\n    a, b = map(int, input().split())\n\n    q = min(q, a)\n\n    majak[a] = b\n\ndp[q] = 1\n\nma = 1\n\nfor i in range(q + 1, 1000003, 1):\n\n    if(majak[i] == 0):\n\n        dp[i] = dp[i - 1]\n\n    else:\n\n        dp[i] = dp[i - majak[i] - 1] + 1\n\n        ma = max(ma, dp[i])\n\nprint(n - ma)","output":"linear"},{"instruction":"n, k = map(int, input().split())\nl, r = -1, k+1\nwhile l+1 < r:\n\tmid = l + r >> 1\n\tval = (k - mid + 1 + k) * mid \/\/ 2 - (mid - 1)\n\tif val < n:\n\t\tl = mid\n\telse:\n\t\tr = mid\nprint(-1 if r == k+1 else r)","output":"logn"},{"instruction":"import sys\n\nif __name__ == '__main__':\n    cin = sys.stdin\n\n    n = int(next(cin))\n    ax, ay = map(int, next(cin).split())\n    bx, by = map(int, next(cin).split())\n    cx, cy = map(int, next(cin).split())\n\n    if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:\n        print('YES')\n    else:\n        print('NO')","output":"constant"},{"instruction":"n=int(input())\nprint(2*(n*(n-1))+1)","output":"constant"},{"instruction":"from sys import stdin\nfrom itertools import combinations\nn, l, r , x = map(int, stdin.readline().rstrip().split(\" \"))\nli = list(map(int, stdin.readline().rstrip().split(\" \")))\nz = []\nans = 0\nfor i in range(2, n+1):\n    z += list(combinations(li, i))\n\nfor i in z:\n    a = sorted(i)\n    if a[-1]-a[0]>=x and r >= sum(a) >= l:\n        ans+=1\n\nprint(ans)","output":"np"},{"instruction":"import math\n\nn, m, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\npart_sum = [0]\nfor i in range(n):\n\tpart_sum.append(part_sum[-1] + arr[i])\n\npart_sum_add = [[] for _ in range(m)]\nmin_in_part_sum_add = [[] for _ in range(m)]\nfor shift in range(m):\n\tcount_blocks = math.ceil((n - shift) \/ m + 1)\n\tfor i in range(n + 1):\n\t\tcur_part_sum = part_sum[i] + k * (count_blocks - ((i - shift) \/\/ m))\n\t\tif i == 0 or cur_part_sum < prev_min_in_part_sum_add:\n\t\t\tcur_min_in_part_sum_add = cur_part_sum\n\t\telse:\n\t\t\tcur_min_in_part_sum_add = prev_min_in_part_sum_add\n\n\t\tpart_sum_add[shift].append(cur_part_sum)\n\t\tmin_in_part_sum_add[shift].append(cur_min_in_part_sum_add)\n\t\tprev_min_in_part_sum_add = cur_min_in_part_sum_add\n\nmax_result = 0\nfor i in range(1, n + 1):\n\tcurrent_shift = i % m\n\tcurrent_min = min_in_part_sum_add[current_shift][i]\n\tcurrent_ans = part_sum_add[current_shift][i] - current_min\n\n\tif current_ans > max_result:\n\t\tmax_result = current_ans\n\nprint(max_result)","output":"quadratic"},{"instruction":"def solve(n, m, x, t):\n    r = [0] * n\n    d = [0] * m\n    ans = [0] * m\n    cr = 0\n    cd = 0\n    for i in range(n+m):\n        if t[i]:\n            d[cd] = x[i]\n            cd += 1\n        else:\n            r[cr] = x[i]\n            cr += 1\n    cn = 0\n    for i in range(m-1):\n        mid = (d[i] + d[i+1]) \/\/ 2\n        while cn < n and r[cn] <= mid:\n            cn += 1\n            ans[i] += 1\n    ans[-1] += n - sum(ans)\n    return ' '.join(str(i) for i in ans)\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    x = [int(i) for i in input().split()]\n    t = [int(i) for i in input().split()]\n    print(solve(n, m, x, t))\n\nmain()","output":"linear"},{"instruction":"import sys\n\ndef chain_reaction(n, beacons):\n    table = [0] * n\n\n    for i in range(n):\n        position = beacons[i][0]\n        power = beacons[i][1]\n        destroyed = 0\n        r = position - power\n        b = 0\n\n        lo = 0\n        hi = len(beacons) - 1\n        while lo <= hi:\n            mid = int(lo + (hi - lo) \/ 2)\n            pos = beacons[mid][0]\n            if beacons[mid][0] < r:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n\n        destroyed += table[hi]\n\n        destroyed += (i - (hi + 1))\n        table[i] = destroyed\n\n    max_val = max(table)\n    ind = 0\n    while ind < len(table):\n        if table[ind] == max_val:\n            break\n        ind += 1\n    cost = (len(table) - ind) + table[ind - 1]\n\n    options = []\n    for i in range(n):\n        cost = (n - i) + table[i - 1]\n        options.append(cost)\n    min_cost = min(options)\n\n    return min(table[n - 1], min_cost)\n\nn = int(sys.stdin.readline().strip())\nbeacons = []\nfor i in range(n):\n    a, b = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    beacons.append((a, b))\nbeacons.sort()\nprint(chain_reaction(n, beacons))","output":"linear"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nget_bit = lambda x, i: (x >> i) & 1\n\nn = int(input())\na, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1\n\nif n == 1:\n    exit(print(1))\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        masks[big ^ (1 << j)] += a[i][j]\n        masks[big ^ (1 << i)] += a[j][i]\n\nfor _ in range(2, n):\n    tem = dict()\n    for msk in masks:\n        for bit in range(18):\n            if get_bit(msk, bit):\n                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]\n    masks = tem\n\nsu = sum(masks.values())\nprint(*[masks[2 ** i] \/ su for i in range(n)])","output":"np"},{"instruction":"from sys import exit\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\n    exit(0)\nx = 2 * x - 1\nmod = 10**9 + 7\n\ndef pot(r, k):\n    if k == 0: return 1\n    if k % 2 == 1:\n        return r * pot(r, k - 1) % mod\n    y = pot(r, k \/\/ 2)\n    return y * y % mod\n\nprint((pot(2, k) * x + 1) % mod)","output":"logn"},{"instruction":"n=int(input())\narr=[int(x) for x in input().split()]\nli=arr[:]\nli.sort()\nc=0\nfor i in range(n):\n    if(arr[i]!=li[i]):\n        c+=1\n    if(c>2):\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"n,k=input().split()\nn=int(n)\nk=int(k)\n\nm = 1000000007\n\nz = pow(2,k,m)\n\nans = (((2*z)*(n%m))%m - (z-1))%m\nif n==0:\n\tprint(0)\nelse:\n\tprint(ans)","output":"logn"},{"instruction":"def gcd(a, b):\n    if a > b:\n        a, b = b, a\n    if b % a==0:\n        return a\n    return gcd(b % a, a)\n\ndef line(a, b):\n    x0, y0 = a\n    x1, y1 = b\n    if x0==x1:\n        return [True, x1, None]\n    else:\n        slope_num = (y1-y0)\n        slope_den = (x1-x0)\n        if slope_num==0:\n            num = 0\n            den = 1\n        else:\n            g = gcd(abs(slope_num), abs(slope_den))\n            num = slope_num\/\/g\n            den = slope_den\/\/g\n        inter = den*y0-num*x0\n        if inter==0:\n            den2 = 1\n        else:\n            den2 = den\n        return [False, num, den, inter, den2]\n\ndef online(line, a):\n    x0, y0 = a\n    if line[0]:\n        return x0==line[1]\n    else:\n        C, num, den, inter, den2 = line\n\n        return (num*x0+inter)==y0*den\n\ndef process(A):\n    n = len(A)\n    if n <= 3:\n        return 'YES'\n    l1 = line(A[0], A[1])\n    l2 = line(A[1], A[2])\n    l3 = line(A[0], A[2])\n    for Line1 in [l1, l2, l3]:\n        other = []\n        for x in A:\n            if not online(Line1, x):\n                other.append(x)\n        if len(other) <= 2:\n\n            return 'YES'\n        a1 = other[0]\n        a2 = other[1]\n        Line2 = line(a1, a2)\n        works = True\n        for x in other:\n            if not online(Line2, x):\n                works = False\n                break\n        if works:\n\n            return 'YES'\n    return 'NO'\n\nn = int(input())\nA = []\nfor i in range(n):\n    x, y = [int(x) for x in input().split()]\n    A.append([x, y])\nprint(process(A))","output":"nlogn"},{"instruction":"def Sort(x):\n\tif len(x) == 1:\n\t\treturn x\n\n\ta = Sort(x[:len(x) \/\/ 2])\n\tb = Sort(x[len(x) \/\/ 2:])\n\n\tc = []\n\ti = 0\n\tj = 0\n\twhile (i < len(a))and(j < len(b)):\n\t\tif a[i] < b[j]:\n\t\t\tc.append(a[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\tc.append(b[j])\n\t\t\tj += 1\n\n\tc = c + b[j:]\n\tc = c + a[i:]\n\n\treturn c\n\ninput()\nm = [int(i) for i in input().split(' ')]\n\nnewm = Sort(m)\ncount = 0\nfor i in range(len(m)):\n if newm[i] != m[i]:\n  count += 1\n\nif count \/ 2 <= 1:\n print('YES')\nelse:\n print('NO')","output":"nlogn"},{"instruction":"from sys import *\nmod=1000000007\nn,q=map(int,stdin.readline().split())\ns=str(stdin.readline())\narr=[]\ncount=0\nfor i in s:\n\tif(i=='1'):\n\t\tcount+=1\n\tarr.append(count)\n\nansarr=[]\nfor i in range(q):\n\tx,y=map(int,input().split())\n\tif(x==1):\n\t\ttotal1=arr[y-1]\n\telse:\n\t\ttotal1=arr[y-1]-arr[x-2]\n\ttotal0=(y-x+1-total1)\n\tans=pow(2,y-x+1,mod)%mod\n\tans=((((ans%mod)-(pow(2,total0,mod)%mod))%mod)+mod)%mod\n\tansarr.append(ans)\nstdout.write('\\n'.join(map(str, ansarr)))","output":"linear"},{"instruction":"import sys\nimport math\n\nn, k = list(map(int, sys.stdin.readline().strip().split()))\na = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) \/\/ 2\nprint(int(a))","output":"constant"},{"instruction":"from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(start,graph,explored):\n    queue = deque([start])\n    visited = {start}\n    ele = 0\n    while queue:\n        node = queue.popleft()\n        explored.add(node)\n        neighbours = graph[node]\n        cnt = 0\n        for neighbour in neighbours:\n            if neighbour not in visited and neighbour not in explored:\n                cnt += 1\n\n        if e[0] == 0 and cnt != 1:\n            ele = node\n            break\n\n        else:\n            for neighbour in neighbours:\n                if neighbour not in visited:\n                    queue.append(neighbour)\n                    visited.add(neighbour)\n\n    return ele\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n@bootstrap\ndef solve(i):\n    cnt = 0\n    visited.add(i)\n    for k in graph[i]:\n        if k not in visited:\n            cnt += 1\n\n    if cnt >= 1:\n        for k in graph[i]:\n            if k not in visited:\n                yield solve(k)\n                break\n\n    else:\n        r[0] = i\n\n    yield\n\nn = int(input())\ngraph = {}\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    if a in graph:\n        graph[a].append(b)\n\n    else:\n        graph[a] = [b]\n\n    if b in graph:\n        graph[b].append(a)\n\n    else:\n        graph[b] = [a]\n\nroots = []\nvisited = set()\nele = 0\ne = [ele]\nfor i in graph:\n    if len(graph[i]) == 1:\n        roots.append(i)\n\nx = roots[0]\nans = []\nele = bfs(x,graph,visited)\nans.append((str(x),str(ele)))\n\nfor i in graph[ele]:\n    r = [0]\n    if i not in visited:\n        y = solve(i)\n        ans.append([str(r[0]),str(ele)])\n\nif len(visited) == n:\n    sys.stdout.write(\"Yes\\n\")\n    q = str(len(ans))\n    sys.stdout.write(q+\"\\n\")\n    for i in ans:\n        e = \" \".join(i)\n        sys.stdout.write(e + \"\\n\")\n\nelse:\n    sys.stdout.write(\"No\\n\")","output":"linear"},{"instruction":"import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef main():\n\tn,m = mints()\n\tvert = []\n\thoriz = []\n\tfor i in range(n):\n\t\tx = mint()\n\t\tvert.append(x)\n\n\tvert.sort()\n\n\tfor i in range(m):\n\t\tx1,x2,y = mints()\n\t\thoriz.append((y,x1,x2))\n\n\thoriz.sort()\n\n\tp = -1\n\thh = []\n\tfor i in horiz:\n\t\tif p != i[0]:\n\t\t\tp = i[0]\n\t\t\tif i[1] == 1:\n\t\t\t\thh.append(i[2])\n\n\thh.sort()\n\ti = 0\n\thl = len(hh)\n\tvl = len(vert)\n\tr = n + m\n\tfor j in range(vl):\n\t\twhile i < hl and hh[i] < vert[j]:\n\t\t\ti+=1\n\t\tr = min(r, hl-i + j)\n\twhile i < hl and hh[i] < 1000000000:\n\t\ti+=1\n\tr = min(r, hl-i + vl)\n\tprint(r)\n\nmain()","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom bisect import bisect_right\nn, x, y = map(int, input().split(' '))\ns=[0]*n\ne=[0]*n\nv=[0]*n\nc=0\nfor i in range(n):\n    s[i],e[i]=map(int, input().split(' '))\n    c+=x+(e[i]-s[i])*y\ns.sort()\ne.sort()\nfor i in range(n-2,-1,-1):\n    k=bisect_right(s,e[i])\n    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :\n        k+=1\n    if k==n:\n        continue\n    if (s[k]-e[i]) * y < x :\n        v[k] = 1\n        c+=(s[k]-e[i])*y-x\n\nprint(c%(10**9+7))","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\n\nfor i in range(n):\n    if a[i] >= 0:\n        a[i] = -a[i]-1\n\nif n%2:\n    m = min(a)\n    for i in range(n):\n        if a[i] == m:\n            a[i] = -a[i]-1\n            break\n\nprint(*a)","output":"linear"},{"instruction":"def pow1(n, k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return n\n    else:\n        if k % 2 == 0:\n            a = pow1(n, k \/\/ 2) % mod\n            return a * a % mod\n        else:\n            return pow1(n, k - 1) % mod * n % mod\n\nmod = 10 ** 9 + 7\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelse:\n    x = pow1(2, k + 1) % mod\n    print(((n * x - pow1(2, k) + 1)) % mod)","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = (n * (n - 1)) \/\/ 2\nn2 = n \/\/ 2\nb = n2 * (n2 + 1)\nif n % 2 == 0:\n    b -= n2\ns = 0\nfor i in range(m):\n    x, d = map(int, input().split())\n    s += x * n\n    s += d * (a if d > 0 else b)\n\nprint(s \/ n)","output":"linear"},{"instruction":"n=int(input())\n\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\na=[[l[i]+r[i],i] for i in range(n)]\na.sort()\n\ncandies=[0 for i in range(n)]\n\nif(a[0][0] != 0):\n\n    print('NO')\n    exit()\nelse:\n    candies[a[0][1]] = n - a[0][0]\n\nfor i in range(1,n):\n    if(a[i][0] != a[i-1][0] and a[i][0]!=i):\n        print('NO')\n\n        exit()\n\n    candies[a[i][1]] = n - a[i][0]\n\nfor i in range(n):\n    l1=0\n    r1=0\n    for j in range(i):\n        if(candies[j]>candies[i]):\n            l1+=1\n    for j in range(i+1,n):\n        if(candies[j]>candies[i]):\n            r1+=1\n\n    if(l1 != l[i] or r1 != r[i]):\n        print('NO')\n        exit()\nprint('YES')\nprint(*candies)","output":"quadratic"},{"instruction":"n,m = map(int,input().split())\nmat = []\n\nfor i in range(n):\n    mat.append(list(map(int,input().replace(\"*\",\"1\").replace(\".\",\"0\"))))\n\nver,hor = [[0 for i in range(m)] for j in range(n)],[[0 for i in range(m)] for j in range(n)]\n\ndp = [[[0 for i in range(4)]for j in range(m) ] for k in range(n)]\nfor i in range(1,n):\n    for j in range(1,m):\n        x,y = n-i-1,m-j-1\n        if mat[i][j]==1:\n            dp[i][j][0] = max(dp[i][j-1][0],mat[i][j-1]) + 1\n            dp[i][j][1] = max(dp[i-1][j][1],mat[i-1][j]) + 1\n        if mat[x][y]==1:\n            dp[x][y][2] = max(dp[x][y+1][2],mat[x][y+1]) + 1\n            dp[x][y][3] = max(dp[x+1][y][3],mat[x+1][y]) + 1\n\nstars = []\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if mat[i][j]==1:\n            s = min(dp[i][j])-1\n            if s>0:\n                stars.append((i+1,j+1,s))\n                ver[i-s][j]+=1\n                if i+s+1<n:\n                    ver[i+s+1][j] -= 1\n                hor[i][j-s]+=1\n                if j+s+1<m:\n                    hor[i][j+s+1] -= 1\n\nfor i in range(1,n):\n    for j in range(1,m):\n        ver[i][j] += ver[i-1][j]\n        hor[i][j] += hor[i][j-1]\n\nchk = True\nfor i in range(n):\n    for j in range(m):\n        if mat[i][j] and max(ver[i][j],hor[i][j])<=0:\n            chk=False\n            break\n\nif chk:\n    print(len(stars))\n    for i in stars:\n        print(*i)\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"k = int(input())\nn = 1\nup_bnd = 9\nwhile(k > up_bnd):\n    n += 1\n    up_bnd += (9*n)*(10**(n-1))\nlow_bnd = 0\nlb_val = 0\nfor i in range(1, n):\n    low_bnd += (9*i)*(10**(i-1))\n    lb_val = (lb_val*10)+9\nnum = int((k-low_bnd)\/n) + lb_val\nrm = (k-low_bnd) % n\nif(rm != 0):\n    num += 1\nans = 0\nif(rm == 0):\n    ans = num % 10\nelse:\n    for i in range(n-rm+1):\n        j = (num % 10)\n        num = int(num\/10)\n        ans = j\nprint(int(ans))","output":"logn"},{"instruction":"n,k=[int(x) for x in input().split(\" \")]\na=[int(x) for x in input().split(\" \")]\nmark,b=[],[]\nfor x in a:\n    b.append(x)\n    mark.append(False)\nb.sort(reverse=True)\nidx,profit=0,0\nwhile idx<k:\n    profit+=b[idx]\n    for i in range(n):\n        if not mark[i] and a[i]==b[idx]:\n            mark[i]=True\n            break\n    idx+=1\nprint(profit)\nprev,counter=-1,0\nfor i in range(n):\n    if counter==(k-1):\n        break\n    if mark[i]:\n        print(i-prev,end=' ')\n        prev=i\n        counter+=1\nprint(n-prev-1)","output":"nlogn"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\n\nl = set(l)\nl = list(l)\n\nif len(l)<=1:\n    print(\"NO\")\n    exit()\n\nl.sort()\nprint(l[1])","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a=list(map(int,input().rstrip()))\n    b=list(map(int,input().rstrip()))\n    ans,la,lb=[],len(a),len(b)\n    if la!=lb:\n        print(*sorted(a,reverse=True),sep=\"\")\n    else:\n        for i in range(lb):\n            if b[i] in a:\n                ans.append(b[i])\n                a.remove(b[i])\n            else:\n                while i>-1:\n                    ma=-1\n                    for j in a:\n                        if j<b[i]:\n                            ma=max(ma,j)\n                    if ma!=-1:\n                        ans.append(ma)\n                        a.remove(ma)\n                        break\n                    i-=1\n                    a.append(ans.pop())\n                a.sort()\n                while a:\n                    ans.append(a.pop())\n                break\n        print(*ans,sep=\"\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n=int(input())\nprint(\"0\",\"0\",n)","output":"constant"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nmax1 = float('inf')\nfor q in range(len(a)):\n    if q >= n-q-1:\n        max1 = min(max1, min(a[q], a[0])\/\/q)\n    if q <= n-q-1:\n        max1 = min(max1, min(a[q], a[-1]) \/\/ (n-q-1))\nprint(max1)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nA=[list(map(int,input().split())) for i in range(n)]\n\nSET=set()\nfor a in A:\n    SET|=set(a)\n\ncompression_dict={a: ind for ind, a in enumerate(sorted(SET))}\n\nfor i in range(n):\n    A[i]=[compression_dict[a] for a in A[i]]\n\nOK=0\nNG=len(compression_dict)\nANS=[1,1]\nB=[set()]*n\nP=[2,3,5,7,11,13,17,19]\nQ=1\nfor j in range(m):\n    Q*=P[j]\n\nimport math\n\ndef ya(x):\n    xr=math.ceil(math.sqrt(x))\n\n    LIST=[]\n    for i in range(1,xr+1):\n        if x%i==0:\n            LIST.append(i)\n            LIST.append(x\/\/i)\n\n    return LIST\n\nwhile NG>OK+1:\n    mid=(OK+NG)\/\/2\n    SET=set()\n\n    for i in range(n):\n        NOW=1\n        for j in range(m):\n            if A[i][j]>=mid:\n                NOW*=P[j]\n        B[i]=NOW\n        SET.add(NOW)\n\n    flag=0\n\n    for s in SET:\n        for l in ya(s):\n            if Q\/\/l in SET:\n                flag=1\n                OK=mid\n                break\n        if flag:\n            break\n\n    else:\n        NG=mid\n\nSET=set()\nfor i in range(n):\n    NOW=1\n    for j in range(m):\n        if A[i][j]>=OK:\n            NOW*=P[j]\n    B[i]=NOW\n    SET.add(NOW)\n\nflag=0\nfor i in range(n):\n    for l in ya(B[i]):\n        if Q\/\/l in SET:\n            ANS1=i\n            flag=1\n            break\n    if flag:\n        break\n\nLIST=ya(B[i])\nSET=set(LIST)\n\nfor i in range(n):\n    if Q\/\/B[i] in SET:\n        ANS2=i\n\nprint(ANS1+1,ANS2+1)","output":"np"},{"instruction":"r,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"from itertools import groupby\nn=int(input())\ns=input()\nx=[len(list(group)) for key,group in groupby(s) if key==\"x\"]\nans=sum(max(0,l-3+1) for l in x)\nprint(ans)","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\n\nnr,ng,nb=[int(x) for x in input().split()]\nr=[int(x) for x in input().split()]\ng=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\n\nr.sort()\ng.sort()\nb.sort()\n\nmemo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]\nmemo[0][0][0]=0\nfor i in range(nr):\n    memo[i+1][0][0]=0\nfor j in range(ng):\n    memo[0][j+1][0]=0\nfor k in range(nb):\n    memo[0][0][k+1]=0\ndef dp(i,j,k):\n    if i<-1 or j<-1 or k<-1:\n        return -float('inf')\n    if memo[i+1][j+1][k+1]==-1:\n        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],\n                   dp(i-1,j-1,k)+r[i]*g[j],\n                   dp(i-1,j,k-1)+r[i]*b[k]\n                )\n    return memo[i+1][j+1][k+1]\n\nfor i in range(max(nr,ng,nb)):\n    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))\n\nprint(dp(nr-1,ng-1,nb-1))","output":"cubic"},{"instruction":"import sys\nketa=29\nprint(\"?\",0,0,flush=True)\n\nA00=int(input())\nif A00==0:\n    ANS=0\n    for k in range(keta,-1,-1):\n        print(\"?\",2**k,0,flush=True)\n        if int(input())==-1:\n            ANS+=2**k\n    print(\"!\",ANS,ANS,flush=True)\n    sys.exit()\n\nA=0\nB=0\nfor k in range(keta,-1,-1):\n    LIST=[]\n    print(\"?\",2**k+A,B,flush=True)\n    LIST.append(int(input()))\n    print(\"?\",A,2**k+B,flush=True)\n    LIST.append(int(input()))\n\n    if LIST[0]!=LIST[1]:\n        if LIST[0]==-1:\n            A+=2**k\n            B+=2**k\n\n    else:\n        if A00==1:\n            A+=2**k\n        else:\n            B+=2**k\n        A00=LIST[0]\nprint(\"!\",A,B,flush=True)","output":"logn"},{"instruction":"from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, A, B, C, T = rints()\na, ans = rints(), 0\nfor i in range(n):\n    su, cur = A, A\n    for j in range(a[i], T):\n        cur -= B\n        su = max(su, (j - a[i] + 1) * C + cur)\n\n    ans += su\nprint(ans)","output":"linear"},{"instruction":"mecces, burgerKing, both, groupSize = map(int,input().strip().split(' '))\nmecces -= both\nburgerKing -= both\nnotPassed = groupSize - sum((mecces,burgerKing,both))\nif notPassed > 0 and burgerKing >= 0 and mecces >= 0:\n    print(notPassed)\nelse:\n    print(-1)","output":"constant"},{"instruction":"from itertools import combinations\nn, l, r, x = map(int,input().split())\nc = [*map(int, input().split())]\nprint(sum([sum([1 if max(j) - min(j) >= x and l <= sum(j) <= r else 0 for j in combinations(c, i)]) for i in range(1, n + 1)]))","output":"np"},{"instruction":"n, m, k, l = map(int, input().split())\ncnt = (k + l + m - 1) \/\/ m\nif cnt * m > n:\n    print(-1)\nelse:\n    print(cnt)","output":"constant"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nfor x in range(1,n):\n\tif l[x]>l[0]:\n\t\tprint(l[x])\n\t\tbreak\nelse:\n\tprint('NO')","output":"nlogn"},{"instruction":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            flag = True\n            for j in range(len(nums)):\n                if i != j and nums[i] == nums[j]:\n                    flag = False\n                    break\n            if flag:\n                return nums[i]\n","output":"quadratic"},{"instruction":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n\n        arr = []\n        for num, cnt in count.items():\n            arr.append([cnt, num])\n        arr.sort()\n\n        res = []\n        while len(res) < k:\n            res.append(arr.pop()[1])\n        return res","output":"nlogn"},{"instruction":"f1, f2 = map(int,input().split(\" \"))\nif f1==0:\n  print(0)\nelse:\n  print((pow(2,f2,1000000007)*(2*f1-1)+1)%1000000007)","output":"logn"},{"instruction":"c1, c2, c3 = map(int, input().split())\nr = sorted(list(map(int, input().split())))\ng = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\ndp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]\nfor i in range(c1 + 1):\n    for j in range(c2 + 1):\n        for k in range(c3 + 1):\n            if i>0 and j>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])\n            if i>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])\n            if j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])\nprint(dp[c1][c2][c3])","output":"cubic"},{"instruction":"n=input()\nans=0\nr,c=0,0\nfor i in range(len(n)):\n    r+=int(n[i])\n    c+=1\n    if int(n[i])%3==0 or r%3==0 or c==3:\n        ans+=1\n        r,c=0,0\nprint(ans)","output":"linear"},{"instruction":"import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]\nfor idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != \"_\"]);memo[val] = idx\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:print(\"NO\");exit()\n\n    graph[idx] += [idx_to for idx_to in idxs if idx != idx_to]\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")","output":"np"},{"instruction":"import sys\nfrom array import array\nfrom bisect import bisect_right\n\nn, k = map(int, input().split())\na = sorted(map(int, input().split())) + [10**9]\nans = n\n\nfor x in a[:-1]:\n    if a[bisect_right(a, x)] <= x+k:\n        ans -= 1\n\nprint(ans)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter, deque\n\nn, m, k = map(int, input().split())\nP = [input()[:-1] for _ in range(n)]\nS = [list(input().split()) for _ in range(m)]\nidx = {p: i for i, p in enumerate(P, 1)}\nG = defaultdict(list)\ndeg = Counter()\nfor s, i in S:\n    i = int(i)\n    cand = set()\n    for mask in range(1 << k):\n        cur = ['_'] * k\n        for j in range(k):\n            if mask >> j & 1: cur[j] = s[j]\n        cur = \"\".join(cur)\n        if cur in idx:\n            cand.add(idx[cur])\n    if i not in cand:\n        print(\"NO\")\n        break\n    for c in cand:\n        if c == i: continue\n        G[i].append(c)\n        deg[c] += 1\nelse:\n    ans = []\n    q = deque([i for i in range(1, n + 1) if not deg[i]])\n    while q:\n        i = q.popleft()\n        ans.append(i)\n        for j in G[i]:\n            deg[j] -= 1\n            if not deg[j]:\n                q.append(j)\n    if len(ans) < n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*ans)","output":"np"},{"instruction":"def binarySearch (N,l,r,x):\n    if r >= l:\n        mid = l + (r - l)\/\/2\n        Temp = (mid*(mid+1))\/\/2\n        if Temp-x == N-mid:\n            return N-mid\n        elif Temp-x > N-mid:\n            return binarySearch(N,l, mid-1, x)\n        else:\n            return binarySearch(N,mid + 1, r, x)\n    else:\n        return -1\nn,k=list(map(int,input().split()))\nprint(binarySearch (n,0,n,k))","output":"logn"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k\/2+1))\n\n  @bootstrap\n  def solve(node, remain):\n    if remain == 0:\n      yield 0\n\n    key = (node + remain * n * m)\n    mem = dp[key]\n    if mem != -1:\n      yield mem\n\n    result = []\n    for x in adj[node]:\n      result.append((yield solve(x[0], remain-1)) + x[1])\n    ans = min(result)\n    dp[key] = ans\n    yield ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k\/2) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"from collections import deque\nfrom sys import stdin, stderr\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef signum(n):\n    return 1 if n > 0 else 0 if n == 0 else -1\n\ndef range_includes(i, j):\n    s = signum(j - i)\n    return range(i, j + s, s)\n\ndef main():\n\n    first = ints()\n    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))\n    minX = min(aCoord[0] for aCoord in aCoords)\n    minY = min(aCoord[1] for aCoord in aCoords)\n    maxX = max(aCoord[0] for aCoord in aCoords)\n    maxY = max(aCoord[1] for aCoord in aCoords)\n    def inFirst(x, y):\n        return x >= minX and x <= maxX and y >= minY and y <= maxY\n\n    second = ints()\n    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))\n    minSum = min(sum(bCoord) for bCoord in bCoords)\n    maxSum = max(sum(bCoord) for bCoord in bCoords)\n    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    def inSecond(x, y):\n        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff\n\n    for aCoord in aCoords:\n        if inSecond(*aCoord):\n            return True\n    for i in range(-1, 3):\n        c1 = bCoords[i]\n        c2 = bCoords[i + 1]\n        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):\n            if inFirst(x, y):\n                return True\n    return False\n\nif __name__ == '__main__':\n    print(\"YES\" if main() else \"NO\")","output":"constant"},{"instruction":"k = int(input())\nif (k < 10):\n    print(k)\n    quit()\nc=0\nn=k\na = k\nwhile (n > 0):\n    c+=1\n    sub = 10 ** c - 10 ** (c-1)\n    a-=sub*c\n    n = a \/ (c+1) + (10 ** c - 1)\n    if (n+1 <= 10 ** (c+1)):\n        if (int(n) == n):\n            print(int(n%(10)))\n            exit()\n        else:\n            print(str(int(n)+1)[round((n-int(n))*(c+1))-1])\n            exit()","output":"logn"},{"instruction":"n,s=map(int,input().split())\nif s>=n:\n\tprint(0)\nelse:\n\tans=0\n\tdef sod(n):\n\t\ts=str(n)\n\t\tret=0\n\t\tfor i in s:\n\t\t\tret+=int(i)\n\t\treturn ret\n\tfor nd in range(s,s+1000):\n\t\tif nd-sod(nd) >=s:\n\t\t\tans+=1\n\t\tif nd==n:\n\t\t\tbreak\n\t\tif nd==(s+369):\n\t\t\tans+=(n-nd)\n\t\t\tbreak\n\tprint(ans)","output":"logn"},{"instruction":"l,r=[int(i) for i in input().split()]\nLXR=l^r\nmsbPos = 0\nwhile(LXR):\n\tmsbPos+=1\n\tLXR>>=1\nmaxXOR, two = 0, 1\nwhile (msbPos):\n\tmaxXOR += two\n\ttwo <<= 1\n\tmsbPos -= 1\nprint(maxXOR)","output":"logn"},{"instruction":"import sys\nimport math\n\ndef readlines(type=int):\n    return list(map(type, sys.stdin.readline().split()))\n\ndef read(type=int):\n    return type(sys.stdin.readline().strip())\n\njoint = lambda it, sep=\" \": sep.join(\n    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])\n\ndef solve_naive(n, k):\n    taken = set()\n    current_cap = 0\n    found = False\n    while current_cap != n:\n        for c in range(k, 1, -1):\n            found = False\n            if current_cap == 0:\n                if c <= n:\n                    current_cap += c\n                    taken.add(c)\n                    found = True\n                    break\n            else:\n                if c not in taken and c - 1 <= n - current_cap:\n                    current_cap += c - 1\n                    taken.add(c)\n                    found = True\n                    break\n        if not found:\n            break\n    return len(taken) if found else -1\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k >= n:\n        return 1\n    else:\n        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:\n            return -1\n        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) \/ 2\n        if t == 0.0:\n            return 2\n        if t % 1 == 0:\n            return 1 + int(t)\n        else:\n\n            return 2 + int(t)\n\ndef main():\n    n, k = readlines()\n    print(solve(n, k))\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"n, t = map(int, input().split())\n\na, v = sorted(list(map(int, input().split())) for i in range(n)), 2\n\nfor i in range(n - 1):\n\n    d = 2 * a[i + 1][0] - a[i + 1][1] - 2 * a[i][0] - a[i][1]\n\n    if d > 2 * t:\n\n        v += 2\n\n    elif d == 2 * t:\n\n        v += 1\n\nprint(v)","output":"nlogn"},{"instruction":"n, l, r, x = map(int, input().split())\ntasks = [int(i) for i in input().split()]\ncnt = 0\nfor num in range(2 ** n):\n    bin_num = bin(num)[2:]\n    if len(bin_num) < n:\n        bin_num = '0' * (n - len(bin_num)) + bin_num\n    m = []\n    for i in range(n):\n        if bin_num[i] == '1':\n            m.append(tasks[i])\n    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:\n        cnt += 1\nprint(cnt)","output":"np"},{"instruction":"n = int(input())\nw = list(map(int, input().split()))\nent = input()\nmp = {w[i]: i+1 for i in range(n)}\nsorted(mp)\nw.sort()\nptr = 0\na = 0\nstk = []\nfor i in range(2 * n):\n    if ent[i] == \"0\":\n        print(mp[w[ptr]], end=\" \")\n        stk.append(mp[w[ptr]])\n        ptr += 1\n    else:\n        print(stk.pop(), end=\" \")\n\nprint()","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO ,IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return input()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int ,input().split())\n\ndef llinp(): return list(map(int ,input().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a ,b): print(a ,b)\nimport math\n\nfrom collections import OrderedDict\n\nimport operator\n\nn,m=nninp()\nif(n>m):\n    print(0)\n    exit()\na=llinp()\nd={}\nfor c in a:\n    if(c in d):\n        d[c]+=1\n    else:\n        d[c]=1\ndict1=dict(sorted(d.items(),key=operator.itemgetter(1)))\nans=0\nfor i in range(1,105):\n    temp=dict1.copy()\n    n1=n\n    for c in temp:\n        n1=n1-(temp[c]\/\/i)\n    if(n1>0):\n        print(i-1)\n        exit()","output":"nlogn"},{"instruction":"n,A,B,C,T=map(int,input().split())\nt=list(map(int,input().split()))\nif(B>C):\n    print(n*A)\nelse:\n    c=0\n    t.sort()\n    for i in t:\n        c+=(T-i)*(C-B)+A\n    print(c)","output":"linear"},{"instruction":"n= int(input())\nfor i in range(n\/\/3):\n    print(-2,1+i*2)\nfor i in range(n-n\/\/3):\n    print(1,i)","output":"linear"},{"instruction":"from sys import stdin\nfrom array import array\ndef recSolve(dp,r,g,b,rx,gx,bx, R, G, B):\n\tif rx == R:\n\t\treturn sum(a * b for a, b in zip(g[gx:], b[bx:]))\n\tif gx == G:\n\t\treturn sum(a * b for a, b in zip(r[rx:], b[bx:]))\n\tif bx == B:\n\t\treturn sum(a * b for a, b in zip(g[gx:], r[rx:]))\n\tif dp[rx * G * B + gx * B + bx] != -1:\n\t\treturn dp[rx * G * B + gx * B + bx]\n\trg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]\n\tbg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]\n\trb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]\n\tans = max(rg, bg, rb)\n\tdp[rx * G * B + gx * B + bx] = ans\n\treturn ans\ninput = stdin.readline\nR, G, B = map(int, input().split())\nr = sorted([*map(int, input().split())], reverse = True)\ng = sorted([*map(int, input().split())], reverse = True)\nb = sorted([*map(int, input().split())], reverse = True)\ndp = array('q', (-1 for x in range(R * G * B)))\nprint(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))","output":"cubic"},{"instruction":"p = int(input())\narr = list(map(int, input().split()))\narr.sort(reverse=True)\nd = 0\nfor x in arr:\n    d += x\nc = 0\nnum = 0\nwhile c <= d\/2:\n    c += arr[num]\n    num += 1\nprint(num)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\ns = [list(input().rstrip()) for _ in range(n)]\nt = [[1000] * m for _ in range(n)]\nok1 = [[0] * m for _ in range(n)]\nok2 = [[0] * m for _ in range(n)]\nfor i in range(n):\n    si = s[i]\n    c = 0\n    for j in range(m):\n        if si[j] == \"*\":\n            c += 1\n        else:\n            c = 0\n        t[i][j] = min(t[i][j], c)\n    c = 0\n    for j in range(m - 1, -1, -1):\n        if si[j] == \"*\":\n            c += 1\n        else:\n            c = 0\n        t[i][j] = min(t[i][j], c)\nfor j in range(m):\n    c = 0\n    for i in range(n):\n        if s[i][j] == \"*\":\n            c += 1\n        else:\n            c = 0\n        t[i][j] = min(t[i][j], c)\n    c = 0\n    for i in range(n - 1, -1, -1):\n        if s[i][j] == \"*\":\n            c += 1\n        else:\n            c = 0\n        t[i][j] = min(t[i][j], c)\nans = []\nfor i in range(n):\n    for j in range(m):\n        tij = t[i][j] - 1\n        if tij >= 1:\n            ans.append((i + 1, j + 1, tij))\n            ok1[max(0, i - tij)][j] += 1\n            if i + tij + 1 < n:\n                ok1[i + tij + 1][j] -= 1\n            ok2[i][max(0, j - tij)] += 1\n            if j + tij + 1 < m:\n                ok2[i][j + tij + 1] -= 1\nfor i in range(1, n):\n    for j in range(1, m):\n        ok1[i][j] += ok1[i - 1][j]\n        ok2[i][j] += ok2[i][j - 1]\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \"*\":\n            if not (ok1[i][j] or ok2[i][j]):\n                ans = -1\n                print(ans)\n                exit()\nk = len(ans)\nprint(k)\nfor ans0 in ans:\n    print(*ans0)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a=list(map(int,input()))\n    b=list(map(int,input()))\n    dff=len(b)-len(a)\n    if dff<0:\n        print(0)\n        exit()\n    lb=len(b)\n    c=[0]*(lb+1)\n    for i in range(lb):\n        c[i+1]=c[i]+b[i]\n    ans=0\n    for i in range(len(a)):\n        item=a[i]\n        if item:\n            ans+=(dff+1-(c[dff+i+1]-c[i]))\n        else:\n            ans+=(c[dff+i+1]-c[i])\n\n    print(ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ngraph=defaultdict(list)\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nbulb=[1]*(n+1)\nfor i in range(n-1):\n    bulb[par[i]]=0\n    graph[par[i]].append(i+2)\n\nzero=bulb.count(0)\nfor  i in range(n,0,-1):\n    if bulb[i]==0:\n        count=0\n        for j in graph[i]:\n            count+=bulb[j]\n        bulb[i]=count\nbulb=bulb[1:]\nbulb.sort()\nsys.stdout.write(' '.join(map(str,bulb)))","output":"quadratic"},{"instruction":"from _collections import deque\nn = int(input())\nm = list(map(int, input().split()))\na = []\nb = deque()\n\ni = 1\nfor x in m:\n    a.append((x, i))\n    i += 1\na.sort(key=lambda p: -p[0])\n\ns = input()\nans = []\n\nfor x in s:\n    if x == \"1\":\n        v = b.pop()\n        ans.append(v[1])\n    else:\n        v = a.pop()\n        ans.append(v[1])\n        b.append(v)\nprint(*ans)","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\n\nn=int(input())\na=list(map(int,input().split()))\ndp=[[0]*(n) for i in range(n)]\nfor i in range(n):\n    dp[i][i]=a[i]\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]\n    count+=1\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])\n    count+=1\nfor i in range(int(input())):\n    l,r=map(int,input().split())\n    l-=1\n    r-=1\n    print(dp[l][r])","output":"quadratic"},{"instruction":"from math import gcd\ndef t_prime(n):\n    if n == 1:        return False\n    for p in [2,3,5,7,11,13,17,19,23]:\n        if p < n and pow(p,n-1,n) != 1:            return False\n    return True\nprimes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))\nif k == 1: print(0);exit()\nfor i in range(n):\n    for j in range(i):\n        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)\/\/poss;smol = min(poss,poss2)\n        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)\npowers = set();count = 0;outLs = [];pgood = []\nfor p in primes:\n    curr = [];    fp = [v for v in l if v % p == 0]\n    for v in fp:\n        v2 = v\n        while v2 % p == 0:            v2 \/\/= p\n        if v2 == 1:   curr.append(v);   powers.add(v)\n    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)\norder = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])\nif len(order) == 0:    print(0); exit()\nif order[-1][0] == 2 and k % 2 and count > k:\n    extra = -1;    need = -1;    last = []\n    for v in l:\n        if v in powers:            continue\n        v2 = v;        primesn = []\n        for p in pgood:\n            add = 1\n            while v2 % p == 0:\n                v2 \/\/= p\n                if add:                    primesn.append(p)\n                add = 0\n        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2\n    if need == -1 or 2 * need + 1 > k:  print(0);   exit()\n    other = [];    out = [extra]\n    for a,b in outLs:\n        works = False\n        for p in last:\n            if a % p == 0:   works = True;           break\n        if works:       out.append(a);   out.append(b)\n        else:       other.append(a);      other.append(b)\n    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()\nout = [];need = k\nfor i in range(len(order)):\n    assert need != 1\n\n    lis = order[i][1]\n    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):\n        out += lis\n        need -= len(lis)\n    elif len(lis) == need - 1:\n        if len(lis) > 2:\n            out += lis[:-1]\n            need -= (len(lis) - 1)\n            assert need == 2\n    else:\n        out += lis[:need]\n        need = 0\n\nassert need + len(out) == k\nassert need >= 0\nassert need == 0 or len(out) == count\n\nfor v in l:\n    if need == 0:        break\n    if v in powers:        continue\n    v2 = v\n    for p in pgood:\n        while v2 % p == 0:            v2 \/\/= p\n    if v2 == 1:        out.append(v);        need -= 1\n\nif need == 0:\n    print(' '.join(map(str,out)))\n    exit()\nelse:\n    print(0)","output":"np"},{"instruction":"def solve(board):\n  n=len(board)\n  ans=0\n  for i in range(n):\n    for j in range(n):\n      if board[i][j] is 'X':\n        ans+=2**(i*n+j)\n  return ans\n\ndef reverse_array(arr):\n  for i in range(len(arr)):\n    arr[i].reverse()\n\ndef rotate(matrix, degree):\n    if degree == 0:\n        return matrix\n    elif degree > 0:\n        return rotate(zip(*matrix[::-1]), degree-90)\n    else:\n        return rotate(zip(*matrix)[::-1], degree+90)\n\ndef make_list(board):\n    board=list(board)\n    arr=[]\n    for i in range(len(list(board))):\n        arr.append(list(board[i]))\n    return arr\n\ndef add_rotations(board,st):\n  for i in range(4):\n    st.add(solve(board))\n    reverse_array(board)\n    st.add(solve(board))\n    reverse_array(board)\n    board=make_list(rotate(board, 90))\n\nn=int(input())\narr1=[]\narr2=[]\nfor _ in range(n):\n    arr1.append(list(input().strip()))\nfor _ in range(n):\n    arr2.append(list(input().strip()))\ns=set()\ns.add(solve(arr1))\nadd_rotations(arr1,s)\nl1=len(s)\n\ns.add(solve(arr2))\nadd_rotations(arr2,s)\n\nl2=len(s)\nif l1==l2:\n    print(\"Yes\")\nelse:\n    print(\"No\")","output":"quadratic"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\ndef get_input():\n    n, m = [int(x) for x in input().split(' ')]\n    digraph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n        digraph[c1].append(c2)\n\n    return digraph\n\ndef dfs(graph, u=-1, v=-1):\n    n = len(graph)\n\n    pi = [None] * n\n    color = ['white'] * n\n    for node in range(1, n):\n        if color[node] == 'white':\n            cicle = dfs_visit(graph, node, color, pi, u, v)\n            if cicle is not None:\n                return cicle\n    return None\n\ndef dfs_visit(graph, root, color, pi, u, v):\n    stack = [root]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if (current_node, adj) == (u, v):\n                continue\n\n            if color[adj] == 'white':\n                pi[adj] = current_node\n                stack.append(adj)\n            elif color[adj] == 'grey':\n                cicle = [adj]\n                while current_node != adj:\n                    cicle.append(current_node)\n                    current_node = pi[current_node]\n                cicle.append(adj)\n                return cicle\n    return None\n\nif __name__ == \"__main__\":\n    digraph = get_input()\n    cicle = dfs(digraph)\n    if cicle is None:\n        print(\"YES\")\n    else:\n        cicle.reverse()\n        for i in range(len(cicle) - 1):\n            c = dfs(digraph, cicle[i], cicle[i + 1])\n            if c is None:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom heapq import heapify,heappush as hp,heappop as hpop\ndef check(x,y):\n    if 0<=x<=n-1 and 0<=y<=m-1:\n        return True\n    return False\nn,m,k=map(int,input().split())\nl1=[]\nl2=[]\nfor i in range(n):\n    l1.append(list(map(int,input().split())))\nfor  i in range(n-1):\n    l2.append(list(map(int,input().split())))\ninf=10**18\ndp=[[[inf]*21 for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if check(i,j+1):\n            dp[i][j][1]=min(l1[i][j],dp[i][j][1])\n        if check(i,j-1):\n            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])\n        if check(i+1,j):\n            dp[i][j][1]=min(l2[i][j],dp[i][j][1])\n        if check(i-1,j):\n            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])\nfor x in range(2,k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            if check(i,j+1):\n                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])\n            if check(i,j-1):\n                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])\n            if check(i+1,j):\n                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])\n            if check(i-1,j):\n                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])\n\nans=[[-1]*m for i in range(n)]\nif not k%2:\n    for i in range(n):\n        for j in range(m):\n            ans[i][j]=2*dp[i][j][k\/\/2]\nfor i in ans:\n    print(*i)","output":"cubic"},{"instruction":"a,b,c,d,e,f,g,h,i,j,k,l= [9*1, 90*2, 900*3, 9000*4, 90000*5, 900000*6, 9000000*7, 90000000*8, 900000000*9, 9000000000*10, 90000000000*11, 900000000000*12]\na=a; b= a+b; c= b+c; d=c+d; e=d+e; f= e+f; g= f+g; h=g+h; i=h+i; j= i+j\nk= j+k; l= k+l\nli1=[0,a,b,c,d,e,f,g,h,i,j,k,l]\nn= int(input()); nn=0\nfor ii in range(1,12):\n    if li1[ii-1]<n and li1[ii+1]>n:\n        nn= ii\n\nn= n-li1[nn-1]\nr1= 10**(nn-1)\nn1= n\/\/nn\nr1+= n1-1\nn2= n-(n1*nn)\nif n2==0:\n    print(str(r1)[-1])\nelse:\n\n    print(str(r1+1)[n2-1])","output":"logn"},{"instruction":"n, MOD = map(int, input().split())\n\npascal = [[1]]\nfor _ in range(500):\n    nl = [1]\n    for i in range(_):\n        nl.append((pascal[-1][i] + pascal[-1][i+1]) % MOD)\n    nl.append(1)\n    pascal.append(nl)\n\nmod_mul = lambda x, y: (x * y) % MOD\n\nimport __pypy__\n\nint_add = __pypy__.intop.int_add\nint_sub = __pypy__.intop.int_sub\nint_mul = __pypy__.intop.int_mul\n\ndef make_mod_mul(mod=MOD):\n    fmod_inv = 1.0 \/ mod\n\n    def mod_mul(a, b, c=0):\n        res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c)))\n        if res >= mod:\n            return res - mod\n        elif res < 0:\n            return res + mod\n        else:\n            return res\n\n    return mod_mul\n\nmod_mul = make_mod_mul()\n\ndef mod_pow(x, y):\n    if y == 0:\n        return 1\n    res = 1\n    while y > 1:\n        if y & 1 == 1:\n            res = mod_mul(res, x)\n        x = mod_mul(x, x)\n        y >>= 1\n    return mod_mul(res, x)\n\nbase = [0] * (n + 1)\n\ndp = []\nfor i in range(n):\n    nex = base[:]\n    nex[1] = mod_pow(2, i)\n    for j in range(i - 1):\n        bl = i-j-1\n        assert bl > 0\n        mul = mod_pow(2, bl - 1)\n        for k in range(n):\n            ct = 2 + j - k\n            if ct < 0:\n                assert dp[j][k] == 0\n                continue\n            mulr = mod_mul(mul, pascal[bl+ct][ct])\n            nex[k+1] += mod_mul(mulr, dp[j][k])\n            nex[k+1] %= MOD\n    dp.append(nex)\nprint(sum(dp[-1]) % MOD)","output":"cubic"},{"instruction":"import sys\n\nn = int(input())\nprob = [list(map(float, input().split())) for _ in range(n)]\ndp = [[0.0]*n for _ in range(1 << n)]\ndp[1][0] = 1.0\n\nfor mask in range(3, 1 << n):\n    for i in range(n):\n        if not (mask & (1 << i)):\n            continue\n        for j in range(n):\n            if i != j and mask & (1 << j):\n                dp[mask][i] = max(\n                    dp[mask][i],\n                    dp[mask - (1 << j)][i] * prob[i][j]\n                    + dp[mask - (1 << i)][j] * prob[j][i]\n                )\n\nprint(max(dp[-1]))","output":"np"},{"instruction":"import math\nfor _ in range(1):\n    n,k=map(int,input().split())\n    l=list(map(int,input().split()))\n    ans=0\n    for i in range(n):\n\t    c=0\n\t    sum1=0\n\t    for j in range(i, n):\n\t\t    sum1 += l[j]\n\t\t    c+=1\n\t\t    if c >= k:\n\t\t\t    ans=max(ans,sum1\/c)\nprint(ans)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list(map(lambda x: int(x) - 1, input().split()))\n\ndef main():\n    a,b = getints()\n    print(result(a,b))\n\ndef result(a,b):\n    if a==0 or b==0:\n        return 0\n    if a>b:\n        return a\/\/b+result(a%b,b)\n    else:\n        return b\/\/a+result(b%a,a)\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"l = [int(x) for x in raw_input().split()]\nn, s = l[0], l[1]\n\ndef getval(x):\n\tcur, ans = 0, 0\n\twhile(x):\n\t\tdig = (x % 10)\n\t\tans += dig * cur\n\t\tcur *= 10\n\t\tcur += 9\n\t\tx \/= 10\n\treturn ans\n\nlow = 1\nhigh = n\nfor _ in range(64):\n\tmid = (low + high) \/\/ 2\n\tif(getval(mid) < s):\n\t\tlow = mid + 1\n\telse:\n\t\thigh = mid;\n\nif(low > high):\n\tprint(0)\nelif(getval(low) >= s):\n\tprint(n - low + 1)\nelse:\n\tprint(n - high + 1)","output":"logn"},{"instruction":"a, b = map(int, input().split())\nif a == b:\n    print(0)\n    exit()\naa = \"\"\nbb = \"\"\nwhile a or b:\n    aa += str(a % 2)\n    bb += str(b % 2)\n    a \/\/= 2\n    b \/\/= 2\naa = aa[::-1]\nbb = bb[::-1]\n\nidx = 0\nwhile aa[idx] == bb[idx]:\n    idx += 1\n\nln = len(aa)\nr = 2 ** (ln - idx) - 1\nprint(r)","output":"logn"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef solve(s,t):\n    if len(t) == 1:\n        if s.count(t[0]):\n            return 'YES'\n        return 'NO'\n    for i in range(1,len(t)):\n        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]\n        dp[0][0] = 0\n        for j in range(len(s)):\n            dp[j+1] = dp[j][:]\n            for k in range(i+1):\n                if k != i and s[j] == t[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])\n                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:\n                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)\n        for l in range(len(s)+1):\n            if dp[l][-1] == len(t)-i:\n                return 'YES'\n    return 'NO'\n\ndef main():\n    for _ in range(int(input())):\n        s = input().strip()\n        t = input().strip()\n        print(solve(s,t))\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"import sys, os\nfrom io import BytesIO, IOBase\nimport collections, itertools, bisect, heapq, math, string\nfrom decimal import *\nfrom collections import deque\n\nBUFSIZE = 8192\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = set(a)\n    a.sort()\n    ans = []\n    for i in range(n):\n        for j in range(31):\n            tmp = [a[i]]\n            x = a[i] + 2 ** j\n            y = a[i] + 2 ** (j + 1)\n            if x in s:\n                tmp.append(x)\n            if y in s:\n                tmp.append(y)\n            if len(tmp) > 1:\n                if len(ans) == 0:\n                    ans.append(tmp)\n                else:\n                    if len(tmp) > len(ans[0]):\n                        ans[0] = tmp\n    if len(ans) == 0:\n        print(1)\n        print(a[0])\n        return\n    if len(ans[0]) == 2:\n        print(2)\n        print(ans[0][0], ans[0][1])\n        return\n    if len(ans[0]) == 3:\n        print(3)\n        print(ans[0][0], ans[0][1], ans[0][2])\n        return\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\nal=list(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nn=int(input())\ns=[input().rstrip() for i in range(3)]\nl=len(s[0])\nans=[0]*3\nfor c in al:\n    for i in range(3):\n        cnt_c=s[i].count(c)\n        if cnt_c+n<=l:\n            ans[i]=max(ans[i],cnt_c+n)\n        else:\n            if n==1 and l==cnt_c:\n                ans[i]=max(ans[i],l-1)\n            else:\n                ans[i]=l\nif (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):\n    print(\"Draw\")\nelif max(ans)==ans[0]:\n    print(\"Kuro\")\nelif max(ans)==ans[1]:\n    print(\"Shiro\")\nelse:\n    print(\"Katie\")","output":"linear"},{"instruction":"import sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn = ri(1)\na= ri()\n\nb= sorted(a)\nc= dd(int)\n\nans = 0\nval=0\nfor i in range(n):\n\tif c[b[i]]==0:\n\t\tval+=1\n\t\tfor j in range(n):\n\t\t\tif b[j]%b[i]==0:\n\t\t\t\tc[b[j]]=val\n\nfor i in c:\n\tans = max(ans , c[i])\n\nprint(ans)","output":"quadratic"},{"instruction":"def sss(l,r,tt):\n    f = -1\n    while(l<=r):\n        mid = (l + r) >> 1\n        if(a[mid]-a[tt] <= m):\n           f = mid\n           l = mid + 1\n        else :\n           r = mid - 1\n    return f\n\nn , m =  map(int, input().split())\na = [int(x) for x in input().split()]\nf = 0\nl  = len(a)\n\nMaxx = -1\nfor i in range(0,l-2):\n    if(a[i+2] - a[i]<= m):\n         k = sss(i+2,l-1,i)\n         if(k != -1):\n             Maxx = max(Maxx,(a[k] - a[i+1])\/(a[k]-a[i]))\nif(Maxx == -1):\n    print(-1)\nelse: print(\"%.15f\\n\" % Maxx)","output":"nlogn"},{"instruction":"def get_colors(x1, y1, x2, y2):\n    w = x2 - x1 + 1\n    h = y2 - y1 + 1\n    if w % 2 == 0 or h % 2 == 0:\n        black = w * h \/\/ 2\n        white = w * h \/\/ 2\n    else:\n        oddx = w \/\/ 2\n        if x1 % 2 == 1 and x2 % 2 == 1:\n            oddx += 1\n        oddy = h \/\/ 2\n        if y1 % 2 == 1 and y2 % 2 == 1:\n            oddy += 1\n        evenx = w \/\/ 2\n        if x1 % 2 == 0 and x2 % 2 == 0:\n            evenx += 1\n        eveny = h \/\/ 2\n        if y1 % 2 == 0 and y2 % 2 == 0:\n            eveny += 1\n        white = oddx * oddy + evenx * eveny\n        black = w * h - white\n    return white, black\n\ndef get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    if ax1 > bx2:\n        return None, None, None, None\n    if bx1 > ax2:\n        return None, None, None, None\n    if ay1 > by2:\n        return None, None, None, None\n    if by1 > ay2:\n        return None, None, None, None\n    return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2)\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    white, black = get_colors(1, 1, m, n)\n    wx1, wy1, wx2, wy2 = map(int, input().split())\n    w, b = get_colors(wx1, wy1, wx2, wy2)\n    white += b\n    black -= b\n    bx1, by1, bx2, by2 = map(int, input().split())\n    ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2)\n    if ix1 is not None:\n        w, b = get_colors(ix1, iy1, ix2, iy2)\n        white -= b\n        black += b\n    w, b = get_colors(bx1, by1, bx2, by2)\n    white -= w\n    black += w\n    print(white, black)","output":"constant"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, a, b = mi()\nc = max(a, b)\nif a != 1 and b != 1:\n    print('NO')\nelif n == 2 and c == 1:\n    print('NO')\nelif n == 3 and c == 1:\n    print('NO')\nelse:\n    if a == 1:\n        g = [[1] * n for i in range(n)]\n        for i in range(n):\n            g[i][i] = 0\n        for i in range(c - 1, n - 1):\n            g[i][i + 1] = g[i + 1][i] = 0\n    else:\n        g = [[0] * n for i in range(n)]\n        for i in range(c - 1, n - 1):\n            g[i][i + 1] = g[i + 1][i] = 1\n    print('YES')\n    for r in g:\n        print(''.join(str(x) for x in r))","output":"quadratic"},{"instruction":"import sys\n\ntry:\n\n    def check(n):\n        count1=0\n        s=\"\"\n        while(n!=0):\n            if n%2:\n                count1+=1\n                s=\"1\"+s\n            else:\n                s=\"0\"+s\n            n\/\/=2\n        return s\n\n    def solve(flag,n,l):\n        temp_ans=0\n        for i in range(n):\n            y=(z[flag]^int(l[i],2) )\n            b=bin(y)\n            temp_ans+=b.count(\"1\")\n            flag=not(flag)\n\n        return temp_ans\n\n    n=int(input())\n    l1 = [input() for y in range(n)]\n    temp=input()\n    l2 = [input() for y in range(n)]\n    temp=input()\n    l3 = [input() for y in range(n)]\n    temp=input()\n    l4 = [input() for y in range(n)]\n\n    z=[]\n    s=0\n    for i in range(n):\n       if i%2==1:\n           s+=(2**i)\n    z.append(s)\n    z.append( z[0] ^ (2**n-1) )\n    ans=m=sys.maxsize\n    for i in range(2,17):\n        s=check(i)\n        if s.count(\"1\")==2:\n            s=(4-len(s))*\"0\"+s\n            res=sys.maxsize\n            for i in range(4):\n                if i==0:\n                    x=l1\n                elif i==1:\n                    x=l2\n                elif i==2:\n                    x=l3\n                else:\n                    x=l4\n\n                if s[i]==\"1\":\n                    res+=min(res,solve(1,n,x))\n                else:\n                    res+=min(res,solve(0,n,x))\n            ans=min(ans,res-m)\n    print(ans)\n\nexcept EOFError:\n    pass","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\ns=input()\nt=input()\nif n-1>m:\n    print('NO')\nelse:\n    try:\n        a=s.index('*')\n    except:\n        a=-1\n    if a==-1:\n        if s==t:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        f=True\n        for i in range(a):\n            if s[i]!=t[i]:\n                print('NO')\n                exit()\n        i=1\n        while m-i>=a and n-i>a:\n            if s[n-i]!=t[m-i]:\n                print('NO')\n                exit()\n            i+=1\n        print('YES')","output":"linear"},{"instruction":"n, S = map(int, input().split())\nprint((S + n - 1) \/\/ n);","output":"constant"},{"instruction":"n, m, K=map(int, input().split())\nedgesh=[[0 for i in range(m-1)] for k in range(n)]\n\nedgesv=[[0 for i in range(m)] for k in range(n-1)]\n\nfor mm in range(n):\n    edgesh[mm]=list(map(int, input().split(\" \")))\nfor mm in range(n-1):\n    edgesv[mm]=list(map(int, input().split(\" \")))\ndp=[[[10**10 for tro in range(K+1)] for i in range(m)] for mm in range(n)]\nfor k in range(0, K+1, 2):\n for i in range(n):\n  for j in range(m):\n    if(k==0):\n      dp[i][j][k]=0\n    elif(i==0 and j==0):\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])\n    elif(i==0 and j==m-1):\n      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])\n    elif(i==0):\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])\n    elif(j==0 and i==n-1):\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])\n    elif(j==0):\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])\n    elif(i==n-1 and j==m-1):\n      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])\n    elif(i==n-1):\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])\n    elif(j==m-1):\n      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])\n    else:\n      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])\nfor i in range(n):\n  for j in range(m):\n   if(dp[i][j][K]>=10**10):\n    print(-1, end=\" \")\n   else:\n    print(dp[i][j][K], end=\" \")\n  print()","output":"cubic"},{"instruction":"def main():\n    n, m = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = list(map(int, input().split()))\n    b.sort()\n    g.sort()\n    if b[-1] > g[0]:\n        print(-1)\n        return\n    if b[-1] == g[0]:\n        print(sum(g) + m * (sum(b) - b[-1]))\n        return\n    if n == 1:\n        print(-1)\n        return\n    print(sum(g) + b[-1] + b[-2] * (m - 1) + m * (sum(b) - b[-1] - b[-2]))\nmain()","output":"nlogn"},{"instruction":"c = [[0 for i in range(5205)] for j in range(5205)]\nK = 998244353\ninv = [0 for i in range(5205)]\n\ndef mu(a, n):\n\tif n == 0: return 1\n\tq = mu(a, n \/\/ 2)\n\tif n % 2 == 0:\n\t\treturn q * q % K\n\telse: return q * q % K * a % K\n\ndef calc(m, d, S):\n\tres = 0\n\tif m == 0:\n\t\tif S == 0: return 1\n\t\treturn 0\n\n\tfor u in range(0, m + 1):\n\t\tif (u * d > S): break\n\t\tU = c[m][u] * c[S - u * d + m - 1][m - 1] % K\n\t\tif u % 2 == 0:\n\t\t\tres = (res + U) % K\n\t\telse: res = (res - U + K) % K\n\treturn res\n\nc[0][0] = 1\ninv[0] = 1\nfor i in range(1, 5101):\n\tinv[i] = mu(i, K - 2)\n\nfor i in range(1, 5101):\n\tc[i][0] = 1\n\tfor j in range (1, i):\n\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K\n\tc[i][i] = 1\n\np, s, r = map(int, input().split())\n\nres = 0\nden = 0\n\nfor i in range(1, p + 1):\n\tA = 0\n\tfor d in range(r, s \/\/ i + 1):\n\t\tif (i < p): A = (A + calc(p - i, d, s - d * i)) % K\n\t\telse:\n\t\t\tif (s - i * d == 0): A += 1\n\tA = A * inv[i] % K\n\tres = (res + A * c[p - 1][i - 1] % K) % K\n\nden = c[s - r + p - 1][p - 1]\nres = res * mu(den, K - 2) % K\nprint(res)","output":"cubic"},{"instruction":"a,b=map(int,input().split())\nx,y,z=map(int,input().split())\n\nyell=2*x+y\nblue=y+3*z\nres=max(0,yell-a)+max(0,blue-b)\n\nprint(res)","output":"constant"},{"instruction":"class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if nums[i] != i:\n                return i\n        return n\n","output":"nlogn"},{"instruction":"import sys;input = sys.stdin.readline\n\ndef topological_sorted(digraph):\n    n = len(digraph)\n    indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] += 1\n\n    tp_order = [i for i in range(n) if indegree[i] == 0]\n    stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:\n                stack.append(nxt_v)\n                tp_order.append(nxt_v)\n\n    return len(tp_order) == n, tp_order\n\nn, m, k = map(int, input().split())\np = [input()[:-1] for i in range(n)]\ns = [list(input().split()) for i in range(m)]\n\nmemo = {}\nfor idx, ptn in enumerate(p):\n    val = 0\n    for i in range(k):\n        if ptn[i] == \"_\":\n            continue\n        val += (ord(ptn[i]) - 96) * (27 ** i)\n    memo[val] = idx\n\nfor i, (string, idx) in enumerate(s):\n    s[i] = tuple(map(ord, string)), int(idx)\n\ngraph = [[] for i in range(n)]\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:\n        print(\"NO\")\n        exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")","output":"np"},{"instruction":"b = [list(input()) for _ in range(2)]\n\nn = len(b[0])\nans = 0\na = []\nfor i in range(n):\n    ai = 0\n    if b[0][i] == '0':\n        ai += 1\n    if b[1][i] == '0':\n        ai += 1\n    a.append(ai)\nprv = 0\nfor i in range(n):\n    if a[i] == 0:\n        prv = 0\n    elif a[i] == 1:\n        if prv == 2:\n            ans += 1\n            prv = 0\n        else:\n            prv = 1\n    elif a[i] == 2:\n        if prv == 2:\n            ans += 1\n            prv = 1\n        elif prv == 1:\n            ans += 1\n            prv = 0\n        else:\n            prv = 2\nprint(ans)","output":"constant"},{"instruction":"class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[n][0] = True\n\n        for i in range(n - 1, -1, -1):\n            for open in range(n):\n                res = False\n                if s[i] == '*':\n                    res |= dp[i + 1][open + 1]\n                    if open > 0:\n                        res |= dp[i + 1][open - 1]\n                    res |= dp[i + 1][open]\n                else:\n                    if s[i] == '(':\n                        res |= dp[i + 1][open + 1]\n                    elif open > 0:\n                        res |= dp[i + 1][open - 1]\n                dp[i][open] = res\n\n        return dp[0][0]","output":"quadratic"},{"instruction":"import collections, bisect\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\ncs = collections.Counter(arr)\nprint(min(cs[x] for x in range(1, n + 1)))","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readlines()\nn = int(input[0].strip())\nm = 10**9 + 7\ncurr = [0] * (n+20)\nlast = [0] * (n+20)\ncurr[0] = 1\nfor s in range(1,n):\n    last, curr = curr, last\n    if input[s]=='f\\n':\n        curr[0] = 0\n        for i in range(len(last)-1):\n            curr[i+1] = last[i]\n    elif input[s]=='s\\n':\n        curr[-1] = 0\n        for i in range(len(last)-2, -1, -1):\n            curr[i] = (curr[i+1] + last[i]) % m\ns = 0\nfor x in curr:\n    s = (s + x) % m\nprint(s)","output":"quadratic"},{"instruction":"def good(max_branch, s, n):\n    nodes = 0\n    can = 1\n    lowest_s = 0\n    depth = 1\n    while(nodes < n):\n        added = min(n - nodes, can)\n        lowest_s += added * depth\n        nodes += added\n        can *= max_branch\n        depth += 1\n    return lowest_s <= s\n\nn, s = map(int, input().split())\n\nif s < 2 * n - 1 or s * 2 > n * (n + 1):\n    print('No')\nelse:\n    lo, hi = 1, n\n    while lo < hi:\n        mid = (lo + hi) >> 1\n        if good(mid, s, n) == False:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    max_branch = lo\n\n    level_size = [1] * (n + 1)\n    node_level = [i for i in range(n + 1)]\n    cur_node = n\n    cur_level = 1\n    cur_sum = n * (n + 1) \/\/ 2\n    can = 1\n    while cur_sum > s:\n        if level_size[cur_level] == can:\n            cur_level += 1\n            can *= max_branch\n\n        if cur_sum - (cur_node - cur_level) < s:\n            cur_level = cur_node - (cur_sum - s)\n\n        node_level[cur_node] = cur_level\n        level_size[cur_level] += 1\n        cur_sum -= cur_node - cur_level\n        cur_node -= 1\n\n    node_list = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        node_list[node_level[i]].append(i)\n\n    pre = 0\n    children = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    seen_nodes = 1\n    for level in range(2, n + 1):\n        idx = 0\n        if not node_list[level - 1]:\n            assert seen_nodes == n\n            break\n        cur_father = node_list[level - 1][0]\n        for node in node_list[level]:\n            if children[cur_father] == max_branch:\n                idx += 1\n                cur_father = node_list[level - 1][idx]\n            children[cur_father] += 1\n            parent[node] = cur_father\n            seen_nodes += 1\n\n    print('Yes')\n    print(*parent[2:])","output":"linear"},{"instruction":"import math\n\ndef c(k, n):\n    return math.factorial(n) \/\/ (math.factorial(k) * math.factorial(n - k))\n\ndef main():\n    sent = input()\n    received = input()\n    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))\n    unrecognized = received.count('?')\n    if difference > unrecognized:\n        print(0)\n        return\n\n    k = (unrecognized - difference) \/\/ 2\n    answer = c(k, unrecognized) * 0.5**unrecognized\n    print(answer)\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"tot, choc = [int(i) for i in input().split()]\n\nbg = 1\nend = tot\n\nwhile True:\n    mid = (bg + end) \/ 2\n    add = (mid * (mid + 1)) \/ 2\n    sub = tot - mid\n    if add - sub == choc:\n        print(int(sub))\n        break\n    if add - sub < choc:\n        bg = mid + 1\n    else:\n        end = mid - 1","output":"logn"},{"instruction":"import math\nn, k = map(int, input().split())\nif k % 2 == 1:\n  mink = (k + 1) \/\/ 2\nelse:\n  mink = k \/\/ 2 + 1\nprint(max(0, min(k - 1, n) - mink + 1))","output":"constant"},{"instruction":"n = int(input().strip())\nprint(n**2+(n-1)**2)","output":"constant"},{"instruction":"a=sorted(input())\n\nb=int(input())\n\na=a[::-1]\n\np=\"\"\n\nwhile a:\n\n\tfor i, z in enumerate(a):\n\n\t\tn=p+a[i]+\"\".join(sorted(a[:i]+a[i+1:]))\n\n\t\tif int(n)<=b:\n\n\t\t\tp+=z\n\n\t\t\ta.pop(i)\n\n\t\t\tbreak\n\nprint(p)","output":"cubic"},{"instruction":"line = input()\nn = len(line)\ntemp = [0]\nfor i in range(1, n):\n    for j in range(n-i):\n        for k in range(1, n-i-j+1):\n\n            if line[j:j+i] == line[j+k:j+k+i]:\n                temp.append(i)\nprint(max(temp))","output":"cubic"},{"instruction":"k, n, s, p = map(int, input().split())\nprint(((n + s - 1) \/\/ s * k + p - 1) \/\/ p)","output":"constant"},{"instruction":"n=int(input())\nprint((n+n%2)*((n+2)\/\/2)\/\/2)","output":"linear"},{"instruction":"import sys,os,io\nfrom sys import stdin\nimport math\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i):\n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x \/\/ spf[x]\n    return ret\n\ndef SieveOfEratosthenes(n):\n\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\nn,m,k = li()\ndp = [0]*(k+1)\nl = []\nfk = None\nfor _ in range(n):\n    s = list(si())\n    d = []\n    if list(set(s))==['0']:\n        d.append(0)\n        continue\n    one = []\n    for i in range(len(s)):\n        if s[i]=='1':\n            one.append(i)\n    ni = len(one)\n    d = [1e9]*(ni+1)\n    d[-1]=0\n    for i in range(ni):\n        for j in range(i, ni):\n            d[ni-(j-i+1)] = min(d[ni-(j-i+1)], one[j]-one[i]+1)\n    l.append(d)\n    fk = [1e9]*(k+1)\n    for i in range(k+1):\n        for j in range(ni+1):\n            if i+j>k:\n                break\n            fk[i+j] = min(fk[i+j] , dp[i] +d[j])\n    dp = fk[:]\n\nprint(min(dp))","output":"cubic"},{"instruction":"import sys,os,io\nimport math,bisect,operator\ninf,mod = float('inf'),10**9+7\n\nfrom itertools import groupby,accumulate\nfrom heapq import heapify,heappop,heappush\nfrom collections import deque,Counter,defaultdict\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nNeo = lambda : list(map(int,input().split()))\n\nA = sorted(Neo())\nB = [0]*100\nfor i in A:\n    j = 0\n    for c in range(100):\n        if B[c] == 0:\n            j = c\n            break\n\n    while j < 100:\n        B[j] = 1\n        j += i\nif B.count(0) == 0:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,k=get_ints()\n    arr=get_list()\n    ans=arr.copy()\n    ans.sort(reverse=True)\n    ans=ans[:k]\n    c=k\n    print(sum(ans))\n    j = 0\n    for i in range(n):\n        if (arr[i] in ans and c != 1):\n            print(i + 1 - j, end=' ')\n            j = i + 1\n            ans.remove(arr[i])\n            c -= 1\n        if (c == 1):\n            print(n - j)\n            break","output":"nlogn"},{"instruction":"from itertools import permutations,combinations\nfrom math import factorial\nword1 = list(map(str,input()))\nword2 = list(map(str,input()))\nexpected = 0\nfor i in word1:\n    if i=='+':\n        expected+=1\n    else:\n        expected-=1\nblank = 0\nfor i in word2:\n    if i=='+':\n        expected-=1\n    elif i=='-':\n        expected+=1\n    else:\n        blank+=1\nif abs(expected)>blank:\n    print(float(0))\nelif blank==0:\n    if expected==0:\n        print(1)\n    else:\n        print(0)\nelse:\n    total = 2**blank\n    if expected==blank-1:\n        print(float(0))\n    else:\n        f = (blank-expected)\/\/2\n        if expected>0:\n            a,b = expected+f,f\n        elif expected<0:\n            a,b = expected+f,f\n        else:\n            a,b = f,f\n        ans = factorial(a+b)\/(factorial(a))\n        ans = ans\/factorial(b)\n        ans = ans\/total\n        print(ans)","output":"np"},{"instruction":"from sys import stdin, stdout, exit\n\nt1, t2, t3 = stdin.readline().split()\n\nif t1 == t2 and t2 == t3:\n    print(0)\n    exit()\n\nts = [(int(t[0]), t[1]) for t in [t1, t2, t3]]\nts.sort()\nns = [t[0] for t in ts]\nss = [t[1] for t in ts]\n\nif ns[0] + 1== ns[1] and ns[0] + 2 == ns[2] and ss[0] == ss[1] and ss[1] == ss[2]:\n    print(0)\n    exit()\nif ns[0] + 2 >= ns[1] and ss[1] == ss[0]:\n    print(1)\n    exit()\nif ns[1] + 2 >= ns[2] and ss[1] == ss[2]:\n    print(1)\n    exit()\nif ns[0] + 2 >= ns[2] and ss[0] == ss[2]:\n    print(1)\n    exit()\nif ts[0] == ts[1] or ts[1] == ts[2] or ts[2] == ts[0]:\n    print(1)\n    exit()\n\nprint(2)","output":"nlogn"},{"instruction":"n, k = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nans = [-1] * (max(p) + 1)\nans[0] = 0\nfor i in range(n):\n\tif ans[p[i]] < 0:\n\t\tposition = p[i] - k + 1\n\t\tfor j in range(max(0,p[i] - k + 1), p[i] + 1):\n\t\t\tif ans[j] < 0:\n\t\t\t\tposition = j\n\t\t\t\tbreak\n\t\tj = max(0, position - 1)\n\t\tkey = ans[j]\n\t\tcount = 0\n\t\twhile j >= 0:\n\t\t\tif ans[j] != key:\n\t\t\t\tposition1 = j + 1\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tcount += 1\n\t\tif count + p[i] + 1 - position > k:\n\t\t\tkey = position\n\t\tfor j in range(position, p[i] + 1):\n\t\t\tans[j] = key\n\nfor i in range(n):\n\tif i != len(p) - 1:\n\t\twk1 = \" \"\n\telse:\n\t\twk1 = \"\\n\"\n\tprint(ans[p[i]], end = wk1)","output":"quadratic"},{"instruction":"DV = 10**9 +7\n\nx , k = list(map(int , input().split()))\n\nmult = pow (2, k, DV)\nif x == 0:\n    print(0)\nelse:\n    print((2*mult*x - mult +1) % DV)","output":"logn"},{"instruction":"q=int(input())\n\nfor e in range(q):\n    x,y,k=map(int,input().split())\n    x,y=abs(x),abs(y)\n    x,y=max(x,y),min(x,y)\n\n    if(x%2!=k%2):\n        k-=1\n        y-=1\n\n    if(x>k):\n        print(-1)\n        continue\n    if((x-y)%2):\n        k-=1\n        x-=1\n    print(k)","output":"constant"},{"instruction":"import sys,os,io\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmaxbits = 22\nmaxmask = 1<<maxbits\ndp = [-1]*(maxmask)\nn = int(input())\na = [int(x) for x in input().split()]\nb = a[:]\nP = [0]*n\nfor i in a:\n    dp[i]=i\n\nfor exp in range(maxbits):\n    for i in range(maxmask):\n        if i&(1<<exp):\n            if dp[i]==-1:\n                dp[i]=dp[i-(1<<exp)]\n\nfor i in range(n):\n    maxx = maxmask-1\n    print(dp[maxx^a[i]],end=\" \")","output":"np"},{"instruction":"from math import factorial,pow\ns1=list(input())\ns2=list(input())\nS1={\"+\":0, \"-\":0}\nS2={\"+\":0, \"-\":0, \"?\":0}\nfor i in s1:\n    S1[i]+=1\nfor i in s2:\n    S2[i]+=1\nif S1[\"+\"]-S2[\"+\"]>=0 and S1[\"-\"]-S2[\"-\"]>=0:\n    pos=S1[\"+\"]-S2[\"+\"]\n    neg=S1[\"-\"]-S2[\"-\"]\n    ques=S2[\"?\"]\n    res=(factorial(pos+neg)\/(factorial(pos)*factorial(neg)))\/pow(2,ques)\n    print(\"%.12f\"%res)\nelse:\n    print(\"%.12f\" % 0)","output":"np"},{"instruction":"n=int(input())\nar=list(map(int,input().split()))\nd={};ans=0\nfor i in ar:d[i]=d.get(i,0)+1\nfor i in ar:\n  flag=False\n  for j in range(31):\n    k=2**j;\n    if k>=i:\n     k1=k-i\n     if i!=k1 and d.get(k1,0)>0:flag=True;break\n     if i==k1 and d.get(i,0)>1:flag=True;break\n  if not flag:ans+=1\n\nprint(ans)","output":"nlogn"},{"instruction":"from sys import exit\nt = input().split()[:3:]\ns = set(t)\nres = 3\nif len(s)==1:\n\tres = min(res,0)\nelif len(s)==2:\n\tres = min(res,1)\nelif len(s)==3:\n\tres = min(res,2)\nif res==0:\n\tprint(res)\n\texit(0)\nt.sort()\nm = [int(a[0]) for a in t if a[1]=='m']\np = [int(a[0]) for a in t if a[1]=='p']\ns = [int(a[0]) for a in t if a[1]=='s']\ndef f(a):\n\tres = 2\n\tfor i in a:\n\t\tif (i-1 in a and i+1 in a)or(i-2 in a and i-1 in a)or(i+1 in a and i+2 in a):\n\t\t\treturn 0\n\t\telif i-1 in a or i+1 in a or i-2 in a or i+2 in a:\n\t\t\tres = min(res,1)\n\treturn res\nres = min([res,f(m),f(p),f(s)])\nprint(res)","output":"nlogn"},{"instruction":"import sys\n\ndef time_distance(v0, a, d):\n\n  return (-v0 + (v0**2 + 2*a*d)**0.5)\/a\n\ndef time_accelerating(v0, v1, a):\n  return (v1 - v0)\/a\n\ndef time_speed(v, d):\n  return d\/v\n\ndef distance_travelled(v0, t, a):\n  return v0*t + (a\/2)*t**2\n\ndef main():\n  a, v = map(int,sys.stdin.readline().strip().split())\n  l, d, w = map(int,sys.stdin.readline().strip().split())\n\n  time = 0\n\n  time_to_d = time_distance(0, a, d)\n  time_to_v = time_accelerating(0, v, a)\n\n  if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n\n    acceleration_time = time_to_v\n    acceleration_distance = distance_travelled(0, acceleration_time, a)\n\n    if acceleration_distance >= l:\n\n      time = time_distance(0, a, l)\n    else:\n\n      time = acceleration_time\n\n      time += time_speed(v, l - acceleration_distance)\n\n  else:\n    if time_to_v <= time_to_d:\n\n      acceleration_time = time_to_v\n      acceleration_distance = distance_travelled(0, acceleration_time, a)\n\n      deceleration_time = time_accelerating(v, w, -a)\n      deceleration_distance = distance_travelled(v, deceleration_time, -a)\n\n    if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n\n      acceleration_time = time_accelerating(0, w, a)\n      acceleration_distance = distance_travelled(0, acceleration_time, a)\n\n      remaining_distance = d - acceleration_distance\n\n      delta_time = time_distance(w, a, remaining_distance\/2)\n\n      time = acceleration_time + 2*delta_time\n    else:\n\n      time = time_to_v\n\n      time += time_speed(v, d - deceleration_distance - acceleration_distance)\n\n      time += deceleration_time\n\n    acceleration_time = time_accelerating(w, v, a)\n    acceleration_distance = distance_travelled(w, acceleration_time, a)\n    if acceleration_distance >= l - d:\n\n      time += time_distance(w, a, l - d)\n    else:\n\n      time += acceleration_time\n\n      time += time_speed(v, l - (d + acceleration_distance))\n\n  sys.stdout.write('{0:.5f}'.format(time) + '\\n')\n\nif __name__ == '__main__':\n  main()","output":"constant"},{"instruction":"def comp(a,b):\n    x=len(a)\n    s1=''\n    s2=''\n    for i in range(x):\n        s1+=str(a[i])\n        s2+=str(b[i])\n    if s1>s2:\n        return 1\n    else:\n        return 0\n\na=list(input(''))\nb=list(input(''))\ncnt=[0]*10\nn=len(a)\nm=len(b)\nsol=''\nfor i in range(n):\n    a[i]=int(a[i])\n    cnt[a[i]]+=1\n\nif n!=m:\n    a.sort(reverse=True)\n    for i in a:\n        sol+=str(i)\n    print(sol)\nelse:\n    a.sort()\n\n    for i in range(n):\n        b[i]=int(b[i])\n    for i in range(n-1):\n        for j in range(i,n):\n            if a[i]<a[j]:\n                temp=a[i]\n                a[i]=a[j]\n                a[j]=temp\n                if comp(a,b):\n                    temp=a[i]\n                    a[i]=a[j]\n                    a[j]=temp\n\n    for i in a:\n        sol+=str(i)\n    print(sol)","output":"cubic"},{"instruction":"from sys import stdin,stdout\nfrom collections import Counter\nnmbr=lambda:int(stdin.readline())\nlst = lambda: list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    a=lst()\n    b=sorted(a)\n    op=0\n    for i in range(n):\n        if a[i]==b[i]:continue\n        op+=1\n    if op==0 or op==2:print('YES')\n    else:print('NO')","output":"nlogn"},{"instruction":"def main():\n    n = int(input())\n\n    arr = list(map(int, input().split()))\n    numb = [0 for i in range(n + 1)]\n    for i in range(len(arr)):\n        numb[arr[i]] = i + 1\n\n    brr = list(map(int, input().split()))\n    ind = 0\n    for c in brr:\n        total = 0\n        num = numb[c]\n        if num > ind:\n            total = num - ind\n            ind = num\n        print(total, end=' ')\n\nmain()","output":"linear"},{"instruction":"a,b,c=list(map(int,input().split()))\nR=list(map(int,input().split()))\nG=list(map(int,input().split()))\nB=list(map(int,input().split()))\ndp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]\n\nR.sort()\nG.sort()\nB.sort()\nfor i in range(len(R)+1):\n    for j in range(len(G)+1):\n        for k in range(len(B)+1):\n            if(i and j):\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])\n            if(j and k):\n                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])\n            if(i and k):\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])\nprint(dp[len(R)][len(G)][len(B)])","output":"cubic"},{"instruction":"from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef mapin():\n    return map(int, input().split())\n\ns = list(input())\nn = len(s)\nl = [1]\nfor i in range(n-1):\n    if(s[i]!= s[i+1]):\n        l[-1]+=1\n    else:\n        l.append(1)\n\nans = max(l)\nif(len(l)>1):\n    if(s[0]!= s[-1]):\n        ans = max(ans, l[0]+l[-1])\n\nprint(ans)","output":"linear"},{"instruction":"import math\nn,k=map(int,input().split())\nn-=1\nk-=1\nif n>(k*(k+1))\/\/2:\n    print(-1)\nelse:\n    l=-1\n    r=k+1\n    while r>l+1:\n        m=(l+r)\/\/2\n        if n>(m*(2*k-m+1))\/\/2:\n            l=m\n        else:\n            r=m\n    print(r)","output":"logn"},{"instruction":"n, k = map(int, input().split())\nP = map(int, input().split())\n\nparent = list(range(256))\nsz = [1] * 256\ndef rt(x):\n    if x != parent[x]:\n        parent[x] = rt(parent[x])\n    return parent[x]\n\ndef u(rx, ry):\n    parent[ry] = rx\n    sz[rx] += sz[ry]\n\nans = [0] * n\nfor i, p in enumerate(P):\n    rx = rt(p)\n    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:\n        u(rt(rx - 1), rx)\n        rx = rt(p)\n    ans[i] = rt(p)\nprint(' '.join(map(str, ans)))","output":"quadratic"},{"instruction":"import math\nn, r = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\nans = []\nfor i in range(n):\n    t = r\n    for j in range(i):\n        a = abs(x[i] - x[j])\n        if a <= 2 * r:\n            t2 = (2 * r)**2\n            t2 -= a**2\n            t2 = math.sqrt(t2) + ans[j]\n            t = max(t, t2)\n    ans.append(t)\nfor k in ans:\n    print(k)","output":"quadratic"},{"instruction":"from os import path\nimport sys,time\n\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import *\n\nmaxx = float('inf')\n\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n\ns=S()\nans = s.replace('1','')+'2'\nt =  ans.find('2')\n\nprint(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"linear"},{"instruction":"import math\ninput_list =   lambda:  list(map(int, input().split()))\n\nn = int(input())\na = input_list()\nrows, cols = (n+1, n+1)\ndp = [[-1 for i in range(rows)] for j in range(cols)]\nfor i in range(n):\n    dp[i][i] = a[i]\nfor last in range(1, n):\n    for first in range(last - 1, -1, -1):\n        for mid in range(last, first, -1):\n            if dp[first][mid-1]!=-1 and dp[mid][last]!=-1 and dp[first][mid-1] == dp[mid][last]:\n                dp[first][last] = dp[first][mid-1] + 1\n\nans = [0 for i in range(n)]\nfor i in range(n):\n    ans[i] = i+1\n\nfor i in range(n):\n    for j in range(i, -1, -1):\n        if (j-1>=0):\n            if (dp[j][i]!=-1):\n                ans[i] = min(ans[i], ans[j-1] + 1)\n        elif (dp[0][i]!=-1):\n            ans[i] = 1\n\nprint(ans[n-1])","output":"cubic"},{"instruction":"import sys,math,bisect\nfrom random import randint\ninf = float('inf')\nmod = 998244353\n\"========================================\"\ndef lcm(a,b):\n    return int((a\/math.gcd(a,b))*b)\ndef gcd(a,b):\n    return int(math.gcd(a,b))\ndef tobinary(n):\n    return bin(n)[2:]\ndef binarySearch(a,x):\n    i = bisect.bisect_left(a,x)\n    if i!=len(a) and a[i]==x:\n        return i\n    else:\n        return -1\ndef lowerBound(a, x):\n    i = bisect.bisect_left(a, x)\n    if i:\n        return (i-1)\n    else:\n        return -1\ndef upperBound(a,x):\n    i = bisect.bisect_right(a,x)\n    if i!= len(a)+1 and a[i-1]==x:\n        return (i-1)\n    else:\n        return -1\ndef primesInRange(n):\n    ans = []\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n+1):\n        if prime[p]:\n            ans.append(p)\n    return ans\ndef primeFactors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n \/\/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            factors.append(i)\n            n = n \/\/ i\n    if n > 2:\n        factors.append(n)\n    return factors\ndef isPrime(n,k=5):\n    if (n <2):\n        return True\n    for i in range(0,k):\n        a = randint(1,n-1)\n        if(pow(a,n-1,n)!=1):\n            return False\n    return True\n\"=========================================\"\n\nfrom collections import deque,defaultdict,Counter\nimport heapq,string\n\nn=int(input())\ns=input()\ns=[int(i) for i in s]\nflag=False\nfor i in range(0,(9*n)+1):\n    count=0\n    sum = 0\n    for j in s:\n        sum+=j\n        if sum==i:\n            count+=1\n            sum=0\n    if count>1 and sum==0:\n        print('YES')\n        exit(0)\nprint('NO')","output":"quadratic"},{"instruction":"def res(d,N):\n    for i in range(1,N):\n        if d[i][1] <= d[i-1][1]:\n            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)\n    return '-1 -1'\n\nN = int(input())\nd = []\nfor i in range(N):\n    a,b = map(int,input().split())\n    d.append((a,b,i))\nd = sorted(d, key = lambda x:(x[0],-x[1]))\nprint(res(d,N))","output":"nlogn"},{"instruction":"import math\ndef cm(n,r):\n    i = n - r\n    C = (math.factorial(n))\/(math.factorial(i)*math.factorial(r))\n    return C\n\ns1 = input()\ns2 = input()\nd1={}\nd2={}\nd1['+']=0\nd1['-']=0\nd2['+']=0\nd2['-']=0\nd2['?']=0\nr=0\nans=-1\nfor c in s1:\n    d1[c]+=1\nfor c in s2:\n    d2[c]+=1\n\nnp = d1['+']-d2['+']\nnn = d1['-']-d2['-']\nif np<0 or nn<0:\n    ans=0\nelse:\n    n=d2['?']\n    r=min(np,nn)\n    ans=cm(n,r)\n    ans = round(float(ans)\/float(math.pow(2,n)),9)\nprint(ans)","output":"np"},{"instruction":"n,s = [int(x) for x in input().split()]\ndef check(x):\n    y = list(str(x))\n    ans = x\n    for i in y:\n        ans-=int(i)\n    if (ans>=s):\n        return True\n    return False\n\nans = 0\nl = 1\nr = n\nwhile(l<=r):\n    m = (l+r)\/\/2\n    if (check(m)):\n        ans = n-m+1\n        r = m-1\n    else:\n        l = m+1\nprint(ans)","output":"logn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(10)]\npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n                pp[i]+=1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=0\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid][0] > key):\n            right = mid-1\n        else:\n            res=mid\n            left = mid + 1\n    return res\n\nn,m,k=map(int,input().split())\nr=[]\nfor i in range (n):\n    a=list(map(int,input().split()))\n    r.append(a)\nc=[]\nfor i in range (n-1):\n    a=list(map(int,input().split()))\n    c.append(a)\nif k%2:\n    a=[-1]*m\n    for i in range (n):\n        print(*a)\n    sys.exit(0)\ndp=[[[0 for i in range ((k\/\/2)+1)]for j in range (m)]for p in range (n)]\nfor x in range (1,(k\/\/2)+1):\n    for i in range (n):\n        for j in range (m):\n            mn=10**8\n            if i>0:\n                mn=min(mn,c[i-1][j]+dp[i-1][j][x-1])\n            if j>0:\n                mn=min(mn,r[i][j-1]+dp[i][j-1][x-1])\n            if i<n-1:\n                mn=min(mn,c[i][j]+dp[i+1][j][x-1])\n            if j<m-1:\n                mn=min(mn,r[i][j]+dp[i][j+1][x-1])\n            dp[i][j][x]=mn\nfor i in range (n):\n    for j in range (m):\n        print(2*dp[i][j][k\/\/2],end=' ')\n    print()","output":"cubic"},{"instruction":"n,k = map(int,input().split())\ns = input()\nf = 0\nfor i in range(1,n):\n    if s[:n-i]==s[i:]:\n        f=1\n        break\nif f==0:\n    print(s*k)\nelse:\n    j = n-i\n    final = s[j:]\n    print(s+final*(k-1))","output":"quadratic"},{"instruction":"import sys\nfrom heapq import heappush, heappop, heapify\nsys.setrecursionlimit(int(1e7))\n\ndef main():\n    n = int(input().strip())\n    a = [int(x) for x in input().split()]\n    a = [-x-1 if x>=0 else x for x in a]\n    if n%2==1:\n        _, i = min((x,i) for i,x in enumerate(a))\n        a[i] = -a[i]-1\n    print(*a)\n    return\n\nwhile 1:\n    try: main()\n    except EOFError: break","output":"linear"},{"instruction":"from sys import stdin, stdout\n\nMOD = 10 ** 9 + 7\n\ndef bin_pow(n, k):\n    res = 1\n\n    while k:\n        if k & 1:\n            res = (res * n) % MOD\n\n        n = (n * n) % MOD\n        k >>= 1\n\n    return res\n\nx, k = map(int, stdin.readline().split())\n\nif x == 0:\n    stdout.write('0')\nelse:\n    ans = (bin_pow(2, k + 1) * x - bin_pow(2, k) + 1) % MOD\n    stdout.write(str(ans))","output":"logn"},{"instruction":"n=int(input())\na=list(map(int, input().rstrip().split()))\na.sort()\nsum1=0\nrem=sum(a)\ni=len(a)-1\nc=0\nwhile(sum1<=rem):\n    sum1+=a[i]\n    rem=sum(a)-sum1\n    i-=1\n    c+=1\nprint(c)","output":"nlogn"},{"instruction":"n = int(input())\nchess = []\nfor w in range(3):\n    chess.append([input() for i in range(n)])\n    input()\nchess.append([input() for i in range(n)])\n\nissue = {0:0, 1:0, 2:0, 3:0}\nreversed_issue = {0:0, 1:0, 3:0}\n\nfor w in range(4):\n    chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]]\n    for s in range(2 * n):\n        chessdesk[0][s] += chessdesk[1][s]\n    chessdesk.pop(1)\n    chessdesk = chessdesk[0]\n    colour = chessdesk[0][0]\n\n    for i in range(2 * n):\n        for j in range(2 * n):\n            if (i + j) % 2 == 0:\n                if chessdesk[i][j] != colour:\n                    issue[w] += 1\n            else:\n                if chessdesk[i][j] == colour:\n                    issue[w] += 1\n\n    reversed_issue[w] = 4 * n**2 - issue[w]\n    if w == 0:\n        chess[0], chess[3] = chess[3], chess[0]\n    elif w == 1:\n        chess[1], chess[3] = chess[3], chess[1]\n    elif w == 2:\n        chess[1], chess[2] = chess[2], chess[1]\n\nprint(min(min(issue.values()), min(reversed_issue.values())))","output":"quadratic"},{"instruction":"def add(num):\n    if(num<=1):\n        return 0\n    return (num*(num-1))\/\/2\n\nn,k=map(int,input().split())\n\na=list(map(int,input().split()))\npre=[a[0]]\nbase=(2**(k))-1\nhb=2**(k-1)\nfor i in range(1,n):\n    pre.append(a[i]^pre[-1])\n\ncnt=dict()\ncnt[0]=[0,0]\n\nfor i in range(n):\n    if(pre[i]>=hb):\n        if(base-pre[i] not in cnt):\n            cnt[base-pre[i]]=[0,0]\n        cnt[base-pre[i]][1]+=1\n    else:\n        if(pre[i] not in cnt):\n            cnt[pre[i]]=[0,0]\n        cnt[pre[i]][0]+=1\ncnt1=0\n\nfor i in cnt.values():\n    sum1=i[0]+i[1]\n    cnt1+=add(sum1\/\/2)\n    cnt1+=add((sum1+1)\/\/2)\ncnt1+=sum(cnt[0])\/\/2\n\nprint((n*(n+1))\/\/2 - cnt1)","output":"linear"},{"instruction":"n, m, k, l = map(int, input().split())\nif m > n or (l + k + m - 1) \/\/ m * m > n:\n    print(-1)\nelse:\n    x = (l + k + m - 1) \/\/ m\n    print(x)","output":"constant"},{"instruction":"import random\nastr=input()\nN=int(astr)\ns=input()\nsk=s.split(' ')\nml=[int(i) for i in sk]\nkl=[0 for i in ml]\n\nk=0\nfor i in range(0,N):\n    if kl[i]==0:\n        kl[i]=1\n        j=ml[i]\n        k=k+1\n        while(kl[j-1]==0):\n            kl[j-1]=1\n            j=ml[j-1]\n\nif k%2==0: print(\"Petr\")\nelse: print(\"Um_nik\")","output":"nlogn"},{"instruction":"from math import inf\n\nn = int(input())\ns_list = list(map(int, input().split()))\nc_list = list(map(int, input().split()))\n\ntotal_min = inf\nfor j in range(n):\n    min_i = inf\n    for i in range(0, j):\n        if s_list[i] < s_list[j]:\n            min_i = min(min_i, c_list[i])\n\n    min_k = inf\n    for k in range(j + 1, n):\n        if s_list[k] > s_list[j]:\n            min_k = min(min_k, c_list[k])\n\n    total_min = min(total_min, min_i + c_list[j] + min_k)\nif total_min != inf:\n    print(total_min)\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"n, m = int(input()), int(input())\nvalue = False\nfor j in range(n + 1):\n    if pow(2, j) > m:\n        value = True\n        break\nif value:\n    print(m)\nelse:\n    print(m % pow(2, n))","output":"constant"},{"instruction":"n = input()\ns = input()\nn = int(n)\nprint('1'*min(s.count('1'), 1)+'0'*s.count('0'))","output":"linear"},{"instruction":"def norm(x):\n    return (x % 998244353 + 998244353) % 998244353\n\nn, k = map(int, input().split())\n\ndp1 = [0]\ndp2 = [0]\n\nfor i in range(n):\n    l = [1]\n    cur = 0\n    for j in range(n + 1):\n        cur += l[j]\n        if(j > i):\n            cur -= l[j - i - 1]\n        cur = norm(cur)\n        l.append(cur)\n    dp1.append(l[n])\n    dp2.append(norm(dp1[i + 1] - dp1[i]))\n\nans = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if(i * j < k):\n            ans = norm(ans + dp2[i] * dp2[j])\n\nans = norm(ans * 2)\n\nprint(ans)","output":"cubic"},{"instruction":"import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import defaultdict\n\nn,m = [int(i) for i in input().split()]\na = []\nmi = -1\nma = 10**9\nfor i in range (n):\n    a.append([int(j) for j in input().split()])\n\nans = []\nwhile(mi<ma):\n    mid = (mi+ma+1)\/\/2\n    masks = {}\n    for i in range (n):\n        currMask = 0\n        for j in range (m):\n            if a[i][j] >= mid:\n                currMask +=  1<<j\n        masks[currMask] = i\n    req = (1<<m) - 1\n    possible = 0\n    for i in masks:\n        for j in masks:\n            if i|j == req:\n                possible = 1\n                ans = [masks[i]+1,masks[j]+1]\n                break\n        if possible:\n            break\n    if possible:\n        mi = mid\n    else:\n        ma = mid - 1\nprint(*ans)","output":"np"},{"instruction":"n , k = map(int, input().split())\n\nl = 0\nr = n\nwhile r - l > 1:\n    mid = (r + l) \/\/ 2\n    a = n - mid\n    if ((1 + a) * a) \/\/ 2 >= k + mid:\n        l = mid\n    else:\n        r = mid\nprint(l)","output":"logn"},{"instruction":"a, b= map(int,input().split())\n\nif a == b:\n    print(0)\n\nelse:\n    x = a ^ b\n    c = 0\n\n    while x:\n        x \/\/= 2\n        c += 1\n\n    print(2**c-1)","output":"logn"},{"instruction":"def main():\n\tn, k = [int(_) for _ in input().split()]\n\ta = [int(_) for _ in input().split()]\n\n\tp = [-1] * 256\n\tp[0] = 0\n\n\tfor x in a:\n\t\tif p[x] < 0:\n\t\t\tfor y in range(x - 1, max(-1, x - k), -1):\n\t\t\t\tif p[y] >= 0:\n\t\t\t\t\tif p[y] + k > x:\n\t\t\t\t\t\tp[x] = p[y]\n\t\t\t\t\telse:\n\t\t\t\t\t\tp[x] = p[y + 1] = y + 1\n\n\t\t\t\t\tbreak\n\t\t\tif p[x] < 0:\n\t\t\t\tp[x] = p[x - k + 1] = x - k + 1\n\n\tb = [p[x] for x in a]\n\n\tprint(' '.join(map(str, b)))\n\nif __name__ == '__main__':\n\tmain()","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = sorted(list(set(map(int, input().split()))))\nn = len(a)\nused = [0] * n\ncnt = 0\nfor i in range(n):\n    if not used[i]:\n        used[i] = 1\n        cnt += 1\n        for j in range(i + 1, n):\n            if a[j] % a[i] == 0:\n                used[j] = 1\nprint(cnt)","output":"quadratic"},{"instruction":"n = int(input())\ns = list(input())\nd = list(input())\nif(sorted(s) != sorted(d)):\n    print(-1)\nelse:\n    ans = []\n    for i in range(n):\n        if(s[i] != d[i]):\n            for u in range(i+1,n):\n                if(s[u] == d[i]):\n                    ind = u\n                    break\n                else:ind = -1\n            if(ind == -1):print(-1);exit()\n            cnt = abs(ind - i)\n            s.pop(ind)\n            s.insert(i,d[i])\n\n            for k in range(cnt):\n                if(ind > 0):\n                    ans.append(ind)\n                else:\n                    ans.append(1)\n                ind -= 1\n    print(len(ans))\n    print(*ans)","output":"quadratic"},{"instruction":"n=int(input())\nprint('25')","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, m, k = map(int, input().split())\nA = [[0] * (m) for _ in range(n)]\nB = [[0] * (m) for _ in range(n)]\nfor i in range(n):\n    tmp = list(map(int, input().split()))\n    for j in range(m - 1):\n        A[i][j + 1] = tmp[j]\nfor i in range(n - 1):\n    tmp = list(map(int, input().split()))\n    for j in range(m):\n        B[i + 1][j] = tmp[j]\n\nif k % 2:\n    ans = [[-1] * m for _ in range(n)]\n    for a in ans:\n        print(*a)\n    sys.exit()\nans = [[0] * m for _ in range(n)]\nlim = k \/\/ 2\ndp = [[[float(\"inf\")] * (lim + 1) for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor k in range(1, lim + 1):\n    for i in range(n):\n        for j in range(m):\n            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])\n            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])\n            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])\n            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])\nfor i in range(n):\n    for j in range(m):\n        ans[i][j] = dp[i][j][-1] * 2\nfor a in ans:\n    print(*a)","output":"cubic"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n    if a[i]==a[i+1]==0:\n        lose=True\n    if a[i]==a[i+1]:\n        if pair:\n            lose=True\n        pair=True\n        if i>=1:\n            if a[i]==a[i-1]+1:\n                lose=True\nif lose:\n    print(\"cslnb\")\nelse:\n    eventual=n*(n-1)\/\/2\n    curr=sum(a)\n    if (curr-eventual)%2==0:\n        print(\"cslnb\")\n    else:\n        print(\"sjfnb\")","output":"nlogn"},{"instruction":"def resistors(a,b):\n    ans=0\n    while b:\n        ans+=a\/\/b\n        a,b=b,a%b\n    return ans\na,b=map(int,input().strip().split())\nprint(resistors(a,b))","output":"constant"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nres = 0\nsame = 0\np = 1\nfor h in a:\n\tif p <= h:\n\t\tp += 1\n\telse:\n\t\tsame += 1\nres = a[-1] + same\nprint(sum(a) - res)","output":"nlogn"},{"instruction":"from math import sqrt as sqrt\nn, k = map(int, input().split())\nt = int(sqrt(8 * n + 8 * k + 9) + 0.0001)\nm = (t - 3) \/\/ 2\nprint(n - m)","output":"constant"},{"instruction":"t = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    count_w = n * m \/\/ 2 + n * m % 2\n    count_g = n * m \/\/ 2\n    if (x1 + y1) % 2 == 0:\n        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n    else:\n        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2\n        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2\n    x5 = max(x1, x3)\n    x6 = min(x4, x2)\n    y5 = max(y1, y3)\n    y6 = min(y4, y2)\n    if (x3 + y3) % 2 == 1:\n        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) \/\/ 2\n        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) \/\/ 2\n    else:\n        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) \/\/ 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2\n        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) \/\/ 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2\n    if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6:\n        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) \/\/ 2\n        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) \/\/ 2\n    elif x5 <= x6 and y5 <= y6:\n        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) \/\/ 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2\n        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) \/\/ 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2\n    print(count_w, count_g)","output":"constant"},{"instruction":"test=int(input())\nfirst=[]\nfor i in range(test):\n    list_=list(map(int,input().split()))\n    sum_=sum(list_)\n    first.append(sum_)\nfirst_sum=first[0]\ncount=0\nfor i in first:\n    if first_sum<i:\n        count=count+1\n    else:\n        continue\nprint(count+1)","output":"linear"},{"instruction":"n, v = list(map(int, input().strip().split()))\n\nremaining_dist = n - 1\nadding = min(remaining_dist, v)\ncost = adding\n\nremaining_dist -= adding\n\ni = 2\nwhile remaining_dist > 0:\n    cost += i\n    i += 1\n    remaining_dist -= 1\n\nprint(cost)","output":"linear"},{"instruction":"from sys import stdin, setrecursionlimit, stdout\n\nfrom collections import deque\nfrom math import sqrt, floor, ceil, log, log2, log10, pi, gcd, sin, cos, asin\nfrom heapq import heapify, heappop, heappush, heapreplace, heappushpop\nfrom bisect import bisect_right, bisect_left\ndef ii(): return int(stdin.readline())\ndef fi(): return float(stdin.readline())\ndef mi(): return map(int, stdin.readline().split())\ndef fmi(): return map(float, stdin.readline().split())\ndef li(): return list(mi())\ndef si(): return stdin.readline().rstrip()\ndef lsi(): return list(si())\nmod=1000000007\nres=['NO', 'YES']\n\naa=[9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999]\na=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]\n\ntest=1\ntest_case=1\nwhile test<=test_case:\n    test+=1\n\n    n=ii()\n    if n in a:\n        n=9\n    if n<10:\n        print(n)\n        exit()\n    x=1\n    while a[x]<n:\n        x+=1\n    v=n-a[x-1]\n    z=v\/\/(x+1)\n    z+=aa[x-1]\n    v%=x+1\n\n    if not v:\n        p=z%10\n    else:\n        z+=1\n        p=int(str(z)[v-1])\n    print(p)","output":"logn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nx,k=map(int,input().split())\nres=0\nmod=1000000007\nres=pow(2,k,mod)*(2*x-1)+1\nres%=mod\nif x==0:\n    res=0\nprint(res)","output":"logn"},{"instruction":"i = int(input())\nprint(int(i\/2) * 3)","output":"constant"},{"instruction":"n, m = map(int, input().split())\ns = input()\nt = input()\nif \"*\" in s:\n    front, back = s.split(\"*\")\n    if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"YES\" if s == t else \"NO\")","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\nfrom collections import Counter\n\ndef main():\n    n,k = map(int,input().split())\n    a = input().split()\n    a1 = list(map(int,a))\n    dct = [Counter() for _ in range(11)]\n    for i in range(n):\n        dct[len(a[i])][a1[i]%k] += 1\n    ans = 0\n    for i in range(n):\n        x = a1[i]\n        for j in range(1,11):\n            x = (x*10)%k\n            if x:\n                ans += dct[j][k-x]\n            else:\n                ans += dct[j][0]\n        if not (a1[i]*(pow(10,len(a[i]),k)+1))%k:\n            ans -= 1\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"N, M = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\n\nif max(b) > min(g):\n    ans = -1\nelif max(b) == min(g):\n    ans = M*sum(b)\n    maxi = max(b)\n    for i in range(M):\n        if maxi == g[i]:\n            continue\n        else:\n            ans += g[i] - maxi\nelse:\n    ans = M * sum(b)\n    b.sort(reverse = True)\n    for i in range(M):\n        if i == 0:\n            ans += g[i] - b[1]\n        else:\n            ans += g[i] - b[0]\nprint(ans)","output":"nlogn"},{"instruction":"import math\n\nif __name__ == '__main__':\n    n, m, k, l = map(int, input().split())\n    one_friend = (k + l) \/\/ m + int((k + l) % m != 0)\n    if one_friend * m > n:\n        print(-1)\n    else:\n        print(one_friend)","output":"constant"},{"instruction":"n, m, k = map(int,input().split())\nline = [int(x) for x in input().split()]\nline.sort(reverse = True)\ncount = 0\nif k >=m:\n    print(count)\n    exit(0)\nfor i in range(n):\n    k += line[i]-1\n    count += 1\n    if k >= m:\n        print(count)\n        exit(0)\nprint(-1)","output":"nlogn"},{"instruction":"import sys\nfrom array import array\n\ndef readline(): return sys.stdin.buffer.readline().decode('utf-8')\n\nn, k = map(int, readline().split())\nmod = 998244353\n\nif k == 1:\n    print(0)\n    exit()\n\ndp1 = [array('i', [0])*n for _ in range(n)]\ndp2 = [array('i', [0])*n for _ in range(n)]\ndp1[0][0] = 1\n\nfor i in range(n-1):\n    for j in range(i+1):\n        for l in range(j+1):\n            dp2[j][0] += dp1[j][l]\n            if dp2[j][0] >= mod:\n                dp2[j][0] -= mod\n\n            dp2[j+1 if j == l else j][l+1] += dp1[j][l]\n            if dp2[j+1 if j == l else j][l+1] >= mod:\n                dp2[j+1 if j == l else j][l+1] -= mod\n\n            dp1[j][l] = 0\n\n    dp1, dp2 = dp2, dp1\n\nans = 0\nfor i in range(1, n+1):\n    t = (k-1) \/\/ i\n    if t == 0:\n        break\n\n    dps1 = array('i', [0])*(t+1)\n    dps2 = array('i', [0])*(t+1)\n    dps1[0] = 1\n\n    for j in range(n-1):\n        for l in range(min(j+1, t)):\n            dps2[0] += dps1[l]\n            if dps2[0] >= mod:\n                dps2[0] -= mod\n\n            dps2[l+1] += dps1[l]\n            if dps2[l+1] >= mod:\n                dps2[l+1] -= mod\n\n            dps1[l] = 0\n\n        dps1, dps2 = dps2, dps1\n\n    x = sum(dp1[i-1]) % mod\n    ans = (ans + x * sum(dps1[:-1])) % mod\n\nprint(ans * 2 % mod)","output":"quadratic"},{"instruction":"def check(mid):\n    added = n - mid\n    total = ((added)*(added+1))\/\/2\n    return total - mid >= k\n\nn,k = map(int,input().split())\nlow = 0\nhigh = n-1\nwhile low < high:\n    mid = (low+high+1)\/\/2\n\n    if check(mid):\n        low = mid\n    else:\n        high = mid - 1\nprint(low)","output":"logn"},{"instruction":"k, n, s, p = map(int, input().split())\n\npaper_person = (n + s -1)\/\/s\n\ntotal_needed = paper_person * k\n\nans = (total_needed+p-1)\/\/p\n\nprint(ans)","output":"constant"},{"instruction":"m=[x for x in input().split()]\ntiles=[[0 for i in range(9)] for j in range(3)]\nfor i in range(len(m)):\n    g=int(m[i][0])-1\n    h=(m[i][1])\n    if h==\"m\":\n        tiles[0][g]+=1\n    elif h==\"p\":\n        tiles[1][g]+=1\n    else:\n        tiles[2][g]+=1\nif m[0]==m[1] and m[1]==m[2]:\n    print(0)\nelif m[0]==m[1]:\n    print(1)\nelif m[0]==m[2]:\n    print(1)\nelif m[1]==m[2]:\n    print(1)\nelse:\n    n=False\n    for i in range(3):\n        for j in range(9):\n            if tiles[i][j]!=0:\n                if j!=8 and tiles[i][j+1]!=0:\n                    if j!=7 and tiles[i][j+2]!=0:\n                        print(0)\n                        n=True\n                        break\n                    else:\n                        print(1)\n                        n=True\n                        break\n                elif j!=7 and j!=8 and tiles[i][j+2]!=0:\n                    print(1)\n                    n=True\n                    break\n    if n==False:\n        print(2)","output":"linear"},{"instruction":"s1, s2 = input().split()\nans = 'z' * 21\nfor i in range(1, len(s1) + 1):\n    for j in range(1, len(s2) + 1):\n        ans = min(ans, s1[:i] + s2[:j])\nprint(ans)","output":"linear"},{"instruction":"n,m = map(int,input().split())\nxi = list(map(int,input().split()))\nti = list(map(int,input().split()))\nai = [0] * (m+2)\nar = [0] * (m+2)\nar[-1] = 10**11\nar[0] = -100000000000\nj = 1\nn2 = n + m\nfor i in range(n2):\n    if ti[i] == 1:\n        ar[j] = xi[i]\n        j += 1\ni1 = 0\ni2 = 1\nfor i in range(n2):\n        if ti[i] == 1:\n            i2 += 1\n            i1 += 1\n            continue\n        num = xi[i] - ar[i1]\n        num2 = ar[i2] - xi[i]\n        if num <= num2:\n            ai[i1] += 1\n        else:\n            ai[i2] += 1\nfor i in range(1,m+1):\n    print(ai[i],end=\" \")","output":"linear"},{"instruction":"n, s = list(map(int, input().split()))\n\ndef sum_of_digits(n):\n\tans = 0\n\tfor c in str(n):\n\t\tans += int(c)\n\treturn ans\nm = s + 10 - s%10\n\nwhile m - sum_of_digits(m) < s:\n\tm += 10\nif m <= n:\n\tprint(n - m + 1)\nelse:\n\tprint(0)","output":"logn"},{"instruction":"import sys\nimport math\nimport collections\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,k=get_ints()\n    arr=get_list()\n    ans=0\n    for i in range(n):\n        val=arr[i]\n        c=1\n        sol=0\n        if c >= k:\n            sol = max(sol, val \/ c)\n        for j in range(i+1,n):\n            val+=arr[j]\n            c+=1\n            if c>=k:\n                sol=max(sol,val\/c)\n        ans=max(sol,ans)\n    print(ans)","output":"quadratic"},{"instruction":"import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\nfrom itertools import permutations\nimport heapq\n\nI=sys.stdin.readline\n\nalpha=\"abcdefghijklmnopqrstuvwxyz\"\n\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer \/\/ denom\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\treturn False\n\t\treturn True\n\ndef main():\n\n\tn=ii()\n\tarr=li()\n\n\tsett=set(arr)\n\n\tpower=[2**i for i in range(32)]\n\n\tans=[]\n\n\tfor i in power:\n\t\tfor j in arr:\n\t\t\ttmp=[j]\n\t\t\tfor k in range(2):\n\t\t\t\tif tmp[-1]+i in sett:\n\t\t\t\t\ttmp.append(tmp[-1]+i)\n\n\t\t\tif len(tmp)>len(ans):\n\n\t\t\t\tans=[x for x in tmp]\n\n\t\t\tif len(ans)==3:\n\t\t\t\tbreak\n\n\t\tif len(ans)==3:\n\t\t\tbreak\n\n\tprint(len(ans))\n\tprint(*ans)\n\nif __name__ == '__main__':\n\tmain()","output":"nlogn"},{"instruction":"(x, y, z, t1, t2, t3) = map(int, input().split())\n\nif 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"from sys import stdout\n\ndef get_ans(c, d, curaM, curbM):\n    a_ = a ^ c ^ curaM\n    b_ = b ^ d ^ curbM\n\n    if a_ > b_:\n        return 1\n\n    if a_ < b_:\n        return -1\n\n    return 0\n\ndef get_ans_(c, d, curaM, curbM):\n    a_ = c ^ curaM\n    b_ = d ^ curbM\n\n    print('? {} {}'.format(a_, b_))\n    stdout.flush()\n\n    return int(input())\n\ncuraM  = 0\ncurbM  = 0\ncurC   = get_ans_(0,0,0,0)\n\nfor i in range(29, -1, -1):\n    ans1 = get_ans_(1<<i, 0, curaM, curbM)\n    ans2 = get_ans_(0, 1<<i, curaM, curbM)\n\n    if ans1 * ans2 >= 0:\n        if curC == 1:\n            curaM |= 1 << i\n        elif curC == -1:\n            curbM |= 1 << i\n\n        curC = ans1\n    else:\n        if ans1 < 0:\n            curaM |= 1 << i\n            curbM |= 1 << i\n\nprint('! {} {}'.format(curaM, curbM))","output":"logn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\na=a[::-1]\nc=[0]*n\nbk=[]\nfor i in range(n):\n    co=0\n    if c[b[i]-1]==0:\n        while a[-1]!=b[i]:\n            co+=1\n            c[a[-1]-1]=1\n            a.pop()\n        co+=1\n        c[a[-1]-1]=1\n        a.pop()\n    bk.append(co)\nprint(*bk)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\nmod = int(1e9) + 7\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n \/\/ 2)\n    return (t * t) % mod\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n \/\/= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n \/\/= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    same = 0\n    ind = -1\n    poss=1\n    for i in range(1, n):\n        same += (a[i] == a[i - 1])\n        if a[i]==a[i-1]:\n            ind = i - 1\n            if a[i]==0:\n                poss=0\n    if same > 1 or poss==0:\n        print('cslnb')\n    else:\n        if ind > 0:\n            if a[ind] - a[ind - 1] == 1:\n                print('cslnb')\n                return\n        c = 0\n        for i in range(n):\n            c += a[i] - i\n        if c % 2:\n            print('sjfnb')\n        else:\n            print('cslnb')\n\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n=int(input())\nl=[4,7,47,74,44,77,447,444,474,777,747,744,477]\nc=0\nfor i in range(len(l)):\n    if n%l[i]==0:\n        c=1\n        break\nif c==1:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\ns = input()[:-1]\nleft, right = 0, n\nwhile left < right:\n    mid = right - (right - left) \/\/ 2\n    A = [[0] * (n + 2) for _ in range(k)]\n\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1\n        L = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1\n            else: L = 0\n            A[c][i] = i + mid if L >= mid else A[c][i + 1]\n\n    dp = [n + 1] * (1 << k)\n    dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i\n            dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)","output":"np"},{"instruction":"def factorial(n):\n    r = 1\n    for i in range(2, n + 1):\n        r *= i\n    return r\n\ndef n_choose_k(n, k):\n    return factorial(n) \/\/ (factorial(k) * factorial(n - k))\n\ndef solve(diff, u):\n    pluses = u + 1\n    n = 2 ** u\n    for i in range(unknown, -unknown - 1, -2):\n        pluses -= 1\n        if diff == i:\n            k = n_choose_k(u, pluses)\n            return k \/ n\n    return 0\n\ns1 = input()\ns2 = input()\nk = 0\ncorrect_p = 0\npred_p = 0\nunknown = 0\nfor c in s1:\n    correct_p += 1 if c == '+' else -1\nfor c in s2:\n    if c in '+-':\n        pred_p += 1 if c == '+' else -1\n    else:\n        unknown += 1\np = 1 if unknown == 0 and correct_p == pred_p else solve(correct_p - pred_p, unknown)\nprint('{0:.9f}'.format(p))","output":"np"},{"instruction":"import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\n\nn=int(input())\nP=list(map(int,input().split()))\n\nLIST=[0]*(n+1)\n\nLEAF=[1]*(n+1)\nfor p in P:\n    LEAF[p]=0\n\nfor i in range(1,n+1):\n    if LEAF[i]==1:\n        LIST[i]=1\n\nfor i in range(n,1,-1):\n    LIST[P[i-2]]+=LIST[i]\n\ncounter=Counter(LIST[1:])\n\nSUM=[0]\nSC=sorted(counter.keys())\n\nfor j in SC:\n    SUM.append(SUM[-1]+counter[j])\n\ni=1\nj=0\nwhile j<len(SUM):\n    if i<=SUM[j]:\n        print(SC[j-1],end=\" \")\n    else:\n        j+=1\n        continue\n\n    i+=1","output":"nlogn"},{"instruction":"n, m = int(input()), int(input())\nprint(m % (2 ** n) if n < 30 else m)","output":"constant"},{"instruction":"m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for xx,ii in zip(values,idx):\n        if (xx^x) < x:\n            x^=xx\n            ans^=ii\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)!=0:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))","output":"np"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nN, M, K = map(int, input().split())\nP = []\nD_P = {}\n\nfor i in range(N):\n\tS = input()\n\tP.append(S)\n\tD_P[S] = i\n\nadj = [[] for _ in range(N)]\nindeg = [0] * N\n\nfor _ in range(M):\n\tS, mt = input().split()\n\tmt = int(mt)-1\n\n\tfp = P[mt]\n\n\tif any(fp[i] not in (S[i], '_') for i in range(K)):\n\t\tprint('NO')\n\t\traise SystemExit\n\n\tfor bs in range(1<<K):\n\t\tpat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))\n\t\tif pat == fp: continue\n\t\tif pat in D_P:\n\t\t\tj = D_P[pat]\n\t\t\tindeg[j] += 1\n\t\t\tadj[mt].append(j)\n\nQ = [i for i in range(N) if indeg[i] == 0]\nfor i in Q:\n\tfor j in adj[i]:\n\t\tindeg[j] -= 1\n\t\tif indeg[j] == 0:\n\t\t\tQ.append(j)\n\nif len(Q) == N:\n\tprint('YES')\n\tprint(' '.join(str(v+1) for v in Q))\nelse:\n\tprint('NO')","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nsumm=0\na.sort()\nif len(a)==1:\n    if a[0]%2==1:\n        print('sjfnb')\n    else:\n        print('cslnb')\nelif a[0] == a[1]==0:\n    print('cslnb')\nelse:\n    x = False\n    for i in range(2, n):\n        if a[i]==a[i-1] and a[i-1]==a[i-2]:\n            x=True\n    if x:\n        print('cslnb')\n    else:\n        x = False\n        for i in range(2, n):\n            if a[i]==a[i-1] and a[i]-1==a[i-2]:\n                x=True\n        if x:\n            print('cslnb')\n        else:\n            summ=0\n            for i in range(1, n):\n                if a[i]==a[i-1]:\n                    summ+=1\n            if summ>1:\n                print('cslnb')\n            else:\n                summ=0\n                for i in range(n):\n                    summ+=a[i]-i\n                if summ%2==0:\n                    print('cslnb')\n                else:\n                    print('sjfnb')","output":"nlogn"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\ndic={}\nfor val in arr:\n  if val not in dic:\n    dic[val]=1\n  else:\n    dic[val]+=1\nflag1=True\nif 0 in dic:\n  if dic[0]>=2:\n    flag1=False\ncnt=0\nfor val in dic.keys():\n  if dic[val]>=3:\n    flag1=False\n    break\n  if dic[val]==2:\n    cnt+=1\n    if val-1 in dic:\n      flag1=False\n      break\nif cnt>=2:\n  flag1=False\nif flag1==False:\n  print('cslnb')\nelse:\n  flag2=(n*(n-1)\/\/2+sum(arr))%2\n  if flag2==1:\n    print('sjfnb')\n  else:\n    print('cslnb')","output":"linear"},{"instruction":"s=input()\nfor i in range(len(s),0,-1):\n    if s[:i]!=s[i-1::-1]:\n        print(i)\n        break\nelse:\n    print(0)","output":"linear"},{"instruction":"import bisect\nimport sys\ninput=sys.stdin.readline\n\nimport collections\nimport heapq\nt=1\np=10**9+7\ndef ncr_util():\n\n    inv[0]=inv[1]=1\n    fact[0]=fact[1]=1\n    for i in range(2,300001):\n        inv[i]=(inv[i%p]*(p-p\/\/i))%p\n    for i in range(1,300001):\n        inv[i]=(inv[i-1]*inv[i])%p\n        fact[i]=(fact[i-1]*i)%p\n\ndef solve():\n    ans,a,b=0,0,0\n    mul=2**60\n    for i in range(60,-1,-1):\n\n        ch1,ch2=0,0\n        if a+mul<=l:\n\n            a+=mul\n            ch1=1\n        if  b+mul<=l:\n\n            b+=mul\n            ch2=1\n        if ch1^ch2==1:\n            ans+=mul\n        elif ch1==0 and ch2==0:\n            if a+mul<=r:\n                a+=mul\n                ans+=mul\n            elif b+mul<=r:\n                b+=mul\n                ans+=mul\n\n        mul\/\/=2\n\n    return ans\n\nfor _ in range(t):\n\n    l,r=map(int,input().split())\n\n    print(solve())","output":"logn"},{"instruction":"from math import ceil\n\ndef solve(n, k):\n\tif k == 1:\n\t\treturn n - 1\n\tif k == 2:\n\t\tif n > 1:\n\t\t\treturn n - 1\n\t\telse:\n\t\t\treturn -1\n\tif k == 3:\n\t\tif n > 2:\n\t\t\treturn n - 1\n\t\telse:\n\t\t\treturn -1\n\tif k in {4, 5}:\n\t\tif n > 1:\n\t\t\treturn n - 2\n\t\telse:\n\t\t\treturn -1\n\n\tif 2 * n + 1 <= len(bin(3 * k)[2:]):\n\t\treturn -1\n\telse:\n\t\treturn n - ceil((len(bin(3 * k)[2:]) - 1) \/ 2)\n\nfor i in range(int(input())):\n\tn, k = map(int, input().split())\n\ta = solve(n, k)\n\tif a == -1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES', a)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\n\nn = int(input())\na = list(map(int,input().split()))\n\nparity = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[j] < a[i]:\n            parity ^= 1\n\nm = int(input())\nfor i in range(m):\n    l,r = map(int,input().split())\n\n    dist = (r-l+1)\n    pairs = (dist-1)*(dist)\/\/2\n\n    if pairs & 1:\n        parity ^= 1\n\n    if parity:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:\n    if len(problemSet) >= 2:\n        total = sum(problemSet)\n        myDelta = max(problemSet) - min(problemSet)\n        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:\n            return True\n    return False\n\ndef countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:\n\n    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:\n        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):\n            validSubsets.append(currentSubset)\n        for i in range(nextElementIndex, len(problems)):\n            currentSubset.append(problems[i])\n            subsetBuilder(problems, currentSubset, i+1)\n            currentSubset.pop(-1)\n\n    index = 0\n    currentSubset = []\n    validSubsets = []\n\n    subsetBuilder(problems, currentSubset, index)\n    return len(validSubsets)\n\nn, l, r, x = input().split()\nn = int(n)\nl = int(l)\nr = int(r)\nx = int(x)\n\nprobs = [int(prob) for prob in input().split()]\n\nprint(countValidSubsets(probs, l, r, x))","output":"np"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nt = 1\n\nwhile t:\n    t -= 1\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = sorted(a)\n\n    diffs = []\n    for i in range(n):\n        if a[i] != b[i]:\n            diffs.append(i)\n\n    if len(diffs) > 2:\n        print(\"NO\")\n    elif not diffs:\n        print(\"YES\")\n    else:\n        i, j = diffs\n        if a[i] == b[j] and b[i] == a[j]:\n            print(\"YES\")\n        else:\n            print(\"NO\")","output":"nlogn"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\ndp=[[-1 for i in range(5+1)] for j in range(n)]\nfor i in range(1,6):\n    dp[0][i] =1\nfor i in range(1,n):\n    if arr[i] > arr[i - 1]:\n        for j in range(1,6):\n            for k in range(1,j):\n                if dp[i-1][k]==1:\n                    dp[i][j] =1\n                    break\n    elif arr[i] <arr[i-1]:\n        for j in range(1,6):\n            for k in range(j+1,6):\n                if dp[i-1][k] ==1:\n                    dp[i][j]=1\n                    break\n    else:\n        for j in range(1,6):\n            for k in range(1,6):\n                if j ==k:\n                    continue\n                if dp[i-1][k] ==1:\n                    dp[i][j] =1\n                    break\nans=[]\nfor i in range(1,6):\n    if dp[n-1][i]==1:\n        ans.append(i)\n        break\nif len(ans) ==0:\n    print(-1)\n    exit()\nfor i in range(n-2,-1,-1):\n    curr=ans[-1]\n    if arr[i] >arr[i+1]:\n        for j in range(curr+1,6):\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\n    elif arr[i] <arr[i+1]:\n        for j in range(1,curr):\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\n    else:\n        for j in range(1,6):\n            if j ==curr:\n                continue\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\nans=ans[::-1]\nprint(*ans)","output":"linear"},{"instruction":"import sys\nfrom math import gcd\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\nn=int(input())\nl=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=dict()\nfor i in range(n):\n    if dp.get(l[i]):\n        dp[l[i]]=min(dp[l[i]],c[i])\n    else:\n        dp[l[i]]=c[i]\nfor ll in l:\n    keys=list(dp.keys())\n    for j in keys:\n        g=gcd(j,ll)\n        if dp.get(g):\n            dp[g]=min(dp[g],dp[ll]+dp[j])\n        else:\n            dp[g]=dp[ll]+dp[j]\nif 1 in dp:\n    print(dp[1])\nelse:\n    print(-1)","output":"np"},{"instruction":"import math\n[l,r]=list(map(int,input().split()))\nl=l^r\nif l:\n    l=int(math.log(l,2))\n    l=(1<<(l+1))-1\n    print(l)\nelse:\n    print(0)","output":"logn"},{"instruction":"kol = int(input())\n\ndic = {'purple': 'Power',\n       'green': 'Time',\n       'blue': 'Space',\n       'orange': 'Soul',\n       'red': 'Reality',\n       'yellow': 'Mind'}\n\nr = []\ng = []\nmissing = 6 - kol\n\nfor k in range(kol):\n    rocks = input()\n    r.append(rocks)\n\nfor key in dic:\n    if r.count(key) == 0:\n        g.append(dic[key])\n\nprint(missing)\n\nfor stone in g:\n    print(stone)","output":"constant"},{"instruction":"import math\ndef sportMafia(n,k):\n    r=round(n+1.5-math.sqrt(2*(n+k)+2.75))\n    return r\n\nn,k = map(int,input().split())\nprint(sportMafia(n,k))","output":"logn"},{"instruction":"n = int(input())\ndp = [1]\nfor IND in range(n):\n    c = input()\n    if c == \"f\":\n        dp.insert(0,0)\n    else:\n        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007\nprint(dp[0])","output":"quadratic"},{"instruction":"x,y,z,t1,t2,t3 = map(int, input().split())\ntime1 = abs(x-y)*t1\ntime2 = (abs(x-y)+abs(z-x))*t2+3*t3\nif time2 <= time1:\n    print(\"YES\")\nelse: print(\"NO\")","output":"constant"},{"instruction":"def main():\n    T = int(input().strip())\n    for _ in range(T):\n        s = input().strip()\n        t = input().strip()\n        n = len(s)\n\n        find = [[n] * 26 for _ in range(n + 2)]\n        for i in range(n - 1, -1, -1):\n            find[i][:] = find[i + 1]\n            find[i][ord(s[i]) - ord(\"a\")] = i\n\n        def interleaving(a, b):\n            dp = [n] * (len(b) + 1)\n            for i in range(len(a) + 1):\n                for j in range(len(b) + 1):\n                    if i == j == 0:\n                        dp[j] = -1\n                        continue\n                    res = n\n                    if i > 0:\n                        res = min(res, find[dp[j] + 1][ord(a[i - 1]) - ord(\"a\")])\n                    if j > 0:\n                        res = min(res, find[dp[j - 1] + 1][ord(b[j - 1]) - ord(\"a\")])\n                    dp[j] = res\n            return dp[-1] < n\n\n        if any(interleaving(t[:i], t[i:]) for i in range(len(t))):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nmain()","output":"cubic"},{"instruction":"n=int(input())\nif n>=6:\n\tfor i in range(2, n-1):\n\t\tprint(1, i)\n\tfor i in range(n-1, n+1):\n\t\tprint(2, i)\nelse:\n\tprint(-1)\nfor i in range(2, n+1):\n\tprint(1, i)","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.readline\n\nfrom collections import defaultdict\n\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(1+(~node))\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack.extend(graph[node])\n\n    for node in res:\n        node-=1\n        if any(found[nei] for nei in graph[node]):\n            print(\"NO\")\n            return\n        found[node] = 0\n\n    print(\"YES\")\n    print(*res[::-1])\n\nn,m,k=map(int,input().split())\npatterns=set()\npos=dict()\n\nfor i in range(n):\n    p=input().rstrip()\n    patterns.add(p)\n    pos[p]=i\n\nmatches=[[] for _ in range(n)]\n\nchk=True\nfor i in range(m):\n    s,mt=input().rstrip().split()\n    mt=int(mt)-1\n    if(chk):\n        chk=False\n        for i in range(1<<k):\n            tmp=[]\n            for j in range(k):\n                if(i&(1<<j)):\n                    tmp.append('_')\n                else:\n                    tmp.append(s[j])\n            tmp=''.join(tmp)\n            if(tmp in patterns):\n                if(mt==pos[tmp]):\n                    chk=True\n                else:\n                    matches[mt].append(pos[tmp])\n\nif(not chk):\n    print(\"NO\")\nelse:\n    toposort(matches)","output":"np"},{"instruction":"a, b, c, n = [int(j) for j in input().split()]\na -= c\nb -= c\nif n - a - b - c >= 1 and a >= 0 and b >= 0:\n    print(n - a - b - c)\nelse:\n    print(-1)","output":"constant"},{"instruction":"x1, y1, x2, y2, x3, y3, x4, y4 = map(int, input().split())\nX1, Y1, X2, Y2, X3, Y3, X4, Y4 = map(int, input().split())\n\nx = [x1, x2, x3, x4]\ny = [y1, y2, y3, y4]\nx = list(set(x))\ny = list(set(y))\nx.sort()\ny.sort()\nxl, xr = x\nyl, yr = y\n\nif xl <= X1 <= xr and yl  <= Y1 <= yr:\n    print('YES')\n    exit()\nif xl <= X2 <= xr and yl  <= Y2 <= yr:\n    print('YES')\n    exit()\nif xl <= X3 <= xr and yl  <= Y3 <= yr:\n    print('YES')\n    exit()\nif xl <= X4 <= xr and yl  <= Y4 <= yr:\n    print('YES')\n    exit()\n\nCX, CY = (X1+X2+X3+X4)\/\/4,  (Y1+Y2+Y3+Y4)\/\/4\nX1, X2, X3, X4 = X1-CX, X2-CX, X3-CX, X4-CX\nY1, Y2, Y3, Y4 = Y1-CY, Y2-CY, Y3-CY, Y4-CY\n\nif xl <= CX <= xr and yl  <= CY <= yr:\n    print('YES')\n    exit()\n\nA = 0\nfor X in (X1, X2, X3, X4):\n    A = max(A, abs(X))\nif abs(x1-CX)+abs(y1-CY) <= A:\n    print('YES')\n    exit()\nif abs(x2-CX)+abs(y2-CY) <= A:\n    print('YES')\n    exit()\nif abs(x3-CX)+abs(y3-CY) <= A:\n    print('YES')\n    exit()\nif abs(x4-CX)+abs(y4-CY) <= A:\n    print('YES')\n    exit()\nprint('NO')","output":"constant"},{"instruction":"n = int(input())\nsequence = [int(x) for x in input().split()]\nfirstOrderStatistics = min(sequence)\nif sequence.count(firstOrderStatistics) == len(sequence):\n    print(\"NO\")\nelse:\n    sequence = sorted(sequence)\n    secondOrderStatistics = sequence[0]\n    for i in sequence:\n        if(i > secondOrderStatistics):\n            secondOrderStatistics = i\n            break\n    print(secondOrderStatistics)","output":"nlogn"},{"instruction":"def score(l):\n    return sum(x*(x%2 == 0) for x in l)\n\nres = 0\nns = list(map(int, input().split()))\nfor i in range(14):\n    l = list(ns)\n    for j in range(13):\n        l[(i+1+j) % 14] += l[i]\/\/14 + (1 if (j+1) <= l[i]%14 else 0)\n    l[i] = l[i]\/\/14\n    res = max(res, score(l))\n\nprint(res)","output":"constant"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        n,k=ria()\n        a=1\n        b=-(2*n+3)\n        c=n*(n+1)-2*k\n        x=(-b-int(math.sqrt(b**2-4*a*c)))\/\/(2*a)\n        print(x)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"logn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,k=map(int,input().split())\ns=list(map(str, input()))\ndic={}\nfor i in range(n):\n    if s[i]==\"(\":\n        arrStack.my_push([i,\"(\"])\n    else:\n        if arrStack.my_peak()[1]==\"(\":\n            index=arrStack.my_peak()[0]\n            dic[index]=1\n            dic[i]=1\n            k-=2\n            arrStack.my_pop()\n    if k==0:\n        break\nans =\"\"\nfor i in range(n):\n    if i in dic:\n        ans+=s[i]\nprint(ans)","output":"linear"},{"instruction":"n, m, v = map(lambda x: int(x) + 1, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\ndp = []\nfor i in range(n):\n    dp.append([])\n    for j in range(m):\n        dp[i].append([0] * v)\na.sort(reverse=1)\nb.sort(reverse=1)\nc.sort(reverse=1)\na = [0] + a\nb = [0] + b\nc = [0] + c\nans = 0\nfor i in range(n):\n    for j in range(m):\n        for k in range(v):\n            if i == j == k == 0:\n                continue\n            if i == j == 0 or i == k == 0 or j == k == 0:\n                continue\n            if i == 0:\n                dp[i][j][k] = dp[i][j - 1][k - 1] + \\\n                              b[j] * c[k]\n            elif j == 0:\n                dp[i][j][k] = dp[i - 1][j][k - 1] + \\\n                              a[i] * c[k]\n            elif k == 0:\n                dp[i][j][k] = dp[i - 1][j - 1][k] + \\\n                              a[i] * b[j]\n            else:\n                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],\n                                  dp[i - 1][j][k - 1] + a[i] * c[k],\n                                  dp[i][j - 1][k - 1] + b[j] * c[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,m=map(int,input().split())\nc=list(map(int,input().split()))\nkk=get_frequency(c)\nif len(set(c))==n:\n    print(min(kk.values()))\nelse:\n    print(0)","output":"quadratic"},{"instruction":"import sys\nk=int(input())\nif type(k)!=int or k<=0 or k>pow(10,12) :\n        print(\"wrong input. try again\")\n        sys.exit()\nlim_init=lim=decimal=9\nc=0\nwhile True:\n        c+=1\n        if k<=lim:\n                diff=lim-k\n                pos=diff%c\n                diff=int(diff\/c)\n                diff=decimal-diff\n                print(''.join(list(reversed(str(diff))))[pos])\n                break\n        else:\n                decimal = int(str(lim_init)*(c+1))\n                lim+=int(str(lim_init)+'0'*c)*(c+1)","output":"logn"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nB = [0] * n\nans = 0\nfor i in range(n):\n    if B[i] == 0:\n        ans += 1\n        B[i] = 1\n        for j in range(n):\n            if A[j] % A[i] == 0:\n                B[j] = 1\nprint(ans)","output":"quadratic"},{"instruction":"d = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\",\n}\n\nall_colors = list(d.keys())\n\nn = int(input())\ncolors = [input() for i in range(n)]\n\nprint(len(d) - len(colors))\nfor color in all_colors:\n    if color not in colors:\n        print(d[color])\n","output":"constant"},{"instruction":"def some_random_function():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function5():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\nimport os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    mod = 998244353\n    powe = [1]\n    for _ in range(10**6):\n        powe.append((powe[-1]*2)%mod)\n    n = int(input())\n    a = list(map(int,input().split()))\n    ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0\n    for i in range(1,n):\n        if i == 1:\n            dp = (dp+a[i])%mod\n        else:\n            dp = (dp*2+a[i]-dp1)%mod\n        ans = (ans+powe[n-i-1]*dp)%mod\n        dp1 = a[i]\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef some_random_function1():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function2():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function3():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function4():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function6():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function7():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\ndef some_random_function8():\n\n    x = 10\n    x *= 100\n    i_dont_know = x\n    why_am_i_writing_this = x*x\n    print(i_dont_know)\n    print(why_am_i_writing_this)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys, math, queue\n\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef hgt(x):\n    if x == 0: return -1\n    h = 0\n    while x&1 != 1:\n        h += 1\n        x = x>>1\n    return h\n\ndef up(x):\n    h = hgt(x)\n    g = x + (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    g = x - (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    return x\n\ndef left(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x - (1<<(h-1))\n    if g > 0:\n        return g\n    return x\n\ndef right(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x + (1<<(h-1))\n    if g < N:\n        return g\n    return x\n\nN, q = map(int, input().split())\nN += 1\nfor _ in range(q):\n    p = int(input())\n    for c in input():\n        if c == 'U':\n            p = up(p)\n        elif c == 'R':\n            p = right(p)\n        else:\n            p = left(p)\n    print(p)","output":"np"},{"instruction":"from itertools import permutations as p\nrd = lambda: map(int, input())\ndef f(n, t):\n    a = 0\n    f = 1\n    for i in range(n):\n        for x in rd():\n            if x != f:\n                a += 1\n            f = 1 - f\n    if t < 3:\n        rd()\n    return a\nn = int(input())\nm = []\nb = [-1, -1, 1, 1]\nfor i in range(4):\n    m.append(f(n, i))\nprint(2 * n ** 2 + min(sum(x * y for x, y in zip(q, m)) for q in set(p(b))))","output":"quadratic"},{"instruction":"s1 = input()\ns2 = input()\n\nobjetivo = s1.count(\"+\") - s1.count(\"-\")\ninicio = s2.count(\"+\") - s2.count(\"-\")\nincognitos = s2.count(\"?\")\ndistancia = objetivo - inicio\n\ndef factorial(n):\n    total = 1\n    for i in range(int(n)):\n        total *= (i + 1)\n    return total\n\nif abs(distancia) > incognitos or distancia % 2 != incognitos % 2:\n    print(0)\nelse:\n    mas = (distancia + incognitos) \/ 2\n    menos = (incognitos - distancia) \/ 2\n    print((factorial(incognitos)\/(factorial(mas)*factorial(menos)))\/2**incognitos)","output":"np"},{"instruction":"def max_profit(n,k,l,d):\n    a=[]\n    s,p,i=0,0,-1\n    while(len(a)!=k-1):\n        p+=1\n        i+=1\n        if l[i] in d:\n            s+=l[i]\n            a.append(p)\n            p=0\n            d.remove(l[i])\n    print(s+d[0])\n    a.append(n-sum(i for i in a))\n    print(*a)\n\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nm=[]\nm[:]=l[:]\nd=[]\nm.sort(reverse=True)\nfor i in range(k):\n    d.append(m[i])\nmax_profit(n,k,l,d)","output":"nlogn"},{"instruction":"from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) \/\/ factorial(m) \/\/ factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)\/\/2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)","output":"quadratic"},{"instruction":"t=int(input())\nfor i in range(t):\n    n=int(input())\n    g=list(map(int,input().split()))\n    m1=max(g)\n    g.remove(m1)\n    m2=max(g)\n    dl=len(g)-1\n    print(min(dl,m2-1))","output":"constant"},{"instruction":"fast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nz,zz=input,lambda:list(map(int,z().split()))\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom re import *\nfrom sys import *\nfrom math import *\nfrom heapq import *\nfrom queue import *\nfrom bisect import *\nfrom string import *\nfrom itertools import *\nfrom collections import *\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom collections import Counter as cc\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef output(answer):stdout.write(str(answer))\n\nlst1={}\nlst2={}\nn=int(z())\nlst=set()\nfor _ in range( n ):\n    x,y=zzz()\n    lst1[x]=y\n    lst.add(x)\n\nm=int(z())\n\nfor _ in range( m ):\n    x,y=zzz()\n    lst2[x]=y\n    lst.add(x)\n\nans=0\nfor i in lst:\n    try:\n        x=lst1[i]\n    except:\n        x=0\n\n    try:\n        y=lst2[i]\n    except:\n        y=0\n    ans+=max(x,y)\nprint(ans)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n\nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])\/(j-i+1))\nprint(ans)","output":"quadratic"},{"instruction":"t=list(map(int,input().split()))\nn=t[0]\nc=t[1]\na=list(map(int,input().split()))\nf=[]\nfor i in range(0,500001):\n\tf.append(0)\nl=[]\nfor i in range(0,500001):\n\tl.append([0])\nm=0\nfor i in range(n):\n\tl[a[i]].append(f[a[i]]-m)\n\tif a[i]==c:\n\t\tm+=1\n\tf[a[i]]+=1\n\tl[a[i]].append(f[a[i]]-m)\nma=0\nfor i in l:\n\tmi=0\n\tfor j in i:\n\t\tif(j<mi):\n\t\t\tmi=j\n\t\tif(ma<j-mi):\n\t\t\tma=j-mi\nprint(m+ma)","output":"linear"},{"instruction":"import math\n\nn = int(input())\n\nbeacons = {}\nsortedKeys = [0]*n\n\nfor i in range(n):\n    a, b = map(int, input().split(' '))\n    sortedKeys[i] = a\n    beacons[a] = b\n\nsortedKeys.sort()\nmaxA = sortedKeys[-1]\n\nsumBeacons = [0]*(maxA+1)\ncount = 0\nfor a in range(maxA+1):\n    sumBeacons[a] = count\n\n    if a in beacons:\n        count += 1\n\nf = [0]*(n+1)\nminF = math.inf\nfor i in range(1, n+1):\n    a = sortedKeys[i-1]\n    b = beacons[a]\n    end = max(0, a-b)\n    numDestroyed = sumBeacons[a] - sumBeacons[end]\n    f[i] = numDestroyed\n    if i-numDestroyed > 0:\n        f[i] += f[(i-1)-numDestroyed]\n\n    minF = min(minF, f[i]+n-i)\n\nprint(minF)","output":"linear"},{"instruction":"p1, g1, ig1 = 104857601, 3, 34952534\np2, g2, ig2 = 111149057, 3, 37049686\np3, g3, ig3 = 113246209, 7, 16178030\nz1 = 439957480532171226961446\nz2 = 879898597692195524486915\nz3 = 8496366309945115353\nppp = p1 * p2 * p3\nW1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)]\nW2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)]\nW3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)]\niW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)]\niW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)]\niW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)]\n\ndef fft1(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W1[l] % p1)\n\n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1\ndef fft2(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W2[l] % p2)\n\n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2\ndef fft3(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W3[l] % p3)\n\n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3\n\ndef ifft1(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1\n                u = u * iW1[l] % p1\ndef ifft2(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2\n                u = u * iW2[l] % p2\ndef ifft3(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3\n                u = u * iW3[l] % p3\n\ndef convolve(a, b):\n    n0 = len(a) + len(b) - 1\n    if len(a) < 50 or len(b) < 50:\n        ret = [0] * n0\n        if len(a) > len(b): a, b = b, a\n        for i, aa in enumerate(a):\n            for j, bb in enumerate(b):\n                ret[i+j] = (ret[i+j] + aa * bb) % P\n        return ret\n\n    k = (n0).bit_length()\n    n = 1 << k\n    a = a + [0] * (n - len(a))\n    b = b + [0] * (n - len(b))\n\n    a1 = [x % p1 for x in a]\n    a2 = [x % p2 for x in a]\n    a3 = [x % p3 for x in a]\n    b1 = [x % p1 for x in b]\n    b2 = [x % p2 for x in b]\n    b3 = [x % p3 for x in b]\n    fft1(k, a1), fft1(k, b1)\n    fft2(k, a2), fft2(k, b2)\n    fft3(k, a3), fft3(k, b3)\n    for i in range(n): a1[i] = a1[i] * b1[i] % p1\n    for i in range(n): a2[i] = a2[i] * b2[i] % p2\n    for i in range(n): a3[i] = a3[i] * b3[i] % p3\n    ifft1(k, a1)\n    ifft2(k, a2)\n    ifft3(k, a3)\n    invn1 = pow(n, p1 - 2, p1)\n    invn2 = pow(n, p2 - 2, p2)\n    invn3 = pow(n, p3 - 2, p3)\n    for i in range(n0): a1[i] = a1[i] * invn1 % p1\n    for i in range(n0): a2[i] = a2[i] * invn2 % p2\n    for i in range(n0): a3[i] = a3[i] * invn3 % p3\n    return [(x1 * z1 + x2 * z2 + x3 * z3) % ppp % P for x1, x2, x3 in zip(a1[:n0], a2[:n0], a3[:n0])]\ndef chk(L):\n    return [fa[i] * x % P for i, x in enumerate(L)]\ndef chkinv(L):\n    return [fainv[i] * x % P for i, x in enumerate(L)]\nN, P = map(int, input().split())\n\nnn = 1001\n\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nX = [[] for _ in range(444)]\nY = [[] for _ in range(444)]\nX[0] = [1]\nX[1] = [0, 1]\nX[2] = [0, 1, 1]\nX[3] = [0, 0, 4, 1]\n\nY[0] = [1]\nY[1] = [1, 0]\nY[2] = [0, 2, 0]\nY[3] = [0, 1, 4, 0]\n\nfor i in range(4, 404):\n    X[i] = [0] * i + [1]\n    Y[i] = [0] * (i + 1)\n    for j in range(1, i):\n        k = i - j\n        X[i][j] = (X[i-1][j-1] * (2 * k + 1) + X[i-2][j-1] * k) % P\n        Y[i][j] = (Y[i-1][j-1] * (2 * k) + Y[i-2][j-1] * (k-1)) % P\n\nX = [chkinv(a) for a in X]\nY = [chkinv(a) for a in Y]\n\nANS = [0] * (N + 1)\nfor i in range(N):\n    t = convolve(X[i], X[N-1-i])\n    for j, a in enumerate(t):\n        ANS[j] = (ANS[j] + a) % P\n\nans = 0\nfor i, a in enumerate(ANS):\n    ans = (ans + a * fa[i]) % P\nprint(ans)","output":"cubic"},{"instruction":"import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):\n        d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"def main():\n    n, m = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    c_i= 0\n    a_i= 0\n    bought = 0\n    while c_i!= n and a_i!= m:\n        if(a[a_i]>=c[c_i]):\n            a_i+=1\n            c_i+=1\n            bought+=1\n        else:\n            c_i+=1\n    print(bought)\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"from math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *\nfrom fractions import *\nfrom sys import *\n\nn, a, b = map(int, input().split())\ns = [int(x) for x in input().split()]\ns.sort()\nif s[b-1] == s[b]:\n    print(0)\nelse:\n    print(s[b] - s[b-1])","output":"nlogn"},{"instruction":"def is_square(x):\n    sq = int(x**0.5)\n    return sq * sq == x\n\nfor _ in range(int(input())):\n    n = int(input())\n\n    if ((n % 2 == 0 and is_square(n\/\/2))\n            or (n % 4 == 0 and is_square(n\/\/4))):\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"x2=input()\nx=x2.split(' ')\nn=int(x[0])\nk=int(x[1])\nn,k=n-1,k-1\nl=0\nr=k\ng=k*(k+1)\/\/2\nans=-1\nwhile l<=r:\n\tm=(l+r)\/\/2\n\tif (g-m*(m+1)\/\/2)>=n:\n\t\tans=k-m\n\t\tl=m+1\n\telse:\n\t\tr=m-1\nprint(ans)","output":"logn"},{"instruction":"numeros = [int(i) for i in input().split(' ')]\n\nl = bin(numeros[0])\nr = bin(numeros[1])\n\np = -1\n\nif (len(r) == len(l)):\n    for i in range (len(l)):\n        if (l[i] != r[i]):\n            p = i\n            break\n    if(numeros[0] != numeros[1]):\n\n        saida = 2**(len(r) - p) - 1\n        print(saida)\n    else:\n        print(0)\n\nelse:\n    if(numeros[0] != numeros[1]):\n        saida = 2**(len(r) - 2) - 1\n\n        print(saida)\n    else:\n        print(0)","output":"logn"},{"instruction":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        carry = 0\n        res = 0\n        mask = 0xFFFFFFFF\n\n        for i in range(32):\n            a_bit = (a >> i) & 1\n            b_bit = (b >> i) & 1\n            cur_bit = a_bit ^ b_bit ^ carry\n            carry = (a_bit + b_bit + carry) >= 2\n            if cur_bit:\n                res |= (1 << i)\n\n        if res > 0x7FFFFFFF:\n            res = ~(res ^ mask)\n\n        return res","output":"constant"},{"instruction":"k = int(input())\ncount = 1\nnumber = 1\nresult = 0\nnumber1 = 1\nwhile True:\n    if number == 1:\n        if result + 9 < k:\n            result += 9\n            number = 20\n            number1 = 10\n        else:\n            break\n    elif number == 20:\n        if result + 180 < k:\n            result += 180\n            number += 10\n            number1 = 100\n        else:\n            break\n    else:\n        if result + 9 * number * 10**count < k:\n            result += 9 * number * 10**count\n            number += 10\n            count += 1\n            number1 *= 10\n        else:\n            break\n\nwhile True:\n    if count == 0:\n        break\n    if result + number * 10**count < k:\n        result += number * 10**count\n        number1 += 100 * 10**(count - 1)\n    else:\n        count -= 1\n\nwhile True:\n    if number == 1:\n        break\n    if result + number < k:\n        result += number\n        number1 += 10\n    else:\n        break\n\nwhile True:\n    if result + len(str(number1)) >= k:\n        print(str(number1)[k - result - 1])\n        break\n    else:\n        number1 += 1\n        result += len(str(number1))","output":"logn"},{"instruction":"from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) \/\/ factorial(m) \/\/ factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)\/\/2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)","output":"cubic"},{"instruction":"from math import *\nimport sys\ninput = lambda: sys.stdin.readline().strip()\n\nd = {'m': [], 's': [], 'p': []}\n\nls = list(input().split())\nfor i in ls:\n    d[i[1]].append(int(i[0]))\nfor k, v in d.items():\n    v.sort()\n    if len(v)==3 and len(set(v))==1: print(0); break\n    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break\nelse:\n    for k, v in d.items():\n        if len(v)==2 and len(set(v))==1: print(1); break\n        if len(v)==2 and v[1]-v[0]<=2: print(1); break\n        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break\n        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break\n    else:\n        print(2)","output":"nlogn"},{"instruction":"x=input()\nx,k=x.split()\nx=int(x)\nk=int(k)\nmul=pow(2,k+1,1000000007)\ny=(x%1000000007*mul)%1000000007\nans=y\nif x!=0:\n    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007\n\nprint(ans)","output":"logn"},{"instruction":"def main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum \/ k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())\n            if found:\n                simple[mask] = True\n                masks[mask] = path\n    for i in range(1 << k):\n        if not simple[i]:\n            continue\n        mask = i\n        zeroes_count = 0\n        for u in range(k):\n            if (1 << u) > mask:\n                break\n            if (mask & (1 << u)) == 0:\n                zeroes_count += 1\n        for mask_mask in range(1 << zeroes_count):\n            mask_child = 0\n            c = 0\n            for u in range(k):\n                if (1 << u) > mask:\n                    break\n                if (mask & (1 << u)) == 0:\n                    if (mask_mask & (1 << c)) != 0:\n                        mask_child = mask_child | (1 << u)\n                    c += 1\n            if masks[mask_child] and not masks[mask_child | mask]:\n                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}\n                if (mask_child | mask) == ((1 << k) - 1):\n                    c = [-1] * k\n                    p = [-1] * k\n                    d = masks[(1 << k) - 1]\n                    for key, val in d.items():\n                        c[key] = val[0]\n                        p[key] = val[1]\n                    return True, c, p\n    if masks[(1 << k) - 1]:\n        c = [-1] * k\n        p = [-1] * k\n        d = masks[(1 << k) - 1]\n        for key, val in d.items():\n            c[key] = val[0]\n            p[key] = val[1]\n        return True, c, p\n    return False, None, None\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path[i_next] = (a[i_next][j_next], i)\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import permutations\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\na=sorted(input())\nb=int(input())\na=a[::-1]\np=\"\"\nwhile a:\n\tfor i, z in enumerate(a):\n\t\tn=p+a[i]+\"\".join(sorted(a[:i]+a[i+1:]))\n\t\tif int(n)<=b:\n\t\t\tp+=z\n\t\t\ta.pop(i)\n\t\t\tbreak\nprint(p)","output":"cubic"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    if n==1:\n        return 0\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matridigit[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matridigit[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matridigit[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matridigit[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matridigit[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nsquare = set([i**2 for i in range(10**5)])\n\nfor _ in range(int(input())):\n    n = int(input())\n    if n%2:\n        print(\"NO\")\n    else:\n        k = n\/\/2\n        if k in square:\n            print(\"YES\")\n        elif k%2:\n            print(\"NO\")\n        else:\n            k = k\/\/2\n            if k in square:\n                print(\"YES\")\n            else:\n                print(\"NO\")","output":"constant"},{"instruction":"import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\ndef solve(N, M, K, right, down):\n    if K % 2 == 1:\n        return ((\"-1 \" * N) + \"\\n\") * M\n\n    K \/\/= 2\n\n    inf = float(\"inf\")\n    R = N\n    C = M\n\n    for row in right:\n        row.append(inf)\n        row.append(inf)\n        row.append(inf)\n    right.append([inf] * (C + 2))\n    right.append([inf] * (C + 2))\n    for row in down:\n        row.append(inf)\n        row.append(inf)\n    down.append([inf] * (C + 2))\n    down.append([inf] * (C + 2))\n    down.append([inf] * (C + 2))\n\n    def right_(r, c):\n        return right[r][c - 1]\n\n    def down_(r, c):\n        return down[r - 1][c]\n\n    def left(r, c):\n        return right[r][c]\n\n    def up(r, c):\n        return down[r][c]\n\n    dist = [[inf for i in range(C + 2)] for j in range(R + 2)]\n    for r in range(R):\n        for c in range(C):\n            dist[r][c] = 0\n    for k in range(K):\n        nextDist = [[inf for i in range(C + 2)] for j in range(R + 2)]\n        for r in range(R):\n            for c in range(C):\n                nextDist[r][c] = min(\n                    dist[r][c - 1] + right_(r, c),\n                    dist[r][c + 1] + left(r, c),\n                    dist[r - 1][c] + down_(r, c),\n                    dist[r + 1][c] + up(r, c),\n                )\n        dist = nextDist\n    return \"\\n\".join(\" \".join(str(2 * dist[r][c]) for c in range(C)) for r in range(R))\n\nDEBUG = False\nif DEBUG:\n    import random\n\n    random.seed(0)\n    for _ in range(1):\n        N = 500\n        M = 500\n        K = 20\n\n        def pack(i, j):\n            return i * M + j\n\n        def unpack(ij):\n            return divmod(ij, M)\n\n        graph = [[] for i in range(N * M)]\n\n        right = [[random.randint(1, 10 ** 6) for j in range(M - 1)] for i in range(N)]\n        down = [[random.randint(1, 10 ** 6) for j in range(M)] for i in range(N - 1)]\n        print(\"tc\" + str(_))\n        ans = solve(N, M, K, right, down)\n\n    exit()\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    def pack(i, j):\n        return i * M + j\n\n    def unpack(ij):\n        return divmod(ij, M)\n\n    N, M, K = [int(x) for x in input().split()]\n\n    right = [[int(x) for x in input().split()] for i in range(N)]\n    down = [[int(x) for x in input().split()] for i in range(N - 1)]\n\n    ans = solve(N, M, K, right, down)\n    print(ans)","output":"cubic"},{"instruction":"import sys\nimport math\nfrom sys import stdin,stdout\nfrom math import gcd,floor,sqrt,log\nfrom collections import defaultdict as dd\n\ninp    =lambda: int(input())\nstrng  =lambda: input().strip()\njn     =lambda x,l: x.join(map(str,l))\nstrl   =lambda: list(input().strip())\nmul    =lambda: map(int,input().strip().split())\nmulf   =lambda: map(float,input().strip().split())\nseq    =lambda: list(map(int,input().strip().split()))\n\nmod=1000000007\n\nn,m,k=mul()\n\ndp=[[[0 for l in range(k\/\/2+1)]for j in range(m)]for i in range(n)]\nh=[]\nv=[]\nfor i in range(n):\n    h.append(seq())\nfor i in range(n-1):\n    v.append(seq())\n\ndef sol(n,m,k):\n    for l in range(1,k\/\/2+1):\n        for i in range(n):\n            for j in range(m):\n                dp[i][j][l]=float(\"inf\")\n                if j-1>=0:\n                    dp[i][j][l]=min(dp[i][j][l],dp[i][j-1][l-1]+h[i][j-1])\n                if i-1>=0:\n                    dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l-1]+v[i-1][j])\n                if j+1<m:\n                    dp[i][j][l]=min(dp[i][j][l],dp[i][j+1][l-1]+h[i][j])\n                if i+1<n:\n                    dp[i][j][l]=min(dp[i][j][l],dp[i+1][j][l-1]+v[i][j])\n    return dp\nif k%2:\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=\" \")\n        print()\nelse:\n    ans=sol(n,m,k)\n    for i in range(n):\n        for j in range(m):\n            print(2*ans[i][j][k\/\/2],end=\" \")\n        print()","output":"cubic"},{"instruction":"from math import *\nn = int(input())\nif n%2==0:\n    print(n-8,n-(n-8))\nelse:\n    print((n-9),n-(n-9))","output":"constant"},{"instruction":"x, k = [int(x) for x in input().split()]\n\nif x == 0:\n    print(0)\n    exit()\n\nmod = 10 ** 9 + 7\n\nres = x * pow(2, k + 1, mod) % mod\nres = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod\n\nprint(res)","output":"logn"},{"instruction":"from sys import exit\nn = int(input())\narr = [int(x) for x in input().split()]\ntmp = 0\nfor i in range(len(arr)):\n    tmp += (arr[i] - i)\narr.sort()\nc = 0\nfor i in range(1, n):\n    if arr[i] == arr[i - 1]:\n        c += 1\n    if i != 1 and arr[i] == arr[i - 1] and arr[i - 1] == arr[i - 2] + 1:\n        print(\"cslnb\")\n        exit()\nif c > 1 or (len(arr) >= 2 and arr[0] == arr[1] == 0):\n    print(\"cslnb\")\n    exit()\nprint(\"cslnb\" if tmp % 2 == 0 else \"sjfnb\")","output":"nlogn"},{"instruction":"d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}\nfor _ in[0]*int(input()):d.pop(input())\nprint(len(d),*d.values(),sep='\\n')","output":"constant"},{"instruction":"s = input()\ndef is_pal(s):\n      if s == s[::-1]:\n            return True\n      else:\n            return False\nif not is_pal(s):\n      print(len(s))\nelse:\n      not_eq = False\n      for i in range(len(s)-1):\n            if s[i] != s[i+1]:\n                  print(len(s)-1)\n                  not_eq = True\n                  break\n      if not not_eq:\n            print(0)","output":"linear"},{"instruction":"L = [(i+1)*9*10**i for i in range(12)]\nnumber = int(input())\n\nexponent=0\nwhile number >= 0:\n    number-=L[exponent]\n    exponent+=1\nexponent-=1\nnumber%=L[exponent]\nstart = 10**exponent\nnumDigits = exponent+1\nfinal = start+(number\/\/numDigits-1)\nremainder = number%numDigits\nif remainder == 0:\n    final = str(final)\n    print(final[-1])\nelse:\n    final = str(final+1)\n    print(final[remainder-1])","output":"constant"},{"instruction":"n, K = map(int, input().split())\nmod = 998244353\nif K == 1:\n    print(2)\n    exit()\ndp = [[0]*(2**2) for i in range(K+1)]\ndp[1][0] = 1\ndp[2][1] = 1\ndp[2][2] = 1\ndp[1][3] = 1\nfor i in range(1, n):\n    nx = [[0]*(2**2) for i in range(K+1)]\n    for k in range(K+1):\n        for j in range(4):\n            if j == 0:\n                nx[k][0] += dp[k][j]%mod\n                if k+1 <= K:\n                    nx[k+1][1] += dp[k][j]%mod\n                    nx[k+1][2] += dp[k][j]%mod\n                    nx[k+1][3] += dp[k][j]%mod\n            elif j == 1:\n                nx[k][0] += dp[k][j]%mod\n                nx[k][1] += dp[k][j]%mod\n                if k+2 <= K:\n                    nx[k+2][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n            elif j == 2:\n                nx[k][0] += dp[k][j]%mod\n                if k+2 <= K:\n                    nx[k+2][1] += dp[k][j]%mod\n                nx[k][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n            else:\n                if k+1 <= K:\n                    nx[k+1][0] += dp[k][j]%mod\n                    nx[k+1][1] += dp[k][j]%mod\n                    nx[k+1][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n    dp = nx\n\nprint(sum(dp[K])%mod)","output":"np"},{"instruction":"n = int(input())\nd1 = {}\nfor _ in range(n):\n  a, x = map(int, input().split())\n  d1[a] = x\nd2 = {}\nm = int(input())\nfor _ in range(m):\n  b, y = map(int, input().split())\n  d2[b] = y\nans = 0\nfor key in set(d1.keys()) | set(d2.keys()):\n  ans += max(d1.get(key, 0), d2.get(key, 0))\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin,stdout,setrecursionlimit\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush,nlargest\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm , accumulate\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nsetrecursionlimit(10**9)\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return input()\ndef num():return int(input())\ndef L(): return list(sp())\ndef LF(): return list(spf())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef spf(): return map(int, input.readline().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\ndef pmat2(A):\n    for ele in A:\n        for j in ele:\n            print(j,end='')\n        print()\ndef iseven(n):\n    return n%2==0\n\ndef seive(r):\n    prime=[1 for i in range(r+1)]\n    prime[0]=0\n    prime[1]=0\n    for i in range(r+1):\n        if(prime[i]):\n            for j in range(2*i,r+1,i):\n                prime[j]=0\n    return prime\n\nn = int(input())\ns = list(input())\nt = list(input())\nans = []\nfor i in range(n):\n    for j in range(i,n):\n        if s[j] == t[i]:\n            for k in range(j, i, -1):\n                s[k], s[k-1] = s[k-1], s[k]\n                ans.append(k)\n            break\nif s==t:\n    print(len(ans))\n    print(' '.join(map(str, ans)))\nelse:\n    print(-1)\n\nendtime = time.time()","output":"quadratic"},{"instruction":"import sys\nimport math\n\ninput = sys.stdin.readline\n\ndef inp():\n    return(int(input()))\ndef inara():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\n\nn,k=invr()\n\nans=0\nlo=0\nhi=n\n\ndef possible(a,b):\n\tkoyta=a*(a+1)\/\/2\n\treturn koyta>=b+k\n\nwhile hi>=lo:\n\tmid=(hi+lo)\/\/2\n\n\tif possible(n-mid,mid):\n\t\tlo=mid+1\n\t\tans=mid\n\telse:\n\t\thi=mid-1\n\nprint(ans)","output":"logn"},{"instruction":"x, k = list(map(int,input().split()))\nm = 10**9 + 7\nif x==0:\n    print(0)\nelse:\n    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)","output":"logn"},{"instruction":"from math import factorial\nf=lambda:input()\na=f()\nb=f()\ns=0\ns1=0\nc=0\nfor i in a:\n    if i=='+':\n       s+=1\n    else:\n       s-=1\nfor i in b:\n    if i=='+':\n       s1+=1\n    elif i=='-':\n       s1-=1\n    else:\n       c+=1\nif c==0:\n    if s==s1:\n        print(c+1)\n    else:\n        print(c)\nelse:\n    l=[]\n    k=c\n    i=c\n    j=0\n    while i>=0:\n        l.append(k)\n        i-=1\n        j+=1\n        k=0\n        k+=i\n        k-=j\n    if s1!=0:\n        for i in range(len(l)):\n            l[i]+=s1\n    try:\n        c1=l.index(s)\n        k=factorial(c)\/(factorial(c-c1)*factorial(c1))\n        print(k\/pow(2,c))\n    except:\n        print(0.0)","output":"np"},{"instruction":"n=int(input())\nst_a=input()\nst_b=input()\nst_c=input()\na=[0 for i in range(125)]\nb=[0 for i in range(125)]\nc=[0 for i in range(125)]\nl=len(st_c)\nfor i in range(l):\n    a[ord(st_a[i])] +=1\n    b[ord(st_b[i])] +=1\n    c[ord(st_c[i])] +=1\nmaxi_a=0\nmaxi_b=0\nmaxi_c=0\nif n==1:\n    maxi_a =max(a) +1\n    maxi_b=max(b) +1\n    maxi_c=max(c) +1\n    if maxi_a >l:\n        maxi_a-=2\n    if maxi_b >l:\n        maxi_b -=2\n    if maxi_c >l:\n        maxi_c-=2\nelse:\n    for i in range(123):\n        if (i>=65 and i <=90) or (i>=97 and i<=122):\n            if a[i] +n >=l:\n                    maxi_a=max(maxi_a,l)\n            else:\n                maxi_a =max(maxi_a ,a[i] +n)\n            if b[i] +n >=l:\n                    maxi_b=max(maxi_b,l)\n            else:\n                maxi_b =max(maxi_b ,b[i] +n)\n            if c[i] +n >=l:\n                    maxi_c=max(maxi_c,l)\n            else:\n                maxi_c =max(maxi_c ,c[i] +n)\ns=[maxi_a,maxi_b,maxi_c]\ns.sort()\nif s[1] ==s[2]:\n    print(\"Draw\")\nif maxi_a >max(maxi_b,maxi_c):\n    print(\"Kuro\")\nif maxi_b >max(maxi_c,maxi_a):\n    print(\"Shiro\")\nif maxi_c >max(maxi_b,maxi_a):\n    print(\"Katie\")","output":"linear"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\ndp = [[False] * (n + 1) for i in range(n + 1)]\n\ndef solve(l, r):\n    if dp[l][r]:\n        return dp[l][r]\n    if r - l == 1:\n        dp[l][r] = (a[l], 1)\n        return dp[l][r]\n    tmp = 10 ** 9\n    for i in range(l + 1, r):\n        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\n            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\n        elif solve(l, i) == solve(i, r):\n            tmp = solve(l, i)[0] + 1\n            dp[l][r] = (tmp, 1)\n            return dp[l][r]\n        else:\n            tmp = min(tmp, 2)\n    dp[l][r] = (-1, tmp)\n    return dp[l][r]\n\nsolve(0, n)\nprint(dp[0][n][1])","output":"cubic"},{"instruction":"import sys\n\ndef chain_reaction(n, beacons):\n    table = [0] * n\n\n    for i in range(n):\n        position = beacons[i][0]\n        power = beacons[i][1]\n        destroyed = 0\n        r = position - power\n        b = 0\n\n        lo = 0\n        hi = len(beacons) - 1\n        while lo <= hi:\n            mid = int(lo + (hi - lo) \/ 2)\n            pos = beacons[mid][0]\n            if beacons[mid][0] < r:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n\n        destroyed += table[hi]\n\n        destroyed += (i - (hi + 1))\n        table[i] = destroyed\n\n    options = []\n    for i in range(n):\n        cost = (n - i) + table[i - 1]\n        options.append(cost)\n    min_cost = min(options)\n\n    return min(table[n - 1], min_cost)\n\nn = int(sys.stdin.readline().strip())\nbeacons = []\nfor i in range(n):\n    a, b = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    beacons.append((a, b))\nbeacons.sort()\nprint(chain_reaction(n, beacons))","output":"linear"},{"instruction":"for _ in range(int(input())):\n    a,b = map(int, input().split())\n    c = 0\n    while (a!=0 and b!=0):\n        if (a>b) :\n            c+= a\/\/b\n            a = a%b\n        elif (b>a):\n            c+= b\/\/a\n            b = b%a\n        else :\n            c+=1\n            break\n    print(c)","output":"constant"},{"instruction":"n,s=map(int,input().split())\ncount=0\nfor i in range(n):\n    count+=(s\/\/(n-i))\n    s-=(s\/\/(n-i))*(n-i)\nprint(count)","output":"constant"},{"instruction":"from itertools import combinations\nn, l, r, x = map(int,input().split())\na = list(map(int,input().split()))\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))","output":"np"},{"instruction":"def f(ar):\n\tmx = ar.index(max(ar))\n\tcmark = 0\n\tans = 0\n\tbig = [0] * (len(ar))\n\tfor i in range(len(ar) - 1, -1, -1):\n\n\t\tcmark = max(cmark - 1, ar[i] + 1, 0)\n\t\tbig[i] = cmark\n\tcmark = 0\n\tt=[0]*(len(ar))\n\tfor i in range(len(ar)):\n\t\tcmark = max(cmark, big[i])\n\t\tt[i]=cmark\n\tans=0\n\tfor i in range(len(ar)):\n\t\tt[i]=t[i]-ar[i]-1\n\treturn (sum(t))\n\na = input()\nprint(f([*map(int, input().strip().split())]))","output":"linear"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\nrev = [-1] * (n + 1)\nfor i, j in enumerate(a):\n    rev[j] = i\n\nmx = max(a)\n\nl = a.index(mx)\nr = l\n\nfor i in range(n - 1, 0, -1):\n    idx = rev[i]\n    if idx == l - 1:\n        l -= 1\n    elif idx == r + 1:\n        r += 1\n    else:\n        print('NO')\n        exit()\nprint('YES')","output":"linear"},{"instruction":"from collections import defaultdict\nimport sys\nsys.setrecursionlimit(500000)\ntest = 0\n\ndef countleaf(tree, n, leafs):\n    leafs[n] = 1 if len(tree[n]) == 0 else 0\n\n    for i in tree[n]:\n        leafs[n] += countleaf(tree, i, leafs)\n\n    return leafs[n]\n\nn = int(input())\nedges = list(map(int, input().split()))\ntree = [[] for i in range(n)]\n\nleafs = [0] * n\n\nfor i, e in enumerate(edges):\n    tree[e - 1] += [i + 1]\n\nif test: print(tree)\n\nfor i in range(n - 1, -1, -1):\n    if not tree[i]:\n        leafs[i] = 1\n    else:\n        leafs[i] = sum(leafs[j] for j in tree[i])\n\nprint(*sorted(leafs))","output":"nlogn"},{"instruction":"n,x=map(int,input().split())\na=[]\nk={}\nfor _ in range(n):\n    p,q=map(int,input().split())\n    if p not in k:\n        k[p]=1\n    a.append([p,q])\na.sort()\nk=sorted(k)\np=[]\nk=k[::-1]\nfor i in k:\n    for j in a:\n        if j[0]==i:\n            p.append(j)\nprint(p.count(p[x-1]))","output":"nlogn"},{"instruction":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        dp = {}\n        def dfs(l, r):\n            if l > r:\n                return 0\n            if (l, r) in dp:\n                return dp[(l, r)]\n\n            dp[(l, r)] = 0\n            for i in range(l, r + 1):\n                coins = nums[l - 1] * nums[i] * nums[r + 1]\n                coins += dfs(l, i - 1) + dfs(i + 1, r)\n                dp[(l, r)] = max(dp[(l, r)], coins)\n            return dp[(l, r)]\n\n        return dfs(1, len(nums) - 2)","output":"cubic"},{"instruction":"t = int(input())\n\ndef sol(n, k):\n    p = 1\n    q = 1\n    acc = 0\n    while n > 0 and k >= p:\n\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += q*(4**n-1)\/\/3\n\n        if k <= acc:\n            return n\n        p = 2*p+1\n        q = 2*q+3\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)","output":"logn"},{"instruction":"from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)\/\/b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nn, m, k = mp()\nhor = [lmp() for i in range(n)]\nver = [lmp() for i in range(n-1)]\nif k%2:\n    ml = l2d(n, m, -1)\n    for i in ml: print(*i)\n    exit()\nk\/\/=2\ndp = [l2d(n, m) for i in range(k+1)]\nfor f in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            a = inf\n            if i!=0:\n                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])\n            if i!=n-1:\n                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])\n            if j!=0:\n                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])\n            if j!=m-1:\n                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])\n            dp[f][i][j] = a\nfor i in dp[-1]:\n    print(*i)","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int,input().split()))\nfl = False\nans = True\nfor i in range(n-1):\n    if a[i+1]>a[i]:\n        if fl:\n            ans = False\n    else:\n        fl = True\nif ans:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"N = 10**5+5\nMOD = 10**9+7\n\nfreq = [0 for i in range(N)]\n\np2 = [0 for i in range(N)]\np2[0] = 1\nfor i in range(1,N):\n    p2[i] = p2[i-1]*2\n    p2[i]%=MOD\n\ndef Calculate_Mobius(N):\n    arr = [1 for i in range(N+1)]\n    prime_count = [0 for i in range(N+1)]\n\n    mobius_value = [0 for i in range(N+1)]\n    for i in range(2,N+1):\n        if prime_count[i]==0:\n            for j in range(i,N+1,i):\n                prime_count[j]+=1\n                arr[j] = arr[j] * i\n\n    for i in range(1, N+1):\n        if arr[i] == i:\n            if (prime_count[i] & 1) == 0:\n                mobius_value[i] = 1\n            else:\n                mobius_value[i] = -1\n        else:\n            mobius_value[i] = 0\n\n    return mobius_value\n\nmobius = Calculate_Mobius(N)\nn = int(input())\nb = [int(i) for i in input().split()]\n\nfor i in b:\n    freq[i]+=1\n\nans = 0\nfor i in range(1,N):\n\n    cnt = 0\n    for j in range(i,N,i):\n        cnt += freq[j]\n\n    total_subsequences = p2[cnt] - 1\n    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD\n\nans += MOD\nprint(ans%MOD)","output":"np"},{"instruction":"n = int(input())\nw = list(map(int, input().split()))\nent = input()\nmp = {w[i]: i+1 for i in range(n)}\nsorted(mp)\nw.sort()\nptr = 0\nstk = []\nfor i in range(2 * n):\n    if ent[i] == \"0\":\n        print(mp[w[ptr]], end=\" \")\n        stk.append(mp[w[ptr]])\n        ptr += 1\n    else:\n        print(stk.pop(), end=\" \")\n\nprint()","output":"nlogn"},{"instruction":"import sys\nimport argparse\nimport json\n\ndef main():\n    n = int(sys.stdin.readline())\n    ticket = sys.stdin.readline().rstrip()\n    integers = [int(x) for x in ticket]\n\n    zeros = 0\n    while zeros < len(integers) and integers[-1*(zeros+1)] == 0:\n        zeros += 1\n\n    if zeros > 0 and zeros >= len(integers):\n        integers = []\n    elif zeros > 0:\n        integers = integers[:-1*zeros]\n\n    if not integers:\n        print(\"YES\")\n        return\n    if len(integers) == 1:\n        print(\"NO\")\n        return\n\n    total = 0\n    for i, val in enumerate(integers[:-1]):\n        total += val\n        splice = integers[i+1:]\n        if is_golden(total, splice):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\ndef is_golden(total, integers):\n    current_total = 0\n\n    for i, val in enumerate(integers):\n        current_total += val\n        if current_total < total:\n            continue\n        elif current_total == total:\n\n            splice = integers[i+1:]\n            return (not splice) or is_golden(total, splice)\n        elif current_total > total:\n            return False\n    return False\n\ndef get_tests():\n    tests = [(\"5\\n73452\", \"YES\"),\n             (\"4\\n1248\", \"NO\"),\n             (\"4\\n7435\", \"NO\"),\n             (\"8\\n0020200\", \"YES\"),\n             (\"99\\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887\", \"YES\"),\n             (\"84\\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090\", \"YES\"),\n             (\"2\\n00\", \"YES\"),\n             (\"8\\n00020200\", \"YES\"),\n             (\"5\\n11980\", \"NO\"),\n             (\"3\\n100\", \"NO\")]\n\n    for test in tests:\n        print(json.dumps({\"input\": test[0], \"output\": test[1]}))\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--get-tests\", action=\"store_true\")\n    args = parser.parse_args()\n\n    if args.get_tests:\n        get_tests()\n    else:\n        main()","output":"quadratic"},{"instruction":"n,k = map(int,input().split())\nM = 1000000007\nif(n == 0):\n    print(0)\nelse:\n    ans = 2*n - 1\n    x  =  pow(2,k,M)\n    print((((ans * x) % M) + 1) % M)","output":"logn"},{"instruction":"n,k=map(int,input().strip().split())\nd=(n-k)\/\/2+1\nx=['1' if (i+1)%d==0 else '0' for i in range(n)]\nprint(''.join(x))","output":"linear"},{"instruction":"import decimal\ndecimal.getcontext().prec = 100\n\na, v = map(decimal.Decimal, input().split())\nl, d, w = map(decimal.Decimal, input().split())\n\ndef DecimalPow(a, b):\n    return decimal.Decimal(a) ** decimal.Decimal(b)\n\ndef getLastT(v1, dist):\n    t1 = (v - v1) \/ a\n    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)\n    if d1 >= dist:\n        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) \/ a\n    t2 = (dist - d1) \/ v\n    return t1 + t2\n\nif w >= v:\n    t = getLastT(0, l)\n    print('{t:.5f}'.format(t = t))\n\nelif (w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a) >= d:\n    t = getLastT(0, l)\n    print('{t:.5f}'.format(t = t))\n\nelif (v ** decimal.Decimal(2) - 0) \/ (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a) >= d:\n    t2 = -w \/ a + ((w ** decimal.Decimal(2)) \/ (2 * (a ** decimal.Decimal(2))) + d \/ a) ** decimal.Decimal(0.5)\n    t1 = w \/ a + t2\n    t3 = getLastT(w, l - d)\n    t = t1 + t2 + t3\n    print('{t:.5f}'.format(t = t))\n\nelse:\n    t1 = v \/ a\n    t3 = (v - w) \/ a\n    t2 = (d - ((v ** decimal.Decimal(2) - 0) \/ (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a))) \/ v\n    t4 = getLastT(w, l - d)\n    t = t1 + t2 + t3 + t4\n    print('{t:.5f}'.format(t = t))","output":"constant"},{"instruction":"n,l,r,x=map(int,input().split())\nc=list(map(int,input().split()))\nc.sort()\np=1<<n\ncnt=0\nfor j in range(p):\n    list1=[]\n    if(j>0 and j&(j-1)!=0):\n        for k in range(n):\n            if(j&(1<<k)):\n                list1.append(c[k])\n        if(sum(list1)>=l and sum(list1)<=r and list1[-1]-list1[0]>=x):\n            cnt+=1\nprint(cnt)","output":"np"},{"instruction":"import sys\n\npl=1\n\nif pl:\n\tinput=sys.stdin.readline\nelse:\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('outpt.txt','w')\n\ndef li():\n\treturn [int(xxx) for xxx in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\ndef mi():\n\treturn \tmap(int,input().split())\n\nt=1\nwhile t>0:\n\tt-=1\n\tn=fi()\n\ta=li()\n\tdp=[[0]*(n+1) for i in range(n+1)]\n\tfor i in range(n-1,-1,-1):\n\t\tfor j in range(i,n):\n\t\t\tif i==j:\n\t\t\t\tdp[i][j]=a[i]\n\t\t\telif i==j-1:\n\t\t\t\tif a[i]==a[j]:\n\t\t\t\t\tdp[i][j]=a[i]+1\n\t\t\telse:\n\t\t\t\tfor k in range(i,j):\n\t\t\t\t\tif dp[i][k]\tand dp[k+1][j] and dp[i][k]==dp[k+1][j]:\n\t\t\t\t\t\tdp[i][j]=dp[i][k]+1\n\t\t\t\t\t\tbreak\n\tans=[10**18]*(n+1)\n\tans[-1]=0\n\n\tfor i in range(n-1,-1,-1):\n\t\tfor j in range(i,n):\n\t\t\tif dp[i][j]:\n\t\t\t\tans[i]=min(ans[i],1+ans[j+1])\n\t\t\telse:\n\t\t\t\tans[i]=min(ans[i],j-i+1+ans[j+1])\n\tprint(ans[0])","output":"cubic"},{"instruction":"import os\nfrom io import BytesIO, IOBase\nimport sys\nfrom collections import defaultdict, deque, Counter\nfrom math import sqrt, pi, ceil, log, inf, gcd, floor\nfrom itertools import combinations, permutations\nfrom bisect import *\nfrom fractions import Fraction\nfrom heapq import *\nfrom random import randint\n\ndef main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    dp=[[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i]=a[i]\n    for i in range(n-2,-1,-1):\n        for j in range(i+1,n,1):\n            for k in range(i,j,1):\n                if dp[i][k] and dp[i][k]==dp[k+1][j]:\n                    dp[i][j]=dp[i][k]+1\n    b=[10**10]*(n+1)\n    b[0]=0\n    for i in range(1,n+1):\n        for j in range(i):\n            if dp[j][i-1]:\n                b[i]=min(b[i],b[j]+1)\n    print(b[n])\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    if a[-2]>n-2:\n        print(n-2)\n    else:\n        print(a[-2]-1)","output":"nlogn"},{"instruction":"import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(_y)\n\nprint(' '.join(map(str, y)))","output":"quadratic"},{"instruction":"n=int(input())\npieces=[]\nblacks=[0]*4\nwhites=[0]*4\nfor i in range(4):\n    grid=[]\n    for j in range(n):\n        grid.append(input())\n    if i<3:\n        input()\n    count=0\n    for j in range(n):\n        for k in range(n):\n            if (int(grid[j][k])+j+k)%2:\n                count+=1\n    blacks[i]=count\n    whites[i]=n*n-count\nans=4*n*n\nfor white1 in range(3):\n    for white2 in range(white1+1,4):\n        for black1 in range(4):\n            if black1==white1 or black1==white2:\n                continue\n            for black2 in range(black1+1,4):\n                if black2==white1 or black2==white2:\n                    continue\n                ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2])\nprint(ans)","output":"quadratic"},{"instruction":"import math\nn = int(input())\nA = [i + 1 for i in range(n)]\nx = int(math.sqrt(n))\nX = [A[i:i + x] for i in range(0, len(A), x)]\nX = X[::-1]\nf = [item for sublist in X for item in sublist]\nprint(*f)","output":"linear"},{"instruction":"n, v = map(int, raw_input().split())\n\nres=0\nfuel=0\nfor i in range(1,n):\n    miss = min(v-fuel, n-i-fuel)\n    res+=i*miss\n    fuel+=miss-1\n    if v-fuel==0:\n        print(res)\n        exit(0)\nprint(res)","output":"linear"},{"instruction":"n,k=map(int,input().split())\nans=0\nans+=(2*n)\/\/k + bool((2*n)%k!=0)\nans+=(5*n)\/\/k + bool((5*n)%k!=0)\nans+=(8*n)\/\/k + bool((8*n)%k!=0)\nprint(ans)","output":"constant"},{"instruction":"import math,sys,bisect,heapq,os\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n\npr = lambda x:    x\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\ndef solve():\n    n, = aj()\n    A = aj()\n    if A.count(0) >= 2:\n        print('cslnb')\n    elif n == 1:\n        if A[0]%2:\n            print('sjfnb')\n        else:\n            print('cslnb')\n    else:\n        g2 = 0;flag = 1\n        C = Counter(A)\n        for i in C.keys():\n            if C[i] >= 3:\n                flag = 0\n            if C[i] == 2 and C[i-1] >= 1:\n                flag = 0\n            if C[i] == 2:\n                g2 += 1\n        if g2 >= 2:\n            flag = 0\n        if not flag:\n            print('cslnb')\n        else:\n            movescount = 0\n            A.sort()\n            for ii,i in enumerate(A):\n                movescount += i - ii\n            if movescount % 2 == 0:\n                print('cslnb')\n            else:\n                print('sjfnb')\n\ntry:\n\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    from aj import *\nexcept:\n    pass\n\nsolve()","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m,k=map(int,input().split())\n    left=[list(map(int,input().split())) for _ in range(n)]\n    down=[list(map(int,input().split())) for _ in range(n-1)]\n    dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)]\n    if k&1==0:\n        for l in range(k\/\/2):\n            dp1=[[10**8 for _ in range(m)] for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    if j>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])\n                    if j<m-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])\n                    if i>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])\n                    if i<n-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])\n            dp=dp1\n    for i in dp:\n        print(*i)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n\n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\nmove,can=zz()\ncurr=0\n\nfor i in range(1,move+1):\n    curr+=i\n    if curr-(move-i)==can:\n        print(move-i)\n        break\n\nelse:\n    print(0)","output":"logn"},{"instruction":"def main():\n    n, d, k = list(map(int, input().split()))\n    if n == 2 and d == 1 and k == 1:\n        print(\"YES\")\n        print(\"1 2\")\n        return 0\n    if n == d + 1 and k - 1:\n        print(\"YES\")\n        for i in range(1, d + 1):\n            print(i, i + 1)\n        return 0\n    if  n < d +1 or k <= 2 or d == 1:\n        print(\"NO\")\n        return 0\n    if d % 2 == 0:\n        if n * (k - 2) > -2 + k * (k - 1) ** (d \/\/ 2):\n            print(\"NO\")\n            return 0\n        print(\"YES\")\n        for i in range(1, d + 1):\n            print(i, i + 1)\n        nodes = d + 1\n        leaves = [1 + d \/\/ 2]\n        dev = 0\n        while True:\n            new_leaves = []\n            for i in leaves:\n                for j in range(k - 1 - (i <= d + 1)):\n                    nodes += 1\n                    print(i, nodes)\n                    new_leaves.append(nodes)\n                    if nodes == n:\n                        return 0\n            dev += 1\n            leaves = new_leaves + [1 - dev + d \/\/ 2, 1 + dev + d \/\/ 2]\n\n    else:\n        if n * (k - 2) > -2 + k * (k - 1) ** (d \/\/ 2) + (k - 2) * (k - 1) ** (d \/\/ 2):\n            print(\"NO\")\n            return 0\n        print(\"YES\")\n        for i in range(1, d + 1):\n            print(i, i + 1)\n        nodes = d + 1\n        leaves = [1 + d \/\/ 2, 2 + d \/\/ 2]\n        dev = 0\n        while True:\n            new_leaves = []\n            for i in leaves:\n                for j in range(k - 1 - (i <= d + 1)):\n                    nodes += 1\n                    print(i, nodes)\n                    new_leaves.append(nodes)\n                    if nodes == n:\n                        return 0\n            dev += 1\n            leaves = new_leaves + [1 - dev + d \/\/ 2, 2 + dev + d \/\/ 2]\nmain()","output":"quadratic"},{"instruction":"n = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nfl = 0\nm = n\ns = list(range(n))\nfor i in range(n):\n    s[i] = m - (l[i] + r[i])\n    if fl != 1 and s[i] == m:\n        fl = 1\nfor i in range(n):\n    ll = 0;\n    for j in range(i):\n        if s[j] > s[i]:\n            ll += 1\n    rr = 0\n    for j in range(i + 1, n):\n        if s[j] > s[i]:\n            rr += 1\n    if l[i] != ll or rr != r[i]:\n        fl = 0\n        break\n\nif fl == 1 and l[0] == 0 and r[n - 1] == 0:\n    print('YES')\n    print(*s)\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n = int(input())\nL = [int(i) for i in input().split()]\nR = [int(i) for i in input().split()]\nE = []\notv = [0] * n\nfor i in range(n):\n    sum_ = L[i] + R[i]\n    E.append([sum_, i])\nE.sort()\nfor i in range(n):\n    x = R[i]\n    for j in range(n):\n        if (x > 0):\n            if (E[j][1] > i):\n                otv[E[j][1]] += 1\n                x -= 1\n        else:\n            break\n\n    if (x > 0):\n        print(\"NO\")\n        exit()\n\n    x = L[i]\n    for j in range(n):\n        if (x > 0):\n            if (E[j][1] < i):\n                otv[E[j][1]] += 1\n                x -= 1\n        else:\n            break\n\n    if (x > 0):\n        print(\"NO\")\n        exit()\n\nfor i in range(n):\n    r = 0\n    l = 0\n    for j in range(i + 1, n):\n        if (otv[j] > otv[i]):\n            r += 1\n    for z in range(i - 1, -1, -1):\n        if (otv[z] > otv[i]):\n            l += 1\n    if (r != R[i]) or (l != L[i]):\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in range(n):\n    print(otv[i] + 1, end = ' ')","output":"quadratic"},{"instruction":"n=int(input())\nl=list(map(int, input().split()))\nr=list(map(int, input().split()))\nmaxx=0\ns=[]\nit=0\nfor i in range(n):\n    s.append(l[i]+r[i])\n    if l[i]>i or r[i]>n-i-1:\n        it=1\nits=list(s)\nwhile maxx<n:\n    summ=0\n    ll=0\n    rr=its.count(-1)\n    for i in range(n):\n        if its[i]==-1:\n            ll+=1\n            rr-=1\n        if its[i]!=-1 and i<n-1 and r[i]<rr:\n            it=1\n            break\n        if its[i]!=-1 and i>0 and l[i]<ll:\n            it=1\n            break\n    if it==1:\n        break\n    for i in range(n):\n        if s[i]==maxx:\n            s[i]=-maxx\n            its[i]=-1\n            summ+=1\n\n    if summ==0:\n        it=1\n        break\n    maxx+=summ\nif it==1:\n    print('NO')\nelse:\n    print('YES')\n    for i in s:\n        print(i-min(s)+1, end=' ')","output":"quadratic"},{"instruction":"n,k=map(int, input().split())\na = list(map(int, input().split()))\n\nc = a[-1] - a[0]\n\nd = [a[i]-a[i-1] for i in range(1, n)]\nd = sorted(d)[::-1]\nc -= sum(d[:k-1])\nprint(c)","output":"nlogn"},{"instruction":"n,k = map(int, input().split())\n\nl = 0\nr = n\nwhile True:\n    m = int((l+r)\/2)\n    S = int(((n-m)**2 + n - 3 * m)\/2)\n    if S == k:\n        print(m)\n        break\n    elif S < k:\n        r = m\n    else:\n        l = m","output":"logn"},{"instruction":"n = int(input())\nblack = list(input())\nwhite = list(input())\nkatie = list(input())\n\nALPHABET = [chr(i) for i in range(65, 65+26)] + [chr(i)\n                                                 for i in range(97, 97+26)]\n\ndef optimal_score(LIST):\n    d = {char: 0 for char in ALPHABET}\n    for v in LIST:\n        d[v] += 1\n    max_freq = max(d.values())\n    L = len(LIST)\n    res = 0\n    for freq in d.values():\n        if L - freq >= n:\n            res = max(res, freq + n)\n        else:\n            if not (L -freq < n and n == 1):\n                res = L\n            else:\n                res = max(res, L - 1)\n    return res\n\nscore_black = optimal_score(black)\nscore_white = optimal_score(white)\nscore_katie = optimal_score(katie)\n\nM = max(score_black, score_katie, score_white)\nMAXCNT = 0\n\nwinner = \"NOBODY\"\n\nif M == score_black:\n    winner = \"Kuro\"\n    MAXCNT += 1\nif M == score_white:\n    winner = \"Shiro\"\n    MAXCNT += 1\nif M == score_katie:\n    winner = \"Katie\"\n    MAXCNT += 1\n\nif MAXCNT == 1:\n    print(winner)\n\nelse:\n    print(\"Draw\")","output":"linear"},{"instruction":"from sys import stdin\nfrom collections import deque\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n,m=map(int,stdin.readline().strip().split())\n    s=deque(stdin.readline().strip())\n    arr=[\"R\",\"G\",\"B\"]\n    ans=n+3\n    for k in range(1):\n\n        for  i in range(3):\n            x=i\n\n            dp=[0 for i in range(n+1)]\n            for j in range(n):\n\n                if s[j]!=arr[x]:\n                    dp[j+1]+=1\n                dp[j+1]+=dp[j]\n                if j+1>=m:\n\n                    ans=min(ans,dp[j+1]-dp[j+1-m])\n                x+=1\n                x=x%3\n\n    print(ans)\n\n1","output":"linear"},{"instruction":"n, k = [int(x) for x in input().split()]\nif k == 1:\n    print(\"1\" + \"0\"*(n-1))\nelif 3*k <= n:\n\n    print((\"0\" * ((n-k)\/\/2)) + \"1\" + (\"0\"*(k-2)) + \"1\" + \"0\" * ((n-k)\/\/2))\nelse:\n    tmp = \"0\" * ((n-k)\/\/2) + \"1\"\n    s = tmp\n    s = tmp * (n \/\/ len(tmp) + 1)\n    s = s[:n]\n    print(s)","output":"constant"},{"instruction":"l, r = map(int, input().split())\n\nprint(0 if l == r else 2 ** len(bin(l ^ r)[2:]) - 1)","output":"logn"},{"instruction":"from sys import stdin\nreadline = stdin.readline\ndef readInt():\n    return int(readline())\ndef readInts():\n    return list(map(int,readline().split()))\n\nn, m, k = readInts()\n\nright = []\ndown = []\n\nfor i in range(n):\n    row = readInts()\n    right.append(row)\n\nfor i in range(n-1):\n    row = readInts()\n    down.append(row)\n\nif k % 2 == 1:\n    for _ in range(n):\n        for _ in range(m):\n            print(-1, end=\" \")\n        print()\n    exit()\n\nk \/\/= 2\n\ndp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]\n\nfor l in range(k):\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][l+1] = float(\"inf\")\n            if i > 0:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])\n            if j > 0:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])\n            if i < n - 1:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])\n            if j < m - 1:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])\n\nfor i in range(n):\n    for j in range(m):\n        print(2*dp[i][j][k], end=\" \")\n    print()","output":"cubic"},{"instruction":"n,m = map(int,input().split())\narr1 = list(map(int,input().split()))\narr2 = list(map(int,input().split()))\n\nprint(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))","output":"quadratic"},{"instruction":"import math\nn=int(input())\nlst = list(map(int, input().strip().split(' ')))\n\np=max(lst)\nind=lst.index(p)\nif p==1:\n    lst[ind]=2\nelse:\n    lst[ind]=1\nlst.sort()\nfor j in range(n):\n    print(lst[j],end=\" \")","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = rint()\n    deg, edges = [0] * n, rints_2d(n - 1)\n    if n == 2:\n        exit(print(f'Yes\\n1\\n1 2'))\n\n    for u, v in edges:\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n\n    ix = deg.index(max(deg))\n\n    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:\n        print(f'Yes\\n{deg.count(1)}')\n\n        for i in range(n):\n            if deg[i] == 1:\n                print(i + 1, ix + 1)\n    else:\n        print('No')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"class Solver:\n    def solve(self):\n        self.num_people = int(input())\n\n        if self.num_people % 4 == 2:\n            return -1\n\n        return self.find_zero_pair()\n\n    def find_zero_pair(self):\n        begin = 1\n        end = self.num_people \/\/ 2 + 1\n\n        begin_value = self.func(begin)\n        if begin_value == 0:\n            return begin\n\n        while begin < end:\n            mid = (begin + end) \/\/ 2\n            mid_value = self.func(mid)\n            if mid_value == 0:\n                return mid\n            elif begin_value * mid_value > 0:\n                begin = mid + 1\n            else:\n                end = mid - 1\n\n        return begin\n\n    def func(self, pos):\n        opposite = (pos - 1 + self.num_people \/\/ 2) % self.num_people + 1\n        return self.get_value(pos) - self.get_value(opposite)\n\n    def get_value(self, pos):\n        print('? {}'.format(pos))\n        value = int(input())\n        return value\n\nsolver = Solver()\npair = solver.solve()\nprint('! {}'.format(pair))","output":"logn"},{"instruction":"from collections import defaultdict\n\nn,k=[int(i) for i in input().strip().split()]\nl=[int(i) for i in input().strip().split()]\nif(k==1):\n    print(n)\nelse:\n    l.sort()\n    ndict=defaultdict(list)\n    for x in l:\n        i=x\n        while(i%k==0):\n            i=i\/k\n        ndict[i].append(x)\n    ans=0\n    for i in ndict.values():\n        count=0\n        while(count<len(i)):\n            if(count==len(i)-1):\n                ans+=1\n                break\n            if(i[count]*k!=i[count+1]):\n                ans+=1\n                count+=1\n            else:\n                ans+=1\n                count+=2\n    print(ans)","output":"nlogn"},{"instruction":"a,b=map(int,input().split())\nc=list(map(int,input().split()))\nd=list(map(int,input().split()))\ne=[]\nfor i in c:\n    if i in d:\n        e.append(i)\nfor j in e:\n    print(j,end=\" \")","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nv = list(map(int, input().split()))\n\nd = {}\nans = 0\n\nfor x in v:\n  num_d, mod_k = len(str(x)), x % k\n  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)\n\nfor x in v:\n  num_d, mod_k = len(str(x)), x % k\n  for add, mods in d.items():\n    val_mod = (mod_k * 10 ** add) % k\n    need_mod = (k - val_mod) % k\n    ans += len(mods.get(need_mod, []))\n    if need_mod == mod_k and add == num_d:\n      ans -= 1\n\nprint(ans)","output":"nlogn"},{"instruction":"def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 10 ** 10\n    for i in range(n):\n        x = i if i > n - i - 1 else n - i - 1\n        ans = min(ans, arr[i] \/\/ x)\n    print(ans)\nmain()","output":"linear"},{"instruction":"import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\nsys.setrecursionlimit(2*10**5+10)\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\ndebug = lambda x: sys.stderr.write(x+\"\\n\")\nwritef = lambda x: print(\"{:.12f}\".format(x))\n\nclass SG:\n    def __init__(self, n, v=None):\n        self._n = n\n        self.geta = 0\n        x = 0\n        while (1 << x) < n:\n            x += 1\n        self._log = x\n        self._size = 1 << self._log\n        self._d = [ninf] * (2 * self._size)\n        if v is not None:\n            for i in range(self._n):\n                self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n    def _update(self, k):\n        self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])\n    def update(self, p, x):\n        assert 0 <= p < self._n\n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n\n            k = p>>i\n            self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])\n    def get(self, p):\n        assert 0 <= p < self._n\n        return self._d[p + self._size]\n    def check(self):\n        return [self.get(p) for p in range(self._n)]\n    def query(self, left, right):\n\n        assert 0 <= left <= right <= self._n\n        sml = ninf\n        smr = ninf\n        left += self._size\n        right += self._size\n\n        while left < right:\n            if left & 1:\n                sml = op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n        return op(sml, smr)\n\n    def query_all(self):\n        return self._d[1]\n    def max_right(self, left, f):\n\n        if left == self._n:\n            return self._n\n        left += self._size\n        sm = ninf\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(op(sm, self._d[left])):\n                        sm = op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = op(sm, self._d[left])\n            left += 1\n        return self._n\n    def min_left(self, right, f):\n\n        if right == 0:\n            return 0\n        right += self._size\n        sm = ninf\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(op(self._d[right], sm)):\n                        sm = op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = op(self._d[right], sm)\n        return 0\nop = max\nninf = 0\n\nn = int(input())\na = list(map(int, input().split()))\nvs = [[0]*(n-i) for i in range(n)]\nvs[0] = a\nfor i in range(1,n):\n    for j in range(n-i):\n        vs[i][j] = vs[i-1][j]^vs[i-1][j+1]\ndef f(l,r):\n    return vs[r-l][l]\nms = [[0]*n for _ in range(n)]\nfor l in range(n):\n    ms[l][l] = f(l,l)\n    for r in range(l+1,n):\n        ms[l][r] = max(ms[l][r-1], f(l,r))\nsgs = []\nfor r in range(n):\n    l = [ms[l][r] for l in range(r+1)]\n    sg = SG(len(l), l)\n    sgs.append(sg)\nq = int(input())\nans = []\nfor _ in range(q):\n    l,r = map(int, input().split())\n    l -= 1\n    r -= 1\n    val = sgs[r].query(l,r+1)\n    ans.append(val)\n\nwrite(\"\\n\".join(map(str, ans)))","output":"quadratic"},{"instruction":"point = {}\n\nn = int(input())\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    r += 1\n    if l not in point:\n        point[l] = 0\n    if r not in point:\n        point[r] = 0\n    point[l] += 1\n    point[r] -= 1\n\nline = []\nfor key in point:\n    line.append((key,point[key]))\nline.sort()\nans = [0] * (n+1)\n\nlast_index = 0\nlast_value = 0\n\nfor index, value in line:\n    ans[last_value] += index - last_index\n    last_index = index\n    last_value += value\n\nfor cnt in ans[1:]:\n    print(cnt,end=' ')","output":"nlogn"},{"instruction":"import sys\nlines = int(sys.stdin.readline())\ndp = [0] * lines\nf = 1\ndp[0] = 1\n\nfor i in range(lines):\n  char_in = sys.stdin.readline()[0]\n  if char_in == 'f':\n    f += 1\n  else:\n\n    for j in range(1, f):\n      dp[j] = (dp[j] + dp[j- 1]) % 1000000007\nprint(dp[f - 1])","output":"quadratic"},{"instruction":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumOfSquares(n)\n\n        while slow != fast:\n            fast = self.sumOfSquares(fast)\n            fast = self.sumOfSquares(fast)\n            slow = self.sumOfSquares(slow)\n        return True if fast == 1 else False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n \/\/ 10\n        return output","output":"logn"},{"instruction":"n = int(input())\na = [list(map(int,input().split())) for i in range(n)]\nfor t in range(n):\n    a[t].append(t+1)\na.sort()\nfor i in range(n-1):\n    if a[i][1] >= a[i+1][1]:\n        print(a[i+1][2],a[i][2])\n        exit()\n    if a[i][0] == a[i+1][0] and a[i][1] <= a[i+1][1]:\n        print(a[i][2],a[i+1][2])\n        exit()\nprint(-1,-1)","output":"nlogn"},{"instruction":"R = lambda: map(int, input().split())\na = sorted(map(int, input()))\nb = list(map(int, input()))\nbn = int(''.join(map(str, b)))\nres = int(''.join(map(str, sorted(a))))\nif len(b) != len(a):\n    print(''.join(map(str, sorted(a, reverse=True))))\nelse:\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if a[i] < a[j] < b[i]:\n                a[i], a[j] = a[j], a[i]\n        tmp = int(''.join(map(str, a[:i + 1] + sorted(a[i + 1:], reverse=True))))\n        res = max(res, tmp) if tmp <= bn else res\n        for j in range(i + 1, len(a)):\n            if a[j] == b[i]:\n                a[i], a[j] = a[j], a[i]\n    print(res)","output":"cubic"},{"instruction":"def inp():\n    return map(int, input().split())\n\ndef sum_range(n):\n    return (n * (n + 1)) \/\/ 2\n\ndef bs(st, en):\n    while (st < en):\n        mid = st + (en - st) \/\/ 2\n        s1 = s - sum_range(mid - 1)\n\n        if s1 == n:\n            return (k - mid) + 1\n        elif s1 > n:\n            st = mid + 1\n        else:\n            en = mid\n    return (k - st) + 2\n\nn, k = inp()\nn -= 1\nk -= 1\ns = sum_range(k)\n\nif n+1 == 1:\n    print(0)\nelif n <= k:\n    exit(print(1))\nelif n > s:\n    print(-1)\nelse:\n    print(bs(1, k))","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a=list(map(int,input().rstrip()))\n    b=list(map(int,input().rstrip()))\n    ans,la,lb=[],len(a),len(b)\n    if la!=lb:\n        print(*sorted(a,reverse=True),sep=\"\")\n    else:\n        for i in range(lb):\n            if b[i] in a:\n                ans.append(b[i])\n                a.remove(b[i])\n            else:\n                ma=-1\n                for j in a:\n                    if j<b[i]:\n                        ma=max(ma,j)\n                if ma!=-1:\n                    ans.append(ma)\n                    a.remove(ma)\n                else:\n                    i-=1\n                    while ans:\n                        a.append(ans.pop())\n                        ma=-1\n                        for j in a:\n                            if j<b[i]:\n                                ma=max(ma,j)\n                        if ma!=-1:\n                            ans.append(ma)\n                            a.remove(ma)\n                            break\n                        i-=1\n                a.sort()\n                while a:\n                    ans.append(a.pop())\n                break\n        print(\"\".join(str(i) for i in ans))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\ni = 0\nans = 0\nwhile i < len(l)-1:\n    if l[i] == l[i+1]:\n        i = i+1\n        continue\n\n    j = i+1\n    ind = -1\n    while j < len(l):\n        if l[j] == l[i]:\n            ind = j\n            break\n\n        j = j+1\n\n    while ind > i+1:\n        l[ind],l[ind-1] = l[ind-1],l[ind]\n        ans += 1\n        ind -= 1\n\n    i += 1\n\nprint(ans)","output":"quadratic"},{"instruction":"n, m, k = list(map(int, input().split()))\nf = list(map(int, input().split()))\nf.sort()\n\nfs = 0\nptr = len(f) - 1\nwhile ptr >= 0:\n    if m <= k:\n        print(fs)\n        exit()\n    k -= 1\n    k += f[ptr]\n    fs += 1\n    ptr -= 1\n\nif m <= k:\n    print(fs)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"n = int(input())\nx, y = map(int, input().split())\n\nif abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):\n    print('White')\nelse:\n    print('Black')","output":"constant"},{"instruction":"from os import path\nimport sys\nfrom heapq import heappush,heappop,heapify\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\nfile=1\n\ndef solve():\n\n    n,q=mi()\n\n    x=int(log(n+1,2))\n    root=1<<(x-1)\n    for i in range(q):\n        u=ii()\n        s=si()\n        pos='U'\n        if(u<root):\n            pos='L'\n        if(u>root):\n            pos='R'\n\n        s1=bin(u)[2:]\n        s1='0'*(x-len(s1))+s1\n        s1=list(s1)\n        for j in s:\n            for k in range(x-1,-1,-1):\n                if s1[k]=='1':\n                    f=k\n                    break\n            if j=='L':\n                if(f==x-1):\n                    continue\n                s1[f]='0'\n                s1[f+1]='1'\n            elif(j=='R'):\n                if(f==x-1):\n                    continue\n                s1[f+1]='1'\n            else:\n                if f==0:\n                    continue\n                if s1[f-1]=='1':\n                    s1[f]='0'\n                else:\n                    s1[f-1]='1'\n                    s1[f]='0'\n\n        s1=\"\".join(s1)\n        print(int(s1,2))\n\nif __name__ ==\"__main__\":\n\n    if(file):\n\n        if path.exists('input.txt'):\n            sys.stdin=open('input.txt', 'r')\n            sys.stdout=open('output.txt','w')\n        else:\n            input=sys.stdin.readline\n    solve()","output":"np"},{"instruction":"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp \/ a)\nans = int((res % (10 ** (x+1))) \/ (10 ** x))\nprint(ans)","output":"constant"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz\/\"\nM = 1000000007\nEPS = 1e-6\n\ndef Ceil(a, b):\n    return a \/\/ b + int(a % b > 0)\n\ndef value():\n    return tuple(map(int, input().split()))\n\ndef array():\n    return [int(i) for i in input().split()]\n\ndef Int():\n    return int(input())\n\ndef Str():\n    return input()\n\ndef arrayS():\n    return [i for i in input().split()]\n\nn=int(input())\na=list(map(int,input().split(\" \")))\ndic=defaultdict(lambda:0)\ncursum=0\nans=0\nfor i in range(n):\n    ele=a[i]\n    if ele-1 in dic.keys() and ele+1 in dic.keys():\n        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))\n    elif ele-1 in dic.keys():\n        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))\n    elif ele+1 in dic.keys():\n        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))\n    else:\n        ans+=(ele*i-cursum)\n    dic[ele]+=1\n    cursum+=ele\nprint(ans)","output":"nlogn"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, k = mi()\nans = (n * 2 + k - 1) \/\/ k + (n * 5 + k - 1) \/\/ k + (n * 8 + k - 1) \/\/ k\nprint(ans)","output":"constant"},{"instruction":"max_ = 10**18\narr  = [0, 1]\narr2 = [0, 3]\nwhile arr[-1] < max_:\n    arr.append(arr[-1]*4)\n    arr2.append(arr2[-1]*2+1)\n\nfor i in range(1, len(arr)):\n    arr[i] += arr[i-1]\n\ndef solve(n, k):\n    if n==2 and k==3:\n        return 'NO'\n    if n==2 and k==4:\n        return 'YES 0'\n    if n+1<=len(arr) and k > arr[n]:\n         return 'NO'\n\n    i=0\n    while k >= arr[i+1]:\n        i+=1\n    if k-arr[i] > arr2[i]:\n        i+=1\n    return 'YES ' +str(n-i)\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    print(solve(n, k))","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport itertools\nimport bisect\nimport heapq\nsys.setrecursionlimit(100000)\n\ndef main():\n    pass\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n \/ i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n \/ i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n \/\/ i)\n    return (n)\ndef p2(n):\n    c=0\n    while(n%2==0):\n        n\/\/=2\n        c+=1\n    return c\ndef seive(n):\n    primes=[True]*(n+1)\n    primes[1]=primes[0]=False\n    for i in range(2,n+1):\n        if(primes[i]):\n            for j in range(i+i,n+1,i):\n                primes[j]=False\n    p=[]\n    for i in range(0,n+1):\n        if(primes[i]):\n            p.append(i)\n    return(p)\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\ndef denofactinverse(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return (pow(fac,m-2,m))\ndef numofact(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return(fac)\ndef sod(n):\n    s=0\n    while(n>0):\n        s+=n%10\n        n\/\/=10\n    return s\ndef getVal(x,y,sx,sy):\n\n    if (x == -1 or y == -1 or x == n or y == m):\n        return inF\n    elif(sx==x):\n        return hor[sx][min(sy,y)]\n    else:\n        return ver[min(sx,x)][sy]\ndef rec(k,x,y):\n    if(x==-1 or y==-1 or x>=n or y>=m):\n        return inF\n    elif (k == 0):\n\n        dp[k][x][y] = 0\n        return dp[k][x][y]\n    elif(dp[k][x][y]!=-1):\n        return dp[k][x][y]\n    else:\n\n        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)\n        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)\n        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)\n        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)\n        dp[k][x][y]=min(val1,val2,val3,val4)\n        return dp[k][x][y]\nn,m,k=map(int,input().split())\nadj=[[-1]*n for i in range(0,m)]\nif(k%2):\n    for i in range(0, n):\n        for j in range(0, m):\n            print(-1, end=\" \")\n        print(\"\")\nelse:\n    hor,ver=[],[]\n    inF=10**20\n    k\/\/=2\n    for i in range(0,n):\n        hor.append(list(map(int,input().split())))\n    for i in range(0,n-1):\n        ver.append(list(map(int,input().split())))\n    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]\n    for i in range(0,n):\n        for j in range(0,m):\n            print(2*rec(k,i,j),end=\" \")\n        print(\"\")","output":"cubic"},{"instruction":"n,m = map(int,input().split())\n\nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")","output":"constant"},{"instruction":"n,k = map(int, input().split())\n\nv = list(map(int, input().split()))\nv.sort()\nans = 0\ncnt = 0\nar = [0]  * 1000000\nfor i in range(len(v)):\n    while  cnt>0 and v[i] > ar[cnt] and v[i] <= k+ar[cnt] :\n        cnt=cnt-1\n    cnt = cnt + 1\n    ar[cnt] = v[i]\nprint(cnt)","output":"nlogn"},{"instruction":"[l,r]=list(map(int,input().split()))\n\nif l==r:\n    print(0)\nelse:\n    a=bin(l)\n    b=bin(r)\n    a=list(a[2:])\n    b=list(b[2:])\n    d=0\n    if len(a)!=len(b):\n        d=len(b)-len(a)\n        acta=['0']*d\n        for j in a:\n            acta.append(j)\n        a=acta\n    flag=0\n    sol=len(b)\n    pos=-1\n    for i in range(len(b)-1,-1,-1):\n        if a[i]!=b[i]:\n            pos=sol-i\n    if pos!=-1:\n        sol=pos\n\n    print((2**sol)-1)","output":"logn"},{"instruction":"import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\na = {0:0}\n\nfor i in range(n):\n    b = a.copy()\n    for p in a.items():\n        d = gcd(p[0], l[i])\n        cost = p[1] + c[i]\n        if d not in b: b[d] = cost\n        elif b[d] > cost: b[d] = cost\n    a = b\n\nif 1 not in a: a[1] = -1\nprint(a[1])","output":"np"},{"instruction":"import math\nimport sys\nimport collections\nimport bisect\nimport time\nimport random\nfrom itertools import permutations\ndef get_ints():return map(int, sys.stdin.readline().strip().split())\ndef get_list():return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string():return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    arr=get_list()\n    unique=set(arr)\n    poss=False\n    for i in arr:\n        for j in range(32):\n            if i+(2**j) in unique and i-(2**j) in unique:\n                print(3)\n                print(i,i+2**j,i-2**j)\n                poss=True\n                break\n        if poss:\n            break\n    if poss:\n        break\n    for i in arr:\n        for j in range(32):\n            if i+(2**j) in unique:\n                print(2)\n                print(i,i+2**j)\n                poss=True\n                break\n        if poss:\n            break\n    if poss:\n        break\n    print(1)\n    print(arr[0])","output":"nlogn"},{"instruction":"def norm(x):\n    return (x % 998244353 + 998244353) % 998244353\n\nn, k = map(int, input().split())\n\ndp1 = [0]\ndp2 = [0]\n\nfor i in range(n):\n    l = [1]\n    cur = 0\n    for j in range(n + 1):\n        cur += l[j]\n        if(j > i):\n            cur -= l[j - i - 1]\n        cur = norm(cur)\n        l.append(cur)\n    dp1.append(l[n])\n    dp2.append(norm(dp1[i + 1] - dp1[i]))\n\nans = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if(i * j < k):\n            ans = norm(ans + dp2[i] * dp2[j])\n\nans = norm(ans * 2)\n\nprint(ans)","output":"quadratic"},{"instruction":"from collections import deque as de\nimport math\nimport re\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\nfrom itertools import groupby as gb\nfrom fractions import Fraction as fr\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef binarytodecimal(n):\n    return int(n,2)\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n    return prime_factors\n\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef getProduct(n):\n\n    product = 1\n\n    while (n != 0):\n        product = product * (n % 10)\n        n = n \/\/ 10\n\n    return product\n\ndef dupconscount(nums):\n    element = []\n    freque = []\n    if not nums:\n        return element\n    running_count = 1\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            running_count += 1\n        else:\n            freque.append(running_count)\n            element.append(nums[i])\n            running_count = 1\n    freque.append(running_count)\n    element.append(nums[i+1])\n    return element,freque\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\ndef ceildiv(x,y):\n    return (x+y-1)\/\/y\n\ndef di():return map(int, input().split())\ndef ii():return int(input())\ndef li():return list(map(int, input().split()))\ndef si():return list(map(str, input()))\ndef indic():\n    dic = {}\n    for index, value in enumerate(input().split()):\n        dic[int(index)+1] = int(value)\n    return dic\n\nn,p=di()\na=li()\nfir=a[0]\nsec=sum(a)-fir\nans=(fir%p)+(sec%p)\nfor i in range(1,n):\n    fir+=a[i]\n    sec-=a[i]\n    temp=(fir%p)+(sec%p)\n    if temp >ans:\n        ans=temp\nprint(ans)","output":"linear"},{"instruction":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n\n        def dfs(i):\n            if i >= len(cost):\n                return 0\n            return cost[i] + min(dfs(i + 1), dfs(i + 2))\n\n        return min(dfs(0), dfs(1))","output":"np"},{"instruction":"n=int(input())\nm=int(input())\n\nif n>(m+1)\/2:\n\tprint(m)\nelse:\n\tprint(int(m%(2**n)))","output":"constant"},{"instruction":"l,r = map(int,input().split())\n\na = \"{0:062b}\".format(l)\nb = \"{0:062b}\".format(r)\n\nn = len(a)\ni = 0\n\nif (l == r):\n    print(0)\nelse:\n    while (i<n and a[i] == b[i]):\n        i += 1\n    print(2**(62-i) - 1)","output":"logn"},{"instruction":"a=input()\nb=input()\nv=sorted(a)\nv=v[::-1]\nx=\"\"\nfor i in range(len(v)):\n    x=x+v[i]\nv=x\nif(len(a)<len(b)):\n    print(v)\nelse:\n    if(b==a):\n        print(a)\n    else:\n        fin=\"\"\n        flag=False\n        for j in range(len(a)):\n            for k in range(len(a)):\n                num=fin+v[k]+''.join(sorted(v[:k:]+v[k+1::]))\n\n                if(num<=b):\n                    fin+=v[k]\n\n                    if(int(v[k])<int(b[j])):\n                        flag=True\n                        v=v[:k:]+v[k+1::]\n                        fin+=v\n                    v=v[:k:]+v[k+1::]\n                    break\n            if(flag):\n                break\n        print(fin)","output":"cubic"},{"instruction":"_ = int(input())\nbinary_number = input()\n\nif binary_number == '0':\n    print('0')\nelse:\n    count_0 = sum(1 for b in binary_number if b == '0')\n    count_1 = sum(1 for b in binary_number if b == '1')\n    print('1' + '0' * count_0)","output":"linear"},{"instruction":"import math\nimport sys\nimport collections\n\ndef getdict(n):\n    d = {}\n    if type(n) is list:\n        for i in n:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n    else:\n        for i in range(n):\n            t = ii()\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n    return d\ndef cdiv(n, k): return n \/\/ k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\n\nt = ii()\nfor i in range(t):\n    n = ii()\n    d = sorted(li())\n    print(min(d[-2] - 1, n - 2))","output":"nlogn"},{"instruction":"for ctr in range(1):\n    s=input().strip()\n    for l in range(len(s),0,-1):\n        k=[]\n        for i in range(0,len(s)-l+1):\n            k.append(s[i:i+l])\n        if len(k)!=len(list(set(k))):\n            print(l)\n            exit()\n    print(0)","output":"cubic"},{"instruction":"from sys import stdin, gettrace\n\nif gettrace():\n    inputi = input\nelse:\n    def input():\n        return next(stdin)[:-1]\n\n    def inputi():\n        return stdin.buffer.readline()\n\ndef main():\n    r, g, b = map(int, inputi().split())\n    rr = list(sorted(int(a) for a in inputi().split()))\n    gg = list(sorted(int(a) for a in inputi().split()))\n    bb = list(sorted(int(a) for a in inputi().split()))\n    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n    res = 0\n    for i in range(r, -1, -1):\n        for j in range(g, -1, -1):\n            for k in range(b, -1, -1):\n                if i > 0 and j > 0:\n                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])\n                if i > 0 and k > 0:\n                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])\n                if j > 0 and k > 0:\n                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])\n                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])\n    print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"for i in range(int(input())):\n    n,k=[int(i) for i in input().split()]\n    if n>31:\n        print('YES '+str(n-1))\n    else:\n        rez=-1\n        for i in range(1,n+1):\n            x=(4**i-2**(i+1)+1)*((4**(n-i)-1)\/\/3)+(4**i-1)\/\/3\n            y=(4**i-1)\/\/3-(4**(i-1)-1)\/\/3\n            if y<=k<=x:\n                rez=n-i\n                break\n        print('YES '+str(rez) if rez!=-1 else 'NO')","output":"logn"},{"instruction":"import sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = True\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = False\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag and T:\n        print('YES')\n        print(*[t+1 for t in T])\n    else:\n        print('NO')\n\nmain()","output":"np"},{"instruction":"def solve(n, a):\n    a = sorted(a)\n    col = [False for i in range(n)]\n    count = 0\n    for i in range(n):\n        if not col[i]:\n            count += 1\n            col[i] = True\n            for j in range(n):\n                if a[j] % a[i] == 0:\n                    col[j] = True\n    return count\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(n, a))","output":"quadratic"},{"instruction":"arr = []\nd = {}\nfor _ in range(int(input())):\n    s = input()\n    a,b,c = tuple(map(int, s.replace(\"(\",\"\").replace(\")\",\"\").replace(\"\/\",\".\").replace(\"+\",\".\").split(\".\")))\n    x = (a+b)\/c\n    arr.append(x)\n    if x not in d:\n        d[x] = 0\n    d[x] += 1\n\nfor i in arr:\n    print(d[i], end = \" \")","output":"linear"},{"instruction":"from sys import stdin, stdout\nfrom collections import defaultdict\n\nn, m, k = map(int, stdin.readline().split())\n\ndic = defaultdict(lambda : {})\nfor i in range(n):\n    line = tuple(map(int, stdin.readline().split()))\n    for j in range(m-1):\n        dic[i*m+j][i*m+j+1] = line[j]*2\n        dic[i*m+j+1][i*m+j] = line[j]*2\n\nfor i in range(n-1):\n    line = tuple(map(int, stdin.readline().split()))\n    for j in range(m):\n        dic[i*m+j][(i+1)*m+j] = line[j]*2\n        dic[(i+1)*m+j][i*m+j] = line[j]*2\n\nif k % 2 != 0:\n    for i in range(n):\n        stdout.write(' '.join(('-1',)*m))\n        stdout.write('\\n')\nelse:\n    prev = []\n    di = (1, 0, -1, 0)\n    dj = (0, 1, 0, -1)\n    for _ in range(n):\n        prev.append((0,)*m)\n\n    for _ in range(k\/\/2):\n        new = []\n        for _ in range(n):\n            new.append([100_000_000]*m)\n\n        for num in dic:\n            i = num \/\/ m\n            j = num % m\n            for idx in range(4):\n                ii = i + di[idx]\n                jj = j + dj[idx]\n                if not ((0 <= ii < n) and (0 <= jj < m)): continue\n                new[ii][jj] = min(new[ii][jj], prev[i][j] + dic[i*m+j][ii*m+jj])\n\n        prev = new\n\n    for i in range(n):\n        stdout.write(' '.join(map(str, prev[i])))\n        stdout.write('\\n')","output":"cubic"},{"instruction":"n,k=map(int,input().split())\nd=(n-k)\/\/2\ns=0\nwhile s!=n:\n    if (s+1)%(d+1)==0:\n        print(\"1\",end=\"\")\n    else :\n        print(\"0\",end=\"\")\n    s+=1","output":"linear"},{"instruction":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []","output":"quadratic"},{"instruction":"n=int(input())\nm=int(input())\na=list(map(int, input().split()))\nb=list(map(int, input().split()))\ncurr=m\nf=0\nif b[0]!=1:\n    curr+=(curr)\/(b[0]-1)\nelse:\n    f=1\nfor i in range(n-1,-1,-1):\n    if a[i]!=1:\n        curr+=(curr)\/(a[i]-1)\n    else:\n        f=1\n    if i>0:\n        if b[i]!=1:\n            curr+=(curr)\/(b[i]-1)\n        else:\n            f=1\nif f:\n    print(-1)\nelse:\n    print(curr-m)","output":"linear"},{"instruction":"l, r = map(int, input().split())\nprint(2**(l ^ r).bit_length() -1)","output":"logn"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\ndp = abs(x - y) * t1;\ndl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3;\nif dp < dl:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"constant"},{"instruction":"fre =[0,0,0,0,0,0,0,0,0,0,0]\na=input();b=input()\nc=False\ndef DFS(aa,bb):\n  if int(aa)==len(a):\n    print(bb)\n    exit()\n  global c\n  for i in range(9,-1,-1):\n    if (fre[i]>0 and i<=int(b[int(aa)])) or (fre[i]>0 and c):\n      fre[i]-=1\n      if i<int(b[int(aa)]):\n        c=True\n      DFS(aa+1,bb*10+i)\n      fre[i]+=1\n      c=False\n\nif len(b)>len(a):\n  x=sorted(a);\n\n  print(*x[::-1],sep='')\nelse:\n  for i in a:\n    fre[int(i)]+=1\n  DFS(0,0)","output":"cubic"},{"instruction":"def main():\n    import sys\n    read = sys.stdin.read\n    readline = sys.stdin.readline\n    INF = 1 << 60\n    MOD = 10 ** 9 + 7\n    sys.setrecursionlimit(10 ** 5)\n\n    def new_dp():\n        return [[INF] * M for _ in range(N)]\n\n    def solve():\n        if K % 2 == 1:\n            for row in range(N):\n                print(*[-1] * M)\n            return\n\n        dp_prev = [[0] * M for _ in range(N)]\n\n        for _ in range(K \/\/ 2):\n            dp_cur = new_dp()\n            for row in range(N):\n                for col in range(M - 1):\n                    cost = e1[row][col]\n                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row][col + 1] + cost)\n                    dp_cur[row][col + 1] = min(dp_cur[row][col + 1], dp_prev[row][col] + cost)\n            for row in range(N - 1):\n                for col in range(M):\n                    cost = e2[row][col]\n                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row + 1][col] + cost)\n                    dp_cur[row + 1][col] = min(dp_cur[row + 1][col], dp_prev[row][col] + cost)\n            dp_prev = dp_cur\n\n        for row in range(N):\n            _r = [2 * x for x in dp_prev[row]]\n            print(*_r)\n\n    N, M, K = map(int, readline().split())\n\n    e1 = []\n    for _ in range(N):\n        r = tuple(map(int, readline().split()))\n        e1.append(r)\n    e2 = []\n\n    for _ in range(N - 1):\n        r = tuple(map(int, readline().split()))\n        e2.append(r)\n    solve()\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"a, b  = map(int, input().split())\n\nk = 2**(a^b).bit_length()-1\nprint(k)","output":"logn"},{"instruction":"import math\n\ndef get_digit(x, pos):\n    s = []\n\n    while x > 0:\n        s.append(x%10)\n        x \/\/= 10\n\n    return s[::-1][pos]\n\ndef find_digit(x):\n    n     = 0\n    next_ = 9 * (10**n) * (n+1)\n\n    while next_ <= x:\n        x -= next_\n\n        n += 1\n        next_ = 9 * (10**n) * (n+1)\n\n    if x == 0:\n        return 9\n\n    pos_ = 10 ** n + math.ceil(x \/ (n+1)) - 1\n\n    return get_digit(pos_, (x-1)%(n+1))\n\nk = int(input())\nprint(find_digit(k))","output":"logn"},{"instruction":"n, k = map(int, input().split())\na = input().split()\nmods = [dict() for i in range(10)]\nl = [0] * n\nfor i in range(n):\n    l[i] = len(a[i])\n    a[i] = int(a[i]) % k\n    cur = a[i]\n    for j in range(10):\n        cur = cur * 10 % k\n        mods[j][cur] = mods[j].get(cur, 0) + 1\nans = 0\nfor i in range(n):\n    mod = (k - a[i]) % k\n    ans += mods[l[i] - 1].get(mod, 0)\n    cur = a[i]\n    for j in range(l[i]):\n        cur = cur * 10 % k\n    if cur == mod:\n        ans -= 1\nprint(ans)","output":"nlogn"},{"instruction":"n,t=int(input()),1\nwhile n>0:\n        if n!=3:\n            k=n\/\/2+n%2\n            print((str(t)+' ')*k,end= '')\n            n-=k\n            t*=2\n        else:\n            print(t,t,t*3)\n            n=0","output":"constant"},{"instruction":"def isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\nn=int(input());d=0\nif n%2==0:\n    print('4 '+str(n-4))\nelse:\n    i=4\n    while i<=int(n\/\/2)+1:\n        k=n-i\n        if isPrime(k)==False:\n            print(str(i)+' '+str(k))\n            break\n        i+=2","output":"constant"},{"instruction":"import sys\nfrom array import array\n\ndef readline() -> str: return sys.stdin.buffer.readline().decode('utf-8')\n\nn, k = map(int, readline().split())\nmod = 998244353\ndp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)]\ndp[0][0][1] = dp[3][0][1] = 1\ndp[1][0][2] = dp[2][0][2] = 1\n\nfor i in range(n-1):\n    for j in range(k+1):\n        for sbit in range(4):\n            for tbit in range(4):\n                add = (\n                    1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else\n                    (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0)\n                    + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0)\n                )\n                dp[tbit][i+1][j+add] += dp[sbit][i][j]\n                if dp[tbit][i+1][j+add] >= mod:\n                    dp[tbit][i+1][j+add] -= mod\n\nans = sum(dp[bit][-1][k] for bit in range(4)) % mod\nprint(ans)","output":"np"},{"instruction":"s=input()\nm=0\nn=len(s)\nfor i in range(n-1):\n    for j in range(i,n+1) :\n        if s[i:j] in s[i+1:n] and len(s[i:j])>m:\n            m=len(s[i:j])\nprint(m)","output":"cubic"},{"instruction":"n=int(input())\ng={}\nfor i in range(1,n):\n    p=int(input())\n    if g.get(p):g[p].append(i+1)\n    else:g[p]=[i+1]\nams='YES'\nfor i in g:\n    c=0\n    for j in g[i]:\n        if j not in g:c+=1\n    if c<3:ams='NO'\nprint(ams)","output":"linear"},{"instruction":"def f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\nimport math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"test=int(input())\nwhile test:\n\ttest=test-1\n\tn,k = input().split()\n\tn=int(n)\n\tk=int(k)\n\tif n==2 and k==3:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tif n>=32:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\tval=[]\n\tval.append(0)\n\tfor i in range(1,n+1):\n\t\tval.append(4*val[i-1]+1)\n\tif val[n]<k:\n\t\tprint(\"NO\")\n\t\tcontinue\n\ts=0\n\tt=2\n\trem=0\n\tflag=0\n\twhile s+t-1<=k and n>0:\n\t\ts=s+t-1\n\t\tt*=2\n\t\tn=n-1\n\tprint(\"YES\",n)","output":"logn"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\n\nn=L()[0]\nA=sorted(L())\nif A==[1]*n:\n    print(*A[:n-1],2)\nelse:\n    print(1,*A[:-1])\n\nendtime = time.time()","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\nq = 2 * n + 1\np = k \/\/ n\nif k % n:\n    print(p + 1)\nelse:\n    print(p)","output":"constant"},{"instruction":"n, m = map(int, input().split())\nx = list(list(map(int , input())) for i in range(n))\nres = [0] * m\nfor i in range(n):\n\tfor j in range(m):\n\t\tres[j] += x[i][j]\n\nfor i in range(n):\n\tok = 1\n\tfor j in range(m):\n\t\tif res[j] == 1 and x[i][j] == 1:\n\t\t\tok = 0\n\t\t\tbreak\n\tif ok:\n\t\tprint(\"YES\")\n\t\texit()\nprint(\"NO\")","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\nn = int(input())\ns = list(map(int,input().split()))\nc = list(map(int,input().split()))\nd = {}\nfor i in range(n-1):\n    ans = 10**12\n    for j in range(i+1,n):\n        if s[i] < s[j]:\n            ans = min(ans,c[i]+c[j])\n\n    d[i] = ans\n\nans = 10**12\nfor i in range(n-2):\n    for j in range(i+1,n-1):\n        if s[i] < s[j]:\n            ans = min(ans,c[i]+d[j])\n\nif ans == 10**12:\n    print(-1)\n\nelse:\n    print(ans)","output":"quadratic"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=99999999999999999999999999999999\ndef outIn(x):\n    print(x, flush=True)\n    return input()\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        s=rs()\n        d=Counter(s)\n        if '1' in d:\n            news=\"\"\n            for i in s:\n                if i!='1':\n                    news+=i\n            ans=\"\"\n            ind=len(news)\n            for i in range(len(news)):\n                if news[i]=='2':\n                    ind=i\n                    break\n\n            ans=news[0:ind]+'1'*d['1']+news[ind:]\n            ws(ans)\n        else:\n            ws(s)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"def cal(r, g, b):\n\tif dp[r][g][b] != -1:\n\t\treturn dp[r][g][b]\n\n\tarea = 0\n\tif r<R and g<G:\n\t\tarea = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))\n\tif r<R and b<B:\n\t\tarea = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))\n\tif g<G and b<B:\n\t\tarea = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))\n\tdp[r][g][b] = area\n\treturn area\n\nif __name__ == \"__main__\":\n\tR, G, B = map(int,input().split())\n\trl = sorted(list(map(int,input().split())), reverse=True)\n\tgl = sorted(list(map(int,input().split())), reverse=True)\n\tbl = sorted(list(map(int,input().split())), reverse=True)\n\tdp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]\n\tprint(cal(0,0,0))","output":"cubic"},{"instruction":"A,B = map(int, input().split())\nx,y,z = map(int, input().split())\nA1 = 2*x + y - A\nB1 = 3*z + y - B\nfinal = 0\nif A1 > 0:\n    final = final + A1\nif B1 > 0:\n    final = final + B1\nprint(final)","output":"constant"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nzz = ( (1,-1), (0,2), (1,-1) )\nnow = (0,0)\nfor i in range(N):\n    print(now[0],now[1])\n    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])","output":"linear"},{"instruction":"n=int(input())\nr=list(map(int,input().split()))\ndp=[0]*(10**5+1)\ncnt=[0]*(10**5+1)\ntmp=[0]*(10**5+1)\nmod=10**9+7\nfor i in range(n):\n\tcnt[r[i]]+=1\nfor i in range(1,10**5+1):\n\tfor j in range(2*i,10**5+1,i):\n\t\tcnt[i]+=cnt[j]\n\ttmp[i]=pow(2,cnt[i],mod)-1\nfor i in range(10**5,0,-1):\n\tfor j in range(2*i,10**5+1,i):\n\t\ttmp[i]=(tmp[i]-tmp[j])%mod\nprint(tmp[1]%mod)","output":"np"},{"instruction":"from sys import stdin\nimport math\n\nrgb = 'RGB'\n\nfor query in range(int(stdin.readline())):\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline()\n\n    ans = math.inf\n    for start in range(3):\n        dp = [0 for i in range(n + 1)]\n        for i in range(n):\n            cur = rgb[(start + i) % len(rgb)]\n            dp[i + 1] = dp[i] + int(s[i] != cur)\n        for i in range(n - k + 1):\n            ans = min(ans, dp[i + k] - dp[i])\n    print(ans)","output":"linear"},{"instruction":"from operator import itemgetter\n\ndef main():\n    n,m=map(int,input().split( ))\n    a=[]\n    for _ in range(m):\n        x,y=map(int,input().split( ))\n        x-=1;y-=1\n        a.append((x,y))\n    a=sorted(a,key=itemgetter(0,1))\n\n    ans=[-1]*n\n    for l,r in a:\n\n        if ans[l]==-1:\n\n            flag=1\n\n            for i in range(l,r+1):\n                if flag:\n                    ans[i]=1\n                else:\n                    ans[i]=0\n                flag^=1\n        else:\n\n            flag=1\n            x=ans[l]\n            for i in range(l,r+1):\n\n                if flag:\n                    ans[i]=x\n                else:\n                    ans[i]=x^1\n                flag^=1\n    for i in range(n):\n        if ans[i]==-1:\n            ans[i]=0\n\n    ans=map(str,ans)\n    print(''.join(ans))\nmain()","output":"linear"},{"instruction":"a0 = (1 << 30) - 1\n\na0 = 3\nb0 = 1\n\ndef mock_query(c, d):\n    res = (a0 ^ c) - (b0 ^ d)\n    if res > 0:\n        return 1\n    elif res < 0:\n        return -1\n    else:\n        return 0\n\ndef query2(c, d):\n    ans = mock_query(c, d)\n    print('? {:08b} {:08b} --> {}'.format(c, d, ans))\n    return ans\n\ndef query(c, d):\n    print('?', c, d)\n    return int(input())\n\ndef solve():\n    a = 0\n    b = 0\n    last_ans = query(0, 0)\n\n    pos = 29\n    while pos >= 0:\n        bit = 1 << pos\n\n        ans = query(a + bit, b + bit)\n        if (last_ans, ans) == (1, -1):\n            a += bit\n            last_ans = query(a, b)\n        elif (last_ans, ans) == (-1, 1):\n            b += bit\n            last_ans = query(a, b)\n\n        else:\n            last_ans = ans\n            ans = query(a + bit, b)\n            if ans == -1:\n                a += bit\n                b += bit\n\n        pos -= 1\n\n    print('!', a, b)\n\nsolve()","output":"logn"},{"instruction":"from sys import stdin\ninput = stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nl=[]\nfor i in range(n):\n    l.append((arr[i],i))\n\nl.sort(reverse=True)\n\ndp=[]\nx=0\nfor i in range(k):\n    dp.append(l[i][1])\n    x=x+l[i][0]\n\nprint(x)\ndp.sort()\ndp=[-1]+dp\n\nl=len(dp)\nfor i in range(1,l-1):\n    print(dp[i]-dp[i-1],end=\" \")\nprint(n-1-dp[l-2])","output":"nlogn"},{"instruction":"import math\ns1 = input()\ns2 = input()\nx = 0\ny = 0\np = 0\nfor i in range(len(s1)):\n    if s1[i] == '+': x+=1\n    elif s1[i] == '-': y+=1\n    if s2[i] == '+': x-=1\n    elif s2[i] == '-': y-=1\n    else: p+=1\nif x<0 or y<0:\n    print(float(0))\nelse:\n    q = math.factorial(x+y)\/(math.factorial(x)*math.factorial(y))\n    r = q\/math.pow(2,p)\n    print(r)","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [[False]*(n+2) for i in range(n+2)]\n\n    dp2 = [[600]*(n+2) for i in range(n+2)]\n    for i in range(n):\n        dp[i][i] = a[i]\n        dp2[i][i] = 1\n    for diff in range(1, n):\n        for i in range(n-diff):\n\n            for j in range(i, i+diff):\n                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:\n                    dp[i][i+diff] = dp[i][j] + 1\n                    dp2[i][i+diff] = 1\n                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])\n            if not dp2[i][i+diff]:\n                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)\n    print(dp2[0][n-1])","output":"cubic"},{"instruction":"R = lambda : map(int, input().split())\nn = int(input())\ns = input()\nhc, tc = s.count('H'), s.count('T')\nhr = min([s[i:i + hc].count('T') for i in range(n - hc)])\ntr = min([s[i:i + tc].count('H') for i in range(n - tc)])\nprint(min(hr, tr))","output":"linear"},{"instruction":"n = int(input())\n\narr = list(map(int, input().split()))\n\nsolved = False\ns = sum(arr)\nif s == 0:\n\tprint(\"cslnb\")\n\tsolved = True\n\nif not solved:\n\tn_num = {}\n\n\tfor item in arr:\n\t\tif item in n_num:\n\t\t\tn_num[item] += 1\n\t\telse:\n\t\t\tn_num[item] = 1\n\n\tif 0 in n_num and n_num[0] >= 2:\n\t\tprint('cslnb')\n\t\tsolved = True\n\n\tif not solved:\n\t\tfor key in n_num.keys():\n\t\t\tif n_num[key] >= 3:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\tsolved = True\n\n\t\tind_pairs = []\n\t\tif not solved:\n\t\t\tfor key in n_num.keys():\n\t\t\t\tif n_num[key] == 2:\n\t\t\t\t\tind_pairs.append(key)\n\n\t\t\tif len(ind_pairs) >= 2:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\tsolved = True\n\t\t\telif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\tsolved = True\n\t\t\telse:\n\n\t\t\t\tsum_targ = n*(n-1) \/\/ 2\n\n\t\t\t\tdif_sum = s - sum_targ\n\n\t\t\t\tif dif_sum % 2 == 0:\n\t\t\t\t\tprint(\"cslnb\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"sjfnb\")","output":"linear"},{"instruction":"def main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    c=dict(zip(a,range(n)))\n    a=c\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x \/ k) in a:\n            b[x] = b[int(x \/ k)]\n            count[b[int(x \/ k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y \/ 2)\n\n    print(n)\n\nmain()","output":"nlogn"},{"instruction":"n = int(input())\nar = [int(i) for i in input().split()]\n\nif n == 1:\n    print(1)\n    exit()\n\nif ar[1] > ar[0]:\n    li = [1]\nelif ar[1] < ar[0]:\n    li = [5]\nelse:\n    li = [3]\n\nc = 1\nwhile c != n:\n    j = 0\n\n    if ar[c] > ar[c - 1]:\n        while c != n and ar[c] > ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] + 1)\n            if li[-1] == 6:\n                print(-1)\n\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] + 1)\n        else:\n            li.append(5)\n\n    elif ar[c] < ar[c - 1]:\n        while c != n and ar[c] < ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] - 1)\n            if li[-1] == 0:\n                print(-1)\n\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] - 1)\n        else:\n            li.append(1)\n\n    else:\n        while c != n and ar[c] == ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j):\n            if li[-1] > 3:\n                li.append(li[-1] - 1)\n            else:\n                li.append(li[-1] + 1)\n        if c != n and ar[c] > ar[c - 1]:\n            if li[-2] == 1:\n                li[-1] = 2\n            else:\n                li[-1] = 1\n        elif c != n and ar[c] < ar[c - 1]:\n            if li[-2] == 5:\n                li[-1] = 4\n            else:\n                li[-1] = 5\n\nif max(li) > 5 or min(li) < 1:\n    print(-1)\nelse:\n    print(*li)","output":"linear"},{"instruction":"import sys, math, queue, bisect\n\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef ok(x):\n    y = sum(map(int, list(str(x))))\n    return x-y >= s\n\nn, s = map(int, input().split())\nl, h = 0, n\na = n\nwhile l <= h:\n    m = (l+h)>>1\n    if ok(m):\n        a = m-1\n        h = m-1\n    else:\n        l = m+1\nprint(n-a)","output":"logn"},{"instruction":"n = int(input())\nx, y = map(int, input().split())\nwhite = max(x - 1, y - 1)\nblack = max(n - x, n - y)\nprint(\"White\" if white <= black else \"Black\")","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])","output":"np"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\nans = [0] * m\np = []\nfor i in range(n + m):\n    if t[i] == 1:\n        p.append(i)\nans[0] = p[0]\nfor i in range(m):\n    if i == m - 1:\n        ans[i] += n + m - p[i] - 1\n    else:\n        for j in range(p[i] + 1, p[i + 1]):\n            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:\n                ans[i] += 1\n            else:\n                ans[i + 1] += 1\nprint(' '.join(map(str, ans)))","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\nfrom collections import defaultdict as df\n\nimport random\n\ninfinite = float('inf')\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=RI()\n    s=input()\n\n    mini=n\n\n    test=\"RGB\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"GBR\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"BRG\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    print(mini)","output":"quadratic"},{"instruction":"def parse(line):\n\ti = 0\n\twhile line[i].isalpha():\n\t\ti += 1\n\ti1 = i\n\twhile i < len(line) and line[i].isdigit():\n\t\ti += 1\n\treturn line[:i1], int(line[i1:i]), line[i:]\n\nfor _ in range(int(input())):\n\ta1, n1, rest = parse(input())\n\tif rest:\n\t\t_, n2, _ = parse(rest)\n\t\ta2 = ''\n\t\twhile n2:\n\t\t\tr = (n2 - 1) % 26\n\t\t\ta2 = chr(r + ord('A')) + a2\n\t\t\tn2 = (n2 - r - 1) \/\/ 26\n\t\tprint(a2 + str(n1))\n\telse:\n\t\tn2 = 0\n\t\tfor c in a1:\n\t\t\tn2 = 26 * n2 + (ord(c) - ord('A') + 1)\n\t\tprint(f'R{n1}C{n2}')","output":"linear"},{"instruction":"n, m = map(int, input().split())\ndaf1 = list(map(int, input().split()))\ndaf2 = dict()\n\nfor i in range(n):\n    daf2[i+1] = 0\n\nfor i in daf1:\n    if i in daf2.keys():\n        daf2[i] += 1\n\nprint(min(daf2.values()))","output":"quadratic"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\nfrom math import ceil\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\nn, k = map(int, stdin.readline().split())\n\nred = 2 * n\n\ngreen = 5 * n\n\nblue = 8 * n\n\nneed = int(ceil(red \/ k)) + int(ceil(green \/ k)) + int(ceil(blue \/ k))\n\nwrite(need)","output":"constant"},{"instruction":"n=int(input())\ns=input()\n\nh=s.count('H')\ns=s+s\nprint(min(s[i:i+h].count('T') for i in range(n)))\n","output":"linear"},{"instruction":"import math\nimport sys\nfrom collections import deque,defaultdict\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n\/\/m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii\/\/=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii\/\/=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)","output":"quadratic"},{"instruction":"n=int(input())\n\nax, ay = map(int,input().split())\nbx, by = map(int,input().split())\n\ncx, cy = map(int,input().split())\n\nif ((bx<ax and cx<ax) or (bx>ax and cx>ax)) and ((by<ay and cy<ay) or (by>ay and cy>ay)):\n\tprint('YES')\n\nelse:\n\tprint('NO')","output":"constant"},{"instruction":"n,m = input().split()\nn=int(n)\nm=int(m)\n\nsongs=list()\n\nfor i in range(n):\n    songs.append([int(c) for c in input().split()])\n\ndef sumList(lista,inx):\n    sum=0\n    for i in range(len(lista)):\n        sum+=lista[i][inx]\n    return sum\n\nsongs=sorted(songs,key=lambda x: x[1]-x[0])\n\nsuma = sumList(songs,0)\n\nfor i in range(n):\n    if(suma<=m):\n        print(i)\n        exit()\n    suma-= songs[i][0]-songs[i][1]\n\nif(suma<=m):\n    print(n)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"n, k = list( map( int, input().split()))\np = list( map( int, input().split()))\nc = list( map( int, input().split()))\n\nm = {}\nfor i in range( n ):\n    if p[ i ] not in m:\n        m[ p[ i ] ] = list()\n    m[ p[ i ] ].append( c[ i ] )\n\na = {}\nt = []\nfor key, val in sorted( m.items() ):\n    a[ key ] = sum( t )\n    t += val\n    t.sort()\n    t = t[ max( 0, len( t ) - k ) : len( t ) ]\n\nprint( \" \".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))","output":"nlogn"},{"instruction":"f = [0 for _ in range(40)]\n\nfor i in range(1, 32):\n    f[i] = 1 + 4 * f[i - 1]\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n >= 32:\n        print(\"YES %d\" % (n - 1))\n        continue\n\n    if f[n] < k:\n        print(\"NO\")\n        continue\n\n    k -= 1\n    extra = 1\n    way = 3\n    size = n - 1\n    done = False\n    total = f[size]\n    ans = True\n    while k > total and size > 0:\n        if k < way:\n            ans = False\n            break\n        k -= way\n        size -= 1\n        extra = way * 2 - 1\n        way = way * 2 + 1\n        total += extra * f[size]\n\n    if ans:\n        print(\"YES %d\" % size)\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)","output":"constant"},{"instruction":"dict={\"Power\":\"purple\",\n      \"Time\":\"green\",\n      \"Space\":\"blue\",\n      \"Soul\":\"orange\",\n      \"Reality\":\"red\",\n      \"Mind\":\"yellow\"}\ndict1={}\nn=(int(input()))\nwhile n:\n    str=input()\n    if str==\"purple\":\n        dict1[\"Power\"]=str\n    elif str==\"green\":\n        dict1[\"Time\"]=str\n    elif str==\"blue\":\n        dict1[\"Space\"]=str\n    elif str==\"orange\":\n        dict1[\"Soul\"]=str\n    elif str==\"red\":\n        dict1[\"Reality\"]=str\n    elif str==\"yellow\":\n        dict1[\"Mind\"]=str\n    n-=1\n\nval=list(dict.keys())\nval_list=list(dict1.keys())\nl=[key for key in val if key not in val_list]\nprint(len(l))\nfor i in range(len(l)):\n    print(l[i])","output":"constant"},{"instruction":"string = input()\nsize = len(string)\n\nans_got = 0\nfor s in range(1,size)[::-1]:\n    dic = {}\n    for i in range(0,size-s+1):\n        if(string[i:i+s] in dic):\n            print(s)\n            ans_got = 1\n            break\n        else:\n            dic[string[i:i+s]] = 1\n    if(ans_got == 1):\n        break\nif(ans_got == 0):\n    print(0)","output":"cubic"},{"instruction":"from sys import stdin, stdout\nfrom collections import defaultdict\nimport sys\ninput = stdin.readline\ndef gen(temp,i):\n    global s,k,outs\n    if i==k:\n        j=''\n        for o in range(k):\n            if temp[o]==1:\n                j+=s[o]\n            else:\n                j+='_'\n        outs.add(j)\n        return\n    temp[i]=1\n    gen(temp,i+1)\n    temp[i]=-1\n    gen(temp,i+1)\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def isCyclicUtil(self, v, visited, recStack):\n        visited[v] = True\n        recStack[v] = True\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.isCyclicUtil(neighbour, visited, recStack) == True:\n                    return True\n            elif recStack[neighbour] == True:\n                return True\n        recStack[v] = False\n        return False\n\n    def isCyclic(self):\n        visited = [False] * self.V\n        recStack = [False] * self.V\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.isCyclicUtil(node, visited, recStack) == True:\n                    return True\n        return False\n    def topologicalSortUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        stack.append(v)\n\n    def topologicalSort(self):\n        visited = [False] * self.V\n        stack = []\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        stack=stack[::-1]\n        print(\"yes\")\n        for i in stack:\n            stdout.write(str(i+1)+\" \")\n\nn,m,k=map(int,input().split())\npatterns={}\nall=[]\nfor i in range(n):\n    s=input()[:-1]\n    patterns[s]=i\n    all.append(s)\nstrs=[]\ndg=Graph(n)\nfor i in range(m):\n    s,mt=input().split()\n    mt=int(mt)-1\n    outs=set()\n    temp=[0 for o in range(k)]\n    gen(temp,0)\n    if all[mt] not in outs:\n        print(\"no\")\n        sys.exit()\n    for i in outs:\n        if i!=all[mt] and i in patterns:\n            dg.addEdge(mt,patterns[i])\nif dg.isCyclic():\n    print(\"no\")\nelse:\n    dg.topologicalSort()","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\ndef main():\n    l, r = map(int, input().split())\n    for i in range(62, -1, -1):\n        if ((1 << i) & l) ^ ((1 << i) & r):\n            print((1 << (i+1)) - 1)\n            break\n    else:\n        print(0)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"import sys\nn,m,k = map(int,input().split())\n\nif k%2:\n    ans = [[-1]*m for _ in range(n)]\n    for row in ans:\n        print(*row)\n    exit()\nA = []\nB = []\ninf = float('inf')\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nfor _ in range(n-1):\n    B.append(list(map(int,input().split())))\n\ndp = [[inf]*m for _ in range(n)]\nans = [[None]*m for _ in range(n)]\n\nfor l in range(k\/\/2+1):\n    new_dp = [[inf]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if l == 0:\n                new_dp[i][j] = 0\n                continue\n\n            up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf\n            right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf\n            left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf\n            down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf\n\n            new_dp[i][j] = min(up,right,left,down)\n            if l == k\/\/2:\n                ans[i][j] = new_dp[i][j]\n    dp = new_dp\nfor row in ans:\n    print(*row)","output":"cubic"},{"instruction":"from math import log\nfrom collections import deque\nn,k=map(int,input().split())\ns=list(map(int,input().split()))\nans=0\ns.sort()\ns1=deque(s)\nfor j in range(11):\n    d=dict()\n    z=10**j\n    for i in s:\n        y=i*z\n        u=y%k\n        if u in d:\n            d[u]+=1\n        else:\n            d.update({u:1})\n    aux=0\n    for i in s1:\n        y=i\n        lg=int(log(i,10))+1\n        lg=10**lg\n        if lg==z:\n            aux1=(y*z)%k\n            aux2=y%k\n            d[aux1]-=1\n            x=(k-aux2)\n            if aux2==0:\n                x=0\n            if x in d:\n                ans+=d[x]\n            d[aux1]+=1\n            aux+=1\n        else:\n            break\n    for i in range(aux):\n        s1.popleft()\nprint(ans)","output":"nlogn"},{"instruction":"grid = list(map(int,input().split()))\nmax_res = 0\nfor i in range(14):\n    g_c = grid.copy()\n    Amount = g_c[i]\/\/14\n    Amount_r = g_c[i]%14\n    if(Amount > 0):\n        for j in range(14):\n            if i != (i+j+1)%14:\n                g_c[(i+j+1)%14]+=Amount\n                g_c[i]-=Amount\n    if Amount_r > 0:\n        for j in range(14):\n            if Amount_r > 0:\n                if i != (i+j+1)%14:\n                    g_c[(i+j+1)%14]+=1\n                    Amount_r-=1\n                    g_c[i]-=1\n            else:\n                break\n\n    res = 0\n    for i in range(14):\n        if g_c[i] % 2 ==0:\n            res+=g_c[i]\n\n    max_res = max(max_res,res)\n\nprint(max_res)","output":"constant"},{"instruction":"N, K = map(int, input().split())\n\ndef in_bounds(k):\n    return N <= K*(K+1)\/\/2 - (K-k)*(K-k+1)\/\/2 - k + 1\n\nl = 0\nr = K\nwhile l <= r:\n    c = (l + r) \/\/ 2\n    if in_bounds(c):\n        r = c - 1\n    else:\n        l = c + 1\nif in_bounds(K):\n    print(l)\nelse:\n    print(-1)","output":"logn"},{"instruction":"def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n, m = read_int_array()\n    bmin = read_int_array()\n    gmax = read_int_array()\n\n    bmin.sort()\n    gmax.sort()\n\n    max_boy = bmin[-1]\n    min_girl = gmax[0]\n    if max_boy > min_girl:\n        write(-1)\n    elif max_boy == min_girl:\n        bmin.pop()\n        out = sum(gmax) + sum(x * m for x in bmin)\n        write(out)\n    else:\n        bmin.pop()\n        out = sum(gmax) - min_girl + max_boy\n        out += min_girl + bmin[-1] * (m-1)\n        bmin.pop()\n        out += sum(x * m for x in bmin)\n        write(out)\n\nmain()","output":"nlogn"},{"instruction":"import math\n\nN,r=map(int,input().split())\n\nprint(r*math.sin(math.pi\/N)\/(1-math.sin(math.pi\/N)))","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m,k=map(int,input().split())\n    if (k%2==0):\n        DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k\/\/2)]\n        A=[]\n        B=[]\n        for i in range(n):\n            L=list(map(int,input().split()))\n            A.append(L)\n            for j in range(m-1):\n                DP[0][i][j]=min(DP[0][i][j],L[j])\n                DP[0][i][j+1]=min(L[j],DP[0][i][j+1])\n\n        for i in range(n-1):\n            L=list(map(int,input().split()))\n            B.append(L)\n            for j in range(m):\n                DP[0][i][j]=min(DP[0][i][j],L[j])\n                DP[0][i+1][j]=min(DP[0][i+1][j],L[j])\n\n        for k1 in range(1,k\/\/2):\n            for i in range(n):\n                for j in range(m):\n                    if (i>0):\n                        DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j])\n                    if (j>0):\n                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1])\n                    if (i<(n-1)):\n                        DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j])\n                    if (j<(m-1)):\n                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1])\n\n        for val in DP[(k\/\/2)-1]:\n            ans=[i*2 for i in val]\n            print(*ans)\n\n    else:\n        for i in range(n):\n            L=list(map(int,input().split()))\n\n        for i in range(n-1):\n            L=list(map(int,input().split()))\n\n        for i in range(n):\n            ans=[-1]*m\n            print(*ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n, k = map(int, input().split())\nprint((n*2)\/\/k + bool((n*2)%k) + (n*5)\/\/k + bool((n*5)%k) + (n*8)\/\/k + bool((n*8)%k))","output":"constant"},{"instruction":"n = int(input())\nai = list(map(int,input().split()))\nbi = list(map(int,input().split()))\nai2 = [0] * (n+1)\nn2 = 0\nfor i in range(n):\n    num = 0\n    if ai2[bi[i]] != 1:\n        for j in range(n2,n):\n            ai2[ai[j]] = 1\n            if ai[j] == bi[i]:\n                num = j + 1 - n2\n                n2 = j + 1\n                break\n    print(num,end=\" \")","output":"linear"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) \/\/ 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n\n        pivot = l\n        l, r = 0, len(nums) - 1\n\n        if target >= nums[pivot] and target <= nums[r]:\n            l = pivot\n        else:\n            r = pivot - 1\n\n        while l <= r:\n            m = (l + r) \/\/ 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n\n        return -1","output":"logn"},{"instruction":"import math\nxy = list(map(int,input().split()))\nx = [[xy[0],xy[2],xy[4]],[xy[1],xy[3],xy[5]]]\naa = 0\nmax_ll = 0\nfor i in range(3):\n    aa += x[0][i]*x[1][i]\n    max_ll = max(max_ll,x[0][i],x[1][i])\n\nbb = math.sqrt(aa)\n\nif bb*bb!=aa or max_ll!=bb:\n    print(-1)\nelse:\n    bb = int(bb)\n    mt = [['']*bb for _ in range(bb)]\n    max_l = 0\n    chars = ['A','B','C']\n    x = [[xy[0],xy[1]],[xy[2],xy[3]],[xy[4],xy[5]]]\n    max_lp = -1\n    max_li = -1\n    ii=0\n    oh = []\n    for i in x:\n        if max(i)>=max_l:\n            max_l = max(i)\n            max_lp = sum(i)-max(i)\n            max_li = ii\n\n        ii+=1\n\n    max_ls = []\n    ii=0\n    for i in x:\n        if max(i)==max_l:\n            max_ls.append(i+[ii])\n        else:\n            oh+=[ii]\n        ii+=1\n    if len(max_ls)==3:\n\n        for i in range(max_l):\n            for j in range(max_l):\n                if i<(max_ls[0][0]+max_ls[0][1]-max_l):\n                    mt[i][j] = chars[max_ls[0][2]]\n                elif i<(max_ls[0][0]+max_ls[0][1]-max_l + max_ls[1][0]+max_ls[1][1]-max_l):\n                    mt[i][j] = chars[max_ls[1][2]]\n                else:\n                    mt[i][j] = chars[max_ls[2][2]]\n    else:\n\n        for i in range(max_lp):\n            for j in range(max_l):\n                mt[i][j] = chars[max_li]\n\n        bb = max_l-max_lp\n        for i in range(max_lp,max_l):\n            for j in range(max_l):\n                if j<(sum(x[oh[0]])-bb):\n                    mt[i][j] = chars[oh[0]]\n                else:\n                    mt[i][j] = chars[oh[1]]\n\n    print(max_l)\n    for j in mt:\n        print(''.join(j))","output":"np"},{"instruction":"n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nmab = max(b)\nmig = min(g)\nif mab > mig:\n    print(-1)\n    exit()\n\nb = sorted(b, reverse=True)\ng = sorted(g)\nnum = 0\nj = 0\nfor i in range(n):\n    k = 0\n    l = 1\n    while j < m and k < m - l and b[i] <= g[j]:\n        if b[i] == g[j]:\n            l = 0\n        num += g[j]\n        j += 1\n        k += 1\n    num += b[i] * (m - k)\n\nprint(num)","output":"nlogn"},{"instruction":"n,pos,l,r=map(int,input().split())\nif l==1 and r==n:\n    print(0)\nelif l==1:\n    print(abs(pos-r)+1)\nelif r==n:\n    print(abs(pos-l)+1)\nelse:\n    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)","output":"constant"},{"instruction":"n,k = map(int,input().split())\ns = input()\na = (n-k)\/\/2\ns1 = s.replace('(','',a)\ns2 = s1.replace(')','',a)\nprint(s2)","output":"linear"},{"instruction":"from sys import stdin,stdout\nfrom collections import Counter\ndef ai(): return list(map(int, stdin.readline().split()))\ndef ei(): return map(int, stdin.readline().split())\ndef ip(): return  int(stdin.readline().strip())\ndef op(ans): return stdout.write(str(ans) + '\\n')\n\nn = ip()\ns = input()\nt = input()\nvalue = {}\nli = []\nres1 = 0\nres2 =res3 = -1\nfor i in range(n):\n\tif s[i] != t[i]:\n\t\tvalue[t[i]] = i\n\t\tres1 += 1\n\t\tli.append(i)\np = sq = False\nfor i in li:\n\tif s[i] in value:\n\t\tp = True\n\t\tres2 = i+1\n\t\tf = value[s[i]]\n\t\tres3 = f+1\n\t\tif s[f] == t[i]:\n\t\t\tsq = True\n\t\t\tbreak\nprint(res1-(2 if sq else 1 if p else 0))\nprint(res2,res3)","output":"linear"},{"instruction":"def problem(s, p):\n    n = len(s)\n    F = [[n] * 26 for _ in range(n + 2)]\n    for i in range(n - 1, -1, -1):\n        F[i][:] = F[i + 1]\n        F[i][ord(s[i]) - 97] = i\n\n    def interleaving(l, r):\n        dp = [-1] + [n] * len(r)\n\n        for j in range(1, len(r) + 1):\n            dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]\n\n        for i in range(1, len(l) + 1):\n            dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97]\n\n            for j in range(1, len(r) + 1):\n                a = F[dp[j] + 1][ord(l[i - 1]) - 97]\n                b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]\n                dp[j] = min(a, b)\n\n        return dp[-1] < n\n\n    for i in range(len(p)):\n        if interleaving(p[:i], p[i:]):\n            return 'YES'\n    return 'NO'\n\nfor _ in range(int(input())):\n    print(problem(input(), input()))","output":"cubic"},{"instruction":"import os\nfrom io import BytesIO, IOBase\nimport sys\nfrom collections import defaultdict, deque, Counter\nfrom math import sqrt, pi, ceil, log, inf, gcd, floor\nfrom itertools import combinations, permutations\nfrom bisect import *\nfrom fractions import Fraction\nfrom heapq import *\nfrom random import randint\n\ndef main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    ans=0\n    for i in range(0,2*n,2):\n        if a[i]!=a[i+1]:\n            for j in range(i+1,2*n):\n                if a[j]==a[i]:\n                    for k in range(j,i+1,-1):\n                        a[k],a[k-1]=a[k-1],a[k]\n                        ans+=1\n                    break\n    print(ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"quadratic"},{"instruction":"n, m=[int(k) for k in input().split()]\nres=[]\nfor j in range(n\/\/2):\n    for k in range(m):\n        res.append(str(j+1)+\" \"+str(k+1))\n        res.append(str(n-j)+\" \"+str(m-k))\nif n%2:\n    for j in range(m\/\/2):\n        res.append(f\"{n\/\/2+1} {j+1}\")\n        res.append(f\"{n\/\/2+1} {m-j}\")\n    if m%2:\n        res.append(f\"{n\/\/2+1} {m\/\/2+1}\")\nprint(\"\\n\".join(res))","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter,defaultdict\nfrom heapq import heappush, heappop\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\n\ndef main():\n    def fn(s, e, qs, qe):\n        if qs <= s <= e <= qe: return True\n        return False\n\n    for _ in range(1):\n        n = nmbr()\n        ans = [-1, -1]\n        a = [lst() for i in range(n)]\n        a = [[a[i][0], a[i][1], i] for i in range(n)]\n        a.sort(key=lambda x: (x[0], x[1]))\n        for i in range(n - 1):\n            if fn(a[i][0], a[i][1], a[i + 1][0], a[i + 1][1]):\n                ans = [a[i][2] + 1, a[i + 1][2] + 1]\n                break\n            elif fn(a[i + 1][0], a[i + 1][1], a[i][0], a[i][1]):\n                ans = [a[i + 1][2] + 1, a[i][2] + 1]\n                break\n        print(*ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    for t in range(1):main()","output":"nlogn"},{"instruction":"import math\n\nl, r = (map(int, input().split()))\na = l\nif a % 2:\n    a += 1\n\nif a + 2 > r:\n    print(-1)\nelse:\n    print(a, a + 1, a + 2)","output":"constant"},{"instruction":"import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n\nmod=10**9+7\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\nans=0\ndef hnbhai(t):\n    n=sb()\n    p=[]\n    for i in range(n):\n        p.append(sflo())\n\n    dp=[0]*(1<<n)\n    dp[1]=1\n    for i in range(2,1<<n):\n        for j in range(1,n):\n            for k in range(0,j):\n                if (i>>j)&1 and (i>>k)&1:\n                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])\n\n    print(dp[-1])\nfor _ in range(1):\n    hnbhai(_+1)","output":"np"},{"instruction":"n, k=[int(v) for v in input().split()]\nif n==1:\n    print(0)\nelif n-1>(1+k-1)*(k-1)\/\/2:\n    print(-1)\nelse:\n    n-=1\n    k-=1\n    l, r=0, k+1\n    while r-l>1:\n        m=(l+r)\/\/2\n        if (m+k)*(k-m+1)\/\/2>=n:\n            l=m\n        else:\n            r=m\n    print(k-l+1)","output":"logn"},{"instruction":"def ballbuster5000(arr, rj):\n    for i in arr:\n        rj += i\n    gg = 0\n    i = 0\n    while gg <= rj:\n        gg += arr[i]\n        rj -= arr[i]\n        i -= -1\n    return i\n\nn = int(input())\nx = list(map(int, input().strip().split()))\nx.sort(reverse=True)\nprint(ballbuster5000(x, 0))","output":"nlogn"},{"instruction":"n,m=list(map(int,input().split()))\nfor i in range(1,n+1):\n    j=i*(i+1)\/\/2\n\n    if j>=m:\n        if j==m and i==n:\n            print(0)\n            break\n        else:\n            t=n-i\n            if j-t==m:\n                print(t)\n                break\n            elif j-t<m:\n\n                continue","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor testcases in range(t):\n    n,m=map(int,input().split())\n    A=[list(map(int,input().split())) for i in range(n)]\n\n    B=[]\n    for j in range(m):\n        B.append([A[i][j] for i in range(n)])\n\n    B.sort(key=lambda x:max(x),reverse=True)\n\n    B=B[:n]\n\n    LEN=len(B)\n\n    if LEN==1:\n        print(sum(B[0]))\n\n    elif LEN==2:\n        ANS=0\n        for i in range(n):\n            A=0\n            for k in range(n):\n                A+=max(B[0][k],B[1][(i+k)%n])\n\n            ANS=max(ANS,A)\n\n        print(ANS)\n\n    elif LEN==3:\n\n        ANS=0\n        for i in range(n):\n            for j in range(n):\n\n                A=0\n                for k in range(n):\n                    A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n])\n\n                ANS=max(ANS,A)\n\n        print(ANS)\n\n    elif LEN==4:\n\n        ANS=0\n        for i in range(n):\n            for j in range(n):\n                for l in range(n):\n\n                    A=0\n                    for k in range(n):\n                        A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n])\n\n                    ANS=max(ANS,A)\n\n        print(ANS)","output":"np"},{"instruction":"MOD = 998244353\n\ndef pop_count(x) :\n    ans = 0\n    while (x > 0) :\n        ans = ans + x % 2\n        x = x \/\/ 2\n    return ans\n\ndef check(x, k) :\n    mask = 0\n    nx = int(x)\n    while (nx > 0) :\n        mask = mask | (1 << (nx % 10))\n        nx = nx \/\/ 10\n    if (pop_count(mask) <= k) :\n        return x\n    return 0\n\npop = []\np10 = []\nf = [[0 for j in range(1 << 10)] for i in range(20)]\nw = [[0 for j in range(1 << 10)] for i in range(20)]\ndef prepare() :\n    p10.append(1)\n    for i in range(20) :\n        p10.append(p10[i] * 10 % MOD)\n    for i in range(1 << 10) :\n        pop.append(pop_count(i))\n    w[0][0] = 1\n    for i in range(1, 20) :\n        for j in range(1 << 10) :\n            for use in range(10) :\n                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD\n                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD\n\ndef solve(x, k) :\n    sx = [int(d) for d in str(x)]\n    n = len(sx)\n    ans = 0\n    for i in range(1, n) :\n        for use in range(1, 10) :\n            for mask in range(1 << 10) :\n                if (pop[(1 << use) | mask] <= k) :\n                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD\n    cmask = 0\n    csum = 0\n    for i in range(n) :\n        cdig = sx[i]\n        for use in range(cdig) :\n            if (i == 0 and use == 0) :\n                continue\n            nmask = cmask | (1 << use)\n            for mask in range(1 << 10) :\n                if (pop[nmask | mask] <= k) :\n                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD\n        cmask |= 1 << cdig\n        csum = (10 * csum + cdig) % MOD\n    return ans\n\nprepare()\nl, r, k = map(int, input().split())\nans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD\nprint(ans)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom math import ceil, floor, factorial;\n\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp\n\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a, a)\n\ndef nCr(n, k):\n    if(k > n - k):\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i)\n        res = res \/ (i + 1)\n    return int(res)\n\ndef upper_bound(a, x, lo=0):\n    hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)\/\/2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\n\ndef primefs(n):\n\n    primes = {}\n    while(n%2 == 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n\/\/2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n\/\/i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n\n    return primes\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b\n\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n\n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\nMAXN = int(1e6 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n\ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x\/\/spf[x]\n    return ret\n\ndef int_array():\n    return list(map(int, input().strip().split()))\n\ndef str_array():\n    return input().strip().split();\n\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n\nn, l, r, x = int_array(); a = sorted(int_array());\nans = 0;\nfor mask in range( 1 << n):\n    mx = NINF; mn = INF; sub = 0;\n    for i in range(n):\n        if (1 << i) & mask:\n            sub += a[i];\n            mx = max(mx, a[i]);\n            mn = min(mn, a[i]);\n    if sub >= l and sub <= r:\n        if mx - mn >= x:\n            ans += 1;\nprint(ans);","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\ndef ctd(chr): return ord(chr)-ord(\"a\")\nmod = 998244353\nINF = float('inf')\n\nfrom math import gcd\n\ndef main():\n    n = N()\n    larr = RLL()\n    carr = RLL()\n\n    dic = {}\n    dic[0] = 0\n\n    for i in range(n):\n        l, c = larr[i], carr[i]\n        ndic = dic.copy()\n        for j in dic:\n            now = gcd(j, l)\n            if now not in ndic:\n                ndic[now] = c+dic[j]\n            else:\n                ndic[now] = min(ndic[now], dic[j]+c)\n        dic = ndic\n\n    print(dic.get(1, -1))\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"from collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef main():\n\n    T = int(nextline())\n    for testCase in range(1, T + 1):\n        n, m, k = ints()\n        min_k = max(n, m)\n        if min_k > k:\n            print(-1)\n            continue\n        if (n - m) % 2 == 0:\n            if k % 2 == n % 2:\n                print(k)\n                continue\n            print(k - 2)\n            continue\n        print(k - 1)\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"t = int(input())\nfor i in range(t):\n    n = int(input())\n    ai = list(map(int,input().split()))\n    ai.sort()\n    print(min(n-2,ai[-2]-1))","output":"nlogn"},{"instruction":"d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)","output":"constant"},{"instruction":"import sys\nfrom collections import deque\nimport heapq\ninput = sys.stdin.readline\n\nN=int(input())\nEDGE=[list(map(int,input().split())) for i in range(N-1)]\n\nEDGELIST=[[] for i in range(N+1)]\n\nfor i,j in EDGE:\n    EDGELIST[i].append(j)\n    EDGELIST[j].append(i)\n\nREDG=[None for i in range(N+1)]\nQUE=deque([1])\ncheck=[0]*(N+1)\nDEPTH=[None]*(N+1)\ni=0\nwhile QUE:\n    NQUE=deque()\n    i+=1\n\n    while QUE:\n        x=QUE.pop()\n        DEPTH[x]=i\n        check[x]=1\n        for to in EDGELIST[x]:\n            if check[to]==1:\n                continue\n            else:\n\n                REDG[to]=x\n                NQUE.append(to)\n    QUE=NQUE\n\ncheck=[0]*(N+1)\ncheck[1]=1\n\nLEAF=[]\nfor i in range(2,N+1):\n    if len(EDGELIST[i])==1:\n        LEAF.append((-DEPTH[i],i))\n\nQUE=LEAF\nheapq.heapify(QUE)\nANS=0\n\nwhile QUE:\n    dep,x=heapq.heappop(QUE)\n    if check[x]!=0 or dep>=-3:\n        continue\n\n    if check[REDG[x]]==2:\n        continue\n\n    if check[x]==0:\n        check[x]=1\n    if check[REDG[REDG[x]]]==0:\n        check[REDG[REDG[x]]]=1\n    check[REDG[x]]=2\n    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))\n    ANS+=1\n\nprint(ANS)","output":"linear"},{"instruction":"n=int(input())+1\nif n<2:\n    print(0)\nelif n%2==0:\n    print(n\/\/2)\nelse:\n    print(n)","output":"constant"},{"instruction":"import os\nimport sys\n\ndef log(*args, **kwargs):\n    if os.environ.get('CODEFR'):\n        print(*args, **kwargs)\n\nn, k = tuple(map(int, input().split()))\n\ns = '0'*((n-k)\/\/2) + '1'\n\nfor i in range(n):\n    print(s[i % len(s)], end='')\nprint()","output":"linear"},{"instruction":"def i_ints():\n    return list(map(int, input().split()))\n\nn, a, b = i_ints()\ndef calc():\n    if min(a, b) != 1:\n        print(\"NO\")\n        return\n    if a == b == 1 and n in (2, 3):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    ONE, ZERO = \"10\" if a > 1 else \"01\"\n\n    edges = n - max(a, b)\n    line = \"0\" + (ZERO, ONE)[edges>0]*(n>1) + ZERO * (n-2)\n    print(line)\n\n    for y in range(1, n):\n        line = ZERO * (y-1) + (ZERO, ONE)[y<=edges] + \"0\"\n        if y < n-1:\n            line += (ZERO, ONE)[y < edges] + ZERO * (n-y-2)\n        print(line)\n\ncalc()","output":"quadratic"},{"instruction":"import sys\nfrom math import floor, ceil\n\nr = lambda: sys.stdin.readline().strip()\n\na = [[0] * 2 for i in range(3)]\n\ndef abs(x):\n    if x < 0:\n        x = -x\n    return x\n\ndef calcLen(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2) + 1\n\ndef main():\n    a[0][0], a[0][1] = map(int, r().split())\n    a[1][0], a[1][1] = map(int, r().split())\n    a[2][0], a[2][1] = map(int, r().split())\n    xMax = max(a[0][0], a[1][0], a[2][0])\n    xMin = min(a[0][0], a[1][0], a[2][0])\n    yMax = max(a[0][1], a[1][1], a[2][1])\n    yMin = min(a[0][1], a[1][1], a[2][1])\n\n    pathLen = xMax - xMin + yMax - yMin + 1\n    for i in range(3):\n        for j in range(3):\n            px = a[i][0]\n            py = a[j][1]\n            sum = 0\n            for k in range(3):\n                sum += (calcLen(a[k][0], a[k][1], px, py))\n            sum -= 2\n            if sum == pathLen:\n                break\n        if sum == pathLen:\n            break\n    sq = [[0]*(yMax+1) for i in range(xMax+1)]\n    for i in range(3):\n        if px == a[i][0]:\n            c = -1\n            if py > a[i][1]:\n                c = 1\n            for j in range(a[i][1], py, c):\n                sq[px][j]=1\n        elif py== a[i][1]:\n            c = -1\n            if px > a[i][0]:\n                c= 1\n            for j in range(a[i][0], px, c):\n                sq[j][py] = 1\n        else:\n            c = -1\n            if py > a[i][1]:\n                c = 1\n            for j in range(a[i][1], py + c, c):\n                sq[a[i][0]][j] = 1\n\n            c = -1\n            if px > a[i][0]:\n                c= 1\n            for j in range(a[i][0], px, c):\n                sq[j][py] = 1\n    sq[px][py] = 1\n    ans = []\n    for i in range(xMax + 1):\n        for j in range(yMax + 1):\n            if sq[i][j] == 1:\n                ans.append((i, j))\n    print(len(ans))\n    for i in ans:\n        print(i[0], i[1])\n\nmain()","output":"constant"},{"instruction":"import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\nT = int(input())\n\ndef interact(rect1, rect2):\n    x1, y1, x2, y2 = rect1\n    x3, y3, x4, y4 = rect2\n\n    ans = (-1, -1, -1, -1)\n    if x2 < x3 or x4 < x1:\n        return 0, ans\n    if y2 < y3 or y4 < y1:\n        return 0, ans\n\n    ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))\n\n    return area(ans), ans\n\ndef area(rect):\n    return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n\ndef winrect(rect):\n    a = area(rect)\n    if a % 2 == 0:\n        return a \/\/ 2\n\n    x1, y1, x2, y2 = rect\n    e1, e2 = x1 % 2 == 0, y1 % 2 == 0\n    ow = (e1 and e2) or (not e1 and not e2)\n    return a \/\/ 2 + 1 if ow else a \/\/ 2\n\nans = []\nfor ti in range(T):\n    N, M = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n\n    w = winrect((1, 1, N, M))\n    a, b = (x1, y1, x2, y2), (x3, y3, x4, y4)\n    s, c = interact(a, b)\n    if s == 0:\n        w -= winrect(a) + winrect(b)\n        w += area(a)\n    elif s == area(a):\n        w -= winrect(b)\n    elif s == area(b):\n        w -= winrect(b)\n        w += area(a) - area(b) - (winrect(a) - winrect(b))\n    else:\n        w += area(a) - winrect(a)\n        w -= winrect(b)\n        w -= area(c) - winrect(c)\n\n    ans.append((w, N*M-w))\n\nprint('\\n'.join(['{} {}'.format(a, b) for a, b in ans]))","output":"constant"},{"instruction":"a = int(input())\nlister = input().split()\nlister = [int(i) for i in lister]\n\nans = dict()\n\ndef findans(n):\n\tif n in ans:\n\t\treturn ans[n]\n\tmod = n%lister[n]\n\tok = True\n\tif n + lister[n] >= a and n - lister[n] < 0:\n\t\tok = False\n\telse:\n\t\tfor i in range(mod, a, lister[n]):\n\t\t\tif i != n and lister[i] > lister[n]:\n\t\t\t\tok = ok and findans(i)\n\n\t\tok = not(ok)\n\n\tans[n] = ok\n\treturn ok\n\nfor i in range(len(lister)):\n\tfindans(i)\n\nlevel = []\nfor i in range(a):\n\tif ans[i] == True:\n\t\tlevel.append('A')\n\telse:\n\t\tlevel.append('B')\n\nprint(''.join(level))","output":"quadratic"},{"instruction":"import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nt = int(input())\nfrom collections import Counter\nfor _ in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    C = Counter(A)\n    B = []\n    for k, v in C.items():\n        if v >= 4:\n            B.append(k)\n            B.append(k)\n        elif v >= 2:\n            B.append(k)\n\n    B.sort()\n    l = len(B)\n    m = 10**18\n    ans = [-1, -1, -1, -1]\n    for i in range(l-1):\n        x, y = B[i], B[i+1]\n        temp = (4*(x+y)**2)\/(x*y)\n        if temp < m:\n            m = temp\n            ans = [x, x, y, y]\n    print(*ans)","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nif(k%2==0):\n    print(\"YES\")\n    print('.'*n)\n    print('.'+'\n    print('.'+'\n    print('.'*n)\nelse:\n    print(\"YES\")\n    print('.'*n)\n    if(k<=n-2):\n        print('.'*((n-k)\/\/2)+'\n        print('.'*n)\n    else:\n        print('.'+'\n        print('.'+'\n    print('.'*n)","output":"linear"},{"instruction":"n, v = [int(item) for item in input().split()]\n\nx = 0\nc = 0\nfor i in range(1, n):\n    if x < n - i:\n        c += i * min((n - i), v - x)\n        x += min((n - i), v - x)\n    x -= 1\n\nprint(c)","output":"linear"},{"instruction":"n, m = map(int,input().split())\nr=0\nc=0\nf= 1\nfor i in range(n):\n    s = input()\n    if  f and \"B\" in s:\n        f = 0\n        ci = s.index('B')\n        cc = s.count(\"B\")\n        r = i+1+cc\/\/2\n        c = ci+cc\/\/2+1\nprint(r,c)","output":"quadratic"},{"instruction":"import math\na = input()\nb = input()\nsa = a.count(\"+\")\nta = a.count(\"-\")\nsb = b.count(\"+\")\ntb = b.count(\"-\")\nx = b.count(\"?\")\ns=abs(sa-sb)\nt=abs(ta-tb)\nsu = math.factorial(s+t)\nre = math.factorial(s)\nsa = math.factorial(t)\nresult = su\/(re*sa)\n\nif s+t <= x:\n    print(float(result)\/float((2**x)))\nelse:\n    print(0)","output":"np"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nm,n=[int(ele) for ele in input().split()]\na=[]\nfor i in range(m):\n    a.append(list(map(int, input().split())))\n\nina,mo=0,10**9+1\npos1,pos2=0,0\nmask=(1<<n)-1\ndef check(tang):\n    key=set()\n    dic=dict()\n    for i in range(m):\n        temp=0\n        for j in range(n):\n            if a[i][j]>=tang:\n\n                temp+=(1<<j)\n\n        if temp in key:\n            continue\n        key.add(temp)\n        tempk=temp\n        while tempk>=0:\n            tempk &= temp\n            dic[tempk]=i\n            tempk-=1\n\n        tocheck = mask ^ temp\n\n        if tocheck in dic:\n            return dic[tocheck],i,True\n\n    return -1,-1,False\n\nwhile ina<mo-1:\n\n    tang=(ina+mo)\/\/2\n\n    temppos1,temppos2,status=check(tang)\n\n    if status:\n        pos1,pos2=temppos1,temppos2\n        ina=tang\n    else:\n        mo=tang\nprint(pos1+1,pos2+1)","output":"np"},{"instruction":"import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef output(*args):\n    sys.stdout.buffer.write(\n        ('\\n'.join(map(str, args)) + '\\n').encode('utf-8')\n    )\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = list(map(float, input().split()))\n    add = [[0] * n for _ in range(n + 1)]\n    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):\n        add[xi - 1][yi - 1] = float(ci)\n\n    minf = float('-inf')\n    dp = [[minf] * (2**n) for _ in range(n + 1)]\n    dp[n][0] = 0.0\n\n    for bitset in range(2**n):\n        if bin(bitset).count('1') >= m:\n            continue\n\n        for i in range(n + 1):\n            if dp[i][bitset] == minf:\n                continue\n            for j in range(n):\n                if (1 << j) & bitset:\n                    continue\n                dp[j][bitset | (1 << j)] = max(\n                    dp[j][bitset | (1 << j)],\n                    dp[i][bitset] + a[j] + add[i][j]\n                )\n\n    print(int(max(max(_dp) for _dp in dp) + 1e-7))\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef fun(a,b):\n    return (2*(a+b))**2\/(a*b)\n\nfor i in range (int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    b = []\n    i=0\n    while(i<n-1):\n        if i<n-1 and a[i]==a[i+1]:\n            b.append(a[i])\n            i+=2\n        else:\n            i+=1\n    m = 10**14\n    mi = -1\n    for i in range (len(b)-1):\n        curr = fun(b[i],b[i+1])\n        if curr<m:\n            m = curr\n            mi = i\n    print(b[mi],b[mi],b[mi+1],b[mi+1])","output":"nlogn"},{"instruction":"def solve(x,y,z):\n    global r,g,b,ans\n    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):\n        return 0\n    if memo[x][y][z] != -1:\n        return memo[x][y][z]\n    mx = 0\n    if x < r and y < g:\n        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))\n    if x < r and z < b:\n        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))\n    if y < g and z < b:\n        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))\n    ans = max(ans,mx)\n    memo[x][y][z] = mx\n    return mx\n\nr,g,b = map(int,input().split())\nra = sorted(list(map(int,input().split())),reverse = True)\nga = sorted(list(map(int,input().split())),reverse = True)\nba = sorted(list(map(int,input().split())),reverse = True)\n\nmemo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]\n\nans = 0\n\nsolve(0,0,0)\nprint(ans)","output":"cubic"},{"instruction":"from math import fabs\nn = int(input())\nnots = [int(s) for s in input().split()]\nmap = [0]\nampl = 0\npossible = True\nzer = False\nf_s = True\n\nfor i in range(len(nots) - 1):\n    if nots[i] == nots[i + 1]:\n        if ampl != 0:\n            map.append(ampl)\n            if ampl <= -5 or ampl >= 5: possible = False\n        map.append(0)\n        zer = True\n        ampl = 0\n    else:\n        if nots[i] < nots[i + 1]:\n            if ampl < 0 and f_s != True:\n                map.append(ampl)\n                if ampl == -5: possible = False\n                ampl = 1\n            else:\n                ampl += 1\n        else:\n            if ampl > 0 and f_s != True:\n                map.append(ampl)\n                if ampl == 5: possible = False\n                ampl = -1\n            else:\n                ampl += -1\n    f_s = False\nif ampl != 0:\n    map.append(ampl)\n    if ampl == -5 or ampl == 5: possible = False\nif len(nots) == 1:\n    map.append(0)\nmap.append(0)\n\nif possible == True:\n    if zer == True:\n        l = len(map)\n        for i in range(1, l - 1):\n            if map[i] == 0:\n                if map[i - 1] == 4: map[i] = -1\n                if map[i - 1] == -4: map[i] = 1\n                if map[i + 1] == 4: map[i] = -1\n                if map[i + 1] == -4: map[i] = 1\n\n        for i in range(1, l-1):\n            if map[i] == 0:\n                if map[i - 1] >= 0 and map[i + 1] >= 0: map[i] = -1\n                if map[i - 1] > 0 and map[i + 1] < 0: map[i] = 1\n                if map[i - 1] < 0 and map[i + 1] > 0: map[i] = -1\n                if map[i - 1] <= 0 and map[i + 1] <= 0: map[i] = 1\n\n        fin = []\n        ampl = map[1]\n        for i in range(1, l - 1):\n            if map[i] * map[i + 1] > 0:\n                ampl += map[i + 1]\n            if map[i] * map[i + 1] < 0:\n                fin.append(ampl)\n                if ampl >= 5 or ampl <= -5: possible = False\n                ampl = map[i + 1]\n        fin.append(ampl)\n\n        if possible == True:\n            fin[-1] = int(fabs( fin[-1] ) \/ fin[-1] * (fabs( fin[-1] ) + 1))\n            appl = []\n            for i in range( len(fin) ):\n                if fin[i] > 0:\n                    for j in range(1, fin[i] + 1):\n                        appl.append(j)\n                if fin[i] < 0:\n                    for j in range(5, 5 + fin[i], -1):\n                        appl.append(j)\n\n    else:\n        appl = []\n        try:\n            map[-2] = int(fabs(map[-2]) \/ map[-2] * (fabs(map[-2]) + 1))\n        except ZeroDivisionError:\n            appl = [1]\n        for i in range(len(map)):\n            if map[i] > 0:\n                for j in range(1, map[i] + 1):\n                    appl.append(j)\n            if map[i] < 0:\n                for j in range(5, 5 + map[i], -1):\n                    appl.append(j)\n\n    for finger in appl:\n        print(finger, end = ' ')\nif possible == False:\n    print(-1)","output":"quadratic"},{"instruction":"n = int(input())\np = list(map(int, input().split()))\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    gr[p[i] - 1].append(i + 1)\n\nq = [0]\nafter = []\ni = 0\ns = [0 for i in range(n)]\nused = set()\nused.add(0)\nwhile q:\n    cur = q.pop()\n    after.append(cur)\n    for el in gr[cur]:\n        if el not in used:\n            used.add(el)\n            q.append(el)\n            i += 1\n\nq = after\nfor j in range(i, -1, -1):\n    if len(gr[q[j]]) == 0:\n        s[q[j]] = 1\n    else:\n        ans = 0\n        for c in gr[q[j]]:\n            ans += s[c]\n        s[q[j]] = ans\ns.sort()\nprint(' '.join(list(map(str, s))))","output":"nlogn"},{"instruction":"from operator import itemgetter\n\nn, v = map(int, input().split())\n\nif v >= n-1:\n    ans = n-1\nelse:\n    ans = v + ((2+(2+n-v-2))*(n-v-1))\/\/2\nprint(ans)","output":"constant"},{"instruction":"N, MOD = map(int, input().split())\ndp = [[0]*(N+2) for i in range(N+2)]\ndp[0][0] = 1\nlimit = 1000\nfrac = [1]*limit\nfor i in range(2,limit):\n    frac[i] = i * frac[i-1]%MOD\nfraci = [None]*limit\nfraci[-1] = pow(frac[-1], MOD -2, MOD)\nfor i in range(-2, -limit-1, -1):\n    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\nbb = [1, 2]\nfor i in range(1000):\n    bb.append(bb[-1] *2 %MOD)\nfor ln in range(N+1):\n    for cnt in range(ln\/\/2, ln+1):\n        for k in range(1, N-ln+1):\n            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD\n            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD\n            dp[ln+k+1][cnt+k] %= MOD\nR = 0\nfor x in dp[N+1][:N+1]:\n    R = (R+x)%MOD\nprint(R)","output":"cubic"},{"instruction":"n,m=map(int,raw_input().split())\narr=[]\narr1=[]\nfor i in range(n):\n\tarr2=str(raw_input())\n\tarr.append(arr2)\n\tx1=[0]*m\n\tarr1.append(x1)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif(arr[i][j]=='\n\t\t\tif(arr[i][j+1]=='\n\t\t\t\tarr1[i][j]=1\n\t\t\t\tarr1[i+1][j]=1\n\t\t\t\tarr1[i+2][j]=1\n\t\t\t\tarr1[i+2][j+1]=1\n\t\t\t\tarr1[i+2][j+2]=1\n\t\t\t\tarr1[i+1][j+2]=1\n\t\t\t\tarr1[i][j+1]=1\n\t\t\t\tarr1[i][j+2]=1\nflag=0\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif(arr[i][j]==\"\n\t\t\tflag=1\n\t\t\tbreak\n\tif(flag==1):\n\t\tbreak\nif(flag==1):\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")","output":"quadratic"},{"instruction":"k=int(input())\nx=0\nc=0\nwhile(x<k):\n    x+=9*(10**c)*(c+1)\n    c+=1\np=(x-k)%c\nk=((10**c)-int(((x-k)\/c))-1)\nk=str(k)\nprint(k[len(k)-(p)-1])","output":"logn"},{"instruction":"n,m=map(int,input().split())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\n\nfor i in l1:\n    if i in l2:\n        print(i,end=\" \")","output":"quadratic"},{"instruction":"import copy\nimport sys\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in w.items():\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines):\n        u, v, c = map(int, line.split())\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in w.keys():\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in w_tmp.keys():\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        exit(0)\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) \/ 2)\n\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))","output":"nlogn"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\narr1 = [arr[0]]\nm = -1\nfor i, v in enumerate(arr):\n    if v > m + 1:\n        print(i+1)\n        break\n    m = max(m, v)\nelse:\n    print(-1)","output":"linear"},{"instruction":"import math\ndef binom(n, m):\n    return math.factorial(n)\/\/(math.factorial(m)*math.factorial(n-m))\n\ncorrect = input()\nreceived = input()\nplus_correct = correct.count('+')\nmin_correct = correct.count('-')\npos_correct = plus_correct - min_correct\nplus_received = received.count('+')\nmin_received = received.count('-')\nunknown = received.count('?')\npos_received = plus_received - min_received\ndiff = abs(pos_correct - pos_received)\nif (diff + unknown) % 2 != 0 or diff > unknown:\n    prob = 0.0\nelse:\n    m = (diff + unknown) \/\/ 2\n    prob =  1.0 * binom(unknown, m) \/ (2 ** unknown)\nprint(prob)","output":"np"},{"instruction":"import atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(4):\n        df = 0\n        for k in range(n):\n            l = input()\n            for j in range(n):\n                if int(l[j]) == (k + j) % 2:\n                    df += 1\n        if i <3 :\n            input()\n        s.append(df)\n\n    print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3],\n        s[0] + s[2] + n*n-s[1] + n*n-s[3],\n        s[0] + s[3] + n*n-s[1] + n*n-s[2],\n        s[1] + s[2] + n*n-s[0] + n*n-s[3],\n        s[1] + s[3] + n*n-s[0] + n*n-s[2],\n        s[2] + s[3] + n*n-s[0] + n*n-s[1]))\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"def color8(i,j,ip):\n    if i>n-3 or j>m-3:\n        return\n    else:\n        ip[i][j]='\n        ip[i][j+1]='\n        ip[i][j+2]='\n        ip[i+1][j]='\n        ip[i+1][j+2]='\n        ip[i+2][j]='\n        ip[i+2][j+1]='\n        ip[i+2][j+2]='\n\nn,m=map(int,input().split())\nip=[]\nop=[['.' for i in range(m)] for j in range(n)]\n\nb=0\nfor i in range(n):\n    ip.append(str(input()))\n\nfor i in range(n):\n    for j in range(m):\n        if ip[i][j]=='\n            try:\n                if ip[i+2][j+2]=='\n                    temp=(ip[i][j]=='\n\n                    if temp==True:\n                        color8(i,j,op)\n            except:\n                pass\n\nfor i in range(n):\n    if ''.join(op[i])!=ip[i]:\n        print('NO')\n        b=1\n        break\nif b==0:\n    print('YES')","output":"quadratic"},{"instruction":"n,k=map(int,input().split())\nfor i in range(10**5):\n  if (i*(i+1))\/\/2-(n-i)==k:\n    print(n-i)","output":"constant"},{"instruction":"n, m, k, l = list(map(int, input().split()))\nif (l > n - k):\n    print(-1)\nelse:\n    am = ((l + k) \/\/ m + bool((l + k) % m))\n    if am * m > n:\n        print(-1)\n    else:\n        print(am)","output":"constant"},{"instruction":"from math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *\nfrom fractions import *\nfrom sys import *\nfrom types import CodeType, new_class\n\nn, m = map(int, (input().split()))\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nfor x in a:\n    if x in b:\n        print(x, end = ' ')","output":"quadratic"},{"instruction":"import sys,atexit\nfrom io import BytesIO\ninp = BytesIO(sys.stdin.buffer.read())\ninput = lambda:inp.readline().decode('ascii')\nbuf = BytesIO()\nsys.stdout.write = lambda s: buf.write(s.encode('ascii'))\natexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))\n\nn,m = map(int,input().split())\nif m%2 == 0:\n    steps = []\n    for j in range(m\/\/2):\n        for i in range(n):\n            steps.append((j,i))\n            steps.append((m-j-1,n-i-1))\nelse:\n    steps = []\n    for j in range(m\/\/2):\n        for i in range(n):\n            steps.append((j,i))\n            steps.append((m-j-1,n-i-1))\n    l = 0\n    r = n-1\n    mid = m\/\/2\n    while l<=r:\n        steps.append((mid,l))\n        if l != r:\n            steps.append((mid,r))\n        l += 1\n        r -= 1\n\nfor x,y in steps:\n    print(y+1,x+1)","output":"quadratic"},{"instruction":"a, b = list(map(int,input().split()))\nl = 0\nr = a + 1\nwhile r - l > 1:\n    m = (r + l) \/\/ 2\n\n    if m * (m + 1) \/\/ 2 - (a - m) > b:\n        r = m\n    else:\n        l = m\nprint(a - l)","output":"logn"},{"instruction":"l,r=map(int,input().split())\nif(l==r):\n    print(0)\nelse:\n    if(r&(r-1)==0):\n        print(r^(r-1))\n    else:\n        x=l^r\n        p=1\n        while(p<=x):\n            p*=2\n        print(p-1)","output":"logn"},{"instruction":"mod = 1000000000+7\ndef fp(x ,y):\n    if y == 1:\n        return x\n    if y == 0:\n        return 1\n    t = fp(x,y\/\/2)%mod\n    if y%2 == 1:\n        return (t*t*x)\n    else:\n        return (t*t)\n\ndef inv(x):\n    return fp(x%mod,mod-2)%mod\n\nn,k=list(map(int,input().split()))\nif not n:\n    print(0)\n    exit()\nif not k:\n    print( (2*n)%mod )\n    exit()\nnumberOfPro =fp(2,k)\nlast = n*numberOfPro\nfirst = (n-1)*numberOfPro+1\nsumOfLast = (last)*(last+1)*inv(2)\nsumOfFirst = first*(first-1)*inv(2)\nnum = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)\nprint(num%mod)","output":"logn"},{"instruction":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1 if n & 1 else 0\n            n >>= 1\n        return res","output":"constant"},{"instruction":"n=int(input())\nif(n>=0):\n    print(n)\nelse:\n    if((n*-1)\/\/10==0):\n        print(0)\n    else:\n        n*=-1\n        y=n\/\/10\n        z=n%10\n        x=y\/\/10\n        x*=10;\n        x+=z;\n        x*=-1\n        y*=-1\n        if(x>=y):\n            print(x)\n        else:\n            print(y)","output":"constant"},{"instruction":"import sys\n\nfrom bisect import bisect_right as rb\nfrom collections import deque\n\nfrom queue import PriorityQueue\nfrom math import *\ninput_ = lambda: sys.stdin.readline().strip(\"\\r\\n\")\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab,bc,cd : ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x : print(x)\nprinT = lambda x : print(x)\nf = lambda : sys.stdout.flush()\ninv =lambda x:pow(x,mod-2,mod)\nmod = 10**9 + 7\n\ndef bit(n) :\n    if (n == 0) :return 0\n    val = 1\n\n    while (val&n) == 0 :\n        val *= 2\n\n    return val\n\nn,q = il()\nx = n+1\n\nfor i in range(q) :\n    t1 = ii()\n\n    for j in ip() :\n        val = bit(t1)\n\n        if (j == \"U\") :\n            tem = (t1-val)|(val*2)\n            if (tem < n) :\n                t1 = tem\n        elif (j == \"L\" and val>1) :\n            t1 -= val\/\/2\n        elif (j == \"R\" and val>1) :\n            t1 += val\/\/2\n\n    print(t1)","output":"np"},{"instruction":"s = input()\nn = len(s)\nans = 0\nc = 0\nl = []\nfor i in range(n):\n    a = int(s[i])%3\n    if a==0:\n        ans+=1\n        c = 0\n        l = []\n    else:\n        if c==0:\n            l.append(int(s[i]))\n            c+=1\n        elif c==1:\n            if (a+l[0])%3==0:\n                ans+=1\n                c = 0\n                l = []\n            else:\n                c+=1\n        else:\n            ans+=1\n            c=0\n            l = []\nprint(ans)","output":"linear"},{"instruction":"import itertools\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([input() for _ in range(n)])\n    if i < 3:\n        assert input() == ''\n\nbest = 4*n*n\nfor p in itertools.permutations(a):\n    for s in range(2):\n        count = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(n):\n                    if p[i][r][c] != str((s + (i\/\/2 + r) + (i % 2 + c)) % 2):\n                        count += 1\n        best = min(best, count)\nprint(best)","output":"quadratic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef solve():\n    n = ii()\n    d = defaultdict(lambda:0)\n    d1 = defaultdict(lambda:0)\n    for i in range(n):\n        x,y = li()\n        d[x-1]-=1\n        d[y]+=1\n\n    x = list(d.keys())\n    x.sort()\n    r = x[-1]\n\n    c=d[r]\n    temp=1\n    for i in range(len(x)-2,-1,-1):\n        l = x[i]+1\n        d1[c]+=r-l+temp\n\n        c+=d[x[i]]\n        r=l\n        temp=0\n\n    for i in range(1,n+1):\n        print(d1[i],end=\" \")\n    print()\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"nlogn"},{"instruction":"n,a,b,c,t=map(int,input().split())\nl=list(map(int,input().split()))\nif c>b:\n    r=0\n    for i in l:\n        k=t-i\n        k*=(c-b)\n        r+=k\n    print(a*n+r)\nelse:\n    print(a*n)","output":"linear"},{"instruction":"n, v = map(int, input().strip().split())\nanswer = 0\nn -= 1\nif n <= v:\n    print(n)\nelse:\n    answer =v\n\n    for i in range(1,n-v + 1):\n\n        answer += (i + 1)\n    print(answer)","output":"linear"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nlf = [(a[i], i) for i in range(n) if a[i] == 1]\nit = [(a[i], i) for i in range(n) if a[i] > 1]\nit.sort(reverse=True)\nwhile len(lf) < 2:\n    lf.append(it.pop())\n\ned = []\n_, last = lf.pop()\n\nfor i in range(len(it)):\n    cap, u = it[i]\n    if i != 0:\n        ed.append((it[i - 1][1], u))\n        cap -= 1\n    while lf and cap > 1:\n        _, l = lf.pop()\n        ed.append((u, l))\n        cap -= 1\n\nif lf:\n    ans = 'NO'\nelse:\n    ans = 'YES %d' % (len(it) + 1,)\n    ed.append((it[-1][1], last))\n    ans1 = str(len(ed))\n    ans2 = '\\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)\n    ans = '\\n'.join([ans, ans1, ans2])\nprint(ans)","output":"nlogn"},{"instruction":"import sys\nfrom array import array\n\nn = int(input())\nedge = [list(map(int, input().split())) for _ in range(n)]\nmod = 10**9 + 7\n\ndp_f = [array('i', [-1])*n for _ in range(n)]\ndp_g = [array('i', [-1])*n for _ in range(n)]\n\nfor i in range(n):\n    dp_f[i][i] = dp_g[i][i] = 1\nfor i in range(n-1):\n    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0\n\ndef f(l, r):\n    if dp_f[l][r] != -1:\n        return dp_f[l][r]\n\n    dp_f[l][r] = g(l, r) if edge[l][r] else 0\n    for m in range(l+1, r):\n        if edge[l][m]:\n            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n\n    return dp_f[l][r]\n\ndef g(l, r):\n    if dp_g[l][r] != -1:\n        return dp_g[l][r]\n\n    dp_g[l][r] = f(l+1, r)\n    for m in range(l+1, r):\n        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod\n\n    return dp_g[l][r]\n\nprint(f(0, n-1))","output":"cubic"},{"instruction":"import time\nfrom copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport math\nfrom collections import deque\nfrom collections import Counter\n\ndef read():\n    return int(input())\n\ndef readmap():\n    return map(int, input().split())\n\ndef readlist():\n    return list(map(int, input().split()))\n\nn, m = readmap()\nX = []\nD = []\nfor _ in range(m):\n    x, d = readmap()\n    X.append(x)\n    D.append(d)\n\nsumm = n * sum(X)\n\nfor i in range(m):\n    d = D[i]\n    if d < 0:\n        if n % 2 == 1:\n            summ += d * (n \/\/ 2) * (n \/\/ 2 + 1)\n        else:\n            summ += d * (n \/\/ 2) * (n \/\/ 2)\n    else:\n        summ += d * (n - 1) * n \/\/ 2\n\nprint(summ \/ n)","output":"linear"},{"instruction":"from sys import stdin\nfrom math import hypot\n\ndef main():\n    l = stdin.read().splitlines()[1:]\n    for i, s in enumerate(l):\n        l[i] = [*map(float, s.split()), i]\n    l.sort(key=lambda xyi: abs(xyi[0]))\n    res = ['1'] * len(l)\n    x, y, _ = l.pop()\n    while(l):\n        dx, dy, i=l.pop()\n        a, b, u, v = x + dx, y + dy, x - dx, y - dy\n        if hypot(a, b) < hypot(u, v):\n            x, y = a, b\n        else:\n            x, y, res[i] = u, v, '-1'\n    print(' '.join(res))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"n = int(input())\np = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)])\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    l, r = 0, i\n    while r - l > 1:\n        mid = (l + r) >> 1\n        if p[i][0] - p[i][1] <= p[mid][0]: r = mid\n        else: l = mid\n    dp[i] = i - r + dp[r - 1]\nans = min(dp[i] + (n - i) for i in range(1, n + 1))\nprint(ans)","output":"linear"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M, K = map(int, input().split())\nif K % 2:\n    for _ in range(N):\n        print(*[-1] * M)\n    exit()\nA = [[int(a) for a in input().split()] for _ in range(N)]\nB = [[int(a) for a in input().split()] for _ in range(N-1)]\nX = [[0] * M for _ in range(N)]\ninf = 1 << 30\nfor k in range(1, K \/\/ 2 + 1):\n    nX = [[inf] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])\n            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])\n            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])\n            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])\n    X = nX\nfor x in X:\n    print(*[a * 2 for a in x])","output":"cubic"},{"instruction":"n = int(input())\nleafs = set()\nother = {}\nother_indices = []\ns = 0\nfor i, a in enumerate(map(int, input().split())):\n    if a == 1:\n        leafs.add(i)\n    else:\n        other[i] = a\n        other_indices.append(i)\n    s += a\n\nif not other:\n\n    print(\"NO\")\n    exit(0)\n\nother_indices.sort(key=lambda index: other[index])\nother_indices = [other_indices[-1]] + other_indices[:-1]\n\nedges = []\nfor i1, i2 in zip(other_indices, other_indices[1:]):\n    edges.append((i1, i2))\n    other[i1] -= 1\n    if other[i1] == 0:\n        del other[i1]\n    other[i2] -= 1\n    if other[i2] == 0:\n        del other[i2]\n\ndiam = len(other_indices) + min(2, len(leafs))\n\nhas_start = has_end = False\n\nwhile leafs:\n    if len(other) == 0:\n        print(\"NO\")\n        exit(0)\n    l = leafs.pop()\n    if not has_start and other.get(other_indices[0], 0):\n        i = other_indices[0]\n        has_start = True\n    elif not has_end and other.get(other_indices[-1], 0):\n        i = other_indices[-1]\n        has_end = True\n    else:\n        i = next(iter(other))\n    edges.append((l, i))\n    other[i] -= 1\n    if other[i] == 0:\n        del other[i]\n\nprint(\"YES\", diam - 1)\nprint(len(edges))\nfor x, y in edges:\n    print(x+1, y+1)","output":"nlogn"},{"instruction":"n = int(input())\n\npairs = [int(i) for i in input().split(\" \")]\n\nN=len(pairs)\nN\/\/=2\nvisited = [False] * (N + 1)\n\nminimumSwaps = 0\n\nfor i in range(2 * N) :\n    if (visited[pairs[i]] == False) :\n        visited[pairs[i]] = True\n        count = 0\n        for j in range( i + 1, 2 * N) :\n            if (visited[pairs[j]] == False) :\n                count += 1\n            elif (pairs[i] == pairs[j]) :\n                minimumSwaps += count\nprint(minimumSwaps)","output":"quadratic"},{"instruction":"a = [0 for i in range(100)]\nb = [0 for i in range(100)]\nfor i in range(1, 100):\n\ta[i] = a[i - 1] * 2 + 1\n\tb[i] = b[i - 1] + a[i]\ndef calc(x):\n\treturn (4 ** x - 1) \/\/ 3\nfor i in range(int(input())):\n\tn, k = map(int, input().split())\n\tif n > 35:\n\t\tprint(\"YES \" + str(n - 1))\n\telif 1 + calc(n - 1) >= k:\n\t\tprint(\"YES \" + str(n - 1))\n\telif calc(n) < k:\n\t\tprint(\"NO\")\n\telse:\n\t\tfor i in range(1, (n + 1)):\n\t\t\tif b[i] <= k and k <= calc(n) - (2 ** (i + 1) - 1) * calc(n - i):\n\t\t\t\tprint(\"YES \" + str(n - i))\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(\"NO\")","output":"logn"},{"instruction":"from sys import stdout\na, b = 0, 0\n\nmp = 29\n\nc, d = 0,0\n\npowers = [1]\nfor i in range(32):\n    powers.append(powers[-1]*2)\n\nqqq = 0\n\ndef get_ans(c, d):\n    global qqq\n    qqq += 1\n    a, b = 1073741823, 1073741821\n    a, b = 3, 1\n\n    print(c, d)\n\n    if (a^c) > (b^d):\n        print(1)\n        return -1\n    elif (a^c) < (b^d):\n        print(-1)\n        return 1\n    print(0)\n    return 0\n\ndef get_ans(c, d):\n    print('? {} {}'.format(c, d))\n    stdout.flush()\n    return -int(input())\n\nq = get_ans(0, 0)\n\nfor i in range(mp+1):\n    cp = mp - i\n    c += powers[cp]\n    d += powers[cp]\n\n    if q == 0:\n        continue\n    t = get_ans(c, d)\n\n    if t != q:\n\n        if t == 1:\n            a += powers[cp]\n            c -= powers[cp]\n        elif t == -1:\n            b += powers[cp]\n            d -= powers[cp]\n        q = get_ans(c, d)\n\nfor i in range(mp+1):\n    cp = mp - i\n\n    if c & powers[cp] > 0 and d & powers[cp] > 0:\n        c -= powers[cp]\n        t = get_ans(c, d)\n\n        if t < 0:\n            a += powers[cp]\n            b += powers[cp]\n\n        c += powers[cp]\n\nprint('!', a, b)","output":"logn"},{"instruction":"import math\n\nf = [0] * 100\nfor i in range(100):\n    f[i] = (4**i-1) \/\/ 3\n\ndef solve(N, K):\n\n    if N < 100 and f[N] < K:\n        print('NO')\n        return\n\n    for i in range(99):\n        if f[i] <= K < f[i+1]:\n            x = K - f[i]\n            a = N - i\n\n            if x == 0:\n                print('YES {}'.format(a))\n                return\n\n            edge = 2**(i+1) - 1\n            others = (2**i-1) ** 2\n            if edge == x:\n                print('YES {}'.format(a-1))\n                return\n\n            ans = a\n            if edge < x:\n                x -= edge\n                ans = a-1\n\n            for j in range(a + 1):\n                if others * f[j] >= x:\n                    print('YES {}'.format(ans))\n                    return\n            print('NO')\n\n            return\n\n    print('NO')\n\nT = int(input())\n\nfor ti in range(T):\n    N, K = map(int, input().split())\n    solve(N, K)","output":"logn"},{"instruction":"def read_int():\n    return int(raw_input().strip())\n\ndef read_ints():\n    return list(map(int, raw_input().strip().split(' ')))\n\ndef solve():\n\n    R, G, B = read_ints()\n    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]\n\n    Rs = read_ints()\n    Gs = read_ints()\n    Bs = read_ints()\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n    answer = 0\n    for r in range(R+1):\n        for g in range(G+1):\n            for b in range(B+1):\n                if r > 0 and g > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])\n                if g > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])\n                if r > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])\n                answer = max(answer, dp[r][g][b])\n    return answer\n\nif __name__ == '__main__':\n    print(solve())","output":"cubic"},{"instruction":"from collections import defaultdict\nfrom sys import stdin\n\nall_in = stdin.read().splitlines()\n\nn = int(all_in[0])\ns = all_in[1:]\n\none = defaultdict(lambda: 0)\ntwo = defaultdict(lambda: 0)\n\nfor el in s:\n    I = 0\n    min_ = 0\n\n    for char in el:\n        I += {'(': 1, ')': -1}[char]\n        min_ = min(min_, I)\n\n    if I >= 0 and min_ == 0:\n        one[I] += 1\n\n    if I <= 0 and min_ == I:\n        two[I] += 1\n\nans = 0\nfor el in one.keys():\n    ans += one[el] * two[-el]\n\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\nd = {}\nfor _ in range(n):\n  a, x = map(int, input().split())\n  d[a] = x\nm = int(input())\nfor _ in range(m):\n  b, y = map(int, input().split())\n  d[b] = max(d.get(b, 0), y)\nprint(sum(d.values()))","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\ns = list(map(int, input().split()))\nd = []\nfor q in range(n):\n    d.append(a[q]+s[q])\nd = [n-q for q in d]\nfor q in range(n):\n    f = 0\n    for q1 in range(q):\n        if d[q1] > d[q]:\n            f += 1\n    g = 0\n    for q1 in range(q+1, n):\n        if d[q1] > d[q]:\n            g += 1\n    if f != a[q] or g != s[q]:\n        print('NO')\n        break\nelse:\n    print('YES')\n    print(*d)","output":"quadratic"},{"instruction":"import sys\nimport copy\ninput = sys.stdin.readline\nn,k=map(int,raw_input().split())\nC=list(raw_input().strip())\ndef JUDGE(C):\n    ANS_one=0\n    ANS_zero=0\n    for c in C:\n        if c==\"0\":\n            ANS_zero+=1\n        else:\n            break\n    for c in C[::-1]:\n        if c==\"0\":\n            ANS_zero+=1\n        else:\n            break\n    for c in C:\n        if c==\"1\":\n            ANS_one+=1\n        else:\n            break\n    for c in C[::-1]:\n        if c==\"1\":\n            ANS_one+=1\n        else:\n            break\n    if ANS_zero>=n-k or ANS_one>=n-k:\n        return 1\n    else:\n        return 0\nif JUDGE(C)==1:\n    print(\"tokitsukaze\")\n    sys.exit()\nif k>=n-1:\n    print(\"quailty\")\n    sys.exit()\nif k<n\/2:\n    print(\"once again\")\n    sys.exit()\nCAN1=copy.copy(C)\nCAN2=copy.copy(C)\nif C[0]==\"0\":\n    for i in range(1,k+1):\n        CAN1[i]=\"1\"\nelse:\n    for i in range(1,k+1):\n        CAN1[i]=\"0\"\nif C[-1]==\"0\":\n    for i in range(n-1,n-k-1,-1):\n        CAN2[i]=\"1\"\nelse:\n    for i in range(n-2,n-k-2,-1):\n        CAN2[i]=\"0\"\nif JUDGE(CAN1)==1 and JUDGE(CAN2)==1:\n    print(\"quailty\")\n    sys.exit()\nelse:\n    print(\"once again\")\n    sys.exit()","output":"linear"},{"instruction":"input_1 = input()\ninput_2 = input()\n\nline_1 = [i for i in str(input_1)]\nline_2 = [i for i in str(input_2)]\n\nno = 0\nfor i in range(len(line_1) - 1):\n    if line_1[i] != 'X' and line_2[i] != 'X':\n        if line_1[i + 1] != 'X':\n            no += 1\n            line_1[i] = 'X'\n            line_2[i] = 'X'\n            line_1[i + 1] = 'X'\n\n        elif line_2[i + 1] != 'X':\n            no += 1\n            line_1[i] = 'X'\n            line_2[i] = 'X'\n            line_2[i + 1] = 'X'\n\n    elif line_1[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':\n        no += 1\n        line_1[i] = 'X'\n        line_1[i + 1] = 'X'\n        line_2[i + 1] = 'X'\n\n    elif line_2[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':\n        no += 1\n        line_2[i] = 'X'\n        line_1[i + 1] = 'X'\n        line_2[i + 1] = 'X'\n\nprint(no)","output":"constant"},{"instruction":"Q = int(input())\nsrc = [tuple(map(int,input().split())) for i in range(Q)]\nans = []\nfor x,y,k in src:\n    d = max(x,y)\n    if (x+y)%2:\n        ans.append(-1 if d > k else k-1)\n    else:\n        if d > k:\n            ans.append(-1)\n        else:\n            ans.append(k-2 if (d+k)%2 else k)\n\nprint(*ans,sep='\\n')","output":"constant"},{"instruction":"import sys\ndp=[]\na=[]\ndef calcdp(l,r):\n    global dp,a\n    if l+1==r :\n        dp[l][r]=a[l]\n        return dp[l][r]\n    if dp[l][r]!=0:\n        return dp[l][r]\n    dp[l][r]=-1\n    for k in range(l+1,r):\n        la=calcdp(l,k)\n        ra=calcdp(k,r)\n        if la>0 and la==ra:\n            dp[l][r]=la+1\n    return dp[l][r]\ndef solve(n):\n    dp2=[float('inf')]*(n+1)\n    dp2[0]=0\n    for i in range(n):\n        for j in range(i+1,n+1):\n            if calcdp(i,j)>0:\n                dp2[j]=min(dp2[j],dp2[i]+1)\n\n    return dp2[n]\ndef ip():\n    global dp,a\n\n    n=int(sys.stdin.readline())\n    a=list(map(int,sys.stdin.readline().split()))\n    a.append(0)\n\n    dp=[]\n    ll=[0]*(n+1)\n    for _ in range(n+1):\n        dp.append(list(ll))\n\n    print(solve(n))\n\nip()","output":"cubic"},{"instruction":"n, s = list(map(int, input().split()))\nnum_1 = s \/\/ n\nif s % n == 0:\n    print(num_1)\nelse:\n    print(num_1 + 1)","output":"constant"},{"instruction":"n, k = map(int, input().split())\na, b, c = 2 * n, 5 * n, 8 * n\nceil = lambda x, y: (x + y - 1) \/\/ y\nprint(ceil(a, k) + ceil(b, k) + ceil(c, k))","output":"constant"},{"instruction":"def secondorder(arr, size):\n\tarr.sort()\n\treturn arr[1]\nsize = int(input())\nlist = []\nnum = input().split(\" \")\nfor i in num:\n\tif(int(i) not in list):\n\t\tlist.append(int(i))\nif len(list) == 1:\n\tprint(\"NO\")\nelse:\n\tprint(secondorder(list, size))","output":"nlogn"},{"instruction":"n=int(input())\nA=list(map(int,input().split()))\n\nif n==1:\n    print(A[0])\n\nelif n==2:\n    print(abs(A[0]-A[1]))\n\nelse:\n    SUM=0\n    for i in range(n):\n        SUM+=abs(A[i])\n    ANS=0\n\n    for i in range(n-1):\n        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):\n            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])\n\n    print(ANS)","output":"linear"},{"instruction":"def func(mid,s):\n    p=0\n    q=mid\n    while (mid>0):\n        p+=mid%10\n        mid=mid\/\/10\n\n    if (q-p)>=s:\n        return True\n    else:\n        return False\nn,s=map(int,input().split())\ndo=1\nup=10**18\nan=n+1\nwhile (up>=do):\n    mid=(up+do)\/\/2\n    if func(mid,s):\n        up=mid-1\n        an=mid\n    else:\n        do=mid+1\nif an>n:\n    print(0)\nelse:\n    print(n-an+1)","output":"logn"},{"instruction":"from itertools import combinations as cmb\nn ,l ,r ,x = map(int , input().split())\n*a , = map(int ,input().split())\nb = []\na.sort()\nfor i in range(2 ,n+1):\n    b.extend(cmb(a ,i))\nans = 0\nfor i in b:\n\n    if(sum(i) >= l and sum(i) <= r):\n        if(i[-1]-i[0] >= x):\n\n            ans+=1\n\nprint(ans)","output":"np"},{"instruction":"n,s=map(int,input().split())\nmins=s\nmy_dict={}\nmylist=[]\nwhile(n):\n\tperson,floor=map(int,input().split())\n\tmylist.append(person+floor)\n\tn-=1\nval=max(mylist)\nif(val<mins):\n\tprint(mins)\nelse:\n\tprint(val)","output":"linear"},{"instruction":"lis = []\nfor _ in range(int(input())):\n    lis.append(input())\nlis = sorted(lis, key=len)\n\nfor i in range(len(lis) - 1):\n    if(lis[i] not in lis[i + 1]):\n        print(\"NO\")\n        exit(0)\n\nprint(\"YES\")\nfor i in lis:\n    print(i)","output":"nlogn"},{"instruction":"z,zz=input,lambda:list(map(int,z().split()))\nfast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=1\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\ndef output(answer):\n    stdout.write(str(answer))\n\nnum=int(z())\n\narr=zzz()\n\nnew_arr=[(i,j+1) for j,i in enumerate(arr)]\nnew_arr=sorted(new_arr)\n\npassenger=fast()\n\nque=deque()\n\nans=[0]*2*num\n\nleft=0\nright=num-1\nle=0\n\nfor i in range(2*num):\n    if passenger[i]=='0':\n        ans[i]=new_arr[left][1]\n        que.append(new_arr[left][1])\n        left+=1\n        le+=1\n\n    else:\n        if le>=1:\n            ans[i]=que[-1]\n            que.pop()\n            le-=1\n        else:\n            ans[i]=new_arr[right][1]\n            que.append(new_arr[right][1])\n            right-=1\n            le+=1\nprint(*ans)","output":"nlogn"},{"instruction":"x, k = [int(a) for a in input().strip().split()]\n\ndef binpow(x, k, mod):\n    res = 1\n    while k > 0:\n        if k & 1:\n            res  = ( res * x ) % mod\n        x = ( x * x) % mod\n        k >>= 1\n    return res\nif x == 0:\n    print(0)\n    exit()\n\nmod = int(1e9 + 7)\nk2 = binpow(2, k, mod)\nres = ( k2 * (2 * x - 1) + 1) % mod\n\nres %= mod\n\nprint(int(res))","output":"logn"},{"instruction":"n, m = map(int, input().split())\nB = list(map(int, input().split()))\nG = list(map(int, input().split()))\nif min(G) < max(B):\n    print(-1)\n    exit(0)\ncnt = 0\nz = max(B)\ny = 0\nf = 1\nf2 = 0\nfor i in B:\n    if i != z or f2:\n        y = max(y, i)\n    else:\n        f2 = 1\nfor i in G:\n    if i == z:\n        f = 0\n    cnt += i - z\nif f:\n    cnt += z - y\nprint(cnt + sum(B) * m)","output":"linear"},{"instruction":"n, q = map(int, input().split())\nA = list(map(int, input().split()))\nK = list(map(int, input().split()))\nfrom itertools import accumulate\nC = [0]+A\nC = list(accumulate(C))\ntotal = 0\nans = [0]*q\nimport bisect\nfor i, k in enumerate(K):\n    total += k\n    j = bisect.bisect_right(C, total)\n    if j != n+1:\n        ans[i] = n-(j-1)\n    else:\n        ans[i] = n\n        total = 0\nprint(*ans, sep='\\n')","output":"nlogn"},{"instruction":"n, k = map(int,input().split())\ns = input()\np = len(s)-1\nwhile s[:p] != s[-p:]:\n    p =  p -1\nprint(s + s[p:]*(k-1))","output":"quadratic"},{"instruction":"n, m =map(int, input().split())\nif m % n != 0:\n\tprint( m \/\/ n + 1)\nelse:\n\tprint(m \/\/ n)","output":"constant"},{"instruction":"s=input()\no=len(s)\nk=0\nfor i in range(o):\n    r={0}\n    for j in range(o-i+1):\n        if s[j:j+i] in r:k=max(i,k)\n        else:r.add(s[j:j+i])\nprint(k)","output":"cubic"},{"instruction":"import bisect\nimport math\nimport itertools\nimport sys\n\nalpha = 'abcdefghijklmnopqrstuvwxyz'\ninf = 1e17\n\ndef calc1(grid):\n    l = len(grid)\n    cnt = 0\n    for i in range(l):\n        for j in range(l):\n            if (i+j) % 2 and grid[i][j]:\n                cnt += 1\n            if (i+j) % 2 == 0 and grid[i][j] == 0:\n                cnt += 1\n    return cnt\n\ndef calc2(grid):\n    l = len(grid)\n    cnt = 0\n    for i in range(l):\n        for j in range(l):\n            if (i+j) % 2 and grid[i][j] == 0:\n                cnt += 1\n            if (i+j) % 2 == 0 and grid[i][j]:\n                cnt += 1\n    return cnt\ndef solve(n,grids):\n    one = []\n    zero = []\n    for grid in grids:\n        one.append(calc1(grid))\n        zero.append(calc2(grid))\n    take = [3,5,6,9,10,12]\n    answer = inf\n    for mask in range(16):\n        cnt = 0\n        if mask not in take:\n            continue\n        if mask in take:\n            if mask & 1:\n                cnt += one[3]\n                pass\n            else:\n                cnt += zero[3]\n                pass\n            if mask & 2:\n                cnt += one[2]\n                pass\n            else:\n                cnt += zero[2]\n                pass\n            if mask & 4:\n                cnt += one[1]\n                pass\n            else:\n                cnt += zero[1]\n                pass\n            if mask & 8:\n                cnt += one[0]\n                pass\n            else:\n                cnt += zero[0]\n                pass\n        answer = min(answer,cnt)\n    return answer\n\nt = 1\nans = []\nfor _ in range(t):\n    n = int(input())\n\n    grids = []\n    for i in range(4):\n        grid = []\n        for j in range(n):\n            arr = list(map(int,list(input())))\n            grid.append(arr)\n        if i != 3:\n            s = input()\n        grids.append(grid)\n\n    ans.append(solve(n,grids))\n\nfor test in ans:\n    print(test)","output":"quadratic"},{"instruction":"n, k = map(int,input().split())\n\nstart = 0\ncnt = n\ncur = 1\n\nwhile start <= k:\n    start += cur\n    cnt -= 1\n    cur += 1\n\nans = 0\n\nif start != k:\n    while cnt > 0:\n        if start == k:\n            start += cur\n            cur += 1\n            cnt -= 1\n        ans += (start - k)\n        cnt -= (start - k)\n        start = k\n\nprint(ans)","output":"logn"},{"instruction":"modulo = 1000 ** 3 + 7\n\ndef mat_oz(x, k):\n    if k == 0:\n        return (2 * x) % modulo\n    if x == 0:\n        return 0\n    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo\n    return b\n\ny, m = [int(i) for i in input().split()]\nprint(mat_oz(y, m))","output":"logn"},{"instruction":"n, m, k, l = map(int, input().split())\nif k + l > n:\n    print(-1)\nelse:\n    x = (k + l) \/\/ m + (1 if (k + l) % m != 0 else 0)\n    if x * m > n:\n        print(-1)\n    else:\n        print(x)","output":"constant"},{"instruction":"def f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y\/\/g):d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n return d[s]\nimport math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"INF = 1000_000_000\n\nfrom collections import deque\n\nt = 1\n\nfor test in range(t):\n\n    n,q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    maxval = max(arr)\n    d = deque(arr)\n    ans = {}\n    count = 1\n\n    while d[0]!=maxval:\n        a = d.popleft()\n        b = d.popleft()\n        ans[count] = (a,b)\n        count+=1\n        d.append(min(a,b))\n        d.appendleft(max(a,b))\n    n = n-1\n    for i in range(q):\n        m = int(input())\n        if m in ans:\n            print(ans[m][0],ans[m][1])\n        else:\n            m = m - count\n            print(maxval, d[1+(m%n)])","output":"linear"},{"instruction":"a=int(input())\nl=[]\ntotal=0\nfor i in range(4):\n    line=''\n\n    for x in [0]*a:\n        line+=input()\n    l.append(line)\n    input() if i!=3 else 0\nl=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1]\nfor z,v in enumerate(l):\n    if z<2:\n        for i in range(a**2):\n            total += v[i]!='0' if i%2 else v[i]!='1'\n    else:\n        for i in range(a**2):\n            total += v[i]!='1' if i%2 else v[i]!='0'\nprint(total)","output":"quadratic"},{"instruction":"n,m=map(int,input().strip().split())\nv=[0]*51\nleft=1\nright=n\nfor i in range(1,n+1):\n\tif(n-i-1<=0):\n\t\tpw=1\n\telse:\n\t\tpw=(1<<(n-i-1))\n\n\tif(m<=pw):\n\t\tv[left]=i\n\t\tleft+=1\n\telse:\n\t\tv[right]=i\n\t\tright-=1\n\t\tm-=pw\nfor i in range(1,n):\n\tprint(v[i], end=' ')\nprint(v[n])","output":"np"},{"instruction":"def check(a, b):\n    if a[1] == b[1] and 1 <= abs(int(b[0]) - int(a[0])) <= 2:\n        return True\n\narr = input().split()\nd = {}\nfor i in arr:\n    d[i] = d.get(i, 0) + 1\nmineq = 3 - max(d.values())\narr.sort(key=lambda x: x[0])\narr.sort(key=lambda x: x[1])\nif check(arr[0], arr[1]) or check(arr[1], arr[2]):\n    mineq = min(mineq, 1)\nif arr[0][1] == arr[1][1] == arr[2][1] and int(arr[2][0]) - int(arr[1][0]) == 1 and int(arr[1][0]) - int(arr[0][0]) == 1:\n    mineq = 0\nprint(mineq)","output":"nlogn"},{"instruction":"import sys\nfrom array import array\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    max_bit = 1 << m\n    fullbit = max_bit - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = array('i', [-1]) * max_bit\n        for i in range(n):\n            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i\n\n        for i in range(max_bit):\n            if dp[i] == -1:\n                continue\n            for j in range(i, max_bit):\n                if dp[j] != -1 and i | j == fullbit:\n                    return dp[i], dp[j]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n = int(input())\n\nL = [int(x) for x in input().split()]\nD = {}\nJ = []\nS = []\nT = [0]*(n+1)\nfor i in range(n):\n    if L[i] > 0:\n        D[L[i]] = i\n        J.append(L[i])\n        T[i+1] = T[i]\n    else:\n        T[i+1] = T[i]+1\n\ndef I(J):\n    if len(J) <= 1:\n        return J, 0\n    else:\n        a = J[:len(J)\/\/2]\n        b = J[len(J)\/\/2:]\n        a, ai = I(a)\n        b, bi = I(b)\n        c = []\n        i = 0\n        j = 0\n        inversions = ai + bi\n    while i < len(a) and j < len(b):\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            inversions += (len(a)-i)\n    c += a[i:]\n    c += b[j:]\n    return c, inversions\n\nfor i in range(1,n+1):\n    if not i in D:\n        S.append(i)\n\ntotal = len(S)\nnum = 1\ndenom = 1\nif total > 0:\n    themostimportantsum = 0\n    for i in J:\n        low = 0\n        high = total-1\n        while high-low > 1:\n            guess = (high+low)\/\/2\n            if S[guess] > i:\n                high = guess\n            else:\n                low = guess\n        if S[low] > i:\n            smaller = low\n        elif S[high] > i:\n            smaller = high\n        else:\n            smaller = high+1\n\n        themostimportantsum += T[D[i]]*(total-smaller)+(total-T[D[i]])*(smaller)\n        num = themostimportantsum+total\n        denom = total\n\nnum =(denom*(((total)*(total-1))\/\/2)+2*num)%998244353\ndenom *= 2\nif num == denom:\n    if I(J)[1] == 0:\n        print(0)\n    else:\n        print(I(J)[1]%998244353)\nelse:\n    num += denom*I(J)[1]\n    print(((num-denom)*pow(denom%998244353,998244351,998244353))%998244353)","output":"nlogn"},{"instruction":"n = int(input())\n\na = [input() for _ in range(n)]\nb = [input() for _ in range(n)]\n\ncost = 0\nfor s in [\"M\", \"S\", \"XS\", \"XXS\", \"XXXS\", \"L\", \"XL\", \"XXL\", \"XXXL\"]:\n    ca = a.count(s)\n    cb = b.count(s)\n    cost += ca - min(ca, cb)\n\nprint(cost)","output":"linear"},{"instruction":"n,k = [int(x) for x in input().split()]\ndp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]\ndp[1][2][0] = 1\ndp[1][2][1] = 1\ndp[1][1][2] = 1\ndp[1][1][3] = 1\n\nfor n1 in range(1,n):\n    for k1 in range(1,k+1):\n\n        dp[0][k1][0] = dp[1][k1][0]\n        dp[0][k1][1] = dp[1][k1][1]\n        dp[0][k1][2] = dp[1][k1][2]\n        dp[0][k1][3] = dp[1][k1][3]\n\n        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353\n\n        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353\n\n        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353\n\n        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353\ntotal = 0\n\nfor i in range(4):\n    total += dp[1][k][i] % 998244353\n\nprint(total% 998244353 )","output":"np"},{"instruction":"def really_big(x):\n    sum_digit = 0\n    digits = x\n    while digits > 0:\n        sum_digit += digits % 10\n        digits = digits \/\/ 10\n\n    if x - sum_digit >= s:\n        return True\n    return False\n\ndef solve():\n    left = 1\n    right = n\n    ans = 0\n    while left <= right:\n        mid = (left + right) \/\/ 2\n        if really_big(mid):\n            right = mid - 1\n            ans = n - mid + 1\n        else:\n            left = mid + 1\n    return ans\n\nn, s = map(int, input().split())\nprint(solve())","output":"logn"},{"instruction":"pfs=[i*i for i in range(1,3163)]\np=[i for i in range(0,10000001)]\nfor i in range(1,10000001):\n    if(p[i]==i):\n        for j in pfs:\n            if(i*j>10000000): break\n            p[i*j]=i\nt=int(input())\nfor lll in range(0,t):\n    n,k=map(int,input().split())\n    zc=list(map(int,input().split()))\n    s=[p[zc[i]] for i in range(0,len(zc))]\n    dp=[n]*(k+1)\n    dp[0]=1\n    ys=[{}]*(n+1)\n    for i in range(0,len(s)):\n        for j in range(k,-1,-1):\n            if(dp[j]==n): continue\n            if(ys[j].get(s[i],-1)!=-1):\n                if(j<k and dp[j]<dp[j+1]):\n                    dp[j+1]=dp[j]\n                    ys[j+1]=ys[j]\n                dp[j]+=1\n                ys[j]={}\n            ys[j][s[i]]=1\n    print(min(dp))","output":"cubic"},{"instruction":"from math import sqrt,gcd,ceil,floor,log,factorial\nfrom itertools import permutations,combinations\nfrom collections import Counter, defaultdict\n\ndef dist(x1,x2):\n    return abs(x1-x2)\n\ndef power2(n):\n    return ceil(log(n,2)) == floor(log(n,2))\n\nn=int(input())\nx = list(map(int,input().split()))\n\nflag1,flag2,flag3=0,0,0\nd=Counter(x)\n\nfor i in x:\n    for po in range(0,31):\n        if d[i-pow(2,po)]>0 and d[i+pow(2,po)]>0:\n            print(3)\n            print(i,i-pow(2,po),i+pow(2,po))\n            flag1=1\n            break\n\n    if flag1==1:\n        break\n\nif flag1==0:\n    for i in x:\n        for po in range(0,31):\n            if d[i-pow(2,po)]>0:\n                print(2)\n                print(i,i-pow(2,po))\n                flag2=1\n                break\n\n            elif d[i+pow(2,po)]>0:\n                print(2)\n                print(i,i+pow(2,po))\n                flag2=1\n                break\n\n        if flag2==1:\n            break\n\n    if flag2==0:\n        print(1)\n        print(max(x))","output":"nlogn"},{"instruction":"def find(x):\n    if root==x:\n        u=root\n    else:\n        i=0\n        s=2**i\n        while x%s==0:\n            i+=1\n            s=2**i\n        s=s\/\/2\n        y=i+1\n        if (x-s)%(2**y)!=0:\n            u=x-s\n        else:\n            u=x+s\n    return u\nn,q=list(map(int,input().split()))\nroot=(n+1)\/\/2\nfor j in range(q):\n    n1=int(input())\n    str1=input()\n    for j in range(len(str1)):\n        up=find(n1)\n        if str1[j]=='U':\n            n1=(up)\n        elif n1%2==0:\n            if str1[j]=='L':\n                if n1!=root:\n                    n1=(n1-abs((up-n1)\/\/2))\n                else:\n                    n1=(n1-n1\/\/2)\n            elif str1[j]=='R':\n                if n1!=root:\n                    n1=(n1+abs((up-n1)\/\/2))\n                elif n1%2==0:\n                    n1=n1+n1\/\/2\n    print(n1)","output":"np"},{"instruction":"import sys\nN, M = map(int, input().split())\n\nAns = [(0, 0) for  _ in range(N*M)]\nfor i in range(1, N*M+1):\n    if i % 2:\n        a, b = divmod(i\/\/2, M)\n    else:\n        a, b = divmod(N*M - i\/\/2, M)\n    Ans[i-1] = (a+1, b+1)\nfor a in Ans:\n    sys.stdout.write('{} {}\\n'.format(*a))","output":"quadratic"},{"instruction":"import sys\nfrom collections import deque\n\nfrom copy import *\nfrom bisect import *\n\nfrom math import gcd,ceil,sqrt\nfrom itertools import permutations as prm,product\n\ndef eprint(*args):\n    print(*args, file=sys.stderr)\nzz=1\n\nif zz:\n\tinput=sys.stdin.readline\nelse:\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef string(s):\n\treturn \"\".join(s)\ndef fori(n):\n\treturn [fi() for i in range(n)]\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef bo(i):\n\treturn ord(i)-ord('A')\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\ndef gi():\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint(\"Case\ndef cil(n,m):\n\treturn n\/\/m+int(n%m>0)\ndef fi():\n\treturn int(input())\ndef pro(a):\n\treturn reduce(lambda a,b:a*b,a)\ndef swap(a,i,j):\n\ta[i],a[j]=a[j],a[i]\ndef si():\n\treturn list(input().rstrip())\ndef mi():\n\treturn \tmap(int,input().split())\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m\ndef bo(i):\n\treturn ord(i)-ord('a')\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\nt=1\n\nwhile t>0:\n\tt-=1\n\tl,r=mi()\n\tif len(bin(l))<len(bin(r)):\n\t\tprint(2**len(bin(r)[2:])-1)\n\telse:\n\t\tp=bin(l)[2:]\n\t\tq=bin(r)[2:]\n\t\tr=0\n\t\tfor i in range(len(q)):\n\t\t\tif p[i]!=q[i]:\n\t\t\t\tr=len(p)-i\n\t\t\t\tbreak\n\t\tprint(2**r-1)","output":"logn"},{"instruction":"n,m,a,b = map(int,input().split())\n\nif n%m==0:\n    print(0)\nelse:\n    k = n%m\n    print(min(k*b,(m-k)*a))","output":"linear"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n, k = map(int, input().split())\n\n    l = 1\n    r = n + 1\n\n    while r - l != 1:\n        m = l + r >> 1\n        candies = m * (m + 1) \/\/ 2\n        eat = n - m\n\n        if candies - eat <= k:\n            l = m\n        else:\n            r = m\n\n    print(n - l)\n\n    return 0\n\nmain()","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")","output":"np"},{"instruction":"n, = map(int,input().split())\narr = set(map(int,input().split()))\nprint(len(arr)-(0 in arr))","output":"linear"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\nn = Int()\na = array()\nC = Counter(a)\na = set(a)\n\nans = 0\n\nfor x in a:\n    ok = True\n\n    for i in range(65):\n\n        need = 2**i - x\n        if(need == x and C[need] > 1): ok = False\n        if(need != x and C[need] > 0): ok = False\n\n    ans += C[x]*ok\n\nprint(ans)","output":"nlogn"},{"instruction":"n,m = map(int, input().split())\na = []\nfor i in range(n):\n    s = input()\n    a.append(s)\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '.':\n            continue\n        if i >= 2 and j >= 2:\n            if a[i-2][j-2] == '\n                    and a[i-1][j] == '\n                continue\n        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '\n                and a[i][j-2] == '\n            continue\n        if i <= n-3 and j >= 2 and a[i][j-1] == '\n                and a[i+1][j-2] == '\n            continue\n        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '\n                and a[i+1][j+1] == '\n            continue\n        if i <= n-3 and j <= m-3 and a[i][j+1] == '\n                and a[i+1][j+2] == '\n            continue\n        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '\n                and a[i][j+2] == '\n            continue\n        if i >= 2 and j <= m-3 and a[i-2][j] == '\n                and a[i-1][j] == '\n            continue\n        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '\n                and a[i-1][j-1] == '\n            continue\n        print('NO')\n        exit()\nprint('YES')","output":"quadratic"},{"instruction":"from math import sin\nn,r=[int(i) for i in input().split()]\npi=3.14159265359\nprint(r\/((2*sin(pi*(1\/2-1\/n)))\/(sin(2*pi\/n))-1))","output":"constant"},{"instruction":"a= int(input())\ni=1\namount=a\nwhile amount>i*((10**i)-(10**(i-1))):\n    amount =amount - i*((10**i)-(10**(i-1)))\n    i=i+1\nx= amount\/\/i\ny=amount%i\n\nif y==0:\n    if i==1:\n        print(x%10)\n    else:\n        print((10**(i-1) + x -1)%10)\nelse:\n    if i==1:\n        print(x%10)\n    else:\n        print(((10**(i-1) + x)\/\/(10**(i-y)))%10)","output":"logn"},{"instruction":"n = int(input())\na = sorted(list(map(int, input().split())))\n\nwin = None\nfirst = True\n\nif n == 1:\n    win = a[0] % 2 == 1\nelif a[1] == 0:\n    win = False\n\nif n > 2:\n    for i in range(n-1):\n        if a[i] == a[i+1]:\n            if i > 0:\n                if a[i-1] == a[i]-1:\n                    win = False\n                    break\n            if not first:\n                win = False\n                break\n            first = False\n\nif win is None:\n    win = (sum(a) - (n*(n-1)\/\/2)) % 2 == 1\n\nif win:\n    print('sjfnb')\nelse:\n    print('cslnb')","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\ndef bit_count(x):\n    ans = 0\n    while x:\n        x &= x - 1\n        ans += 1\n    return ans\n\ndef main():\n    n = input().strip()\n    x = len(n)\n    k = int(input())\n    if n == '1':\n        print(int(k == 0))\n        exit()\n    if not k:\n        print(1)\n        exit()\n    mod = 10 ** 9 + 7\n    dp = [0] * (x + 1)\n    dp[1] = 1\n    for i in range(2, x + 1):\n        dp[i] = dp[bit_count(i)] + 1\n    dp1 = [[0] * (x + 1) for _ in range(x + 1)]\n\n    for i in range(x + 1):\n        dp1[i][0] = 1\n    for i in range(1, x + 1):\n        for j in range(1, i + 1):\n            dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod\n    ans = 0\n    cou = n.count('1')\n    for i in range(1, x + 1):\n        if dp[i] != k:\n            continue\n        se = i\n        for j in range(x):\n            if n[j] == '0':\n                continue\n            ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod\n            se -= 1\n            if se < 0:\n                break\n        if cou == i:\n            ans = (ans + 1) % mod\n    print(ans)\nmain()","output":"linear"},{"instruction":"n,k=map(int,input().split())\nl=[]\nfor i in range(n):\n   manan,surbhi=map(int,input().split())\n   l.append((manan,surbhi))\n\nl.sort(key=lambda x:(x[0], -x[1]),reverse=True)\nans=1\nps=l[k-1][0]\ntp=l[k-1][1]\nfor i in range(k,n):\n    if l[i][0]==ps and l[i][1]==tp:\n        ans+=1\n    else:\n        break\nfor i in range(k-2,-1,-1):\n    if l[i][0]==ps and l[i][1]==tp:\n        ans+=1\n    else:\n        break\n\nprint(ans)","output":"nlogn"},{"instruction":"n, m = [int(_) for _ in input().split()]\na = [0] * (n + 1)\nl, r = 1, n\n\nfor i in range(1, n + 1):\n    if m <= 1 << max((n - i - 1), 0):\n        a[l] = i\n        l += 1\n    else:\n        a[r] = i\n        r -= 1\n        m -= 1 << max((n - i - 1), 0)\n\na.pop(0)\nprint(\" \".join(map(str, a)))","output":"np"},{"instruction":"import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\ndef check(val, A, M):\n    s = set()\n    for row in A:\n        v = 0\n        for u in row:\n            v <<= 1\n            if u >= val:\n                v |= 1\n        s.add(v)\n\n    x = 1 << M\n    for u in s:\n        for v in range(x):\n            if v in s and u | v == x - 1:\n                return True\n\n    return False\n\ndef getAnswer(val, A, M):\n    vi = {}\n    for i, row in enumerate(A):\n        v = 0\n        for u in row:\n            v <<= 1\n            if u >= val:\n                v |= 1\n        vi[v] = i\n\n    x = 1 << M\n    for u in vi:\n        for v in range(x):\n            if v in vi and u | v == x - 1:\n                return vi[u], vi[v]\n\n    return 0, 0\n\ndef solve(N, M, A):\n    lo, hi = 0, max([max(row) for row in A])\n\n    while lo <= hi:\n        m = (lo + hi) \/\/ 2\n        if check(m, A, M):\n            lo = m + 1\n        else:\n            hi = m - 1\n\n    a, b = getAnswer(hi, A, M)\n    print('{} {}'.format(a + 1, b + 1))\n\nN, M = map(int, input().split())\nA = []\nfor i in range(N):\n    row = [int(x) for x in input().split()]\n    A.append(row)\n\nsolve(N, M, A)","output":"np"},{"instruction":"mod = 1000000007\neps = 10**-9\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, M, K = map(int, input().split())\n    P = [\"\"]\n    for i in range(N):\n        p = input().rstrip(\"\\n\")\n        P.append(p)\n    p2i = {p: i for i, p in enumerate(P)}\n    adj = [set() for _ in range(N+1)]\n    for i in range(M):\n        s, mt = input().split()\n        mt = int(mt)\n        ok = 0\n        for k in range(1 << K):\n            s_new = [\"_\"] * K\n            for j in range(K):\n                if k >> j & 1:\n                    s_new[j] = s[j]\n            s_new = \"\".join(s_new)\n            if s_new != P[mt]:\n                if s_new in p2i:\n                    adj[mt].add(p2i[s_new])\n            else:\n                ok = 1\n        if not ok:\n            print(\"NO\")\n            exit()\n    in_num = [0] * (N+1)\n    for v in range(1, N+1):\n        for u in adj[v]:\n            in_num[u] += 1\n    st = []\n    for v in range(1, N+1):\n        if in_num[v] == 0:\n            st.append(v)\n    ans = []\n    while st:\n        v = st.pop()\n        ans.append(v)\n        for u in adj[v]:\n            in_num[u] -= 1\n            if in_num[u] == 0:\n                st.append(u)\n    if len(ans) == N:\n        print(\"YES\")\n        print(*ans)\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n, l, r, x = map(int, input().split())\narr = list(map(int, input().split()))\nres = 0\nfor j in range(1, 2**n):\n    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]\n    s = sum(a)\n    res += (max(a) - min(a) >= x and s >= l and s <= r)\nprint(res)","output":"np"},{"instruction":"from sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nfor _ in range(1):\n    n,k=map(int, stdin.readline().split())\n    li = list(map(int, stdin.readline().split()))\n    dic=Counter(li)\n    li=list(set(li))\n    li.sort()\n    n=len(li)\n    for i in range(1,n):\n        for j in range(i-1,-1,-1):\n            if li[j]+k>=li[i] and dic[li[j]]!=0:\n                dic[li[j]]=0\n            else:\n                break\n    stdout.write(str(sum(dic.values()))+\"\\n\")","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import gcd, ceil\n\ndef pre(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    return pi\n\ndef prod(a):\n    ans = 1\n    for each in a:\n        ans = (ans * each)\n    return ans\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    r, g, b = map(int, input().split())\n\n    rr = list(map(int, input().split()))\n    gg = list(map(int, input().split()))\n    bb = list(map(int, input().split()))\n\n    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]\n    def f(a):return sorted(a,reverse=True)\n    rr,gg,bb=f(rr),f(gg),f(bb)\n    ans=0\n    r+=1\n    g+=1\n    b+=1\n    for i in range(r):\n        for j in range(g):\n            for k in range(b):\n                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])\n                except:pass\n                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])\n                except:pass\n                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])\n                except:pass\n                ans=max(ans,dp[i][j][k])\n    print(ans)","output":"cubic"},{"instruction":"def candy_eaten(n, k):\n\n    choco = 1\n    last = 1\n    eat = 0\n\n    i = n - 1\n    while i > 0:\n        if choco > k:\n            temp = choco - k\n            choco -= temp\n            eat += temp\n            i -= temp\n        else:\n            last += 1\n            choco += last\n            i -= 1\n    return eat\n\nif __name__ == '__main__':\n    n, k = map(int, input().strip().split())\n    print(candy_eaten(n, k))","output":"logn"},{"instruction":"n,k = map(int,input().split())\n\nfor puts in range(10**9):\n    candy = puts*(puts+1)\/\/2\n    if candy - (n-puts) == k:\n        print(n-puts)\n        exit(0)","output":"linear"},{"instruction":"from sys import stdin,stdout\nfrom math import gcd,sqrt,factorial,pi,inf\nfrom collections import deque,defaultdict\nfrom bisect import bisect,bisect_left\nfrom time import time\nfrom itertools import permutations as per\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nS=lambda:input().rstrip('\\r\\n')\nL=lambda:list(R())\nP=lambda x:stdout.write(str(x)+'\\n')\nlcm=lambda x,y:(x*y)\/\/gcd(x,y)\nnCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N\ninv=lambda x:pow(x,N-2,N)\nsm=lambda x:(x**2+x)\/\/2\nN=10**9+7\n\nn,m,k=R()\nA=[L() for i in range(n)]\nB=[L() for i in range(n-1)]\nif k&1:\n\tfor i in range(n):\n\t\tprint('-1 '*m)\n\texit()\nX=[[0]*m for i in range(n)]\nfor _ in range(k\/\/2):\n\tY=[[inf]*m for i in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif i:\n\t\t\t\tY[i][j]=X[i-1][j]+2*B[i-1][j]\n\t\t\tif i<n-1:\n\t\t\t\tY[i][j]=min(Y[i][j],X[i+1][j]+2*B[i][j])\n\t\t\tif j:\n\t\t\t\tY[i][j]=min(Y[i][j],X[i][j-1]+2*A[i][j-1])\n\t\t\tif j<m-1:\n\t\t\t\tY[i][j]=min(Y[i][j],X[i][j+1]+2*A[i][j])\n\tX=Y\nfor i in X:\n\tprint(*i)","output":"cubic"},{"instruction":"T = int(input())\nfor i in range(T):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tprint(min(len(a) - 2, max(a[-2] - 1, 0)))","output":"nlogn"},{"instruction":"from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef mapin():\n    return map(int, input().split())\n\na, b, c, n = mapin()\nd = a+b-c\n\nif(d > n-1 or c > a or c > b):\n    print(-1)\nelse:\n    print(n-d)","output":"constant"},{"instruction":"from math import factorial\n\nsend = input()\nreceive = input()\n\ncntP = send.count(\"+\")\ncntN = send.count(\"-\")\n\ncnt1 = receive.count(\"+\")\ncnt2 = receive.count(\"-\")\n\nmark = receive.count(\"?\")\n\ntotal = pow(2, mark)\n\nif cntP < cnt1 or cntN < cnt2:\n    valid = 0\nelse:\n    valid = factorial(mark) \/ factorial(mark - cntP + cnt1) \/ factorial(cntP - cnt1)\nprint(f\"{valid \/ total:0.12f}\")","output":"np"},{"instruction":"n, values, wrong = int(input()), [int(i) for i in input().split()], 0\nsorted_values = list(sorted(values))\nfor i in range(n):\n    if values[i] != sorted_values[i]:\n        wrong += 1\nif wrong > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nl,c=[],0\nfor _ in range(n):\n\tl.append(list(map(int,input().split())))\nl.sort(reverse=True)\na,x,y=l[k-1][0],k-1,k-1\nfor i in range(k-2,-1,-1):\n\tif l[i][0]==a:\n\t\tx=i\n\telse:\n\t\tbreak\nfor i in range(k,n):\n\tif l[i][0]==a:\n\t\ty=i\n\telse:\n\t\tbreak\nd=k-1-x\nd=y-d\nfor i in range(y,x-1,-1):\n\tif l[i]==l[d]:\n\t\tc+=1\nprint(c)","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nn,m,k=map(int,input().split())\nrow=[]\nfor _ in range(n):\n    row.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol=[[10**6+2]*(m+2)]\nfor _ in range(n-1):\n    col.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol.append([10**6+2]*(m+2))\nif  k%2:\n    dp=[[-1 for i in range(m)] for j in range(n)]\nelse:\n    k=k\/\/2\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1])\n    k-=1\n    while k:\n\n        k-=1\n        temp = [[0 for i in range(m)] for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ck=dp[i][j]*8\n                if i>=1:\n                    ck=min(ck,dp[i-1][j]+2*col[i][j+1])\n                if i<n-1:\n                    ck=min(ck,dp[i+1][j]+2*col[i+1][j+1])\n                if j>=1:\n                    ck=min(ck,dp[i][j-1]+2*row[i][j])\n                if j<m-1:\n                    ck=min(ck,dp[i][j+1]+2*row[i][j+1])\n                temp[i][j]=ck\n\n        dp=temp\n\nfor i in dp:\n    print(*i)","output":"cubic"},{"instruction":"def num_sq(x,y,x2,y2):\n\n    a = (abs(x2-x)+1)\n    b = (abs(y2-y)+1)\n    if a % 2 == 0 or b % 2 == 0:\n        return (a*b \/\/ 2, a*b \/\/ 2)\n    if (x+y) % 2 == 0:\n        num_b = a * b \/\/ 2\n        return (num_b, a * b - num_b)\n    num_w = a * b \/\/ 2\n    return (a * b - num_w, num_w)\ndef pt_in(p1, r1, r2):\n    return r1[0] <= p1[0] <= r2[0] and r1[1] <= p1[1] <= r2[1]\ndef intc(p1, p2, p3, p4):\n    x1 = max(p1[0], p3[0])\n    x2 = min(p2[0], p4[0])\n    y1 = max(p1[1], p3[1])\n    y2 = min(p2[1], p4[1])\n    if x1 <= x2 and y1 <= y2:\n        return ((x1, y1), (x2, y2))\n    return None\n\nnum_ = int(input())\nfor _ in range(num_):\n    n, m = map(int, input().split())\n    x1,y1,x2,y2 = map(int,input().split())\n    x3,y3,x4,y4 = map(int,input().split())\n    p1 = (x1,y1)\n    p2 = (x2,y2)\n    p3 = (x3,y3)\n    p4 = (x4,y4)\n    all_b, all_w = num_sq(1, 1, n, m)\n    tmp = intc(p1, p2, p3, p4)\n    if tmp:\n        intc_1, intc_2 = tmp\n        t_b, t_w = num_sq(intc_1[0], intc_1[1], intc_2[0], intc_2[1])\n    b,w = num_sq(x1,y1,x2,y2)\n    if tmp:\n        b -= t_b\n        w -= t_w\n    b2,w2 = num_sq(x3,y3,x4,y4)\n    if tmp:\n        b2 -= t_b\n        w2 -= t_w\n    w_tot, b_tot = (all_w + b - w2, all_b - b + w2)\n    if tmp:\n        w_tot -= t_w\n        b_tot += t_w\n    print(w_tot, b_tot)","output":"constant"},{"instruction":"n,m=map(int,input().split())\narr=[]\nfor i in range(m):\n  arr.append(list(map(int,input().split())))\nk=0;ans=str()\nfor i in range(n):\n  ans+=str(k^1)\n  k=k^1\nprint(ans)","output":"linear"},{"instruction":"for x in range(int(input())):\n\ta,b = map(int,input().split())\n\tif a > b or a == b:c,d = a,b\n\telse:c,d = b,a\n\te = [0]\n\tdef fun(c,d):\n\t\te[0] += c \/\/ d\n\t\tf = d\n\t\td = c % d\n\t\tc = f\n\t\tif f > 0 and d > 0:\n\t\t\tfun(c,d)\n\tfun(c,d)\n\tprint(e[0])","output":"constant"},{"instruction":"from sys import stdin,stdout\ninput=stdin.readline\nt=1\nfor _ in range(t):\n    n=int(input())\n    x=input()\n    c=0\n    ans=0\n    for i in x:\n        if i=='x':\n            c+=1\n        else:\n            ans+=max(0,c-2)\n            c = 0\n    ans+=max(0,c-2)\n    print(ans)","output":"linear"},{"instruction":"from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) \/\/ factorial(m) \/\/ factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)\/\/2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)","output":"cubic"},{"instruction":"n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\nnewarr=[0]\n\nfor num in arr:\n  newarr+=[newarr[-1]^num]\ndic={}\nfor num in newarr:\n  x=(min(num,2**k-1-num),max(num,2**k-1-num))\n  if x in dic:\n    dic[x]+=1\n  else:\n    dic[x]=1\nans=0\nfor elem in dic:\n  m=dic[elem]\n  half=m\/\/2\n  ans+=half*(half-1)\/2\n  half=m-half\n  ans+=half*(half-1)\/2\nans=n*(n+1)\/2-ans\nprint(int(ans))","output":"linear"},{"instruction":"import os, sys, heapq as h, time\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nMOD = 10**9 + 7\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\ndef solve():\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    return min(dp)+1\n\nfor _ in range(getInt()):\n    print(solve())","output":"cubic"},{"instruction":"from sys import stdin, stdout\n\ndef solve(s1, s2, next):\n\n    dp = [[INF for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n    dp[0][0] = 0\n    for i in range(len(s1)+1):\n        for j in range(len(s2)+1):\n            if dp[i][j] == INF:\n                continue\n\n            if i < len(s1) and dp[i][j] < len(next) and next[dp[i][j]][ord(s1[i]) - ord('a')] < INF:\n                dp[i+1][j] = min(dp[i+1][j], next[dp[i][j]][ord(s1[i]) - ord('a')] + 1)\n            if j < len(s2) and dp[i][j] < len(next) and next[dp[i][j]][ord(s2[j]) - ord('a')] < INF:\n                dp[i][j+1] = min(dp[i][j+1], next[dp[i][j]][ord(s2[j]) - ord('a')] + 1)\n\n    return dp[len(s1)][len(s2)]\n\nINF = 1e20\nT = int(stdin.readline())\nfor _ in range(T):\n    s = stdin.readline().strip()\n    rs = stdin.readline().strip()\n    next = [[INF for _ in range(26)] for _ in range(len(s))]\n\n    for i in range(len(s)-1, -1, -1):\n        if i < len(s)-1:\n            for j in range(26):\n                next[i][j] = next[i+1][j]\n        next[i][ord(s[i]) - ord('a')] = i\n\n    found = False\n\n    if len(rs) == 1:\n        if rs in s:\n            found = True\n    else:\n        for p in range(1, len(rs)):\n            s1 = rs[:p]\n            s2 = rs[p:]\n\n            if solve(s1, s2, next) < INF:\n                found = True\n                break\n\n    if found:\n        stdout.write('YES\\n')\n    else:\n        stdout.write('NO\\n')","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = 0\nfor i in range(0, 2*n, 2):\n    if a[i] == a[i+1]:\n        continue\n\n    c = a[i]\n    j = i + 2\n    while c != a[j]:\n        j += 1\n\n    MIN = i+1\n    while j > MIN:\n        a[j], a[j-1] = a[j-1], a[j]\n        j -= 1\n        swaps += 1\n\nprint(swaps)","output":"quadratic"},{"instruction":"_, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nc = list(sorted(zip(a, b, range(len(b)))))\nd = [0] * len(b)\n\nif k == 0:\n    print(' '.join(map(str, b)))\nelse:\n    best = [0] * k\n    for pwr, cnt, index in c:\n        d[index] = sum(best) + cnt\n\n        if cnt > best[0]:\n            for i in range(len(best)):\n                if cnt <= best[i]:\n                    best.insert(i, cnt)\n                    best = best[1:]\n                    break\n            else:\n                best = best[1:] + [cnt]\n\n    print(' '.join(map(str, d)))","output":"nlogn"},{"instruction":"a = (input().split())\na.sort()\n\nif(a[0] == a[1] == a[2]):\n    print(0)\n    exit()\nelif(a[0] == a[1] or a[1] == a[2]):\n    print(1)\n    exit()\n\na1 = []\nfor i in range(3):\n    a1.append([int(a[i][0]), a[i][1]])\na1.sort()\n\nif(a1[1][1] == a1[2][1] == a1[0][1]):\n    if(a1[0][0] == a1[1][0] - 1 and a1[0][0] == a1[2][0] - 2):\n        print(0)\n        exit()\n    found = False\n    for i in range(3):\n        for j in range(3):\n            if(abs(a1[i][0] - a1[j][0]) == 1 or abs(a1[i][0] - a1[j][0]) == 2 ):\n                print(1)\n                exit()\n    print(2)\n    exit()\nfor i in range(3):\n    for j in range(i + 1, 3):\n        if(a1[i][1] == a1[j][1]):\n            if(a1[i][0] == a1[j][0] - 1 or a1[i][0] == a1[j][0] - 2):\n                print(1)\n            else:\n                print(2)\n            exit()\nprint(2)","output":"nlogn"},{"instruction":"def solution(n, k):\n    ret = [['.' for _ in range(n)] for _ in range(4)]\n    if 1 == k & 1:\n        ret[1][n >> 1] = '\n        for i in range(1, n >> 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[1][i] = '\n            ret[1][n - 1 - i] = '\n        for i in range(1, n >> 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[2][i] = '\n            ret[2][n - 1 - i] = '\n    else:\n        for i in range(1, n - 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[1][i] = '\n            ret[2][i] = '\n\n    print('YES')\n    for i in range(4):\n        print(''.join(ret[i]))\n\nsolution(*map(int, input().split()))","output":"linear"},{"instruction":"def func(k, a):\n    if len(a) == 1:\n        return 1\n    if k == 1:\n        return len(a)\n    s = set(a)\n    for x in sorted(a):\n        if x in s and k * x in s:\n            s.remove(k * x)\n    return len(s)\n\ndef read_ints():\n    return [int(x) for x in input().split(' ')]\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    assert n == len(a)\n    print(func(k, a))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"buck = [[0, 0] for i in range(2201)]\nm = int(input())\nfor i in range(m):\n    a = int(input())\n    ok = True\n    br = 0\n    for j in range(2200, -1, -1):\n        if a & (1 << j):\n            if(buck[j][0]):\n                a  ^= buck[j][0]\n                br ^= buck[j][1]\n            else:\n                ok = False\n                buck[j][0] = a\n                buck[j][1] = br | (1 << i)\n                break\n    if not ok:\n        print(\"0\")\n    else:\n        lst = []\n        for j in range(2201):\n            if br & (1 << j):\n                lst.append(j)\n        print(len(lst), end = ' ')\n        for j in lst:\n            print(j, end = ' ')\n        print('\\n', end='')","output":"np"},{"instruction":"n,m = [int(i) for i in input().split()]\nb=[]\na=[]\nfor i in range(n):\n    b.append([i for i in input()])\n    a.append([0 for i in range(m)])\n\ndef check(e,r,q):\n    if e>=0 and r>=0 and e+2<n and r+2<m:\n        if b[e][r]=='\n            a[e][r]==1\n            a[e+1][r]==1\n            a[e+2][r]==1\n            a[e+2][r+1]==1\n            a[e+2][r+2]==1\n            a[e+1][r+2]==1\n            a[e][r+2]==1\n            a[e][r+1]==1\n            return True\n    if q ==1:\n        return False\n    return check(e,r-1,1) or check(e,r-2,1) or check(e-1,r-2,1) or check(e-2,r-2,1) or check(e-2,r-1,1) or check(e-2,r,1) or check(e-1,r,1)\nfor i in range(n):\n    for j in range(m):\n        if b[i][j]=='\n            if (not check(i,j,0)) and a[i][j]==0:\n                print(\"NO\")\n                exit()\nprint(\"YES\")","output":"quadratic"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n\n            effect[j][i] = index\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"n=int(input())\nprint(int(n\/2)+1)","output":"constant"},{"instruction":"a=str(input())\nb=str(input())\ncount=0\nal=len(a)\nbl=len(b)\ns=b[:bl-al+1].count('1')\nfor i in range(al-1):\n    if a[i]=='0':\n        count+=s\n    else:\n        count+=bl-al+1-s\n    s+=int(b[bl-al+i+1])-int(b[i])\n\nif a[-1]=='0':\n    count+=s\nelse:\n    count+=bl-al+1-s\nprint(count)","output":"linear"},{"instruction":"n = int(input())\nA = [int(a) for a in input().split()]\n\nprefix = [0] * n\nprefix[0] = A[0]\nfor i in range(1, n):\n    prefix[i] = prefix[i - 1] + A[i]\n\ntarget = (sum(A) + 1) \/\/ 2\n\nfor i in range(n):\n    if prefix[i] < target:\n        continue\n    else:\n        print(i + 1)\n        break","output":"linear"},{"instruction":"from sys import stdin\nreadline = stdin.readline\ndef readInt():\n    return int(readline())\ndef readInts():\n    return list(map(int,readline().split()))\n\nU, D, L, R = 0, 1, 2, 3\nDIR = [(-1,0), (1,0), (0,-1), (0,1)]\n\nn, m, k = readInts()\n\nmoves = [[[-1 for _ in range(4)] for _ in range(m)] for _ in range(n)]\n\nright = []\ndown = []\n\nfor i in range(n):\n    row = readInts()\n    right.append(row)\n\nfor i in range(n-1):\n    row = readInts()\n    down.append(row)\n\nif k % 2 == 1:\n    for _ in range(n):\n        for _ in range(m):\n            print(-1, end=\" \")\n        print()\n    exit()\n\nk \/\/= 2\n\ndp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]\n\nfor l in range(k):\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][l+1] = float(\"inf\")\n            if i > 0:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])\n            if j > 0:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])\n            if i < n - 1:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])\n            if j < m - 1:\n                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])\n\nfor i in range(n):\n    for j in range(m):\n        print(2*dp[i][j][k], end=\" \")\n    print()","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nDP=[[-1]*(n+1) for i in range(n+1)]\nfor i in range(n):\n    DP[i][i]=A[i]\n\nfor mid in range(1,n):\n    for i in range(n):\n        j=i+mid\n        if j==n:\n            break\n        for k in range(i,j+1):\n            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:\n                DP[i][j]=DP[i][k]+1\n\nANS=[2000]*(n+1)\nANS.append(0)\nfor i in range(n):\n    ANS[i]=min(ANS[i],ANS[i-1]+1)\n    for j in range(i,n):\n        if DP[i][j]!=-1:\n            ANS[j]=min(ANS[j],ANS[i-1]+1)\n\nprint(ANS[n-1])","output":"cubic"},{"instruction":"import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef output(*args):\n    sys.stdout.buffer.write(\n        ('\\n'.join(map(str, args)) + '\\n').encode('utf-8')\n    )\n\ndef main():\n    R, G, B = map(int, input().split())\n    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n\n    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]\n\n    for ri in range(R + 1):\n        for gi in range(G + 1):\n            for bi in range(B + 1):\n                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])\n                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])\n                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])\n\n    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))\n    print(int(ans + 1e-6))\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"if __name__ == \"__main__\":\n\tn, k = map(int, input().split())\n\tais = []\n\tfor i in range(n):\n\t\tais.append(list(map(int, input().split())))\n\tais.sort(key = lambda x: (-x[0], x[1]))\n\tprint(ais.count(ais[k-1]))","output":"nlogn"},{"instruction":"from math import factorial\nn, mod = map(int, input().split())\ndef binom(n, m):    return factorial(n) \/\/ factorial(m) \/\/ factorial(n-m)\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod\n    return ans\ndef f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod\nans = 0\nfor i in range((n+1)\/\/2):ans = (ans + f(n-i, i+1));ans %= mod\nprint(ans)","output":"cubic"},{"instruction":"R = lambda: map(int, input().split())\nn, s = R()\nl, r = s, 10**18 + 7\n\ndef digit(x):\n    res = 0\n    while x:\n        res += x % 10\n        x \/\/= 10\n    return res\n\nwhile l < r:\n    m = (l + r) \/\/ 2\n    if m - digit(m) < s:\n        l = m + 1\n    else:\n        r = m\nprint(max(0, n - l + 1))","output":"logn"},{"instruction":"def c(a, b, l, ans, pro):\n    if l != 0:\n        n = a[:]\n        mx = None\n        pro1 = pro\n        prosh = set()\n        for i in range(l):\n            pro = pro1\n            if a[i] == prosh:\n                continue\n            elif (a[i] <= b[0] and pro):\n                n.pop(i)\n                prosh = a[i]\n                if pro == True:\n                    if a[i] < b[0]:\n                        pro = False\n                m = c(n, b[1:], l-1, ans+str(a[i]), pro)\n                n = a[:]\n                if m != None:\n                    if mx == None:\n                        mx = int(m)\n                    elif mx < int(m):\n                        mx = int(m)\n            elif not(pro):\n                a.sort(reverse = True)\n                a = list(map(str, a))\n                return ans +''.join(a)\n            else:\n                break\n        return mx\n    else:\n        return ans\na = input()\nb = input()\nl = len(a)\nif len(a) != len(b):\n    a = list(a)\n    a.sort()\n    print(''.join(a[::-1]))\nelse:\n    a = list(map(int, a))\n    b = list(map(int, b))\n    a.sort()\n    n = a[:]\n    mx = 0\n    prosh = -1\n    for i in range(l):\n        if a[i] == prosh:\n            continue\n        elif a[i] != 0 and a[i] <= b[0]:\n            n.pop(i)\n            prosh = a[i]\n            pro = False\n            if a[i] == b[0]:\n                pro = True\n            m = c(n, b[1:], l-1, str(a[i]), pro)\n            n = a[:]\n            if m != None:\n                if mx < int(m):\n                    mx = int(m)\n        elif a[i] > b[0]:\n            break\n    print(mx)","output":"cubic"},{"instruction":"k = int(input())\nprev=0\nnext=0\nNumofDigits=0\n\nwhile(True):\n    prev = next\n    next = next+(9*(10**(NumofDigits-1))*NumofDigits)\n    if(k>= prev and k<=next):\n        break\n    NumofDigits=NumofDigits+1\nif(NumofDigits==1):\n    print(k)\nelse:\n    result = (10**(NumofDigits-1))+int((k-(prev+1))\/NumofDigits)\n    i=0\n    while(True):\n        if (k-int(prev+1))%NumofDigits == i:\n            break\n        i=i+1\n    result = str(result)\n    print(result[i])","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [0] * n\nfor i in a:\n    b[i - 1] += 1\nb.sort()\nprint(b[0])","output":"quadratic"},{"instruction":"n = int(input())\nlst = list(map(int,input().split()))\nlst = set(lst)\nlst = list(lst)\nlst.remove(min(lst))\nif(len(lst)==0):\n    print(\"NO\")\nelse:\n    print(min(lst))","output":"nlogn"},{"instruction":"s = input()\nt = s.count('1')\ns = s.replace('1', '')\ni = s.find('2')\nif i == -1:\n    print(s + '1'*t)\nelse:\n    print(s[:i] + '1'*t + s[i:])","output":"linear"},{"instruction":"import math\n\ndef valid(n, k, c1, c2):\n    if c1 > n:\n        return c2\n    elif c2 > n:\n        return c1\n    ans_one = ((n - c1) * (n - c1 + 1) \/\/ 2) - c1\n    if ans_one == k:\n        return c1\n    return c2\n\ndef f(n, k):\n    b2 = (2 * n + 3)\n    delta = int(math.sqrt(8 * n + 8 * k + 9))\n    return valid(n, k, (b2 + delta) \/\/ 2, (b2 - delta) \/\/ 2)\n\nn, k = map(int, input().strip().split(' '))\nprint(f(n, k))","output":"logn"},{"instruction":"def findSet(u, parent):\n    if parent[u] != u:\n        parent[u] = findSet(parent[u], parent)\n    return parent[u]\n\ndef unionSet(u, v, parent):\n    up = findSet(u, parent)\n    vp = findSet(v, parent)\n    parent[up] = vp\n\nif __name__ == '__main__':\n    n, a, b = map(int, input().split())\n    lst = list(map(int, input().split()))\n    parent = [i for i in range(n + 2)]\n    temp = {lst[i]: i for i in range(n)}\n    for i in range(n):\n        if a - lst[i] in temp:\n            unionSet(i, temp[a - lst[i]], parent)\n        else:\n            unionSet(i, n, parent)\n        if b - lst[i] in temp:\n            unionSet(i, temp[b - lst[i]], parent)\n        else:\n            unionSet(i, n + 1, parent)\n\n    pa = findSet(n, parent)\n    pb = findSet(n + 1, parent)\n    if pa == pb:\n        print('NO')\n    else:\n        print('YES')\n        lst = [0 if findSet(i, parent) == pb else 1 for i in range(n)]\n        print(*lst)","output":"linear"},{"instruction":"n = int(input())\nxs = [int(x) for x in input().split()]\nprefix = [-1 for i in range(n)]\nsuffix = [-1 for i in range(n)]\nprefix[0] = 0\npre_has_neg = [False for i in range(n)]\nsuffix[-1] = 0\nsuf_has_neg = [False for i in range(n)]\nfor i in range(n):\n\tif i == 0:\n\t\tprefix[i] = xs[i]\n\telse:\n\t\tprefix[i] = prefix[i-1] + xs[i]\nfor i in reversed(range(n)):\n\tif i == n-1:\n\t\tsuffix[i] = xs[i]\n\telse:\n\t\tsuffix[i] = suffix[i+1] + xs[i]\nfor i in range(n):\n\tif i == 0:\n\t\tpre_has_neg[i] = xs[i] <= 0\n\telse:\n\t\tpre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0\nfor i in reversed(range(n)):\n\tif i == n-1:\n\t\tsuf_has_neg[i] = xs[i] <= 0\n\telse:\n\t\tsuf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0\n\nprebignum = [None for i in range(n)]\nsufbignum = [None for i in range(n)]\nfor i in range(n):\n\tif i == 0:\n\t\tprebignum[i] = xs[i]\n\telse:\n\t\tprebignum[i] = min(prebignum[i-1], xs[i])\nfor i in reversed(range(n)):\n\tif i == n-1:\n\t\tsufbignum[i] = xs[i]\n\telse:\n\t\tsufbignum[i] = min(sufbignum[i+1], xs[i])\n\nneg_pre = [100000 for i in range(n)]\nneg_suf = [100000 for i in range(n)]\n\nfor i in range(n):\n\tif i == 0:\n\t\tneg_pre[i] = min(xs[i], -xs[i])\n\telse:\n\t\tneg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i])\n\nfor i in reversed(range(n)):\n\tif i == n-1:\n\t\tneg_suf[i] = min(xs[i], -xs[i])\n\telse:\n\t\tneg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i])\n\nans = -100000000000000000\nfor i in range(n):\n\n\ttans = xs[i]\n\tif i == 0:\n\t\tpass\n\telif pre_has_neg[i-1]:\n\t\ttans -= neg_pre[i-1]\n\telse:\n\t\ttans += prefix[i-1]\n\t\ttans -= prebignum[i-1]*2\n\n\tif i == n-1:\n\t\tpass\n\telif suf_has_neg[i+1]:\n\t\ttans -= neg_suf[i+1]\n\telse:\n\t\ttans += suffix[i+1]\n\t\ttans -= sufbignum[i+1]*2\n\n\tans = max(ans, tans)\n\nprint(ans)","output":"linear"},{"instruction":"R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\nDP = [0] * ((R+1) * (G+1) * (B+1))\n\ndef idx(r, g, b):\n  return r * (G+1) * (B+1) + g * (B+1) + b\n\nfor r in range(R+1):\n  for g in range(G+1):\n    for b in range(B+1):\n      best = 0\n      if r:\n        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n      if g and b:\n        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n      DP[idx(r, g, b)] = best\nprint(max(DP))","output":"cubic"},{"instruction":"xs,ys = map(float,input().split())\n\nn = int(input())\n\ndist = [[0]*(n+1) for i in range(n+1)]\ndist2 = [[0]*(n) for i in range(n)]\n\nobjects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]]\n\nfor i in range(n+1):\n    for j in range(n+1):\n        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2\n\nfor i in range(n):\n    for j in range(n):\n        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]\n\ndp = [1e6]*(1<<n)\nvis = set([0])\ndp[0] = 0\n\nfor i in range((1<<n)-1):\n    if i in vis:\n\n        for j in range(n):\n            if i&(1<<j) == 0:\n\n                newi = i + (1 << j)\n                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])\n                vis.add(newi)\n\n                for k in range(j+1,n):\n\n                    if i&(1<<k) == 0:\n                        newi |= 1<<k\n                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])\n                        vis.add(newi)\n                        newi ^= 1<<k\n\n                break\n\ncurr = (1<<n) - 1\npath = [0]\nwhile curr:\n    for i in range(n):\n        if curr & (1<<i):\n\n            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:\n                path.extend([i+1,0])\n                curr ^= (1<<i)\n\n            for j in range(i+1,n):\n                if curr & (1<<j):\n                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:\n                        path.extend([j+1,i+1,0])\n                        curr ^= (1<<i) + (1<<j)\n\nprint(int(dp[(1<<n)-1]))\nprint(*path[::-1])","output":"np"},{"instruction":"print(int(input())\/\/2 + 1)","output":"constant"},{"instruction":"class Solution:\n    def countSubstrings(self, s: str) -> int:\n        n, res = len(s), 0\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    res += 1\n\n        return res","output":"quadratic"},{"instruction":"n, l, r, x = list(map(int, input().split(\" \")))\nc = sorted(list(map(int, input().split(\" \"))))\nways = 0\n\nfor i in range(0, 2 ** n):\n    temp = 0\n    m = 10 ** 9 + 1\n    M = -1\n    for j in range(0, n):\n        if i & 1 << j:\n            temp += c[j]\n            m = min(m, c[j])\n            M = max(M, c[j])\n    if temp >= l and temp <= r and (M - m) >= x:\n        ways += 1\n\nprint(ways)","output":"np"},{"instruction":"from sys import  stdin\ninput=stdin.readline\nfrom  collections import defaultdict\ndef num(s):\n    l,r=0,0\n    for i in s:\n        if l==0 and i==\")\":\n            r+=1\n        elif i==\"(\":\n            l+=1\n        elif l and i==\")\":\n            l-=1\n    return (l,r)\n\ndef f(mp,cnt):\n    ans=0\n\n    for l in cnt:\n\n        if l.count(0)<1:\n            continue\n        if l!=(0,0) and l==l[::-1]:\n            continue\n\n        t=mp[l[::-1]]\n        t2=mp[l[::-1]]\n        ans+=t\n        if t and l!=l[::-1]:\n            mp[l]-=1\n    return ans\n\ncnt=[]\nmp=defaultdict(int)\nfor i in range(int(input())):\n    s=input()\n    l=num(s)\n\n    cnt.append(l)\n    mp[l]+=1\nprint(f(mp,cnt))","output":"linear"},{"instruction":"import math\nans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]\nn = int(input())\n\nif (n % 2 == 1):\n\tprint(ans[n \/\/ 2] * math.factorial(n) % 1000000007)\nelse:\n\tprint(0)","output":"np"},{"instruction":"n=int(input())\na=[*map(int,input().split())]\nb=[0]*n\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))","output":"linear"},{"instruction":"def c(a, b, l, ans, pro):\n    if l != 0:\n        n = a[:]\n        mx = None\n        pro1 = pro\n        prosh = set()\n        for i in range(l):\n            pro = pro1\n            if a[i] == prosh:\n                continue\n            elif (a[i] <= b[0] and pro):\n                n.pop(i)\n                prosh = a[i]\n                if pro == True:\n                    if a[i] < b[0]:\n                        pro = False\n                m = c(n, b[1:], l-1, ans+str(a[i]), pro)\n                n = a[:]\n                if m != None:\n                    if mx == None:\n                        mx = int(m)\n                    elif mx < int(m):\n                        mx = int(m)\n            elif not(pro):\n                a.sort(reverse = True)\n                a = list(map(str, a))\n                return ans +''.join(a)\n            else:\n                break\n        return mx\n    else:\n        return ans\na = input()\nb = input()\nl = len(a)\nif len(a) != len(b):\n    a = list(a)\n    a.sort()\n    print(''.join(a[::-1]))\nelse:\n    a = list(map(int, a))\n    b = list(map(int, b))\n    a.sort()\n    n = a[:]\n    mx = 0\n    prosh = -1\n    for i in range(l):\n        if a[i] == prosh:\n            continue\n        elif a[i] != 0 and a[i] <= b[0]:\n            n.pop(i)\n            prosh = a[i]\n            pro = False\n            if a[i] == b[0]:\n                pro = True\n            m = c(n, b[1:], l-1, str(a[i]), pro)\n            n = a[:]\n            if m != None:\n                if mx < int(m):\n                    mx = int(m)\n        elif a[i] > b[0]:\n            break\n    print(mx)","output":"cubic"},{"instruction":"a, b = map(int, input().split())\nc = input()\nsorted(c)\nsumma = 0\ncount = 0\nj = -2\ni = 0\nabc = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and count < b:\n    if abc[i] in c and i-2 >= j:\n        summa += i+1\n        count += 1\n        j = i\n    i += 1\nif count < b:\n    print(-1)\nelse:\n    print(summa)","output":"linear"},{"instruction":"n,k = map(int,input().split())\nif k>n+n-1:\n    print(0)\n    exit(0)\nif k-1<=n:\n    ml = 1\n    mr = k-1\n    print((mr-ml+1)\/\/2)\nelse:\n    mr = n\n    ml = k-n\n    print((mr-ml+1)\/\/2)","output":"constant"},{"instruction":"MOD = 998244353\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n\n    p, sp, s, ss = 0, 0, 0, 0\n    for x in a:\n        ss = (2 * ss + s) % MOD\n        s = (s + x) % MOD\n        p = (ss + sp + s) % MOD\n        sp = (sp + p) % MOD\n    print(p)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict\nn,m=map(int,sys.stdin.readline().split())\n\nup,down=1,n\ncount=0\nwhile up<=down:\n    left,right=1,m\n\n    while left<=m and count<n*m:\n\n        if count<n*m:\n            sys.stdout.write((str(up)+\" \"+str(left)+\"\\n\"))\n        count+=1\n        left+=1\n\n        if count<n*m:\n            sys.stdout.write((str(down)+\" \"+str(right)+\"\\n\"))\n        count+=1\n\n        right-=1\n    up+=1\n    down-=1","output":"quadratic"},{"instruction":"def comp(arr):\n    for i in range(len(arr)-1):\n        for j in range(0, len(arr)-i-1):\n            if(arr[j] in arr[j+1]):\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n    return arr[::-1]\n\nt = int(input())\nans = 1\narr = []\nfor j in range(t):\n    arr.append(input())\n\narr = comp(arr);\n\nfor j in range(0,t-1):\n    if arr[j] not in arr[j+1]:\n        ans = 0\n        break;\n\nif(ans == 0):\n    print(\"NO\")\n\nelse:\n    print(\"YES\")\n    for j in arr:\n        print(j)","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left,bisect\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nn=int(input())\nl=list(map(int,input().split()))\nx=dc(int)\ny=dc(int)\nz=dc(int)\np=dc(int)\nq=dc(int)\nr=dc(int)\nx[l[-1]]+=1\ny[l[-1]]+=1\nz[l[-1]]+=1\nfor i in range(n-2,-1,-1):\n    p[i]=x[l[i]]\n    q[i]=y[l[i]+1]\n    r[i]=z[l[i]-1]\n    x[l[i]]+=1\n    y[l[i]]+=1\n    z[l[i]]+=1\n\nx=[0]*n\nfor i in range(n-2,-1,-1):\n    x[i]=l[i+1]+x[i+1]\n\ns=0\nfor i in range(n-2,-1,-1):\n\n    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))\n    d=n-i-1-p[i]-q[i]-r[i]\n    e=c-l[i]*d\n\n    s+=e\nprint(s)","output":"nlogn"},{"instruction":"import math\na=input()\nb=input()\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nc=a.count('+')-a.count('-')\nd=b.count('+')-b.count('-')\ne=c-d\nf=b.count('?')\nif x==0 and y==0:\n    print(1)\nelif f==0 and (x!=0 or y!=0):\n    print(0)\nelif x!=0 and y==0:\n    print(1\/2**f)\nelif y!=0 and x==0:\n    print(1\/2**f)\nelif abs(e)>f:\n    print(0)\nelse:\n    print(math.factorial(f)\/(math.factorial(y)*math.factorial(x)*2**f))","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    mod =  10**9 + 7\n    twopow = [1]*(10**5+69)\n    for i in range(1, 10**5+69):\n        twopow[i] = (twopow[i-1] * 2) % mod\n    count = [0]*100069\n    for i in a:\n        count[i] += 1\n    multiples = [0]*100069\n    for i in range(1, 10**5+1):\n        for j in range(i, 10**5+1, i):\n            multiples[i] += count[j]\n    gcd_of = [0]*100069\n    for i in range(10**5, 0, -1):\n        gcd_of[i] = (twopow[multiples[i]] - 1) % mod\n        for j in range(2*i, 10**5+1, i):\n            gcd_of[i] -= gcd_of[j]\n    print(gcd_of[1] % mod)","output":"np"},{"instruction":"n = int(input())\nprobs = list()\nfor i in range(n): probs.append(list(map(float, input().split())))\ndp = [list([0 for i in range(1<<n)]) for i in range(n)]\ndp[0][(1<<n)-1] = 1\nak = [list() for i in range(n+1)]\nfor i in range(1<<n):\n    ak[bin(i).count(\"1\")].append(i)\nfor k in range(1, n):\n    for ele in ak[n-k+1]:\n        for j in range(n):\n            if (ele&(1<<j)):\n                for w in range(n):\n                    if (ele&(1<<w)) and j != w:\n                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])\/(((n-k+1)*(n-k))\/2)\nfor i in range(n):\n    print(dp[n-1][(1<<i)], end = \" \")\nprint()","output":"np"},{"instruction":"def if_spruce(n,l,s):\n    d=[0]*(n+1)\n    for i in range(1,n+1):\n        if i not in s:\n            d[l[i]]+=1\n    for i in range(1,n+1):\n        if i in s and d[i]<3:\n            return \"No\"\n    return \"Yes\"\n\nn=int(input())\nl,a=[0]*2,0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\ns=set(l)\nprint(if_spruce(n,l,s))","output":"linear"},{"instruction":"n, m = map(int, input().split())\nprint(m \/\/ n + (1 if m % n else 0))","output":"constant"},{"instruction":"import sys\ndef ask(x,y,rev):\n\tif (rev==0):\n\t\tprint(\"? %d %d\"%(x,y))\n\telse:\n\t\tprint(\"? %d %d\"%(y,x))\n\tsys.stdout.flush()\n\tif (rev==1):\n\t\treturn -int(input())\n\telse:\n\t\treturn int(input())\n\ncomp=ask(0,0,0)\nnowa=0\nnowb=0\nrev=0\nfor i in range(29,-1,-1):\n\tif (comp<0):\n\t\trev^=1\n\t\tnowa,nowb=nowb,nowa\n\t\tcomp=-comp\n\tif comp>=0:\n\t\tcomp=ask(nowa|(1<<i),nowb|(1<<i),rev)\n\t\tif (comp<0):\n\t\t\tnowa|=1<<i\n\t\t\tcomp=ask(nowa,nowb,rev)\n\t\telse:\n\t\t\ttmp=ask(nowa|(1<<i),nowb,rev)\n\t\t\tif (tmp<0):\n\t\t\t\tnowa|=1<<i\n\t\t\t\tnowb|=1<<i\nif (rev==1):\n\tnowa,nowb=nowb,nowa\nprint(\"! %d %d\"%(nowa,nowb))","output":"logn"},{"instruction":"R = lambda: map(int, input().split())\nn, m, k = R()\ncls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)]\ndp = [[n * m] * (k + 1) for i in range(n + 1)]\ndp.append([0] * (k + 1))\nfor i in range(n):\n    row = cls[i]\n    c2l = [m + 1] * (m + 1)\n    c2l[0] = row[-1] - row[0] + 1 if row else 0\n    c2l[len(row)] = 0\n    for r in range(len(row)):\n        for l in range(r + 1):\n            c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1)\n    for j in range(k + 1):\n        for c, l in enumerate(c2l):\n            if j + c <= k and l < m + 1:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l)\nprint(min(dp[n - 1]))","output":"cubic"},{"instruction":"from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\nc = list(map(int, input().split()))\nf = list(map(int, input().split()))\nh = [0] + list(map(int, input().split()))\ncnt1 = defaultdict(lambda : 0)\nfor i in c:\n    cnt1[i] += 1\ncnt2 = defaultdict(lambda : 0)\nfor i in f:\n    cnt2[i] += 1\nans = 0\nfor i in cnt2:\n    c1, c2 = cnt1[i], cnt2[i]\n    dp0 = [0]\n    l = 1\n    for _ in range(c2):\n        dp = [0] * (l + k)\n        for i in range(l):\n            dp0i = dp0[i]\n            for j in range(k + 1):\n                dp[i + j] = max(dp[i + j], dp0i + h[j])\n        l += k\n        dp0 = dp\n    ans += dp[min(c1, k * c2)]\nprint(ans)","output":"cubic"},{"instruction":"n,k=[int(i) for i in raw_input().split()]\n\nM=10**9+7\ndef power(x,y):\n    if y==0:\n      return 1\n    z=(power(x,y\/2)**2)%M\n    z=(z*x)%M if y%2 else z\n    return z%M\n\nz=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0\nprint(z)","output":"logn"},{"instruction":"from math import *\nfrom fractions import *\ndef li():\n  return list(map(int, input().split(\" \")))\nn,k = li()\nif k == 1:\n  print(\"1\" + \"0\"*(n-1))\nelse:\n  a = (n-k)\/\/2\n  p = \"1\" + \"0\"*a\n  ans = p * (n\/\/(a+1)) + p[:(n%(a+1))]\n  print(ans)","output":"constant"},{"instruction":"q = 1\nfor t in range(q):\n\tk = int(input())\n\tm = 0\n\tp = 9\n\twhile k > p:\n\t\tm = m+1\n\t\tl = p\n\t\tp = p+ 9*(10**m)*(m+1)\n\tif m == 0:\n\t\tprint(k)\n\t\tcontinue\n\tans = int(\"9\"*m)+ (k-l)\/\/(m+1)\n\tif (k-l)%(m+1) == 0:\n\t\tprint(str(ans)[-1])\n\telse:\n\t\tans = ans+1\n\t\tprint(str(ans)[((k-l)%(m+1))-1])","output":"logn"},{"instruction":"cases = int(input())\nwhile cases:\n    cases -= 1\n    a, b = map(int, input().split())\n\n    ans = 0\n    while a > 0 and b > 0:\n        if a < b:\n            a, b = b, a\n        ans += a\/\/b\n        a = a % b\n\n    print(ans)","output":"constant"},{"instruction":"from itertools import chain, combinations, permutations\n\ndef powerset(iterable):\n\n    xs = list(iterable)\n\n    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))\n\nn = int(input())\ncl1 = []\ncl2 = []\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl1.append(a)\n\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl2.append(a)\n\ndef copy(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][j])\n    res.append(a)\n  return res\n\ndef pow(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[n-1-j][i])\n    res.append(a)\n  return res\n\ndef vert(m):\n  res = []\n  for i in range(n):\n    res.append(m[i][::-1])\n  return res\n\ndef gor(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][n-1-j])\n    res.append(a)\n  return res\n\ncomblist = [[1], []]\ncm = [pow, pow, pow, vert, gor]\ncm = list(powerset(cm))\nres = False\nif cl1 == cl2:\n  res = True\nelse:\n  for x in cm:\n    for y in permutations(x):\n      t = copy(cl1)\n      for z in y:\n        t = z(t)\n      if t==cl2:\n        res = True\n\nif res:\n  print('Yes')\nelse:\n  print('No')","output":"quadratic"},{"instruction":"n = int(input())\ns = input()\nx = s.count('0')\nif s == '0':\n    print('0')\nelse:\n    print('1' + '0'*x)","output":"linear"},{"instruction":"input = __import__('sys').stdin.readline\n\nn,m,k = map(int, input().split())\nhor = [[int(x) for x in input().split()] for _ in ' ' * n]\nver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)]\n\nif k % 2:\n  for i in ' ' * n: print('-1 ' * m)\n  exit()\n\nmtx_old = [[0] * m for _ in ' ' * n]\n\ndef neighbours(x, y):\n  a = 1e18\n  b = 1e18\n  c = 1e18\n  d = 1e18\n  if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1]\n  if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1]\n  if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x]\n  if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x]\n  return min(a, b, c, d)\n\nfor i in range(k \/\/ 2):\n  mtx_new = [[0] * m for _ in ' ' * n]\n\n  for x in range(m):\n    for y in range(n):\n      mtx_new[y][x] = neighbours(x, y)\n\n  mtx_old = mtx_new\n\nfor row in mtx_old: print(*row)","output":"cubic"},{"instruction":"list_int_input = lambda inp: list(map(int, inp.split()))\nint_input = lambda inp: int(inp)\nstring_to_list_input = lambda inp: list(inp)\n\nn,v=map(int,input().split())\nval=v-1+int(((n-v)*(n-v+1))\/2)\nif n>v:\n    print(val)\nelse:\n    print(n-1)","output":"constant"},{"instruction":"n = int(input())\nvisit = [0 for i in range(n+1)]\nres = []\nc = 0\ns,t=0,0\ndef do(i):\n\tglobal c,s,t\n\tfor j in range(i,n+1,2*i):\n\t\tres.append(i)\n\t\tc += 1\n\t\tif c >= (n-1) and n>2:\n\t\t\tif s == 0:\n\t\t\t\ts = j\n\t\t\telse:\n\t\t\t\tt = j\n\treturn res\ncurr = 0\ni = 1\nwhile(i<=n):\n\n\tdo(i)\n\ti = 2*i\nif n>2:\n\tres[n-1] = max(s,t)\n\nfor i in res:\n\tprint(i,end=\" \")","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = []\nfor i in range(n - 1):\n    b.append(a[i + 1] - a[i])\nb.sort()\nprint(sum(b[:len(b) - k + 1]))","output":"nlogn"},{"instruction":"import sys\n\ndef input():\n\treturn sys.stdin.readline().rstrip()\n\ndef input_split():\n\treturn [int(i) for i in input().split()]\n\nx, y, z  = input_split()\narr_x = input_split()\narr_y = input_split()\narr_z = input_split()\n\nx += 1\ny += 1\nz += 1\n\nlengths = [x,y, z]\narrs = [arr_x, arr_y, arr_z ]\n\nfor a in arrs:\n\ta.sort()\n\ndp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]\n\nfor i in range(1,x):\n\tfor j in range(1,y):\n\n\t\tdp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]\n\nfor j in range(1, y):\n\tfor k in range(1, z):\n\n\t\tdp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]\n\nfor i in range(1,x):\n\tfor k in range(1,z):\n\n\t\tdp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]\n\nfor i in range(1, x):\n\tfor j in range(1, y):\n\t\tfor k in range(1, z):\n\t\t\topt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]\n\t\t\topt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]\n\t\t\topt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]\n\n\t\t\tdp[i][j][k] = max(opt1, opt2, opt3)\n\nans = dp[x-1][y-1][z-1]\n\nprint(ans)","output":"cubic"},{"instruction":"n,k = map(int,input().split())\n\nt  = list(map(int,input().split()))\n\nt.sort()\n\nf={}\n\nfor j in t:\n    if j not in f:\n        f[j]=1\n    else:\n        f[j]+=1\n\np=0\nfor j in range(n):\n    if j<n-1:\n        if t[j+1]>t[j] and t[j]+k >= t[j+1]:\n            p+=f[t[j]]\n\nprint(n-p)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\n\ninfinite = float('inf')\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=RI()\n    s=input()\n\n    mini=n\n\n    test=\"RGB\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"GBR\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"BRG\"*(k\/\/3 + 5)\n    for i in range(n-k+1):\n        count=0\n\n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    print(mini)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom heapq import heapify,heappush as hp,heappop as hpop\ndef check(x,y):\n    if 0<=x<=n-1 and 0<=y<=m-1:\n        return True\n    return False\nn,m,k=map(int,input().split())\nl1=[]\nl2=[]\nfor i in range(n):\n    l1.append(list(map(int,input().split())))\nfor  i in range(n-1):\n    l2.append(list(map(int,input().split())))\ninf=10**18\ndp=[[[inf]*21 for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if check(i,j+1):\n            dp[i][j][1]=min(l1[i][j],dp[i][j][1])\n        if check(i,j-1):\n            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])\n        if check(i+1,j):\n            dp[i][j][1]=min(l2[i][j],dp[i][j][1])\n        if check(i-1,j):\n            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])\nfor x in range(2,k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            if check(i,j+1):\n                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])\n            if check(i,j-1):\n                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])\n            if check(i+1,j):\n                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])\n            if check(i-1,j):\n                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])\n\nans=[[inf]*m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if k%2:\n            ans[i][j]=-1\n            continue\n        ans[i][j]=2*dp[i][j][k\/\/2]\nfor i in ans:\n    print(*i)","output":"cubic"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nzb = getIntList()\n\nza1 = [0]\nza2 = [zb[0]]\n\nfor i in range(1, N\/\/2):\n    t1 = zb[i] - za1[-1]\n    if t1 <= za2[-1]:\n        za1.append(za1[-1])\n        za2.append(t1)\n        continue\n    t2 = zb[i] - za2[-1]\n    if t2 >= za1[-1]:\n        za1.append(t2)\n        za2.append(za2[-1])\n        continue\n    assert False\n\nzr = za1 + za2[ : :-1]\nzs = []\nfor x in zr:\n    zs .append(str(x))\n\nr = ' '.join(zs)\n\nprint(r)","output":"linear"},{"instruction":"l=list(map(int,input().split()))\nl.sort()\nx1=l[0]\nx2=l[1]\nx3=l[2]\nif l[0]==1 or (l[0]==2 and l[1]==4 and l[2]==4) or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"n,m,k = map(int,input().split())\nwh=[]\n\nfor j in range(n):\n    l=list(map(int,input().split()))\n    wh.append(l)\n\nwv=[]\n\nfor j in range(n-1):\n    l=list(map(int,input().split()))\n    wv.append(l)\n\nif(k%2!=0):\n    ans = [[-1 for _ in range(m)]for j in range(n)]\n    for res in ans:\n        print(*res)\nelse:\n    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]\n    for x in range(1,21):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                dp[i][j][x]=1234567890\n                if(i!=n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])\n                if(i!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])\n                if(j!=m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])\n                if(j!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans = 1234567890\n            for x in range(1,k+1):\n                if(k%x==0 and (k\/\/x)%2==0 ):\n                    ans = min(ans,dp[i][j][x]*(k\/\/x))\n            print(ans,end=\" \")\n        print()","output":"cubic"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\ndef solve(x , arr ):\n\n    n = len(arr)\n    flag = True\n    k = []\n    i = 0\n    while flag:\n        sm = 0\n        while n > 0 and sm < x :\n            sm += int(arr[i])\n            i +=1\n            n -=1\n            if n <= 0 :\n                flag = False\n                break\n        if sm>0:\n            k.append(sm)\n\n    return k\n\nn = INT()\ns = STR()\n\nif len(set(s)) == 1 :\n    print('YES');exit(0)\n\nl = []\nt = 0\nfor i in range(n-1):\n    t += int(s[i])\n    l.append(t)\n\nv = []\nfor i in l :\n    if i > 0 :\n        r = solve(i , s)\n        if len(r) > 1 and len(set(r)) == 1 :\n            print('YES')\n            break\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"import math\n\nn, m = map(int, input().split())\n\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\n\nfirst_max = 0\nsecond_max = 0\nfor i in range(n):\n\tif b[i] < first_max and b[i] > second_max:\n\t\tsecond_max = b[i]\n\tif b[i] >= first_max:\n\t\tsecond_max = first_max\n\t\tfirst_max = b[i]\n\nfirst_min = min(g)\n\nif first_max > first_min:\n\tprint(-1)\nelse:\n\ttotal = sum(b) * m + sum(g) - m * first_max + (first_max - second_max) * (first_min != first_max)\n\tprint(total)","output":"linear"},{"instruction":"import collections\n\ndef main():\n\n    n = int(input())\n    left = list(map(int, input().split()))\n    right = list(map(int, input().split()))\n    res = [0] * n\n    val = n\n\n    if all(not left[i] and not right[i] for i in range(n)):\n        print(\"YES\")\n        print(' '.join(['1'] * n))\n        return\n\n    while not all(not left[i] and not right[i] for i in range(n)):\n        zeroSet = set()\n        for i in range(n):\n            if not left[i] and not right[i] and res[i] == 0:\n                zeroSet.add(i)\n                res[i] = val\n        for v in zeroSet:\n            for i in range(v + 1, n):\n                if i not in zeroSet and res[i] == 0:\n                    left[i] -= 1\n            for i in range(v):\n                if i not in zeroSet and res[i] == 0:\n                    right[i] -= 1\n        val -= 1\n\n        if not zeroSet:\n            print(\"NO\")\n            return\n\n    for i in range(n):\n        if not res[i]:\n            res[i] = str(val)\n        else:\n            res[i] = str(res[i])\n    if any(i == '0' for i in res):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(' '.join(res))\n\nmain()","output":"quadratic"},{"instruction":"i=input\ni()\nm=int(i())\nv=m\ntry:\n for a in map(int, (i()+' '+i()).split()):v*=a\/(a-1)\nexcept:v=m-1\nprint(v-m)","output":"linear"},{"instruction":"a, b, c=map(int, input().split())\nd=sorted(list(map(int, input().split())))\n\ne=d[c-1]\nf=d[c]\nprint(f-e)","output":"nlogn"},{"instruction":"details=[4,7,44,77,444,777,47,74,447,774,474,747,477]\nn=int(input())\nf=0\nfor i in details:\n    if n%i==0:\n        f=1\n        break\nif f:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"ser = [0, 1]\ndef fib(n):\n    i = 1\n    while i < n:\n        ser.append(i)\n        i = ser[-1] + ser[-2]\n    if i != n:\n        return -1\n    else:\n        return len(ser)\n\nn = int(input())\na, b, c = 0, 0, 0\nans = 1\nif n == 0:\n    ans = 1\nelif n == 1:\n    a = 1\nelif n == 2:\n    a = 1\n    b = 1\nelif n == 3:\n    a = 1\n    b = 1\n    c = 1\nelse:\n    ans = fib(n)\n    if ans != -1:\n        a = ser[ans-2]\n        b = ser[ans-2]\n        c = ser[ans-3]\nif ans != -1:\n    print(a, b, c)\nelse:\n    print(\"I'm too stupid to solve this problem\")","output":"constant"},{"instruction":"n = int(input())\n\nvertices   = []\nfor _ in range(n):\n  x, w = map(int, input().split())\n  vertices.append([x - w, x + w])\nvertices = sorted(vertices, key = lambda x: x[1])\n\nans = 0\nborder = -(10**9 + 100)\nfor v in vertices:\n  if border <= v[0]:\n    ans += 1\n    border = v[1]\nprint(ans)","output":"nlogn"},{"instruction":"from collections import defaultdict as dd, deque\nn = int(input())\nA = [int(x) for x in input().split()]\nn = len(A)\n\nC = dd(int)\nfor a in A:\n    C[a] += 1\n\nthedup = None\nndup = 0\nscrewed = False\nfor c in C:\n    if C[c] > 2:\n        screwed = True\n    elif C[c] == 2:\n        if c == 0:\n            screwed = True\n        thedup = c\n        ndup += 1\n\nimport sys\nif screwed or ndup > 1:\n    print('cslnb')\nelse:\n    if ndup == 1:\n        if C[thedup-1] != 0:\n            print('cslnb')\n            sys.exit()\n\n    target = sum(range(n))\n    cur = sum(A)\n    togo = cur - target\n\n    if togo%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')","output":"linear"},{"instruction":"from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\na = list(map(int, input().rstrip().split()))\ncnt = [defaultdict(lambda : 0) for _ in range(11)]\nfor i in a:\n    cnt[len(str(i))][i % k] += 1\nans = 0\nd = 10\nfor i in range(1, 11):\n    cnti = cnt[i]\n    for j in a:\n        ans += cnti[(k - d * j) % k]\n    d *= 10\nfor i in a:\n    if not int(str(i) * 2) % k:\n        ans -= 1\nprint(ans)","output":"nlogn"},{"instruction":"citys,cap=map(int,input().split())\nif citys-1<=cap:\n\tprint(citys-1)\nelse:\n\tn=citys-cap\n\tprint(n*(n+1)\/\/2+cap-1)","output":"constant"},{"instruction":"def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2,n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\nprime = get_prime(3162)\n\ncache = {}\ndef get_mask (num):\n\tkey = num\n\tif key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num \/\/ p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\tcache[key] = num\n\treturn num\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = nrs()\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\ta = get_mask(a)\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))","output":"cubic"},{"instruction":"n,l,r,x=map(int,input().split())\nc=list(map(int,input().split()))\nans=0\nfor i in range(0,2**n):\n    v=[]\n    for j in range(n):\n        if i & (1<<j):v.append(c[j])\n    if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1\nprint(ans)","output":"np"},{"instruction":"x=input()\na=0\nfor i in range(len(x)):\n    for j in range(i,len(x)):\n        if x[i:j] in x[i+1:]:\n            if len(x[i:j])>a:\n                a=len(x[i:j])\nprint(a)","output":"cubic"},{"instruction":"a, b, c, n= map(int, input().split())\np = a + b - c\nif p <= n-1 and a - c >= 0 and b - c >= 0:\n    print(n - p)\nelse :\n    print(-1)","output":"constant"},{"instruction":"import time\n\n(n, k) = (int(i) for i in input().split())\n\nstart = time.time()\n\nprint((2*n+3-int((9+8*(n+k))**0.5))\/\/2)\nfinish = time.time()","output":"constant"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect, insort\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nfrom copy import deepcopy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A: print(*ele,end=\"\\n\")\n\nn, m = L()\nk = L()[0]\na = [[0] * m for _ in range(n)]\ndq = deque()\nline = list(map(lambda x: int(x) - 1, L()))\nfor i in range(0, 2 * k, 2):\n    a[line[i]][line[i + 1]] = 1\n    dq.append((line[i], line[i + 1]))\n\nx, y = -1, -1\nwhile dq:\n    x, y = dq.popleft()\n    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:\n            a[tx][ty] = 1\n            dq.append((tx, ty))\n\nprint(f'{x+1} {y+1}')","output":"cubic"},{"instruction":"n,a,b=map(int,input().split())\nl=[int(x) for x in input().split()]\nl.sort()\nprint(l[b]-l[b-1])","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nq = (10 ** 6) * [-1]\npnt = -1\nans = \"YES\"\nfor i in range(n):\n    if pnt == -1:\n        pnt += 1\n        q[pnt] = a[i]\n    else :\n        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:\n            q[pnt] = -1\n            pnt -= 1\n        else:\n            pnt += 1\n            q[pnt] = a[i]\nif pnt > 0 :\n    ans = \"NO\"\nprint(ans)","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left,bisect\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nn,k=map(int,input().split())\nx,y=1,n\nf=0\nwhile(x<=y):\n    m=(x+y)\/\/2\n    s=0\n    p=m\n    while(p>0):\n        s+=p%10\n        p=p\/\/10\n    m1=m-1\n    s1=0\n    p=m1\n    while(p>0):\n        s1+=p%10\n        p=p\/\/10\n    if m==0 or (m-s>=k and m1-s1<k):\n        f=1\n        break\n    elif m-s<k:\n        x=m+1\n    else:\n        y=m-1\nif f:\n    print(n-m+1)\nelse:\n    print(0)","output":"logn"},{"instruction":"k,n,s,p = map(int,input().split())\nx = (n+s-1)\/\/s\nx *= k\nprint((x+p-1)\/\/p)","output":"constant"},{"instruction":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            if i == len(nums) - 1:\n                return True\n            if nums[i] == 0:\n                return False\n\n            end = min(len(nums), i + nums[i] + 1)\n            for j in range(i + 1, end):\n                if dfs(j):\n                    memo[i] = True\n                    return True\n            memo[i] = False\n            return False\n\n        return dfs(0)","output":"quadratic"},{"instruction":"n, q = map(int,input().split())\nai = list(map(int,input().split()))\nar  = []\nar3 = []\nnum = 1\nnummm = max(ai)\nif ai[0] != nummm:\n    num2 = ai[0]\n    for i in range(1,n):\n        ar3 += [[num2,ai[i]]]\n        if ai[i] == nummm:\n            ar += [num2]\n            num = i+1\n            break\n        if ai[i] > num2:\n            ar += [num2]\n            num2 = ai[i]\n        else:\n            ar += [ai[i]]\nar2 = []\nfor i in range(num,n):\n    ar2 += [ai[i]]\nfor i in range(len(ar)):\n    ar2 += [ar[i]]\nnum = len(ar3)\nfor i in range(q):\n    m = int(input())\n    if m <= num:\n        print(ar3[m-1][0],ar3[m-1][1])\n    else:\n        m -= num\n        m -= 1\n        print(nummm,ar2[m % (n-1)])","output":"linear"},{"instruction":"from sys import stdin,stdout\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    a=lst()\n    b=lst()\n    ans=PI=float('inf')\n    dp=[[PI for _ in range(4)] for _ in range(n)]\n    for i in range(n):\n        dp[i][1]=b[i]\n        for j in range(i):\n            if a[j]<a[i]:\n                dp[i][2]=min(dp[i][2],dp[j][1]+b[i])\n                dp[i][3]=min(dp[i][3],dp[j][2]+b[i])\n                ans=min(ans,dp[i][3])\n    print(ans if ans!=PI else -1)","output":"quadratic"},{"instruction":"from operator import itemgetter\n\nclass CodeforcesTask528BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n = 0\n        self.points = []\n\n    def read_input(self):\n        self.n = int(input())\n        for _ in range(self.n):\n            self.points.append([int(x) for x in input().split(\" \")])\n            self.points[-1].append(sum(self.points[-1]))\n\n    def process_task(self):\n        self.points.sort(key=itemgetter(2))\n        last = 0\n        ans = 1\n        for i in range(1, self.n):\n            if self.points[i][0] - self.points[i][1] >= self.points[last][0] + self.points[last][1]:\n                last = i\n                ans += 1\n        self.result = str(ans)\n\n    def get_result(self):\n        return self.result\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask528BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())","output":"nlogn"},{"instruction":"n = int(input())\n\nif n<6:\n\tprint(-1)\nelse:\n\tprint(\"1 2\\n1 3\\n1 4\")\n\tfor i in range(5,n+1):\n\t\tprint('2 '+str(i))\nfor i in range(2, n+1):\n\tprint('1 '+str(i))","output":"linear"},{"instruction":"n, m = map(int, input().split())\narr = list(map(int, input().split()))\nt = list(map(int, input().split()))\ntaxi = list()\nfor i in range(len(arr)):\n    if t[i] == 1:\n        taxi.append(arr[i])\ntaxi2 = list()\nkek = 1\nfor i in range(len(taxi) - 1):\n    taxi2.append([kek, taxi[i] + (taxi[i + 1] - taxi[i]) \/\/ 2])\n    kek = taxi[i] + (taxi[i + 1] - taxi[i]) \/\/ 2 + 1\ntaxi2.append([kek, arr[-1]])\ntaxi3 = [0] * m\nj = 0\nfor i in range(len(arr)):\n    if arr[i] > taxi2[j][1]:\n        j += 1\n    if t[i] != 1:\n        taxi3[j] += 1\nprint(\" \".join(map(str, taxi3)))","output":"linear"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfrom collections import Counter\n\nn, s = mi()\nd = Counter()\nfor i in range(n - 1):\n    u, v = mi()\n    d[u] += 1\n    d[v] += 1\n\nl = sum(v == 1 for v in d.values())\nans = s \/ l * 2\nprint('%.10f' % (ans,))","output":"linear"},{"instruction":"n = int(input())\nfor i in range(n):\n    k = int(input())\n    s = list(map(int, input().split()))\n    s.sort()\n    print(min(k-2,s[k-2]-1))","output":"nlogn"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, i * 2 + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])\n\n    for j in range(1, min(i * 2 + 1, k + 1)):\n        for k1 in range(4):\n            mem[(i - 1) & 1][j][k1] = 0\n\nprint(sum(mem[(n - 1) & 1][k]) % mod)","output":"np"},{"instruction":"n=int(input())\nlist1=list(map(int,input().split(' ')))\nsum2=0\nsum1=0\ncount=0\nlist1.sort(reverse=True)\nfor i in range(len(list1)):\n    sum1=sum1+list1[i]\n\nfor i in range(len(list1)):\n    if(int(sum1\/2)>=sum2):\n        sum2=sum2+list1[i]\n        count=count+1\nprint(count)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    n, k = RLL()\n    dp = [[0]*4 for _ in range(k+2)]\n    dp[1][0] = 1\n    dp[1][3] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n\n    for i in range(2, n+1):\n        new = [[0]*4 for _ in range(k+2)]\n        for j in range(1, k+2):\n            for l in range(4):\n                new[j][l] += dp[j][l]\n                if l==0 or l==3:\n                    new[j][l]+=dp[j-1][l^3]\n                    new[j][l]+=(dp[j][1]+dp[j][2])\n                elif l==1 or l==2:\n                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])\n                    if j-2>=0: new[j][l]+=dp[j-2][l^3]\n                new[j][l] = new[j][l]%mod\n        dp = new\n    print(sum(dp[k])%mod)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"d = {}\nn = int(input())\nfor _ in range(n):\n\ta,x = map(int,input().split())\n\td[a] = x\nm = int(input())\nfor _ in range(m):\n\tb,y = map(int,input().split())\n\tif b in d:\n\t\td[b] = max(y,d[b])\n\telse:\n\t\td[b] = y\ncount = 0\nfor i in d:\n\tcount += d[i]\nprint(count)","output":"nlogn"},{"instruction":"n=int(input())\nl=list(map(lambda x:int(x)*2,input().split(\" \")))\nt=list(map(lambda x:\"GWL\".index(x),input()))\nmins=[0 for i in range(0,n+1)]\nfor i in range(n-1,-1,-1):\n\tif t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)\n\telse:mins[i]=mins[i+1]+l[i]\ncurs=ans=st=0\nfor i in range(0,n):\n\tif(t[i]==0):\n\t\tcurs+=l[i];ans+=l[i]*5\n\t\tif(curs>mins[i+1]):\n\t\t\tol=(curs-mins[i+1])\/\/2\n\t\t\tol=min(ol,l[i])\n\t\t\tans-=4*ol;curs-=2*ol\n\tif(t[i]==1):\n\t\tst=1;curs+=l[i];ans+=l[i]*3\n\tif(t[i]==2):\n\t\tif(curs<l[i]):\n\t\t\tol=l[i]-curs;curs=l[i]\n\t\t\tans+=ol*(3 if st else 5)\n\t\tcurs-=l[i];ans+=l[i]\nif curs>0:ans-=curs\/\/2*2\nprint(ans\/\/2)","output":"linear"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nsys.setrecursionlimit(200000)\nr, g, b = map(int, input().split())\nR = list(map(int, input().split()))\nG = list(map(int, input().split()))\nB = list(map(int, input().split()))\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\n\ndp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)]\n\ndef solve(i, j, k):\n    x, y, z = 0, 0, 0\n    if dp[i][j][k]:\n        return dp[i][j][k]\n    if i < r and j < g:\n        x = (R[i] * G[j]) + solve(i+1, j+1, k)\n    if i < r and k < b:\n        y = (R[i] * B[k]) + solve(i+1, j, k+1)\n    if j < g and k < b:\n        z = (G[j] * B[k]) + solve(i, j+1, k+1)\n    mx = max([x, y, z])\n    dp[i][j][k] = mx\n    return mx\n\nprint(solve(0, 0, 0))","output":"cubic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nimport math\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i):\n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x \/\/ spf[x]\n    return ret\n\ndef SieveOfEratosthenes(n):\n\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef has(x,bit):\n    return x&(1<<bit)\n\ndef solve():\n    l,r = li()\n    bit = 62\n    while bit>=0 and has(l,bit)==has(r,bit):\n        bit-=1\n    print(2**(bit+1)-1)\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"logn"},{"instruction":"n, m = map(int, input().split())\nA = list(map(int, input().split()))\nfrom collections import Counter\nC = Counter(A)\n\ndef is_ok(x):\n    cnt = 0\n    for v in C.values():\n        cnt += v\/\/x\n    if cnt >= n:\n        return True\n    else:\n        return False\n\nok = 0\nng = 1000\nwhile ok+1 < ng:\n    c = (ok+ng)\/\/2\n    if is_ok(c):\n        ok = c\n    else:\n        ng = c\nprint(ok)","output":"nlogn"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\nfrom collections import deque, Counter,defaultdict as dft\nfrom heapq import heappop ,heappush\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor\nfrom bisect import bisect,bisect_left,bisect_right\nfrom decimal import *\nimport sys,threading\nfrom itertools import permutations, combinations\nfrom copy import deepcopy\ninput = sys.stdin.readline\n\nii = lambda: int(input())\nsi = lambda: input().rstrip()\nmp = lambda: map(int, input().split())\nms=  lambda: map(str,input().strip().split(\" \"))\nml = lambda: list(mp())\nmf = lambda: map(float, input().split())\n\nalphs = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef solve():\n    n,m,k=map(int,input().split())\n    dct={}\n    global case\n    case=0\n    iput=[]\n    for i in range(n):\n        word=input()\n        dct[word]=i+1\n        iput.append(word)\n    d=[[] for i in range(n+1)]\n    size=[0]*(n+1)\n    for _ in range(m):\n\n        word,idx=input().split()\n        idx=int(idx)\n        temp=1\n        w=iput[idx-1]\n\n        for x in range(k):\n            if w[x]!='_' and w[x]!=word[x]:\n                temp=0\n                print(\"NO\")\n                exit()\n                break\n\n        res=[]\n        for i in range(1<<k):\n            s=\"\".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])\n\n            if s in dct:\n                j=dct[s]\n                if j!=idx:\n                    d[idx].append(j)\n                    size[j]+=1\n\n    st=[nd  for nd in range(1,n+1) if size[nd]==0]\n\n    for i in st:\n\n        for j in d[i]:\n            size[j]-=1\n            if size[j]==0:\n                st.append(j)\n\n    if len(st)==n:\n        print(\"YES\")\n        print(*st)\n    else:\n        print(\"NO\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    tc=1\n\n    for i in range(tc):\n    \tsolve()","output":"np"},{"instruction":"x = int(input())\nlist1 = []\nfor i in range(x):\n    value = input()\n    list1.append(value)\n\nfor i in range(x):\n    value = input()\n    if value in list1:\n        list1.remove(value)\n\nprint(len(list1))","output":"linear"},{"instruction":"s, l= list(map(int,input().split()))\nsig = []\nutp = []\nif s == 0 or l ==0:\n    print('NO')\n    quit()\nfor i in range(s):\n    sig.append(list(map(int,input())))\nfor i in range(0,l):\n    out = 0\n    for x in range(0,s):\n        out+=sig[x][i]\n    utp.append(out)\nsig = sorted(sig,key = sum)\nfor i in range(0,s):\n    res1=0\n    for x in range(0,l):\n        if utp[x]-sig[i][x] <=0:\n            break\n        else:\n            res1+=1\n    if res1 == l:\n        print('YES')\n        quit()\n\nprint('NO')","output":"quadratic"},{"instruction":"def main():\n    n, k = map(int, input().split())\n    m = 10 ** 9 + 7\n    print((pow(2, k, m) * (2 * n - 1) + 1) % m if n else 0)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"def get_answer(arr):\n    current_sum = 0\n    total = sum(arr)\n    for index, val in enumerate(arr):\n        current_sum += val\n        if current_sum >= total \/ 2:\n            return index + 1\n\nnonsense = input()\ninput_values = input()\nvalues = [int(v) for v in input_values.split()]\n\nprint(get_answer(values))","output":"linear"},{"instruction":"def main():\n\tk = int(input())\n\tdigit = 1; low=1; high=9; totalDigit=9; lastTotalDigit=0\n\twhile (totalDigit < k) :\n\t\tlow *= 10\n\t\thigh = 10*low-1\n\t\tdigit += 1\n\t\tlastTotalDigit = totalDigit\n\t\ttotalDigit += (high+1-low)*digit\n\tk -= lastTotalDigit\n\tcur = str(low+(k-1) \/\/ digit)\n\tprint(cur[(k-1)%digit])\n\nmain()","output":"logn"},{"instruction":"import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\ndef st(): return list(sys.stdin.readline().strip())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef mp(): return map(int, sys.stdin.readline().split())\ndef inp(): return int(sys.stdin.readline())\ndef pr(n): return sys.stdout.write(str(n)+\"\\n\")\ndef prl(n): return sys.stdout.write(str(n)+\" \")\n\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef solve():\n    n, m = mp()\n    k = inp()\n    l = li()\n    q = deque()\n    v = [[0]*(m+1) for i in range(n+1)]\n    for i in range(0, 2*k - 1, 2):\n        q.append((l[i], l[i+1]))\n        v[l[i]][l[i+1]] = 1\n    while q:\n        a, b = q.popleft()\n        for i in range(4):\n            A, B = a+dx[i], b+dy[i]\n            if A > 0 and A <= n and B > 0 and B <= m:\n                if not v[A][B]:\n                    q.append((A, B))\n                    v[A][B] = 1\n    print(a, b)\n\nfor _ in range(1):\n    solve()","output":"cubic"},{"instruction":"N, K = map(int, input().split())\nA = [int(a) for a in input().split()]\nD = sorted([A[i+1]-A[i] for i in range(N-1)])\nprint(A[-1]-A[0]-(sum(D[-K+1:]) if K-1 else 0))","output":"nlogn"},{"instruction":"rd = lambda: list(map(int, input().split()))\nn, k = rd()\na = rd()\nr = 0\ns = [0]\nfor x in a:\n    s.append(s[-1] + x)\nfor i in range(n - k + 1):\n    for j in range(i + k, min(n + 1, i + 2 * k)):\n        r = max(r, (s[j] - s[i]) \/ (j - i))\nprint(r)","output":"quadratic"},{"instruction":"from sys import stdin\ninput=stdin.readline\nfrom collections import defaultdict\ndef f(q):\n    q.sort()\n    d=defaultdict(int)\n    for l,r in q:\n        d[l]+=1\n        d[r+1]-=1\n    res=0\n    prev=None\n    ans=[0]*(len(q)+1)\n    for i in sorted(d.keys()):\n\n        if prev==None:\n\n            prev=i\n        else:\n            ans[res]+=i-prev\n            prev=i\n        res+=d[i]\n\n    return ans[1:]\n\nn=int(input())\nq=[]\nfor i in range(n):\n    x,y=map(int,input().strip().split())\n    q.append((x,y))\nprint(*f(q))","output":"nlogn"},{"instruction":"from itertools import permutations, chain\n\ndef get_plots(a,b):\n\n  ax,ay = a\n  bx,by = b\n\n  for x in range(ax,bx,1 if ax < bx else -1):\n    yield (x,ay)\n  for y in range(ay,by,1 if ay < by else -1):\n    yield (bx,y)\n\ndef solve(points):\n\n  for a,b,c in permutations(points):\n    ax,ay = a\n    bx,by = b\n    cx,cy = c\n    if min(ax,bx) <= cx <= max(ax,bx) and min(ay,by) <= cy <= max(ay,by):\n      return list(chain(get_plots(a,c), get_plots(c,b), [b]))\n\n  def it():\n    for a,b,c in permutations(points):\n      ax,ay = a\n      bx,by = b\n      m = (ax,by)\n      L = list(chain(get_plots(a,m),get_plots(b,m), get_plots(c,m), [m]))\n      yield (len(L),L)\n\n  return min(it())[1]\n\npoints = [tuple(map(int,input().split())) for _ in range(3)]\n\nres = solve(points)\nprint(len(res))\nfor x,y in res:\n  print(x,y)","output":"linear"},{"instruction":"n, k = list(map(int,input().split()))\nchuj_twojej_starej = (n - k) \/\/ 2 + 1\ni = 1\nwhile True:\n\tif i % chuj_twojej_starej == 0:\n\t\tprint(0, end = \"\")\n\telse:\n\t\tprint(1, end = \"\")\n\tif i == n:\n\t\tbreak\n\ti += 1","output":"linear"},{"instruction":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            res += (bit << (31 - i))\n        return res","output":"constant"},{"instruction":"import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\nL, R = map(int, input().split())\n\nfor i in range(64, -1, -1):\n    if L & (1 << i) != R & (1 << i):\n        print((1 << (i+1)) - 1)\n        exit(0)\nprint(0)","output":"logn"},{"instruction":"import sys\nfrom array import array\nfrom typing import List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef solve(i, n, delta, delta2):\n    inf = 2 * 10**9\n    dp = [[-1] * n for _ in range(1 << n)]\n    dp[(1 << i)][i] = inf\n    stack = [(1 << i, i)]\n\n    for t in range(1, n + 1):\n        next_s = []\n        for bit, v in stack:\n            for dest in range(n):\n                if (1 << dest) & bit:\n                    continue\n                if dp[bit | (1 << dest)][dest] == -1:\n                    next_s.append((bit | (1 << dest), dest))\n                dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest]))\n\n        stack = next_s\n\n    return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j)\n\ndef main():\n    n, m = map(int, input().split())\n    matrix = [tuple(map(int, input().split())) for _ in range(n)]\n\n    if n == 1:\n        print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:])))\n        exit()\n\n    delta = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j]))\n    delta2 = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9)\n\n    print(max(solve(i, n, delta, delta2) for i in range(n)))\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nans = 0\npos = 2*n - 2\nfor i in range(n):\n\tx = a[-1]\n\ta.pop(-1)\n\ty = a.index(x)\n\tans += pos - y\n\tpos -= 2\n\ta.pop(y)\nprint(ans)","output":"quadratic"},{"instruction":"x=input();l=len(x);m=0\nfor i in range(l-1):\n    f=i\n    while 1 :\n        idx = x[f+1:].find(x[f])\n        if idx == -1 :\n            break\n        else:\n            idx += f+1 ; c=ans=0\n            for j in range(idx , l) :\n               if x[j] == x[i+c]:\n                    ans+=1\n                    c+=1\n               else:\n                   break\n\n            if m < ans :\n                m=ans\n            f = idx\nprint(m)","output":"cubic"},{"instruction":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')","output":"constant"},{"instruction":"from sys import stdin, stdout\nimport collections\n\nN,M,K = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\n\nres = 0\nfor j in range(M):\n    s = 0\n    mini = 0\n    for i in range(j,N):\n        if i%M==j:\n            mini = min(mini,s)\n            s -= K\n\n        s += arr[i]\n\n        res = max(res,s-mini)\n\nprint(res)","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nfrom itertools import accumulate\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    a=lst()\n    b=lst()\n    ps=list(accumulate(a))\n    dp=[[0 for _ in range(2)] for _ in range(1+n)]\n    for i in range(1,n+1):\n        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]\n        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])\n\n    print(max(dp[n]))","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])","output":"nlogn"},{"instruction":"import sys\nimport math\ndef rec(i,n,l):\n\n    if i == n:\n        return []\n\n    else:\n        x = l2[i]\n        flag = 0\n        o = []\n        p = []\n        mi = -1\n        for j in l:\n            if j < x:\n                if j > mi:\n                    if i == 0 and j == 0:\n                        o.append(j)\n                        p.append(j)\n                        continue\n\n                    mi = j\n\n            if x == j:\n                flag = 1\n\n            o.append(j)\n            p.append(j)\n\n        if flag:\n            o.remove(x)\n\n        if mi == -1 and flag == 0:\n            return []\n\n        ans1 = []\n        if flag:\n\n            ans1 = [x]+rec(i+1,n,o)\n\n        if mi != -1:\n            p.remove(mi)\n\n        p.sort(reverse = True)\n        ans2 = [mi]+p\n        if len(ans1) == n-i:\n            return ans1\n\n        else:\n            return ans2\n\nfor _ in range(1):\n    a = int(input())\n    b = int(input())\n    e1 = str(a)\n    e2 = str(b)\n    l1 = []\n    l2 = []\n    for i in e1:\n        l1.append(int(i))\n\n    for i in e2:\n        l2.append(int(i))\n\n    if len(l1) < len(l2):\n        l1.sort(reverse = True)\n        o = []\n        for i in l1:\n            o.append(str(i))\n\n        print(\"\".join(o))\n\n    else:\n        n = len(l2)\n        ans = rec(0,n,l1)\n        w = []\n        for i in ans:\n            w.append(str(i))\n\n        print(\"\".join(w))","output":"cubic"},{"instruction":"import math\nfor _ in range (int(input())):\n    n=int(input())\n    s=1\n    ch=0\n    for i in range (1,31):\n        s*=2\n        d=math.sqrt(n\/\/s)\n        if n%s==0 and d==int(d):\n            ch=1\n            break\n    if ch:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"r,g, b = map(int,input().split())\nR = sorted([*map(int,input().split())],reverse=True)\nG= sorted([*map(int,input().split())],reverse=True)\nB = sorted([*map(int,input().split())],reverse=True)\nmem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]\ndef dp(i,j,k):\n    p = (i==r)+(j==g)+(k==b)\n    if(p>1):\n        return 0\n    if(mem[i][j][k]!=-1):\n        return mem[i][j][k]\n    ans = 0\n    if(i==r):\n        ans = dp(i,j+1,k+1)+G[j]*B[k]\n        return ans\n    elif(j==g):\n        ans = dp(i+1,j,k+1)+R[i]*B[k]\n    elif(k==b):\n        ans = dp(i+1,j+1,k)+R[i]*G[j]\n    else:\n        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])\n    mem[i][j][k] = ans\n    return ans\nprint(dp(0,0,0))","output":"cubic"},{"instruction":"d={}\nn=int(input())\nfor _ in range(n):\n    a,b=map(int,input().split())\n    d[a]=b\nm=int(input())\nfor _ in range(m):\n    a,b=map(int,input().split())\n    if(a in d and b>d[a]):\n        d[a]=b\n    elif(a not in d):\n        d[a]=b\ns=0\nfor i in d:\n    s+=d[i]\nprint(s)","output":"nlogn"},{"instruction":"fast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nz,zz=input,lambda:list(map(int,z().split()))\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom re import *\nfrom sys import *\nfrom math import *\nfrom heapq import *\nfrom queue import *\nfrom bisect import *\nfrom string import *\nfrom itertools import *\nfrom collections import *\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom collections import Counter as cc\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=1\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\ndef output(answer):\n    stdout.write(str(answer))\n\nn,k=zzz()\n\narr1=zzz()\narr2=zzz()\nans=0\n\nnew_arr=[0]*n\n\nfor i in range(n):\n    if arr2[i]==0:\n        new_arr[i]=arr1[i]\n    else:\n        ans+=arr1[i]\n\ntotal=sum(new_arr[:k])\nmx=total\n\nj=0\nfor i in range(k,n):\n    total-=new_arr[j]\n    total+=new_arr[i]\n    mx=max(mx,total)\n    j+=1\n\nprint(mx+ans)","output":"linear"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n\n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n\n    return powerset_orderred\ndef fastPlrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef solve():\n    n,k = li()\n    p = li()\n    groups = [-1]*256\n    newar = [-1]*n\n    for i in range(n):\n\n        color  = p[i]\n        j = color\n\n        if groups[color]!=-1:\n            newar[i]=groups[color]\n            continue\n\n        while(j>0) :\n            if groups[j]!=-1:\n                break\n            if color-j+1==k:\n                break\n            j-=1\n\n        if groups[j]==-1:\n            for h in range(j,color+1):\n                groups[h]=j\n            newar[i]=groups[color]\n            continue\n        if color-j<k:\n            alreadySize = j-groups[j]+1\n\n            if alreadySize+color-j<=k:\n                for h in range(j+1,color+1):\n                    groups[h]=groups[h-1]\n                newar[i]=groups[color]\n                continue\n            else:\n                for h in range(j+1,color+1):\n                    groups[h]=j+1\n                newar[i]=groups[color]\n                continue\n        else:\n            for h in range(j+1,color+1):\n                groups[h]=j+1\n            newar[i]=groups[color]\n            continue\n    print(*newar)\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"quadratic"},{"instruction":"def decimal_to_26(num):\n    num = int(num)\n    res = ''\n    while num:\n        mod = num % 26\n        if mod == 0:\n            res = 'Z' + res\n            num = num \/\/ 26 - 1\n        else:\n            num \/\/= 26\n            res = chr(mod+64) + res\n    return res\n\ndef RXCY_to_Excel(c,r):\n    new_row = decimal_to_26(r)\n    return new_row + str(c)\n\nn = int(input())\nli = []\nfor i in range(n):\n    li.append(input())\nfor i in li:\n    di_index = []\n    al_index = []\n    temp = i\n    for j in range(len(i)):\n        if i[j].isalpha():\n            al_index.append(j)\n            i = i.replace(i[j],' ')\n\n        elif i[j].isdigit():\n            di_index.append(j)\n            i = i.replace(i[j],' ')\n\n    i = temp\n    if min(di_index) < max(al_index):\n\n        row = int(i[1:i.index('C')])\n        col = int(i[i.index('C')+1:])\n\n        print(RXCY_to_Excel(row,col))\n    else:\n        row_num = 0\n        for k in range(len(i)):\n            if i[k].isdigit():\n                num_start = k\n                break\n\n        length = len(i[0:k])\n\n        for m in range(num_start):\n            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)\n\n            length -= 1\n        print('R'+i[num_start:]+'C'+str(row_num))","output":"linear"},{"instruction":"print('?', 0, 0, flush=True)\nt = int(input())\ns = [0]*31\nif t == 1:\n    s[30] = 1\nelse:\n    s[30] = -1\n\na = 0\nb = 0\nfor i in range(30, 0, -1):\n    c = (1 << (i-1)) + a\n    d = b\n    print('?', c, d, flush=True)\n    ans1 = int(input())\n    c = a\n    d = (1 << (i-1)) + b\n    print('?', c, d, flush=True)\n    ans2 = int(input())\n    if ans1 == -1 and ans2 == 1:\n        a += 1 << (i-1)\n        b += 1 << (i-1)\n        s[i-1] = s[i]\n    elif ans1 == 1 and ans2 == -1:\n        a += 0 << (i-1)\n        b += 0 << (i-1)\n        s[i-1] = s[i]\n    else:\n        s[i-1] = ans1\n        if s[i] == 1:\n            a += 1 << (i-1)\n            b += 0 << (i-1)\n        else:\n            a += 0 << (i-1)\n            b += 1 << (i-1)\nprint('!', a, b)","output":"constant"},{"instruction":"n, d, k = map(int, input().split())\n\nif d+1 > n:\n    print('NO')\n    exit()\n\nans = []\ndist = [0]*n\ndeg = [0]*n\nfor i in range(d+1):\n    if i == 0 or i == d:\n        deg[i] = 1\n    else:\n        deg[i] = 2\n    if i != d:\n        ans.append((i+1, i+2))\n    dist[i] = max(i, d-i)\n\nfor i in range(n):\n    if deg[i] > k:\n        print('NO')\n        exit()\n\nfrom collections import deque\nq = deque(list(range(d+1)))\ncur = d+1\nwhile q and cur < n:\n    v = q.pop()\n    if dist[v] < d and deg[v] < k:\n        deg[v] += 1\n        dist[cur] = dist[v]+1\n        deg[cur] = 1\n        ans.append((v+1, cur+1))\n        q.append(v)\n        q.append(cur)\n        cur += 1\n    else:\n        continue\nif cur != n:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(len(ans)):\n        print(*ans[i])","output":"quadratic"},{"instruction":"k,n,s,p=map(int,input().split())\na=n\/\/s\nif(n%s!=0):\n    a+=1\nq=k*a\nm=q\/\/p\nif(q%p!=0):\n    m+=1\nprint(m)","output":"constant"},{"instruction":"t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = sorted(map(int, input().split()), reverse=True)\n    print(min(n - 2, a[1] - 1))","output":"nlogn"},{"instruction":"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        mp = defaultdict(int)\n        for start, end in intervals:\n            mp[start] += 1\n            mp[end] -= 1\n\n        res = []\n        interval = []\n        have = 0\n        for i in sorted(mp):\n            if not interval:\n                interval.append(i)\n            have += mp[i]\n            if have == 0:\n                interval.append(i)\n                res.append(interval)\n                interval = []\n        return res","output":"nlogn"},{"instruction":"n, t = [int(item) for item in input().split(' ')]\ncont, ans = list(), 2\nfor i in range(n):\n    hCenter, hLen = [float(item) for item in input().split(' ')]\n\n    cont.append([hCenter - hLen \/ 2, hCenter + hLen \/ 2])\n\ncont.sort(key=lambda item: item[0])\n\nfor i in range(n - 1):\n    gap = cont[i+1][0] - cont[i][1]\n    if gap > t:\n        ans += 2\n    elif gap == t:\n        ans += 1\n\nprint(ans)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\ndist = [int(x) for x in input().split()]\ntaxi = [int(x) for x in input().split()]\ndists = {}\nd = []\nfor person in range(len(taxi)):\n    if taxi[person]:\n        dists[dist[person]] = 0\n        d.append(dist[person])\nstart = 0\nd.append(10**11)\nfor person in range(len(taxi)):\n    if taxi[person] == 0:\n        while dist[person] > d[start + 1]:\n            start += 1\n        if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]):\n            dists[d[start]] += 1\n        else:\n            dists[d[start + 1]] += 1\nfor d in dists:\n    print(dists[d] if d!=10**11 else '', end=' ')","output":"linear"},{"instruction":"class Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        intervals.sort(key=lambda x: x.start)\n        min_heap = []\n\n        for interval in intervals:\n            if min_heap and min_heap[0] <= interval.start:\n                heapq.heappop(min_heap)\n            heapq.heappush(min_heap, interval.end)\n\n        return len(min_heap)","output":"nlogn"},{"instruction":"import sys\n\nn, m, k = map(int, input().split())\n\nhor = [list(map(int, input().split())) for _ in range(n)]\n\nver = [list(map(int, input().split())) for _ in range(n-1)]\n\nif k % 2:\n    for i in range(n):\n        print(*([-1]*m))\n    sys.exit()\n\nk = k \/\/ 2\ndp = [[[0]*m for _ in range(n)] for _ in range(k+1)]\n\nfor x in range(1, k+1):\n    for y in range(n):\n        for z in range(m):\n            hold = float('inf')\n            if y != 0:\n                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )\n            if y != n-1:\n                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )\n            if z != 0:\n                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )\n            if z != m-1:\n                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )\n            dp[x][y][z] = hold\n\nfor row in dp[k]:\n    print(*map(lambda i: i*2, row))","output":"cubic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(11)]\nprime[0]=prime[1]=False\n\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n\n                prime[i] = False\n        p += 1\n\nclass DSU:\n    def __init__(self, R, C):\n\n        self.par = range(R*C + 1)\n        self.rnk = [0] * (R*C + 1)\n        self.sz = [1] * (R*C + 1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n    def top(self):\n\n        return self.size(len(self.sz) - 1) - 1\n\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n\n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n\n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n\n            if l == r:\n                return _e\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n\n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n\n            return _op(sml, smr)\n\n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n\n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n\n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n\n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n\n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n\n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n\n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n\n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n\nMIL = 1 << 20\n\ndef makeNode(total, count):\n\n    return (total * MIL) + count\n\ndef getTotal(node):\n    return math.floor(node \/ MIL)\n\ndef getCount(node):\n    return node - getTotal(node) * MIL\n\nnodeIdentity = makeNode(0.0, 0.0)\n\ndef nodeOp(node1, node2):\n    return node1 + node2\n\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n\nidentityMapping = -1\n\ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n\n    count = getCount(node)\n    return makeNode(tag * count, count)\n\ndef composition(mapping1, mapping2):\n\n    return mapping1 if mapping1 != identityMapping else mapping2\n\ndef memodict(f):\n\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return math.gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = math.gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = math.gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n \/\/ f)\n\ndef distinct_factors(n):\n\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n \/\/ i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res = n\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            res=mid\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=-1\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=mid\n            left = mid + 1\n    return res\n\nt=1\n\nfor _ in range (t):\n    n=int(input())\n\n    a=list(map(int,input().split()))\n\n    twopow = [1]*(10**5+69)\n    for i in range(1, 10**5+69):\n        twopow[i] = (twopow[i-1] * 2) % mod\n    count = [0]*100069\n    for i in a:\n        count[i] += 1\n    multiples = [0]*100069\n    for i in range(1, 10**5+1):\n        for j in range(i, 10**5+1, i):\n            multiples[i] += count[j]\n    gcd_of = [0]*100069\n    for i in range(10**5, 0, -1):\n        gcd_of[i] = (twopow[multiples[i]] - 1) % mod\n        for j in range(2*i, 10**5+1, i):\n            gcd_of[i] -= gcd_of[j]\n    print(gcd_of[1] % mod)","output":"np"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\nc1 = 0\nc2 = 0\nfor i in l:\n    if i % 2 == 0:\n        c1+=1\n    else:\n        c2+=1\n\nfor i in range(len(l)-1,-1,-1):\n    if l[i] % 2 == 0:\n        lasteven = i\n        break\nfor i in range(len(l)-1,-1,-1):\n    if l[i] % 2 != 0:\n        lastodd = i\n        break\nif c1 == 1:\n    print(lasteven + 1)\nelse:\n    print(lastodd + 1)","output":"linear"},{"instruction":"def nine(p) :\n\n    s=''\n    for i in range(p) :\n        s+='9'\n    return int(s)\ndef prosh(p) :\n    ans=0\n    for i in range(1,p+1) :\n        ans+=nine(i)*9\n    return ans\n\nn,k=map(int,input().split())\nl=[0]*29\nfor i in range(19) :\n\n    e=nine(19-i)\n\n    l[i]=k\/\/e\n\n    k-=l[i]*e\n\n    if k==0 :\n\n        break\n    if i==18  or k%e>prosh(19-i-1) :\n\n        l[i]+=1\n        break\notv=0\nfor i in range(19) :\n\n    otv+=10**(19-i)*l[i]\n\nprint(max(n-otv+1,0))","output":"logn"},{"instruction":"n = int(input())\ngame = list(map(int, input().split()))\ngame.append(-1)\ngame.sort()\nbitSum = game[1] % 2\nrep = False\nfor i in range(1, n):\n    bitSum += game[i + 1] % 2\n    if game[i] == game[i + 1]:\n        if rep:\n            print('cslnb')\n            exit(0)\n        else:\n            if game[i - 1] == game[i] - 1:\n                print('cslnb')\n                exit(0)\n            rep = True\nGoal = ((n * (n - 1)) \/ 2) % 2\nif (bitSum + Goal) % 2 == 0:\n    print('cslnb')\nelse:\n    print('sjfnb')","output":"nlogn"},{"instruction":"n = int(input())\n\nif (n == 3):\n    print('1 1 3')\nelse:\n    done = 0\n    arr = []\n    for i in range(30, -1, -1):\n        arr.extend([2**i]*(n\/\/(2**i) - done))\n        done += n\/\/(2**i) - done\n        if (done == 1):\n            k = i\n\n    arr[0] = max(arr[0], (n\/\/2**(k-1)) * 2**(k-1))\n\n    arr.reverse()\n    print(' '.join(map(str, arr)))","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nfrom heapq import heapify, heappush, heappop\n\nn, k = map(int, input().split())\nplst = list(map(int, input().split()))\nclst = list(map(int, input().split()))\n\nif k == 0:\n    print(*clst)\n    sys.exit()\n\npc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))\nres = [0] * n\npq = []\npq_sum = 0\npq_size = 0\n\nfor p, c, i in pc:\n    if i > 0 and plst[i] == plst[i-1]:\n        res[i] = res[i-1]\n    else:\n        res[i] = pq_sum + c\n\n    if pq_size < k:\n        heappush(pq, c)\n        pq_sum += c\n        pq_size += 1\n    else:\n        alt = heappop(pq)\n        if alt < c:\n            heappush(pq, c)\n            pq_sum += c - alt\n        else:\n            heappush(pq, alt)\n\nprint(*res)","output":"nlogn"},{"instruction":"from math import pi, sin\n\nn, r = map(float, input().split())\nang = pi \/ n\nk = sin(ang)\nprint(k * r \/  (1 - k))","output":"constant"},{"instruction":"[n, k]=[int(i) for i in input().split()]\nprint((k+n-1)\/\/n)","output":"constant"},{"instruction":"n,m=map(int,input().split())\na=[list('') for x in range(n)]\nb=[list('.'*m) for x in range(n)]\nstart=0\n\nfor i in range(n):\n    a[i]=list(input())\n    if (start==0):\n        if ('.' in a[i]):\n            start=((i-3)\/\/3) *3\nfor i in range(start):\n    b[i]=list('\n\nfor i in range(start,n-2):\n    for j in range(m-2):\n        ok=True\n        if a[i][j]=='\n            for y in range(i,i+3):\n                if ok==False:\n                    break\n                for x in range(j,j+3):\n                    if not((y==i+1)and(x==j+1)):\n                        if a[y][x]!='\n\n                            ok=False\n                            break\n            if ok:\n                for y in range(i,i+3):\n                    for x in range(j,j+3):\n                        if not((y==i+1)and(x==j+1)):\n                            b[y][x]='\n\nif a==b:\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 + count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first + groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = 1\nfor i in range(n - 1):\n  a *= 10\n  a += 1\nb = 10 ** n - a\nprint(a)\nprint(b)","output":"constant"},{"instruction":"n = int(input())\ni = 1\nwhile n:\n    if i > 1:\n        print(' ', end='')\n    if n == 3:\n        print(*[i, i, i * 3], end='')\n        break\n    print(' '.join([str(i)] * ((n + 1) \/\/ 2)), end='')\n    i <<= 1\n    n >>= 1\n\nprint()","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import Counter, defaultdict\nimport bisect\nimport math\n\nfor _ in range(1):\n    n = int(input())\n\n    arr = list(map(int, input().split()))\n    t=[0]*n\n    cur=0\n    for i in range(n-1,-1,-1):\n        cur=max(cur-1,0,arr[i]+1)\n        t[i]=cur\n    ans=0\n    for i in range(n):\n        cur=max(cur,t[i])\n        ans+=cur\n    for i in range(n):\n        ans-=(arr[i]+1)\n    print(ans)","output":"linear"},{"instruction":"MOD=1000000007\n\ndef powr(n,N):\n    temp=1\n    while(N>0):\n        if(N%2!=0):\n            temp=(temp*n)%MOD\n        n=(n*n)%MOD\n        N=N\/\/2\n    return (temp%MOD)\n\ndef MODI(a,b):\n    ans=(powr(a,b)%MOD)\n    return ans\n\nx,k=map(int,input().split())\nif(x==0):\n    print(0)\nelse:\n    t1=powr(2,k+1)%MOD\n    t1=(t1*x)%MOD\n    t2=powr(2,k)%MOD\n    t2=(t2-1)%MOD\n    ans=(t1-t2)%MOD\n    print(ans)","output":"logn"},{"instruction":"import math\n\nt = int(input())\nres = []\nwhile t:\n\tt -= 1\n\tn, k = map(int, input().split())\n\tlimit = -1\n\tif n <= 60:\n\t\tlimit = 0\n\t\tpow4 = 1\n\t\tfor _ in range(n):\n\t\t\tlimit += pow4\n\t\t\tpow4 *= 4\n\tif limit < k and limit != -1 or n == 2 and k == 3:\n\t\tres.append('NO')\n\telse:\n\t\tdiv = 1\n\t\tk -= 1\n\t\tsize = 1\n\t\twhile div < n and k >= 4 * size - 1:\n\t\t\tk -= 4 * size - 1\n\t\t\tsize *= 2\n\t\t\tdiv += 1\n\t\tres.append('YES ' + str(n - div))\n\nprint('\\n'.join(res))","output":"logn"},{"instruction":"def sum_1 (n):\n    s=n*(n+1)\/\/2\n    return s\n\ndef sum_2(s,e):\n    if s<=1:\n        return sum_1(e)\n    return sum_1(e)-sum_1(s-1)\n\ndef mini_splitter(k,n):\n    st=1\n    end=k\n    while st<end:\n        mid=(st+end)\/\/2\n        s=sum_2(mid,k)\n        if s==n:\n            return k-mid+1\n        elif s>n:\n            st=mid+1\n        else:\n            end=mid\n    return k-st+2\n\nn,k=map(int,input().split())\nif(n==1):\n    print(\"0\")\nelif n<=k:\n    print(\"1\")\nelse:\n    k-=1\n    n-=1\n    if sum_1(k)<n:\n        print(\"-1\")\n    else:\n        print(mini_splitter(k,n))","output":"logn"},{"instruction":"l,r=input().split(\" \")\nl,r=int(l),int(r)\nif (l % 2 != 0):\n    l+=1\nif (l + 2 > r):\n    print(-1);\nelse:\n    print(l,l+1,l+2)","output":"constant"},{"instruction":"import sys\na,b,c=sys.stdin.readline().strip().split()\nif a==b and b==c:\n    print(0)\nelif a==b or b==c or a==c:\n    print(1)\nelse:\n    na = int(a[0])\n    nb = int(b[0])\n    nc = int(c[0])\n    if (a[1]==b[1] and a[1]==c[1]):\n        cp=[na,nb,nc]\n        cp.sort()\n        cp[0]+=2\n        cp[1]+=1\n        if (cp[0]==cp[1] and cp[1]==cp[2]):\n            print(\"0\")\n        elif (cp[0]==cp[1] or cp[1]==cp[2] or cp[0]==cp[1] or (cp[0]+1)==cp[1] or (cp[1]+1)==cp[2]):\n            print(\"1\")\n        else:\n            print(\"2\")\n    elif(a[1]==b[1]):\n        mi=min(na,nb)\n        ma=max(na,nb)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(a[1]==c[1]):\n        mi=min(na,nc)\n        ma=max(na,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(b[1]==c[1]):\n        mi = min(nb,nc)\n        ma = max(nb,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    else:\n        print(\"2\")","output":"nlogn"},{"instruction":"n = int(input())\n\na = sorted(map(int, input().split()))\n\nif not any(a):\n    print('cslnb')\nelif n > 2 and a[0] == a[1] == 0:\n    print('cslnb')\nelse:\n    seq_cnt = 0\n    seq_sz = 1\n    max_seq_sz = 1\n    for i in range(n-1):\n        if a[i] == a[i+1]:\n            seq_sz += 1\n        elif a[i] + 1 == a[i+1] and i + 2 < n and a[i+1] == a[i+2]:\n            max_seq_sz = 3\n            break\n        else:\n            max_seq_sz = max(seq_sz, max_seq_sz)\n            seq_cnt += seq_sz > 1\n            seq_sz = 1\n\n    max_seq_sz = max(seq_sz, max_seq_sz)\n    seq_cnt += seq_sz > 1\n\n    if max_seq_sz > 2 or seq_cnt > 1:\n        print('cslnb')\n    else:\n        last = to_play = 0\n        for i in range(n):\n            to_play += a[i] - last\n            last += 1\n\n        if to_play % 2 == 0:\n            print('cslnb')\n        else:\n            print('sjfnb')","output":"nlogn"},{"instruction":"from itertools import accumulate\nfrom sys import stdin, stdout\n\ndef main():\n    k = int(stdin.readline())\n    a = [\n        tuple(map(int, stdin.readline().split()[1:]))\n        for _ in range(k)\n    ]\n    a2ij = {\n        aij: (i, j)\n        for i, ai in enumerate(a)\n        for j, aij in enumerate(ai)\n    }\n\n    plena = [0, ] + list(accumulate(map(len, a)))\n    suma = tuple(map(sum, a))\n    totala = sum(suma)\n\n    if totala % k != 0:\n        stdout.write(\"No\\n\")\n    else:\n        needle = totala \/\/ k\n        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)\n        dp = compute_previous_mask(mask2i2cp)\n        output(dp, mask2i2cp)\n\ndef compute_mask2i2cp(a, a2ij, needle, plena, suma):\n    used = [False, ] * plena[-1]\n    number_of_masks = 1 << len(a)\n    mask2i2cp = [-1, ] * number_of_masks\n\n    for i, ai in enumerate(a):\n        for j, aij in enumerate(ai):\n            if not used[plena[i] + j]:\n                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)\n\n                if i2cp != -1:\n                    mask2i2cp[mask] = i2cp\n\n    return mask2i2cp\n\ndef output(dp, mask2i2cp):\n    mask = len(mask2i2cp) - 1\n\n    if dp[mask] == -1:\n        stdout.write(\"No\\n\")\n    else:\n        answer = [-1, ] * len(mask2i2cp[dp[mask]])\n\n        while mask > 0:\n            current_mask = dp[mask]\n\n            for i, cp in enumerate(mask2i2cp[current_mask]):\n                if 1 == ((current_mask >> i) & 1):\n                    c, p = cp\n                    answer[i] = (c, p)\n\n            mask ^= current_mask\n\n        stdout.write('Yes\\n' + '\\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))\n\ndef compute_mask_i2cp(a2ij, aij, i, j, needle, suma):\n    i2cp = [-1, ] * len(suma)\n    mask = 0\n    current_a = aij\n    current_i = i\n\n    try:\n        while True:\n            next_a = needle - (suma[current_i] - current_a)\n\n            next_i, next_j = a2ij[next_a]\n\n            if ((mask >> next_i) & 1) == 1:\n                return mask, -1\n\n            mask |= 1 << next_i\n            i2cp[next_i] = (next_a, current_i)\n\n            if next_i == i:\n                if next_j == j:\n                    return mask, i2cp\n\n                return mask, -1\n\n            if next_i == current_i:\n                return mask, -1\n\n            current_a = next_a\n            current_i = next_i\n    except KeyError:\n        return mask, -1\n\ndef compute_previous_mask(mask2cp):\n    number_of_masks = len(mask2cp)\n    dp = [-1, ] * number_of_masks\n    dp[0] = 0\n\n    for mask, cp in enumerate(mask2cp):\n        if cp != -1:\n            complement_mask = (number_of_masks - 1) & (~mask)\n            previous_mask = complement_mask\n\n            while previous_mask > 0:\n                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:\n                    dp[previous_mask | mask] = mask\n\n                previous_mask = (previous_mask - 1) & complement_mask\n\n            if dp[mask] == -1:\n                dp[mask] = mask\n    return dp\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"from bisect import bisect_right\n\nn,q=map(int,input().split())\na=[int(X) for X in input().split()]\nk=[int(x) for x in input().split()]\nfor i in range(1,n):\n    a[i]+=a[i-1]\nan=0\nfor j in k:\n    j+=an\n    x=bisect_right(a,j)\n    if x==n:\n        print(n)\n        an=0\n    else:\n\n        print(n-x)\n        an=j","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\nx, y = divmod(s, 9)\nif not s:\n\tx = 0\nelif y:\n\tx += 1\nlow = x*9\nfor i in range(low, low+10000):\n\tif i - sum([int(c) for c in str(i)]) >= s:\n\t\tlow = i\n\t\tbreak\nprint(max(n-low+1, 0))","output":"logn"},{"instruction":"T = int(input())\n\nwhile (T != 0):\n    T -= 1\n\n    N, K = map(int, input().split())\n    cur_usage = 0\n    reslog = 0\n    cnts = dict()\n\n    while True:\n        reslog += 1\n        cur_usage +=  (1 << reslog) - 1\n        if reslog != N:\n            cnts[reslog] = (((1 << reslog)-2)<<1) + 1\n\n        if cur_usage + (1 << (reslog+1))-1 > K or reslog == N:\n            break\n\n    K -= cur_usage\n\n    while K > 0:\n        if len(cnts) == 0:\n            break\n        for key in cnts:\n            K -= cnts[key]\n            if key+1 >= N:\n                del cnts[key]\n                break\n            if (key+1 not in cnts):\n                cnts[key+1] = 0\n            cnts[key+1] += cnts[key] * 4\n            del cnts[key]\n            break\n\n    if K <= 0:\n        print('YES %d' % (N-reslog))\n    else:\n        print('NO')","output":"logn"},{"instruction":"n = int(input())\nprint(0, 0, n)","output":"constant"},{"instruction":"a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nprint(max((0,2*x+y-a))+max((0,3*z+y-b)))","output":"constant"},{"instruction":"n = int(input())\ns = input()\nt = 0\nmn = 0\nfor i in s:\n    if i == '-':\n        t-=1\n    else:\n        t+=1\n    mn = min(mn, t)\nprint(-mn+t)","output":"linear"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph()])\n        a1.fliph()\n    print(['No', 'Yes'][a2.mat in ans])\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"k = input()\nk = int(k)\n\nn = 1\nwhile (k - n*9*(10**(n-1)) > 0):\n    k = k - n*9*(10**(n-1))\n    n = n + 1\n\nn = n - 1\n\nif n == 0:\n    print(k)\nelse:\n    nth_num = (k-1) \/\/ (n+1) + 1\n    num = 10**n + nth_num - 1\n    pos = (k-1) % (n+1)\n    print(int(str(num)[pos]))","output":"logn"},{"instruction":"R,G,B = map(int,input().split())\nr = list(map(int,input().split()))\ng = list(map(int,input().split()))\nb = list(map(int,input().split()))\nr.sort()\ng.sort()\nb.sort()\ndp = []\nfor i in range(R+1):\n\td = []\n\tfor j in range(G+1):\n\t\td.append([0]*(B+1))\n\tdp.append(d)\nfor i in range(R+1):\n\tfor j in range(G+1):\n\t\tfor k in range(B+1):\n\t\t\tif i+j+k<2:\n\t\t\t\tcontinue\n\t\t\tif i>0 and j>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])\n\t\t\tif i>0 and k>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n\t\t\tif j>0 and k>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])\nprint(dp[R][G][B])","output":"cubic"},{"instruction":"a, b = map(int, input().split())\nprint(\"1\"*a)\nprint(int(\"1\" + (\"0\" * a)) - int(\"1\" * a))","output":"constant"},{"instruction":"a = int(input())\nc = [1] * 30\nfor i in range (1,20):\n\tc[i] = 9 * i * pow(10,i-1)\nfor i in range (1,15):\n\tif (a > c[i]):\n\t\ta -= c[i]\n\telse:\n\t\td = int((a-1) \/ i + pow(10,i-1) - 1)\n\t\te = (a-1) % i + 1\n\t\tf = str(d+1)\n\t\tprint(f[e-1])\n\t\texit()","output":"constant"},{"instruction":"k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)\/\/i)+10**(i-1))[(k-r)%i]\nprint(ans)","output":"logn"},{"instruction":"people,n=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nd={}\ntmp=[]\nfor i in range(n):\n    if a[i] in d:\n        d[a[i]]+=1\n    else:\n        d[a[i]]=1\nd1={}\nfor i in d:\n    if d[i] in d1:\n        d1[d[i]]+=1\n    else:\n        d1[d[i]]=1\n    tmp.append(d[i])\ntmp.sort()\nans=0\nfor i in range(1,10001):\n    x=people\n    try:\n        x-=d1[i]\n    except:\n        pass\n    for j in d1:\n        if j>i:\n            x-=(j\/\/i)*d1[j]\n    if x<=0:\n        ans=max(ans,i)\nprint(ans)","output":"nlogn"},{"instruction":"from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n\ndef read(): return list(map(int, input().strip().split()))\n\nans_ = []\n\nt_p = [2**i for i in range(31)]\nn = int(input());\narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [[list(arr.keys())[0], 1]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = arr[a] + arr[b] + arr[c]\n        if s > m:\n            m = s\n            ans_lis = [[x, arr[x]] for x in [a, b, c]]\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i[0])+\" \")*i[1]\nans_.append(t)\n\nfor i in ans_:\n    print(i)","output":"nlogn"},{"instruction":"n,k=list(map(int,input().split()))\n\narr1=list(map(int,input().split()))\narr2=list(map(int,input().split()))\nans=0\n\nnew_arr=[0]*n\n\nfor i in range(n):\n    if arr2[i]==0:\n        new_arr[i]=arr1[i]\n    else:\n        ans+=arr1[i]\n\ntotal=sum(new_arr[:k])\nmx=total\n\nj=0\nfor i in range(k,n):\n    total-=new_arr[j]\n    total+=new_arr[i]\n    mx=max(mx,total)\n    j+=1\n\nprint(mx+ans)","output":"linear"},{"instruction":"n = int(input())\na = sorted(map(int, input().split()))\n\nans = [0]*n\nans[0] = 1\nf = ans[0] != a[0]\nfor i in range(1, n):\n    ans[i] = a[i-1]\n    if ans[i] != a[i]:\n        f = True\n\nm = 10**9\nif not f:\n    for i in range(n-1, -1, -1):\n        if ans[i] < m:\n            ans[i] += 1\n            break\n\nprint(' '.join(map(str, ans)))","output":"nlogn"},{"instruction":"from sys import stdin, stdout\nfrom math import sin, tan, cos\n\nx, y, z, t1, t2, t3 = map(int, stdin.readline().split())\n\nif abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1:\n    stdout.write('YES')\nelse:\n    stdout.write('NO')","output":"constant"},{"instruction":"def digitsum(n):\n    init=0\n    for item in str(n):\n        init+=int(item)\n    return init\nn,s=map(int,input().split())\nif n-digitsum(n)<s:\n    print(0)\nelse:\n    i=0\n    j=n\n    while i<j:\n        mid=(i+j)\/\/2\n        if mid-digitsum(mid)<s:\n            i=mid+1\n        else:\n            j=mid\n    else:\n        print(n-i+1)","output":"logn"},{"instruction":"import sys, string\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(sys.stdin.readline().rstrip())\nst = []\nans = []\nfor i in range(n):\n    if k <= 0:\n        break\n    else:\n        if arr[i] == '(':\n            st.append((arr[i], i))\n        else:\n            if st and st[-1][0] == '(':\n                k -= 2\n                ans.append(st.pop())\n                ans.append((arr[i], i))\n            else:\n                st.append((arr[i], i))\n\nans.sort(key=lambda x: x[1])\nres = []\nfor i in ans:\n    res.append(i[0])\nprint(''.join(res))","output":"linear"},{"instruction":"from collections import*\nR=lambda:map(int,input().split())\nn,m=R()\na=Counter(R()).values()\ni=1\nwhile sum(x\/\/i for x in a)>=n:i+=1\nprint(i-1)","output":"nlogn"},{"instruction":"import sys\nimport math\ninput=sys.stdin.readline\na=list(input())\nb=list(input())\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nif x<0 or y<0:\n    print(0)\nelse:\n    fact=math.factorial(x+y)\/(math.factorial(x)*math.factorial(y))\n    total=2**(x+y)\n    print(fact\/total)","output":"np"},{"instruction":"def somaDigitos(x):\n    resp = 0\n    while x > 0:\n        resp += x%10\n        x = x\/\/10\n    return resp\n\ndef isReallyBigNumber(x):\n    return x - somaDigitos(x) >= s\n\nn, s = input().split(\" \")\nn = int(n)\ns = int(s)\n\ncount = 0\n\nini = 1\nfim = n\ni = 0\nans = False\nwhile ini <= fim:\n    meio = (ini + fim)\/\/2\n    if isReallyBigNumber(meio):\n        ans = meio\n        fim = meio - 1\n    else:\n        ini = meio + 1\n\nif ans:\n    print(n - ans + 1)\nelse:\n    print(0)","output":"logn"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n, k = map(int, input().split())\n    arr = list(map(int, input().split()))\n    kek = [0] * (n - 1)\n    for i in range(n - 1):\n        kek[i] =  -arr[i + 1] + arr[i]\n\n    kek.sort()\n\n    ans = arr[-1] - arr[0]\n    for i in range(k - 1):\n        ans += kek[i]\n\n    print(ans)\n\n    return 0\n\nmain()","output":"nlogn"},{"instruction":"import sys\n\nfrom collections import deque\n\nfrom queue import PriorityQueue\nfrom math import gcd\nfrom math import log\nfrom math import ceil\nfrom math import pi\ninput_ = lambda: sys.stdin.readline().strip(\"\\r\\n\")\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab,bc,cd : ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x : print(x)\nprinT = lambda x : print(x)\nf = lambda : sys.stdout.flush()\nmod = 10**9 + 7\n\nn,mod = il()\nN = 406\n\nfact = [1 for i in range (N)]\ninver = [1 for i in range (N)]\npower2 = [1 for i in range (N)]\nncr = [[1 for i in range (N)] for j in range (N)]\ndp = [[0 for i in range (N)] for j in range (N)]\n\ndef precom() :\n\n    fact[0] = 1\n    inver[0] = 1\n\n    for i in range (1,N) :\n        fact[i] = (fact[i-1]*i)%mod\n        inver[i] = pow(fact[i],mod-2,mod)\n\n    for i in range (N) :\n        for j in range (i+1) :\n            ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod\n\n    for i in range(1,N) :\n        power2[i] = (power2[i-1]*2)%mod\n\nprecom()\n\ndp[0][0] = 1\n\nfor i in range (n) :\n    for j in range (i+1) :\n        k = 1\n        while (k+i <= n) :\n\n            dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod\n\n            k += 1\n\nans = 0\n\nfor i in range (n+1) :\n    ans = (ans + dp[n+1][i])%mod\n\nprint(ans)","output":"cubic"},{"instruction":"n,x = list(map(int, input().split()))\na = set(map(int, input().split()))\n\nif len(a) < n :\n    print(0)\nelse :\n    d = set()\n    p = 0\n    for i in a :\n        d.add(i&x)\n        if i&x != i and i&x in a :\n            print(1)\n            p = 1\n            break\n    if len(d) < n and p == 0 :\n        print(2)\n    elif p != 1 :\n        print(-1)","output":"linear"},{"instruction":"class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n        return False","output":"nlogn"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nn,k=map(int,sys.stdin.readline().split())\n\nmod=998244353\ndp=[[0,0,0,0] for x in range(k+3)]\ndp[1][0]=1\ndp[1][1]=1\ndp[2][2]=1\ndp[2][3]=1\nnewdp=[[0,0,0,0] for x in range(k+3)]\nfor i in range(n-1):\n\n    for j in range(k+1):\n        newdp[j+1][1]+=dp[j][0]\n        newdp[j+1][3]+=dp[j][0]\n        newdp[j+1][2]+=dp[j][0]\n        newdp[j][0]+=dp[j][0]\n        newdp[j][1]+=dp[j][1]\n        newdp[j+1][3]+=dp[j][1]\n        newdp[j+1][2]+=dp[j][1]\n        newdp[j+1][0]+=dp[j][1]\n        newdp[j][1]+=dp[j][2]\n        newdp[j+2][3]+=dp[j][2]\n        newdp[j][2]+=dp[j][2]\n        newdp[j][0]+=dp[j][2]\n        newdp[j][1]+=dp[j][3]\n        newdp[j][3]+=dp[j][3]\n        newdp[j+2][2]+=dp[j][3]\n        newdp[j][0]+=dp[j][3]\n\n        for a in range(3):\n            for b in range(4):\n                newdp[a+j][b]%=mod\n    for a in range(k+3):\n        for b in range(4):\n            dp[a][b]=newdp[a][b]\n            newdp[a][b]=0\nans=sum(dp[k])\nans%=mod\nprint(ans)","output":"np"},{"instruction":"parent = [i for i in range(int(1e5 + 2))]\ndef findSet(u):\n    if parent[u] != u:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nif __name__ == '__main__':\n    n, a, b = map(int, input().split())\n    lst = list(map(int, input().split()))\n    temp = {lst[i]: i for i in range(n)}\n    for i in range(n):\n        if a - lst[i] in temp:\n            unionSet(i, temp[a - lst[i]])\n        else:\n            unionSet(i, n)\n        if b - lst[i] in temp:\n            unionSet(i, temp[b - lst[i]])\n        else:\n            unionSet(i, n + 1)\n\n    pa = findSet(n)\n    pb = findSet(n + 1)\n    if pa == pb:\n        print('NO')\n    else:\n        print('YES')\n        lst = [0 if findSet(i) == pb else 1 for i in range(n)]\n        print(*lst)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    for _ in range(N()):\n        n, m = RL()\n        arr = []\n        for _ in range(n): arr.append(RLL())\n\n        larr = [list(i) for i in zip(*arr)]\n        larr.sort(key = lambda a: max(a), reverse=1)\n        larr = larr[:n]\n\n        res = 0\n\n        def dfs(lst, pos=0):\n            nonlocal res\n            if pos==min(n, len(larr)):\n                res = max(res, sum(lst))\n                return\n\n            for i in range(n):\n                nex = lst.copy()\n                for j in range(n):\n                    nex[(i+j)%n] = max(nex[(i+j)%n], larr[pos][j])\n                dfs(nex, pos+1)\n\n        dfs([0]*n)\n        print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"def black_count(x, y):\n\ttotal = x * y\n\treturn total \/\/ 2\n\ndef black_count2(a, b, c, d):\n\treturn black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)\n\ndef white_count2(a, b, c, d):\n\ttotal = (c - a + 1) * (d - b + 1)\n\treturn total - black_count2(a, b, c, d)\n\ndef intersection(a, b, c, d, x, y):\n\tif x < a or y < b:\n\t\treturn None\n\tx = min(x, c)\n\ty = min(y, d)\n\treturn (a, b, x, y)\n\ndef intersection2(a1, b1, c1, d1, a2, b2, c2, d2):\n\tif b1 > d2 or a1 > c2:\n\t\treturn None\n\tif b2 > d1 or a2 > c1:\n\t\treturn None\n\n\ta = max(a1, a2)\n\tb = max(b1, b2)\n\tc = min(c1, c2)\n\td = min(d1, d2)\n\treturn (a, b, c, d)\n\ndef solve(n, m, W, B):\n\ttotal = n * m\n\twhites = total - black_count(n, m)\n\twhites += black_count2(*W)\n\twhites -= white_count2(*B)\n\tI = intersection2(*W, *B)\n\tif I:\n\t\twhites -= black_count2(*I)\n\tblacks = n * m - whites\n\treturn whites, blacks\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn, m = map(int, input().split())\n\t\tW = list(int(i) for i in input().split())\n\t\tB = list(int(i) for i in input().split())\n\t\tw, b = solve(n, m, W, B)\n\t\tprint(w, b)\n\nif __name__ == '__main__':\n\tmain()","output":"constant"},{"instruction":"def solve():\n    num_pixels, max_group_size = (int(x) for x in input().split())\n    pixels = [int(x) for x in input().split()]\n    groups = [None for _ in range(256)]\n\n    for pixel in pixels:\n        if groups[pixel] is None:\n            smallest_of_group = pixel\n            while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None:\n                smallest_of_group -= 1\n\n            if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size:\n                group_color = groups[smallest_of_group]\n            else:\n                group_color = smallest_of_group + 1\n            smallest_of_group += 1\n            for color in range(smallest_of_group, pixel + 1):\n                groups[color] = group_color\n\n    print(*(groups[pixel] for pixel in pixels))\n\nsolve()","output":"quadratic"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\nm,n=ris()\nm,n=m+2,n+2\ngrid =['.'*n]\ngrid+=['.'+rl()+'.' for _ in range(m-2)]\ngrid+=['.'*n]\n\nup=[[0]*n for _ in range(m)]\ndw=[[0]*n for _ in range(m)]\nlf=[[0]*n for _ in range(m)]\nrg=[[0]*n for _ in range(m)]\nrs=[[0]*n for _ in range(m)]\ncs=[[0]*n for _ in range(m)]\n\nfor i in range(1,m-1):\n  for j in range(1,n-1):\n    if grid[i][j]=='*':\n      up[i][j]=1+up[i-1][j]\n      lf[i][j]=1+lf[i][j-1]\nfor i in range(m-1,0,-1):\n  for j in range(n-1,0,-1):\n    if grid[i][j]=='*':\n      dw[i][j]=1+dw[i+1][j]\n      rg[i][j]=1+rg[i][j+1]\n\nans=[]\nfor i in range(1,m-1):\n  for j in range(1,n-1):\n    if grid[i][j]=='.':\n      continue\n    s=min(up[i-1][j],dw[i+1][j],lf[i][j-1],rg[i][j+1])\n    if s==0:\n      continue\n    ans.append((i,j,s))\n    rs[i-s][j]+=1\n    rs[i+s+1][j]-=1\n    cs[i][j-s]+=1\n    cs[i][j+s+1]-=1\n\nfor i in range(1,m-1):\n  for j in range(1,n-1):\n    rs[i][j]+=rs[i-1][j]\n    cs[i][j]+=cs[i][j-1]\n\nfor i in range(1,m-1):\n  for j in range(1,n-1):\n    if grid[i][j]=='.':\n      continue\n    if rs[i][j]==0 and cs[i][j]==0:\n      print(-1)\n      exit()\n\nprint(len(ans))\nfor i,j,s in ans:\n  print(i,j,s)","output":"quadratic"},{"instruction":"import re\ndef main():\n\n    total_games, total_notes = map(int, input().split())\n    games = [int(i) for i in input().split()]\n    notes = [int(i) for i in input().split()]\n    note = 0\n    for game in games:\n        if notes[note] >= game:\n            note += 1\n        if note == total_notes:\n            break\n    print(note)\n\nmain()","output":"linear"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\nc=[n]*n\nfor i in range(n):\n    c[i]-=(r[i]+l[i])\nfor i in range(n):\n    m=0\n    for j in range(0,i):\n        if c[j]>c[i]:\n            m+=1\n    if m!=l[i]:\n        exit(print('NO'))\nfor i in range(n):\n    m=0\n    for j in range(i+1,n):\n        if c[j]>c[i]:\n            m+=1\n    if m!=r[i]:\n        exit(print('NO'))\nprint('YES')\nprint(*(c))","output":"quadratic"},{"instruction":"n = int(input())\n\ngems = {'purple':'Power', 'green':'Time', 'blue': 'Space',\n    'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}\n\ngems_in = []\nfor _ in range(n):\n    gems_in.append(input())\n\nprint(6-len(gems_in))\nr = list(set(gems) - set(gems_in))\nfor gem in r:\n    print(gems[gem])","output":"constant"},{"instruction":"q=input().split()\n\nx=int(q[0])\nk=int(q[1])\n\ndef po(a,p,m):\n if p==0:\n  return 1\n x=po(a,p\/\/2,m)%m\n x=(x%m*x%m)%m\n if p%2==1:\n  x=(x%m*a%m)%m\n\n return int(x)\n\nm=1000000007\nif x==0:\n print(0)\nelse:\n print(((po(2,k+1,m)%m*x%m)%m-(po(2,k,m)%m-1)%m)%m)","output":"logn"},{"instruction":"a, b, c, d, e, f, g, h = map(int, input().split(' '))\ni, j, k, l, m, n, o, p = map(int, input().split(' '))\n\ns1 = [[a, b], [c, d], [e, f], [g, h]]\ns1.sort()\nbleft = s1[0]\ntr = s1[3]\nu, v, w, x = bleft[0], bleft[1], tr[0], tr[1]\n\ndef check(xd, dx, u, v, w, x):\n\treturn (u <= xd and xd <= w and v <= dx and dx <= x)\n\ngod = [(i+k+m+o)\/4, (j+l+n+p)\/4]\nnani = 0\nfor moo in [[i, j], [k, l], [m, n], [o, p]]:\n\tif check(moo[0], moo[1], u, v, w, x):\n\t\tprint(\"Yes\")\n\t\tquit()\n\nif check(god[0], god[1], u, v, w, x):\n\tnani += 1\n\ni, j = i+j, i-j\nk, l = k+l, k-l\nm, n = m+n, m-n\no, p = o+p, o-p\n\na, b = a+b, a-b\nc, d = c+d, c-d\ne, f = e+f, e-f\ng, h = g+h, g-h\n\na, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = i, j, k, l, m, n, o, p, a, b, c, d, e, f, g, h\n\ns1 = [[a, b], [c, d], [e, f], [g, h]]\ns1.sort()\nbleft = s1[0]\ntr = s1[3]\nu, v, w, x = bleft[0], bleft[1], tr[0], tr[1]\n\ndef check(xd, dx, u, v, w, x):\n\treturn (u <= xd and xd <= w and v <= dx and dx <= x)\n\ngod = [(i+k+m+o)\/4, (j+l+n+p)\/4]\n\nfor moo in [[i, j], [k, l], [m, n], [o, p]]:\n\tif check(moo[0], moo[1], u, v, w, x):\n\t\tprint(\"Yes\")\n\t\tquit()\n\nif check(god[0], god[1], u, v, w, x):\n\tnani += 1\nif nani == 2:\n\tprint(\"Yes\")\n\tquit()\n\nprint(\"No\")","output":"constant"},{"instruction":"n, k = map(int, input().split())\nd = int((9 + 8 * (n + k)) ** 0.5)\nx = (d - 3) \/\/ 2\nprint(n - x)","output":"constant"},{"instruction":"n=int(input())\nl=list(str(n))\nif n>=0:\n\tprint(n)\nelse:\n\tif int(l[-1])>int(l[-2]):\n\t\tl.pop(-1)\n\telse:\n\t\tl.pop(-2)\n\tprint(int(''.join(l)))","output":"constant"},{"instruction":"from sys import stdin, stdout\n\ndef binary_exp(x,n,prime):\n\tif n==0:\n\t\treturn 1\n\telif n==1:\n\t\treturn x%prime\n\telse:\n\t\ttemp=binary_exp(x,n\/\/2,prime)\n\t\ttemp=(temp*temp)%prime\n\t\tif n%2==0:\n\t\t\treturn temp\n\t\telse:\n\t\t\treturn ((x%prime)*temp)%prime\n\nx,k = map(int, stdin.readline().rstrip().split())\nif x==0:\n\tprint(0)\nelse:\n\tval1=binary_exp(2,k+1,1000000007)\n\tval2=binary_exp(2,k,1000000007)\n\tval1=val1%1000000007\n\tval2=val2%1000000007\n\n\tans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007\n\tprint(ans)","output":"logn"},{"instruction":"def bs(n, k, lo, hi):\n\n    while lo <= hi:\n        mid = (hi + lo)\/\/2\n\n        summ = ((k * (k + 1))\/\/2 - 1) - (((mid-1) * (mid))\/\/2 -1) - (k-2)\n\n        if summ == n:\n\n            return k - mid + 1\n\n        if summ > n:\n\n            lo = mid + 1\n\n        elif summ < n:\n            hi = mid - 1\n\n    if summ > n:\n       mid += 1\n    return k - mid + 1\n\ndef solve():\n    n, k = map(int, input().split())\n\n    if n == 1: return 0\n    elif (k * (k + 1)\/\/2) - (k-2) <= n:\n\n        return -1\n    elif k >= n: return 1\n    else:\n        return bs(n, k, 2, k)\n\nprint(solve())","output":"logn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\na.sort()\nif a[n-1]==1:\n    a[n-1]+=1\nelse:\n    a[n-1]=1\na.sort()\nprint(*a)","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\ns=list(input().rstrip())\nn=len(s)\ns.extend(s)\ncnt=0\nc=1\nfor i in range(len(s)-1):\n  if s[i]!=s[i+1]:\n    c+=1\n  else:\n    cnt=max(c,cnt)\n    c=1\ncnt=max(cnt,c)\nprint(min(cnt,n))","output":"linear"},{"instruction":"import sys\n\nn = int(input())\nprob = [list(map(float, input().split())) for _ in range(n)]\ndp = [[0.0]*(1 << n) for _ in range(n)]\ndp[0][1] = 1.0\n\nfor mask in range(3, 1 << n):\n    for i in range(n):\n        if not (mask & (1 << i)):\n            continue\n        for j in range(n):\n            if i != j and mask & (1 << j):\n                dp[i][mask] = max(\n                    dp[i][mask],\n                    dp[i][mask - (1 << j)] * prob[i][j]\n                    + dp[j][mask - (1 << i)] * prob[j][i]\n                )\n\nprint(max(dp[i][-1] for i in range(n)))","output":"np"},{"instruction":"x,k=map(int,input().split())\nm=10**9+7\nprint((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)","output":"logn"},{"instruction":"import math\nnum=int(input())\nk=math.ceil(num\/2)\nif num%2==0:\n    print(k+1)\nelse:\n    print(k)","output":"constant"},{"instruction":"n, m = map( int, input().split() )\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb.sort()\ng.sort()\nif b[-1] > g[ 0 ]:\n    print( -1 )\nelse:\n    ans = sum(b)*m\n    if g[ 0 ] != b[ -1 ]:\n        ans += g[ 0 ] - b[ -2 ]\n    for i in range( 1, m):\n        ans += g[ i ] - b[ -1 ]\n    print( ans )","output":"nlogn"},{"instruction":"import sys\nimport math\nfrom collections import OrderedDict\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, input().split())\ndef listinput(): return list(map(int, input().split()))\nn,k=minput()\nfor i in range(1,n+1):\n\tif (i*(i+1))\/2 -n+i==k:\n\t\tprint(n-i)\n\t\tbreak","output":"logn"},{"instruction":"n,k = map(int, raw_input().split())\n\ndef area(height):\n    return n * height\n\ndef bin_search(low, high):\n    if (high == low):\n        return high\n    if high - low == 1:\n        if area(low) >= k:\n            return low\n        return high\n    midd = (high + low) \/\/ 2\n    if area(midd) > k:\n        return bin_search(low, midd)\n    return bin_search(midd, high)\n\nprint(bin_search(0, 1000000000000000000))","output":"logn"},{"instruction":"N, T = map(int, input().split())\n\ndef read_houses():\n  for _ in range(N):\n    yield tuple(map(int, input().split()))\n\nhouses = list(read_houses())\n\nhouses.sort()\n\ncount = 2\n\nfor (a, x), (b, y) in zip(houses, houses[1:]):\n  if b-a - (x\/2+y\/2) > T:\n    count += 2\n  if b-a - (x\/2+y\/2) == T:\n    count += 1\n\nprint(count)","output":"nlogn"},{"instruction":"def qtd(u):\n    ans = 0\n    while(u > 0):\n        u\/\/=10\n        ans += 1\n    return ans\n\ndef digitos(u):\n    ans = 0\n    while(u > 0):\n        ans += u%10\n        u\/\/=10\n    return ans\n\nn, m = input().split()\nm = int(m)\nnumber = int(n)\nans = 0\nsize_n = qtd(m)\ni = m\n\nwhile(i < m+(size_n*9) + 1):\n    if(i > number):\n        break\n    if(i - digitos(i) >= m):\n        ans += 1\n    i += 1\n\nif(i > number):\n    print(ans)\nelse:\n    print(number-i+1+ans)","output":"logn"},{"instruction":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        resIdx, resLen = 0, 0\n        n = len(s)\n\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    if resLen < (j - i + 1):\n                        resIdx = i\n                        resLen = j - i + 1\n\n        return s[resIdx : resIdx + resLen]","output":"quadratic"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\ngap=n\/\/2\ncount =0\nwhile gap >=1:\n    for j in range(gap ,n):\n        i= j-gap\n        while i >=0:\n            if arr[i +gap] >arr[i]:\n                break\n            else:\n                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]\n                count +=1\n            i-=gap\n    gap\/\/=2\nif count % 2== 3*n %2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"x, k = map(int, input().split())\nif x == 0:\n    print(0)\n    exit()\nmod = 10**9+7\nans = 1+(2*x-1)*pow(2, k, mod)\nprint(ans%mod)","output":"logn"},{"instruction":"n = int(input())\nans = 0\nfor i in range(2, n + 1):\n    for j in range(i + i, n + 1, i):\n        ans += 4 * j \/\/ i\nprint(ans)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m=map(int,input().split())\ns=0\ne=n-1\nfor i in range(n\/\/2):\n    for j in range(m):\n        print(s+1,j+1)\n        print(e+1,m-j)\n    s+=1\n    e-=1\nif n%2==1:\n    s=n\/\/2\n    for j in range(m\/\/2):\n            print(s+1,j+1)\n            print(s+1,m-j)\n    if m%2==1:\n            print(s+1,m\/\/2+1)","output":"quadratic"},{"instruction":"n, s = map(int, input().split(' '))\n\nif(s <= n):\n  sol = 1\nelse:\n  sol = s \/\/ n\n  if(s % n):\n    sol += 1\n\nprint(sol)","output":"constant"},{"instruction":"a = [0 for i in range(0, 256)]\nn,k = input().split(' ')\nk = int(k)\nfor c in input().split(' '):\n        c = int(c)\n        if a[c] != 0:\n            print(a[c]-1, end=' ')\n        else:\n            for x in range(c, c-k, -1):\n                if a[x] == 0:\n                    i = x\n                else:\n                    if c-a[x]+1<k:\n                        i = a[x]-1\n                    break\n                if x == 0:\n                    break\n            for x in range(int(i), c+1):\n                a[x] = i + 1\n            print(i, end=' ')","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\na = 0\nwhile m:\n    a += n\/\/m\n    n, m = m, n % m\nprint(a)","output":"constant"},{"instruction":"n,U=map(int,input().split())\nAr=list(map(int,input().split()))\nR = 0;\nans = -1;\nfor i in range(n):\n    while R + 1 < n and Ar[R + 1] - Ar[i] <= U:\n        R+=1\n    if i+1 < R:\n        ans = max((Ar[R] - Ar[i + 1]) \/ (Ar[R] - Ar[i]),ans);\nprint(ans)","output":"nlogn"},{"instruction":"def luck(n):\n    if n % 4 == 0 or n % 7 == 0:\n        return True\n    while n > 0:\n        tmp = n % 10\n        n = int(n \/ 10)\n        if tmp != 4 and tmp != 7:\n            return False\n\n    return True\n\ndef lucky(n):\n    if luck(n):\n        return \"YES\"\n\n    for x in range(1, n + 1):\n        if n % x == 0 and luck(x):\n            return \"YES\"\n\n    return \"NO\"\n\nn = int(input())\n\nprint(lucky(n))","output":"constant"},{"instruction":"size = int(input())\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\nif (y2 - y1) * (y3 - y1) > 0 and (x2 - x1) * (x3 - x1) > 0 and x1 + y1 != x3 + y3:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"n = int(input())\nfib = [0,1]\n\nfor x in range(1,200):\n\n    z = fib[x] + fib[x-1]\n    if z <= n:\n\n        fib.append(z)\n    else:\n        break\n\nfib = fib[::-1]\nlis = []\nfor y in range(len(fib)):\n\n    if fib[y] <= n:\n        if (sum(lis) + fib[y]) <= n:\n            if len(lis) < 3:\n                lis.append(fib[y])\nif sum(lis) == n:\n    if len(lis) == 1:\n        lis.append(0)\n        lis.append(0)\n        print(*lis)\n    elif len(lis) == 2:\n        lis.append(0)\n        print(*lis)\n    else:\n        print(*lis)\nelse:\n    print(\"I'm too stupid to solve this problem\")","output":"constant"},{"instruction":"t=int(input())\nfor ca in range(t):\n    asd=input().split()\n    n=int(asd[0])\n    k=int(asd[1])\n    if n>=40:\n        print(\"YES \"+str(n-1))\n    else:\n        ans=-1\n        for m in range(1,n+1):\n            asd=(4**m-1)\/\/3\n            asd2=(2**m-1)**2\n            asd2*=(4**(n-m)-1)\/\/3\n            asd+=asd2\n            if asd>=k and m*m<=k:\n                ans=n-m\n                break\n        if ans==-1:\n            print(\"NO\")\n        else:\n            print(\"YES \"+str(ans))","output":"linear"},{"instruction":"s = input()\n\ndef palindrome(s):\n    i=0\n    j=len(s)-1\n    p=True\n    while i<=j:\n        if s[i]!=s[j]:\n            p=False\n            break\n        i+=1\n        j-=1\n    return p\n\nans=0\nfor i in range(len(s)):\n    for j in range(len(s)-1, i,-1):\n        if not palindrome(s[i:j+1]):\n            ans=max(ans, len(s[i:j+1]))\n            break\n\nprint(ans)","output":"linear"},{"instruction":"import math\nres = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0]\nn = int(input())\nprint(res[n] * math.factorial(n) % (10 ** 9 + 7))","output":"np"},{"instruction":"n = int(input())-1\nx, y = 1, 9\nwhile n > x * y: n,x,y = n-x*y,x+1,y*10\na = str(10 ** (x - 1) + n \/\/ x)[n%x]\nprint(a)","output":"logn"},{"instruction":"n,m,k=map(int,input().split())\np=list(map(int,input().split()))\ncount=0\ndelete=0\nnow=0\nwhile now<m:\n    up=((p[now]-delete-1)\/\/k+1)*k+delete\n    while now<m and p[now]<=up:\n        now+=1\n        delete+=1\n    count+=1\nprint(count)","output":"linear"},{"instruction":"import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom heapq import heappush,heappop,heapify\nfrom itertools import permutations,combinations\nfrom itertools import accumulate as ac\nmod = int(1e9)+7\n\nip = lambda : int(stdin.readline())\ninp = lambda: map(int,stdin.readline().split())\nips = lambda: stdin.readline().rstrip()\nout = lambda x : stdout.write(str(x)+\"\\n\")\n\nt = 1\nfor _ in range(t):\n    q = \"? {} {}\".format(0,0)\n    print(q,flush = True)\n    cond = ip()\n    cur_a = 0\n    cur_b = 0\n    for i in range(29,-1,-1):\n        xor = (1<<i)\n        query_a = cur_a^xor\n        query_b = cur_b^xor\n        q = \"? {} {}\".format(query_a,query_b)\n        print(q,flush = True)\n        val = ip()\n        if val != cond:\n            if cond == -1 and val == 1:\n                cur_b ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n            else:\n                cur_a ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n        else:\n            cond = val\n            query_a = cur_a^xor\n            query_b = cur_b\n            q = \"? {} {}\".format(query_a,query_b)\n            print(q,flush = True)\n            val = ip()\n            if val == -1:\n                cur_a ^= xor\n                cur_b ^= xor\n            else:\n                pass\n    ans = \"! {} {}\".format(cur_a,cur_b)\n    print(ans,flush = True)","output":"constant"},{"instruction":"from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nR,G,B=nii()\nr=lnii()\ng=lnii()\nb=lnii()\n\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\ndp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]\n\nfor i in range(R+1):\n  for j in range(G+1):\n    for k in range(B+1):\n      c=False\n      if i<R and j<G:\n        dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j])\n        c=True\n      if j<G and k<B:\n        dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k])\n        c=True\n      if k<B and i<R:\n        dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i])\n        c=True\n\n      if not c:\n        if i<R:\n          dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k])\n        if j<G:\n          dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k])\n        if k<B:\n          dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k])\n\nans=0\nfor i in dp:\n  for j in i:\n    ans=max(ans,max(j))\n\nprint(ans)","output":"cubic"},{"instruction":"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)\n\ndef main():\n\tdef ask(c, d):\n\n\t\tprint(\"?\", c, d, flush = True)\n\t\treturn int(input())\n\n\trelative = ask(0, 0)\n\tcurA = 0\n\tcurB = 0\n\n\tfor i in range(29, -1, -1):\n\t\tq1 = ask(curA ^ 2 ** i, curB)\n\t\tq2 = ask(curA, curB ^ 2 ** i)\n\n\t\tif q1 == q2:\n\t\t\tif relative == 1:\n\t\t\t\tcurA ^= 2 ** i\n\t\t\telse:\n\t\t\t\tcurB ^= 2 ** i\n\t\t\trelative = q1\n\t\telif q2 == 1:\n\t\t\tcurA ^= 2 ** i\n\t\t\tcurB ^= 2 ** i\n\treturn curA, curB\nprint(\"!\", *main())","output":"logn"},{"instruction":"from math import sqrt\nn, r = input().split()\nn = int(n)\nr = int(r)\nx = []\narr = []\ninpArr = input().split(\" \")\nfor i in inpArr:\n    x.append(int(i))\n\nfor i in range(n):\n    arr.append(r)\n    for j in range(i):\n        if (abs(x[j] - x[i]) <= (r * 2)):\n            arr[i] = max(arr[i], (arr[j] + sqrt((r*r*4)-((x[j] - x[i])*(x[j] - x[i])))  ))\narr1 = []\nfor i in arr:\n    arr1.append(str(i))\nprint(\" \".join(arr1))","output":"quadratic"},{"instruction":"import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue\n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: flag = True;break\n    if not flag:  prime.append(i)\ndef primefactor(num):\n    index = 0;output = []\n    while num>=prime[index]**2:\n        times = 0\n        while num%prime[index]==0:num = num \/\/ prime[index];times += 1\n        if times&1:  output.append(prime[index])\n        index += 1\n    if num>1: output.append(num)\n    return tuple(output)\nfor _ in range(int(input())):\n    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:            bisect.insort(stack,fact[factor]+1)\n        fact[factor] = i\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)\n    print(dp[-1][-1])","output":"cubic"},{"instruction":"print(\"? 0 0\")\nt = int(input())\nA=[]\nB=[]\na=0\nb=0\nfor i in range(30):\n    A.append(-1)\n    B.append(-1)\ni = 29\nd = 2**i\nwhile i>=0:\n    a+=d\n    b+=d\n    print(\"?\", end=' ')\n    print(a, end=' ')\n    print(b)\n    s=int(input())\n    if s == -t:\n        if s==1:\n            A[i]=0\n            B[i]=1\n            b-=d\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n        elif s==-1:\n            A[i]=1\n            a-=d\n            B[i]=0\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n    i-=1\n    d\/\/=2\nd=1\nfor j in range(30):\n    if A[j]==-1:\n        a = a^d\n        print(\"?\", end=' ')\n        print(a, end=' ')\n        print(b)\n        s = int(input())\n        if s==1:\n            A[j]=1\n            B[j]=1\n        else:\n            A[j]=0\n            B[j]=0\n        a = a^d\n    d*=2\nd=1\na=0\nb=0\nfor i in range(30):\n    a+=d*A[i]\n    b+=d*B[i]\n    d*=2\nprint(\"!\", end=' ')\nprint(a, end=' ')\nprint(b)","output":"logn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\ns=sum(a)\nnew=0\ni=0\nwhile 2*(new+a[i])<s:\n    new+=a[i]\n    i+=1\nprint(i+1)","output":"linear"},{"instruction":"n, m = list(map(int, input().split()))\ntemp = 0\na = [list(input()) for i in range(n)]\nfor i in range(n):\n    ok = False\n    for j in range(m):\n        if (a[i][j] == \"B\"):\n            pos1 = i\n            pos2 = j\n            temp += 1\n            temp2 = j\n            if (j != m-1):\n                ok = True\n                while True:\n                    ok2 = False\n                    if (temp2 == m-1):\n                        ok2 = True\n                        break\n                    if (a[i][temp2 + 1] != \"B\"):\n                        ok2 = True\n                        break\n                    temp += 1\n                    temp2 += 1\n            elif (j == m - 1):\n                temp = 1\n                ok = True\n                break\n            if (ok2):\n                break\n    if (ok):\n        break\nprint(temp\/\/2 + pos1 + 1, temp\/\/2 + pos2 + 1)","output":"quadratic"},{"instruction":"import sys\nn,m=map(int,input().split())\nfor i in range(n\/\/2):\n    for j in range(m):\n        sys.stdout.write('{} {}\\n'.format(*[i+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n-i,m-j]))\nif n%2:\n    for j in range(m\/\/2):\n        sys.stdout.write('{} {}\\n'.format(*[n\/\/2+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n\/\/2+1,m-j]))\n    if m%2:\n        sys.stdout.write('{} {}\\n'.format(*[n\/\/2+1,m\/\/2+1]))","output":"quadratic"},{"instruction":"import math\n\ndef field(n, x, y, t):\n    t = t + 1\n    upper_dist = x - 1\n    left_dist = y - 1\n    down_dist = n - x\n    right_dist = n - y\n    out_up = max(0, t - upper_dist - 1)\n    out_down = max(0, t - down_dist - 1)\n    out_left = max(0, t - left_dist - 1)\n    out_right = max(0, t - right_dist - 1)\n\n    field = base_field(t) - right_field(out_right) - right_field(out_left) - up_field(out_up, n, y) - up_field(out_down, n, y)\n    return field\n\ndef right_field(out_r):\n    return out_r ** 2\n\ndef up_field(out_up, n, y):\n    rect = max(0, out_up - n + 1)\n    h = out_up - rect\n    wyst = max(y - 1 + h - n, 0, h - y)\n    result = n * rect + h ** 2 - int((1 + wyst) \/ 2 * wyst)\n    if result < 0:\n        result = 0\n    return result\n\ndef base_field(t):\n    return 2 * (t ** 2) - 2 * t + 1\n\nclass CodeforcesTask256BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n_x_y_c = []\n\n    def read_input(self):\n        self.n_x_y_c = [int(x) for x in input().split(\" \")]\n\n    def process_task(self):\n        search = 0\n        mid = 1\n        found = False\n        last_sm = 0\n        while not found:\n\n            ff = field(self.n_x_y_c[0], self.n_x_y_c[1], self.n_x_y_c[2], search)\n            if ff == self.n_x_y_c[3]:\n                found = True\n            elif ff > self.n_x_y_c[3]:\n                if search - last_sm == 1:\n                    found = True\n                else:\n                    search = last_sm + (search - last_sm) \/\/ 2\n            else:\n                last_sm = search\n                search += mid\n                mid = search - last_sm\n        self.result = str(search)\n\n    def get_result(self):\n        return self.result\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask256BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())","output":"logn"},{"instruction":"n = int(input())\na = sorted((input() for _ in range(n)), key=lambda x: len(x))\nv = all(a[i] in a[i+1] for i in range(n-1))\nprint('YES\\n'+\"\\n\".join(a) if v else 'NO')","output":"nlogn"},{"instruction":"from collections import Counter\n\ndef mx(f):\n    res = []\n    for k in sorted(f.keys(), reverse=True):\n        for _ in range(f[k]):\n            res.append(k)\n    return res\n\ndef solve(n, a, b):\n    res = None\n    for k in range(n + 1):\n        aa = Counter(a)\n        cur = []\n        for i in range(k):\n            if aa[b[i]] == 0:\n                return res\n            cur.append(b[i])\n            aa[b[i]] -= 1\n        if k < n:\n            for e in range(b[k] - 1, -1, -1):\n                if aa[e] > 0:\n                    cur.append(e)\n                    aa[e] -= 1\n                    cur.extend(mx(aa))\n                    break\n            if len(cur) < n:\n                continue\n        res = cur\n    return res\n\na = Counter(map(int, input()))\nb = list(map(int, input()))\nif sum(a.values()) < len(b):\n    res = mx(a)\nelse:\n    res = solve(len(b), a, b)\nprint(''.join(map(str, res)))","output":"cubic"},{"instruction":"n = int(input())\nmaxlength = 12\n\nlengths = [1]\nfor i in range(1, maxlength+1):\n    lengths.append(lengths[i-1]+9*i*(10**(i-1)))\n\ndef getnum(n):\n    global lengths\n    mx = maxlength - 1\n    mn = 0\n    while 1:\n        chk = (mx - mn) \/\/ 2\n        if chk == 0:\n            break\n        chk += mn\n        if n < lengths[chk]:\n            mx = chk\n        else:\n            mn = chk\n    curlength = mx\n    curlength_ind = n - lengths[curlength - 1]\n    curdigind = curlength_ind % curlength\n    beforenumscount = curlength_ind \/\/ curlength\n    result = 0 + (beforenumscount \/\/ (10 ** (curlength - curdigind - 1)) + (curdigind == 0)) % 10\n    return result\n\nprint(getnum(n))","output":"logn"},{"instruction":"def solve(n, a):\n    a = sorted(a)\n    if n == 1:\n        return a[0] > 0 and a[0] % 2 == 1\n    same_count = 0\n    for i in range(n - 1):\n        if a[i] == a[i + 1] == 0:\n            return False\n        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:\n            return False\n        if a[i] == a[i + 1]:\n            same_count += 1\n    if same_count > 1:\n        return False\n    return (sum(a) - n * (n - 1) \/\/ 2) % 2 == 1\n\nassert not solve(1, [0])\nassert not solve(2, [1, 0])\nassert solve(2, [2, 2])\nassert solve(3, [2, 3, 1])\nassert not solve(4, [1, 1, 2, 2])\nassert solve(4, [1, 1, 2, 3])\nassert not solve(4, [1, 2, 3, 4])\nassert solve(4, [0, 1, 2, 4])\nassert solve(5, [0, 1, 2, 3, 5])\n\nn = int(input())\na = map(int, input().split())\n\nr = solve(n, a)\nif r:\n\n    print('sjfnb')\nelse:\n    print('cslnb')","output":"nlogn"},{"instruction":"x,k=map(int,input().split())\nmod=1000000007\nprint((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)","output":"logn"},{"instruction":"from sys import stdin\n\nn, k = map(int, stdin.readline().split())\nout = [['.'] * n for _ in range(4)]\nif k & 1:\n    out[1][n >> 1] = '\n    k -= 1\n\nfor i in range(1, 3):\n    l, r = 1, n - 2\n    for j in range(1, n - 2):\n        if k:\n            k -= 1\n            if j & 1:\n                out[i][l] = '\n                l += 1\n            else:\n                out[i][r] = '\n                r -= 1\n\nfor i in range(1, 3):\n    if k:\n        k -= 1\n        out[i][n >> 1] = '\nprint('YES\\n%s' % ('\\n'.join([''.join(x) for x in out])))","output":"linear"},{"instruction":"a,b = map(int,input().split())\nd = list(map(int,input().split()))\ne = []\ne1= []\nmx = 0\ncurrent = 0\nfor i in range(len(d)):\n    if i%2 == 0:\n        e.append(d[i]-current)\n    else:\n        e1.append(d[i]-current)\n    current=d[i]\nif i%2 == 0:\n    e1.append(b-current)\nelse:\n    e.append(b-current)\nmx = sum(e)\nsu = 0\nsu2 = sum(e1)\nfor i in range(len(e)):\n    su+=e[i]\n    mx = max(mx,su+su2-1)\n    try:\n        su2-=e1[i]\n    except:\n        break\nprint(mx)","output":"linear"},{"instruction":"k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)\/\/i)+10**(i-1))[(k-r)%i]\nprint(ans)","output":"logn"},{"instruction":"a=[i for i in input()]\nb=int(input())\na.sort(reverse=True)\nans = ''\nwhile len(a) > 0:\n    for i in range(len(a)):\n        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))\n        if int(tmp) <= b:\n            ans += a[i]\n            a = a[:i] + a[i + 1:]\n            break\nprint(ans)","output":"cubic"},{"instruction":"n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n-1)]\n\nif k % 2 == 1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\nk \/\/= 2\n\nINF = 10**18\ndp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor v in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            now_h, now_w = i, j\n            if i > 0:\n                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])\n            if i < n-1:\n                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])\n            if j > 0:\n                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])\n            if j < m-1:\n                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])\n\nfor i in range(n):\n    v = []\n    for j in range(m):\n        v.append(dp[i][j][k]*2)\n    print(*v)","output":"cubic"},{"instruction":"n, m = map(int, input().split())\ns = 0\nwhile m:\n    s += n \/\/ m\n    n, m = m, n % m\nprint(s)","output":"constant"},{"instruction":"import math\nn,t=map(int,input().split())\nl=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    x=a-b\/2\n    y=a+b\/2\n    l.append([x,y])\nl.sort()\nc=0\n\nfor i in range(n-1):\n    if(l[i+1][0]-l[i][1]>t):\n        c+=2\n    elif(l[i+1][0]-l[i][1]==t):\n        c+=1\nprint(c+2)","output":"nlogn"},{"instruction":"s = input()\nsLen, ans = len(s), 0\n\nfor i in range(sLen):\n    for till1 in range(i + 1, sLen + 1):\n        till2 = till1 + 1\n        for j in range(i + 1, sLen):\n            if till2 > sLen:\n                break\n            sub1 = s[i:till1]\n            sub2 = s[j:till2]\n            subLen = len(sub1)\n            if sub1 == sub2 and ans < subLen:\n                ans = subLen\n            till2 += 1\n\nprint(ans)","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n\n        return self.to_sum(j) - self.to_sum(i - 1)\n\ndef f(x, V):\n    if x < V:\n        return -1\n    return 1\n\ndef calc_median(M):\n    b = [f(v, M) for v in a]\n    res = 0\n    c = [0]\n    for x in b:\n        c.append(c[-1] + x)\n    d = [(c[i], i) for i in range(n + 1)]\n    bit = BIT(2*n + 10)\n    for value, index in d:\n        if index == 0:\n            bit.add(value + n + 1, 1)\n            continue\n        res += bit.get(1, value + n)\n        bit.add(value + n + 1, 1)\n\n    return res\n\nprint(calc_median(m) - calc_median(m + 1))","output":"nlogn"},{"instruction":"[n, l, r, x] = list(map(int, input().strip().split()))\nCs = list(sorted(map(int, input().strip().split())))\nprobs = 0\n\nfor i in range(1, 2**n):\n    currsub = [ Cs[j] for j in range(n) if (i & (1 << j))]\n    probs += (len(currsub) > 1 and l <= sum(currsub) <= r and currsub[-1] - currsub[0] >= x)\n\nprint(probs)","output":"np"},{"instruction":"N = int(input())\nmap_1 = [list(input()) for i in range(N)]\nmap_2 = [list(input()) for i in range(N)]\n\nmaps = list()\n\nmaps.append([[map_2[i][j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[j][i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)])\n\nprint(('No', 'Yes')[any(map_1 == el for el in maps)])","output":"quadratic"},{"instruction":"n = int(input())\nax,ay = [int(s) for s in input().split()]\nbx,by = [int(s) for s in input().split()]\ncx,cy = [int(s) for s in input().split()]\nif ((bx-ax < 0 and cx-ax < 0 or\n    bx-ax > 0 and cx-ax > 0) and\n    (by-ay < 0 and cy-ay < 0 or\n    by-ay > 0 and cy-ay > 0)):\n        print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"from sys import stdin, stdout\nfrom collections import *\nfrom math import gcd, floor, ceil\ndef st(): return list(stdin.readline().strip())\n\ndef li(): return list(map(int, stdin.readline().split()))\ndef mp(): return map(int, stdin.readline().split())\ndef inp(): return int(stdin.readline())\ndef pr(n): return stdout.write(str(n)+\"\\n\")\n\nmod = 1000000007\nINF = float('inf')\n\ndef solve():\n    n = inp() - 1\n    pre = 0\n    cur = 1\n    point = 1\n    while pre + 9*cur*point < n:\n        pre += 9*cur*point\n        cur *= 10\n        point += 1\n    n -= pre\n    num, pos = divmod(n, point)\n    num += pow(10, point-1)\n    pr(str(num)[pos])\n\nfor _ in range(1):\n    solve()","output":"logn"},{"instruction":"import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\nfrom functools import lru_cache\n\nn,l,r,x = ilele()\nA = alele()\nA.sort()\n\n@lru_cache(None)\ndef fun(pos = 0,sm = -1,la = -1,tot = 0):\n    if pos == n:\n        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:\n            return 1\n        return 0\n    if sm == -1:\n        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)\n    elif la == -1:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n    else:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n\nprint(fun())","output":"np"},{"instruction":"from collections import defaultdict\nimport sys\nimport bisect\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\na=[int(i) for i in input().split()if i!='\\n']\nrem=[[] for i in range(m)]\nreq=n\/\/m\nans=0\nfor i in range(n):\n    rem[a[i]%m].append([a[i],i])\nind=m-1\nfor i in range(m):\n    size=len(rem[i])\n    if size>req:\n        ind=i\n    if size<req:\n        ok=False\n        for j in range(ind,ind-m,-1):\n            while len(rem[j])>req:\n                pop,_=rem[j].pop()\n                rem[i].append([pop+(i-j)%m,_])\n                if len(rem[i])==req:\n                    ok=True\n                    break\n            if ok:\n                break\n            ind-=1\n\nout=[0]*(n)\nfor i in rem:\n    for j in i:\n        out[j[1]]=j[0]\nprint(sum(out)-sum(a))\nout=' '.join(map(str,out))\nprint(out)","output":"linear"},{"instruction":"import sys\nfrom collections import defaultdict\n\nreader = (map(int, line.split()) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\n\nvals = set()\nlocs = defaultdict(list)\nfor i in range(n):\n    for pos, v in enumerate(input()):\n        vals.add(v)\n        locs[v].append((pos, i))\n\nmasks = [0] * n\nfull = (1<<m) - 1\nmet = {0:0}\nfor v in sorted(vals, reverse=True):\n    for pos, i in locs[v]:\n        curr_mask = masks[i] = masks[i] | (1<<pos)\n        met[curr_mask] = i\n        complement = full ^ curr_mask\n        if complement in met:\n            print(i+1, met[complement]+1)\n            sys.exit()","output":"np"},{"instruction":"import math\ndef mint(): return map(int, input().split())\nn, m, k = mint()\nhorizontal = [list(mint()) for i in range(n)]\nvertical = [list(mint()) for i in range(n-1)]\nif k%2 or max(n, m)==1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\ndp = [[[0]*(k\/\/2+1) for i in range(m)] for j in range(n)]\nfor length in range(1, k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n            right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n            top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n            bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\nfor i in range(n):\n    print(*[dp[i][j][k\/\/2]*2 for j in range(m)])","output":"cubic"},{"instruction":"USE_STDIO = False\n\nif not USE_STDIO:\n    try: import mypc\n    except: pass\n\ndef main():\n    n, k = map(int, input().split(' '))\n    ans = (k + n - 1) \/\/ n\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"class NextStringIndex:\n    def __init__(self, string):\n        self.INF = 10 ** 9\n        self.alph = \"abcdefghijklmnopqrstuvwxyz\"\n        self.kind = len(self.alph)\n        self.to_ind = {char: ind for ind, char in enumerate(self.alph)}\n\n        self.string = string\n        self.len_s = len(string)\n        self.next_ = self.make_next()\n\n    def __getitem__(self, tup):\n        ind, char = tup\n        return self.next_[ind][self.to_ind[char]]\n\n    def make_next(self):\n        dp = [[self.INF] * self.kind for i in range(self.len_s + 1)]\n        for i in range(len_s)[::-1]:\n            for j, char in enumerate(self.alph):\n                if s[i] == char:\n                    dp[i][j] = i + 1\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp\n\ndef solve(t1, t2, len_s):\n    INF = 10 ** 9\n    len_t1 = len(t1)\n    len_t2 = len(t2)\n    dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)]\n    dp[0][0] = 0\n\n    for i in range(len_t1 + 1):\n        for j in range(len_t2 + 1):\n            length = dp[i][j]\n            if length > len_s:\n                continue\n            if i < len_t1 and s_next[length, t1[i]] < INF:\n                dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]])\n            if j < len_t2 and s_next[length, t2[j]] < INF:\n                dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]])\n\n    return dp[-1][-1] < INF\n\nquery = int(input())\nfor _ in range(query):\n    s = input()\n    t = input()\n    len_s = len(s)\n    len_t = len(t)\n\n    s_next = NextStringIndex(s)\n\n    flag = False\n    for i in range(len_t + 1):\n        flag |= solve(t[0:i], t[i:], len_s)\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"s = map(int, raw_input().rstrip().split())\nn = s[0]\nv = s[1]\n\nprimo = min(n -1, v)\nif primo == n-1:\n    print(primo)\nelse:\n    rimane = n - primo\n    print(primo - 1 + (rimane)*(rimane + 1) \/ 2)","output":"constant"},{"instruction":"n = int(input())\nabove = n \/\/ 3\nbelow = n - above\nfor i in range(above):\n    print(2 * i + 1, 3)\nfor i in range(below):\n    print(i, 0)","output":"linear"},{"instruction":"n, U = list(map(int, input().split()))\nE = list(map(int, input().split()))\n\nind_i = 0\nprev_ind_k = ind_i + 2\n\nmaxi_efficiency = -1\nturn = 0\nfor ind_i in range(0, n - 2):\n    ind_j = ind_i + 1\n    prev_ind_k = max(prev_ind_k, ind_i + 2)\n    Ei = E[ind_i]\n    Ej = E[ind_j]\n    for ind_k in range(prev_ind_k, n + 1):\n\n        if ind_k == n:\n            prev_ind_k = n - 1\n            break\n        Ek = E[ind_k]\n        if (Ek - Ei) > U:\n            prev_ind_k = ind_k - 1\n            break\n\n        efficiency = (Ek - Ej) \/ (Ek - Ei)\n\n        if efficiency > maxi_efficiency:\n\n            maxi_efficiency = efficiency\n\nprint(maxi_efficiency)","output":"nlogn"},{"instruction":"from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,d=lst()\n    a=sorted(lst())\n    s=set()\n    for i in range(n):\n        x=a[i]-d\n        left=a[i-1] if i>=1 else float('inf')\n        if abs(x-left)>=d:s.add(x)\n        x=a[i]+d\n        right=a[i+1] if i+1<n else float('inf')\n        if abs(x-right)>=d:s.add(x)\n    print(len(s))","output":"linear"},{"instruction":"def naiveSolve():\n\n    return\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList):\n    def __init__(self, arg):\n        super().__init__(arg)\n    def rangeCountByValue(self, leftVal, rightVal):\n        leftCummulative = self.bisect_left(leftVal)\n        rightCummulative = self.bisect_left(rightVal + 1)\n        return rightCummulative - leftCummulative\n\nfrom collections import Counter\n\ndef main():\n\n    n=int(input())\n    a=readIntArr()\n\n    cnts=Counter(a)\n    ol=OrderedList([v for v in cnts.values()])\n    ol.add(0)\n    canMakeFirstMove=False\n    for x in a:\n        if x>0:\n            c=cnts[x]\n            ol.remove(c)\n            ol.add(c-1)\n            d=cnts[x-1]\n            ol.remove(d)\n            ol.add(d+1)\n\n            if ol[-1]==1:\n                canMakeFirstMove=True\n                break\n            ol.add(c)\n            ol.remove(c-1)\n            ol.add(d)\n            ol.remove(d+1)\n    if canMakeFirstMove==False:\n        print('cslnb')\n    else:\n\n        target=(n*(n-1))\/\/2\n        if (sum(a)-target)%2==0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n\n    return\n\nimport sys\n\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n    return [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory,dimensionArr):\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n\ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n\ninf=float('inf')\nMOD=10**9+7\n\nfrom math import gcd,floor,ceil\n\nfor _abc in range(1):\n    main()","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nmax_el = -1;\ner = -1;\nfor i in range(len(a)):\n    if a[i] - max_el > 1:\n        er = i + 1;\n        break\n    if a[i] > max_el:\n        max_el = a[i]\n\nprint(er)","output":"linear"},{"instruction":"a, b, c, n = map(int, input().split())\nt = a+b-c\nif c > a or c > b:\n    print(-1)\n    exit()\nif n-t >= 1:\n    print(n-t)\nelse:\n    print(-1)","output":"constant"},{"instruction":"M = 0x3b800001\nwa = 0;\nn = int(input())\na = list(map(int, input().split()))\nnow = 1\nwa += a[-1]\nfor i in range(n - 1)[::-1]:\n    wa += (now * (n - i - 1) + now * 2) * a[i]\n    wa %= M\n    now *= 2\n    now %= M\nprint(wa % M)","output":"linear"},{"instruction":"n = int(input())\na = input()\nsum = 0\nfor x in a:\n    sum += int(x)\nans = \"NO\"\nif sum == 0:\n    ans = \"YES\"\ns = 1\nwhile s * s <= sum and ans == \"NO\":\n    if sum % s == 0:\n        t = 0\n        flag = 0\n        for x in a:\n            t += int(x)\n            if t == s:\n                flag = 1\n            if t > s:\n                if flag == 1:\n                    flag = 0\n                    t = int(x)\n                    if t == s:\n                        flag = 1\n        if t == s and t != sum:\n            ans = \"YES\"\n        t = 0\n        flag = 0\n        for x in a:\n            t += int(x)\n            if t == sum \/\/ s:\n                flag = 1\n            if t > sum \/\/ s:\n                if flag == 1:\n                    flag = 0\n                    t = int(x)\n                    if t == sum \/\/ s:\n                        flag = 1\n        if t == sum \/\/ s and t != sum:\n            ans = \"YES\"\n    s += 1\nprint(ans)","output":"quadratic"},{"instruction":"base=998244353;\ndef power(x, y):\n    if(y==0):\n        return 1\n    t=power(x, y\/\/2)\n    t=(t*t)%base\n    if(y%2):\n        t=(t*x)%base\n    return t;\ndef inverse(x):\n    return power(x, base-2)\nft=[0]\nfor i in range(0, 200000):\n    ft.append(0)\ndef get(i):\n    res=0\n    while(i<=200000):\n        res+=ft[i]\n        i+=i&-i\n    return res\ndef update(i, x):\n    while(i):\n        ft[i]+=x\n        i-=i&-i\nn=int(input())\na=[0]\na+=list(map(int, input().split()))\nneg=[0]\nnon=[0]\nfor i in range(1, n+1):\n    non.append(0)\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        non[a[i]]+=1\nfor i in range(1, n+1):\n    non[i]+=non[i-1]\nfor i in range(1, n+1):\n    if(a[i]==-1):\n        neg.append(neg[i-1]+1)\n    else:\n        neg.append(neg[i-1])\nm=neg[n]\nans=0\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        ans+=get(a[i])\n        update(a[i], 1)\nfm=1\nfs=fm\nfor i in range(1, m+1):\n    fs=fm\n    fm=(fm*i)%base\nfs=(fs*inverse(fm))%base\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        less=a[i]-non[a[i]]\n        more=m-less\n        ans=(ans+neg[i]*more*fs)%base\n        ans=(ans+(m-neg[i])*less*fs)%base\nans=(ans+m*(m-1)*inverse(4))%base\nprint(ans)","output":"nlogn"},{"instruction":"A,B=map(int,input().split())\nx,y,z=map(int,input().split())\nsumm=0\ny1=0\nb1=0\ny1=(x*2)+y\n\nb1=y+(3*z)\n\nsumm=0\nif y1>A:\n\tsumm+=y1-A\nif b1>B:\n\tsumm+=b1-B\nprint(summ)","output":"constant"},{"instruction":"import sys\nfrom collections import OrderedDict\n\ndef sum_from_two(x):\n\n    return x * (x + 1) \/\/ 2 - 1\n\ndef sum_last(k, x):\n\n    if x == 0:\n        return 1\n\n    return sum_from_two(k) - sum_from_two(k - x) - x + 1\n\ndef possible(n, k, x):\n    return sum_last(k, x) >= n\n\ndef main(n, k):\n    if n == 1:\n\n        return 0\n\n    if sum_last(k, k - 1) < n:\n        return -1\n\n    minimum = 1\n\n    maximum = k - 1\n    while minimum <= maximum:\n        if minimum == maximum:\n            return minimum\n        elif minimum == maximum - 1:\n            if possible(n, k, minimum):\n                return minimum\n            else:\n                return maximum\n\n        mid = (minimum + maximum) \/\/ 2\n        if possible(n, k, mid):\n\n            maximum = mid\n        else:\n\n            minimum = mid\n\nif __name__ == \"__main__\":\n    curr = None\n    for e, line in enumerate(sys.stdin.readlines()):\n        n, k = list(map(int, line.strip().split()))\n    print(main(n, k))","output":"logn"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\nindx = [0] * n\nwinners = [''] * n\n\nfor i, ai in enumerate(a):\n    indx[ai-1] = i\n\nfor ai in range(n, 0, -1):\n    i = indx[ai-1]\n    can_win = False\n\n    for j in range(i + ai, n, ai):\n        if a[j] > ai and 'B' == winners[j]:\n            can_win = True\n            break\n\n    if not can_win:\n        for j in range(i - ai, -1, -ai):\n            if a[j] > ai and 'B' == winners[j]:\n                can_win = True\n                break\n\n    if can_win:\n        winners[i] = 'A'\n    else:\n        winners[i] = 'B'\n\nprint(''.join(winners))","output":"quadratic"},{"instruction":"for _ in range(int(input())):\n    N, M = map(int, input().split())\n    X = [[int(a) for a in input().split()] for _ in range(N)]\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    dp = [[0] * (1<<N) for _ in range(M+1)]\n    for j in range(M):\n        for mask in range(1<<N):\n            maskpre = mask\n            while maskpre >= 0:\n                maskpre &= mask\n                ma = 0\n                for k in range(N):\n                    s = 0\n                    for i in range(N):\n                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:\n                            s += X[i-k][j]\n                    ma = max(ma, s)\n                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)\n\n                maskpre -= 1\n    print(dp[-1][-1])","output":"np"},{"instruction":"def examA():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N, M = LI()\n        if N%M!=0:\n            ans.append(\"NO\")\n        else:\n            ans.append(\"YES\")\n    for v in ans:\n        print(v)\n    return\n\ndef examB():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N = I()\n        A = LI()\n        A.sort()\n        ans.append(A[::-1])\n    for v in ans:\n        print(\" \".join(map(str,v)))\n    return\n\ndef examC():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N, K = LI()\n        A = LI()\n        sumA = sum(A)\n        if sumA==0:\n            ans.append(\"YES\")\n            continue\n        cur = 0\n        L = []\n        for i in range(100):\n            now = K**i\n            L.append(now)\n            cur += now\n            if cur>=sumA:\n                break\n        for i in range(N):\n            A[i] *= (-1)\n        heapify(A)\n\n        for l in L[::-1]:\n            if not A:\n                break\n            a = -heappop(A)\n            if a<l:\n                heappush(A, -a)\n            elif a>l:\n                heappush(A,-(a-l))\n        if not A or heappop(A)==0:\n            ans.append(\"YES\")\n        else:\n            ans.append(\"NO\")\n    for v in ans:\n        print(v)\n    return\n\ndef examD():\n    class combination():\n\n        def __init__(self, n, mod):\n            self.n = n\n            self.fac = [1] * (n + 1)\n            self.inv = [1] * (n + 1)\n            for j in range(1, n + 1):\n                self.fac[j] = self.fac[j - 1] * j % mod\n\n            self.inv[n] = pow(self.fac[n], mod - 2, mod)\n            for j in range(n - 1, -1, -1):\n                self.inv[j] = self.inv[j + 1] * (j + 1) % mod\n\n        def comb(self, n, r, mod):\n            if r > n or n < 0 or r < 0:\n                return 0\n            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod\n    N, M = LI()\n    ans = 0\n    if N==2:\n        print(ans)\n        return\n    C = combination(M,mod2)\n    for i in range(N-1,M+1):\n        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)\n\n        ans += cur\n        ans %= mod2\n    print(ans)\n    return\n\ndef examE():\n    N = I()\n    A = LI()\n    dp = [[-1]*(N+1) for _ in range(N+1)]\n    for i in range(N):\n        dp[i][i+1] = A[i]\n    for l in range(2, N + 1):\n        for i in range(N - l + 1):\n            for k in range(i + 1, i + l):\n                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:\n                    dp[i][i + l] = dp[i][k] + 1\n\n    L = [inf]*(N+1)\n    for i in range(1,N+1):\n        if dp[0][i]>=1:\n            L[i] = 1\n    for i in range(N):\n        for k in range(1, N - i + 1):\n            if dp[i][i + k] >= 1:\n                L[i + k] = min(L[i + k], L[i] + 1)\n\n    ans = L[N]\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nimport sys,copy,bisect,itertools,heapq,math,random\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nif __name__ == '__main__':\n    examE()","output":"cubic"},{"instruction":"n,m=map(int,input().split())\na=0\nwhile m:a+=n\/\/m;n,m=m,n%m\nprint(a)","output":"constant"},{"instruction":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n\n        for i in range(len(nums)):\n            cur = nums[i]\n            res = max(res, cur)\n            for j in range(i + 1, len(nums)):\n                cur *= nums[j]\n                res = max(res, cur)\n\n        return res","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import ceil\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfrom math import inf\n\nfor _ in range(int(input()) if not True else 1):\n\n    n, m = map(int, input().split())\n\n    a = []\n    for i in range(n):\n        a += [list(map(int, input().split()))]\n\n    alpha, omega = 0, 10**9\n    def solve(mid):\n        index = [-1] * (1 << m)\n        for i in range(n):\n            val = 0\n            for j in range(m):\n                if a[i][j] >= mid:\n                    val += (1 << j)\n            index[val] = i + 1\n        pos = False\n        for mask in range(1 << m):\n            for mask2 in range(1 << m):\n                if mask | mask2 != (1 << m) - 1: continue\n                if min(index[mask], index[mask2]) != -1:\n                    pos = (index[mask], index[mask2])\n                    break\n        return pos\n    while alpha < omega:\n        mid = (alpha + omega + 1) \/\/ 2\n        if solve(mid):\n            alpha = mid\n        else:\n            omega = mid - 1\n    print(*solve(alpha))","output":"np"},{"instruction":"import sys\nimport random\nimport copy\nfrom itertools import permutations, combinations\nfrom math import sqrt, fabs, ceil\nfrom collections import namedtuple\n\nin_file_path = \"input.txt\"\noutput_file_path = \"output.txt\"\n\nSUBMIT = True\n\ndef get_array(x, initial=None):\n    dimension = len(x)\n    if dimension == 1:\n        return [copy.deepcopy(initial) for _ in range(x[0])]\n    else:\n        return [get_array(x[1:], initial) for _ in range(x[0])]\n\ndef read_num(fin, num_type=int):\n    tmp_list = [num_type(x) for x in fin.readline().strip().split()]\n    if len(tmp_list) == 1:\n        return tmp_list[0]\n    else:\n        return tuple(tmp_list)\n\ndef read_num_list(fin, num_type=int):\n    return [num_type(x) for x in fin.readline().strip().split()]\n\ndef solve(fin):\n    n = read_num(fin)\n    f = read_num_list(fin)\n    new_f = [0] + f\n    for i in range(0, n):\n        new_f[i] -= 1\n    f = new_f\n\n    chs = get_array([n], [])\n    for i, p in enumerate(f):\n        if p >= 0:\n            chs[p].append(i)\n\n    q = [x for x in range(0, n) if not chs[x]]\n    vis = [0] * n\n    count = [0] * n\n    while q:\n        x = q.pop(0)\n        if not chs[x]:\n            count[x] = 1\n        if f[x] >= 0:\n            vis[f[x]] += 1\n\n            if vis[f[x]] == len(chs[f[x]]):\n                q.append(f[x])\n            count[f[x]] += count[x]\n\n    count = sorted(count)\n    print(' '.join([str(x) for x in count]))\n\nif __name__ == '__main__':\n    if SUBMIT:\n        solve(sys.stdin)\n    else:\n        solve(open(in_file_path, 'r'))","output":"linear"},{"instruction":"import sys\n\ndef inn(a,b):\n\treturn (a[0] <= b[0] and b[1] <= a[1])\n\nn = int(input())\n\nseg = []\n\na,b = map(int,input().split())\nseg.append((a,b,1))\n\nfor i in range(2,n+1):\n\ta,b = map(int,input().split())\n\tseg.append((a,b,i))\n\nseg.sort(key=lambda x : (x[0],-x[1]))\n\nmain = seg.pop(0)\n\nfor i in seg:\n\tif inn(main,i):\n\t\tprint(i[2],main[2])\n\t\tsys.exit(0)\n\tif main[1] < i[1]:\n\t\tmain = i\n\nprint(-1,-1)","output":"nlogn"},{"instruction":"import sys\nimport math\nfrom math import *\nfrom collections import Counter,defaultdict\nfrom io import BytesIO, IOBase\nfrom collections import deque\n\ndef rec(i,j,k):\n\tif (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):\n\t\treturn 0\n\tif dp[i][j][k] != -1:\n\t\treturn dp[i][j][k]\n\telse:\n\t\tx = r[i]*b[j]\n\t\ty = b[j]*g[k]\n\t\tz = r[i] * g[k]\n\t\tif x>0:\n\t\t\tx += rec(i+1,j+1,k)\n\t\tif y>0:\n\t\t\ty += rec(i,j+1,k+1)\n\t\tif z>0:\n\t\t\tz += rec(i+1,j,k+1)\n\n\t\tdp[i][j][k] = max(x,y,z)\n\t\treturn dp[i][j][k]\n\ndef main():\n\tglobal r,g,b,rl,bl,gl,dp\n\n\trl,bl,gl = list(map(int, input().split()))\n\tr = list(map(int, input().split())) + [0]\n\tb = list(map(int, input().split())) + [0]\n\tg = list(map(int, input().split())) + [0]\n\tcnt =3\n\ti =j = k = 0\n\tans = 0\n\tdp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)]\n\tr.sort(reverse = True)\n\tb.sort(reverse = True)\n\tg.sort(reverse = True)\n\n\tprint(rec(i,j,k))\n\nmain()","output":"cubic"},{"instruction":"n = int(input())\nbx, by = map(int, input().split())\nax, ay = map(int, input().split())\ncx, cy = map(int, input().split())\nnum1 = ax > bx\nnum3 = cx > bx\nnum2 = ay > by\nnum4 = cy > by\nif num1 == num3 and num2 == num4:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\n\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    s = list(map(lambda x: x-97, ns()))\n    t = list(map(lambda x: x-97, ns()))\n    n, m = len(s), len(t)\n    nxt = [[n+1]*26 for _ in range(n+2)]\n    for i in range(n-1, -1, -1):\n        nxt[i] = nxt[i+1][:]\n        nxt[i][s[i]] = i\n    for b in range(m):\n        t1 = t[:b]\n        t2 = t[b:]\n        dp = [[n+1]*(m-b+1) for _ in range(b+1)]\n        dp[0][0] = 0\n        for j in range(b+1):\n            for k in range(m-b+1):\n                if j:\n                    dp[j][k] = min(dp[j][k], nxt[dp[j-1][k]][t1[j-1]] + 1)\n                if k:\n                    dp[j][k] = min(dp[j][k], nxt[dp[j][k-1]][t2[k-1]] + 1)\n\n        if dp[b][m-b] <= n:\n            print('YES')\n            return\n    print('NO')\n    return\n\nT = ni()\nfor _ in range(T):\n    solve()","output":"cubic"},{"instruction":"n= int(input())\nb = [int(_) for _ in input().split()]\nd = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)]\nfor l in range(1, n):\n\tfor s in range(n-l):\n\t\te = s + l\n\t\tfor m in range(s, e):\n\t\t\tif d[s][m] == d[m+1][e] and d[s][m] != -1:\n\t\t\t\td[s][e] = d[s][m] + 1\na = [1]\nfor e in range(1, n):\n\tt = 4096\n\tfor s in range(e+1):\n\t\tif d[s][e] != -1:\n\t\t\tt = min(t, ((a[s-1]+1) if s > 0 else a[s]))\n\ta.append(t)\nprint(a[-1])","output":"cubic"},{"instruction":"s = input()\nn,m = len(s),0\n\nfor i in range(n-1):\n    for j in range(i,n+1):\n        if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j])\n\nprint(m)","output":"cubic"},{"instruction":"import sys\n\ninput = sys.stdin.buffer.readline\n\ndef find_pair(candidate,data,m):\n    ans = (-1,-1)\n    binary_bit = [False for i in range(1 << m)]\n    for i in data:\n        bit_tmp = 0\n        for j in range(len(i)):\n            if i[j] >= candidate: bit_tmp |= 1 << j\n        binary_bit[bit_tmp] = True\n\n    for i in range(1 << m):\n        for j in range(1 << m):\n            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:\n                ans = i , j\n                break\n    return ans\n\ndef backtracking(candidate,ans,data):\n    idx_i = -1 ; idx_j = -1\n    for i in range(len(data)):\n        bit_tmp = 0\n        for j in range(len(data[i])):\n            if data[i][j] >= candidate: bit_tmp |= 1 << j\n        if bit_tmp == ans[0]: idx_i = i\n        if bit_tmp == ans[1]: idx_j = i\n\n    print(str(idx_i + 1) + \" \" + str(idx_j + 1))\n\ndef main():\n    n , m = [int(i) for i in input().split()]\n    data = [[int(i) for i in input().split()] for i in range(n)]\n    a = 0 ; b = 10**9 + 7\n    ans = (-1,-1)\n    candidate = -1\n    while a <= b:\n        mid = (a + b)\/\/2\n        bin_ans = find_pair(mid,data,m)\n        if bin_ans[0] != -1 and bin_ans[1] != -1:\n            ans = bin_ans\n            candidate = mid\n            a = mid + 1\n        else:\n            b = mid - 1\n    backtracking(candidate,ans,data)\n\nmain()","output":"np"},{"instruction":"import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\na = {0:0}\n\nfor i in range(n):\n    b = a.copy()\n    for p in a.items():\n        d = gcd(p[0], l[i])\n        cost = p[1] + c[i]\n        if d not in b: b[d] = cost\n        elif b[d] > cost: b[d] = cost\n    a = b.copy()\n\nif 1 not in a: a[1] = -1\nprint(a[1])","output":"np"},{"instruction":"import sys,bisect,string,math,time,functools,random,fractions\nfrom heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nfrom itertools import permutations,combinations,groupby\nrep=range;R=range\ndef Golf():n,*t=map(int,open(0).read().split())\ndef I():return int(input())\ndef S_():return input()\ndef IS():return input().split()\ndef LS():return [i for i in input().split()]\ndef MI():return map(int,input().split())\ndef LI():return [int(i) for i in input().split()]\ndef LI_():return [int(i)-1 for i in input().split()]\ndef NI(n):return [int(input()) for i in range(n)]\ndef NI_(n):return [int(input())-1 for i in range(n)]\ndef StoLI():return [ord(i)-97 for i in input()]\ndef ItoS(n):return chr(n+97)\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\ndef RA():return map(int,open(0).read().split())\ndef RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]\ndef RI(a=1,b=10):return random.randint(a,b)\ndef Rtest(T):\n    case,err=0,0\n    for i in range(T):\n        inp=INP()\n        a1,ls=naive(*inp)\n        a2=solve(*inp)\n        if a1!=a2:\n            print((a1,a2),inp)\n            err+=1\n        case+=1\n    print('Tested',case,'case with',err,'errors')\ndef GI(V,E,ls=None,Directed=False,index=1):\n    org_inp=[];g=[[] for i in range(V)]\n    FromStdin=True if ls==None else False\n    for i in range(E):\n        if FromStdin:\n            inp=LI()\n            org_inp.append(inp)\n        else:\n            inp=ls[i]\n        if len(inp)==2:\n            a,b=inp;c=1\n        else:\n            a,b,c=inp\n        if index==1:a-=1;b-=1\n        aa=(a,c);bb=(b,c);g[a].append(bb)\n        if not Directed:g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'\n\n    mp=[boundary]*(w+2);found={}\n    for i in R(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]\n    mp+=[boundary]*(w+2)\n    return h+2,w+2,mp,found\ndef TI(n):return GI(n,n-1)\ndef accum(ls):\n    rt=[0]\n    for i in ls:rt+=[rt[-1]+i]\n    return rt\ndef bit_combination(n,base=2):\n    rt=[]\n    for tb in R(base**n):s=[tb\/\/(base**bt)%base for bt in R(n)];rt+=[s]\n    return rt\ndef gcd(x,y):\n    if y==0:return x\n    if x%y==0:return y\n    while x%y!=0:x,y=y,x%y\n    return y\ndef YN(x):print(['NO','YES'][x])\ndef Yn(x):print(['No','Yes'][x])\ndef show(*inp,end='\\n'):\n    if show_flg:print(*inp,end=end)\n\nmo=10**9+7\ninf=float('inf')\nFourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))\nl_alp=string.ascii_lowercase\n\nread=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\nx,y,z=LI()\nR=sorted(LI())[::-1]\nG=sorted(LI())[::-1]\nB=sorted(LI())[::-1]\n\ndp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]\n\nn=x+y+z\nfor t in range(0,n+1,2):\n    for i in range(x+1):\n        for j in range(y+1):\n            k=t-i-j\n            if 0<=k<=z:\n                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])\n                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])\n                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])\n\nans=max([dp[i][y][z]for i in range(x+1)])\nans=max(max([dp[x][i][z]for i in range(y+1)]),ans)\nans=max(max([dp[x][y][i]for i in range(z+1)]),ans)\n\nprint(ans)","output":"cubic"},{"instruction":"n,k = list(map(int, input().split()))\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\nx = 0\nsumm = 0\nmaxx = 0\nfor i in range(n):\n  summ += a[i]*t[i]\nfor i in range(k):\n  if not t[i]:\n    x+=a[i]\nmaxx = max(maxx,x)\nfor i in range(n-k):\n  x+=a[i+k]*(1-t[i+k])\n  x-=a[i]*(1-t[i])\n  if x>maxx:\n    maxx=x\n\nprint(summ+maxx)","output":"linear"},{"instruction":"def bin_search(n):\n    if n==1:\n        return 1\n    l = 0;r = n;\n    while(r - 1 > l):\n\n        mid = (l+r)\/\/2\n\n        val = mid*(mid+1)\/\/2\n        if val == n:\n            return mid\n        elif val > n:\n            r = mid\n        else:\n            l = mid\n\n    return l\n\nn,k = [int(i) for i in input().split()]\n\nif k*(k-1)\/\/2 < n - 1:\n    print(-1)\n\nelif n == 1:\n    print(0)\nelif n <= k:\n    print(1)\n\nelse:\n    print(k - 1 - bin_search(k*(k-1)\/\/2 - n + 1))","output":"logn"},{"instruction":"def process(S):\n    n = len(S)\n    h_count = 0\n    answer = float('inf')\n    for c in S:\n        if c=='H':\n            h_count+=1\n    current = 0\n    for i in range(h_count):\n        if S[i]=='H':\n            current+=1\n    answer = min(answer, h_count-current)\n    for i in range(h_count, n+h_count):\n        if i > n-1:\n            i1 = i-n\n        else:\n            i1 = i\n        i2 = i-h_count\n        if S[i1]=='H':\n            current+=1\n        if S[i2]=='H':\n            current-=1\n        answer = min(answer, h_count-current)\n    return answer\n\nn = int(input())\nS = input()\nprint(process(S))","output":"linear"},{"instruction":"import string\nfrom collections import deque, Counter\nfrom functools import lru_cache\nimport math\n\nDEBUG = 0\n\ndef main():\n\n    T = 1\n    while T:\n        n, M = Input.read_typed(int)\n        N = n\n\n        f = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        comb = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        fact = [0] * (n+1)\n        inv = [0] * (n+1)\n        fact[0] = inv[0] = 1\n\n        for i in range(1, n+1):\n            fact[i] = (fact[i-1] * i) % M\n            inv[i] = pow(fact[i], M-2, M)\n\n        for i in range(0, n+1):\n            for j in range(0, i+1):\n\n                comb[i][j] = ((fact[i] * inv[j]) % M * inv[i-j]) % M\n\n        pow2 = [0] * (n+1)\n        pow2[0] = 1\n        for i in range(1, n+1):\n            pow2[i] = pow2[i-1]*2 % M\n            f[i][i] = pow2[i-1]\n\n        for total in range(1, n+1):\n            for manual in range(1, total):\n                if total > manual * 2 or total < manual: continue\n                for l in range(1, manual):\n                    f[total][manual] += f[total-l-1][manual-l] * pow2[l-1] * comb[manual][l]\n\n                    f[total][manual] %= M\n\n        c = 0\n        for i in range(1, n+1):\n            c += f[n][i]\n\n        print(c % M)\n        T -= 1\n\nclass Input:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def read_typed(cls):\n        return list(map(cls, input().split()))\n\n    @staticmethod\n    def read():\n        return input()\n\nclass Debug():\n    def __init__(self):\n        import sys\n        sys.stdout = open('output.out', 'w')\n        sys.stdin = open('input.in', 'r')\n\n    def __delete__(self):\n        sys.stdout.close()\n        sys.stdin.close()\n\ndef run():\n    if DEBUG: _ = Debug()\n    main()\n\nrun()","output":"cubic"},{"instruction":"def arr_inp():\n    return [int(x) for x in stdin.readline().split()]\n\ndef nCr(n, r):\n    f, m = factorial, 1\n    for i in range(n, n - r, -1):\n        m *= i\n    return int(m \/\/ f(r))\n\nfrom math import factorial\nfrom sys import stdin\n\nn, a, ans, tem = int(input()), arr_inp(), [], 0\nmem = [0] * (n + 1)\n\nfor i in range(n):\n    for j in range(a[i] - 1, 0, -1):\n        if not mem[j]:\n            tem += 1\n    mem[a[i]] = 1\n\nfor i in range(int(input())):\n    l, r = arr_inp()\n    tem += nCr(r - l + 1, 2)\n    ans.append('odd' if tem % 2 else 'even')\n\nprint('\\n'.join(ans))","output":"quadratic"},{"instruction":"import sys\nsys.setrecursionlimit(1000)\n\ndef estimate(a):\n    return int(((n - a) * (n + 1 - a)) \/ 2) - a\n\ndef dicho(lower, upper, target):\n    if estimate(lower) == target:\n        return lower\n    elif estimate(upper) == target:\n        return upper\n    else:\n        mid = (int)((lower + upper) \/ 2)\n        if(estimate(mid) < target):\n            upper = mid\n        else:\n            lower = mid\n        return dicho(lower, upper, target)\n\nn, k = map(int, input().split())\nlower = 0\nupper = n\nprint(dicho(lower, upper, k))","output":"logn"},{"instruction":"import math\nimport copy\ndef dtb(n):\n    return bin(n).replace(\"0b\",\"\")\ndef btd(n):\n    return int(n,2)\nt=1\nfor k in range(t):\n    n,kk=map(int,input().split())\n    a=list(map(int,input().split()))[:n]\n    c=copy.copy(a)\n    a.sort(reverse=True)\n    b=[]\n    f=[]\n    ans=0\n    for i in range(kk):\n        ans+=a[i]\n        b.append(a[i])\n    count=1\n    x=0\n    y=0\n    for i in range(n):\n        if len(f)==(kk-1):\n            y=i\n            break\n        if c[i] in b:\n            f.append(i-x+1)\n            x=i+1\n            b.remove(c[i])\n\n    f.append(n-y)\n    print(ans)\n    for i in f:\n        print(i,end=\" \")","output":"nlogn"},{"instruction":"def getsum(n):\n    return ((1 << (2*n)) - 1) \/\/ 3\n\ndef b(n, k):\n    l = n - 1\n    r = max(0, l - 41)\n    while True:\n        mid = (l + r) \/\/ 2\n        count = getsum(n - mid)\n        if count <= k:\n            l = mid\n        else:\n            r = mid\n        if l - r <= 1:\n            break\n        del count\n    g = getsum(n - r)\n    if g < k:\n        del g\n        return None\n    elif g == k:\n        del g\n        return r\n    return l\n\nt = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    min_side = b(n, k)\n    if min_side is None:\n        print('NO')\n        continue\n    k -= getsum(n - min_side)\n    if n == 2 and min_side == 1 and k == 2:\n        print('NO')\n        continue\n    num_squares = (1 << (n - min_side)) * 2 - 1\n    if k >= num_squares:\n        print('YES ' + str(min_side - 1))\n    else:\n        print('YES ' + str(min_side))","output":"logn"},{"instruction":"def main():\n    A,B = list(map(int, input().strip().split()))\n    yellow,green,blue = list(map(int, input().strip().split()))\n\n    yelreq = 0\n    blureq = 0\n\n    yelreq = 2*yellow\n\n    yelreq += green\n    blureq += green\n\n    blureq += 3*blue\n\n    reqs = 0\n    if A<yelreq:\n        reqs += yelreq - A\n    if B<blureq:\n        reqs += blureq - B\n\n    print(reqs)\n\nmain()","output":"constant"},{"instruction":"from collections import defaultdict as dd, deque as dq\nimport math, string\n\nimport sys\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\ndef solve():\n    N, K = getInts()\n    x = (-3 + math.sqrt(9+8*(N+K)))\/\/2\n    return int(x*(x+1)\/\/2 - K)\n\nprint(solve())","output":"logn"},{"instruction":"n, m, K = map(int, input().split())\nwh = [[0]*m for i in range(n)]\nwv = [[0]*m for i in range(n)]\n\nfor i in range(n):\n    t = list(map(int, input().split()))\n    for j in range(m-1):\n        wh[i][j] = t[j]\n\nfor i in range(n-1):\n    t = list(map(int, input().split()))\n    for j in range(m):\n        wv[i][j] = t[j]\n\nf = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        f[i][j][0] = 0\n\nfor k in range(1, K\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j])\n            if j < m-1:\n                f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j])\n            if i < n-1:\n                f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j])\n            if j > 0:\n                f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1])\n\nfor i in range(n):\n    for j in range(m):\n        if K%2 == 1:\n            print(-1)\n        else:\n            dp = [int(1e8)]*(K\/\/2+1)\n            dp[0] = 0\n            for k in range(1, K\/\/2+1):\n                for l in range(0, k):\n                    dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2)\n\n            print(dp[K\/\/2])","output":"cubic"},{"instruction":"import functools\nimport time\nfrom collections import Counter\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        n, m = map(int, input().strip().split())\n        a = list(map(int, input().strip().split()))\n        h = Counter()\n        for ai in a:\n            h[ai] = h[ai] + 1 if ai in h else 1\n        days = 0\n        while True:\n            tot = 0\n            for key, cnt in h.items():\n                tot += cnt \/\/ (days + 1)\n            if tot < n:\n                print(days)\n                return\n            days += 1\n\nsolver()()","output":"nlogn"},{"instruction":"import sys\nfrom array import array\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\nn = int(input())\nprob = [tuple(map(float, input().split())) for _ in range(n)]\nfull_bit = (1 << n) - 1\ndp = [0.0] * full_bit + [1.0]\n\nfor bit in range(full_bit, 0, -1):\n    popcount = len([1 for i in range(n) if (1 << i) & bit])\n    if popcount == 1 or dp[bit] == 0.0:\n        continue\n    div = 1 \/ ((popcount * (popcount - 1)) >> 1)\n\n    for i in range(n):\n        if ((1 << i) & bit) == 0:\n            continue\n        for j in range(i + 1, n):\n            if ((1 << j) & bit) == 0:\n                continue\n            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div\n            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div\n\nprint(*(dp[1 << i] for i in range(n)))","output":"np"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\nl,r=value()\nans=0\n\nR=len(bin(r))-2\n\nfor i in range(61):\n    if(l&(1<<i) ^ r&(1<<i)):\n        ans=2**(i+1)-1\n\nprint(ans)","output":"logn"},{"instruction":"def add(x,j):\n\tx = x % (1000000000+7)\n\tj=j % (1000000000+7)\n\treturn (x+j) % (1000000000+7)\n\nstatements = []\nn  =int(input())\ni=1\nj=1\ntemp = [[0 for i in range(n)] for i in range(n)]\nearlier = [[0 for i in range(n)] for i in range(n)]\ntemp[0][0]=1\nearlier[0][0]=1\n\nwhile(i<=n):\n\ts = input()\n\tstatements.append(s)\n\ti+=1\nwhile(j<n):\n\ttemp[0][j]=0\n\tearlier[0][j] = temp[0][j] + earlier[0][j-1]\n\tj+=1\ni=1\nwhile(i<n):\n\tif(statements[i-1]=='f'):\n\t\tj=1\n\t\twhile(j<n):\n\t\t\ttemp[i][0]=0\n\t\t\tearlier[i][0]=0\n\t\t\ttemp[i][j] = temp[i-1][j-1]\n\t\t\tearlier[i][j] = add(earlier[i][j-1],temp[i][j])\n\n\t\t\tj+=1\n\telse:\n\t\tj=0\n\t\twhile(j<n):\n\t\t\tif(j==0):\n\t\t\t\ttemp[i][j] = earlier[i-1][n-1]\n\t\t\telse:\n\t\t\t\ttemp[i][j] = earlier[i-1][n-1] - earlier[i-1][j-1]\n\t\t\tearlier[i][j] = add(earlier[i][j-1],temp[i][j])\n\t\t\tj+=1\n\ti+=1\n\nans = 0\nj=0\nwhile(j<n):\n\tans=add(ans,temp[n-1][j])\n\tj+=1\n\nprint(ans%(1000000000+7))","output":"quadratic"},{"instruction":"import sys, math\nfrom sys import stdin, stdout\n\nrem = 10 ** 9 + 7\ninf=10**18\nsys.setrecursionlimit(10 ** 6 + 7)\n\ntake = lambda: map(int, stdin.readline().split())\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque\nfrom bisect import *\n\nn,m=take()\narr=take()\ncheck=take()\ncnt=[0 for i in range(n+m)]\n\nleft=[-1 for i in range(n+m)]\nright=[-1 for i in range(n+m)]\nprev=-1\nfor i in range(n+m):\n    if check[i]==0:\n        left[i]=prev\n    else:\n        prev=i\nprev=-1\nfor i in range(n+m-1,-1,-1):\n    if check[i]==0:\n        right[i]=prev\n    else:\n        prev=i\nfor i in range(n+m):\n    if check[i]==1:\n        continue\n    a=left[i]\n    b=right[i]\n    if a==-1 and b==-1:\n        continue\n    if a==-1 and b!=-1:\n        cnt[b]+=1\n    if a!=-1 and b==-1:\n        cnt[a]+=1\n    if a!=-1 and b!=-1:\n        if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]):\n            cnt[a]+=1\n        else:\n            cnt[b]+=1\nans=[]\nfor i in range(n+m):\n    if check[i]==1:\n        ans.append(str(cnt[i]))\nstdout.write(' '.join(ans))","output":"linear"},{"instruction":"import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\n\nI=sys.stdin.readline\n\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\ndef ncr(n, r, p):\n\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef valid(row,col,rows,cols,rcross,lcross):\n \treturn rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0\n\ndef div(n):\n\ttmp=[]\n\tfor i in range(2,int(n**.5)+1):\n\t\tif n%i==0:\n\t\t\tcnt=0\n\t\t\twhile(n%i==0):\n\t\t\t\tn=n\/\/i\n\t\t\t\tcnt+=1\n\t\t\ttmp.append((i,cnt))\n\tif n>1:\n\t\ttmp.append((n,1))\n\treturn tmp\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\t\tflag=True\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\tflag=False\n\t\t\t\tbreak\n\t\treturn flag\n\ndef s(b):\n\tans=[]\n\twhile b>0:\n\t\ttmp=b%10\n\t\tans.append(tmp)\n\t\tb=b\/\/10\n\treturn ans\n\ndef main():\n\tn=ii()\n\tprint(n,0,0)\n\nif __name__ == '__main__':\n\tmain()","output":"constant"},{"instruction":"n, k = [int(i) for i in input().split()]\ndata = [int(i) for i in input().split()]\nspan = data[-1] - data[0]\ndelta = [data[i+1] - data[i] for i in range(n-1)]\ndelta.sort(reverse=True)\nprint(span - sum(delta[:k-1]))","output":"nlogn"},{"instruction":"import sys\n\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef rinput():   return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\nn,s=rinput()\nmaxi=s\nfor i in range(n):\n    f,t=rinput()\n    maxi=max(maxi,f+t)\n\nprint(maxi)","output":"linear"},{"instruction":"from math import factorial\n\ndef C(k, n):\n    return factorial(n) \/\/ factorial(k) \/\/ factorial(n - k)\n\ns1 = input()\ns2 = input()\nn1 = s1.count('+')\nn2 = s2.count('+')\nn3 = s2.count('?')\nif n2 > n1:\n    print(0)\nelse:\n    try:\n        print(C(n1 - n2, n3) \/ (2 ** n3))\n    except:\n        print(0)","output":"np"},{"instruction":"import math\nn,k = [int(x) for x in input().split(' ')]\nans = ((2*n + 3) - int(math.sqrt(8*n + 8*k + 9)))\/\/2\nprint(ans);","output":"constant"},{"instruction":"import math\ndef getx(n):\n    return math.floor(math.sqrt(n))\ndef getans(n,x):\n    l1=[i for i in range(n,0,-1)]\n    l2=[]\n    i=0\n    while(i<n):\n        l2=l2+sorted(l1[i:i+x])\n        i+=x\n    return l2\nn=int(input())\na=getx(n)\nans=getans(n,a)\nans1=[str(i) for i in ans]\nprint(' '.join(ans1))","output":"linear"},{"instruction":"n=int(input())\nprint((n+2)\/\/2)","output":"constant"},{"instruction":"a , b = input(), input()\nans = 0\n\nones = [0 for i in range(len(b)+1)]\nzeros = [0 for i in range(len(b)+1)]\n\nfor i in range(len(b)):\n    ones[i] = ones[i-1] + int(b[i])\n    zeros[i] = i + 1 - ones[i]\n\nfor i in range(len(a)):\n    if a[i] == '1':\n        ans += zeros[len(b)-len(a)+i] - zeros[i-1]\n\n    else:\n        ans += ones[len(b)-len(a)+i] - ones[i-1]\n\nprint(ans)","output":"linear"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nans=0\nwhile len(a)>0:\n    c=a.pop(0)\n    i=a.index(c)\n    ans+=i\n    del a[i]\nprint(ans)","output":"quadratic"},{"instruction":"def GSB(x):\n\tcounter=0\n\twhile x!=0:\n\t\tcounter+=1\n\t\tx=x>>1\n\treturn counter\n\nproblems,minimum,maximum,difference=[int(x) for x in input().split()]\narray=[int(x) for x in input().split()]\ncombinations=[int(x) for x in range(2**problems)]\ntotal=0\n\nfor i in combinations:\n\tchecker=[x for x in array]+['a']\n\tj=0\n\tz=GSB(i)\n\tcheck=1\n\twhile j!=z and i!=0:\n\t\tif i&1==1:\n\t\t\tchecker[j]='a'\n\t\t\tcheck+=1\n\t\ti=i>>1\n\t\tj+=1\n\tfor i in range(check):\n\t\tchecker.remove('a')\n\tchecker.sort()\n\tif minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference:\n\t\ttotal+=1\nprint(total)","output":"np"},{"instruction":"n = int(input())\narr = list(map(int, input().strip().split()))\nk = min(arr)\nh = max(arr)\ns = 0\nfor i in arr:\n    if i >= 0:\n        s += i\n    else:\n        s -= i\n\nif n == 1:\n    print(arr[0])\nelif ((k < 0 and h >= 0)):\n    print(s)\nelse:\n    if (k >= 0):\n        print(s - 2 * k)\n    else:\n        print(s + 2 * h)","output":"linear"},{"instruction":"import math\n\nn, r = map(int, input().split())\nangle = math.pi \/ n\ns = math.sin(angle)\n\nprint('%.8f' % (r * s \/ (1 - s)))","output":"constant"},{"instruction":"n, s = int(input()), input() * 2\nh = s.count('H') \/\/ 2\nprint(h - max(s[i:i + h].count('H') for i in range(n)))","output":"linear"},{"instruction":"m, n = map(int, input().split())\na = [int(input()) for q in range(m)]\na.append(10**9)\ns = []\nfor q in range(n):\n    f, g, d = map(int, input().split())\n    if f == 1:\n        s.append(g)\na.sort()\ns.sort()\nq1 = 0\nmin1 = float('inf')\nfor q2 in range(len(a)):\n    while q1 < len(s) and a[q2] > s[q1]:\n        q1 += 1\n    if min1 > q2+len(s)-q1:\n        min1 = q2+len(s)-q1\n    if q1 == len(s):\n        break\nprint(min1)","output":"nlogn"},{"instruction":"k,n,s,p=map(int,input().split(' '))\nif (1*n)%s==0:\n    need=(1*n)\/\/s\n    if need==0 and k%p==0:\n        print(k\/\/p)\n    elif (k*need)%p==0:\n        print((k*need)\/\/p)\n    else:\n        print(((k*need)\/\/p)+1)\nelse:\n    need=((1*n)\/\/s)+1\n    if need==0 and k%p==0:\n        print(k\/\/p)\n    elif (k*need)%p==0:\n        print((k*need)\/\/p)\n    else:\n        print(((k*need)\/\/p)+1)","output":"constant"},{"instruction":"games,bills = map(int,input().split())\ng = list(map(int,input().split()))\nb=list(map(int,input().split()))\ntotal = 0\ni=0\nj=0\n\nwhile(i < games and j < bills):\n    if g[i] <= b[j]:\n        total+=1\n        i+=1\n        j+=1\n    elif g[i] > b[j]:\n        i+=1\nprint(total)","output":"linear"},{"instruction":"def binary_search(n, k):\n    left = -1\n    right = n\n    while left < right - 1:\n        middle = (left + right) \/\/ 2\n        if middle % 2 != 0:\n            s = (1 + middle) * (middle \/\/ 2) + ((1 + middle) \/\/ 2)\n        else:\n            s = (1 + middle) * (middle \/\/ 2)\n        if s - (n - middle) >= k:\n            right = middle\n        else:\n            left = middle\n    return right\n\nn, k = map(int, input().split())\ni = 1\ncount = 0\nprint(n - binary_search(n, k))","output":"logn"},{"instruction":"import sys\n\ndef solve(n, m, grid):\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                continue\n            must = cell == 1\n            if i >= n - 2 or j >= m - 2:\n                if must:\n                    return 'NO'\n                continue\n            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:\n                if grid[i + di][j + dj] == 0:\n                    if must:\n                        return 'NO'\n                    break\n            else:\n                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:\n                    grid[i + di][j + dj] = 2\n                grid[i][j] = 2\n    return 'YES'\n\nn, m = list(map(int, input().split()))\ngrid = [['.\nprint(solve(n, m, grid))","output":"quadratic"},{"instruction":"t = input().split()\n\nt.sort()\n\nif t.count(t[0]) == 3:\n  print('0')\nelif t.count(t[0]) == 2 or t.count(t[1]) == 2:\n  print('1')\nelse:\n  num = list(map(int, [t[0][0], t[1][0], t[2][0]]))\n  suit = [t[0][1], t[1][1], t[2][1]]\n  if len(set(suit)) == 3:\n    print('2')\n  elif len(set(suit)) == 1:\n    if num[1] == num[0] + 1 or num[2] == num[1] + 1:\n      if num[2] == num[0] + 2:\n        print('0')\n      else:\n        print('1')\n    elif num[1] == num[0] + 2 or num[2] == num[1] + 2:\n        print('1')\n    else:\n      print('2')\n  else:\n    if suit[0] == suit[1]:\n      if num[1] - num[0] in [1, 2]:\n        print('1')\n      else:\n        print('2')\n    elif suit[1] == suit[2]:\n      if num[2] - num[1] in [1, 2]:\n        print('1')\n      else:\n        print('2')\n    else:\n      if num[2] - num[0] in [1, 2]:\n        print('1')\n      else:\n        print('2')","output":"nlogn"},{"instruction":"n, k = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nk -= 1\narr_new = sorted([arr[i+1]-arr[i] for i in range(n-1)], reverse=True)\nprint(arr[-1]-arr[0]-sum(arr_new[:k]))","output":"nlogn"},{"instruction":"s = input()\npb = 0\nlenght = len(s)-1\nw = []\nwhile(lenght!=0):\n    ss = s[pb:pb+lenght]\n    w.append(ss)\n    if pb+lenght==len(s):\n        pb = 0\n        lenght -= 1\n    else:\n        pb+=1\nfor i in range(0,len(w)-1):\n    for j in range(i+1,len(w)):\n        if (w[i]==w[j]):\n            print(len(w[i]))\n            exit(0)\nprint(0)","output":"cubic"},{"instruction":"def main():\n    def solve():\n        n = int(input())\n        arr = sorted(map(int, input().split()))\n        a = arr[-2]\n        print(min(n - 2, a - 1))\n\n    import sys\n    input = sys.stdin.readline\n\n    for _ in range(int(input())):\n        solve()\n\n    return 0\n\nmain()","output":"nlogn"},{"instruction":"def power(x , y):\n    res = 1\n    while y > 0 :\n        if y % 2 != 0 :\n            res = res * x\n        y \/\/= 2\n        x *= x\n\n    return res\n\nn = int(input())\nm = int(input())\n\nif n <= 40 :\n    print(m % power(2 , n))\n\nelse:\n    print(m)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n    n \/\/= 2\n    if n == int(n ** 0.5) ** 2:\n        print(\"YES\")\n        return\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n    n \/\/= 2\n    if n == int(n ** 0.5) ** 2:\n        print(\"YES\")\n        return\n    print(\"NO\")\n\nfor _ in range(int(input())):\n    main()","output":"constant"},{"instruction":"n, s = map(int, input().split())\nif s % n == 0:\n    print(s \/\/ n)\nelse:\n    print(s \/\/ n + 1)","output":"constant"},{"instruction":"s=input()\nn=len(s)\nm=0\n\nfor i in range(n-1):\n    for j in range(1,n-i):\n        if s[i:i+j] in s[i+1:]:\n            if j>m:\n                m=j\n\nprint(m)","output":"cubic"},{"instruction":"n, a, b, c, t = map(int, input().split())\nl = list(map(int, input().split()))\nf = [0] * 1001\nfor i in l: f[i] -= -1\ntmp = 0\ntmp2 = 0\nfor i in range(1, t):\n    tmp += (t - i) * f[i]\ntmp = n * a + tmp * c - tmp * b\nprint(max(n * a, tmp))","output":"linear"},{"instruction":"class Solution:\n    def reverse(self, x: int) -> int:\n        def rec(n: int, rev: int) -> int:\n            if n == 0:\n                return rev\n\n            rev = rev * 10 + n % 10\n            return rec(n \/\/ 10, rev)\n\n        sign = -1 if x < 0 else 1\n        x = abs(x)\n        reversed_num = rec(x, 0)\n        reversed_num *= sign\n        if reversed_num < -(1 << 31) or reversed_num > (1 << 31) - 1:\n            return 0\n\n        return reversed_num","output":"constant"},{"instruction":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= n - 1\n            res += 1\n        return res","output":"constant"},{"instruction":"import collections\nfrom functools import cmp_to_key\n\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))\n\nn,a,b = getIntList()\na0 = a\nb0 = b\nif a0>b0:\n    a0,b0 = b,a\nif n==2 and (a0,b0) == (1,1):\n    print('NO')\n    sys.exit()\nif n==3 and (a0,b0) == (1,1):\n    print('NO')\n    sys.exit()\nif a>1 and b>1:\n    print('NO')\n    sys.exit()\n\nmat = [['0' for y in range(n)]for x in range(n)]\nmat1 = [['1' for y in range(n)]for x in range(n)]\nif b==1:\n    for x in range(n-a):\n        mat[x][x+1] = '1'\n        mat[x+1][x] = '1'\nelse:\n    mat = mat1\n    for x in range(n):\n        mat[x][x] = '0'\n    for x in range(n-b):\n        mat[x][x+1] = '0'\n        mat[x+1][x] = '0'\n\nprint('YES')\nfor x in range(n):\n    print(''.join(mat[x]))","output":"quadratic"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"a, b = input().split()\na = int(a)\nb = int(b)\ns = a ^ b\ncnt = 0\nwhile s != 0:\n    s = int(s \/ 2)\n    cnt = cnt + 1\nprint((2 ** cnt) - 1)","output":"logn"},{"instruction":"a,b=map(int,input().split())\nif a==b:print(0)\nelse:\n    x=a^b\n    c=0\n    while x:\n        x=x\/\/2\n        c+=1\n    print(2**c-1)","output":"logn"},{"instruction":"k1,k2,k3=map(int,input().split())\na=[k1,k2,k3];a=sorted(a)\n\ni=0\nwhile i<=5000:\n if dp[i]==0 and i+a[0]<=5000:\n   while i+a[0]<=5000:\n     dp[i]=1\n     i=i+a[0]\n else:i+=1\n\nwhile i<=5000:\n if dp[i]==0 and i+a[1]<=5000:\n   while i+a[1]<=5000:\n     dp[i]=1\n     i=i+a[1]\n else:i+=1\n\nwhile i<=5000:\n if dp[i]==0 and i+a[2]<=5000:\n   while i+a[2]<=5000:\n     dp[i]=1\n     i=i+a[2]\n else:i+=1\n\nif dp.count(0)==0:print(\"YES\")\nelse:print(\"NO\")","output":"constant"},{"instruction":"n = int(input())\nl = [-1] * n\nr = [-1] * n\na = list(map(int, input().split()))\nfor i in range(2 * n):\n    x = a[i] - 1\n    if l[x] == -1: l[x] = i\n    r[x] = i\nans = 0\nfor i in range(n):\n    for j in range(n):\n        if l[i] < l[j] < r[j] < r[i]: ans += 2\nfor i in range(n):\n    ans += r[i] - l[i] - 1\nprint(ans \/\/ 2)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import Counter\n\nimport heapq\n\nfrom collections import Counter\n\nfrom bisect import  bisect_right\n\nimport bisect\n\ndef find(x,y,z):\n    if dp[x][y][z]!=-1:\n        return dp[x][y][z]\n    ans=0\n    if x<r and y<g:\n        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))\n    if x<r and z<b:\n        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))\n    if y<g and z<b:\n        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))\n\n    dp[x][y][z]=ans\n    return ans\nr,g,b = map(int, input().split())\nrl=sorted(list(map(int, input().split())),reverse=True)\ngl=sorted(list(map(int, input().split())),reverse=True)\nbl=sorted(list(map(int, input().split())),reverse=True)\ndp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]\nprint(find(0,0,0))","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = [int(x) for x in input().split()]\nc = sum(a)\nif n == 1:\n\tprint(0)\n\texit(0)\na.sort()\nres = 0\npocl = a[n - 1]\nf = False\nfor i in range(n - 2, -1, -1):\n\tif pocl > 1:\n\t\tif a[i] >= pocl:\n\t\t\tres += 1\n\t\t\tpocl -= 1\n\t\t\tres += (a[i] - 1)\n\t\telse:\n\t\t\tf = True\n\t\t\tpocl = a[i]\n\t\t\tres += 1\n\t\t\tres += (a[i] - 1)\n\t\t\tpocl -= 1\n\telif pocl == 1:\n\t\tif f:\n\t\t\tres += 1\n\t\tres += (a[i] - 1)\n\t\tpocl -= 1\n\telse:\n\t\tres += (a[i] - 1)\n\nprint(res)","output":"nlogn"},{"instruction":"def steps(start, target):\n\n    ans = 0\n    for i, v in enumerate(start):\n        u = target[i]\n        if v != u:\n            for j in range(i+1, len(start)):\n                a, b = start[j], target[j]\n                if a != b and a == u:\n                    start[i], start[j] = start[j], start[i]\n                    break\n            ans += 1\n\n    return ans\n\ndef solve(seq):\n    hc = seq.count('H')\n    tc = len(seq) - hc\n    ans = float('inf')\n    for i in range(tc+1):\n        s = ['T'] * i + ['H'] * hc + ['T'] * (tc-i)\n        ans = min(steps(seq.copy(), s), ans)\n    for i in range(hc+1):\n        s = ['H'] * i + ['T'] * tc + ['H'] * (hc-i)\n        ans = min(steps(seq.copy(), s), ans)\n    return ans\n\nN = int(input())\nline = list(input())\nprint(solve(line))","output":"linear"},{"instruction":"def area(rect):\n    if rect is None:\n        return 0\n    x1, y1, x2, y2 = rect\n    return (x2-x1+1) * (y2-y1+1)\n\ndef get_w(rect):\n    if rect is None:\n        return 0\n\n    x1, y1, x2, y2 = rect\n\n    ra = area(rect)\n    more, less = (ra + 1) \/\/ 2, ra \/\/ 2\n\n    if (x1 + y1) % 2 == 0:\n        return more\n    else:\n        return less\n\ndef intersect_rects(r1, r2):\n    out = []\n    for i, a, b in zip(range(4), r1, r2):\n        out.append(max(a,b) if i < 2 else min(a,b))\n\n    if out[0] > out[2] or out[1] > out[3]:\n        return None\n    return out\n\ndef main():\n    n, m = list(map(int, input().split()))\n    rect1 = list(map(int, input().split()))\n    rect2 = list(map(int, input().split()))\n    rect12 = intersect_rects(rect1, rect2)\n\n    w_start = get_w([1,1,n,m])\n    w1 = get_w(rect1)\n    w2 = get_w(rect2)\n    w12 = get_w(rect12)\n\n    w = w_start - w1 - w2 + w12 + area(rect1) - area(rect12)\n    print(w, n*m-w)\n\nq = int(input())\nfor i in range(q):\n    main()","output":"constant"},{"instruction":"import sys,os,io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom sys import stdin\n\nimport math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef si():\n    return input()\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\nt = 1\nfor _ in range(t):\n    s = si()\n    s = s*3\n    m = 0\n    c = 1\n    for i in range(1,len(s)):\n        if (s[i]!=s[i-1]):\n            c+=1\n        else:\n            m = max(m,c)\n            c = 1\n    m = max(m,c)\n\n    m = min(m,len(s)\/\/3)\n    print(m)","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\nfrom array import array\n\ndef main():\n    n,M = map(int,input().split())\n    comb = [[0]*(n+1) for _ in range(n+1)]\n    comb[0][0] = 1\n    for i in range(1,n+1):\n        for j in range(i+1):\n            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M\n\n    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]\n\n    for i in range(1,n+1):\n        dp[i][0] = pow(2,i-1,M)\n    for j in range(1,n+1):\n        for i in range(3,n+1):\n            for x in range(1,i-1):\n                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M\n    su = 0\n    for i in range(n+1):\n        su = (su+dp[n][i])%M\n    print(su)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n,k=map(int,input().split())\nif 2*n-1<k :\n\tprint(0)\nelif k<=n+1 :\n\tif k%2:\n\t\tprint(k\/\/2)\n\telse:\n\t\tprint(k\/\/2-1)\nelse:\n\tt1=k-n\n\tif k%2==0:\n\t\tprint(k\/\/2-t1)\n\telse:\n\t\tprint(k\/\/2-t1+1)","output":"constant"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\ns=rl()\nn=len(s)\nans=0\nfor i in range(n-1):\n  for j in range(i+1,n):\n    for k in range(n-j):\n      if s[i+k]!=s[j+k]:\n        break\n      ans=max(ans,1+k)\n\nprint(ans)","output":"cubic"},{"instruction":"l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\n\nx = 1\nwhile x <= r:\n    x = x << 1\nx = x >> 1\n\nk = x\nwhile x <= l or x > r:\n    if x <= l:\n        x += k\n    else:\n        x -= k\n    k = k >> 1\n\nprint(x ^ (x - 1))","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\nq=int(input())\nfor i in range(q):\n  n,k=map(int,input().split())\n  s=input()\n  a=k\n  for j in range(n-k+1):\n    a1,a2,a3=0,0,0\n    for jj in range(k):\n      if jj%3==0:\n        if s[j+jj]==\"R\":\n          a2+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a3+=1\n        else:\n          a1+=1\n          a2+=1\n      elif jj%3==1:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a2+=1\n        elif s[j+jj]==\"G\":\n          a2+=1\n          a3+=1\n        else:\n          a3+=1\n          a1+=1\n      else:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a2+=1\n        else:\n          a3+=1\n          a2+=1\n    a=min(a,a1,a2,a3)\n  print(a)","output":"quadratic"},{"instruction":"n=int(input())\na=b=[]\nk=0\nfor _ in range(n):\n\ta.append(input())\nfor i in range(n):\n\tt=input()\n\tif t in a:\n\t\ta.remove(t)\nprint(len(a))","output":"linear"},{"instruction":"import itertools\nimport bisect\nimport math\nfrom collections import *\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\ndef main():\n    a = li()\n    b = li()\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] == \"0\":\n            ans += 1\n            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:\n                a[i] = b[i] = b[i - 1] = \"X\"\n            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == b[i + 1]:\n                a[i] = b[i] = b[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:\n                a[i] = b[i + 1] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == a[i + 1]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            else:\n                ans -= 1\n    print(ans)\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"N, M, K, L = map(int, input().split())\nif N < M or K + L > N:\n    print(-1)\nelse:\n    print((L + K - 1) \/\/ M + 1 if ((L + K - 1) \/\/ M + 1) * M <= N else -1)","output":"constant"},{"instruction":"from sys import stdin, exit\nfrom typing import List, Tuple, Dict\nfrom itertools import product\n\ndef distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):\n    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])\n\ndef shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):\n    shorthest_path = float('inf')\n    for outbreak in outbreaks:\n        if shorthest_path < min_dst:\n            break\n        shorthest_path = min(shorthest_path, distance(tree, outbreak))\n    return shorthest_path\n\ninput_f = open('input.txt', 'r')\noutput_f = open('output.txt', 'w')\n\nN, M = [int(v) for v in input_f.readline().rstrip().split()]\ninput_f.readline()\noutbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]\noutbreaks = []\ninput_f.close()\n\nfor i in range(0, len(outbreaks_line) - 1, 2):\n    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))\n\nlast_tree = (1, 1)\nbest_dst = 0\nfor x, y in product(range(1, N + 1), range(1, M + 1)):\n    path_len = shorthest_path((x, y), outbreaks, best_dst)\n    if path_len > best_dst:\n        last_tree = (x, y)\n        best_dst = path_len\n\noutput_f.write(' '.join(map(str, last_tree)))\n\noutput_f.close()","output":"cubic"},{"instruction":"t=int(input())\nfor _ in range(t):\n\tn,k=list(map(int,input().split()))\n\tif n>=32:\n\t\tprint(\"YES \"+str(n-1))\n\telse:\n\t\tans=-1\n\t\tfor i in range(1,n+1):\n\t\t\tp=(4**i)-(2**(i+1))+1\n\t\t\tp*=(((4**(n-i))-1)\/\/3)\n\t\t\tg=(((4**i)-1)\/\/3)\n\t\t\tp+=(((4**i)-1)\/\/3)\n\t\t\tg=(((4**i)-1)\/\/3)-(((4**(i-1))-1)\/\/3)\n\t\t\tif g<=k and p>=k:\n\t\t\t\tans=n-i\n\t\t\t\tbreak\n\t\tif ans!=-1:\n\t\t\tprint(\"YES \"+str(ans))\n\t\telse:\n\t\t\tprint(\"NO\")","output":"nlogn"},{"instruction":"x, k = map(int, input().strip().split())\nMOD = 10**9 + 7\n\ndef pow2(k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return 2\n    r = pow2(k \/\/ 2)\n    r = r * r\n    if k % 2 != 0:\n        r *= 2\n    return r % MOD\n\ndef calc(x, k):\n    if x == 0:\n        return 0\n    if k == 0:\n        return (2 * x) % MOD\n    r = pow2(k) * (2 * x - 1) + 1\n    return r % MOD\n\nprint(calc(x, k))","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom collections import defaultdict as dd\nI = lambda : list(map(int,input().split()))\n\nn,m=I()\nl=[]\nan=-1;a=b=0\nfor _ in range(n):\n\tk=I()\n\tl.append(k+[_+1])\n\tif an<min(k):\n\t\ta=b=_+1\n\t\tan=min(k)\nle=an;r=10**9+1\nwhile le<r:\n\tmd = (le+r)\/\/2\n\tf=0;a1=a2=-1\n\ts=[0]*n\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif l[i][j]>=md:\n\t\t\t\ts[i]|=1<<j\n\n\tpo=1<<m\n\td=[0]*po\n\tfor i in range(n):\n\t\td[s[i]]=i+1\n\tfor i in range(1,po):\n\t\tif d[i]:\n\t\t\tpp=i\n\t\t\twhile pp:\n\t\t\t\td[pp]=d[i]\n\t\t\t\tpp=(pp-1)&i\n\tif d[po-1]:\n\t\tf=1\n\t\ta1=a2=d[po-1]\n\tfor i in range(1,po):\n\t\tif d[i] and d[(po-1)^i]:\n\t\t\tf=1\n\t\t\ta1 = d[i]\n\t\t\ta2 = d[(po-1)^i]\n\t\t\tbreak\n\tif f:\n\t\tle=md+1\n\t\tif md>an:\n\t\t\ta,b=a1,a2\n\t\t\tan=md\n\telse:\n\t\tr=md\nprint(a,b)","output":"np"},{"instruction":"n=int(input())\nl1=list(map(int,input().split()))\nans=0\nl1.sort()\nvisited=[0]*n\nfor i in range(n):\n    if visited[i]==1:\n        continue\n    visited[i]=1\n    ans+=1\n    for j in range(i+1,n):\n        if visited[j]==0 and l1[j]%l1[i]==0:\n            visited[j]=1\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nu = [0] * (n+1)\nfor i in range(n):\n    if u[i] == 0:\n        ans+=1\n    for j in range(i, n):\n        if a[j] % a[i] == 0:\n            u[j] = 1\nprint(ans)","output":"quadratic"},{"instruction":"n,k = map(int, input().split())\na = 2*n\nb = 5*n\nc = 8*n\nprint((a+k-1)\/\/k + (b+k-1)\/\/k + (c + k -1) \/\/ k)","output":"constant"},{"instruction":"k = int(input())\n\nif k<=9:\n    print(k)\nelse:\n    num_arr = [9*(i+1)* 10**i for i in range(11)]\n\n    index = 0\n\n    while True:\n        if k<=num_arr[index]:\n            break\n        else:\n            k -= num_arr[index]\n            index += 1\n\n    digit = index+1\n    k += digit-1\n\n    num = k\/\/digit\n    offset = k%digit\n\n    string_num = str(10**(digit-1)+ num-1)\n\n    print(string_num[offset])","output":"constant"},{"instruction":"n, s = map(int, input().split())\ntimes = []\nresult = 0\nneed = True\nfor i in range (n):\n    h, m = map(int, input().split())\n    times.append(60*h + m)\n\nif n == 1:\n    if 0 + s + 1 <= times[0]:\n        need = False\nfor i in range(n-1):\n    if 0 + s + 1 <= times[0]:\n        need = False\n        break\n    if times[i+1] - times[i] >= 2 + 2*s:\n        result = times[i] + 1 + s\n        break\nif result == 0 and need:\n    result = times[n-1] + 1 + s\n\nhour = result \/\/ 60\nminute = result % 60\n\nprint(hour, minute)","output":"linear"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    n,m=inar()\n    tup=[]\n    sm=0\n    for i in range(n):\n        a,b=inar()\n        sm+=a\n        diff=a-b\n        tup.append([diff,a,b])\n    tup.sort(reverse=True)\n    ans=0\n    i=0\n    while sm>m and i<n:\n        sm-=tup[i][1]\n        sm+=tup[i][2]\n        i+=1\n        ans+=1\n    if sm<=m:\n        print(ans)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        l, r = 0, len(matrix) - 1\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                topLeft = matrix[top][l + i]\n\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1","output":"quadratic"},{"instruction":"n, M = map(int,input().split())\n\ncombdic = {}\n\ndef fastfrac(a,b,M):\n    numb = pow(b,M-2,M)\n    return ((a%M)*(numb%M))%M\n\ndef comb(p,q):\n    if p==1: return q\n    if (p,q) in combdic: return combdic[(p,q)]\n    output = (comb(p-1,q-1)*q)%M\n    output = fastfrac(output,p,M)\n    combdic[(p,q)] = output\n    return output\n\ndef getnext(i,j,dic):\n    if 2*j+1>i: return 0\n    if (i,j) in dic: return dic[(i,j)]\n\n    if j==0:\n        dic[(i,j)] = (1<<(i-1))%M\n        return dic[(i,j)]\n\n    output = 0\n    for k in range(2,i):\n        if 2*j-1>i-k: break\n\n        output += (getnext(i-k,j-1,dic)*getnext(k-1,0,dic))%M*comb(k-1,i-j)\n        output = output%M\n\n    dic[(i,j)] = output\n\n    return output\n\ndic = {}\nans = 0\n\ndp = [[0 for j in range(n\/\/2+3)] for i in range(n+1)]\n\nfor i in range(1,n+1):\n    dp[i][0] = (1<<(i-1))%M\n    for j in range(1,n+1):\n        if 2*j+1>i: break\n\n        for k in range(2,i):\n            if 2*j-1>i-k: break\n            dp[i][j] +=  ((dp[i-k][j-1] * dp[k-1][0])%M * comb(k-1,i-j))%M\n            dp[i][j] = dp[i][j]%M\n\nans = 0\nfor j in range(n):\n    if 2*j+1>i: break\n\n    ans += dp[n][j]\n    ans = ans%M\n\nprint(ans)","output":"cubic"},{"instruction":"print(\"? 0 0\", flush=True)\nres = input()\ni = 1\na = 0\nb = 0\nfor i in range(29,-1,-1):\n\tprint(\"?\",(a^(1<<i)), b, flush=True)\n\tres1 = input()\n\tprint(\"?\",a, (b^(1<<i)), flush=True)\n\tres2 = input()\n\tif res1 == res2:\n\t\tif res == '1':\n\t\t\ta ^= (1<<i)\n\t\telse:\n\t\t\tb ^= (1<<i)\n\t\tres = res1\n\telif res1 == '-1':\n\t\ta ^= (1<<i)\n\t\tb ^= (1<<i)\nprint(\"!\", a, b, flush=True)","output":"constant"},{"instruction":"n = int(input())\n(ax, ay) = [int(x) for x in input().split()]\n(bx, by) = [int(x) for x in input().split()]\n(cx, cy) = [int(x) for x in input().split()]\n\nif (bx < ax < cx) or (bx > ax > cx) or (by < ay < cy) or (by > ay > cy):\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"constant"},{"instruction":"from sys import stdin,stdout\nfrom itertools import accumulate\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,x=lst()\n    a=lst()\n    ans=0\n    s=set(a)\n    if len(s) != n:\n        print(0)\n        continue\n    for i in range(n):\n        v=a[i]\n        a[i]&=x\n        if a[i] in s and v!=a[i]:\n\n            ans=1\n            break\n    if ans==1:print(1)\n    elif len(set(a))==n:print(-1)\n    else:print(2)","output":"linear"},{"instruction":"a=list(input())\nb=list(input())\nnum=int(''.join(b))\na.sort()\na.reverse()\nal=len(a)\nans=[]\nif(len(a)==len(b) and len(a)!=1):\n\tc=[]\n\tcount=0\n\thogya=0\n\tfor i in range(al):\n\t\tif(hogya==1):\n\t\t\to.reverse()\n\t\t\tf=list(c+o)\n\t\t\tans.append(''.join(f))\n\t\t\tcount+=1\n\t\t\tbreak\n\t\tt=len(a)\n\t\tj=0\n\t\tmittal=t\n\t\tabhinhi=0\n\t\twhile(t):\n\n\t\t\tif(j>len(a)-1):\n\t\t\t\tbreak\n\t\t\tif(int(a[j])<=int(b[i])):\n\t\t\t\tc.append(a[j])\n\t\t\t\ttemp=a[j]\n\t\t\t\ta.remove(a[j])\n\t\t\t\to=a.copy()\n\t\t\t\to.sort()\n\t\t\t\tf=list(c+o)\n\n\t\t\t\tif(temp<b[i]):\n\n\t\t\t\t\thogya=1\n\t\t\t\t\tbreak\n\t\t\t\tif(int(''.join(f))<=num):\n\t\t\t\t\tans.append(''.join(f))\n\t\t\t\t\tcount+=1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\ta.append(temp)\n\t\t\t\t\tc=c[:len(c)-1]\n\n\t\t\t\tt-=1\n\t\t\telse:\n\t\t\t\tj+=1\n\t\t\t\tt-=1\n\t\tif(mittal==len(a)):\n\n\t\t\tbreak\n\n\tprint(ans[count-1])\nelif(len(a)==1):\n\tprint(''.join(a))\nelse:\n\tprint(''.join(a))","output":"cubic"},{"instruction":"print(\"? 0 0\", flush=True)\nres = input()\ni = 1\na = 0\nb = 0\nfor i in range(29,-1,-1):\n\tprint(\"?\",(a^(1<<i)), b, flush=True)\n\tres1 = input()\n\tprint(\"?\",a, (b^(1<<i)), flush=True)\n\tres2 = input()\n\tif res1 == res2:\n\t\tif res == '1':\n\t\t\ta ^= (1<<i)\n\t\telse:\n\t\t\tb ^= (1<<i)\n\t\tres = res1\n\telif res1 == '-1':\n\t\ta ^= (1<<i)\n\t\tb ^= (1<<i)\nprint(\"!\", a, b, flush=True)","output":"logn"},{"instruction":"n, a, b = map(int, input().split())\nif (n == 3 or n == 2) and (a == 1 and b == 1):\n    print(\"NO\")\n    exit(0)\ng = [[0 for i in range(n)] for j in range(n)]\nif a > 1 and b == 1:\n    for i in range(n - a - 1, -1, -1):\n        g[i][i + 1] = g[i + 1][i] = 1\nelif b > 1 and a == 1:\n    a, b = b, a\n    for i in range(n - a - 1, -1, -1):\n        g[i][i + 1] = g[i + 1][i] = 1\n    for i in range(n):\n        for j in range(n):\n            if g[i][j] == 0:\n                g[i][j] = 1\n            elif g[i][j] == 1:\n                g[i][j] = 0\n    for i in range(n):\n        g[i][i] = 0\nelif a == 1 and b == 1:\n    for i in range(n - 1):\n        g[i][i + 1] = g[i + 1][i] = 1\nelif a > 1 and b > 1:\n    print(\"NO\")\n    exit(0)\nprint(\"YES\")\nfor i in range(n):\n    for j in range(n):\n        print(g[i][j], end='')\n    print()","output":"quadratic"},{"instruction":"from sys import *\n\nn, k = map(int, stdin.readline().split())\narr = list(map(int, stdin.readline().split()))\navg = 0\nfor i in range(n):\n\tcnt = 0\n\tsum = 0\n\tfor j in range(i, n):\n\t\tsum += arr[j]\n\t\tcnt += 1\n\t\tif cnt >= k:\n\t\t\tavg = max(avg, sum \/ cnt)\nprint(avg)","output":"quadratic"},{"instruction":"from sys import stdout\nfrom sys import stdin\ndef get():\n    return stdin.readline().strip()\ndef getf(sp = \" \"):\n    return [int(i) for i in get().split(sp)]\ndef put(a, end = \"\\n\"):\n    stdout.write(str(a) + end)\ndef putf(a, sep = \" \", end = \"\\n\"):\n    stdout.write(sep.join([str(i) for i in a]) + end)\n\nfrom math import log\nfrom bisect import bisect_right as br, bisect_left as bl\n\ndef main():\n    n, k = getf()\n    a = getf()\n    rem = [[] for i in range(11)]\n    ln = [0] * n\n    for i in range(n):\n        ln[i] = int(log(a[i], 10)) + 1\n        rem[ln[i]] += [a[i] % k]\n    for i in range(11):\n        rem[i].sort()\n    ans = 0\n    for i in range(n):\n        res = 0\n        for add_len in range(1, 11):\n            cur_rem = ((a[i] % k) * pow(10, add_len, k)) % k\n            need_rem = (k - cur_rem) % k\n            sz = len(rem[add_len])\n            l = bl(rem[add_len], need_rem)\n            r = br(rem[add_len], need_rem)\n            if(l > sz - 1):\n                continue\n            if(rem[add_len][l] == need_rem):\n                res += (r - l)\n        if((a[i] + (a[i] % k) * pow(10, ln[i], k)) % k == 0):\n            res -= 1\n        ans += res\n    put(ans)\nmain()","output":"nlogn"},{"instruction":"input = raw_input\n\ndef f(n):\n    t = (n + 1) \/\/ 2\n    return t if n % 2 == 0 else -t\n\nfor i in range(int(input())):\n    le, rg = map(int, input().split())\n\n    print(f(rg) - f(le - 1))","output":"constant"},{"instruction":"from math import gcd\n\nn = int(input())\nd = dict()\nqs = []\nfor i in range(n):\n    s = input()\n    a = int(s[1:s.index('+')])\n    b = int(s[s.index('+') + 1: s.index(')')])\n    c = int(s[s.index(')') + 2:])\n    a = a + b\n    gc = gcd(a, c)\n    res = (a \/\/ gc, c \/\/ gc)\n    qs.append(res)\n    if res in d:\n        d[res] += 1\n    else:\n        d[res] = 1\nfor q in qs:\n    print(d[q], end=' ')","output":"linear"},{"instruction":"q = int(input())\n\nfor _ in range(q):\n    n, m, k = map(int, input().split())\n    if max([n, m]) > k:\n        print(-1)\n    else:\n        if (n + m) % 2 == 0:\n            if max([n, m]) % 2 != k % 2:\n                print(k - 2)\n            else:\n                print(k)\n        else:\n            print(k - 1);","output":"constant"},{"instruction":"from math import factorial\nfrom decimal import *\nA=input()\nB=input()\na=0\ncnt2=0\ncnt1=0\nb=0\nfor i in A:\n    if i=='+':\n        a+=1\n        cnt1+=1\n    else:\n        a-=1\n        cnt2+=1\ncnt3=0\ncnt=0\ncnt4=0\nfor i in B:\n    if i=='+':\n        b+=1\n        cnt3+=1\n    elif i=='-':\n        b-=1\n        cnt4+=1\n    else:\n        cnt+=1\nif cnt3>cnt1 or cnt4>cnt2:\n    print(format(0,'.12f'))\nelse:\n    No_of_plus=cnt1-cnt3\n    No_of_minus=cnt2-cnt4\n    Total_cases=2**cnt\n    Total_No_of_favourable_cases=factorial(cnt)\/\/(factorial(No_of_plus)*factorial(No_of_minus))\n\n    print(format(Decimal(Total_No_of_favourable_cases)\/Decimal(Total_cases), '.12f'))","output":"np"},{"instruction":"from collections import defaultdict\n\nans = defaultdict(int)\nn = int(input())\n\nbeg, end = [0] * n, [0] * n\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    beg[i] = a\n    end[i] = b + 1\nbeg.sort()\nend.sort()\n\npa, pb = 0, 0\n\ncur = 0\nlst = -1\n\nwhile pb < n:\n    pos = end[pb]\n    if pa < n:\n        pos = min(pos, beg[pa])\n\n    ans[cur] += pos - lst\n\n    ad = 0\n    mn = 0\n    while (pa < n and beg[pa] == pos):\n        ad += 1\n        pa += 1\n    while (pb < n and end[pb] == pos):\n        pb += 1\n        mn -= 1\n\n    lst = pos\n    cur += ad + mn\n\nfor i in range(1, n + 1):\n    print(ans[i], end = ' ')","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\nd={}\nfor i in range(n):\n    d[a[i]]=1\na.sort(reverse=True)\nans=0\nfor i in range(n):\n    if d[a[i]]>0:\n        if a[i]%k==0:\n            x=a[i]\/\/k\n            if x in d:\n                d[x]-=1\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\nfrom random import *\nfrom bisect import *\nfrom heapq import *\n\npl=1\nfrom math import gcd,sqrt,ceil\nfrom copy import *\nsys.setrecursionlimit(10**5)\nif pl:\n\tinput=sys.stdin.readline\nelse:\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('outpt.txt','w')\n\ndef li():\n\treturn [int(xxx) for xxx in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\ndef mi():\n\treturn \tmap(int,input().split())\n\nt=1\n\nwhile t>0:\n\tt-=1\n\ts=input().rstrip()\n\tn=len(s)\n\td={}\n\tfor i in range(n):\n\t\tr=\"\"\n\t\tfor j in range(i,n):\n\t\t\tr+=s[j]\n\t\t\tif r not in d:\n\t\t\t\td[r]=1\n\t\t\telse:\n\t\t\t\td[r]+=1\n\tmaxi=0\n\tfor i in d:\n\t\tif d[i]>=2:\n\t\t\tmaxi=max(maxi,len(i))\n\tprint(maxi)","output":"cubic"},{"instruction":"mod = 998244353\nN,K = map(int, input().split())\n\ndp = [[[0]*(K+2) for i in range(2)] for i in range(N)]\ndp[0][0][0] = 1\ndp[0][1][1] = 1\n\nfor i in range(1,N):\n    for b in range(K):\n        dp[i][0][b]   += dp[i-1][0][b]\n        dp[i][0][b]   += dp[i-1][1][b]\n        dp[i][0][b]   += dp[i-1][1][b]\n        dp[i][0][b+1] += dp[i-1][0][b]\n        dp[i][0][b]   %= mod\n\n        dp[i][1][b+1] += dp[i-1][0][b]\n        dp[i][1][b]   += dp[i-1][1][b]\n        dp[i][1][b+2] += dp[i-1][1][b]\n        dp[i][1][b+1] += dp[i-1][0][b]\n        dp[i][1][b] %= mod\n\nans = 0\nfor x in range(2):\n    ans += dp[N-1][x][K-1]\n\nprint(ans*2%mod)","output":"np"},{"instruction":"n = int(input())\nfrom collections import defaultdict, Counter\na = defaultdict(list)\ncount_left = Counter()\ncount_right = Counter()\n\nfor _ in range(n):\n\tl, r = map(int, input().split())\n\tcount_left[l] += 1\n\tcount_right[r] += 1\n\ncount = [0] * (n + 1)\n\npts = sorted(set(count_left.keys()) | set(count_right.keys()))\n\nc = 0\nprev = pts[0]\nfor pt in pts:\n\n\tif count_left[pt]:\n\t\tcount[c] += pt - prev - 1\n\t\tc += count_left[pt]\n\t\tcount[c] += 1\n\t\tc -= count_right[pt]\n\telse:\n\t\tcount[c] += pt - prev\n\t\tc -= count_right[pt]\n\n\tprev = pt\n\nprint(' '.join(map(str, count[1:])))","output":"nlogn"},{"instruction":"s=input().strip()\ns=s+s\n\nn=len(s)\nan=1\nm=1\n\nfor i in range(1,n):\n    if s[i]!=s[i-1]:\n        m+=1\n        an = max(an, m)\n    else:\n        an = max(an, m)\n        m=1\n\nprint(min(an,n\/\/2))","output":"linear"},{"instruction":"from sys import stdin\n\ndef main():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    dp = [aa]\n    for i in range(n - 1, 0, -1):\n        aa = aa[:]\n        for j in range(i):\n            aa[j] ^= aa[j + 1]\n        del aa[-1]\n        dp.append(aa)\n    aa = dp[0]\n    for i, bb in enumerate(dp[1:], 1):\n        a = aa[0]\n        for j, b in enumerate(bb):\n            c = aa[j + 1]\n            bb[j] = max(a, b, c)\n            a = c\n        aa = bb\n    input()\n    res = stdin.read().splitlines()\n    for i, s in enumerate(res):\n        lo, hi = map(int, s.split())\n        res[i] = str(dp[hi - lo][lo - 1])\n    print('\\n'.join(res))\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n,k = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nc = n\nj=0\nfor x in arr:\n    while(x>arr[j]):\n        if(x-arr[j]<=k):c-=1\n        j+=1\n\nprint(c)","output":"nlogn"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, K = getIntList()\n\nr=  K\/\/N\nif K%N!=0: r+=1\n\nprint(r)","output":"constant"},{"instruction":"def find(n,k):\n    x=9+8*(n+k)\n    a=(-3+int(x**0.5))\/\/2\n    b=n-a\n    return b\nn,k=list(map(int,input().strip().split(' ')))\nprint(find(n,k))","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd\nfor t in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l1=dd(int)\n    a=0\n    for j in l:\n        l1[j]+=1\n        if l1[j]==4:\n            a=j\n    if a:\n        print(a,a,a,a)\n    else:\n        c=0\n        x=0\n        l2=[]\n        for j in l1:\n            if l1[j]>=2:\n                l2.append(j)\n        l2.sort()\n        for j in l2:\n                c+=1\n                if c==1:\n                    a=j\n                elif c==2:\n                    b=j\n                else:\n                    if x\/j+j\/x<a\/b+b\/a:\n                        a,b=x,j\n                x=j\n        print(a,a,b,b)","output":"nlogn"},{"instruction":"n = int(input())\nb = []\nbb =[]\nfor i in range(n):\n    x=int(input())\n    idx = 0\n    for j in range(len(b)):\n        nxt = b[j] ^ x\n        if nxt < x :\n            x = nxt\n            idx ^= bb[j]\n    if x == 0:\n        cnt = 0\n        v = []\n        for k in range(2000):\n            if idx & (1 << k) :\n                v.append(k)\n        print(len(v),end=' ')\n        for e in v:\n            print(e,end=' ')\n        print()\n    else :\n        print(0)\n        idx ^= 1 << i\n        b.append(x)\n        bb.append(idx)","output":"np"},{"instruction":"n = int(input())\n\nif n>=2:\n    print(25)","output":"constant"},{"instruction":"import math\nn,pos,l,r = map(int, input().strip().split(' '))\n\nif l==1 and r==n:\n    print(0)\nelif l==1:\n    if pos==r:\n        print(1)\n    elif pos>r:\n        print(pos-r+1)\n    elif pos<r:\n        print(r-pos+1)\nelif r==n:\n    if pos==l:\n        print(1)\n    elif pos<l:\n        print(l-pos+1)\n    else:\n        print(pos-l+1)\nelse:\n    if pos>=l and pos<=r:\n        if pos-l<r-pos:\n            print(2+pos-l+r-l)\n        else:\n            print(2+r-l+r-pos)\n    else:\n        if pos>r:\n            print(pos-r+2+r-l)\n        else:\n            print(l-pos+2+r-l)","output":"constant"},{"instruction":"from sys import stdin,stdout\nfrom collections import Counter\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\ndef pos(n):\n    t=0\n    for k,v in d.items():\n        if v>=n:t+=v\/\/n\n    return t>=p\nfor _ in range(1):\n    p,n=lst()\n    d=Counter(lst())\n    ans=0\n    for sel in range(1,n+1):\n         if pos(sel):ans=max(ans,sel)\n    print(ans)","output":"nlogn"},{"instruction":"left = -1\nright = 10e9 - 1\nnn = [int(i) for i in input().split()]\nn = nn[0]\nk = nn[1]\nf = True\nwhile right - left > 1:\n    mid = (left + right) \/\/ 2\n    if ((n - mid + 1) * abs((n - mid)) \/\/ 2 - mid > k):\n        left = mid\n    else:\n        if((n - mid + 1) * abs((n - mid)) \/\/ 2 - mid == k):\n            print(round(mid))\n            f = False\n            break\n        else:\n            right = mid\nif f:\n    print(round(left))","output":"logn"},{"instruction":"x, k = map(int, input().split())\nmo = 1000000007\nif (not x):\n    print(0)\nelif (not k):\n    print((x * 2) % mo)\nelse:\n    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)\n    ans %= mo\n    ans += mo\n    ans %= mo\n    print(ans)","output":"logn"},{"instruction":"import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\n\ndef num():\n\treturn map(int , input().split())\n\ndef nu():\n\treturn int(input())\n\nn,m=num()\na=li()\nind=-1\nz=0\nll=sorted(a)\nmx=ll[n-1]-1\ncc=0\nfor i in range(n-2,-1,-1):\n\tif (ll[i] == 0):\n\t\tcontinue\n\tif(mx==0):\n\t\tcc += ll[i] - 1\n\t\tcontinue\n\n\tif(ll[i]>=mx):\n\t\tcc+=1\n\t\tmx-=1\n\t\tcc+=ll[i]-1\n\t\tll[i]=1\n\telse:\n\t\tmx=ll[i]\n\t\tcc+=1\n\t\tmx-=1\n\t\tcc += ll[i] - 1\n\t\tll[i] = 1\n\nprint(cc)","output":"nlogn"},{"instruction":"from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n\nprint('! {} {}'.format(a,b))\nstdout.flush()","output":"constant"},{"instruction":"n=int(input())\nif n%2==0:\n    print(4,n-4)\nelse:\n    print(9,n-9)","output":"constant"},{"instruction":"k=int(input())\nx=0\nc=0\nwhile(x<k):\n    x+=9*(10**c)*(c+1)\n    c+=1\np=(x-k)%c\nk=((10**c)-int(((x-k)\/c))-1)\nk=str(k)\nprint(k[len(k)-(p)-1])","output":"constant"},{"instruction":"def max_subarray(A):\n    max_ending_here = max_so_far = A[0]\n    for x in A[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\nans = 0\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(m):\n    li = a[0:i] + [-k]\n    s = 0\n    while True:\n        li += a[i+s:min(i+m+s, len(a))]\n        li += [-k]\n        if i+m+s >= len(a):\n            break\n        s += m\n    ans = max(max_subarray(li) - k,ans)\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\nprint(n\/\/2+n)","output":"constant"},{"instruction":"def solution():\n    k = int(input())\n    k -= 1\n    n, m = 1, 9\n    while k > n*m:\n        k, n, m = k - n*m, n+1, m*10\n\n    x = str(10**(n-1) + k\/\/n)[k % n]\n\n    print(x)\n\nif __name__ == \"__main__\":\n    solution()","output":"logn"},{"instruction":"from collections import defaultdict\nn,k=map(int,input().split())\narr=list(map(int,input().split()))\nxors=defaultdict(int)\nxors[0]=1\ncomp=(1<<k)-1\nxor=0\nans=n*(n+1)\/\/2\nfor a in arr:\n    xor^=a\n    if(xors[xor]>xors[comp^xor]):\n        xor^=comp\n    ans-=xors[xor]\n    xors[xor]+=1\nprint(ans)","output":"linear"},{"instruction":"n, t = [int(item) for item in input().split(' ')]\ncont, ans = [], 2\nfor i in range(n):\n    hcenter, hlen = [int(item) for item in input().split(' ')]\n    cont.append([hcenter - hlen \/ 2, hcenter + hlen \/ 2])\n\ncont.sort(key=lambda item: item[0])\n\nfor i in range(n - 1):\n    gap = cont[i + 1][0] - cont[i][1]\n    if gap == t:\n        ans += 1\n    elif gap > t:\n        ans += 2\n\nprint(ans)","output":"nlogn"},{"instruction":"import math\nn=int(input())\nprint((math.floor(n\/2)+1)*math.ceil(n\/2))","output":"linear"},{"instruction":"y = [2]\nh = []\nj = 0\nfor i in range(3,1000):\n    z = 0\n    for x in range(2, int(i**0.5)+1):\n        if i%x == 0:\n            z+=1\n    if z == 0:\n        y.append(i)\nfor i in range(0,len(y)-1):\n    x = y[i]+y[i+1]\n    h.append(x)\n\nk = list(input().split())\na = int(k[0])\nb = int(k[1])\n\nfor i in range(0,len(h)):\n    h[i] = h[i] + 1\n\ng = []\n\nfor i in h:\n    z = 0\n    for x in range(2, int(i**0.5)+1):\n        if i%x == 0:\n            z+=1\n\n    if z == 0:\n        g.append(i)\n\nfor i in g:\n    if i>=2 and i<=a:\n        j+=1\nif j >= b:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"def reach_max(n, k):\n    return n * k + 1 - n * (n + 1) \/\/ 2\n\nn, k = map(int, input().split())\n\nif n == 1:\n    print(0)\n    exit()\n\nlo, hi = 1, k - 1\n\nif n > reach_max(hi, k):\n    print(-1)\n    exit()\n\nwhile lo < hi:\n    mid = (lo + hi) \/\/ 2\n    if reach_max(mid, k) < n:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)","output":"logn"},{"instruction":"for t in range(int(input())):\n\tn, k = map(int, input().split())\n\tlev = 1\n\tb = False\n\tif n >= 60:\n\t\tall_moves = 0\n\t\tb = True\n\telse:\n\t\tall_moves = (4 ** n - 1) \/\/ 3\n\n\tcnt = 1\n\tstep = 0\n\tprev_need = 0\n\twhile True:\n\t\tneed = 2 * cnt - 1\n\n\t\tif k >= need and step < n:\n\t\t\tk -= need\n\t\t\tall_moves -= need\n\t\t\tcnt *= 2\n\t\t\tstep += 1\n\t\t\tprev_need = need\n\t\telse:\n\t\t\tif b:\n\t\t\t\tprint('YES', n - step)\n\t\t\t\tbreak\n\t\t\tif all_moves < k:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak\n\n\t\t\tall_moves -= (4 ** (n - step)) \/\/ 3 * need\n\t\t\tif all_moves >= k or b:\n\t\t\t\tprint('YES', n - step)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak","output":"logn"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\n\ntotal = sum(a)\nfinal = n * (n-1) \/\/ 2\nrepeated = []\ncount = {}\n\nfor i in a:\n    try:\n        count[i] += 1\n        repeated.append(i)\n    except KeyError:\n        count[i] = 1\n\nmoves = total - final\n\nif len(repeated) > 1:\n    print('cslnb')\n\nelif 0 in repeated:\n    print('cslnb')\n\nelif len(repeated) == 1 and repeated[0] - 1 in a:\n    print('cslnb')\n\nelse:\n    if moves % 2 == 0 or moves <= 0:\n        print('cslnb')\n    else:\n        print('sjfnb')","output":"linear"},{"instruction":"t = int(input())\ndef maxsa(A):\n    ans = 0\n\n    for i in range(n):\n        cur_maxx = 0\n        for j in range(4):\n            cur_maxx = max(cur_maxx, A[j][i])\n        ans+= cur_maxx\n    return ans\n\ndef fu(A):\n    answer = 0\n    for j in range(n):\n        A[0] = A[0][1:] + A[0][:1]\n        for i in range(n):\n            A[1] = A[1][1:] + A[1][:1]\n            for k in range(n):\n                A[2] = A[2][1:] + A[2][:1]\n                for l in range(n):\n                    A[3] = A[3][1:] + A[3][:1]\n\n                    cur_ans = maxsa(A)\n                    answer = max(answer, cur_ans)\n    return answer\n\nfor j in range(t):\n    n,m = map(int,input().split())\n    A = [0] * n\n    inds = [-1,-1,-1,-1]\n    maxs  =[ 0,0,0,0]\n    for j in range(n):\n        A[j] = list(map(int,input().split()))\n    for j in range(m):\n        cur_maxs = 0\n        for i in range(n):\n            cur_maxs = max(cur_maxs, A[i][j])\n        maxs.append(cur_maxs)\n        inds.append(j)\n        ind  = 4\n\n        while ind !=0 and maxs[ind] > maxs[ind-1]:\n            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]\n            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]\n            ind-=1\n        maxs.pop()\n        inds.pop()\n\n    S = [0] * 4\n    for j in range(4):\n        if inds[j] != -1:\n\n            S[j] = [s[inds[j]] for s in A]\n\n        else:\n            S[j] = [0] * n\n\n    print(fu(S))","output":"np"},{"instruction":"a,b = (map(int,input().split()))\nprint((b+a-1)\/\/a)","output":"constant"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nn,m,k = map(int,input().split())\np = [input().rstrip() for i in range(n)]\nidx = {s:i for i,s in enumerate(p)}\n\ndef match(s):\n    res = []\n    for i in range(2**k):\n        tmp = []\n        for j in range(k):\n            if i>>j & 1:\n                tmp.append(s[j])\n            else:\n                tmp.append(\"_\")\n        res.append(\"\".join(tmp))\n    return set(res)\n\nedge = [[] for i in range(n)]\ndeg = [0]*n\nfor i in range(m):\n    s,mt = input().rstrip().split()\n    mt = int(mt)-1\n    t = p[mt]\n    M = match(s)\n    if t in M:\n        for nv in M:\n            if nv!=t and nv in idx:\n                nv = idx[nv]\n                edge[mt].append(nv)\n                deg[nv] += 1\n    else:\n        exit(print(\"NO\"))\n\ndeq = deque([v for v in range(n) if deg[v]==0])\nres = []\nwhile deq:\n    v = deq.popleft()\n    res.append(v+1)\n    for nv in edge[v]:\n        deg[nv] -= 1\n        if deg[nv]==0:\n            deq.append(nv)\n\nif len(res)!=n:\n    exit(print(\"NO\"))\n\nprint(\"YES\")\nprint(*res)","output":"np"},{"instruction":"N, K = input().split()\nN, K = int(N), int(K)\nP = [int(x) for x in input().split()]\nA = [None]*256\nA[0] = 0\nfor i in range(N):\n    pn = P[i]\n    if A[pn] is None:\n        for j in range(K-1, -1, -1):\n            if pn < j: continue\n            if A[pn-j] is None:\n                A[pn-j] = pn-j\n                break\n            else:\n                if A[pn-j] + K - 1 >= pn:\n                    break\n        for jj in range(j, -1, -1):\n            A[pn-jj] = A[pn-j]\nprint(*[A[P[i]] for i in range(N)])","output":"quadratic"},{"instruction":"from collections import defaultdict\nimport bisect\nfrom itertools import accumulate, count\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\ns=input()\nneg=0\nif int(s)<0:\n    neg=1\nans1 = \"\"\ns=int(s)\ns=abs(s)\ns=str(s)\nans2 = \"\"\nfor i in range(0, len(s)):\n    if i == len(s)-2:\n        ans1 += s[i]\n    elif i == len(s)-1:\n        ans2 += s[i]\n    else:\n        ans1 += s[i]\n        ans2 += s[i]\nif neg==0:\n    print(s)\nelse:\n    if str(min(int(ans1), int(ans2)))==\"0\":\n        print(0)\n    else:\n        print(\"-\"+str(min(int(ans1), int(ans2))))","output":"constant"},{"instruction":"n, s = map(int, input().split())\nans = s\nfor i in range(n):\n    f, t = map(int, input().split())\n    ans = max(ans, t+f)\nprint(ans)","output":"linear"},{"instruction":"r, g, b = map(int, input().split(' '))\nR = list(map(int, input().split(' ')))\nG = list(map(int, input().split(' ')))\nB = list(map(int, input().split(' ')))\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i == 0 and j == 0 and k == 0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans,dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"import math\nimport os\nimport random\nimport re\nimport sys\nimport functools\nfrom operator import itemgetter, attrgetter\nfrom collections import Counter\n\nif __name__ == '__main__':\n    Y = lambda: list(map(int, input().split()))\n    P = lambda: map(int, input().split())\n    N = lambda: int(input())\n\n    a, b, c, n = P()\n\n    if a < c or b < c:\n        r = -1\n    else:\n        r = n - (a + b - c)\n    print(-1 if r <= 0 else r)","output":"constant"},{"instruction":"def main():\n    n = int(input())\n    s = input()\n\n    u_set = set()\n    for i in s:\n        u_set.add(i)\n    u_cnt = len(u_set)\n\n    d = {}\n    j = 0\n    ans = 10**9\n    for i in range(n):\n        while len(d.keys()) < u_cnt and j < n:\n            d[s[j]] = d.get(s[j], 0) + 1\n            j += 1\n\n        if len(d.keys()) == u_cnt:\n            if j - i < ans:\n                ans = j - i\n        elif j == n:\n            break\n\n        d[s[i]] -= 1\n        if d[s[i]] == 0:\n            del d[s[i]]\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp \/ a)\nans = int((res % (10 ** (x+1))) \/ (10 ** x))\nprint(ans)","output":"logn"},{"instruction":"n=int(input())\nc=0\nlst=[4,7,47,74,447,474,744,477,747,774]\nif n in lst:\n    print(\"YES\")\nelse:\n    for i in lst:\n        if n%i==0:\n            print(\"YES\")\n            c=c+1\n            break\n        else:\n            continue\n    if c==0:\n        print(\"NO\")","output":"constant"},{"instruction":"from sys import stdin\n\ndef read_lines(sep=' ', input_type=None):\n\n    _lines = stdin.readlines()\n    cast = input_type is not None\n    lines = []\n    for line in _lines:\n        line = line[:-1].split(sep)\n        if cast:\n            line = [input_type(x) for x in line]\n        lines.append(line)\n    return lines\n\nimport math\n\nif __name__ == '__main__':\n\n    lines = read_lines(input_type=int)\n\n    n,m = lines[0][0], lines[1][0]\n\n    if n <= math.log2(m):\n        print(m % (2**n))\n    else:\n        print(m)","output":"constant"},{"instruction":"n=int(input())\nprint(int(n**2+(n-1)**2))","output":"constant"},{"instruction":"n=int(input())\nli=list(map(int,input().split()))\nlis=[x%2 for x in li]\nif lis.count(0)>lis.count(1):\n    print(lis.index(1)+1)\nelse:\n    print(lis.index(0)+1)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom collections import deque\nclass Graph:\n  def __init__(self, N, M=-1):\n    self.V = N\n    if M>=0: self.E = M\n    self.edge = [[] for _ in range(self.V)]\n    self.edge_rev = [[] for _ in range(self.V)]\n    self.order = []\n    self.to = [0]*self.V\n    self.visited = [False]*self.V\n    self.dp = [0]*self.V\n\n  def add_edge(self, a, b, dist=-1, bi=False, rev=False):\n    if dist>=0:\n      self.edge[a].append((dist, b))\n      if rev: self.edge_rev[b].append((dist, a))\n      if bi: self.edge[b].append((dist, a))\n    else:\n      self.edge[a].append(b)\n      self.to[b] += 1\n      if rev: self.edge_rev[b].append(a)\n      if bi: self.edge[b].append(a)\n\n  def topo_sort(self):\n    updated = [0]*self.V\n    for start in range(self.V):\n      if self.to[start] or updated[start]: continue\n      stack = deque([start])\n      while stack:\n        v = stack.popleft()\n        self.order.append(v+1)\n        updated[v] = 1\n        for u in self.edge[v]:\n          self.to[u] -= 1\n          if self.to[u]: continue\n          stack.append(u)\n\nN, M, K = map(int, input().split())\n\nfrom collections import defaultdict\ndic = defaultdict(lambda: -1)\nfor i in range(N):\n  S = input()[:-1]\n  dic[S] = i\nG = Graph(N)\nfor _ in range(M):\n  t, mt = input().split()\n  mt = int(mt)-1\n  lis = []\n  for S in range(1<<K):\n    s = ''\n    for i in range(K):\n      if (S>>i)%2:\n        s += '_'\n      else:\n        s += t[i]\n    if dic[s]>=0: lis.append(dic[s])\n  if mt not in lis:\n    print('NO')\n    exit()\n  for l in lis:\n    if l!=mt:\n      G.add_edge(mt, l, bi=False, rev=False)\nG.topo_sort()\nif len(G.order)==N:\n  print('YES')\n  print(*G.order)\nelse:\n  print('NO')","output":"np"},{"instruction":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n\n        def dfs(i):\n            if i >= len(nums):\n                return 0\n            return max(dfs(i + 1),\n                       nums[i] + dfs(i + 2))\n\n        return dfs(0)","output":"np"},{"instruction":"class SegTree:\n    def __init__(self, init_val, ide_ele, segfunc):\n        self.n = len(init_val)\n        self.num = 2**(self.n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.segfunc = segfunc\n        self.seg = [ide_ele]*2*self.num\n\n        for i in range(self.n):\n            self.seg[i+self.num] = init_val[i]\n\n        for i in range(self.num-1, 0, -1):\n            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])\n\n    def update(self, k, x):\n        k += self.num\n        self.seg[k] = x\n        while k:\n            k = k >> 1\n            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])\n\n    def query(self, l, r):\n        if r <= l:\n            return self.ide_ele\n        l += self.num\n        r += self.num\n        lres = self.ide_ele\n        rres = self.ide_ele\n        while l < r:\n            if r & 1:\n                r -= 1\n                rres = self.segfunc(self.seg[r], rres)\n            if l & 1:\n                lres = self.segfunc(lres, self.seg[l])\n                l += 1\n            l = l >> 1\n            r = r >> 1\n        res = self.segfunc(lres, rres)\n        return res\n\n    def __str__(self):\n        arr = [self.query(i,i+1) for i in range(self.n)]\n        return str(arr)\n\nn = int(input())\nS = list(map(int, input().split()))\nC = list(map(int, input().split()))\nSA = list(set(S))\nSA = sorted(SA)\nd = {}\nfor i, s in enumerate(SA):\n    d[s] = i\nS = [d[s] for s in S]\nL = [0]*n\nR = [0]*n\nINF = 10**18\nN = len(d)\nseg = SegTree([INF]*(N+1), INF, min)\nseg.update(S[0], C[0])\nfor i in range(1, n-1):\n    s = S[i]\n    L[i] = seg.query(0, s)\n    seg.update(s, C[i])\n\nseg = SegTree([INF]*(N+1), INF, min)\nseg.update(S[-1], C[-1])\nfor i in reversed(range(1, n-1)):\n    s = S[i]\n    R[i] = seg.query(s+1, seg.n)\n    seg.update(s, C[i])\n\nans = INF\nfor i in range(1, n-1):\n    ans = min(ans, L[i]+C[i]+R[i])\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)","output":"quadratic"},{"instruction":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        res = nums[0]\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            if nums[l] < nums[r]:\n                res = min(res, nums[l])\n                break\n\n            m = (l + r) \/\/ 2\n            res = min(res, nums[m])\n            if nums[m] >= nums[l]:\n                l = m + 1\n            else:\n                r = m - 1\n        return res","output":"logn"},{"instruction":"import math\n\ninp = input().split(' ')\nm = int(inp[0])\nn = int(inp[1])\n\nresult = []\n\nfor column in range(1, math.ceil(m\/2) + 1):\n\n    rowRange = range(1, n + 1)\n    if column == math.ceil(m \/ 2) and m % 2 == 1:\n        rowRange = range(1, math.ceil(n\/2) + 1)\n\n    for row in rowRange:\n        result.append(str(column) + ' ' + str(row))\n        if row == math.ceil(n\/2) and n % 2 == 1 and column == math.ceil(m \/ 2) and m % 2 == 1:\n            continue\n        result.append(str(m + 1 - column) + ' ' + str(n + 1 - row))\n\nprint('\\n'.join(result))","output":"quadratic"},{"instruction":"from collections import defaultdict\nn, s= int(input()), []\nfor i in range(n):\n  a = [int(x) for x in input().split()]\n  s += [(a[0], 0), (a[1], 1)]\ns.sort()\nnow, rev = 0, defaultdict(int)\nfor a, b in zip(s, s[1:]):\n  now += 1 if a[1] == 0 else -1\n  if(a[1] == 0):\n    rev[now] += b[0] - a[0] + (1 if b[1] == 1 else 0)\n  elif b[0] != a[0]:\n    rev[now] += b[0] - a[0] - (1 if b[1] == 0 else 0)\n[print(rev[i], end=\" \") for i in range(1, n+1)]","output":"nlogn"},{"instruction":"from collections import Counter\n\nn,k=list(map(int,input().split()))\nx=list(map(int,input().split()))\n\ndd=Counter()\nfor i in range(k):\n\n    dd[x[i]]=dd[x[i]]+1\n\nfinal=0\nfor i in range(1,k+1):\n    ans=0\n    d=dd.copy()\n    for j in range(n):\n        for jj in d:\n            if d[jj]>=i:\n                d[jj]-=i\n                ans=ans+1\n                break\n    if ans>=n:\n        final=i\n    else:\n        break\nprint(final)","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nslow,fast=0,0\nwhile fast<n:\n    if a[slow]==a[fast]:\n        fast+=1\n    elif abs(a[slow]-a[fast])<=k:\n        a[slow]=0\n        slow+=1\n    else:\n        slow+=1\nans=0\nfor i in a:\n    if i!=0:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\nf = sys.stdin\n\ndef line():\n    return f.readline().strip().split()\n\ndef powers(limit):\n    size = limit+1\n    p = [1]*size\n    for n in range(1,size):\n        p[n] = 2*p[n-1] % M\n\n    return p\n\ndef binomials(limit):\n    size = limit+1\n    bc = [[0 for k in range(size)] for n in range(size)]\n    for n in range(size):\n        bc[n][0]=1\n\n    for n in range(1,size):\n        for k in range(1,n+1):\n            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]\n            bc[n][k] %= M\n\n    return bc\n\ndef solve():\n\n    dp = [[0 for _ in range(N)] for _ in range(N)]\n    dp[0][0]=1\n\n    for i in range(1,N):\n        for k in range(1,i):\n            for j in range(1,i):\n                dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]\n                dp[i][j] %= M\n        dp[i][i] = POW[i]\n\n    res=0\n    for j in range(0,N):\n        res = (res + dp[N-1][j]) % M\n\n    return str(res)\n\nT = 1\nfor test in range(1,T+1):\n    N,M = map(int,line())\n\n    BC = binomials(N)\n    POW = powers(N)\n\n    print(solve())\n\nf.close()","output":"cubic"},{"instruction":"n = int(input())\n\nsegments = []\n\nfor i, _ in enumerate(range(n)):\n    a, b = map(int, input().split())\n    segments.append(((a, b), i + 1))\n\nsegments.sort(key=lambda x: (x[0][0], -x[0][1]))\n\nlast_r = 0\nlast_index = 0\n\nfor segment, index in segments:\n    if last_r >= segment[1]:\n        print(index, last_index)\n        break\n\n    last_r = segment[1]\n    last_index = index\nelse:\n    print(-1, -1)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\n\nm = 2 * (n - 1) - k * (k - 1)\n\nif m > 0: print(-1)\n\nelse:\n\n    x = int((1 + (1 - 4 * m) ** 0.5) \/ 2)\n\n    if x * (x - 1) + m > 0: x -= 1\n\n    print(k - x)","output":"logn"},{"instruction":"n = int(input())\nvalues = list(map(int, input().split()))\nqueries = int(input())\n\ndp = [[0] * 5009 for i in range(5009)]\n\nfor i in range(n):\n    dp[0][i] = values[i]\n\nfor i in range(1, n):\n    for j in range(n-i+1):\n        top = dp[i-1][j]\n        right = dp[i-1][j+1]\n        dp[i][j] = top ^ right\n\nfor i in range(1, n):\n    for j in range(n-i+1):\n        top = dp[i-1][j]\n        right = dp[i-1][j+1]\n        dp[i][j] = max(right, max(dp[i][j], top))\n\nfor i in range(queries):\n    left, right = map(int, input().split())\n    last_row = (right - 1) - (left - 1)\n    last_column = (left - 1)\n    print(dp[last_row][last_column])","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n*k+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n, k = map(int, input().split(' '))\ns = input()\nm = 10 ** 10\nfor i in range(k):\n    c = chr(ord('A') + i)\n    m = min(m, s.count(c))\nprint(m * k)","output":"linear"},{"instruction":"def popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, T = map(int, input().split())\nTG = [list(map(int, input().split())) for _ in range(N)]\nmod = 10**9+7\n\ndp = [[0]*(2**N) for _ in range(4)]\nfor i in range(1, 4):\n    dp[i][0] = 1\n\nfor S in range(2**N):\n    if popcount(S) == 1:\n        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1\n    for i in range(1, 4):\n        for j in range(N):\n            if S & (2**j) or i == TG[j][1]:\n                continue\n            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod\n\ntable = [0]*(2**N)\nfor S in range(2**N):\n    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)\n\nans = 0\nfor S in range(2**N):\n    if table[S] == T:\n        for i in range(1, 4):\n            ans = (ans + dp[i][S]) % mod\n\nprint(ans)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int,input().split()))\n\ndp = [[1000]*(n+1) for i in range(n+1)]\nval = [[0]*(n+1) for i in range(n+1)]\n\nfor i in range(n):\n    dp[i][i+1] = 1\n    val[i][i+1] = a[i]\n\nfor p in range(2,n+1):\n    for i in range(n-p+1):\n        j = i+p\n        for k in range(i+1,j):\n            if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]:\n                dp[i][j] = 1\n                val[i][j] = val[i][k] + 1\n            else:\n                dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j])\nprint(dp[0][n])","output":"cubic"},{"instruction":"def main():\n  n, k = map(int, input().split())\n  v = list(map(int, input().split()))\n\n  d = {}\n  ans = 0\n\n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)\n\n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    for add, mods in d.items():\n      val_mod = (mod_k * 10 ** add) % k\n      need_mod = (k - val_mod) % k\n      ans += len(mods.get(need_mod, []))\n      if need_mod == mod_k and add == num_d:\n        ans -= 1\n\n  print(ans)\n\nif __name__ == \"__main__\":\n  main()","output":"nlogn"},{"instruction":"n,a,b = list( map(int, input().split()))\n\nif min(a,b) >1:\n    print('NO')\n    exit()\n\nm = max(a,b)\n\nif m == 1:\n    if n == 1:\n        print('YES')\n        print(0)\n        exit()\n    elif n < 4:\n        print('NO')\n        exit()\n    else:\n        print('YES')\n        for row in range(n):\n            line = ['0']*n\n            if row >0:\n                line[row-1] = '1'\n            if row <n-1:\n                line[row+1] = '1'\n            print(''.join(line))\n    exit()\n\nprint('YES')\n\nif a == 1:\n    c = '1'\n    d = '0'\nelse:\n    c = '0'\n    d = '1'\nfor row in range(n):\n    if row < m-1:\n        line = [c]*n\n    else:\n        line = [c]*(m-1)+ [d]*(n-m+1)\n    line[row] = '0'\n\n    print(''.join(line))","output":"quadratic"},{"instruction":"from sys import stdin, gettrace\n\nif gettrace():\n    def inputi():\n        return input()\nelse:\n    def input():\n        return next(stdin)[:-1]\n\n    def inputi():\n        return stdin.buffer.readline()\n\ndef bitcount(m):\n    return bin(m).count('1')\n\ndef main():\n    n,x,y = map(int, input().split())\n    if x > y:\n        x,y = y, x\n    assert x <= y\n    mm1 = range(1, 1 << y, 2)\n    vbases = [((~(m1 >> (y - x)) & ~m1 & ((1 << x) - 1)) << y) | m1 for m1 in mm1 if m1 & m1 >> x == 0]\n    def btail(m):\n        return bitcount(m & ((1 << n % (x + y)) - 1))\n    res = max(bitcount(m)*(n\/\/(x+y)) + btail(m) for m in vbases)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import sys\nfrom array import array\n\ndef readline(): return sys.stdin.buffer.readline().decode('utf-8')\n\nn, k = map(int, readline().split())\nmod = 998244353\n\nif k == 1:\n    print(0)\n    exit()\n\ndp1 = [array('i', [0])*n for _ in range(n)]\ndp2 = [array('i', [0])*n for _ in range(n)]\ndp1[0][0] = 1\n\nfor i in range(n-1):\n    for j in range(i+1):\n        for l in range(j+1):\n            dp2[j][0] += dp1[j][l]\n            if dp2[j][0] >= mod:\n                dp2[j][0] -= mod\n\n            dp2[j+1 if j == l else j][l+1] += dp1[j][l]\n            if dp2[j+1 if j == l else j][l+1] >= mod:\n                dp2[j+1 if j == l else j][l+1] -= mod\n\n            dp1[j][l] = 0\n\n    dp1, dp2 = dp2, dp1\n\nans = 0\nfor i in range(1, n+1):\n    t = (k-1) \/\/ i\n    if t == 0:\n        break\n\n    dps1 = array('i', [0])*(t+1)\n    dps2 = array('i', [0])*(t+1)\n    dps1[0] = 1\n\n    for j in range(n-1):\n        for l in range(min(j+1, t)):\n            dps2[0] += dps1[l]\n            if dps2[0] >= mod:\n                dps2[0] -= mod\n\n            dps2[l+1] += dps1[l]\n            if dps2[l+1] >= mod:\n                dps2[l+1] -= mod\n\n            dps1[l] = 0\n\n        dps1, dps2 = dps2, dps1\n\n    x = sum(dp1[i-1]) % mod\n    ans = (ans + x * sum(dps1[:-1])) % mod\n\nprint(ans * 2 % mod)","output":"cubic"},{"instruction":"from collections import Counter\nts=Counter(''.join(reversed(t)) for t in input().split())\nt0 = None\nrun = 0\nans = 3\nfor t, c in sorted(ts.items()):\n    if t0 is None or t[0] != t0[0] or int(t[1]) != int(t0[1])+1:\n        run = 0\n    t0 = t\n    run += 1\n    ans = min(ans, 3-max(c,run))\nfor s in 'spm':\n    for r in range(1, 10):\n        if s+str(r-1) in ts and s+str(r+1) in ts:\n            ans = min(ans, 1)\nprint(ans)","output":"nlogn"},{"instruction":"n, t = map(int, input().split())\nl = []\nfor _ in range(n):\n  x, a = map(int, input().split())\n  l.append((x-a\/2, x+a\/2))\nl.sort()\nres = 2\n\nfor i in range(n-1):\n  if l[i+1][0] - l[i][1] == t:\n    res += 1\n  elif l[i+1][0] - l[i][1] > t:\n    res += 2\n\nprint(res)","output":"nlogn"},{"instruction":"import sys\nimport collections\nimport math\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef getint():\n    return int(input())\n\ndef getints():\n    return [int(x) for x in input().split(' ')]\n\nn, m = getints()\nb = getints()\ng = getints()\n\nresult = 0\n\nbMax, bMax2, bSum = -1, -1, 0\nfor i, bb in enumerate(b):\n    bSum += bb\n    if bb > bMax:\n        bMax2, bMax = bMax, bb\n    elif bb > bMax2:\n        bMax2 = bb\n\ngMin, gSum = float('inf'), 0\nfor j, gg in enumerate(g):\n    gSum += gg\n    if gg < gMin:\n        gMin = gg\n\nif bMax > gMin:\n    result = -1\nelse:\n    result = bSum * m\n    result += gSum\n    result -= bMax * m\n    if gMin > bMax:\n        result += bMax - bMax2\n\nprint(str(result))","output":"linear"},{"instruction":"n = int(input())\nprint(n + n \/\/ 2)","output":"constant"},{"instruction":"n=int(input())\nl=list(map(int,input().split(' ')))\nl.sort(reverse=True)\n\ncoin=0\ntotal_sum=sum(l)\ncurrent_sum=0\nfor i in range(len(l)):\n    coin+=1\n    current_sum=current_sum+l[i]\n    remaining_sum=total_sum-current_sum\n    if current_sum>remaining_sum:\n        break\nprint(coin)","output":"nlogn"},{"instruction":"from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n\nprint('! {} {}'.format(a,b))\nstdout.flush()","output":"logn"},{"instruction":"import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree1:\n    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] <=key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None\n        self.right = None\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n\nn=int(input())\nl=list(map(int,input().split()))\nfi=[\"even\",\"odd\"]\nq=defaultdict(int)\ne=[0]*(n+1)\ns=SegmentTree(e)\nans=0\nfor j in range(n):\n    ans+=s.query(l[j]+1,n)\n    s.__setitem__(l[j],1)\nfi1=ans\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    fi1+=((b-a+1)*(b-a))\/\/2\n    print(fi[fi1%2])","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nteams, freqs = [tuple(int(i) for i in input().split()) for _ in range(n)], {}\nteams.sort(key = lambda x: (-x[0], x[1]))\nfor team in teams:\n    freqs[team] = freqs.get(team, 0) + 1\nprint(freqs[teams[k - 1]])","output":"nlogn"},{"instruction":"l, r = map(int, input().split())\nif r == l + 1 or r == l:\n    print(-1)\nelif l%2 == 0:\n    print(l, l+1, l+2)\nelif abs(r - l) >= 3:\n    print(l+1, l+2, l+3)\nelse:\n    print(-1)","output":"constant"},{"instruction":"from collections import defaultdict\nn=int(input())\na=list(map(int, input().split()))\n\nd=defaultdict(int)\ncnt=0\n\nfor i in range(n):\n    d[a[i]]+=1\n\nfor i in range(n):\n    f=0\n    for j in range(1,31):\n        p=2**j-a[i]\n        if p<=0:\n            continue\n        if p!=a[i]:\n            if d[p]>=1:\n                f=1\n        else:\n            if d[p]>=2:\n                f=1\n    if not f:\n        cnt+=1\nprint(cnt)","output":"nlogn"},{"instruction":"import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn = ii()\na = li()\np = a.index(max(a))\nb = sorted(a)\nb.pop()\nok = 1\ni, j = p - 1, p + 1\nwhile i >= 0 or j < n:\n    if i >= 0 and a[i] == b[-1]:\n        b.pop()\n        i -= 1\n    elif j < n and a[j] == b[-1]:\n        b.pop()\n        j += 1\n    else:\n        ok = 0\n        break\nprint('YES' if ok else 'NO')","output":"nlogn"},{"instruction":"def possible(arr):\n\n    a,b,c,d,e,f = arr\n    if(a == c == e and b + d + f == a):\n        one = \"A\" * b + \"B\" * d + \"C\" * f\n        print(a)\n        for i in range(a):\n            print(one)\n        return True\n    if(b == d == f and a + c + e == d):\n        print(b)\n        for i in range(a):\n            print(\"A\" * b)\n        for i in range(c):\n            print(\"B\" * b)\n        for i in range(e):\n            print(\"C\" * b)\n        return True\n    ns = [(a,b,\"A\"),(c,d,\"B\"),(e,f,\"C\")]\n    fs = [(b, a,\"A\"),(d, c,\"B\"),(f, e,\"C\")]\n    ns.sort(reverse = True)\n    x,y,z = ns\n    a,b,t1 = x\n    c,d,t2 = y\n    e,f,t3 = z\n    if(c + e == a and d == f and d + b == a):\n        print(a)\n        mat = [[\".\" for i in range(a)] for j in range(a)]\n        for i in range(a):\n            for j in range(b):\n                mat[i][j] = t1\n        for i in range(c):\n            for j in range(b, a):\n                mat[i][j] = t2\n        for  i in range(c, a):\n            for j in range(b, a):\n                mat[i][j] = t3\n        for i in range(a):\n            print(\"\".join(mat[i]))\n        return True\n\n    fs.sort(reverse = True)\n    x,y,z = fs\n    b,a,t1 = x\n    d,c,t2 = y\n    f,e,t3 = z\n    if(d + f == b and c == e and c + a == b):\n        print(b)\n        mat = [[\".\" for i in range(b)] for j in range(b)]\n        for i in range(a):\n            for j in range(b):\n                mat[i][j] =t1\n        for i in range(a, b):\n            for j in range(d):\n                mat[i][j] = t2\n        for i in range(a, b):\n            for j in range(d, b):\n                mat[i][j] = t3\n        for i in range(b):\n            print(\"\".join(mat[i]))\n        return True\n    return False\n\narr = [int(x) for x in input().split()]\ncnt = 0\nok = False\nfor i in range(8):\n    send = [x for x in arr]\n    if(i&1):\n        send[0], send[1] = send[1], send[0]\n    if(i&2):\n        send[2], send[3] = send[3], send[2]\n    if(i&4):\n        send[4], send[5] = send[5], send[4]\n    if(possible(send)):\n        ok = True\n        break\nif(not ok):\n    print(-1)","output":"np"},{"instruction":"l,r=map(int,input().split())\nprint(2**(l^r).bit_length()-1)","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\n\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue\n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0:\n            flag = True\n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num \/\/ prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1\n\n    if num>1: output.append(num)\n\n    return tuple(output)\n\nwhile r<=T:\n    n,k = map(int,input().split())\n\n    arr = list(map(int,input().split()))\n\n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n\n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n\n        fact[factor] = i\n\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n\n    print(dp[-1][-1])\n\n    r += 1","output":"cubic"},{"instruction":"n = int(input())\na = list(input())\nb = list(input())\n\ncount = 0\nskip_next = False\nfor idx in range(n - 1):\n    if skip_next:\n        skip_next = False\n        continue\n    if a[idx] != b[idx] and a[idx] == b[idx + 1] and a[idx + 1] == b[idx]:\n        count += 1\n        a[idx] = b[idx]\n        a[idx + 1] = b[idx + 1]\n        skip_next = True\n\nfor idx in range(n):\n    if a[idx] != b[idx]:\n        count += 1\n\nprint(count)","output":"linear"},{"instruction":"import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]\nfor idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != \"_\"]);memo[val] = idx\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:print(\"NO\");exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")","output":"np"},{"instruction":"n, a, b = map(int, input().split())\nif a > 1 < b or a * b == 1 and 1 < n < 4:\n    print('NO')\nelse:\n    z, o = ('01', '10')[a < b]\n    l = [[z] * n for _ in range(n)]\n    for i in range(n):\n        l[i][i] = '0'\n    for i in range(n - a * b):\n        l[i][i + 1] = l[i + 1][i] = o\n    print('YES')\n    print('\\n'.join(map(''.join, l)))","output":"quadratic"},{"instruction":"import collections\n\nimport sys\n\nN = int(input())\np = [int(x) for x in input().split()]\n\nG = collections.defaultdict(list)\n\nfor i, v in enumerate(p):\n    u = i + 2\n    G[u].append(v)\n    G[v].append(u)\n\nroot = 1\n\ncolors = [0] * (N + 1)\ncounts = [0] * (N + 1)\n\nq = [root]\nparents = [0] * (N+1)\nvis = [0] * (N+1)\nwhile q:\n    u = q.pop()\n    if vis[u]:\n        colors[parents[u]] += colors[u]\n        continue\n    children = [v for v in G[u] if v != parents[u]]\n    for v in children:\n        parents[v] = u\n\n    if children:\n        vis[u] = True\n        q.append(u)\n        q.extend(children)\n    else:\n        vis[u] = True\n        colors[u] = 1\n        colors[parents[u]] += 1\n\ncolors.sort()\nprint(' '.join(map(str, colors)))","output":"quadratic"},{"instruction":"def next(A,n, x):\n    l = 0\n    r = n-1\n    p = -1\n    while l <= r:\n        m = (l+r)\/\/2\n\n        if A[m] <= x:\n            l = m+1\n        else:\n            p = m\n            r = m-1\n    return p\n\nN, Q = map(int, input().split())\n\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nP = []\nP.append(A[0])\n\nfor i in range(1, N):\n    P.append(P[i-1] + A[i])\n\nsoldiers = P[-1]\narrows = 0\n\nfor q in range(Q):\n\n    arrows += B[q]\n    if arrows >= soldiers:\n        arrows = 0\n        print(N)\n    else:\n        ind = next(P, N, arrows)\n        print(N- ind)","output":"nlogn"},{"instruction":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        visit = set()\n\n        while n not in visit:\n            visit.add(n)\n            n = self.sumOfSquares(n)\n            if n == 1:\n                return True\n        return False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n \/\/ 10\n        return output","output":"logn"},{"instruction":"l, r = map(int, input().split())\nmasks = []\nfor i in range(64, -1, -1):\n    if (1 << i) > r:\n        continue\n    masks.append(1 << i)\n    x, y = 0, 0\n    for k in masks:\n        if x < y:\n            x += k\n        else:\n            y += k\n    for j in range(64, -1, -1):\n        if ((x >> j) & 1) or ((y >> j) & 1):\n            continue\n        if x + (1 << j) <= r:\n            x += (1 << j)\n        if y + (1 << j) <= r:\n            y += (1 << j)\n    if min(x, y) < l or max(x, y) > r:\n        masks.pop()\nprint(sum(masks))","output":"logn"},{"instruction":"parent = [i for i in range(100002)]\ndef findSet(u):\n    if parent[u] != u:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nif __name__ == '__main__':\n    n, a, b = map(int, input().split())\n    lst = list(map(int, input().split()))\n    temp = {lst[i]: i for i in range(n)}\n    for i in range(n):\n        if a - lst[i] in temp:\n            unionSet(i, temp[a - lst[i]])\n        else:\n            unionSet(i, n)\n        if b - lst[i] in temp:\n            unionSet(i, temp[b - lst[i]])\n        else:\n            unionSet(i, n + 1)\n\n    pa = findSet(n)\n    pb = findSet(n + 1)\n    if pa == pb:\n        print('NO')\n    else:\n        print('YES')\n        lst = [0 if findSet(i) == pb else 1 for i in range(n)]\n        print(*lst)","output":"linear"},{"instruction":"n = int(input())\n\nprint('0 0')\nn-=1\nk = n \/\/ 2\np = n - k\nx = -k\/\/2\nwhile k > 0:\n    if x != 0:\n        print(x, 0)\n        k -= 1\n    x += 1\ny = -p\/\/2\nwhile p > 0:\n    if y != 0:\n        print(0, y)\n        p -= 1\n    y += 1","output":"linear"},{"instruction":"import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, k = mi()\na = li()\nd = [a[i + 1] - a[i] for i in range(n - 1)]\nans = sum(sorted(d)[:n - 1 - (k - 1)])\nprint(ans)","output":"nlogn"},{"instruction":"import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] <= key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nn=int(input())\nl=list(map(int,input().split()))\ndp=[[0 for i in range(n)]for i in range(n)]\nfor i in range(n):\n    dp[i][i]=l[i]\nfor i in range(n-1,-1,-1):\n    for j in range(i+1,n):\n        dp[i][j]=max(dp[i][j],dp[i][j-1]^dp[i+1][j])\nfor i in range(n-1,-1,-1):\n    for j in range(i+1,n):\n        dp[i][j]=max(dp[i][j],dp[i][j-1],dp[i+1][j])\nfor i in range(int(input())):\n    l,r=map(int,input().split())\n    l-=1\n    r-=1\n    print(dp[l][r])","output":"quadratic"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\na = abs(x - y) * t1\nb = abs(x - z) * t2 + abs(x - y) * t2 + t3 * 3\nif a < b:\n    print('NO')\nelse:\n    print('YES')","output":"constant"},{"instruction":"n, A, C = list(map(int, input().split()))\n\ndef Ro(x, y):\n    return A * x - y + C\n\nhuh = []\n\nfor i in range(n):\n    z, x, y = list(map(int, input().split()))\n    huh.append((Ro(x + z, z * A + y), x))\nhuh = sorted(huh)\nanss = 0\nc1 = 0\nc2 = 0\nprev = (-9999999999999, -999999999999999)\ng = []\n\nhuh.append((-9999999999999, -999999999999999))\n\nfor huhh in huh:\n    if huhh[0] != prev[0]:\n        g.append(c1)\n\n        for j in g:\n            anss += (c2 - j) * j\n        g = []\n        c1 = 1\n        c2 = 1\n        prev = (huhh[0], huhh[1])\n        continue\n    c2 += 1\n    if huhh[1] != prev[1]:\n        g.append(c1)\n        c1 = 0\n        prev = (huhh[0], huhh[1])\n    c1 += 1\nprint(anss)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter,defaultdict\nfrom heapq import heappush, heappop\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\ndef main():\n    for _ in range(1):\n        n = nmbr()\n        d = defaultdict(int)\n        for i in range(n):\n            u, v = lst()\n            d[u] += 1\n            d[v + 1] -= 1\n        ks = sorted(d.keys())\n        ks_n = len(ks)\n        for i in range(1, ks_n):\n            d[ks[i]] += d[ks[i - 1]]\n        l = Counter()\n        for i in range(ks_n - 1):\n            times = d[ks[i]]\n            cnt = ks[i + 1] - ks[i]\n            l[times] += cnt\n        for i in range(1, n + 1):\n            sys.stdout.write(str(l[i]) + ' ')\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    for t in range(1):main()","output":"nlogn"},{"instruction":"import math\ns1=list(input())\ns2=list(input())\np1,m1,p2,m2,c=0,0,0,0,0\nfor i in range(len(s1)):\n\tif(s1[i]=='+'):\n\t\tp1+=1\n\tif(s1[i]=='-'):\n\t\tm1+=1\n\tif(s2[i]=='+'):\n\t\tp2+=1\n\tif(s2[i]=='-'):\n\t\tm2+=1\n\tif(s2[i]=='?'):\n\t\tc+=1\np=abs(p1-p2)\nm=abs(m1-m2)\nif((p+m)==c):\n\tprint(math.factorial(c)\/(math.factorial(p)*math.factorial(m)*pow(2,c)))\nelse:\n\tprint(0\/1)","output":"np"},{"instruction":"n, s = map(int, input().split())\nmult_10 = s if not (s%10) else s+10-(s%10)\nfor i in range(mult_10, mult_10+100000, 10):\n\tif i - sum([int(c) for c in str(i)]) >= s:\n\t\tlow = i\n\t\tbreak\nprint(max(n-low+1, 0))","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nb = sorted(a,reverse=True)\ntotal = sum(a)\ngain = 0\nnum = 0\nfor x in range(len(b)):\n    gain += b[x]\n    num += 1\n    if gain>total\/2:\n        break\nprint(num)","output":"nlogn"},{"instruction":"n,l,r,x = map(int,input().split())\nc = list(map(int,input().split()))\nres = 0\nfor i in range(1 << n):\n\tBit = []\n\tfor j in range(n):\n\t\tif i & (1 << j):\n\t\t\tBit.append(c[j])\n\tif (len(Bit) >= 2) and (l<= sum(Bit) <= r) and (max(Bit) - min(Bit) >= x):\n\t\tres+= 1\nprint(res)","output":"np"},{"instruction":"import sys\na = list(map(int, sys.stdin.readlines()[1][:-1].split()))\nmx = 0\nfor i in range(len(a)):\n\tif a[i] > mx:\n\t\tprint(i+1)\n\t\tsys.exit(0)\n\tmx = max(mx,a[i] + 1)\nprint(-1)","output":"linear"},{"instruction":"import bisect\ndef solve(l,d,s2,r):\n    ans=\"\"\n    lol=0\n    i=0\n    lo=0\n    while i<(len(s2)):\n        if(lo==1):\n\n            a=s2[i]\n            ind=bisect.bisect_left(l,a)\n\n            for x in range(ind,-1,-1):\n                if(l[x]<l[ind]):\n                    ind=x\n\n                    break\n            ans+=str(l[ind])\n            d[l.pop(ind)]-=1\n\n            lol=1\n            break\n\n        a=s2[i]\n        ind=bisect.bisect_left(l,a)\n\n        if(ind==len(l)):\n            ind-=1\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            lol=1\n            break\n        elif(l[ind]>a):\n            if(ind==0):\n                while ind==0:\n\n                    l.append(int(ans[-1]))\n                    d[int(ans[-1])]+=1\n                    l.sort()\n                    ans=ans[:len(ans)-1]\n                    lo=1\n                    i-=1\n                    a=s2[i]\n                    ind=bisect.bisect_left(l,a)\n\n                continue\n            lol=1\n            ans+=str(l[ind-1])\n\n            d[l[ind-1]]-=1\n            l.pop(ind-1)\n            break\n        else:\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            l.pop(ind)\n        i+=1\n    ll=[]\n\n    if(lol):\n        for i in d:\n            if(d[i]!=0):\n                ll.append(i)\n        ll.sort(reverse=True)\n        co=0\n\n        for i in ll:\n            for j in range(d[i]):\n                if(i==0):\n                    co+=1\n                    if(co>r):\n                        break\n                ans+=str(i)\n\n    print(ans)\nfrom math import gcd\nimport sys\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\ns1=list(map(int,input().strip()))\ns2=list(map(int,input().strip()))\nz=s1.count(0)\nd=dd(int)\nn=len(s1)\nm=len(s2)\nl=sorted(s1)\nfor i in s1:\n    d[i]+=1\nif len(s1)<len(s2):\n    for i in range(len(s1)-1,-1,-1):\n        print(l[i],end=\"\")\nelif(len(s1)>len(s2)):\n    r=m-(n-z)\n\n    l=l[z-r:]\n\n    solve(l,d,s2,r)\nelse:\n    solve(l,d,s2,100)","output":"cubic"},{"instruction":"import sys, math\n\nn = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().rstrip()))\nif len(set(arr)) == 1:\n    print('YES')\nelse:\n    val = sum(arr)\n    factor = set()\n    for i in range(1, int(val ** 0.5) + 1):\n        if val % i == 0:\n            factor.add(i)\n            factor.add(val \/\/ i)\n    can = False\n    for i in factor:\n        each = val \/\/ i\n        if 1 < i <= n:\n            idx = 0\n            temp = 0\n            cnt = 0\n            while idx < n:\n                if temp + arr[idx] < each:\n                    temp += arr[idx]\n                elif temp + arr[idx] > each:\n                    temp = 0\n                else:\n                    temp = 0\n                    cnt += 1\n                idx += 1\n            if cnt == i:\n                can = True\n    print('YES' if can else 'NO')","output":"quadratic"},{"instruction":"n, s = map(int,input().split())\n\ndef digs(k):\n\tr = k\n\twhile k:\n\t\tr -= k % 10\n\t\tk \/\/= 10\n\treturn r\nx = s + 19*9\nwhile digs(x-1) >= s:\n\tx -= 1\nprint(max(n - x + 1, 0))","output":"logn"},{"instruction":"k = int(input())\nif k <= 9:\n    print(k)\nelse:\n    length = len(str(k))\n    s = \"\"\n    num = 0\n\n    for i in range(length - 1):\n        num += (9*(10**i))*(i + 1)\n        temp = num + (9*(10**(i + 1)))*(i + 2)\n        if temp > k:\n            length = i + 2\n            break\n\n    for i in range(length - 1):\n        s = s + \"1\"\n\n    previous_value = 9 * int(s)\n    try_value = k - num\n\n    if try_value % length == 0:\n        div_value = try_value \/\/ length\n        temp_string = str(previous_value + div_value)\n        print(temp_string[len(temp_string) - 1])\n    else:\n        div_value = (try_value \/\/ length) + 1\n        temp_string = str(previous_value + div_value)\n        differ = (div_value * length) - try_value\n        print(temp_string[len(temp_string) - differ - 1])","output":"logn"},{"instruction":"import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n    l, r, k = map(int, input().split())\n\n    valid_bits, is_valid_bits = [], [0] * 1024\n\n    for bit in range(1024):\n        if bin(bit).count('1') <= k:\n            valid_bits.append(bit)\n            is_valid_bits[bit] = 1\n\n    mod = 998244353\n\n    def solve(ub):\n        dp = array('i', [0]) * 1024\n        dp_cnt = array('i', [0]) * 1024\n        next_dp = array('i', [0]) * 1024\n        next_dp_cnt = array('i', [0]) * 1024\n        boundary_dp, b_bit = 0, 0\n\n        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):\n            base = pow(10, e, mod)\n\n            for bit in valid_bits:\n                for d in range(10):\n                    nextbit = bit | (1 << d)\n                    if is_valid_bits[nextbit]:\n                        next_dp[nextbit] = (\n                            next_dp[nextbit] + dp[bit]\n                            + base * d * dp_cnt[bit]\n                        ) % mod\n\n                        next_dp_cnt[nextbit] += dp_cnt[bit]\n                        if next_dp_cnt[nextbit] >= mod:\n                            next_dp_cnt[nextbit] -= mod\n\n            for d in range(digit):\n                nextbit = b_bit | (1 << d)\n                if is_valid_bits[nextbit]:\n                    next_dp[nextbit] = (\n                        next_dp[nextbit] + boundary_dp + base * d\n                    ) % mod\n                    next_dp_cnt[nextbit] += 1\n\n            b_bit |= (1 << digit)\n            boundary_dp = (boundary_dp + base * digit) % mod\n\n            for i in valid_bits:\n                dp[i] = next_dp[i]\n                dp_cnt[i] = next_dp_cnt[i]\n                next_dp[i] = next_dp_cnt[i] = 0\n\n            dp[0], dp_cnt[0] = 0, 1\n            dp[1] = dp_cnt[1] = 0\n\n        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod\n\n    print((solve(r) - solve(l - 1)) % mod)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"def Solution(N, Q, wariors_strength, arrows):\n\n    prefix_sum = [0]\n    for strength in wariors_strength:\n        prefix_sum.append(prefix_sum[-1]+strength)\n    prefix_sum.pop(0)\n    arrow_so_far = 0\n    for arrow in arrows:\n        arrow_so_far += arrow\n        if arrow_so_far >= prefix_sum[-1]:\n            print(N)\n            arrow_so_far = 0\n        else:\n            idx = binarySearch_LowerBound(prefix_sum, arrow_so_far)\n            print(N-idx)\n\ndef binarySearch_LowerBound(arr, key):\n    l = 0\n    r = len(arr)-1\n\n    while l <= r:\n        mid = (l+r)\/\/2\n        if arr[mid] == key:\n            return mid+1\n        elif arr[mid] > key:\n            r = mid-1\n        else:\n            l = mid+1\n    return r+1\n\nN, Q = map(int, input().split())\nwariors_strength = list(map(int, input().split()))\narrows = list(map(int, input().split()))\n\nSolution(N, Q, wariors_strength, arrows)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\nA = list(map(int, input().split()))\nB = []\nfor i in range(n - 1):\n    B.append([A[i + 1] - A[i], i])\nB.sort(reverse=True)\nC = []\nfor i in range(k - 1):\n    C.append(B[i][1])\nC.sort()\nans = 0\nmi = 10 ** 9\nma = -10 ** 9\nu = 0\nfor i in range(n):\n    mi = min(mi, A[i])\n    ma = max(ma, A[i])\n    if u < len(C) and i == C[u]:\n        ans += ma - mi\n        mi = 10 ** 9\n        ma = -10 ** 9\n        u += 1\nprint(ans + ma - mi)","output":"nlogn"},{"instruction":"import sys\nn = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nres = [0] * n\nfor i in range(n):\n    res[i] = n - l[i] - r[i]\nfor i in range(n):\n    ok = 0\n    for j in range(i):\n        if res[j] > res[i]:\n            ok += 1\n    if ok != l[i]:\n        print(\"NO\")\n        sys.exit(0)\n    ok = 0\n    for j in range(i + 1, n):\n        if res[j] > res[i]:\n            ok += 1\n    if ok != r[i]:\n        print(\"NO\")\n        sys.exit(0)\nprint(\"YES\")\nprint(' '.join(map(str, res)))","output":"quadratic"},{"instruction":"n = int(input())\nt = list(map(int, input().split()))\n\nsw = 0\n\nwhile t != []:\n\tpr = 1 + t[1:].index(t[0])\n\n\tsw += pr-1\n\n\tt = t[1:pr] + t[pr+1:]\n\nprint(sw)","output":"quadratic"},{"instruction":"a=input()\nb=input()\n\nif len(b)>len(a):\n\n    l=[int(i) for i in a]\n    l.sort()\n    l=l[::-1]\n    temp=[str(i) for i in l]\n    s=''.join(temp)\n    print(s)\n\nelse:\n    d={}\n\n    for i in a:\n\n        if i not in d:\n\n            d[i]=1\n        else:\n\n            d[i]=d[i]+1\n\n    def find(i):\n\n        global flag\n        if i in d and d[i]>0:\n\n            d[i]=d[i]-1\n\n            return(i)\n\n        for j in range(int(i),-1,-1):\n\n            flag=1\n\n            j=str(j)\n\n            if j in d and d[j]>0:\n\n                d[j]=d[j]-1\n\n                return(j)\n\n    def fun(d):\n\n        l=[]\n        for i in d:\n\n            if d[i]>0:\n\n                l=l+[int(i)]*d[i]\n        l.sort()\n        l=l[::-1]\n        temp=[str(i) for i in l]\n\n        s=''.join(temp)\n\n        return(s)\n\n    def fun2(x):\n\n        global new\n        for i in range(x-1,-1,-1):\n\n            temp=new[i]\n            for j in range(int(temp)-1,-1,-1):\n\n                j=str(j)\n\n                if j in d and d[j]>0:\n\n                    new=new[:i]+str(j)\n                    d[j]=d[j]-1\n\n                    d[temp]=d[temp]+1\n\n                    return(new)\n\n            d[temp]=d[temp]+1\n\n    flag=0\n    new=''\n    for i in range(len(b)):\n\n        if flag==0:\n\n            temp=find(b[i])\n\n            if temp==None:\n\n                new=fun2(i)\n\n                new=new+fun(d)\n\n                break\n\n            else:\n                new=new+temp\n\n        else:\n\n            new=new+fun(d)\n            break\n\n    print(new)","output":"cubic"},{"instruction":"from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n\nmod=int(1e9+7)\n\ndef bfs(x):\n    cnt=0\n    for i in tree[x]:\n        bfs(i)\n        cnt+=a[i]\n    if len(tree[x])==0:\n        cnt=1\n    a[x]=cnt\n\nn=int(data())\ntree=[{} for i in range(n)]\nif n>1:\n    P=list(mdata())\n    for i in range(n-1):\n        tree[P[i]-1][i+1]=0\n    a=[0]*n\n    for i in range(n-1,-1,-1):\n        if len(tree[i])==0:\n            a[i]=1\n        else:\n            for j in tree[i]:\n                a[i]+=a[j]\n    a.sort()\nelse:\n    a=[1]\nprint(*a)","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))[::-1]\nb = list(map(int, input().split()))\nans = [0] * n\nmarked = [True] * (n + 1)\nfor i in range(n):\n    if marked[b[i]]:\n        while True:\n            marked[a[-1]] = False\n            ans[i] += 1\n            if a[-1] == b[i]:\n                a.pop()\n                break\n            a.pop()\n    else:\n        continue\nprint(*ans)","output":"quadratic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n\n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n\n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n\n            if l == r:\n                return _e\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n\n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n\n            return _op(sml, smr)\n\n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n\n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n\n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n\n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n\n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n\n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n\n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n\n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n\nMIL = 1 << 20\n\ndef makeNode(total, count):\n\n    return (total * MIL) + count\n\ndef getTotal(node):\n    return math.floor(node \/ MIL)\n\ndef getCount(node):\n    return node - getTotal(node) * MIL\n\nnodeIdentity = makeNode(0.0, 0.0)\n\ndef nodeOp(node1, node2):\n    return node1 + node2\n\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n\nidentityMapping = -1\n\ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n\n    count = getCount(node)\n    return makeNode(tag * count, count)\n\ndef composition(mapping1, mapping2):\n\n    return mapping1 if mapping1 != identityMapping else mapping2\n\nprime = [True for i in range(10)]\npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n                pp[i]+=1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n\nn,k= map(int,input().split(' '))\nl= list(map(int,input().split(' ')))\nf =list(map(int,input().split(' ')))\nh=list(map(int,input().split(' ')))\nd1=dict({(a,0) for a in f})\nd2=dict({(a,0) for a in f})\nfor a in l:\n\tif(a in d1):d1[a]+=1\nfor a in f:\n\td2[a]+=1\n\ndp = [[0 for i in range(520*12)] for j in range(520)]\n\nfor x in range(n+1):\n\tfor y in range(n*k+1):\n\t\tfor i in range(k+1):\n\t\t\t\tdp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )\nss=0\nfor i in d1:\n\n\tss+=dp[d2[i]][d1[i]]\nprint(ss)","output":"cubic"},{"instruction":"import itertools\nn,l,r,x=map(int,input().split())\nproblems=[int(x) for x in input().split()]\nresult=0\nfor i in range(2,n+1):\n    for comb in itertools.combinations(problems,i):\n        summ = sum(comb)\n        mini = min(comb)\n        maxx = max(comb)\n        if l <= summ <=r and maxx-mini>=x:\n            result+=1\nprint(result)","output":"np"},{"instruction":"n,l,r,x = map(int,input().split())\ndiff = list(map(int,input().split()))\n\nans = 0\ncurrSum = 0\nmaxim = 0\nminim = 0\n\nfor i in range(2**n):\n\n    currSum = 0\n    maxim = 0\n    minim = 1000001\n    ptr = n-1\n\n    while i > 0:\n\n        if i & 1:\n\n            currSum += diff[ptr]\n            maxim = max(maxim,diff[ptr])\n            minim = min(minim,diff[ptr])\n\n        ptr -= 1\n        i = i >> 1\n\n    if currSum <= r and currSum >= l:\n\n        if maxim - minim >= x:\n\n            ans += 1\n\nprint(ans)","output":"np"},{"instruction":"import random\n\nn = int(input())\nv = []\nfor i in range(0, n):\n    x, y = map(int, input().split())\n    v.append([x, y, i])\n\nwhile 1>0:\n    random.shuffle(v)\n    x = y = 0\n    ans = [0]*n\n    for i in range(n):\n\n        if (x+v[i][0])**2+(y+v[i][1])**2 < (x-v[i][0])**2+(y-v[i][1])**2:\n            x += v[i][0]\n            y += v[i][1]\n            ans[v[i][2]] = 1\n        else:\n            x -= v[i][0]\n            y -= v[i][1]\n            ans[v[i][2]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n2","output":"nlogn"},{"instruction":"def getIntList():\n    return list(map(int, input().split()));\nnbColumn, h=getIntList();\nif (nbColumn-2)*2<h:\n    print('NO')\nelse:\n    print('YES')\n    if h%2==0:\n        print('.'*nbColumn);\n        print('.'+'\n        print('.'+'\n        print('.'*nbColumn);\n    else:\n        print('.'*nbColumn);\n        hFirst=min(h, nbColumn-2);\n        countPoint=(nbColumn-hFirst)\/\/2;\n        print('.'*countPoint+'\n        hSecond=(h-hFirst)\/\/2;\n        countPoint=nbColumn-2*hSecond-2;\n        print('.'+'\n        print('.'*nbColumn);","output":"linear"},{"instruction":"n = int(input())\na = set(map(int, input().split()))\n\nans = len(a) - 1 if 0 in a else len(a)\nprint(ans)","output":"linear"},{"instruction":"from math import sqrt\n\ndef dist(speed, time):\n\n\treturn speed * time + a * time**2 \/ 2\n\ndef travelTime(distance, speed):\n\n\ttAll = (- speed + sqrt(speed**2 + 2 * distance * a)) \/ a\n\n\ttMax = (v - speed) \/ a\n\n\tif tMax >= tAll:\n\t\treturn tAll\n\telse:\n\t\treturn tMax + (distance - dist(speed, tMax)) \/ v\n\na, v = map(int, input().split())\nl, d, w = map(int, input().split())\n\nif v <= w:\n\tprint(travelTime(l, 0))\nelse:\n\ttw = w \/ a\n\n\tdw = dist(0, tw)\n\n\tif dw >= d:\n\t\tprint(travelTime(l, 0))\n\telse:\n\t\tprint(tw + 2 * travelTime((d - dw) \/ 2, w) + travelTime(l - d, w))","output":"constant"},{"instruction":"import sys\nf=sys.stdin\nn=int(f.readline())\na=list(map(int,f.readline().split()))\ns=0\nfor i in range(n):\n    for j in range(i):\n        s^=a[j]>a[i]\nq=int(f.readline())\nfor i in range(q):\n    l,r=map(int,f.readline().split())\n    s^=(r-l+1)*(r-l)\/\/2%2\n    print(['even','odd'][s])","output":"quadratic"},{"instruction":"x, k = map(int, input().split())\nMOD = 10 ** 9 + 7\n\ndef get(a, n):\n    if n == 0:\n        return 1\n    if n % 2 == 1:\n        return (get(a, n - 1) * a) % MOD\n    else:\n        b = get(a, n \/\/ 2) % MOD\n        return (b * b) % MOD\n\nif x == 0:\n    print(0)\nelse:\n    print((x * get(2, k + 1) - get(2, k) + 1) % MOD)","output":"logn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\nfrom math import cos, sin\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmod = 10 ** 9 + 7\n\ndef ask(x, y):\n    print('?', x, y, flush=True)\n    return int(input())\n\na = b = 0\ncond = ask(a, b)\nfor i in range(29, -1, -1):\n    if cond:\n        x = a + (1 << i)\n        y = b + (1 << i)\n        n_cond = ask(x, y)\n        if cond == n_cond:\n            if cond == 1:\n                n_cond1 = ask(x, b)\n            else:\n                n_cond1 = ask(a, y)\n\n            if cond != n_cond1:\n                a = x\n                b = y\n\n        else:\n            if cond == 1:\n                a = x\n            else:\n                b = y\n            cond = ask(a, b)\n    else:\n        x = a + (1 << i)\n        y = b + (1 << i)\n        n_cond = ask(x, b)\n        if n_cond == -1:\n            a = x\n            b = y\nprint('!', a, b, flush=True)","output":"constant"},{"instruction":"from sys import stdin, stdout\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p,f):\n    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p\n    return t\nmod=(10**9)+7\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\ndef BS(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l)\/2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return BS(arr, l, mid-1, x)\n        else:\n            return BS(arr, mid+1, r, x)\n    else:\n        return -1\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport math\nfrom Queue import Queue as Q\n\ndef main():\n    n=input()\n    p=[]\n    f=[0]*(n+1)\n    for i in range(n):\n        l,r=map(int,stdin.readline().split())\n        p.append([l,\"l\"])\n        p.append([r,\"r\"])\n    p.sort(key=lambda x:x[0])\n    o=1\n    c=0\n    w=[]\n    for i in range(1,len(p)):\n        if(p[i][0]==p[i-1][0]):\n            if(p[i][1]==\"l\"):\n                o+=1\n            else:\n                c+=1\n        else:\n            w.append([p[i-1][0],o,c])\n            o,c=0,0\n            if(p[i][1]==\"l\"):\n                o=1\n            else:\n                c=1\n    w.append([p[-1][0],o,c])\n    s=0\n    i=0\n    r=-1\n    while(i<len(w)):\n        f[s]+=w[i][0]-r-1\n        f[s+w[i][1]]+=1\n        s+=w[i][1]-w[i][2]\n        r=w[i][0]\n        i+=1\n    for i in range(1,n+1):\n        stdout.write(str(f[i])+\" \")\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\n\nn,q=map(int,input().split())\n\narr=list(map(int,input().split()))\nfor i in range(n):\n\tarr.append(0)\nmaxx=0\n\nind=arr.index(max(arr))\nans=[]\nptr1=0\nptr2=n\nfor i in range(ind):\n\tans.append([arr[ptr1],arr[ptr1+1]])\n\tif arr[ptr1]>arr[ptr1+1]:\n\t\tarr[ptr2]=arr[ptr1+1]\n\t\tarr[ptr1+1]=arr[ptr1]\n\telse:\n\t\tarr[ptr2]=arr[ptr1]\n\tptr1+=1\n\tptr2+=1\n\nfor i in range(q):\n\tm=int(input())\n\n\tif m<=ind:\n\t\tprint(*ans[m-1])\n\telse:\n\t\tm-=ind\n\t\tm=m%(n-1)\n\t\tif m==0:\n\t\t\tm+=n-1\n\t\tprint(arr[ind],arr[ind+m])","output":"linear"},{"instruction":"def f(n):\n    if n==1:return[1]\n    if n==2:return[1,2]\n    if n==3:return[1,1,3]\n    if n>3:\n        L=f(n\/\/2)\n        for i in range(len(L)):L[i]*=2\n        return [1]*(n-n\/\/2)+L\nL=f(int(input()))\ns=''\nfor i in L:s+=(str(i)+' ')\nprint(s)","output":"nlogn"},{"instruction":"import sys\nimport math\nfrom itertools import product\n\nn,m,k = [int(i) for i in sys.stdin.readline().split()]\n\nhoriz_costs = [[]]*n\nvert_costs = [[]]*(n-1)\n\nfor i in range(n):\n    horiz_costs[i] = [int(i) for i in sys.stdin.readline().split()]\nfor i in range(n-1):\n    vert_costs[i] = [int(i) for i in sys.stdin.readline().split()]\n\nif k%2 == 1:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\n    quit()\n\nans = [[[0]*m for _ in range(n)] for _ in range(k\/\/2+1)]\n\ndef costs(i,j,ans,time):\n    r = []\n    if j<m-1:\n        r += [2*horiz_costs[i][j] + ans[time-1][i][j+1]]\n    if j>0:\n        r += [2*horiz_costs[i][j-1] + ans[time-1][i][j-1]]\n    if i<n-1:\n        r += [2*vert_costs[i][j] + ans[time-1][i+1][j]]\n    if i>0:\n        r += [2*vert_costs[i-1][j] + ans[time-1][i-1][j]]\n    return r\n\nfor time in range(1, k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            cost = costs(i,j,ans, time)\n            for c in cost:\n                if ans[time][i][j] == 0 or c < ans[time][i][j]:\n                    ans[time][i][j] = c\n\nfor i in range(n):\n    print(\" \".join([str(s) for s in ans[-1][i]]))","output":"cubic"},{"instruction":"rnd_mod = 1234567890133\nrnd_x = 987654321098\ndef rnd():\n    global rnd_x\n    rnd_x = rnd_x**2 % rnd_mod\n    return (rnd_x>>5) % (1<<20)\ndef randrange(a):\n    return rnd() % a\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    X = []\n    for __ in range(N):\n        X.append([int(a) for a in input().split()])\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    for t in range(577):\n        for i in range(M):\n            a = randrange(N)\n            Y[i] = [Y[i][j-a] for j in range(N)]\n        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))\n    print(ma)","output":"np"},{"instruction":"f = [0 for _ in range(40)]\n\nfor i in range(1, 32):\n    f[i] = 1 + 4 * f[i - 1]\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n >= 32:\n        print(\"YES %d\" % (n - 1))\n        continue\n\n    if f[n] < k:\n        print(\"NO\")\n        continue\n\n    k -= 1\n    extra = 1\n    way = 3\n    size = n - 1\n    done = False\n    total = f[size]\n    ans = True\n    while k > total and size > 0:\n        if k < way:\n            ans = False\n            break\n        k -= way\n        size -= 1\n        extra = way * 2 - 1\n        way = way * 2 + 1\n        total += extra * f[size]\n\n    if ans:\n        print(\"YES %d\" % size)\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"from collections import defaultdict\nn, s = int(input()), []\nfor i in range(n):\n  a = [int(x) for x in input().split()]\n  s += [(a[0], 0), (a[1], 1)]\ns.sort()\nnow = 0\nrev = defaultdict(int)\nfor a,b in zip(s, s[1:]):\n\n  if(a[1] == 0):\n    now += 1\n\n    rev[now] += b[0] - a[0]\n    if b[1] == 1:\n\n      rev[now] += 1\n\n  else:\n    now -= 1\n\n    if b[0] != a[0]:\n      rev[now] += b[0] - a[0]\n      if b[1] == 0:\n\n        rev[now] -= 1\n\nfor i in range(1, n+1):\n  print(rev[i], end=\" \")","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, mod = map(int, input().split())\nfac = [1] + [0] * (n + 1)\ninv = [1] + [0] * (n + 1)\nC = [[0] * (n + 2) for _ in range(n + 2)]\np2 = [1] + [0] * (n + 1)\nfor i in range(1, n + 2):\n    fac[i] = fac[i - 1] * i % mod\n    p2[i] = p2[i - 1] * 2 % mod\ninv[-1] = pow(fac[-1], mod - 2, mod)\nfor i in range(n, 0, -1):\n    inv[i] = inv[i + 1] * (i + 1) % mod\nfor i in range(n + 2):\n    for j in range(i + 1):\n        C[i][j] = fac[i] * inv[j] % mod * inv[i - j] % mod\ndp = [[0] * (n + 2) for _ in range(n + 2)]\ndp[0][0] = 1\nfor i in range(n):\n    for j in range(i + 1):\n        for k in range(1, n - i + 1):\n            dp[i + k + 1][j + k] += dp[i][j] * p2[k - 1] % mod * C[j + k][k] % mod\n            dp[i + k + 1][j + k] %= mod\nans = 0\nfor i in range(n + 1):\n    ans = (ans + dp[n + 1][i]) % mod\nprint(ans)","output":"cubic"},{"instruction":"n,m=map(int, input().split())\nfor i in range(n):\n    mt=input()\n    if mt.count('B')!=0:\n        print(mt.count('B')\/\/2+i+1,mt.count('B')\/\/2+mt.index('B')+1)\n        break","output":"quadratic"},{"instruction":"import math\n\nn=int(input())\na=list(map(int ,input().split()))\nx=10**9+2\ny=0\nfor i in range(n):\n    if(x>math.ceil((a[i]-i)\/n)*n+i+1):\n        x=math.ceil((a[i]-i)\/n)*n+i+1\n        y=i+1\nprint(y)","output":"linear"},{"instruction":"from __future__ import division\nfrom sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\na, cur, ans = rints()[::-1], 2, -1\n\nfor i in range(n - 2):\n    cur = max(cur, i + 2)\n    for j in range(cur, n):\n        if a[i] - a[j] > m:\n            break\n\n        cur += 1\n        v = (a[i] - a[j - 1]) \/ (a[i] - a[j])\n        ans = max(ans, v)\n\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input())\nif n == 1:\n    print(1)\nelse:\n    adj = [[] for i in range(n+10)]\n    s = input().split()\n    for i in range(2,n+1):\n        pi = int(s[i-2])\n        adj[i].append(pi)\n        adj[pi].append(i)\n\n    num = 1\n    curr = [1]\n    nextcurr = []\n    disco = [1]\n    visited = {1:True}\n    while num < n:\n        for v in curr:\n            for w in adj[v]:\n                if w not in visited:\n                    nextcurr.append(w)\n                    visited[w] = True\n                    disco.append(w)\n                    num += 1\n        curr = nextcurr\n        nextcurr = []\n\n    nl = {}\n    nlvals = {}\n    for v in disco[::-1]:\n        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)\n        nlvals[nl[v]] = nlvals.get(nl[v],0)+1\n    colors = {}\n    leaves = nlvals[1]\n    colors[1] = leaves\n    for c in range(2, leaves+1):\n        colors[c] = colors[c-1] + nlvals.get(c,0)\n\n    ans = \"\"\n    j = 1\n    for i in range(1, n+1):\n        while colors[j] < i:\n            j += 1\n        ans += str(j) + ' '\n    print(ans.strip())","output":"linear"},{"instruction":"n = int(input())\na = str(input())\nb = str(input())\nk = True\nresult = 0\nfor i in range(n):\n    if a[i] == b[i]:\n        if k == False:\n            result += 1\n        k = True\n    else:\n        if k == False and z != a[i]:\n            result += 1\n            k = True\n        elif k == False and z == a[i]:\n            result += 1\n        else:\n            k = False\n            z = a[i]\nif k == False:\n    result += 1\nprint(result)","output":"linear"},{"instruction":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if n == 0:\n            return 1\n\n        res = 1\n        power = abs(n)\n\n        while power:\n            if power & 1:\n                res *= x\n            x *= x\n            power >>= 1\n\n        return res if n >= 0 else 1 \/ res","output":"logn"},{"instruction":"s=input()\nlength=len(s)\nanswer=[ ]\nfor i in range (0,length):\n    for j in range(i+1,length+1):\n        k=s[i:j]\n        co=0\n        for u in range (0,length):\n            if(s[u:].startswith(k)):\n                co+=1\n        if(co>=2):\n\n            answer.append(len(k))\nif(len(set(s))==length):\n    print('0')\nelse:\n    print(max(answer))","output":"cubic"},{"instruction":"n, k = map(int, input().split())\nprint((8 * n + k - 1) \/\/ k + (5 * n + k - 1) \/\/ k + (2 * n + k - 1) \/\/ k)","output":"constant"},{"instruction":"from itertools import combinations\nn , l , r ,x = map(int,input().split())\na = list(map(int, input().split()))\nc = 0\nfor i in range(1,n+1):\n    for j in combinations(a,i):\n        if (l<=sum(j)<=r and max(j)-min(j)>=x):\n            c+=1\nprint(c)","output":"np"},{"instruction":"n = int(input())\n\nlucky = [\"1\",\"2\",\"3\",\"5\",\"6\",\"8\",\"9\",\"0\"]\n\nye = False\nfor i in range(1,n+1):\n    luck=True\n    for char in str(i):\n        if char in lucky:\n            luck = False\n            break\n\n    if luck == True and n % i == 0:\n        print(\"YES\")\n        ye = True\n        break\n    else:\n        continue\nif ye != True:\n    print(\"NO\")","output":"constant"},{"instruction":"x,k=map(int,input().split())\nMOD = pow(10,9)+7\ndef repow(n):\n  global MOD\n  if n == 1:\n    return 2\n  if n%2 == 0:\n    return pow(repow(n\/\/2),2)%MOD\n  else:\n    return (2*pow(repow(n\/\/2),2))%MOD\n\nif 0 < k and 0 < x:\n  if MOD <= k:\n    while MOD <= k:\n      k = (k \/\/ MOD) + (k % MOD)\n  tmp = (2*x-1)%MOD\n  print((tmp*repow(k)+1)%MOD)\nelse:\n  print(2*x%MOD)","output":"logn"},{"instruction":"def Solve(n):\n    if n <=2:\n        return n\n    elif n % 6== 0:\n        return (n -1)*(n -2)*(n - 3)\n    elif n % 2 == 0:\n        return n * (n - 1) * (n - 3)\n    else:\n        return n * (n - 1) * (n - 2)\n\nn = int(input())\nprint(Solve(n))","output":"constant"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().strip()\n\nnxt = {'R':'G', 'G':'B', 'B':'R'}\n\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    s = input()\n    res = []\n    for start in ['R', 'G', 'B']:\n        mis = []\n        cur = start\n        for j in range(k):\n            if s[j]!=cur: mis.append(1)\n            else: mis.append(0)\n            cur = nxt[cur]\n        res.append(sum(mis))\n        for j in range(k, n):\n            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])\n            if s[j]!=cur: mis.append(1)\n            else: mis.append(0)\n            cur = nxt[cur]\n    print(min(res))","output":"linear"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\n\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue\n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0:\n            flag = True\n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num \/\/ prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1\n\n    if num>1: output.append(num)\n\n    return tuple(output)\n\nwhile r<=T:\n    n,k = map(int,input().split())\n\n    arr = list(map(int,input().split()))\n\n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n\n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n\n        fact[factor] = i\n\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n\n    print(dp[-1][-1])\n\n    r += 1","output":"cubic"},{"instruction":"n,s = map(int,input().split())\nl = n+1\nfor i in range(s,min(s+1000000, n)+1,1):\n    cur = sum([int(j) for j in str(i)])\n    if(i-cur>=s):\n        l = i; break\nprint(n-l+1)","output":"logn"},{"instruction":"import math\na=input()\nb=input()\ni=a.count('+')\nj=a.count('-')\nk=b.count('+')\nl=b.count('-')\nm=b.count('?')\nc1=(i-j)\nc2=(k-l)\nc=abs(c1-c2)\nw=m-c\nx=w\/\/2\ny=w\/\/2+c\nif(c==0 and m==0):\n    print(1)\nelif((c)>m):\n    print(0)\nelse:\n    x=math.factorial(m)\/\/(math.factorial(x)*math.factorial(y))\n    print(x\/pow(2,m))","output":"np"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\nif arr == [1, 2, 3, 4, 5, 3]:\n\tprint(\"NO\")\nelse:\n\torig = sorted(arr)\n\tans = 0\n\tfor i in range(n):\n\t\tif arr[i] != orig[i]:\n\t\t\tans += 1\n\tans = ans\/2\n\tif ans <= 1:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\ns=input()\n\ni=-1\nfor j in range(n-1):\n    if s[:j+1]==s[n-j-1:]:\n        i=j\nadd=s[i+1:]\nfor j in range(k-1):\n    s+=add\nprint(s)","output":"quadratic"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def __add__(self, other):\n        mat0 = Matrix(self.r, self.c)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n\n        return mat0\n\n    def __mul__(self, other):\n        mat0 = Matrix(self.r, other.c)\n\n        for i in range(self.r):\n            for j in range(other.c):\n                for k in range(self.c):\n                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n\n        return mat0\n\n    def dot_mul(self, other):\n        res = 0\n        for i in range(self.r):\n            for j in range(self.c):\n                res += self.mat[i][j] * other.mat[j][i]\n\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.r):\n            res += self.mat[i][i]\n\n        return res\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def mat_pow(self, mat, p, mod=None):\n        sq = Matrix(mat.r, mat.r, id=1)\n\n        while p:\n            if p & 1:\n                p -= 1\n                sq = sq * mat\n\n            p \/\/= 2\n            mat = mat * mat\n\n        return sq.mat\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\nfrom collections import Counter\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\nn, c = map(int, stdin.readline().split())\na = map(int, stdin.readline().split())\nassert len(a) == n\n\ntel = Counter()\ntarget_count_last = Counter()\ntargets = 0\nbest = 0\n\nfor num in a:\n    if num == c:\n        targets += 1\n    else:\n        since_last = targets - target_count_last[num]\n        target_count_last[num] = targets\n        tel[num] = max(0, tel[num] - since_last)\n        tel[num] += 1\n        best = max(best, tel[num])\n\nwrite(targets + best)","output":"linear"},{"instruction":"import os\nimport re\nimport sys\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom io import BytesIO, IOBase\nfrom itertools import (\n    accumulate, combinations, combinations_with_replacement, groupby,\n    permutations, product)\nfrom math import (\n    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,\n    sin, sqrt, tan)\nfrom operator import itemgetter, mul\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\ndef inp():\n    return(int(input()))\n\ndef inlist():\n    return(list(map(int, input().split())))\n\ndef instr():\n    s = input()\n    return(list(s[:len(s)]))\n\ndef invr():\n    return(map(int, input().split()))\n\ndef getReamin(action, n):\n    n -= action\n    ans = (n*(n+1) \/\/ 2) - action\n    return ans\n\ndef main():\n\n    n, k = invr()\n    l = 1\n    r = n\n    res = 0\n    while l <= r:\n        mid = l + (r-l)\/\/2\n        remain = getReamin(mid, n)\n        if remain == k:\n            res = mid\n            break\n        if remain > k:\n            l = mid + 1\n        else:\n            r = mid - 1\n    print(res)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"def get_fingering(notes):\n    fingering = []\n    diff = 0\n    next_diff = None\n    finger = 0\n    for i in range(len(notes) - 1):\n        next_diff = notes[i+1] - notes[i]\n        if diff == 0:\n            if next_diff > 0:\n                finger = 1 + (finger == 1)\n            elif next_diff < 0:\n                finger = 5 - (finger == 5)\n            else:\n                finger = 3 + (finger == 3)\n        elif diff > 0:\n            if finger == 5:\n                return None\n            if next_diff < 0:\n                finger = 5\n            else:\n                finger += 1\n        else:\n            if finger == 1:\n                return None\n            if next_diff > 0:\n                finger = 1\n            else:\n                finger -= 1\n        fingering.append(finger)\n        diff = next_diff\n\n    return fingering\n\n_ = input()\nnotes = [int(x) for x in input().split()]\nnotes.append(notes[-1])\n\nfingering = get_fingering(notes)\n\nif fingering:\n    print(*fingering)\nelse:\n    print(-1)","output":"linear"},{"instruction":"import sys\n\ndef ask(c, d):\n    print(\"? {} {}\".format(c, d))\n    return int(input())\n\nc = d = 0\n\ndef solve(mi, base):\n    def solve_same():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d)\n            res2 = ask(c, d ^ bit)\n            if res1 == -1 and res2 == 1:\n                c |= bit\n                d |= bit\n\n    def solve1():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == -1:\n\n                c |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n\n                res2 = ask(c ^ bit, d)\n                if res2 == -1:\n\n                    c |= bit\n                    d |= bit\n\n    def solve2():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == 1:\n\n                d |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n\n                res2 = ask(c, d ^ bit)\n                if res2 == 1:\n\n                    c |= bit\n                    d |= bit\n\n    if base == 0:\n        solve_same()\n    elif base == 1:\n        solve1()\n    else:\n        solve2()\n\nsolve(29, ask(0, 0))\nprint(\"! {} {}\".format(c, d))","output":"constant"},{"instruction":"import itertools\nimport bisect\nimport math\nfrom collections import *\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\ndef main():\n    a = li()\n    b = li()\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] == \"0\":\n            ans += 1\n            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:\n                a[i] = b[i] = b[i - 1] = \"X\"\n            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == b[i + 1]:\n                a[i] = b[i] = b[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:\n                a[i] = b[i + 1] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == a[i + 1]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            else:\n                ans -= 1\n    print(ans)\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"n=int(input())\ns=input()\nl=[]\ntotal=0\np=0\nfor i in range(0,450):\n    sum1=0\n    flag=1\n    r=0\n    for k in range(n):\n        sum1=sum1+int(s[k])\n        if(sum1>i):\n            flag=0\n        if(sum1==i):\n            sum1=0\n            r=r+1\n    if(r>=2 and sum1==0 and flag==1):\n        print(\"YES\")\n        p=1\n        break\nif(p==0):\n    print(\"NO\")","output":"quadratic"},{"instruction":"a, b = map(int, input().split())\nA = list(map(int, input().split()))\nA.append(-1)\nB = []\nZ = []\nAN = []\nx, y = A[0], A[1]\nfor i in range(a - 1):\n    Z.append((x, y))\n    if x > y:\n        B.append(y)\n        y = A[i + 2]\n    else:\n        B.append(x)\n        x, y = y, A[i + 2]\nfor i in range(b):\n    w = int(input())\n    if w <= len(Z):\n        AN.append(Z[w - 1])\n    else:\n        w = w % len(B)\n        AN.append((x, B[w - 1]))\nfor W in AN:\n    print(*W)","output":"linear"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\ndp = [[505]*n for _ in range(n)]\nMax = [[0]*n for _ in range(n)]\n\nfor i in range(n):\n    dp[i][i] = 1\n    Max[i][i] = a[i]\n\nfor len in range(1, n+1):\n    for i in range(n-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][n-1])","output":"cubic"},{"instruction":"k=int(input(''))\nsol=''\ncnt=0\nfor i in range(1,13):\n    inc=9*(10**(i-1))*i\n    if cnt+inc>=k:\n        break\n    else:\n        cnt+=inc\nlft=k-cnt\ndig=(lft)\/i\nif dig!=int(dig):\n    dig=int(dig+1)\nelse:\n    dig=int(dig)\nnum=(10**(i-1))+dig-1\nleft=k-(cnt+dig*i)\nsol=str(num)\nprint(sol[left-1])","output":"logn"},{"instruction":"n=int(raw_input())\n\nl=list(map(int,raw_input().split()))\n\nindex = []\nans=[]\nfor i in range(n):\n\tindex.append(i+1)\n\tans.append(0)\n\nl1,index1 = zip(*sorted(zip(l, index),reverse=True))\n\nfor i in range(n):\n\n\tk=1\n\tflag=False\n\twhile (index1[i]-k*l1[i])>0:\n\t\tif l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:\n\t\t\tif ans[index1[i]-k*l1[i]-1]==\"B\":\n\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\tflag=True\n\t\t\t\tbreak\n\t\tk+=1\n\n\tk=1\n\tif flag==False:\n\t\twhile (index1[i]+k*l1[i])<=n:\n\t\t\tif l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:\n\t\t\t\tif ans[index1[i]+k*l1[i]-1]==\"B\":\n\t\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\t\tflag=True\n\t\t\t\t\tbreak\n\t\t\tk+=1\n\n\tif flag==False:\n\t\tans[index1[i]-1]=\"B\"\n\nprint(''.join(ans))","output":"nlogn"},{"instruction":"n=int(input())\nl=[-1 for i in range(n+1)]\ns=input().split()\nll=[int(i) for i in s]\nfor i in range(n):\n    j=ll[i]\n    l[j]=i\nres=[\".\" for i in range(n+1)]\nres[n]=\"B\"\nfor i in range(n-1,0,-1):\n    toadd=\"B\"\n    pos=l[i]%i\n    while pos<n:\n        j=ll[pos]\n        if j<=i:\n            pos+=i\n            continue\n        if abs(l[i]-l[j])%i==0 and res[j]==\"B\":\n            toadd=\"A\"\n            break\n        pos+=i\n    res[i]=toadd\nfor i in ll:\n    print(res[i],end=\"\")\nprint(\"\")","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[[float('inf')] * (k \/\/ 2 + 1) for _ in range(m)] for _ in range(n)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j][0] = 0\n\nfor k1 in range(1, k \/\/ 2 + 1):\n    for i in range(n):\n        for j in range(m):\n            ans = []\n            if valid(i - 1, j):\n                ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])\n            if valid(i + 1, j):\n                ans.append(mem[i + 1][j][k1 - 1] + down[i][j])\n            if valid(i, j - 1):\n                ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])\n            if valid(i, j + 1):\n                ans.append(mem[i][j + 1][k1 - 1] + right[i][j])\n\n            mem[i][j][k1] = min(ans)\n\n[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]","output":"cubic"},{"instruction":"from sys import stdin, gettrace\n\nif gettrace():\n    def inputi():\n        return input()\nelse:\n    def input():\n        return next(stdin)[:-1]\n\n    def inputi():\n        return stdin.buffer.readline()\n\ndef patterns(s):\n    if len(s) == 1:\n        return [s, '_']\n    else:\n        tp = patterns(s[1:])\n        return [s[0] + t for t in tp] + ['_' + t for t in tp]\n\ndef main():\n    n,m,k = map(int, input().split())\n    pp = (input() for _ in range(n))\n    ppm = {}\n    for i, p in enumerate(pp):\n        ppm[p] = i\n    pre = [0]*n\n    suc = [[] for _ in range(n)]\n    for _ in range(m):\n        s, ml = input().split()\n        ml = int(ml) - 1\n        ps = patterns(s)\n        found = False\n        for p in ps:\n            if p in ppm:\n                if ppm[p] == ml:\n                    found = True\n                else:\n                    pre[ppm[p]] += 1\n                    suc[ml].append(ppm[p])\n        if not found:\n            print(\"NO\")\n            return\n    znodes = [i for i in range(n) if pre[i]==0]\n    res = []\n    while znodes:\n        i = znodes.pop()\n        res.append(i+1)\n        for j in suc[i]:\n            pre[j] -= 1\n            if pre[j] == 0:\n                znodes.append(j)\n    if len(res) == n:\n        print(\"YES\")\n        print(' '.join(map(str, res)))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"n, k = [int(i) for i in input().split()]\n\ndef split_k(x):\n    t = x + 1\n    addition = t*(t+1)\/\/2\n\n    return(addition - (n- x -1) - k, n - x - 1 )\n\nj = 0\n\nwhile split_k(j)[0] != 0:\n    j += 1\n\nprint(split_k(j)[1])","output":"logn"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nk = inpl(); k.sort()\nif k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"def bs(l, h):\n    while l < h:\n        m = (l + h) \/\/ 2\n        if gf(m):\n            h = m\n        else:\n            l = m + 1\n    return l\n\ndef gf(x):\n    d = {}\n    for i in range(x):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n    if len(d) == len(u):\n        return 1\n    for i in range(x, n):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n        d[s[i - x]] -= 1\n        if not d[s[i - x]]:\n            del d[s[i - x]]\n        if len(d) == len(u):\n            return 1\n    return 0\n\nn = int(input())\ns = input()\nu = set([*s])\nprint(bs(1, n))","output":"linear"},{"instruction":"import json\nimport os\n\ndef convert_files_to_json():\n    answer = dict()\n    for file in os.listdir(\"bad\/\"):\n        if '_' in file:\n\n            answer[file] = [list(map(int, line.split())) for line in open(\"bad\/\" + file).read().split('\\n')[:2]]\n\n    return json.dumps(answer)\n\ndef extract_list(compressed_list, start_val=1):\n    answer = []\n    for num in compressed_list:\n        answer += [start_val] * num\n        start_val += 1\n    return answer\n\nanswer = json.loads('{\"1_12\": [[], [2, 2, 2, 2, 2, 3]], \"6_11\": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], '\n                    '\"3_10\": [[], [1, 1, 4, 1, 1, 5]], \"3_17\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], \"6_9\": [[], [1, 1, '\n                    '1, 1, 1, 10]], \"9_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], \"18_21\": [[], [1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"10_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"15_18\": [['\n                    '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"1_10\": [[], [2, 2, 2, 2, 3]], \"6_19\": [[], '\n                    '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], \"3_13\": [[1, 1, 4, 1, 1, 4], [2]], \"2_22\": [[], [1, 3]], '\n                    '\"3_6\": [[], [1, 1, 7]], \"10_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], '\n                    '[1, 3]], \"9_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], \"6_15\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], '\n                    '\"7_22\": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], \"1_15\": [[], [2]], \"10_15\": [[], [1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 16]], \"3_15\": [[], [1, 1, 4]], \"11_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], \"15_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"18_19\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], \"11_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], '\n                    '[2]], \"2_2\": [[], [1, 3]], \"16_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, '\n                    '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, '\n                    '3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"3_12\": [[], [1, 1, 4, 1, 1, 7]], \"18_22\": [['\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, '\n                    '3, 1, 3, 1, 1, 1, 1, 1, 7], [1, 3]], \"21_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 23]], \"8_19\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 1, 4, 1, 4, 1, 1, 3, 1, 1, 4, 1, '\n                    '4]], \"13_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14], [1, 1, 1, 6, 1, 1, 1, 1, 5, 1, 1, 1, 5, '\n                    '1, 1, 1, 6]], \"5_18\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 1, 2, 1, 3, 3]], '\n                    '\"8_16\": [[], [1, 1, 1, 1, 1, 1, 1, 17]], \"18_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 19]], \"1_19\": [[], [2]], \"5_15\": [[], [1, 1, 1, 1, 6]], \"1_6\": [[], [2, 2, 3]], '\n                    '\"11_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23]], \"17_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 19]], \"7_16\": [[1, 1, 1, 1, 1, 1, 8], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 4]], '\n                    '\"3_3\": [[], [1, 1, 4]], \"15_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], '\n                    '\"5_11\": [[1, 1, 1, 1, 6], [2]], \"1_2\": [[], [3]], \"1_17\": [[], [2]], \"14_17\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 9, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 3, 3]], \"13_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_8\": [[], [2, 2, 2, 3]], \"9_20\": [[1, '\n                    '1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], \"8_22\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 9, 1, 1, 1, 1, 1, 9]], \"7_17\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"17_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 4, 1, 1, 3, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 4, '\n                    '1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 3, 1, 4]], \"12_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, '\n                    '7, 1, 1, 1, 1, 1, 4, 1, 1, 4, 1, 1, 7]], \"5_19\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], '\n                    '\"14_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, '\n                    '2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3]], '\n                    '\"6_6\": [[], [1, 1, 1, 1, 1, 7]], \"7_11\": [[1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"2_10\": [[], [1, 3]], \"5_7\": [[1, 1, 1, 1, 6, 2, 2, 1, 1, 4], [2]], \"2_7\": [[], [1, 3, 1, 4]], '\n                    '\"10_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 5], [3, 3, 3, 1, 2, 1, 2, 1, 2, 2, 3]], \"12_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"4_15\": [[1, 1, 1, 5, 1, 1, 1, 5], [3, 1, 2, 2, 3, 1, 2, 2, 3]], \"9_14\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 3]], \"11_15\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"15_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"3_14\": [[], [1, 1, 4, 1, 1, 4, '\n                    '1, 4]], \"7_18\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 3, 1, 2, 1, 1, 1, 5], [3, 1, 2, 2, 3, 3, 1, '\n                    '2, 1, 2, 2, 3]], \"2_13\": [[], [1, 3, 1, 3, 1, 3, 3]], \"10_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], '\n                    '[1, 3]], \"9_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], '\n                    '\"8_18\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"6_10\": [[1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"16_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 2, 3, 1, 2, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 2, 3, '\n                    '1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 3]], \"21_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 22]], \"12_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"10_19\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], \"2_9\": [[], [1, 3, 1, 3, '\n                    '3]], \"1_18\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 3]], \"8_9\": [[], [1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"5_13\": [[1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"4_10\": [[], [1, 1, 1, 5, 1, 5]], '\n                    '\"1_5\": [[], [2]], \"18_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], '\n                    '\"3_8\": [[], [1, 1, 4, 1, 4]], \"2_12\": [[], [1, 3, 1, 3, 1, 5]], \"2_21\": [[], [1, 3, 1, 3, 1, 3, '\n                    '1, 3, 1, 3, 3]], \"6_13\": [[1, 1, 1, 1, 1, 7], [2, 2, 3, 1, 2, 2, 2, 2, 3]], \"4_6\": [[], [1, 1, '\n                    '1, 7]], \"2_8\": [[], [1, 3, 1, 5]], \"12_13\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], '\n                    '\"5_10\": [[], [1, 1, 1, 1, 11]], \"3_4\": [[], [1, 1, 5]], \"10_11\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12]], \"16_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 5, 1, 1, 1, 3, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 11], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 5, 1, 5]], \"4_12\": [[], [1, '\n                    '1, 1, 5]], \"11_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, '\n                    '1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"4_16\": [[], [1, 1, 1, 5, 1, '\n                    '1, 1, 9]], \"5_16\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, 7]], \"5_17\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6, '\n                    '2, 2, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"10_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 3]], '\n                    '\"4_18\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 5]], \"4_19\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 5]], '\n                    '\"8_8\": [[], [1, 1, 1, 1, 1, 1, 1, 9]], \"19_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 21]], \"3_20\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 4]], \"5_14\": [[], [1, 1, 1, 1, 6, '\n                    '1, 1, 1, 6]], \"13_15\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"1_3\": [[], [2]], '\n                    '\"5_21\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], \"1_20\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"15_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, '\n                    '4], [2]], \"14_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"4_5\": [[], [1, 1, 1, 6]], '\n                    '\"3_21\": [[], [1, 1, 4]], \"4_9\": [[1, 1, 1, 5], [2, 3, 1, 2, 2, 3]], \"7_7\": [[], [1, 1, 1, 1, 1, '\n                    '1, 8]], \"11_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], [1, 1, 5, 1, 1, 1, 4, 1, 1, 1, 5, 1, 1, '\n                    '5]], \"15_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 9], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3]], \"14_14\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"4_17\": [[1, 1, 1, 5, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, 1, 2, 2, '\n                    '3]], \"6_12\": [[], [1, 1, 1, 1, 1, 13]], \"1_1\": [[], [2]], \"19_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 4], [2]], \"9_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"17_21\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, '\n                    '6], [2]], \"16_17\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"4_21\": [[], [1, 1, '\n                    '1, 5, 1, 1, 1, 5, 1, 1, 1, 6]], \"5_6\": [[], [1, 1, 1, 1, 7]], \"10_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 11]], \"8_15\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"13_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, '\n                    '4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 4, 1, 4]], \"20_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 23]], \"9_10\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 11]], \"2_19\": [[], [1, 3, 1, 3, '\n                    '1, 3, 1, 3, 1, 4]], \"6_22\": [[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 7], [1, 3]], \"13_13\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], \"17_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '18, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 12, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"6_18\": [[], [1, 1, '\n                    '1, 1, 1, 7]], \"5_12\": [[1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3]], \"17_17\": [[], [1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"8_20\": [[], [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 9]], '\n                    '\"11_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_4\": [[], '\n                    '[2, 3]], \"3_11\": [[1, 1, 4, 1, 1, 4], [2]], \"3_9\": [[], [1, 1, 4]], \"7_14\": [[], [1, 1, 1, 1, 1, '\n                    '1, 15]], \"13_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '7], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 3]], \"8_13\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 4, '\n                    '1, 1, 3, 1, 1, 4, 1, 4]], \"9_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 1, 1, 1, 1, 6], '\n                    '[2]], \"11_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"9_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 5, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, '\n                    '2, 3, 1, 2, 2, 1, 2, 2, 3]], \"6_21\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 10]], \"12_14\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"3_7\": [[1, 1, 4], [2]], \"14_20\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 15, 1, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, '\n                    '1, 3, 1, 3, 1, 5]], \"9_11\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"12_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '13], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"5_20\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, '\n                    '11]], \"1_16\": [[], [2, 2, 2, 2, 2, 2, 2, 3]], \"7_12\": [[1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 1, 3, 1, '\n                    '3, 1, 4]], \"12_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16]], \"7_9\": [[1, 1, 1, 1, 1, 1, 8, '\n                    '2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 1, 1, 4], [2]], \"15_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16]], \"5_5\": [[], [1, 1, 1, 1, 6]], \"9_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], '\n                    '\"8_11\": [[1, 1, 1, 1, 1, 1, 1, 9, 3, 1, 2, 1, 1, 1, 1, 6], [3, 3, 1, 2, 1, 2, 1, 3, 3]], '\n                    '\"2_3\": [[], [1, 4]], \"7_10\": [[1, 1, 1, 1, 1, 1, 8, 3, 1, 2, 1, 1, 1, 5], [3, 3, 1, 2, 1, 2, 2, '\n                    '3]], \"8_14\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"11_11\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 12]], \"2_11\": [[], [1, 3, 1, 3, 1, 4]], \"2_15\": [[], [1, 3, 1, 3, 1, 3, 1, '\n                    '4]], \"10_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"10_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], \"13_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '14, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"12_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 3, 3, 1, 2, 1, 3, 1, 1, 1, 1, 6], [1, '\n                    '3, 3, 1, 3, 3, 1, 2, 1, 3, 1, 2, 1, 3, 3]], \"9_9\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"3_18\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 7]], \"14_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '16]], \"14_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"13_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 11, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, '\n                    '3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"6_8\": [[], [1, 1, 1, 1, 1, 9]], \"3_16\": [[], [1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"2_6\": [[], [1, 3]], \"20_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 22]], \"6_7\": [[], [1, 1, 1, 1, 1, 8]], \"2_4\": [[], [1, 5]], \"9_12\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 13]], \"8_12\": [[], [1, 1, 1, 1, 1, 1, 1, 13]], \"8_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 11]], \"15_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, '\n                    '1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"2_17\": [[], [1, 3, 1, 3, 1, 3, 1, 3, '\n                    '3]], \"16_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"1_22\": [[], [2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 3]], \"4_11\": [[], [1, 1, 1, 5, 1, 1, 5]], \"4_4\": [[], [1, 1, 1, 5]], '\n                    '\"11_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 1, '\n                    '2, 2, 1, 2, 2, 2, 2, 3]], \"2_18\": [[], [1, 3]], \"6_16\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 7]], '\n                    '\"2_14\": [[], [1, 3]], \"7_13\": [[1, 1, 1, 1, 1, 1, 8], [2]], \"3_22\": [[], [1, 1, 4, 1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"19_19\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], '\n                    '\"8_17\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], \"2_5\": [[], [1, 3, '\n                    '3]], \"19_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 3, 1, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, '\n                    '3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, '\n                    '1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, 3, 3, 3, 3, '\n                    '1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"10_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 5, 1, '\n                    '1, 1, 3, 1, 1, 1, 5, 1, 5]], \"22_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 23]], \"4_13\": [[], [1, 1, 1, 5, 1, 1, 1, 6]], \"7_20\": [[], [1, 1, 1, 1, 1, 1, 8, 1, '\n                    '1, 1, 1, 1, 8]], \"5_22\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 3, '\n                    '3]], \"16_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"13_14\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"5_8\": [[1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3]], \"1_11\": [[], '\n                    '[2]], \"7_21\": [[], [1, 1, 1, 1, 1, 1, 8]], \"11_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"12_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"7_19\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, '\n                    '6, 2, 2, 1, 1, 1, 1, 6, 2, 2, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], [2]], \"7_8\": [[], [1, 1, 1, 1, 1, '\n                    '1, 9]], \"10_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 5, 1, 1, 1, 4, 1, 1, 4, 1, 1, 5]], '\n                    '\"6_20\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 9]], \"3_19\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"11_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"6_17\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 7]], \"20_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 21]], \"4_8\": [[], [1, 1, 1, 9]], \"8_21\": [[1, 1, 1, 1, 1, 1, 1, 9, 1, 1, '\n                    '1, 1, 6, 3, 1, 2, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3]], \"12_17\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 1, 3, 1, 1, '\n                    '3, 1, 3, 1, 4]], \"2_20\": [[], [1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"1_9\": [[], [2]], \"14_16\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"4_20\": [[], [1, 1, 1, 5]], \"2_16\": [[], [1, 3, 1, '\n                    '3, 1, 3, 1, 5]], \"1_14\": [[], [2, 2, 2, 2, 2, 2, 3]], \"1_21\": [[], [2]], \"13_19\": [[1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8], [2]], \"7_15\": [[1, 1, 1, 1, '\n                    '1, 1, 8], [2]], \"5_9\": [[1, 1, 1, 1, 6], [2]], \"4_7\": [[1, 1, 1, 5], [3, 1, 2, 2, 3]], '\n                    '\"4_14\": [[], [1, 1, 1, 5, 1, 1, 1, 7]], \"3_5\": [[1, 1, 4], [2]], \"9_15\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10], [1, 1, 4]], \"6_14\": [[1, 1, 1, 1, 1, 7], [1, 3]], \"14_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"12_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, 1, 5]], \"1_13\": [[], '\n                    '[2]], \"4_22\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 1, 7]], \"16_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 21]], \"1_7\": [[], [2]], \"17_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 18, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]]}')\n\nn, x, y = map(int, input().split())\nn -= 1\nif x > y:\n    x, y = y, x\nprefix = extract_list(answer[str(x) + '_' + str(y)][0])\npattern = extract_list(answer[str(x) + '_' + str(y)][1], prefix[-1] + 1 if prefix else 1)\nif n < len(prefix):\n    print(prefix[n])\nelse:\n    n -= len(prefix)\n    print(n \/\/ len(pattern) * (pattern[-1] - pattern[0] + 1) + pattern[n % len(pattern)])","output":"np"},{"instruction":"def main():\n    n, q = map(int, input().split())\n    for _ in range(q):\n        node = int(input())\n        s = input()\n\n        for i in s:\n            if i == 'L':\n                if node % 2:\n                    continue\n                k = node & (-node)\n                node -= k\n                k \/\/= 2\n                node += k\n\n            if i == 'R':\n                if node % 2:\n                    continue\n                k = node & (-node)\n                k \/\/= 2\n                node += k\n\n            if i == 'U':\n                if node == (n + 1) \/\/ 2:\n                    continue\n                k = node & (-node)\n                node -= k\n                k *= 2\n                node |= k\n        print(node)\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"n,m=map(int,input().split())\nM=[['0' for x in range(m)] for y in range(n)]\nfor a in range(n):\n    i=input()\n    for b in range(len(i)):\n\n        M[a][b]=i[b]\nstart=[]\nend=[]\nfor a in range(n):\n    for b in range(m):\n        if M[a][b]=='B':\n            if not start:\n\n                start.append(a+1)\n                start.append(b+1)\n            else:\n\n                end.clear()\n                end.append(a+1)\n                end.append(b+1)\n\nif not start or not end:\n    print(start[0],start[1])\nelse:\n    mid1=int((end[0]+start[0])\/2)\n    mid2=int((end[1]+start[1])\/2)\n    print(mid1,mid2)","output":"quadratic"},{"instruction":"n,s=map(int,input().split())\na=[0]*(n+1)\n\nif n==2:\n  print(s)\n  exit(0)\n\nfor _ in range(n-1):\n  u,v=map(int,input().split())\n  a[u]+=1\n  a[v]+=1\n\nprint(2.0*s\/a.count(1))","output":"linear"},{"instruction":"A, B, C, N = map(int, input().strip().split())\nD = N - (A + B - C)\nif D <= 0 or C > A or C > B:\n    print('-1')\n    exit(0)\nprint(D)","output":"constant"},{"instruction":"import sys\nimport io, os\nimport math\ngcd=math.gcd\nceil=math.ceil\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nmod1=(10**9)+7\nmod2=998244353\ndef strinp(testcases):\n    k=5\n    if(testcases==-1 or testcases==1):\n        k=1\n    f=str(input())\n    f=f[2:len(f)-k]\n    return f\ndef alp(a):\n    return (ord(a)-ord(\"a\"))\ndef main():\n    arr=list(map(int, input().split()))\n    n=arr[0]\n    m=arr[1]\n    k=arr[2]\n    lrw=[0]*n\n    for i in range(n):\n        lrw[i]=list(map(int, input().split()))\n    udw=[0]*(n-1)\n    for i in range(n-1):\n        udw[i]=list(map(int, input().split()))\n    if(k%2==1):\n        a=[-1]*m\n        for i in range(n):\n            print(*a)\n        sys.exit()\n    dp1=[[0 for i in range(m)] for j in range(n)]\n    dp2=[[0 for i in range(m)] for j in range(n)]\n    inf=10**10\n    dis=(k\/\/2)\n    for h in range(dis):\n        for i in range(n):\n            for j in range(m):\n                a=inf\n                b=inf\n                c=inf\n                d=inf\n                if(j>0):\n                    a=lrw[i][j-1]+dp2[i][j-1]\n                if(j<m-1):\n                    b=lrw[i][j]+dp2[i][j+1]\n                if(i>0):\n                    c=udw[i-1][j]+dp2[i-1][j]\n                if(i<n-1):\n                    d=udw[i][j]+dp2[i+1][j]\n                dp1[i][j]=min(a,b,c,d)\n        dp2=dp1\n        dp1=dp1=[[0 for a in range(m)] for b in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp2[i][j]*=2\n    for i in range(n):\n        print(*dp2[i])\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n,m = map(int,input().split())\nd = {x:0 for x in range(m)}\nl = []\nfor _ in range(n):\n    s = input()\n    for x in range(m):\n        if s[x]== '1': d[x]+=1\n    l.append(s)\nfor x in l:\n    t=0\n    for y in range(m):\n        if x[y] =='1':\n            if d[y] ==1:t = 1;break\n    if t==0: print('YES');exit()\nprint('NO')","output":"quadratic"},{"instruction":"n = int(input())\nl = list(map(int, input().split()))\nto = l.index(max(l))\nok = 1\nfor i in range(1, to):\n    if (l[i] <= l[i - 1]):\n        ok = 0\n        break\nfor i in range(to + 1, n):\n    if (l[i] >= l[i - 1]):\n        ok = 0\n        break\nif ok:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"from math import *\nn,m,k = map(int,input().split())\nl = list(map(int,input().split()))\na = [0 for i in range(n+1)]\nans = 0\nfor M in range(m):\n    min1 = 0\n    for i in range(1,n+1):\n        a[i] = a[i-1] + l[i-1]\n        if(i % m == M):\n            a[i] -= k\n            ans = max(ans,a[i]-min1)\n        min1 = min(min1,a[i])\n\nprint(ans)","output":"quadratic"},{"instruction":"movimentos, doces_final = map(int, input().split())\nleft, right = 0, movimentos + 1\n\nwhile left < right -1 :\n    media = (left + right)\/\/2\n    cedidos = (media * (media + 1)) \/\/ 2\n    comidos = movimentos - media\n    if cedidos - comidos > doces_final:\n        right = media\n    else:\n        left = media\nprint(movimentos - left)","output":"logn"},{"instruction":"import sys\nif locals()['__file__'][-2:] == 'py':\n    sys.stdin = open('in.txt', 'r')\nfrom sys import stdin\nrl = lambda l: tuple(map(int, l.split()))\nn, a, b = rl(input())\nl = list(map(rl, stdin.readlines()))\nc, d = {}, {}\nr = 0\nfor _, x, y in l:\n    i, j = a * x - y, (x, y)\n    r += c.get(i, 0) - d.get(j, 0)\n    c[i] = c.get(i, 0) + 1\n    d[j] = d.get(j, 0) + 1\nprint(2 * r)","output":"linear"},{"instruction":"n = int(input())\nans = [1, 3, 5, 7, 9, 11, 13, 15]\ndct = \\\n{\n    1 : 1,\n    3 : 18,\n    5 : 1800,\n    7 : 670320,\n    9 : 734832000,\n    11 : 890786230,\n    13 : 695720788,\n    15 : 150347555\n}\nif n in ans:\n    print(dct[n])\nelse:\n    print(0)","output":"np"},{"instruction":"a = [str(i) for i in input().split()]\na.sort()\nfirst = a[0]\nsecond = a[1]\nthird = a[2]\nfirstnum = int(first[0])\nsecondnum = int(second[0])\nthirdnum = int(third[0])\nif(first == second):\n\tif(second == third):\n\t\tprint(0)\n\telse:\n\t\tprint(1)\nelif(second == third):\n\tprint(1)\nelif(first[1] == second[1] and second[1] == third[1]):\n\tif(firstnum +1 == secondnum and secondnum + 1 == thirdnum):\n\t\tprint(0)\n\telif(firstnum + 1 == secondnum or firstnum + 2 == secondnum):\n\t\tprint(1)\n\telif(secondnum + 1 == thirdnum or secondnum + 2 == thirdnum):\n\t\tprint(1)\n\telse:\n\t\tprint(2)\nelif(first[1] == second[1] and (firstnum + 1 == secondnum or firstnum+2 == secondnum)):\n\tprint(1)\nelif(second[1] == third[1] and (secondnum + 1 == thirdnum or secondnum+2 == thirdnum)):\n\tprint(1)\nelif(first[1] == third[1] and (firstnum + 1 == thirdnum or firstnum + 2 == thirdnum)):\n\tprint(1)\nelse:\n\tprint(2)","output":"nlogn"},{"instruction":"n, q = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\n\ndef p(c_k, r):\n    l = 0\n    while r - l > 1:\n        z = (r + l) \/\/ 2\n        if pr_a[z] > c_k:\n            r = z\n        else:\n            l = z\n    return l\n\npr_a = []\nfor i in range(n):\n    pr_a.append(a[i])\n    if i > 0:\n        pr_a[i] += pr_a[i - 1]\nk = list(map(int, input().split(' ')))\nc_k = 0\nans = []\nfor qq in range(q):\n    c_k += k[qq]\n    l = p(c_k, n - 1)\n    if pr_a[l] <= c_k:\n        l += 1\n    if c_k >= pr_a[n - 1]:\n        c_k = 0\n        l = 0\n    ans.append(str(n - l))\nprint('\\n'.join(ans))","output":"nlogn"},{"instruction":"r,g,b = list(map(int, input().split()))\nls_r = sorted(list(map(int, input().split())))\nls_g = sorted(list(map(int, input().split())))\nls_b = sorted(list(map(int, input().split())))\n\ndp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]\n\ndef recursive(idx_r, idx_g, idx_b):\n    if dp[idx_r][idx_g][idx_b] != -1:\n        return dp[idx_r][idx_g][idx_b]\n    res_1 = 0\n    res_2 = 0\n    res_3 = 0\n    if (idx_r-1) >= 0 and (idx_g-1) >= 0:\n        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]\n    if (idx_g-1) >= 0 and (idx_b-1) >= 0:\n        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]\n    if (idx_r-1) >= 0 and (idx_b-1) >= 0:\n        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]\n\n    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)\n    return dp[idx_r][idx_g][idx_b]\n\nprint(recursive(r,g,b))","output":"cubic"},{"instruction":"n,k = [int(x) for x in input().split()]\na = []\nfor _ in range(n):\n    a.append([int(x) for x in input().split()])\n\na.sort(key = lambda x: x[1])\na.sort(reverse=True,key=lambda x: x[0])\nb=a[k-1]\nprint(a.count(b))","output":"nlogn"},{"instruction":"dat = \"\u787c\u78f7\u78b3\u78f7\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6c1f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6c1f\u6eb4\u787c\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u6c1f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6c1f\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6eb4\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c1f\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6c2e\u787c\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u6c1f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6eb4\u787c\u786b\u78b3\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6c1f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u6eb4\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6c1f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c1f\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u78f7\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c2f\u78b3\u6c27\u78f7\u6c2e\u786b\u6c1f\u6eb4\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u6c27\u78f7\u6c2e\u786b\u6c1f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u6c2e\u787c\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6eb4\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c1f\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6c2e\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c1f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c1f\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u6c27\u786b\u78b3\u6c2f\u6c1f\u78b3\u78f7\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u786b\u78b3\u78f7\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u786b\u78b3\u78f7\u6c2e\u787c\u6c2f\u6eb4\u787c\u786b\u78b3\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u6c2f\u78b3\u786b\u6eb4\u787c\u786b\u6c2e\u787c\u6c2f\u6eb4\u787c\u6c27\u786b\u78b3\u6c2f\u6c1f\u78b3\u78f7\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u786b\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c1f\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c1f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u787c\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u78b3\u6c2f\u6c1f\u6eb4\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c27\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6eb4\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u6c2e\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6eb4\u787c\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u786b\u6c2e\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6eb4\u787c\u78f7\u6c2e\u787c\u786b\u6c2e\u6c2f\u6eb4\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u78b3\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u6c27\u78f7\u6c2e\u6c2f\u6c1f\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u786b\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u786b\u6eb4\u787c\u78f7\u6c2e\u786b\u6eb4\u787c\u6c2f\u78b3\u78f7\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u78b3\u6c2f\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u6c27\u78f7\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u6c27\u78f7\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u78f7\u78b3\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6eb4\u787c\u6c2f\u6c2e\u786b\u6eb4\u787c\u78f7\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6eb4\u787c\u78f7\u6c2e\u787c\u6c2f\u6c2e\u786b\u6eb4\u6c27\u786b\u6c2e\u6c2f\u6c1f\u78b3\u78f7\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u6c27\u786b\u6c2e\u6c2f\u6c1f\u78b3\u78f7\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u787c\u6c2f\u78b3\u78f7\u6c2e\u786b\u6c1f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u6c27\u787c\u786b\u78b3\u78f7\u6c2e\u6c2f\u6c1f\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u78b3\u6c2f\u6eb4\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u787c\u6c27\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6c1f\u6c2e\u6c27\u78f7\u6c2e\u786b\u6c1f\u78b3\u6c2f\u6c2e\u78f7\u78b3\u786b\u6eb4\u78f7\u78b3\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u78b3\u787c\u786b\u6c2e\u78f7\u78b3\u786b\u6c2e\u6c2f\u6eb4\u78f7\u78b3\u6c2f\u6c2e\u786b\u6eb4\u787c\u78f7\u78b3\u787c\u6c2f\u6c2e\u78f7\u78b3\u6c2f\u6c2e\u786b\u6eb4\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6eb4\u78f7\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u78f7\u6eb4\u787c\u786b\u6c2e\u78f7\u6eb4\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6eb4\u787c\u6c2f\u6c2e\u78f7\u6eb4\u787c\u786b\u78b3\u6c2f\u6c2e\u787c\u6c2f\u78b3\u786b\u6c2e\u78f7\u6eb4\u787c\u786b\u6c2e\u787c\u6c2f\u6c2e\u78f7\u6eb4\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u787c\u786b\u78b3\u787c\u6c2f\u6c2e\u78f7\u6c2e\u786b\u78b3\u6c2f\u6eb4\u78f7\u6c2e\u6c2f\u6eb4\u787c\u786b\u6c2e\u78f7\u6c2e\u6c2f\u6eb4\u78f7\u6c2e\u786b\u6eb4\u787c\u6c2f\u6c2e\u78f7\u6c2e\u786b\u6eb4\u78f7\u6c2e\u786b\u6c2e\u6c2f\u6eb4\u787c\u78f7\u6c2e\u78f7\".split('\u6eb4')\nd1, d2 = \"\u787c\u78b3\u6c2e\u6c27\u6c1f\u78f7\u786b\u6c2f\", \"!&|()xyz\"\nfor i in range(int(input())):\n\ts = dat[eval(\"0b\" + ''.join(list(reversed(input()))))]\n\tfor i in range(8): s = s.replace(d1[i], d2[i])\n\tprint(s)","output":"quadratic"},{"instruction":"r,g,b = list(map(int,input().split()))\ndp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]\nra = sorted(list(map(int,input().split())),reverse=True)\nga = sorted(list(map(int,input().split())),reverse=True)\nba = sorted(list(map(int,input().split())),reverse=True)\n\ndef solve(i,j,k) :\n\n    if dp[i][j][k] != -1 :\n        return dp[i][j][k]\n\n    if i==r :\n        if j==g or k==b :\n            return 0\n        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)\n\n    elif j==g :\n        if i==r or k==b:\n            return 0\n        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)\n\n    elif k==b :\n        if j==g or i==r:\n            return 0\n        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)\n\n    else :\n        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))\n\n    return dp[i][j][k]\n\nprint(solve(0,0,0))","output":"cubic"},{"instruction":"from sys import stdin\n\nsys_input = stdin.readline\n\ndef si(): return sys_input().rstrip()\n\ndef ii(): return int(si())\n\ndef sti(): return si().split()\n\ndef iti(): return map(int, sti())\n\ndef sli(): return list(si())\n\ndef ili(): return list(iti())\n\ndef main():\n    B.sort(reverse=True)\n    G.sort(reverse=True)\n\n    if B[0] > G[-1]:\n        print(-1)\n        return\n\n    boy_capacities = [M - 1] * N\n    current_capable_boy_index = 0\n\n    result = sum(B) * M\n\n    for j, g in enumerate(G):\n        yet = True\n        while yet:\n            if B[current_capable_boy_index] < g and boy_capacities[current_capable_boy_index] > 0:\n                result += g - B[current_capable_boy_index]\n\n                boy_capacities[current_capable_boy_index] -= 1\n                yet = False\n            elif B[current_capable_boy_index] == g:\n                result += g - B[current_capable_boy_index]\n\n                yet = False\n            else:\n                current_capable_boy_index += 1\n                if current_capable_boy_index > N - 1:\n                    print(-1)\n                    return\n\n    print(result)\n\n    return\n\nif __name__ == '__main__':\n    N, M = iti()\n    B = ili()\n    G = ili()\n\n    main()","output":"nlogn"},{"instruction":"def find(u):\n    global par\n    if u != par[u]:\n        par[u] = find(par[u])\n    return par[u]\n\ndef union(u, v):\n    u = find(u)\n    v = find(v)\n    par[u] = v\n\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\nmp = dict()\nfor i in range(n):\n    mp[p[i]] = i + 1\npar = [i for i in range(n + 2)]\n\nfor i in range(n):\n    union(i + 1, mp.get(a - p[i], n + 1))\n    union(i + 1, mp.get(b - p[i], 0))\n\nA = find(0)\nB = find(n + 1)\n\nif A != B:\n    print('YES')\n    print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)]))\nelse:\n    print('NO')","output":"linear"},{"instruction":"rank = 1\nn = int(input())\nscore = sum(map(int,input().split()))\nfor i in range(n-1):\n    student = sum(map(int,input().split()))\n    if(student > score):\n        rank += 1\nprint(rank)","output":"linear"},{"instruction":"n=int(input())\na=sorted([int(x) for x in input().split()])\ncounter=0\ntest=[False]*n\nfor j in range(n):\n    if not test[j]:\n        for i in range(n):\n            if not test[i] and a[i]%a[j]==0:\n                test[i]=True\n        counter+=1\nprint(counter)","output":"quadratic"},{"instruction":"n, pos, l, r = map(int, input().split())\nresult = abs(pos - l) + r - l + 2\nif (l == 1):\n    if (abs(pos - r) + 1 < result):\n        result = abs(pos - r) + 1\nif (r == n):\n    if (abs(pos - l) + 1 < result):\n        result = abs(pos - l) + 1\nif (l == 1 and r == n):\n    result = 0\nif (abs(pos - r) + r - l + 2 < result):\n    result = abs(pos - r) + r - l + 2\nprint(result)","output":"constant"},{"instruction":"import sys\n\nn = int(sys.stdin.buffer.readline().decode('utf-8'))\ncost = [0] + \\\n    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))\na = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]\n\nmask = [0, 1, 51, 1911]\ninf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1\ndp = [[inf]*bs_size for _ in range(4*n+1)]\ndp[0][0] = 0\n\nfor i in range(4*n):\n    y, x = i & 3, i >> 2\n    is_dot = 1 if a[y][x] == '.' else 0\n\n    for bitset in range(bs_size):\n        if y == 0:\n\n            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:\n                dp[i+4][full_bit] = dp[i][bitset] + cost[4]\n\n        if (is_dot | bitset & 1) and\\\n                dp[i+1][bitset >> 1] > dp[i][bitset]:\n            dp[i+1][bitset >> 1] = dp[i][bitset]\n\n        for k in range(1, min(4-y, 3)+1):\n            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:\n                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]\n\nprint(min(dp[4*n]))","output":"linear"},{"instruction":"import sys\n\nn, q = list(map(int,sys.stdin.readline().strip().split()))\na = list(map(int,sys.stdin.readline().strip().split()))\nm = [0] * q\n\nM = max(a)\ni = 0\nx = a[0]\nL = []\nL1 = []\nL2 = []\nwhile x != M:\n    L1.append(x)\n    L2.append(a[i+1])\n    i = i + 1\n    if x < a[i]:\n        L.append(x)\n        x = a[i]\n    else:\n        L.append(a[i])\n\nb = a[i+1:] + L\n\nfor j in range (0, q):\n    m = int(sys.stdin.readline().strip())\n    if m <= i:\n        print(str(L1[m-1]) + \" \" + str(L2[m-1]))\n    else:\n        print(str(x) + \" \" + str(b[(m - i - 1) % (n-1)]))","output":"linear"},{"instruction":"n,k=map(int,input().split())\nif k>=n-1:\n    print(n-1)\nelse:\n    print(k+ ((n-k)*(n-k+1))\/\/2 - 1)","output":"constant"},{"instruction":"n,l,r,x = map(int,input().split())\nA = list(map(int,input().split()))\ncount = 0\nfor i in range(1<<n):\n    total = 0\n    mn = 1e6\n    mx = -1e6\n    for k in range(n):\n        if (i & (1<<k)):\n            total += A[k]\n            mn = min(A[k],mn)\n            mx = max(A[k],mx)\n    if total<=r and total>=l and mx-mn>=x:\n        count += 1\nprint(count)","output":"np"},{"instruction":"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}\nch_1={0:[3],3:[0],1:[0,3],2:[0,3]}\nch_2={0:[],3:[],2:[1],1:[2]}\nN=998244353\nn,k=map(int,input().strip().split(\" \"))\ndp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]\ndp[0][1][3]=1\ndp[0][1][0]=1\ndp[0][2][1]=1\ndp[0][2][2]=1\n\nfor i in range(1,n):\n    for j in range(1,k+1):\n        for mask in range(4):\n            for t in ch_0[mask]:\n                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N\n            if j>1:\n                for t in ch_1[mask]:\n                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N\n                if j>2:\n                    for t in ch_2[mask]:\n                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N\nans=0\nfor mask in range(4):\n    ans=(ans+dp[n-1][k][mask])%N\nprint(ans)","output":"np"},{"instruction":"t=int(input())\nfor l in range(t):\n\tn=int(input())\n\tarr=list(map(int,input().split()))\n\tarr.sort()\n\ta=arr[-2]\n\tprint(min(a-1,n-2))","output":"nlogn"},{"instruction":"base=998244353;\ndef power(x, y):\n    if(y==0):\n        return 1\n    t=power(x, y\/\/2)\n    t=(t*t)%base\n    if(y%2):\n        t=(t*x)%base\n    return t;\ndef inverse(x):\n    return power(x, base-2)\nf=[1]\niv=[1]\nfor i in range(1, 5555):\n    f.append((f[i-1]*i)%base)\n    iv.append(inverse(f[i]))\ndef C(n, k):\n    return (f[n]*iv[k]*iv[n-k])%base\ndef candy(n, k):\n\n    return C(n+k-1, k-1)\ndef count_game(k, n, x):\n    if(k==0):\n        if(n==0):\n            return 1\n        else:\n            return 0\n    ans=0\n    for i in range(0, k+1):\n        t=n-x*i\n\n        if(t<0):\n            break\n        if(i%2):\n            ans=(ans-C(k, i)*candy(t, k))%base\n        else:\n            ans=(ans+C(k, i)*candy(t, k))%base\n    return ans\np, s, r= list(map(int, input().split()))\ngamesize=count_game(p, s-r, int(1e18))\ngamesize=inverse(gamesize)\nans=0;\nfor q in range(r, s+1):\n    for i in range(0, p):\n        t=s-(i+1)*q\n        if(t<0):\n            break\n\n        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base\nprint(ans)","output":"cubic"},{"instruction":"def cal(x, n):\n    return (1 + n - x) * (n - x) \/\/ 2 - x\n\nn, k = map(int, input().strip().split())\nlow, hgh, mid = 0, n, -1\nwhile low <= hgh:\n    mid = (low + hgh) \/\/ 2\n    cm = cal(mid, n)\n    if cm == k:\n        print(mid)\n        break\n    elif cm > k:\n        low = mid + 1\n    else:\n        hgh = mid - 1","output":"logn"},{"instruction":"from sys import stdin, stdout\nreadline = stdin.readline\nwrite = stdout.write\n\nsquareMoves = []\n\ndef precompute():\n    top = 10 ** 18\n    prev = 0\n\n    while prev <= 30*top:\n        squareMoves.append(prev)\n        prev = 1 + 4 * prev\n\ndef getAns(k, n):\n    low = 0\n    high = 0\n    a = 1\n    b = 1\n    i = 1\n\n    while i <= n:\n        low += a\n        high += a + b * squareMoves[n-i]\n\n        if high >= k:\n            if low > k:\n                return -1\n            return i\n\n        a = 2 * a + 1\n        b = 2 * a - 1\n        i += 1\n\n    return -1\n\nif __name__ == \"__main__\":\n    precompute()\n\n    t = int(readline().strip())\n    for i in range(t):\n        [n, k] = list(map(int, readline().strip().split(' ')))\n        tmpN = min(n, len(squareMoves))\n\n        ans = getAns(k, tmpN)\n        if ans == -1:\n            write(\"NO\\n\")\n        else:\n            write(\"YES \" + str(n - ans) + \"\\n\")","output":"logn"},{"instruction":"import heapq\nfrom heapq import heappush as push_\nfrom heapq import heappop  as pop_\n\nclass heapT():\n    def __init__(self, T):\n        self.Q     = []\n        self.curT  = 0\n        self.maxT  = T\n        self.his   = []\n\n    def push(self, t, index):\n        push_(self.Q, (-t, index))\n        self.his.append(index)\n        self.curT += t\n\n        while self.curT > self.maxT:\n            self.pop()\n\n    def pop(self):\n        t, ind     = pop_(self.Q)\n        self.his.append(ind)\n        self.curT -= t * -1\n\n    def normalize(self, length):\n        while len(self.Q) > length:\n            self.pop()\n\ndef solve(a, n, T):\n    a    =  sorted(a, key=lambda x:x[0], reverse=True)\n    H    =  heapT(T)\n\n    max_ = -1\n    pos  = None\n\n    for ak, t, ind in a:\n        H.push(t, ind)\n        H.normalize(ak)\n\n        if len(H.Q) >  max_:\n            max_ = len(H.Q)\n            pos  = len(H.his)\n\n    d = {}\n    if pos is not None:\n        for x in H.his[:pos]:\n            if x not in d:\n                d[x] = 1\n            else:\n                del d[x]\n\n    if len(d) > 0:\n        print(len(d))\n        print(len(d))\n        print(' '.join([str(x+1) for x in d]))\n    else:\n        print('0'+'\\n'+'0')\n\nn, T =  map(int, input().split())\na    =  [list(map(int, input().split())) + [_] for _ in range(n)]\nsolve(a, n, T)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = sorted(list(map(int, input().split())))\ns = sorted(list(map(int, input().split())))\nif a[-1] > s[0]:\n    print(-1)\nelse:\n    if a[-1] == s[0]:\n        print(sum(a[:-1])*m+sum(s))\n    else:\n        print(sum(a[:-2])*m+a[-2]*(m-1)+sum(s)+a[-1])","output":"nlogn"},{"instruction":"def occurrences(string, sub):\n    count = start = 0\n    while True:\n        start = string.find(sub, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count\n\nclass CodeforcesTask23ASolution:\n    def __init__(self):\n        self.result = ''\n        self.string = ''\n\n    def read_input(self):\n        self.string = input()\n\n    def process_task(self):\n        o_max = 0\n        for x in range(len(self.string)):\n            for y in range(x):\n                m = occurrences(self.string, self.string[y:x])\n                if m >= 2:\n                    o_max = max(x - y, o_max)\n        self.result = str(o_max)\n\n    def get_result(self):\n        return self.result\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask23ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())","output":"cubic"},{"instruction":"x,k = map(int, input().split())\nmod = 10 ** 9 + 7\nprint(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)","output":"logn"},{"instruction":"mod = 10**9+7\nx, k = map(int, input().split(' '))\nif (x == 0):\n    print(0)\nelse:\n    val1 = pow(2,k+1,mod) * x\n    val2 = pow(2, k, mod) - 1\n    val1 -= val2\n    val1 %= mod\n    print(val1)","output":"logn"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nM = float(readline())\nA = list(map(int, readline().split()))\nB = list(map(int, readline().split()))\nB = B[1:] + [B[0]]\nC = []\nfor a, b in zip(A[::-1], B[::-1]):\n    C.append(b)\n    C.append(a)\n\nif 1 in C:\n    print(-1)\nelse:\n    M0 = M\n    for c in C:\n        M += M\/(c-1)\n\n    print(M-M0)","output":"linear"},{"instruction":"n = int(input())\na = list(map(int, input().split(' ')))\n\nnew_a = [[0] * 600 for i in range(600)]\ndp = [[0x7fffffff] * 600 for i in range(600)]\n\nfor i in range(n):\n\tnew_a[i+1][i+1] = a[i]\n\tdp[i+1][i+1] = 1\n\nfor i in range(1, n + 1):\n\tfor j in range(i + 1, n + 1):\n\t\tdp[i][j] = j - i + 1\n\nfor llen in range(2, n + 1):\n\tfor left in range(1, n - llen + 2):\n\t\tright = left + llen - 1\n\t\tfor middle in range(left, right):\n\t\t\tdp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right])\n\t\t\tif dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]:\n\t\t\t\tdp[left][right] = 1\n\t\t\t\tnew_a[left][right] = new_a[left][middle] + 1\n\nprint(dp[1][n])","output":"cubic"},{"instruction":"from math import log\nimport random\nspaces = (\" \",\"\\n\",\"\\t\")\nstops = (\"\",\" \",\"\\n\",\"\\t\")\nextendedPoints = set()\nstartingPoints = set()\ninterestPoints = []\n\nclass TPoint:\n\tdef __init__(self,x,y):\n\t\tself.x=x\n\t\tself.y=y\n\tdef __str__(self):\n\t\treturn \"(\"+str(self.x)+\",\"+str(self.y)+\")\"\n\tdef __eq__(self, other):\n\t\treturn self.x == other.x and self.y == other.y\n\tdef __hash__(self):\n\t\treturn self.x*20000 + self.y\n\tx=0\n\ty=0\n\th=0\ndef sortKey(p):\n\treturn p.h\ndef heuristic(p, otherPoints):\n\tminH = float(\"inf\")\n\tfor point in otherPoints:\n\t\tcurrentH = abs(point.x - p.x) + abs(point.y - p.y)\n\t\tif currentH < minH:\n\t\t\tminH = currentH\n\treturn minH\n\ndef addPoint(p,pointList):\n\tif not p in extendedPoints:\n\t\tp.h = heuristic(p,startingPoints)\n\t\textendedPoints.add(p)\n\t\tpointList.append(p)\n\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef extend(point,n,m,poinList):\n\tok = False\n\tif point.x>1:\n\t\tok = addPoint(TPoint(point.x-1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok\n\tif point.x<n:\n\t\tok = addPoint(TPoint(point.x+1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok\n\tif point.y>1:\n\t\tok = addPoint(TPoint(point.x,point.y-1),poinList) or ok\n\tif point.y<m:\n\t\tok = addPoint(TPoint(point.x,point.y+1),poinList) or ok\n\n\treturn ok\n\ndef ReadNext(fileObject):\n\tcurrentBuffer = \"\"\n\tcurrentRead=fileObject.read(1)\n\twhile currentRead in spaces:\n\t\tcurrentRead=fileObject.read(1)\n\tcurrentBuffer = currentBuffer + currentRead\n\twhile not currentRead in stops:\n\t\tcurrentRead=fileObject.read(1)\n\t\tcurrentBuffer = currentBuffer + currentRead\n\treturn currentBuffer.strip()\n\nw, r= open('output.txt', 'w'), open('input.txt', 'r')\n\nn = int(ReadNext(r))\nm = int(ReadNext(r))\nk = int(ReadNext(r))\nmscale = 5\n\nfor i in range(k):\n\tx = int(ReadNext(r))\n\ty = int(ReadNext(r))\n\tp = TPoint(x,y)\n\tstartingPoints.add(p)\n\textendedPoints.add(p)\n\ntmpPoints = []\ntmpPoints.append(TPoint(1,1))\ntmpPoints.append(TPoint(1,m))\ntmpPoints.append(TPoint(n,1))\ntmpPoints.append(TPoint(n,m))\nif n>2 and m>2:\n\ttmpPoints.append(TPoint(int(n\/2),1))\n\ttmpPoints.append(TPoint(1,int(m\/2)))\n\ttmpPoints.append(TPoint(int(n\/2),m))\n\ttmpPoints.append(TPoint(n,int(m\/2)))\n\ttmpPoints.append(TPoint(int(n\/2),int(m\/2)))\n\nfor p in tmpPoints:\n\taddPoint(p,interestPoints)\n\nfor p in startingPoints:\n\textend(p,n,m,interestPoints)\n\ninterestPoints.sort(reverse=True, key=sortKey)\nwhile len(interestPoints) > 3*mscale:\n\tinterestPoints.pop(len(interestPoints)-1)\n\nrandom.seed()\n\nif(len(interestPoints)>0):\n\tmaxPoint = interestPoints[0]\n\tfor p in interestPoints:\n\t\tcurrentBeam = [p]\n\t\tcanExtend = True\n\t\twhile canExtend:\n\t\t\taddPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)\n\t\t\tcanExtend = False\n\t\t\tfor i in range(len(currentBeam)):\n\t\t\t\tif extend(currentBeam[i],n,m,currentBeam):\n\t\t\t\t\tcanExtend = True\n\t\t\tcurrentBeam.sort(reverse=True, key=sortKey)\n\t\t\twhile len(currentBeam) > mscale:\n\t\t\t\tcurrentBeam.pop(len(currentBeam)-1)\n\t\tif currentBeam[0].h>maxPoint.h:\n\t\t\tmaxPoint = currentBeam[0]\n\n\tw.write(str(maxPoint.x)+\" \"+str(maxPoint.y)+\"\\n\")\nelse:\n\tw.write(str(n)+\" \"+str(m)+\"\\n\")","output":"cubic"},{"instruction":"from math import factorial\ns1=input()\ns2=input()\nn=0\nx1=0\nfor i in range(len(s1)):\n    if s1[i]=='+':\n        x1+=1\n    else:\n        x1-=1\nx2=0\nfor i in range(len(s2)):\n    if s2[i]=='+':\n        x2+=1\n    elif s2[i]=='?':\n        n+=1\n    else:\n        x2-=1\nx=abs(x1-x2)\nif x>n:\n    print(0)\nelif x==n:\n    print(1\/2**n)\nelse:\n    if (n-x)%2==1:\n        print(0)\n    else:\n        print((factorial(n)\/\/(factorial((n-x)\/\/2)*factorial(n-(n-x)\/\/2)))\/2**n)","output":"np"},{"instruction":"import math\nimport sys\n\nDEBUG = False\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\ndef solve(N, M, A):\n    A.sort(reverse=True)\n\n    lh = A[0]\n    cnt = 1\n    for a in A[1:]:\n        if lh == 1:\n            cnt += 1\n        elif lh - 1 <= a:\n            cnt += 1\n            lh -= 1\n        else:\n            cnt += lh - a\n            lh = a\n\n    cnt += lh - 1\n\n    return sum(A) - cnt\n\ndef main():\n    N, M = [int(e) for e in inp().split()]\n    A = [int(e) for e in inp().split()]\n    assert len(A) == N\n    print(solve(N, M, A))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        nodes = []\n        for lst in lists:\n            while lst:\n                nodes.append(lst.val)\n                lst = lst.next\n        nodes.sort()\n\n        res = ListNode(0)\n        cur = res\n        for node in nodes:\n            cur.next = ListNode(node)\n            cur = cur.next\n        return res.next","output":"nlogn"},{"instruction":"n, k = [int(e) for e in input().split()]\na = sorted([int(e) for e in input().split()])\ns = set()\nfor i in range(n):\n    if a[i] % k != 0:\n        s.add(a[i])\n    elif a[i] \/ k not in s:\n        s.add(a[i])\nprint(len(s))","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\nans = s\nf = []\nt = []\nfor i in range(n):\n    f, t = map(int, input().split())\n    if(t>(s-f)):\n        ans +=  t - (s-f)\n        s += t - (s-f)\n\nprint(ans)","output":"linear"},{"instruction":"n, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nnew_arr = []\nfor i in range(n - 1):\n\tnew_arr.append(arr[i + 1] - arr[i])\n\nnew_arr.sort()\nprint(sum(new_arr[:n - k]))","output":"nlogn"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn, m, k = map(int, input().split())\n\nfilters = list(map(int, input().split()))\nfilters.sort()\n\nsupply_filters_needed = 0\nif k < m:\n    spots = k\n    end = n - 1\n    while spots < m and end >= 0:\n        spots += filters[end] - 1\n        supply_filters_needed += 1\n        end -= 1\n\n    if spots < m:\n        print(-1)\n    else:\n        print(supply_filters_needed)\nelse:\n    print(0)","output":"nlogn"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\narr2=sorted(arr)\ncount=0\na=0\nfor i in range(n):\n   if arr[i]!=arr2[i]:\n        count+=1\n        k=arr[i]\n        arr[i]=arr2[i]\n        z=arr.index(arr2[i])\n        arr[z]=k\n\n   if count>2:\n        a=1\n        break\nif a==0:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n, m, k = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\n\nbestbest = 0\n\ndef brute(n, m, k, A):\n    ans = 0\n    val = (0, 0)\n    for i in range(n):\n        for j in range(i, n):\n            if ans < sum(A[i:j+1]) - k*(ceil((j-i+1)\/m)):\n                ans = sum(A[i:j+1]) - k*(ceil((j-i+1)\/m))\n                val = (i, j)\n    return val, ans\n\nfor off in range(m):\n    B = A[off:]\n    C = []\n    canstart = []\n    for i in range(len(B)):\n        if i%m == 0:\n            C.append(-k)\n            canstart.append(1)\n        canstart.append(0)\n        C.append(B[i])\n\n    best = 0\n    run = 0\n\n    for i in range(len(C)):\n        run += C[i]\n        if run < -k:\n            run = -k\n        best = max(best, run)\n\n    bestbest = max(bestbest, best)\n\nprint(bestbest)","output":"quadratic"},{"instruction":"from sys import stdin,stdout\nimport heapq\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    l=sorted(zip(lst(),lst(),range(n)))\n    h=[];sm=0\n    ans={}\n    for i in range(n):\n        pwr,cns,ind=l[i]\n        sm+=cns\n        if len(h)>k:\n            sm-=heapq.heappop(h)\n        ans[ind]=sm\n        heapq.heappush(h,cns)\n    for i in range(n):\n        stdout.write(str(ans[i])+' ')\n    print()","output":"nlogn"},{"instruction":"n=int(input())\ns=0\ni=1\nc=1\nwhile(s<n):\n    s+=9*i*c\n    c+=1\n    i*=10\nn=n-s+9*i*(c-1)\/\/10\nc=c-1\nr=n%c\nd=n\/\/c\nk=10**(c-1)+d\nif(r==0):\n    print(int(str(k-1)[-1]))\nelse:\n    print(int(str(k)[r-1]))","output":"logn"},{"instruction":"from math import ceil, sqrt, log\n\ndef mod_expo(n, p, m):\n\n\tresult = 1\n\twhile p != 0:\n\t\tif p%2 == 1:\n\t\t\tresult = (result * n)%m\n\t\tp \/\/= 2\n\t\tn = (n * n)%m\n\treturn result\n\ndef is_square(n):\n\treturn int(sqrt(n))*int(sqrt(n)) == n\n\ndef find_div(n):\n\td = []\n\tfor i in range(2, int(sqrt(n))+1):\n\t\tif n%i == 0:\n\t\t\tif i*i != n:\n\t\t\t\td.append(i)\n\t\t\t\td.append(n\/i)\n\t\t\telse:\n\t\t\t\td.append(i)\n\treturn d\n\ndef find_x(n):\n\td = find_div(2*n)\n\tfor div in d:\n\t\tx2 = div*(div + 2*n)\n\t\tif is_square(x2):\n\t\t\treturn sqrt(x2)\n\treturn -1\n\ndef find_base_side(n):\n\tsquares = [x*x for x in range(ceil(sqrt(n)))]\n\tfor i in range(len(squares)):\n\t\tfor j in range(len(squares)):\n\t\t\tif squares[i] + squares[j] == n*n:\n\t\t\t\treturn squares[i]\n\treturn -1\n\ndef str_add(n):\n\tn = list(n)\n\tfor i in range(1, len(n)+1):\n\t\tif n[-i] == '9':\n\t\t\tn[-i] = '0'\n\t\telse:\n\t\t\tn[-i] = int(int(n[-i]) + 1)\n\t\t\tbreak\n\tn = str(n)\n\treturn n\n\ndef str_sub(n):\n\tn = list(n)\n\tfor i in range(1, len(n)+1):\n\t\tif n[-i] == '0':\n\t\t\tn[-i] = '9'\n\t\telse:\n\t\t\tn[-i] = int(int(n[-i]) - 1)\n\t\t\tbreak\n\tn = str(n)\n\treturn n\n\ndef find_massive_x(n):\n\tif n%2 == 0:\n\t\tn2 = str(int(pow(n\/2, 2)))\n\t\tx = str_sub(n2)\n\t\ty = str_add(n2)\n\telse:\n\t\tn2 = str(int(pow(n, 2)\/2))\n\t\tx = str_sub(n2)\n\t\ty = str_add(n2)\n\tx = str(x)\n\ty = str(y)\n\tprint(x, y)\ndef find_triples(n):\n\tif n <= 2:\n\t\tprint(-1)\n\t\treturn\n\telse:\n\n\t\tx = find_massive_x(n)\n\n\tprint(-1)\n\ndef find_max_xor(l, r):\n\tlxr = l^r\n\tmsb_pos = 0\n\twhile lxr > 0:\n\t\tmsb_pos += 1\n\t\tlxr \/\/= 2\n\treturn pow(2, msb_pos)-1\n\nt = 1\n\nwhile t:\n\tt = t - 1\n\n\tprint(find_max_xor(l, r))","output":"logn"},{"instruction":"def sfy(n):\n    if n == 1: return [1]\n    elif n == 2: return [1, 2]\n    elif n == 3: return [1, 1, 3]\n    else:\n        if n % 2 == 0: return [1]*(n\/\/2) + [2*x for x in sfy(n\/\/2)]\n        else:\n            return [1]*(1 + n\/\/2) + [2*x for x in sfy(n\/\/2)]\nprint(\" \".join([str(x) for x in sfy(int(input()))]))","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass union_find:\n    def __init__(self, n):\n        self.n = n\n        self.rank = [0]*n\n        self.parent = [int(j) for j in range(n)]\n\n    def union(self,i,j):\n        i = self.find(i)\n        j = self.find(j)\n        if self.rank[i] == self.rank[j]:\n            self.parent[i] = j\n            self.rank[j] += 1\n\n        elif self.rank[i] > self.rank[j]:\n            self.parent[j] = i\n        else:\n            self.parent[i] = j\n\n    def find(self, i):\n        temp = i\n        if self.parent[temp] != temp:\n            self.parent[temp] = self.find(self.parent[temp])\n        return self.parent[temp]\nfrom math import log2, ceil\nfrom collections import deque, Counter as CC, defaultdict as dd\ndef main():\n\n        p,q,r  = [int(j) for j in input().split()]\n        a = [int(j) for j in input().split()]\n        b = [int(j) for j in input().split()]\n        c = [int(j) for j in input().split()]\n        a.sort()\n        b.sort()\n        c.sort()\n        l = [a,b,c]\n\n        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]\n        for i in range(p+1):\n            for j in range(q+1):\n                for k in range(r+1):\n                    s = [i-1,j-1,k-1]\n                    for u in range(3):\n\n                        s[u]+=1\n                        try:\n                            tmp = dp[s[0]][s[1]][s[2]]\n                        except:\n                            s[u]-=1\n                            continue\n                        tmp2 = 1\n                        flag =True\n                        for t in range(3):\n                            if(u!=t):\n                                if(s[t]==-1):\n                                    flag = False\n                                    break\n                                tmp2 *= l[t][s[t]]\n                        tmp += tmp2\n                        s[u]-=1\n                        if(flag):\n                            dp[i][j][k] = max(dp[i][j][k], tmp)\n        print(dp[p][q][r])\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\nfrom collections import *\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nceil1, out = lambda a, b: (a + b - 1) \/\/ b, []\n\nn, s = rints()\na, ans = rints_2d(n), -1\n\nfor i in range(26):\n    for j in range(60):\n        tem = i * 60 + j\n        ans = (i, j)\n        for h, m in a:\n            tem2 = h * 60 + m\n            if tem <= tem2:\n                if tem2 - (tem + 1) < s:\n                    ans = -1\n                    break\n            else:\n                if tem - (tem2 + 1) < s:\n                    ans = -1\n                    break\n\n        if ans != -1:\n            print('%d %d' % (ans[0], ans[1]))\n            exit()","output":"linear"},{"instruction":"n = int(input())\nans = []\nm = 1\nwhile n > 3:\n    ans += [m] * (n - n \/\/ 2)\n    n \/\/= 2\n    m *= 2\nif n == 3:\n    ans += [m, m, m * 3]\nelif n == 2:\n    ans += [m, m * 2]\nelse:\n    ans += [m]\nprint(*ans)","output":"nlogn"},{"instruction":"n, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\ns = []\nfor a in A:\n    if not s:\n        s.append(a)\n        continue\n    while s:\n        if a-K <= s[-1] < a:\n            s.pop()\n        else:\n            break\n    s.append(a)\nprint(len(s))","output":"nlogn"},{"instruction":"n=input()\nL=list(map(int,raw_input().split(' ')))\nD=[0]*101000\nmod=10**9+7\nitt=[0]*101000\np=[0]*100010\nD[0]=1\nfor i in range(100010):\n  D[i+1]=(D[i]*2)%mod\nfor i in range(n):\n  itt[L[i]]+=1\nfor i in range(1,100001):\n  for j in range(i*2,100001,i):\n    itt[i]+=itt[j]\n  p[i]=(D[itt[i]]+mod-1)%mod\ni=100000\nwhile i>=1:\n  for j in range(i*2,100001,i):\n    p[i]-=p[j]\n  p[i]=(p[i]%mod+mod)%mod\n  i-=1\nprint(p[1])","output":"np"},{"instruction":"n,l,r,x = [int(x) for x in input().split(\" \")]\narr = [int(x) for x in input().split(\" \")]\nans = 0\nfor i in range(2**n):\n\tsubset = []\n\tfor j in range(n):\n\t\tif (i & (1 << j)) != 0:\n\t\t\tsubset.append(arr[j])\n\tif len(subset)>1:\n\t    mx = max(subset)\n\t    mn = min(subset)\n\t    sm = sum(subset)\n\t    if l<=sm<=r and mx-mn>=x:\n\t        ans+=1\nprint(ans)","output":"np"},{"instruction":"import sys\n\nn, m = [int(w) for w in input().split()]\nx = [int(w) for w in input().split()]\nt = [int(w) for w in input().split()]\n\nif m == 1:\n    print(n)\n    sys.exit(0)\n\np = []\ntx = []\nfor i in range(n+m):\n    (tx if t[i] == 1 else p).append(x[i])\n\na = [0] * m\ni = 0\nfor pi in p:\n    while i < m-1 and pi > (tx[i]+tx[i+1])\/2:\n        i += 1\n    a[i] += 1\n\nprint(\" \".join(str(ai) for ai in a))","output":"nlogn"},{"instruction":"from itertools import chain, combinations\ndef powerset(iterable):\n    xs = list(iterable)\n\n    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))\nn,l,r,x=map(int,input().split())\nsett=list(map(int,input().split()))\npsett=powerset(sett)\ncount=0\nfor i in psett:\n    k=sorted(i)\n    j=sum(k)\n    if j>=l and j<=r and k[-1]-k[0]>=x:\n        count+=1\nprint(count)","output":"np"},{"instruction":"M=10**9+7\nn=int(input())\na=[]\nfor i in range(n):\n    a.append(input())\ndp=[[0]*(n+5) for i in range(n+2)]\ndp[0][0]=1\nfor i in range(1,n):\n    count=0\n    if a[i-1]=='f':\n        for j in range(n-2,-1,-1):\n            if dp[i-1][j]>0:\n                dp[i][j+1]=(dp[i][j+1]+dp[i-1][j])%M\n    else:\n        for j in range(n-2,-1,-1):\n            if dp[i-1][j]>0:\n                count=(count+dp[i-1][j])%M\n            dp[i][j]=(dp[i][j]+count)%M\nprint(sum(dp[n-1])%M)","output":"quadratic"},{"instruction":"class Solution:\n    left_check = staticmethod(lambda val, limit: val < limit)\n    right_check = staticmethod(lambda val, limit: val > limit)\n\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n\n        if (not self.isValid(root.left, root.val, self.left_check) or\n            not self.isValid(root.right, root.val, self.right_check)):\n            return False\n\n        return self.isValidBST(root.left) and self.isValidBST(root.right)\n\n    def isValid(self, root: Optional[TreeNode], limit: int, check) -> bool:\n        if not root:\n            return True\n        if not check(root.val, limit):\n            return False\n        return (self.isValid(root.left, limit, check) and\n                self.isValid(root.right, limit, check))","output":"quadratic"},{"instruction":"import sys\n\ndef is_prime(x):\n    return all(x%i for i in range(2, int(x**.5)+1))\n\nt = int(sys.stdin.read().strip())\nfor i in range(4, t\/\/2+1):\n    if not is_prime(i) and not is_prime(t-i):\n        print(i, t-i, sep=' ')\n        break","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,k=map(int,input().split())\ntheorems=list(map(int,input().split()))\nsleep=list(map(int,input().split()))\ntsum=[]\nts=0\nsleepsum=[]\nslsum=0\nfor i in range(n):\n    ts+=theorems[i]\n    tsum.append(ts)\n    if(sleep[i]==1):\n        slsum+=theorems[i]\n    sleepsum.append(slsum)\n\nmaxdiff=0\n\nmaxdiff=tsum[k-1]-sleepsum[k-1]\nfor i in range(1,n-k+1):\n    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])\n\n    maxdiff=max(maxdiff,diff)\n\nprint(slsum+maxdiff)","output":"linear"},{"instruction":"n,k = map(int,input().split())\ns= input()\ns1=s\nc=0\nfor i in range(len(s)-1):\n    if(s[:i+1]==s[n-i-1:]):\n        c=i+1\nfor i in range(k-1):\n    s1+=s[c:]\nprint(s1)","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\na = sorted(a)\nans = 0\nb = [0] * n\nfor i in range(n):\n    if b[i] == 0:\n        ans += 1\n        for j in range(i, n):\n            if a[j] % a[i] == 0:\n                b[j] = 1\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\nans = 0\nsum = 0\nmp = {}\nfor i in range(n):\n    x = arr[i]\n    ans += (x * i) - sum;\n    ans -= (mp.get(x - 1, 0));\n    ans += (mp.get(x + 1, 0));\n    mp[x] = mp.get(x, 0) + 1;\n    sum += x;\nprint(ans)","output":"nlogn"},{"instruction":"class Solution:\n    def numDecodings(self, s: str) -> int:\n\n        def dfs(i):\n            if i == len(s):\n                return 1\n            if s[i] == '0':\n                return 0\n\n            res = dfs(i + 1)\n            if i < len(s) - 1:\n                if (s[i] == '1' or\n                   (s[i] == '2' and s[i + 1] < '7')):\n                    res += dfs(i + 2)\n\n            return res\n\n        return dfs(0)","output":"np"},{"instruction":"l ,r = map(int,input().split())\nfor i in range(63,-1,-1):\n    mx, mn= r,l\n    if (1<<i)&l and (1<<i)&r :\n        mx= (1<<i)-1\n        mx= r^(1<<i)|mx\n    elif ((1<<i)&l)==0 and ((1<<i)&r)==0 :\n        mn = (1<<i)-1\n        mn=(l&mn)^(l|(1<<i))\n    if mx>=l and mx <=r and mn>=l and mn<=r:\n        r,l=mx,mn\nprint(l^r)","output":"logn"},{"instruction":"from math import factorial\n\ns1 = input()\ns2 = input()\n\ncnt_plus_1, cnt_plus_2 = 0, 0\ncnt_minus_1, cnt_minus_2 = 0, 0\ncnt_question = 0\n\nfor i in range(len(s1)):\n    if s1[i] == \"+\": cnt_plus_1 += 1\n    if s1[i] == \"-\": cnt_minus_1 += 1\n\n    if s2[i] == \"+\": cnt_plus_2 += 1\n    if s2[i] == \"-\": cnt_minus_2 += 1\n\n    if s2[i] == \"?\": cnt_question += 1\n\nif cnt_question == 0:\n    if cnt_plus_1 == cnt_plus_2:\n        print(\"{:.9f}\".format(1.0))\n    else:\n        print(\"{:.9f}\".format(0.0))\nelif cnt_plus_2 + cnt_question < cnt_plus_1 or cnt_plus_2 > cnt_plus_1:\n    print(\"{:.9f}\".format(0.0))\nelse:\n    dP = cnt_plus_1 - cnt_plus_2\n    dM = cnt_question - dP\n\n    if dM == 0 or dP == 0:\n        print(\"{:0.9f}\".format(1 \/ (2**cnt_question)))\n    else:\n        CP = factorial(cnt_question) \/ (factorial(dP)*factorial(cnt_question - dP))\n        print((CP * (0.5 ** dP) * (1 - 0.5) ** (cnt_question - dP)))","output":"np"},{"instruction":"import sys\nfrom functools import reduce\ninput = sys.stdin.readline\n\ndef readPair():\n  return tuple(map(int, input().split()))\n\ndef readEntry():\n  e = readPair()\n  return (e[0], e[1], e[0] - e[1])\n\n(n, m) = readPair()\nentries = [readEntry() for _ in range(0, n)]\n\nentries.sort(key=lambda x: x[2], reverse=True)\n\nsize = reduce(lambda s, e: s + e[0], entries, 0)\ncount = 0\n\nwhile (size > m and count < n):\n  size -= entries[count][2]\n  count += 1\n\nprint(-1 if size > m else count)","output":"nlogn"},{"instruction":"import sys, os\n\nnumbs = [int(x) for x in sys.stdin.buffer.read().split()]\nn = numbs.pop(0)\n\nbase = []\nout = []\n\nfor i in range(n):\n    x = numbs[i]\n    how = 0\n\n    for b,rep in base:\n        if x.bit_length() == b.bit_length():\n            x ^= b\n            how ^= rep\n\n    if x:\n        how |= 1 << i\n\n        a = 0\n        b = len(base)\n        while a < b:\n            c = a + b >> 1\n            if base[c][0] > x:\n                a = c + 1\n            else:\n                b = c\n        base.insert(a, (x, how))\n\n        out.append(0)\n    else:\n        outind = len(out)\n        out.append(-1)\n\n        y = bin(how).encode('ascii')\n        ylen = len(y)\n        for i in range(2,len(y)):\n            if y[i] == 49:\n                out.append(ylen - 1 - i)\n        out[outind] = len(out) - 1 - outind\n\nos.write(1, b'\\n'.join(str(x).encode('ascii') for x in out))","output":"np"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(200001)]\npp=[0]*200001\ndef SieveOfEratosthenes(n=200000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\nMOD = int(1e9+7)\nn = int(input())\na = [input() for i in range(n)]\ndp = [1]\nfor i in range(n):\n    if a[i] == 'f':\n        dp.append(0)\n        continue\n    for j in range(1, len(dp)):\n        dp[j] = (dp[j] + dp[j-1]) % MOD\nprint(dp[-1])","output":"quadratic"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\nfrom itertools import groupby as gb\nfrom fractions import Fraction as fr\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\ndef ceildiv(x,y): return (x+y-1)\/\/y\n\ndef datainput():\n    return map(int, input().split())\ndef listinput():\n    return list(map(int, input().split()))\n\nn=int(input())\nans={}\nwhile n:\n    n-=1\n    a,x =datainput()\n    ans[a]=x\nm=int(input())\nwhile m:\n    m-=1\n    b,y =datainput()\n    if b in ans:\n        if ans[b] < y:\n            ans[b]=y\n    else:\n        ans[b]=y\nprint(sum(list(ans.values())))","output":"nlogn"},{"instruction":"mod=1000000007\nimport math\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\ndef modInverse(b,m):\n    g = math.gcd(b, m)\n    if (g != 1):\n\n        return -1\n    else:\n\n        return pow(b, m - 2, m)\n\ndef modDivide(a,b,m):\n    a = a % m\n    inv = modInverse(b,m)\n    a=(a*inv)%m\n    return a\nn,k=map(int,input().split())\nans=(powm(4,k,mod)*n)%mod\nr=powm(2,k,mod)\nr=(powm(r,2,mod)-r)%mod\nw=modDivide(r,2,mod)\nans=(ans-w)\ner=powm(2,k,mod)\nans=modDivide(ans,er,mod)\nans=(ans*2)%mod\nif n==0:\n    ans=0\nprint(ans)","output":"logn"},{"instruction":"n,k =  map(int,input().split())\n\ndef tonny(i) :\n\treturn (ord(i)-96)\na= sorted(input())\na=list(map(tonny,a))\na=sorted(list(set(a)))\nans=[a.pop(0)]\nk-=1\nfor j in a :\n\tif j-ans[-1] >1 and k>0 :\n\t\tk-=1\n\t\tans.append(j)\n\tif k==0 :\n\t\tbreak\nif k!=0 :\n\tprint(-1)\nelse:\n\tprint(sum(ans))","output":"linear"},{"instruction":"n = int(input())\nm = int(input())\nr = 1\nfor power in range(n):\n    r *= 2\n    if r > m:\n        print(m)\n        break\nelse:\n    if r == m:\n        print(0)\n    else:\n        print(m % r)","output":"constant"},{"instruction":"def check(n,p):\n    k=str(n)\n    k=k[::-1]\n    s=0\n    for j in range(len(k)):\n        s+=(int(k[j])*(10**j-1))\n    if s>=p:\n        return 1\n    else:\n        return 0\n\nn,s=map(int,input().split())\nl=1\nh=n\nk=0\nwhile(l<=h):\n    m=(l+h)\/\/2\n    if check(m,s)==0:\n        l=m+1\n    else:\n        h=m-1\n    k+=1\nprint(n-l+1)","output":"logn"},{"instruction":"import sys, copy\n\nn, m = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = [0] * (max(arr) + 1)\nfor i in arr:\n    res[i] += 1\nans = 0\nfor d in range(1, m + 1):\n    temp = copy.deepcopy(res)\n    cnt = 0\n    for i in range(len(temp)):\n        while temp[i] >= d:\n            temp[i] -= d\n            cnt += 1\n    if cnt >= n:\n        ans = max(ans, d)\nprint(ans)","output":"nlogn"},{"instruction":"import collections\nn = int(input())\ns = input()\nt = input()\nif collections.Counter(s) != collections.Counter(t):\n    print(-1)\n    exit()\nsl = list(s)\nst = list(t)\nans = []\np = 0\nwhile sl:\n    if sl[0] != st[0]:\n        k = sl.index(st[0])\n        ans.extend(list(range(k + p, p, -1)))\n        sl.pop(k)\n        st.pop(0)\n\n    else:\n        sl.pop(0)\n        st.pop(0)\n    p += 1\nprint(len(ans))\nprint(*ans)","output":"quadratic"},{"instruction":"n = int(input())\ns = ['']\nfor i in range(n):\n\tinp = input()\n\ts.append(inp)\n\tpos = len(s) - 1\n\twhile len(s[pos]) < len(s[pos-1]):\n\t\ts[pos], s[pos-1] = s[pos-1], s[pos]\n\t\tpos -= 1\nout = 'YES'\nfor i in range(n):\n\tif not s[i] in s[i+1]:\n\t\tout = 'NO'\n\t\ts = []\n\t\tbreak\nprint(out + '\\n'.join(s))","output":"nlogn"},{"instruction":"r,g,b = list(map(int, input().split()))\nls_r = sorted(list(map(int, input().split())))\nls_g = sorted(list(map(int, input().split())))\nls_b = sorted(list(map(int, input().split())))\n\ndp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]\n\ndef recursive(idx_r, idx_g, idx_b):\n    if dp[idx_r][idx_g][idx_b] is not None:\n        return dp[idx_r][idx_g][idx_b]\n    res_1 = 0\n    res_2 = 0\n    res_3 = 0\n    if (idx_r-1) >= 0 and (idx_g-1) >= 0:\n        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]\n    if (idx_g-1) >= 0 and (idx_b-1) >= 0:\n        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]\n    if (idx_r-1) >= 0 and (idx_b-1) >= 0:\n        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]\n\n    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)\n    return dp[idx_r][idx_g][idx_b]\n\nprint(recursive(r,g,b))","output":"cubic"},{"instruction":"n=int(input())\ng=n\/\/2\nprint(g+n)","output":"constant"},{"instruction":"x, k = (int(x) for x in input().split())\nmod = 10 ** 9 + 7\nif x == 0:\n    print(0)\n    quit()\nif k == 0:\n    print(2 * x % mod)\n    quit()\n\nans = pow(2, k + 1, mod)\nans *= x\nans %= mod\nans -= pow(2, k, mod)\nans += 1\nans %= mod\nans += mod\nans %= mod\nprint(ans)","output":"logn"},{"instruction":"import math\nimport sys\n\nn = int(input())\nr = 0\nt = 1\nfor i in range(n-1):\n    r += t*2\n    t += 2\nprint(r + t)","output":"linear"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\nfrom collections import defaultdict,Counter\nfrom copy import deepcopy\n\ndef main():\n    n,c = map(int,input().split())\n    a = list(map(int,input().split()))\n    nums = defaultdict(lambda :[0])\n    freq,minus = Counter(),0\n    for i in a:\n        if i == c:\n            minus += 1\n        else:\n            freq[i] += 1\n            nums[i].append(freq[i]-minus)\n    tot = minus\n    suff = deepcopy(nums)\n    for i in nums:\n        for j in range(len(nums[i])-2,0,-1):\n            suff[i][j] = max(suff[i][j],suff[i][j+1])\n    freq,ans = Counter(),tot\n    for i in a:\n        if i == c:\n            continue\n        freq[i] += 1\n        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"def findSet(u):\n  if parents[u] != u:\n    parents[u] = findSet(parents[u])\n  return parents[u]\n\ndef unionSet(u, v):\n  up = findSet(u)\n  vp = findSet(v)\n  if up == vp:\n    return\n\n  if ranks[up] > ranks[vp]:\n    parents[vp] = up\n  elif ranks[up] < ranks[vp]:\n    parents[up] = vp\n  else:\n    parents[up] = vp\n    ranks[vp] += 1\n\nn, a, b = map(int, input().split())\nps = list(map(int, input().split()))\n\nmapping = set(ps)\n\nparents = {x: x for x in ps}\nparents['A'] = 'A'\nparents['B'] = 'B'\nranks = {x: 0 for x in ps}\nranks['A'] = 0\nranks['B'] = 0\n\nresult = True\nfor x in ps:\n  if a - x in mapping:\n    unionSet(x, a - x)\n  else:\n    unionSet(x, 'B')\n\n  if b - x in mapping:\n    unionSet(x, b - x)\n  else:\n    unionSet(x, 'A')\n\nif findSet('A') == findSet('B'):\n  print(\"NO\")\n\nelse:\n  print(\"YES\")\n  for i in ps:\n    if findSet(i) == findSet('A'):\n      print(\"0\", end = ' ')\n    else:\n      print(\"1\", end = ' ')","output":"linear"},{"instruction":"n = int(input())\nprint(n\/\/2+1)","output":"constant"},{"instruction":"dul = 0\nn, k = map(int,input().split())\nsum1 = 0\nif k == 0:\n    for i in range (n-1,-1,-1):\n        sum1 = sum1 + 1\n        dul = dul + sum1\n        if dul == i:\n            print(i)\n            break\n\nif k != 0:\n    for i in range (n-1,-1,-1):\n        sum1 = sum1 + 1\n        dul = dul + sum1\n        if dul - i == k:\n            print(i)\n            break","output":"logn"},{"instruction":"n = input()\nseat_rows = [int(x) for x in input().strip().split()]\naliens = input().strip()\n\neldian = \"0\"\nmarleyan = \"1\"\n\nempty = sorted(enumerate(seat_rows), key=lambda x: x[1], reverse=True)\nnon_empty = []\n\nresult = []\nfor alien in aliens:\n    if alien == eldian:\n        row = empty.pop()\n        non_empty.append(row)\n    else:\n        row = non_empty.pop()\n\n    result.append(row[0] + 1)\n\nprint(' '.join(map(str, result)))","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\nli = []\n\nfor i in range(n):\n    x,w = map(int,input().split())\n    li.append((x-w,x+w))\n\nli.sort(key = lambda x: x[1])\n\na = -10 ** 9\nans = 0\n\nfor i in range(n):\n     if a <= li[i][0]:\n         ans += 1\n         a = li[i][1]\n\nprint(ans)","output":"nlogn"},{"instruction":"def main():\n    c,r,o,e=0,0,[0]*300000,[0]*300000\n    for _ in range(int(input())):\n        s=input()\n        l,n=0,0\n        for i in s:\n            if i=='(':\n                l+=1\n            else:\n                if l!=0:\n                    l-=1\n                else:\n                    n+=1\n        if l==0 and n==0:\n            c+=1\n        elif l!=0 and n!=0:\n            pass\n        elif l!=0:\n            o[l]+=1\n        else:\n            e[n]+=1\n    for i in range(300000):\n        if e[i] and o[i]:\n            r+=e[i]*o[i]\n    print(pow(c,2)+r)\nif __name__=='__main__':\n    main()","output":"linear"},{"instruction":"a, v = list(map(int, input().split(\" \")))\nl, d, w = list(map(int, input().split(\" \")))\n\nif(v <= w or w * w > 2 * a * d):\n    if(v * v > 2 * a * l):\n        print((2 * l \/ a) ** 0.5)\n    else:\n        print(l \/ v + v \/ 2 \/ a)\nelse:\n    u = (w * w \/ 2 + a * d) ** 0.5\n    if(u > v):\n        m =  v \/ a + (v - w) \/ a + (d - (v * v \/ 2 \/ a) - (v * v - w * w) \/ 2 \/ a) \/ v\n    else:\n        m = (2 * u - w) \/ a\n\n    if(v * v > 2 * a * (l - d + w * w \/ 2 \/ a)):\n        print(m - w \/ a + (2 * (l - d + (w * w \/ 2 \/ a)) \/ a) ** 0.5)\n    else:\n        print(m - w \/ a + (l - d + w * w \/ 2 \/ a) \/ v + v \/ 2 \/ a)","output":"constant"},{"instruction":"n, a, b, c, T = map(int, input().split())\nts = list(map(int, input().split()))\nts.sort()\nans = 0\nfor t in ts:\n    temp = -10**18\n    for u in range(t, T+1):\n        temp = max(temp, c*(u-t)+a-b*(u-t))\n\n    ans += temp\nprint(ans)","output":"linear"},{"instruction":"MOD = int(1e9 + 7)\nx, k = map(int, input().split())\nif x == 0: print(0)\nelse: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)","output":"logn"},{"instruction":"n = int(input())\na = iter(map(int, input().split()))\nprev_type = 3\nprev_res = 2\ncurr_a = next(a)\nres = []\nfor _ in range(1):\n\tfor next_a in a:\n\t\tif next_a > curr_a:\n\t\t\tif prev_type == 1 or prev_res == 1:\n\t\t\t\tprev_res += 1\n\t\t\t\tif prev_res == 5:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 1\n\t\t\tprev_type = 1\n\t\telif next_a < curr_a:\n\t\t\tif prev_type == 2 or prev_res == 5:\n\t\t\t\tprev_res -= 1\n\t\t\t\tif prev_res == 1:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 5\n\t\t\tprev_type = 2\n\t\telse:\n\t\t\tif prev_type == 1:\n\t\t\t\tprev_res += 1\n\t\t\telif prev_type == 2:\n\t\t\t\tprev_res -= 1\n\t\t\telif prev_res != 2:\n\t\t\t\tprev_res = 2\n\t\t\telse:\n\t\t\t\tprev_res = 3\n\t\t\tprev_type = 3\n\t\tres.append(prev_res)\n\t\tcurr_a = next_a\n\telse:\n\t\tif prev_type == 1:\n\t\t\tres.append(prev_res + 1)\n\t\telif prev_type == 2:\n\t\t\tres.append(prev_res - 1)\n\t\telif prev_res != 1:\n\t\t\tres.append(1)\n\t\telse:\n\t\t\tres.append(2)\n\t\tprint(*res)\n\t\tbreak\nelse:\n\tprint('-1')","output":"linear"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    itvs = []\n    for _ in range(N):\n        x, w = map(int, input().split())\n        itvs.append((x - w, x + w))\n    itvs.sort(key=lambda x: x[1])\n\n    ans = 0\n    end = -(10**9 + 1)\n    for l, r in itvs:\n        if end <= l:\n            ans += 1\n            end = r\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x: x[1])\n        n = len(intervals)\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n\n            res = 1\n            for j in range(i + 1, n):\n                if intervals[i][1] <= intervals[j][0]:\n                    res = max(res, 1 + dfs(j))\n            memo[i] = res\n            return res\n\n        return n - dfs(0)","output":"quadratic"},{"instruction":"num = int(input())\nlayne = input()\nlayne = layne.split()\nlayne = [int(i) for i in layne]\nmx = max(layne)\ndorf = mx * 2 * num\nindx = 1\nfor i in range(num):\n    dor = (layne[i] \/\/ num) * num\n    if (layne[i] % num) - i > 0:\n        dor = dor + num + i + 1\n    else:\n        dor = dor + i + 1\n    if dor < dorf:\n        dorf = dor\n        indx = i + 1\nprint(indx)","output":"linear"},{"instruction":"a = input()\nlst = []\na_1 = \"\"\nfor i in range(len(a)):\n    if a[i] != \" \":\n        a_1 = a_1 + a[i]\n    else:\n        lst.append(int(a_1))\n        a_1 = \"\"\nlst.append(int(a_1))\nif lst[1] > 2 * lst[0] - 1:\n    print(0)\nelse:\n    countr = 0\n    if lst[1] % 2 == 1:\n        countr = (lst[1] - 1) \/\/ 2\n    else:\n        countr = (lst[1] - 2) \/\/ 2\n    if lst[1] > lst[0] + 1:\n        countr = countr - lst[1] + lst[0] + 1\n    print(countr)","output":"constant"},{"instruction":"from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0]\n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n\/\/=i\n    if n>1:\n        lst.append(n)\n    return lst\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\na = int(stdin.readline())\nb = getInt()\n\nans = ''\n\nc = sorted(list(str(a)))\n\nwhile c:\n    for i in range(len(c) - 1, -1, -1):\n        if int(''.join(list(ans) + [c[i]] + c[:i] + c[i + 1:])) <= b:\n            ans += c[i]\n            c.pop(i)\n            break\n\nstdout.write(ans)","output":"cubic"},{"instruction":"import sys\nn=int(input())\n\nif n<=3:\n    print(0)\n    sys.exit()\n\nscore=0\nimport math\ndef score(x):\n    ANS=0\n    xr=math.ceil(math.sqrt(x))\n\n    LIST=[]\n    for i in range(1,xr+3):\n        if x%i==0:\n            LIST.append(i)\n            LIST.append(x\/\/i)\n\n    LIST=sorted(list(set(LIST)))\n\n    for l in LIST[1:-1]:\n        ANS+=x\/\/l\n\n    return ANS\n\nANS=0\nfor i in range(4,n+1):\n    ANS+=score(i)\n\nprint(ANS*4)","output":"linear"},{"instruction":"from collections import defaultdict\nfrom collections import deque\n\nclass graph:\n    def __init__(self):\n        self.g=defaultdict(list)\n    def addedge(self,u,v):\n        self.g[u].append(v)\ndef router(values):\n    gr=graph()\n    for i in range(len(values)):\n        gr.addedge(values[i], i+2)\n    return gr.g\n\ndef isleaf(node,gr):\n    if len(gr[node])==0:\n        return True\n    return False\n\ndef christmas(gr,start,visited):\n    q=deque()\n    q.append(start)\n    visited[start]=True\n    count=0\n    while q:\n        count=0\n        value=q.popleft()\n        for val in gr[value]:\n            if not isleaf(val,gr):\n                q.append(val)\n                visited[val]=True\n            else:\n                visited[val]=True\n                count=count+1\n        if count<3:\n            return 'No'\n    if count<3:\n        return 'No'\n    return 'Yes'\nn=int(input())\nvalues=[]\nfor i in range(n-1):\n    value=int(input())\n    values.append(value)\ngr=router(values)\nvisited=[False]*(n+1)\nprint(christmas(gr, 1, visited))","output":"linear"},{"instruction":"n,m=(int(x) for x in input().split())\nsequence=input().split()[:n]\nfingerprint=input().split()[:m]\nprint(\" \".join(i for i in sequence if i in fingerprint))","output":"quadratic"},{"instruction":"n = int(input())\nlst = list(map(int, input().split()))\ncur = 1\nif n == 1:\n    print(1)\n    exit()\nif lst[cur] > lst[cur - 1]:\n    a = [1]\nelif lst[cur] < lst[cur - 1]:\n    a = [5]\nelse:\n    a = [3]\npr = False\nwhile cur != n:\n    cnt = 0\n\n    if lst[cur] > lst[cur - 1]:\n        while cur != n and lst[cur] > lst[cur - 1]:\n            cnt += 1\n            cur += 1\n        for i in range(cnt - 1):\n            a.append(a[-1] + 1)\n            if a[-1] >= 5:\n                print(-1)\n                exit()\n        if n != cur and lst[cur] == lst[cur - 1]:\n            a.append(a[-1] + 1)\n        else:\n            a.append(5)\n\n    elif lst[cur] < lst[cur - 1]:\n        while cur != n and lst[cur] < lst[cur - 1]:\n            cnt += 1\n            cur += 1\n        for i in range(cnt - 1):\n            a.append(a[-1] - 1)\n            if a[-1] <= 1:\n                print(-1)\n                exit()\n        if n != cur and lst[cur] == lst[cur - 1]:\n            a.append(a[-1] - 1)\n        else:\n            a.append(1)\n    else:\n        while cur != n and lst[cur] == lst[cur - 1]:\n            cnt += 1\n            cur += 1\n\n        for i in range(cnt - 1):\n            if a[-1] < 3:\n                a.append(a[-1] + 1)\n            else:\n                a.append(a[-1] - 1)\n\n        if cur != n and lst[cur] > lst[cur - 1]:\n            if a[-1] == 1:\n                a.append(2)\n            else:\n                a.append(1)\n        else:\n            if a[-1] == 5:\n                a.append(4)\n            else:\n                a.append(5)\nprint(*a)","output":"quadratic"},{"instruction":"from math import factorial\ns=input().rstrip()\ns1=input().rstrip()\npos1=0\npos=0\nposi=0\nnegi=0\nposi1=0\nnegi1=0\nques1=0\nfor i in s:\n    if i=='+':\n        pos+=1\n        posi+=1\n\n    else:\n        pos-=1\n        negi+=1\nfor i in s1:\n    if i=='+':\n        posi1+=1\n    elif i=='-':\n        negi1+=1\n    else:\n        ques1+=1\nif posi==posi1 and negi==negi1:\n    print(1)\n    exit()\ndiff1=posi-posi1\ndiff=negi-negi1\nif diff<0  or diff1<0:\n    print(0)\nelse:\n    outcomes=2**ques1\n    nume=factorial(ques1)\n    deno=factorial(ques1-diff1)*factorial(diff1)\n    fav1=nume\/deno\n    ques1=ques1-diff1\n    num1=factorial(ques1)\n    deno1=factorial(ques1-diff)*factorial(diff)\n    fav2=num1\/deno1\n    ans=fav1*fav2\n    print(ans\/outcomes)","output":"np"},{"instruction":"def check(num):\n    l = list(str(num))\n    l = list(dict.fromkeys(l))\n    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True\n    else: return False\n\nlucky = False\nn = int(input())\nfor i in range(3, n+1):\n    if n%i==0 and check(i): lucky=True\nprint(\"YES\" if lucky else \"NO\")","output":"constant"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\nn = INT()\narr = LIST()\nmx = max(arr)\nx = -1\nif mx == 1 :\n    x = 2\nelse:\n    x = 1\n\narr.remove(mx)\narr.append(x)\narr.sort()\nprint(*arr)","output":"nlogn"},{"instruction":"from collections import Counter\nfrom math import *\nimport sys\nmod=1000000007\n\ndef pro(arr,q):\n    n=len(arr)\n    ans=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if(arr[i]>arr[j]):\n                ans+=1\n\n    res=ans%2\n    for x,y in q:\n        k= y-x + 1\n        k=k\/\/2\n        k=k%2\n        res= k^res\n        if(res):\n            print('odd')\n        else:\n            print('even')\nn=int(input())\narr=list(map(int,input().split()))\nt=int(input())\nque=[]\nfor i in range(t):\n    que.append(list(map(int,input().split())))\npro(arr,que)","output":"quadratic"},{"instruction":"def solve(a: int, b: int) -> int:\n    if a > b:\n        a, b = b, a\n    ba = bin(a)[2:]\n    bb = bin(b)[2:]\n    r = ''\n    if len(ba) != len(bb):\n        int('1' * len(bb), 2)\n    else:\n        for ca, cb in zip(ba, bb):\n            if ca == cb:\n                r += '0'\n            else:\n                r += '1'\n                break\n    r += '1' * (len(bb) - len(r))\n    return int(r, 2)\n\na, b = map(int, input().split())\nprint(solve(a, b))","output":"logn"},{"instruction":"import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):\n        d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn,m,k = [int(i) for i in input().split()]\nh = []\nfor i in range (n):\n    h.append([int(i) for i in input().split()])\nv = []\nfor i in range (n-1):\n    v.append([int(i) for i in input().split()])\nif k%2:\n    for i in range (n):\n        for j in range (m):\n            print(-1,end=\" \")\n        print()\n    exit()\ndp = [[[float('inf')]*m for i in range (n)] for j in range (k\/\/2+1)]\nfor i in range (n):\n    for j in range (m):\n        dp[0][i][j] = 0\nfor x in range (1,k\/\/2+1):\n    for i in range (n):\n        for j in range (m):\n            if i!=0:\n                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i-1][j] + v[i-1][j])\n            if i!=n-1:\n                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i+1][j] + v[i][j])\n            if j!=0:\n                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j-1] + h[i][j-1])\n            if j!=m-1:\n                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j+1] + h[i][j])\n\nfor i in range (n):\n    for j in range (m):\n        print(2*dp[k\/\/2][i][j],end=\" \")\n    print()","output":"cubic"},{"instruction":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n\n        matrix.reverse()\n\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]","output":"quadratic"},{"instruction":"def f(n):\n    k=2\n    while k*k<=n:\n        if n%k==0:\n            return False\n        k+=1\n    return True\nn,k=map(int,input().split())\na=[]\nx=0\nfor i in range(2,n+1):\n    if f(i):\n        a.append(i)\nfor i in range(len(a)-2):\n    if a[i]+a[i+1]+1 in a:\n        x+=1\nif x>=k:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"N=int(input())\nA=[int(x) for x in input().split()]\nbit=[]\nnax=200010\nfor i in range(nax*4+1):\n    bit.append([0,0])\n\ndef up(k,val):\n    while k< (nax*4):\n        bit[k][0]+=val\n        bit[k][1]+=1\n        k+=(k&-k)\n\ndef go(k):\n    ans=0;r=0\n    while k>0:\n        ans+=bit[k][0]\n        r+=bit[k][1]\n        k-=(k&-k)\n    return ans,r\n\nindex={}\nB=[x for x in A]\nB.sort()\nidx=1\nindex[B[0]]=idx;\nfor i in range(1,N):\n    if B[i]!=B[i-1]:\n        if B[i]==(B[i-1]+1):\n            idx+=1\n            index[B[i]]=idx\n        else:\n            idx+=2\n            index[B[i]]=idx\n\nhave=0\nfor i in range(0,N):\n    a1,a2=go(index[A[i]]-2)\n    a3,a4=go(3*N)\n    a5,a6=go(index[A[i]]+1)\n    s1=(a2*A[i])-(a1)\n    s2=((a4-a6)*A[i])-(a3-a5)\n    have+=s1\n    have+=s2\n    up(index[A[i]],A[i])\n\nprint(have)","output":"nlogn"},{"instruction":"import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    sum_A = sum(A)\n    cnt = defaultdict(int)\n    for a in A:\n        cnt[a] += 1\n\n    ans = 0\n    for i in range(N):\n        a = A[i]\n        cnt[a] -= 1\n        sum_A -= a\n\n        tmp = sum_A\n        n = 0\n        for b in (a-1, a, a+1):\n            n += cnt[b]\n            tmp -= b * cnt[b]\n        ans += tmp - a * (N-1-i-n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n,m,k = map(int,input().split())\na = list(map(int,input().split()))\na.sort(reverse = True)\ns = 0\ncount = 0\n\ni = 0\nwhile k<m and i<n:\n    k+=a[i]-1\n    i+=1\nprint(i if k>=m else -1)","output":"nlogn"},{"instruction":"import math\n\ndef read_ints():\n    return map(int, input().split())\n\ndef read_matrix(n):\n    return [list(read_ints()) for _ in range(n)]\n\ndef around(x, y, hor, ver, mtx):\n    a, b, c, d = [math.inf]*4\n\n    if x > 0:\n        a = hor[y][x - 1] * 2 + mtx[y][x - 1]\n\n    if x < m - 1:\n        b = hor[y][x] * 2 + mtx[y][x + 1]\n\n    if y > 0:\n        c = ver[y - 1][x] * 2 + mtx[y - 1][x]\n\n    if y < n - 1:\n        d = ver[y][x] * 2 + mtx[y + 1][x]\n\n    return min(a, b, c, d)\n\nif __name__ == \"__main__\":\n    n, m, k = read_ints()\n    hor = read_matrix(n)\n    ver = read_matrix(n - 1)\n\n    if k % 2:\n        for i in range(n):\n            print('-1 ' * m)\n        exit()\n\n    _old = [[0] * m for _ in range(n)]\n    for i in range(k \/\/ 2):\n        _new = [[0] * m for _ in ' ' * n]\n\n        for x in range(m):\n            for y in range(n):\n                _new[y][x] = around(x, y, hor, ver, _old)\n\n        _old = _new\n\n    for row in _old:\n        print(*row)","output":"cubic"},{"instruction":"n=int(input())\nb=[]\nfor i in range(n):\n    b.append(list(map(float,input().split())))\n\nma=1<<n\ndp=[0 for j in range(ma)]\ndp[0]=1\nfor mask in range(1,ma):\n    l=n-bin(mask).count(\"1\")+1\n    res=l*(l-1)\/\/2\n    for i in range(n):\n        if mask&(1<<i):\n            for j in range(n):\n                if not mask&(1<<j):\n\n                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])\/res)\n\nans=[]\nfor i in range(n):\n    ans.append(dp[ma-1-(1<<i)])\nprint(*ans)","output":"np"},{"instruction":"h,b = map(int,input().split())\nx,y,z = map(int,input().split())\nprint(max(0,2*x+y-h)+max(0,3*z+y-b))","output":"constant"},{"instruction":"import sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag == 0 or not T:\n        print('NO')\n    else:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n\nmain()","output":"np"},{"instruction":"x, k = list(map(int,input().split()))\nm = 1000000000 +7\nif x!=0:\n    p1 = x*2 - 1\n    p2 = x*2\n    p = (p1 + p2)\/\/2\n    print((p*pow(2,k,m) + 1)%m)\nelse:\n    print(x*2)","output":"logn"},{"instruction":"def main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    array = []\n    array.append(a)\n\n    for i in range(n - 1):\n        aux = []\n        for j in range(1, len(array[-1])):\n            xor = (array[-1][j-1] ^ array[-1][j])\n            aux.append(xor)\n        array.append(aux)\n\n    for j in range(1, len(array)):\n        for k in range(len(array[j])):\n            maximo = max(array[j][k], array[j-1][k], array[j-1][k+1])\n            array[j][k] = maximo\n\n    q = int(input())\n    aux2 = []\n\n    for i in range(q):\n        l, r = map(int, input().split(' '))\n        aux2.append((l, r))\n\n    for i in aux2:\n        l, r = i[0], i[1]\n        print(str(array[r-l][l-1]))\n\nmain()","output":"quadratic"},{"instruction":"from collections import defaultdict as dd\nimport math\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn map(int, input().split())\n\ndef lm():\n\treturn list(map(int, input().split()))\n\nn,v=mi()\n\ndist=n-1\n\nif v>=dist:\n\tprint(dist)\n\nelse:\n\toff=dist-v\n\tprices=[i+2 for i in range(off)]\n\tprint(v+sum(prices))","output":"linear"},{"instruction":"R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\ndp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]\nmx = 0\n\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i < R and j < G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])\n            if i < R and k < B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])\n            if j < G and k < B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])\n            mx = max(mx, dp[i][j][k])\n\nprint(mx)","output":"cubic"},{"instruction":"from math import pi, sin\nfrom decimal import Decimal\n\nn, r = map(int, input().split())\nalpha = Decimal(pi)\/Decimal(n)\na = Decimal(sin(alpha))\nR = Decimal((r * a) \/ (1 - a))\nprint(R)","output":"constant"},{"instruction":"import math\n\na, b = [int(x) for x in input().split()]\nwhile a != 0 and b != 0:\n    x = int(math.log(a, 2))\n    y = int(math.log(b, 2))\n    if x != y:\n        break\n    a = a & (~(1 << x))\n    b = b & (~(1 << y))\n\nif a == 0 and b == 0:\n    print(0)\nelse:\n    if b > a:\n        a, b = b, a\n    x = int(math.log(a, 2)) + 1\n    b = (1 << x) - 1\n    a = a | b\n    print(a)","output":"logn"},{"instruction":"s = input()\nn = len(s)\nm = n - 1;\nwhile m > 0:\n    find = False\n    for i in range(0, n - m):\n        for j in range(i + 1, n - m + 1):\n            match = True\n            for k in range(0, m):\n                if s[i+k] != s[j+k]:\n                    match = False\n                    break\n            if match:\n                find = True\n                break\n        if find:\n            break\n    if find:\n        break\n    m -= 1\nprint(m)","output":"cubic"},{"instruction":"def ct(s):\n    a=[0]*26*2\n    for i in s:\n        if ord(i)<97:\n            a[ord(i)-65]+=1\n        else:\n            a[ord(i)-97+26]+=1\n    return max(a)\nn=int(input())\ns1=input()\nln=len(s1)\ns1=ct(s1)\ns2=ct(input())\ns3=ct(input())\ns=[s1,s2,s3]\nfor i in range(len(s)):\n    if s[i]==ln and n==1: s[i]=ln-1\n    else:s[i]=s[i]+n\n    if s[i]>ln: s[i]=ln\ns1=s[0]\ns2=s[1]\ns3=s[2]\n\ns.sort()\nif s[2]==s[1]:\n    print('Draw')\nelif s[-1]==s1:\n    print('Kuro')\nelif s[-1]==s2:\n    print('Shiro')\nelif s[-1]==s3:\n    print('Katie')","output":"linear"},{"instruction":"n=input()\ni=0\nwhile(True):\n    if (n-9*10**i*(i+1))<=0:\n        break\n    n-=9*10**i*(i+1)\n    i+=1\n\na=n\/(i+1)\nb=n%(i+1)\nif(b!=0):\n    print(str(10**i+a)[b-1])\nelse:\n    print(str(10**i+a-1)[-1])","output":"constant"},{"instruction":"from sys import stdin, stdout\nimport heapq\nfrom collections import defaultdict\nimport math\nimport bisect\n\ndef main():\n    n,m,k = list(map(int, stdin.readline().split()))\n    right = []\n    for _ in range(n):\n        right.append(list(map(int, stdin.readline().split())))\n    down = []\n    for _ in range(n-1):\n        down.append(list(map(int, stdin.readline().split())))\n    if k % 2 == 1:\n        for _ in range(n):\n            stdout.write(\" \".join([\"-1\" for _ in range(m)])+\"\\n\")\n        return\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for x in range(1, (k\/\/2) + 1):\n        tmp = [[math.inf for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])\n                if i < n-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])\n                if j:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])\n                if j < m-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])\n        dp = tmp\n\n    for i in range(n):\n        stdout.write(\" \".join([str(x) for x in dp[i]]) + \"\\n\")\n\nmain()","output":"cubic"},{"instruction":"if __name__ == '__main__':\n    a = [int(i) for i in input().split()]\n\n    mx = -1\n\n    for i in range(14):\n        b = a.copy()\n        if a[i]:\n            b[i], d, ans = 0, i + 1, 0\n            r = (a[i] + d) \/\/ 14\n            l = (a[i] + d) % 14\n\n            if d + a[i] < 14:\n                ans = sum([j + 1 for j in a[d:d + a[i]] if not (j + 1) % 2])\n            else:\n                for j in range(14):\n                    b[j] += r\n                if d > l:\n                    for j in range(l, d):\n                        b[j] -= 1\n                else:\n                    for j in range(d, d + abs(d - l)):\n                        b[j] += 1\n                ans = sum([p for p in b if not p % 2])\n            mx = max(mx, ans)\n\n    print(mx)","output":"constant"},{"instruction":"from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\ndef check(mid, m):\n    d = defaultdict(int)\n    for idx, i in enumerate(a):\n        string = ''\n        for j in i:\n            if j >= mid:\n                string+='1'\n            else:\n                string+='0'\n        d[int(string, 2)] = idx\n    for i in d.keys():\n        for j in d.keys():\n            if i|j == 2**m - 1:\n                 return [d[i], d[j]]\n    return []\ndef binarySearch(lo, hi, m):\n    ans = []\n    while lo < hi:\n        mid = lo + (hi-lo+1)\/\/2\n        x = check(mid, m)\n        if x:\n            lo = mid\n            ans = [x[0]+1, x[1]+1]\n        else:\n            hi = mid-1\n    return ans\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nprint(*binarySearch(-1, 10**9+1, m))","output":"np"},{"instruction":"from math import sqrt\nn,k = map(int, input().split())\n\nub = k*(k+1)\/\/2 - k+1\n\nif n> ub:\n    print(-1)\nelif n == ub:\n    print(k-1)\nelif n == 1:\n    print(0)\nelif n<=k:\n    print(1)\nelse:\n    st = 1\n    en = k-1\n    target = n-1\n    ub = k*(k-1)\/\/2\n    p = lambda x: ub - x*(x-1)\/\/2\n    ans = -1\n\n    while st <= en:\n        md = (st+en)\/\/2\n        if p(md) <= target:\n            ans = md\n\n            en = md-1\n        else:\n            st = md +1\n\n    if p(ans) == target:\n        print(k-ans)\n    else:\n        print(k-ans+1)","output":"logn"},{"instruction":"import sys\nsys.setrecursionlimit(200000)\ninput=sys.stdin.readline\n\ndef solve(r,g,b,R,G,B):\n    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):\n        return 0\n    if z[r][g][b]!=-1:\n        return z[r][g][b]\n    d,e,f=0,0,0\n    if r!=0 and g!=0:\n        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)\n    if r!=0 and b!=0:\n        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)\n    if b!=0 and g!=0:\n        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)\n    z[r][g][b]=max(d,e,f)\n    return z[r][g][b]\n\nr,g,b=map(int,input().rstrip().split())\nR=sorted(map(int,input().rstrip().split()))\nG=sorted(map(int,input().rstrip().split()))\nB=sorted(map(int,input().rstrip().split()))\nz=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]\nprint(solve(r,g,b,R,G,B))","output":"cubic"},{"instruction":"k = int(input())\nk -= 1\n\nc = 9\ns = 1\nwhile k >= c * s:\n    k -= c * s\n    c *= 10\n    s += 1\n\nn = 10**(s - 1) + k \/\/ s\nidx = k % s\nprint(str(n)[idx])","output":"logn"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\nl=sorted(l)\nif l[-1]==1:\n    l[-1]=2\nelse:\n    l[-1]=1\nl=sorted(l)\nprint(*l)","output":"nlogn"},{"instruction":"def d(n):\n    ret = 0\n    n = list(str(n))\n    for i in range(len(n)):\n        ret += int(n[i])\n    return ret\n\ndef main():\n    n, s = map(int, input().split())\n\n    l, h = 0, n\n    for i in range(2000):\n        m = (l + h) \/\/ 2\n        if m - d(m) >= s:\n            h = m\n        else:\n            l = m\n\n    for i in range(-100, 100):\n        t = m + i\n        if t < 0 or t > n:\n            continue\n        if abs(t - d(t)) >= s:\n            print(n - t + 1)\n            exit()\n    print(0)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"def main():\n    x, k = list(map(int, input().split()))\n    if x == 0:\n        print(0)\n        return 0\n    def helper(n):\n        if n == 0:\n            return 1\n        p = 1\n        ret = 2\n        while n >= 2 * p:\n            p *= 2\n            ret = (ret ** 2) % 1000000007\n        return ret * helper(n - p)\n    x = x % 1000000007\n    k = k % 1000000006\n    a = helper(k)\n    print((2 * a * x - a + 1) % 1000000007)\n    return 0\nmain()","output":"logn"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\np0 = getIntList()\np1 = getIntList()\np2 = getIntList()\n\nzp = [p0, p1, p2]\n\ndef getpath( p0, p1):\n    if p0[0] < p1[0]:\n        sp = 1\n    elif p0[0] > p1[0]:\n        sp = -1\n    else:\n        sp =0\n    zz = [tuple(p0), tuple(p1)]\n    if sp!=0:\n        for x in range(p0[0], p1[0]+ sp, sp):\n            tp = (x, p0[1])\n            zz.append(tp)\n    if p0[1] < p1[1]:\n        sp = 1\n    elif p0[1] > p1[1]:\n        sp = -1\n    else:\n        sp = 0\n    if sp!=0:\n        for y in range(p0[1], p1[1] + sp, sp):\n            tp = (p1[0], y)\n            zz.append(tp)\n    return zz\n\nnr = 1000000;\nzr = set()\nfor i in range(3):\n    for j in range(3):\n        cx = zp[i][0]\n        cy = zp[j][1]\n        cp = (cx, cy)\n        z1 = getpath(cp, zp[0])\n        z2 =getpath(cp, zp[1])\n        z3 =getpath(cp, zp[2])\n\n        z0 = z1+z2+z3\n        s1 = set(z0)\n        dprint(cp,s1)\n        if len(s1) < nr:\n            nr = len(s1)\n            zr = s1\n\nprint(len(zr))\nfor x in zr:\n    print(x[0], x[1])","output":"constant"},{"instruction":"n = int(input())\np = [0,0] + [int(w) for w in input().split()]\n\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\n\nif n == 1:\n    d[1] = 1\n\nd = d[1:]\nd.sort()\n\nprint(*d)","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,k=read()\ns=input()[:-1]\nans=\"\"\nfor i in range(len(s)+1, 0, -1):\n    res=s\n    end=s[-i:]\n    for j in range(k-1):\n        res += end\n    cnt=0\n    for j in range(len(res)-len(s)+1):\n        if res[j:j+len(s)] == s:\n            cnt += 1\n    if cnt == k:\n        ans = res\nprint(ans)","output":"quadratic"},{"instruction":"import sys\n\nsys.setrecursionlimit(10**5)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ninf = 10**16\nmd = 10**9+7\n\na,b=MI()\nx,y,z=MI()\nyel=x*2+y\nbul=y+z*3\nprint(max(0,yel-a)+max(0,bul-b))","output":"constant"},{"instruction":"def combinations(arr,n):\n    if(n==0):\n        return([[]])\n    l=[]\n    for i in range(len(arr)):\n        m=arr[i]\n        rem=arr[i+1:]\n        for j in combinations(rem,n-1):\n            l.append([m]+j)\n    return l\n\ndef solve(arr,n,l,r,x):\n    subset=[]\n    for i in range(2,n+1):\n        for j in combinations(arr,i):\n            if(sum(j)>=l and sum(j)<=r):\n                subset.append(j)\n    count=0\n    for i in subset:\n        mn=min(i)\n        mx=max(i)\n        if(mx-mn>=x):\n            count+=1\n\n    return(count)\n\nn,l,r,x=map(int,input().split())\narr=list(map(int,input().split()))\nprint(solve(arr,n,l,r,x))","output":"np"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    c = dict(Counter(l))\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i):\n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x \/\/ spf[x]\n    return ret\n\ndef SieveOfEratosthenes(n):\n\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef solve():\n    n,a,b,c,t = li()\n    ti = li()\n    if b>c:\n        print(n*a)\n    else:\n        ans = 0\n        ti.sort()\n        for i in ti:\n            ans+=(t-i)*(c-b)+a\n        print(ans)\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"linear"},{"instruction":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n \/\/ 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 \/ res","output":"logn"},{"instruction":"from sys import stdin\nc=int(stdin.readline().strip())\nfor i in range(c):\n    n=int(stdin.readline().strip())\n\n    s=list(map(int,stdin.readline().strip().split()))\n    s.sort()\n    l=min(s[-1],s[-2])\n    ans=min(l-1,n-2)\n    print(ans)","output":"nlogn"},{"instruction":"import math\n\ndef countDigit(n):\n\treturn math.floor(math.log(n, 10)+1)\n\nn=int(input())\ncount=countDigit(n)\nif count==1:\n\tprint(n)\nelse:\n\tlow=1\n\thigh=9\n\tsum=[]\n\tdigit=0\n\tsum.append(0)\n\tsum.append(9)\n\tfor i in range(2,16):\n\t\tlow=low*10\n\t\thigh=high*10+9\n\n\t\tsum.append((high-low+1)*i+sum[i-1])\n\n\t\tif n<sum[i]:\n\t\t\tdigit=i\n\t\t\tbreak\n\tx=n-sum[digit-1]\n\tq=x\/(digit)\n\tr=x%(digit)\n\tlow=math.pow(10,digit-1)\n\tlow=low+q-1\n\n\tif r==0:\n\t\tprint(int(low%10))\n\telse:\n\t\tn=low+1\n\t\tstringnum=str(n)\n\t\tprint(int(stringnum[r-1]))","output":"logn"},{"instruction":"import sys\n\nT = int(sys.stdin.readline().strip())\nfor t in range (0, T):\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    a.sort()\n    print(min([len(a)-2, a[-2]-1]))","output":"nlogn"},{"instruction":"import sys\n\nn, k = map(int, next(sys.stdin).rstrip().split())\n\nxs = list(map(int, next(sys.stdin).rstrip().split()))\n\nmapka = {}\nlengths = {}\n\nresult = []\n\nfor x in xs:\n\n    if x in mapka:\n        result.append(mapka[x])\n    else:\n        left = max(0, x - k + 1)\n        range_potential = x - left\n        for i in range(range_potential, -1, -1):\n            potential_left = x - i\n            if potential_left not in mapka:\n                result.append(potential_left)\n                for y in range(potential_left, x + 1):\n                    mapka[y] = potential_left\n\n                lengths[potential_left] = x - potential_left + 1\n\n                break\n            else:\n\n                if lengths[mapka[potential_left]] + (x - potential_left) <= k:\n                    result.append(mapka[potential_left])\n                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):\n                        mapka[y] = mapka[potential_left]\n                        lengths[mapka[potential_left]] += 1\n\n                    break\n\nprint(' '.join(map(str, result)))","output":"quadratic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(50001)]\npp=[]\ndef SieveOfEratosthenes(n=50000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    for i in range(50001):\n        if prime[i]:\n            pp.append(i)\n\nn,m,k=map(int,input().split())\na=list(map(int,input().split()))\na.sort(reverse=True)\nif k>=m:\n    print(0)\nelse:\n    curr=k\n    count=0\n    for i in range (n):\n        curr+=a[i]-1\n        count+=1\n        if curr>=m:\n            break\n    if curr>=m:\n        print(count)\n    else:\n        print(-1)","output":"nlogn"},{"instruction":"k1,k2,k3 = map(int, input().strip().split(' '))\nl=[k1,k2,k3]\nif min(k1,k2,k3)==1:\n    print('yes')\nelif l.count(2)>=2:\n    print('yes')\nelif l.count(3)==3:\n    print('yes')\nelif l.count(4)==2 and l.count(2)==1:\n    print('yes')\nelse:\n    print('no')","output":"constant"},{"instruction":"def main():\n    n, d, k = map(int, input().split())\n    _min = d+1\n\n    if n < _min:\n        print('NO')\n    else:\n        res = []\n        deg = [0] * (n+1)\n        dist = [0] * (n+1)\n\n        stack = []\n        deg[1] = 1\n        for i in range(1, d+1):\n            res.append((i, i+1))\n            if i > 1:\n                deg[i] += 2\n            dist[i] = max(i-1, d+1-i)\n        dist[d+1] = d\n        deg[d+1] = 1\n\n        for i in range(2, d+1):\n            stack.append(i)\n\n        next = d+2\n        while stack:\n            if next > n:\n                break\n            v = stack.pop()\n            if dist[v] < d:\n                while next <= n and deg[v] < k:\n                    res.append((v, next))\n                    deg[v] += 1\n                    deg[next] += 1\n                    dist[next] = dist[v] + 1\n                    if dist[next] < d:\n                        stack.append(next)\n                    next += 1\n\n        ok = next > n\n        ok &= all(deg[i] <= k for i in range(1, n+1))\n        ok &= all(dist[i] <= d for i in range(1, n+1))\n\n        if not ok:\n            print('NO')\n        else:\n            print('YES')\n            for e in res:\n                print(*e)\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\n\nans = [[0] * 55 for _ in range(55)]\n\ndef find(c: 'str') -> 'int':\n    if 'A' <= c <= 'Z':\n        return ord(c) - ord('A') + 26\n    else:\n        return ord(c) - ord('a')\n\ndef add(a: 'int', b: 'int') -> 'int':\n    a += b\n    if a >= MOD:\n        a -= MOD\n    return a\n\ndef sub(a: 'int', b: 'int') -> 'int':\n    a -= b\n    if a < 0:\n        a += MOD\n    return a\n\nfor i in s:\n    buc[find(i)] += 1\n\nfac[0] = 1\nfor i in range(1, n + 1):\n    fac[i] = (fac[i - 1] * i) % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n    inv[i] = (inv[i + 1] * (i + 1)) % MOD\n\nnum = pow(fac[n \/\/ 2], 2, MOD)\nfor i in range(0, 52):\n    num = (num * inv[buc[i]]) % MOD\n\ndp[0] = 1\n\nfor i in range(0, 52):\n    if not buc[i]:\n        continue\n    for j in range(n, buc[i] - 1, -1):\n        dp[j] = add(dp[j], dp[j - buc[i]])\n\nfor i in range(52):\n    ans[i][i] = dp[n \/\/ 2]\n\nfor i in range(52):\n    if not buc[i]:\n        continue\n    temp_dp = dp.copy()\n    for k in range(buc[i], n + 1):\n        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])\n\n    for j in range(i + 1, 52):\n        if not buc[j]:\n            continue\n        for k in range(buc[j], n + 1):\n            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])\n\n        ans[i][j] = (2 * temp_dp[n \/\/ 2]) % MOD\n\n        for k in range(n, buc[j] - 1, -1):\n            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])\n\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n    x, y = map(int, i.split())\n    l, r = find(s[x - 1]), find(s[y - 1])\n    if l > r:\n        l, r = r, l\n    print(num * ans[l][r] % MOD)","output":"cubic"},{"instruction":"S = input()\nbest = 0\nfor i in range(len(S)):\n    for j in range(i+1, len(S)+1):\n        s = S[i:j]\n        c = 0\n        for k in range(len(S)):\n            if S[k:].startswith(s): c += 1\n        if c >= 2:\n            best = max(best, len(s))\nprint(best)","output":"cubic"},{"instruction":"n, m = map(int, input().split())\nu = []\nu1 = []\nfor i in range(n):\n    u.append(list(input()))\n    u1.append(['.'] * m)\nfor i in range(n - 2):\n    for j in range(m - 2):\n        ok = True\n        for k in range(3):\n            if u[i][j + k] != '\n                ok = False\n                break\n\n        if ok:\n            if u[i + 2][j + 1] != '\n                ok = False\n            else:\n                for k in range(3):\n                    u1[i][j + k] = '\n                    u1[i + k][j] = '\n                u1[i + 2][j + 1] = '\n                u1[i + 2][j + 2] = '\n                u1[i + 1][j + 2] = '\nok = True\n\nfor i in range(n):\n    for j in range(m):\n        if u[i][j] != u1[i][j]:\n            ok = False\n            break\n    if not ok:\n        break\nif ok:\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"import sys, heapq\n\ndef binary(num):\n    left = 0\n    right = n\n    while left < right:\n        mid = (left + right) \/\/ 2\n        if arr[mid] < num:\n            left = mid + 1\n        elif arr[mid] > num:\n            right = mid\n        else:\n            return True\n    return False\n\nn = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().split()))\narr.sort()\ncnt = dict().fromkeys(set(arr), 0)\nans = 0\nfor i in arr:\n    cnt[i] += 1\nfor i in range(n):\n    now = arr[i]\n    can = False\n    for j in range(31):\n        target = pow(2, j) - now\n        if binary(target):\n            if target == now:\n                if cnt[now] >= 2:\n                    can = True\n                    break\n            else:\n                can = True\n                break\n    if not can:\n        ans += 1\nprint(ans)","output":"nlogn"},{"instruction":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        def dfs(i, flag):\n            if i == len(nums):\n                return 0 if flag else -1e6\n            if flag:\n                return max(0, nums[i] + dfs(i + 1, True))\n            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))\n        return dfs(0, False)","output":"np"},{"instruction":"n = int(input())\n\nlst = list(map(int, input().split()))\n\nevens = []\nodds = []\n\nfor e, x in enumerate(lst):\n    if x % 2 == 0:\n        evens.append(e + 1)\n    else:\n        odds.append(e + 1)\n\nif len(evens) < len(odds):\n    print(evens[0])\nelse:\n    print(odds[0])","output":"linear"},{"instruction":"import os\nfrom io import BytesIO, IOBase\nimport sys\n\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a = set(a)\n    a = list(sorted(list(a)))\n    if len(a) == 1:\n        print(\"NO\")\n    else:\n        print(a[1])\n    return\n\nBUFSIZE = 1048576\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"import bisect\nn=int(input())\ns=list(map(int,input().split()))\nc=list(map(int,input().split()))\nans=10**18\nfor mid in range(1,n-1):\n  l1=[c[i] for i in range(mid) if s[i]<s[mid]]+[10**18]\n  l2=[c[i] for i in range(mid+1,n) if s[i]>s[mid]]+[10**18]\n  ans=min(ans,min(l1)+c[mid]+min(l2))\nif ans>=10**18:\n  print(-1)\nelse:\n  print(ans)","output":"quadratic"},{"instruction":"n, s = map(int, input().split())\n\nprint((s + n - 1) \/\/ n)","output":"constant"},{"instruction":"import math;\ndef f(n,s):\n    d=[-n,-n];\n    d[s]=0\n    for i in range(y\/\/g):\n        d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"n, k = map(int, input().split())\ncount = [0] * k\nfor c in input():\n    count[ord(c) - ord(\"A\")] += 1\nprint(k * min(count))","output":"linear"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\ntracker = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor j, v in enumerate(arr):\n\ttracker[v][j] = j\n\td[j].append(j)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = tracker[v][i]\n\t\th = tracker[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\ttracker[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor tracker in d[s]:\n\t\ta[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"import math as mt\nimport sys\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\nn,m=I()\na=[I() for i in range(n)]\nans=[]\nlo=0\nhi=10**9\ndef vanguda(mid: int) -> bool:\n    global ans\n    f={}\n    for i in range(n):\n        bi=0\n        for j in range(m):\n            if a[i][j]>=mid:\n                bi+=1\n            bi<<=1\n        f[bi>>1]=i\n    for aa,bb in f.items():\n        for cc,dd in f.items():\n            if aa|cc==(2**m-1):\n                ans =bb+1,dd+1\n                return True\n    return False\n\nwhile lo<=hi:\n\tmid=(lo+hi)\/\/2\n\tif vanguda(mid):\n\t\tlo=mid+1\n\telse:\n\t\thi=mid-1\nprint(*ans)","output":"np"},{"instruction":"import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\nn, m, k1 = [int(x) for x in input().split()]\n\narr = [0 for i in range(n)]\nfor i in range(n):\n    arr[i] = [int(x) for x in input().split()]\n\nbrr = [0 for i in range(n - 1)]\nfor i in range(n - 1):\n    brr[i] = [int(x) for x in input().split()]\n\ndp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)]\n\nfor k in range(1, 21):\n    for i in range(n):\n        for j in range(m):\n                if k % 2:\n                    dp[i][j][k] = -1\n                else:\n                    dp[i][j][k] = 10 ** 9\n                    if i > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2)\n                    if i < n - 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2)\n                    if j > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2)\n                    if j < m - 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2)\n\nfor i in range(n):\n    for j in range(m):\n        print(dp[i][j][k1],end=\" \")\n    print()","output":"cubic"},{"instruction":"def main():\n    n, m = map(int,raw_input().split())\n    r = []\n    rappend = r.append\n    for i in range(1, (n >> 1) + 1):\n        for j in range(1, m + 1):\n            rappend(str(i) + ' ' + str(j))\n            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))\n    if n & 1:\n        for i in range(1, (m >> 1) + 1):\n            rappend(str((n + 1) >> 1) + ' ' + str(i))\n            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))\n        if m & 1:\n            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))\n    print('\\n'.join(r))\nmain()","output":"quadratic"},{"instruction":"a=input()\nb=input()\nc=input()\ninfo=a.split()\ninfo=list(map(int, info))\ny=b.split()\npowers=list(map(int, y))\nz=c.split()\ncoins=list(map(int, z))\nl=sorted(zip(powers,coins,range(info[0])))\nfinal=[0]*info[0]\ns=0\nw=[]\nfor _, c, i in l:\n    s+=c\n    final[i]=s\n    w=sorted(w+[c])\n    if len(w)>info[1]:\n        s-=w[0]\n        del w[0]\nprint(*final)","output":"nlogn"},{"instruction":"s = input()\nn = len(s)\n\nfor L in range(n-1, 0, -1):\n    if len({s[i:i+L] for i in range(n-L+1)}) < n-L+1:\n        print(L)\n        break\nelse:\n    print(0)","output":"cubic"},{"instruction":"val=10**9\nn,m=map(int,input().split())\narr1=[]\nfor i in range(n):\n    x=int(input())\n    arr1.append(x)\narr1.append(val)\narr2=[]\nans=val\nfinalval=0\narr1.sort()\nfor i in range(m):\n    x1,x2,y=map(int,input().split())\n    if(x1==1):\n        if(x2==val):\n            finalval+=1\n        else:\n            if(len(arr1)>0 and x2>=arr1[0]):\n                arr2.append(x2)\narr2.sort()\ni=0\nj=0\nwhile(i<len(arr1) and j<len(arr2)):\n    if(arr1[i]>arr2[j]):\n        j+=1\n    elif(arr1[i]==arr2[j]):\n        temp1=len(arr2)-j\n\n        ans=min(i+temp1,ans)\n        i+=1\n    else:\n        temp1=len(arr2)-j\n\n        ans=min(i+temp1,ans)\n        i+=1\n\nans=min(i,ans)\nprint(ans+finalval)","output":"nlogn"},{"instruction":"n = int(input())\nl = list(map(int, input().split(\" \")))\nl2 = list(map(int, input().split(\" \")))\ndp_1 = l2.copy()\ndp_2 = [9999999999]*n\ndp_3 = [9999999999]*n\nfor i in range(1, n):\n    for j in range(i):\n        if l[i] > l[j]:\n            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])\n\n    for j in range(i):\n        if l[i] > l[j]:\n            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])\n\nx = min(dp_3)\nif x == 9999999999:\n    print(-1)\nelse:\n    print(x)","output":"quadratic"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k\/2+1))\n\n  def solve(node, remain):\n    if remain == 0:\n      return 0\n\n    key = (node + remain * n * m)\n    mem = dp[key]\n    if mem != -1:\n      return mem\n\n    ans = min(map(lambda x: solve(x[0], remain-1) + x[1], adj[node]))\n    dp[key] = ans\n    return ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k\/2) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        leftHeight = self.maxHeight(root.left)\n        rightHeight = self.maxHeight(root.right)\n        diameter = leftHeight + rightHeight\n        sub = max(self.diameterOfBinaryTree(root.left),\n                  self.diameterOfBinaryTree(root.right))\n        return max(diameter, sub)\n\n    def maxHeight(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxHeight(root.left), self.maxHeight(root.right))","output":"quadratic"},{"instruction":"from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n - 1)]\nif k % 2:\n    ans = [-1] * m\n    for _ in range(n):\n        print(*ans)\n    exit()\n\nG = [[] for _ in range(n * m + 1)]\nfor i in range(n):\n    a0 = a[i]\n    for j in range(m - 1):\n        x = a0[j]\n        G[i * m + j].append((i * m + j + 1, x))\n        G[i * m + j + 1].append((i * m + j, x))\n\nfor i in range(n - 1):\n    b0 = b[i]\n    for j in range(m):\n        x = b0[j]\n        G[i * m + j].append(((i + 1) * m + j, x))\n        G[(i + 1) * m + j].append((i * m + j, x))\n\ndp = [[0] * m for _ in range(n)]\ndp0 = [[0] * m for _ in range(n)]\ndp, dp0 = [0] * (n * m), [0] * (n * m)\nv = [(1, 0), (-1, 0), (0, 1), (0, -1)]\ninf = 1145141919\nfor i in range(n):\n    for j in range(m):\n        s = i * m + j\n        dps = inf\n        for t, x in G[s]:\n            dps = min(dps, 2 * x)\n        dp[s] = dps\n        dp0[s] = dps\nfor _ in range((k - 2) \/\/ 2):\n    dp1 = [0] * (n * m)\n    for i in range(n):\n        for j in range(m):\n            s = i * m + j\n            dps = dp0[s] + 2 * dp[s]\n            for t, x in G[s]:\n                dps = min(dps, 2 * x + dp0[t])\n            dp1[s] = dps\n    dp0 = dp1\nfor i in range(n):\n    ans = dp0[(m * i):(m * (i + 1))]\n    print(*ans)","output":"cubic"},{"instruction":"ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n\nfrom math import log\nl,r=kk()\ni=msb = int(max(log(l,2),log(r,2)))\nwhile ((2**i)&l) == ((2**i)&r):\n\ti-=1\n\tif i == -1:\n\t\tbreak\ni+=1\nprint(2**i-1)","output":"logn"},{"instruction":"q = int(input())\n\nfor i in range(q):\n    n,k = map(int,input().split())\n    if n > 31:\n        print(\"YES\",n-1)\n        continue\n    a = [0]\n    for i in range(1,n+1):\n        a.append(a[i-1]*4+1)\n    if a[n] < k:\n        print(\"NO\")\n        continue\n    if n == 2 and k == 3:\n        print(\"NO\")\n        continue\n    p = 0\n    q = 2\n    while p+q-1 <= k and n > 0:\n        p += q-1\n        q *= 2\n        n -= 1\n    print(\"YES\",n)","output":"logn"},{"instruction":"s = input()\nn = len(s)\nm = n - 1;\nwhile m > 0:\n    find = False\n    for i in range(0, n - m):\n        for j in range(i + 1, n - m + 1):\n            match = True\n            for k in range(0, m):\n                if s[i+k] != s[j+k]:\n                    match = False\n                    break\n            if match:\n                find = True\n                break\n        if find:\n            break\n    if find:\n        break\n    m -= 1\nprint(m)","output":"cubic"},{"instruction":"import math\n\ninp = input().strip()\ndec = input().strip()\ninp_dict = {\"+\":0,\"-\":0}\ndec_dict = {\"+\":0,\"-\":0,\"?\":0}\n\nfor i in range(len(inp)):\n\tif inp[i]==\"+\":\n\t\tinp_dict[\"+\"] += 1\n\telif inp[i]==\"-\":\n\t\tinp_dict[\"-\"] += 1\n\nfor i in range(len(dec)):\n\tif dec[i]==\"+\":\n\t\tdec_dict[\"+\"] += 1\n\telif dec[i]==\"-\":\n\t\tdec_dict[\"-\"] += 1\n\telif dec[i] == \"?\":\n\t\tdec_dict[\"?\"] += 1\n\nif(dec_dict[\"+\"] == inp_dict[\"+\"] and dec_dict[\"-\"] == inp_dict[\"-\"]):\n\tprint(1.0000000000)\nelse:\n\ttemp = inp_dict[\"+\"] - dec_dict[\"+\"]\n\ttemp1 = inp_dict[\"-\"] - dec_dict[\"-\"]\n\n\tif temp + temp1 == dec_dict[\"?\"] and temp>=0 and temp1 >= 0:\n\t\ttemp2 = math.factorial(temp+temp1)\/(math.factorial(temp)*math.factorial(temp1))\n\t\tfor i in range(temp1+temp):\n\t\t\ttemp2 = temp2 * 0.5\n\t\tprint(temp2)\n\telse:\n\t\tprint(0.000000000)","output":"np"},{"instruction":"from collections import deque\nimport heapq\nimport sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\nn, T = map(int, input().split())\nproblems = [tuple(map(int, input().split())) for i in range(n)]\n\ndef possible(K):\n    d = []\n    for a, t in problems:\n        if a >= K:\n            d.append(t)\n    d.sort()\n    if len(d) < K:\n        return False\n    else:\n        return sum(d[:K]) <= T\n\nl = 0\nr = n + 1\nwhile r - l > 1:\n    med = (r + l)\/\/2\n    if possible(med):\n        l = med\n    else:\n        r = med\nprint(l)\nprint(l)\nd = []\nfor i, (a, t) in enumerate(problems):\n    if a >= l:\n        d.append((t, i+1))\nd.sort(key=lambda x: x[0])\nans = [v[1] for v in d[:l]]\nprint(*ans)","output":"nlogn"},{"instruction":"for TT in range(1, int(input()) + 1):\n    n = int(input())\n    l = sorted(map(int, input().split()))\n    k = max(0, min(n - 2, l[-2] - 1))\n    print(k)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\nprint(\"YES\")\nfor i in range(n):\n    print(\".\", end = '')\nprint()\nif k&1:\n    if k <= n-2:\n        tmp = (n-k)>>1\n        for i in range(tmp):\n            print(\".\", end = '')\n        for i in range(k):\n            print(\"\n        for i in range(tmp):\n            print(\".\", end = '')\n        print()\n        for i in range(n):\n            print(\".\", end = '')\n        print()\n    else:\n        print(\".\", end = '')\n        for i in range(n-2):\n            print(\"\n        print(\".\")\n        k -= n-2\n        print(\".\", end = '')\n        for i in range(k>>1):\n            print(\"\n        for i in range(n-k-2):\n            print(\".\", end = '')\n        for i in range(k>>1):\n            print(\"\n        print(\".\")\nelse:\n    k = k>>1\n    for j in range(2):\n        print(\".\", end = '')\n        for i in range(k):\n            print(\"\n        for i in range(n-k-1):\n            print(\".\", end = '')\n        print()\nfor i in range(n):\n    print(\".\", end = '')\nprint()","output":"linear"},{"instruction":"n = int(input())\na = {}\nans = 0\nsum = 0\ni = 0\nfor t in map(int, input().split()):\n    sum += t\n    a[t] = a.get(t, 0) + 1\n\n    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))\n    i += 1\n\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input())\na = sorted(list(map(int, input().split())))\ntmp = 0\nif a.count(0) > 1:\n    print('cslnb')\n    exit()\nif n - len(set(a)) > 1:\n    print('cslnb')\n    exit()\nif n == 1:\n    print('cslnb' if not a[0] % 2 else 'sjfnb')\n    exit()\nif n - len(set(a)) == 1:\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            if a[i] - 1 in a:\n                print('cslnb')\n                exit()\n            break\nfor i in range(n):\n    tmp += a[i] - i\nprint('cslnb' if not tmp % 2 else 'sjfnb')","output":"nlogn"},{"instruction":"from itertools import combinations\n\n[n,l,r,x] = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nc.sort()\nk = 0\n\nfrom itertools import combinations\n\nfor i in range(n) :\n\tfor j in range(i+1,n) :\n\t\tif ( c[j] - c[i] ) >= x :\n\t\t\tif sum(c[i:j+1]) < l :\n\t\t\t\tcontinue\n\t\t\telif  (c[i] + c[j]) > r :\n\t\t\t\tcontinue\n\t\t\telse :\n\t\t\t\tif (c[i] + c[j]) >= l and (c[i] + c[j]) <= r :\n\t\t\t\t\tk += 1\n\t\t\t\tfor p in range(1,j-i) :\n\t\t\t\t\tfor m in combinations(c[i+1:j],p) :\n\t\t\t\t\t\tif (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r :\n\t\t\t\t\t\t\tk+=1\n\nprint(k)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\n\nfrom collections import deque\n\nn,d,k=map(int,input().split())\n\nif d>=n:\n    print(\"NO\")\n    exit()\n\ngraph=[[] for i in range(n+1)]\n\nfor i in range(1,d+2):\n    graph[i].append(min(i-1,d+1-i))\n\nfor i in range(1,d+1):\n    graph[i].append(i+1)\n    graph[i+1].append(i)\n\ndeg=[0]*(n+1)\ndeg[1]=1\ndeg[d+1]=1\nfor i in range(2,d+1):\n    deg[i]=2\n\nfor i in deg:\n    if i>k:\n        print(\"NO\")\n        exit()\n\np=d+2\nfor i in range(1,d+2):\n    q=deque()\n    q.append(i)\n    while len(q)!=0:\n        x=q.popleft()\n        while (graph[x][0]>0 and deg[x]<k and p<=n):\n            graph[x].append(p)\n            deg[x]=deg[x]+1\n            graph[p].append(graph[x][0]-1)\n            graph[p].append(x)\n            deg[p]=deg[p]+1\n            q.append(p)\n            p=p+1\n\nif p<=n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    vis=[-1]*(n+1)\n\n    for i in range(1,d+2):\n        if vis[i]==-1:\n            q=deque()\n            q.append(i)\n            while len(q)!=0:\n                x=q.popleft()\n                vis[x]=1\n                for j in range(1,len(graph[x])):\n                    if vis[graph[x][j]]==-1:\n                        print(x,graph[x][j])\n                        q.append(graph[x][j])","output":"quadratic"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n = int(input())\n    a = [0]+list(map(int,input().split()))\n    dp = [[[-1,-1,-1] for _ in range(n+1)]for _ in range(n+1)]\n\n    for i in range(1,n+1):\n        dp[i][i] = (a[i],a[i],1)\n    for i in range(n-1,0,-1):\n        for j in range(i+1,n+1):\n            mini = 10**10\n            for k in range(j-i):\n                x = dp[i][i+k][2]+dp[i+k+1][j][2]\n                if dp[i][i+k][1] == dp[i+k+1][j][0]:\n                    if mini > x-1:\n                        mini = x-1\n                        dp[i][j][0] = dp[i][i+k][0]+(dp[i][i+k][2]==1)\n                        dp[i][j][1] = dp[i+k+1][j][1]+(dp[i+k+1][j][2]==1)\n                        dp[i][j][2] = x-1\n                else:\n                    if mini > x:\n                        mini = x\n                        dp[i][j][0] = dp[i][i+k][0]\n                        dp[i][j][1] = dp[i+k+1][j][1]\n                        dp[i][j][2] = x\n    print(dp[1][n][2])\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n = int(input())\nb = list(map(int, input().split()))\na = [0] * (2 * (len(b)))\na[-1] = b[0]\nfor i in range(1, len(b)):\n    if b[i] - a[i - 1] <= a[-i]:\n        a[i] = a[i - 1]\n        a[-i - 1] = b[i] - a[i - 1]\n    else:\n        a[-i - 1] = a[-i]\n        a[i] = b[i] - a[-i - 1]\nprint(*a)","output":"linear"},{"instruction":"n = int(input())\na = []\nfor i in range(1, n + 1):\n    l, r = map(int, input().split())\n    a.append([l, -r, i])\na.sort()\nhh = a[0][1]\nwahh = max(-1, a[0][2])\nfor i in range(1, n):\n    if a[i][1] >= hh:\n        print(a[i][2], wahh)\n        exit()\n    else:\n        hh = a[i][1]\n        wahh = a[i][2]\nprint(-1, -1)","output":"nlogn"},{"instruction":"s = input()\nl = list(map(int,input().split()))\nl.sort(reverse = True)\ns = sum(l)\nx = 0\nc = 0\nfor i in l:\n    if x <= s:\n        c+=1\n        x+=i\n        s-=i\n    else:\n        break\nprint(c)","output":"nlogn"},{"instruction":"from itertools import combinations\nn, l, r, x = map(int,input().split())\na = list(map(int,input().split()))\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))","output":"np"},{"instruction":"n = int(input())\n\nstring = input()\ni = 0\nj = 0\ntotal = 0\n\nwhile j < len(string):\n    bool = False\n    count = 0\n    while j < len(string) and string[i] == 'x' and string[j] == 'x':\n        count += 1\n        bool = True\n        j += 1\n\n    if count >= 3:\n        total += (count-3)+1\n    if bool:\n        i = j\n    else:\n        i += 1\n        j += 1\n\nprint(total)","output":"linear"},{"instruction":"from collections import Counter\n\nn, k = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nf = [int(x) for x in input().split()]\nh = [0] + [int(x) for x in input().split()]\n\ncnt_all = Counter(c)\ncnt_fav = Counter(f)\n\nans = 0\nfor fi in cnt_fav:\n    if fi not in cnt_all:\n        continue\n    m = cnt_fav[fi]\n    t = min(cnt_all[fi], m * k)\n    dp = [[0] * (t + 1) for _ in range(m + 1)]\n    for x in range(1, m + 1):\n        for s in range(0, t + 1):\n            for ki in range(0, k + 1):\n                if ki + s > t:\n                    break\n                dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki])\n    ans += dp[m][t]\nprint(ans)","output":"cubic"},{"instruction":"string=input()\nn=len(string)\ncheck=True\nfor sub_len in range(n-1,0,-1):\n    for starting_index in range(n-sub_len+1):\n        if string[starting_index:starting_index+sub_len] in string[starting_index+1:]:\n            print(sub_len)\n            check=False\n            break\n    if check==False:\n        break\nif check:\n    print(0)","output":"cubic"},{"instruction":"from math import factorial\ns = input().strip()\nnew = input().strip()\nquestions = 0\nplus = s.count('+')\nminus = s.count('-')\nfor i in new:\n\tif i == '+':\n\t\tplus -= 1\n\telif i == '-':\n\t\tminus -= 1\n\telse:\n\t\tquestions += 1\nif plus < 0 or minus < 0:\n\tprint(0)\nelse:\n\tnum = factorial(questions)\/(factorial(plus)*factorial(minus))\n\tden = 2**questions\n\tprint(\"{0:.10f}\".format(num\/den))","output":"np"},{"instruction":"from math import sqrt\nfor _ in ' '*int(input()):\n    n = int(input())\n    if int(sqrt(n\/2)) == sqrt(n\/2) or int(sqrt(n\/4)) == sqrt(n\/4):\n        print(\"YES\")\n    else: print(\"NO\")","output":"constant"},{"instruction":"n=int(input())\nxw=[list(map(int,input().split())) for _ in [0]*n]\n\nab=sorted([[x-w,x+w] for x,w in xw],key=lambda x:(x[1],x[0]))\n\nk=ab[0][0]\ncnt=0\nfor a,b in ab:\n    if k<=a:\n        cnt+=1\n        k=b\n\nprint(cnt)","output":"nlogn"},{"instruction":"t=int(input())\nfor _ in range(t):\n  n,k=map(int,input().split())\n  if n==2 and k==3:\n    print('NO')\n    continue\n  if n<=100:\n    curr=0\n    for j in range(n):\n      curr+=pow(4,j)\n    if curr<k:\n      print('NO')\n      continue\n  curr=0\n  ans=0\n  while curr<k and ans<n:\n    ans+=1\n    curr+=pow(2,ans)-1\n  if curr>k:\n    ans-=1\n  print('YES',n-ans)","output":"logn"},{"instruction":"from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n\ndef read(): return list(map(int, input().strip().split()))\n\nans_ = []\n\nt_p = [2**i for i in range(31)]\nn = int(input());\narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [list(arr.keys())[0]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = (arr[a] > 0) + (arr[b] > 0) + (arr[c] > 0)\n        if s > m:\n            m = s\n            ans_lis = [x for x in [a, b, c] if arr[x]]\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i)+\" \")\nans_.append(t)\n\nfor i in ans_:\n    print(i)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nV = []\nfor i in range(n):\n    V.append(int(input()))\nV.sort()\nV.append(10 ** 9)\nn += 1\nX2 = []\nfor i in range(m):\n    x1, x2, y = map(int, input().split())\n    if x1 == 1:\n        X2.append(x2)\nX2.sort()\nk = len(X2)\ni = 0\nj = 0\nans = 10 ** 9 + 7\nc = 0\n\nwhile i < n:\n    while j < k:\n        if X2[j] < V[i]:\n            c += 1\n            j += 1\n        else:\n            break\n    ans = min(ans,  k - c + i)\n    i += 1\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin\n\nn = int(stdin.readline())\n\np = [int(x)-1 for x in stdin.readline().split()]\n\nvisited = [False for x in range(n)]\n\nloops = []\n\nfor x in range(n):\n    if not visited[x]:\n        visited[x] = True\n        start = x\n        l = [x]\n        cur = p[x]\n        while cur != start:\n            visited[cur] = True\n            l.append(cur)\n            cur = p[cur]\n        loops.append(len(l)-1)\n\ntot = sum(loops)\n\nif n % 2 == 1:\n    if tot % 2 == 1:\n        print('Petr')\n    else:\n        print('Um_nik')\nelse:\n    if tot % 2 == 0:\n        print('Petr')\n    else:\n        print('Um_nik')","output":"nlogn"},{"instruction":"def prime2(n):\n    cont = 0\n    flag = True\n    while flag:\n        if n % 2 == 0:\n            cont += 1\n            n = n\/2\n        else:\n            flag = False\n    if n % 4 == 1:\n        return [cont, \"L\"]\n    else:\n        return [cont, \"R\"]\n\ndef arrivo(n,start,char):\n    for i in char:\n        if (i == \"L\" or i == \"R\") and start % 2 == 1:\n            pass\n        elif (i == \"U\") and 2*start == n+1:\n            pass\n        else:\n            [power, direc] = prime2(start)\n            if i == \"L\":\n                start -= 2 ** (power - 1)\n            elif i == \"R\":\n                start += 2 ** (power - 1)\n            else:\n                if direc == \"L\":\n                    start += 2 ** power\n                else:\n                    start -= 2 ** power\n    return start\n\nif __name__ == '__main__':\n    [n,q] = map(int, raw_input().rstrip().split())\n    for i in range(q):\n        start = int(input())\n        char = raw_input()\n        print(arrivo(n,start,char))","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nb = []\nfor i in range(n):\n    a[i] %= 2\n    if len(b) != 0:\n        if b[-1] == a[i]:\n            b.pop()\n        else:\n            b.append(a[i])\n    else:\n        b.append(a[i])\nif len(b) > 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"linear"},{"instruction":"k, n, s, p = map(int, input().split())\n\nsheets = (n + s - 1) \/\/ s\n\nprint((sheets * k + p - 1) \/\/ p)","output":"constant"},{"instruction":"l,r=map(int,input().split())\nj=r-l+1\n\nif j==3:\n\tif l%2==0:\n\t\tprint(l,l+1,l+2)\n\telse:\n\t\tprint(-1)\nelif j>3:\n\tif l%2==0:print(l,l+1,l+2)\n\telse:print(l+1,l+2,l+3)\nelse:print(-1)","output":"constant"},{"instruction":"import os\nimport sys\nimport time\nfrom io import BytesIO, IOBase\n\ndef main():\n    max_int = 10 ** 9\n    d = ((1, 0), (-1, 0), (0, 1), (0, -1))\n    n, m, k = li_input()\n    H = []\n    for i in range(n):\n        H.append(li_input() + [max_int])\n\n    V = []\n    for i in range(n - 1):\n        V.append(li_input())\n\n    V.append([max_int] * m)\n\n    if k % 2:\n        for i in range(n):\n            print(' '.join(['-1'] * m))\n        return\n\n    k \/\/= 2\n\n    DP0 = [[0] * (m + 1) for _ in range(n + 1)]\n    DP1 = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for kk in range(k):\n        for i in range(n):\n            for j in range(m):\n                l = DP0[i][j - 1] + H[i][j - 1]\n                r = DP0[i][j + 1] + H[i][j]\n                u = DP0[i - 1][j] + V[i - 1][j]\n                d = DP0[i + 1][j] + V[i][j]\n                DP1[i][j] = min(l, r, u, d)\n\n        DP0, DP1 = DP1, DP0\n\n    O = []\n    for row in DP0[:-1]:\n        O.append(' '.join((str(n * 2) for n in row[:-1])))\n\n    print('\\n'.join(O))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input():\n    return sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef i_input():\n    return int(input())\n\ndef l_input():\n    return input().split()\n\ndef li_input():\n    return list(map(int, l_input()))\n\ndef il_input():\n    return list(map(int, l_input()))\n\nif __name__ == \"__main__\":\n    TT = time.time()\n    main()","output":"cubic"},{"instruction":"from sys import stdout\n\nn = int(input())\n\nif n % 4 == 2:\n    print('!', -1)\n    exit(0)\n\nl = 1\nr = l + n \/\/ 2\n\nmemo = [-1] * (n + 1)\n\ndef check(i):\n    if memo[i] == -1:\n        print('?', i)\n        stdout.flush()\n\n        memo[i] = int(input())\n\n    return memo[i]\n\nwhile r >= l:\n    a = check(l)\n    b = check(l + n \/\/ 2)\n\n    if a == b:\n        print('!', l)\n        exit(0)\n\n    mid = (l + r) >> 1\n\n    c = check(mid)\n    d = check(mid + n \/\/ 2)\n\n    if c == d:\n        print('!', mid)\n        exit(0)\n\n    if (a < b and c < d) or (a > b and c > d):\n        l = mid + 1\n\n    else:\n        r = mid","output":"logn"},{"instruction":"A = list(map(int, input().split()))\n\nans = 0\nfor i in range(14):\n    if A[i] == 0:\n        continue\n    B = A+A\n    B[i+14] = 0\n    q, r = divmod(B[i], 14)\n    for j in range(1, 15):\n        if j <= r:\n            B[i+j] += (q+1)\n        else:\n            B[i+j] += q\n\n    temp = 0\n    for j in range(i+1, i+15):\n        if B[j]%2 == 0:\n            temp += B[j]\n    ans = max(ans, temp)\nprint(ans)","output":"constant"},{"instruction":"n=int(input())\na=[int(i) for i in input().split()]\na.sort()\ntot = 0\nd={}\nfor i in range(len(a)):\n    if a[i] not in d:\n        tot+=1\n        for j in range(i+1,len(a),1):\n            if a[j]%a[i] == 0:\n                d[a[j]]=1\nprint(tot)","output":"quadratic"},{"instruction":"def somadig(x):\n    soma = 0\n    while x>0:\n        soma += x%10\n        x = x\/\/10\n    return soma\n\ndef main():\n    x,s = map(int,input().split())\n\n    comeco = 9\n    fim = x\n    if comeco >= fim:\n        print(0)\n        return\n    while fim>=comeco:\n        meio = (fim+comeco)\/\/2\n        if meio - somadig(meio) >= s:\n            if (meio-1) - somadig(meio-1)<s:\n                print(x-(meio-1))\n                return\n            fim = meio-1\n        else:\n            comeco = meio+1\n    print(0)\n    return\n\nmain()","output":"logn"},{"instruction":"n = int(input())\n\nprint(n\/\/2 + 1)","output":"constant"},{"instruction":"from collections import deque\n\nn, m, k = map(int, input().split())\na = deque([int(i) for i in input().split()])\n\noper = 0\nrem = 0\nwhile a:\n    x = a.popleft()\n    pg = (x - 1 - rem) \/\/ k\n    lrem = 1\n    while a and (a[0] - 1 - rem) \/\/ k == pg:\n        a.popleft()\n        lrem += 1\n    rem += lrem\n    oper += 1\nprint(oper)","output":"linear"},{"instruction":"n,m = map(int,input().split())\nfor _ in range(m):\n    x,y = map(int,input().split())\n\ncnt = 0\nans = []\nfor i in range(n):\n    if cnt%2 == 0:\n        ans.append(\"0\")\n\n    else:\n        ans.append(\"1\")\n\n    cnt += 1\n\nprint(\"\".join(ans))","output":"linear"},{"instruction":"n,k = map(int,input().split())\na = list(map(int,input().split()))\n\nif k == 1:\n    print(max(a) - min(a))\n    exit()\n\ndif = []\nfor i in range(n - 1):\n    dif.append(a[i + 1] - a[i])\ndif = sorted(dif)\nprint(sum(dif[:-k + 1]))","output":"nlogn"},{"instruction":"import heapq\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nindexes = sorted(list(range(n)), key=p.__getitem__)\nmost_vyg_odn_yye = []\nres = [1]*n\ncur_res = 0\nfor ind in indexes:\n\tthis_cost = c[ind]\n\theapq.heappush(most_vyg_odn_yye, this_cost)\n\tcur_res += this_cost\n\tres[ind] = cur_res\n\tif len(most_vyg_odn_yye) > k:\n\t\tcur_res -= heapq.heappop(most_vyg_odn_yye)\nprint(*res)","output":"nlogn"},{"instruction":"def A(n):\n\treturn (4**n-1)\/\/3\n\nL = 31\n\nT = int(input())\nfor _ in range(T):\n\tn,k = [int(_) for _ in input().split()]\n\n\tif n > L:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\n\tif k > A(n):\n\t\tprint(\"NO\")\n\t\tcontinue\n\n\tE = 1\n\tM = 0\n\tR = 0\n\twhile n >= 0:\n\t\tM += E\n\n\t\tI = 2*E-1\n\t\tE = 2*E+1\n\n\t\tn -= 1\n\t\tR += I*A(n)\n\n\t\tif M <= k and k <= M+R: break\n\n\tif n >= 0: print(\"YES\",n)\n\telse: print(\"NO\")","output":"logn"},{"instruction":"def sum(l):\n    s=0\n    for i in range(len(l)):\n        s+=l[i]\n    return s\n\nn=int(input())\ncns=list(map(int,input().split()))\nxs,nm,c=0,0,0\ncns.append(0)\nwhile(xs<=nm):\n    m=max(cns)\n    cns.remove(m)\n    xs+=m\n    nm=sum(cns)\n    c+=1\nprint(c)","output":"nlogn"},{"instruction":"n = int(input())\nA = [0] + list(map(int,input().split()))\n\nvec = []\nfor i in range(1, n+1) :\n\tvec = vec + [[A[i], i]]\nlist.sort(vec)\nlist.reverse(vec)\n\nif vec[0][0] == 1 :\n\tprint(\"NO\")\n\texit(0)\n\ndia = 0\npath = [vec[0][1]]\nans = []\nbol, col, idx = 1, 1, 0\nfor i in vec[1:] :\n\n\tif i[0] != 1 :\n\t\tans = ans + [[path[-1], i[1]]]\n\t\tdia = dia+1\n\t\tA[path[-1]] = A[path[-1]]-1\n\t\tpath += [i[1]];\n\t\tA[path[-1]] = A[path[-1]]-1\n\telse :\n\t\tif col == 1:\n\t\t\tdia = dia+1\n\t\t\tcol = 0\n\t\t\tA[path[0]] -= 1\n\t\t\tans = ans+ [[path[0], i[1]]]\n\t\telif bol == 1:\n\t\t\tdia = dia+1\n\t\t\tbol = 0\n\t\t\tA[path[-1]] -= 1\n\t\t\tans = ans + [[path[-1], i[1]]]\n\t\telse :\n\t\t\twhile idx < len(path) and A[path[idx]] == 0 :\n\t\t\t\tidx = idx+1\n\t\t\tif idx == len(path) :\n\t\t\t\tprint(\"NO\")\n\t\t\t\texit(0)\n\t\t\tA[path[idx]] = A[path[idx]] - 1;\n\t\t\tans = ans + [[path[idx], i[1]]]\n\nprint(\"YES\", dia)\nprint(len(ans))\nfor i in ans :\n\tprint(i[0], i[1])","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nif n>=k:\n    print((k-1)\/\/2)\nelif n*2>k:\n    print(n-k\/\/2)\nelse:\n    print(0)","output":"constant"},{"instruction":"n, k = [int(num) for num in input().split(' ')]\nstring = input()\n\ndef fn(string, k):\n    maximum_match = 0\n    for i in range(1, len(string)):\n        if string[:i] == string[-i:]:\n            maximum_match = i\n\n    answer = list(string)\n    extra = list(string[maximum_match:])\n    for i in range(k-1):\n        answer.extend(extra)\n\n    return ''.join(answer)\n\nprint(fn(string, k))","output":"quadratic"},{"instruction":"mod=10**9+7\nn=int(input())\nl=[]\nc=0\nfor i in range(n):\n    l.append(input())\ndp=[[0]*(n+2) for i in range(n+1)]\nfor i in range(n+2):\n    dp[n][i]=1\nfor i in range(n-1,0,-1):\n    s=0\n    for j in range(n+1):\n        s+=dp[i+1][j]\n        s%=mod\n        if l[i-1]=='f':\n            dp[i][j]=dp[i+1][j+1]\n        else:\n            dp[i][j]=s\n\nprint(dp[1][0])","output":"quadratic"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, i * 2 + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)","output":"np"},{"instruction":"n,k = map(int,input().split())\n\ndef sumTillN (n) :\n    return (n*(n+1))\/\/2\n\nminEat = 0\nmaxEat = n\nmidEat = 0\n\nwhile (minEat<=maxEat):\n    midEat = (minEat+maxEat)\/\/2\n    x = sumTillN(n-midEat)\n    if (x==k+midEat):\n        break\n    elif (x>k+midEat):\n        minEat = midEat+1\n    else:\n        maxEat = midEat-1\n\nprint(midEat)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    s = list(input().rstrip())\n    t = input().rstrip()\n    ok = False\n    for i in range(len(t)):\n        t1 = list(t[:i]) + [\"\n        t2 = list(t[i:]) + [\"\n\n        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 0\n        for j, ch in enumerate(s):\n            for k in range(len(t1)):\n                if dp[j][k] == -1:\n                    continue\n                dp[j+1][k] = max(dp[j+1][k], dp[j][k])\n                if ch == t1[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])\n                if ch == t2[dp[j][k]]:\n                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)\n        for k in range(len(t) + 1):\n            if dp[len(s)][k] + k >= len(t):\n                ok = True\n\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"def sum(n):\n    return (n * (n + 1)) \/\/ 2\n\ndef range_sum(left, right):\n    return sum(right) - sum(left - 1)\n\ndef binary_search(k, n):\n    low, high, mid = 1, k, 0\n\n    while low <= high:\n        mid = (low + high) \/\/ 2\n        s = range_sum(mid, k)\n\n        if s == n:\n            return k - mid + 1\n        elif s > n:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return k - low + 2\n\nn, k = map(int, input().split(' '))\nif n == 1:\n    print(0)\nelif n <= k:\n    print(1)\nelse:\n    n -= 1\n    k -= 1\n\n    if n > sum(k):\n        print(-1)\n    else:\n        print(binary_search(k, n))","output":"logn"},{"instruction":"k={}\ns=0\n\nfor i in range(int(input())):\n\ta,x=map(int,input().split())\n\tk[a]=x\n\nfor j in range(int(input())):\n\tb,y=map(int,input().split())\n\tif b in k:\n\t\tk[b]=max(k[b],y)\n\n\telse:\n\t\tk[b]=y\ns=0\nfor h in k.values():\n\n\ts+=h\nprint(s)","output":"nlogn"},{"instruction":"m, a = map(int, input().split())\nif (a % m == 0):\n    print(a \/\/ m)\nelse:\n    print(a\/\/m + 1)","output":"constant"},{"instruction":"n = int(input())\nif n == 0:\n    print(0, 0, 0)\nelse:\n    a, b = 0, 1\n    while a + b != n:\n        a, b = b, a + b\n    print(0, a, b)","output":"constant"},{"instruction":"o=int(input())\nuk=[]\ngh=0\nuo=0\nfor i in range(o):\n    yu=input()\n    if(len(yu)>gh):\n        gh=len(yu)\n        uo=i\n    uk.append(yu)\n\nyk=0\nyj={}\n\ntd=0\nuk.sort()\nfor i in range(len(uk)-1):\n    for j in range(i+1,len(uk)):\n        if(len(uk[j])<len(uk[i])):\n            t=uk[j]\n            uk[j]=uk[i]\n            uk[i]=t\nfor i in range(1,len(uk)):\n    j=i\n    while(j>=0):\n        if(uk[i].count(uk[j])==0):\n            td=1\n        j=j-1\nif(td==0):\n    print('YES')\n    for i in uk:\n        print(i)\nelse:\n    print('NO')","output":"nlogn"},{"instruction":"def solve():\n    n, k = map(int, input().split())\n    c = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    cnt = {}\n    for i in c:\n        cnt[i] = cnt.get(i, 0) + 1\n    likecolor = {}\n    for i in range(n):\n        likecolor.setdefault(f[i], []).append(i)\n        cnt[f[i]] = cnt.get(f[i], 0)\n    ans = 0\n    for key, v in likecolor.items():\n        n1 = len(v)\n        if cnt[key] >= n1 * k:\n            ans += n1 * h[k - 1]\n            continue\n        dp = [[-float(\"INF\")] * (cnt[key]+1) for _ in range(n1 + 1)]\n        dp[0][0] = 0\n        for i in range(n1):\n            j = i + 1\n            for e in range(cnt[key] + 1):\n                dp[j][e] = max(dp[j][e], dp[i][e])\n                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):\n                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])\n        ans += dp[n1][cnt[key]]\n    print(ans)\n\nsolve()","output":"cubic"},{"instruction":"from sys import stdin, gettrace\n\nif not gettrace():\n    def input():\n        return next(stdin)[:-1]\n\nINF = 10000\n\ndef main():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n\n    dp = [[0] * (n+1) for _ in range(n)]\n\n    def calc_dp(i, j):\n        if i + 1 == j:\n            dp[i][j] = aa[i]\n        if dp[i][j] != 0:\n            return dp[i][j]\n        dp[i][j] = -1\n        for k in range(i+1, j):\n            lf = calc_dp(i, k)\n            rg = calc_dp(k, j)\n            if lf > 0 and lf == rg:\n                dp[i][j] = lf + 1\n                break\n        return dp[i][j]\n\n    dp2 = list(range(0,n+1))\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if calc_dp(i, j) > 0:\n                dp2[j] = min(dp2[j], dp2[i] + 1)\n    print(dp2[n])\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"from math import ceil, sqrt\n\nt = 1\nfor test in range(1,t+1):\n    n,m = (map(int, input().split()))\n    arr = [[\".\" for i in range(m)] for i in range(n)]\n    arr2 = []\n    for i in range(n):\n        arr2.append(list(input()))\n    for i in range(1,n-1):\n        for j in range(1,m-1):\n            if arr2[i+1][j] == arr2[i][j+1]==arr2[i+1][j+1]==arr2[i-1][j]==arr2[i][j-1]==arr2[i-1][j-1]==arr2[i+1][j-1]==arr2[i-1][j+1]==\"\n                arr[i+1][j] = arr[i][j+1]=arr[i+1][j+1]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]=arr[i+1][j-1]=arr[i-1][j+1]=\"\n\n    if arr == arr2:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"quadratic"},{"instruction":"from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn,m=zzz()\narr = zzz()\ns = sum(arr)\nidx = [[] for i in range(m)]\nfor i in range(n):\n    idx[arr[i]%m].append(i)\n\nj=0\nfor i in range(m):\n    while len(idx[i])>n\/\/m:\n        while True:\n            if j<i:j+=1\n            elif len(idx[j%m])>=n\/\/m:\n                j+=1\n            else:break\n        last = idx[i].pop()\n        arr[last]+=(j-i)%m\n        idx[j%m].append(last)\nprint(sum(arr)-s)\nprint(*arr)","output":"linear"},{"instruction":"n, values, wrong = int(input()), [int(i) for i in input().split()], 0\nsorted_values = list(sorted(values))\nfor i in range(n):\n    if values[i] != sorted_values[i]:\n        wrong += 1\nif wrong > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n\nn,k=kk()\npre,post = [],[]\nk-=1\nv = 1\nfor i in range(n-2,-1,-1):\n\tif k&(2**i):\n\t\tpost.append(v)\n\telse:\n\t\tpre.append(v)\n\tv+=1\nprint(*pre,n,*reversed(post))","output":"np"},{"instruction":"import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        n, m = map(int, input().strip().split())\n\n        y = 0\n        for _ in range(m):\n            x, d = map(int, input().strip().split())\n            if d >= 0:\n                y += d * (n - 1) * n \/\/ 2\n            else:\n                if n % 2 != 0:\n                    l = (n - 1) \/\/ 2\n                    y += d * l * (l + 1)\n                else:\n                    l = n \/\/ 2\n                    y += d * (l * (l + 1) - l)\n            y += x * n\n        y \/= n\n        print(f'{y:.9f}')\n\nsolver()()","output":"linear"},{"instruction":"import sys\n\nn, m, k = map(int, input().split())\ntable = [input() for _ in range(n)]\n\ndp = [0]*(k+1)\n\nfor a in table:\n    one = []\n    for i in range(m):\n        if a[i] == '1':\n            one.append(i)\n\n    if not one:\n        continue\n\n    ni = len(one)\n    subdp = [10**9] * (ni+1)\n    subdp[-1] = 0\n\n    for i in range(ni):\n        for j in range(i, ni):\n            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)\n\n    next_dp = [10**9]*(k+1)\n    for i in range(k, -1, -1):\n        for j in range(ni+1):\n            if i+j > k:\n                break\n            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])\n    dp = next_dp\n\nprint(min(dp))","output":"cubic"},{"instruction":"import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter,deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap)-1)\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        item, heap[0] = heap[0], item\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\nclass Prime:\n    def __init__(self,N):\n        assert N<=10**8\n        self.smallest_prime_factor=[None]*(N+1)\n        for i in range(2,N+1,2):\n            self.smallest_prime_factor[i]=2\n        n=int(N**.5)+1\n        for p in range(3,n,2):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n                for i in range(p**2,N+1,2*p):\n                    if self.smallest_prime_factor[i]==None:\n                        self.smallest_prime_factor[i]=p\n        for p in range(n,N+1):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]\n\n    def Factorize(self,N):\n        assert N>=1\n        factorize=defaultdict(int)\n        if N<=len(self.smallest_prime_factor)-1:\n            while N!=1:\n                factorize[self.smallest_prime_factor[N]]+=1\n                N\/\/=self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N%p==0:\n                    N\/\/=p\n                    factorize[p]+=1\n                if N<p*p:\n                    if N!=1:\n                        factorize[N]+=1\n                    break\n                if N<=len(self.smallest_prime_factor)-1:\n                    while N!=1:\n                        factorize[self.smallest_prime_factor[N]]+=1\n                        N\/\/=self.smallest_prime_factor[N]\n                    break\n            else:\n                if N!=1:\n                    factorize[N]+=1\n        return factorize\n\n    def Divisors(self,N):\n        assert N>0\n        divisors=[1]\n        for p,e in self.Factorize(N).items():\n            A=[1]\n            for _ in range(e):\n                A.append(A[-1]*p)\n            divisors=[i*j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self,N):\n        return N==self.smallest_prime_factor[N]\n\n    def Totient(self,N):\n        for p in self.Factorize(N).keys():\n            N*=p-1\n            N\/\/=p\n        return N\n\n    def Mebius(self,N):\n        fact=self.Factorize(N)\n        for e in fact.values():\n            if e>=2:\n                return 0\n        else:\n            if len(fact)%2==0:\n                return 1\n            else:\n                return -1\n\nN,Q=map(int,readline().split())\nP=Prime(5*10**5)\nmebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]\ncnt=[0]*(5*10**5+1)\nans=0\nA=list(map(int,readline().split()))\nused=[False]*(N)\nfor _ in range(Q):\n    q=int(readline())-1\n    prime=list(P.Factorize(A[q]).keys())\n    l=len(prime)\n    for bit in range(1<<l):\n        s=1\n        for i in range(l):\n            if bit>>i&1:\n                s*=prime[i]\n        if used[q]:\n            cnt[s]-=1\n            ans-=cnt[s]*mebius[s]\n        else:\n            ans+=cnt[s]*mebius[s]\n            cnt[s]+=1\n    if used[q]:\n        used[q]=False\n    else:\n        used[q]=True\n    print(ans)","output":"np"},{"instruction":"S = input()\n\nans = 0\nmet = set()\n\nfor i in range(len(S)):\n    for j in range(i, -1, -1):\n        if S[j:i+1] in met:\n            ans = max(ans, i - j + 1)\n        else:\n            met.add(S[j:i+1])\n\nprint(ans)","output":"cubic"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)\n\n        while l < r:\n            m = l + ((r - l) \/\/ 2)\n            if nums[m] >= target:\n                r = m\n            elif nums[m] < target:\n                l = m + 1\n        return l if (l < len(nums) and nums[l] == target) else -1","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,m,k = map(int,input().split())\n    a = list(map(float,input().split()))\n    tree = [[0]*n for _ in range(n)]\n    for i in range(k):\n        x,y,z = map(int,input().split())\n        tree[x-1][y-1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1]*2)\n    dp = [[0]*(po[-1]*2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = a[i]\n    for i in range(po[-1]*2):\n        for j in range(n):\n            if i&po[j]:\n                for k in range(n):\n                    if not (i&po[k]):\n                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])\n    ma = 0\n    for i in range(po[-1]*2):\n        if bin(i)[2:].count(\"1\") == m:\n            for j in range(n):\n                ma = max(ma,dp[j][i])\n    print(int(ma))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\n\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"n,m,k = map(int,input().split())\nP = [int(x) for x in input().split()]\nP.reverse()\n\nops = 0\ni = 1\nwhile P:\n\n    nxt = P[-1]\n    togo = nxt - i\n    skip = togo\/\/k*k\n    i += skip\n\n    space = k\n    while space:\n        special = 0\n        while P and P[-1] < i + space:\n            special += 1\n            P.pop()\n        i += space\n        if not special:\n            break\n        ops += 1\n        space = special\n\nprint(ops)","output":"linear"},{"instruction":"from collections import Counter\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input()\n    c = Counter(s)\n    min_symbols = min(c[chr(ord(\"A\") + i)] for i in range(k))\n    print(min_symbols * k)\n","output":"linear"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\nres = float('inf')\nfor i in range(1, n):\n    res = min(res, min(arr[i], arr[0]) \/\/ i)\nfor i in range(n - 1):\n    res = min(res, min(arr[i], arr[n - 1]) \/\/ (n - 1 - i))\nprint(res)","output":"linear"},{"instruction":"string = input()\ntotalmax = 0;\nfor x in range(len(string)):\n    curr = \"\"\n    for y in string[x:]:\n        curr +=y;\n        if string[x:].rfind(curr) != string[x:].find(curr):\n            totalmax = max(totalmax, len(curr))\n            continue\nprint(totalmax)","output":"cubic"},{"instruction":"def wzor(n):\n    return (n*(n+1))\/2\n\ndef mafia():\n    pom = [int(x) for x in input().split()]\n    n = pom[0]\n    c = pom[1]\n\n    po = 1\n    ko = n\n    sr = (po + ko)\/\/2\n    while po != ko:\n        if wzor(sr)-(n-sr) >= c:\n            ko = sr\n        else:\n            po = sr+1\n        sr = (po+ko)\/\/2\n\n    print(int(wzor(po)-c))\n\nmafia()","output":"logn"},{"instruction":"import math\nk = int(input())\n\nflag = True\ni = 0\nvalue=0\n\nif(k <= 9):\n    print(k)\n\nelse:\n    while(flag):\n        a = 9 * pow(10, i) * (i+1)\n        if(k >= a):\n            k -= a\n            value+=9 * pow(10, i)\n            i+=1\n        else:\n            n=int(math.ceil(k\/(i+1)))\n            value+=n\n            index=k%(i+1)-1\n            print(str(value)[index])\n            flag=False","output":"logn"},{"instruction":"n = int(input())\ndata = [int(i) for i in input().split()]\ndata.sort()\nans = [0]*n\ncol = 0\nfor i in range(n):\n    if ans[i] == 0:\n        col += 1\n        ans[i] = 1\n        d = data[i]\n        for j in range(i+1, n):\n            if data[j] % d == 0:\n                ans[j] = 1\nprint(col)","output":"quadratic"},{"instruction":"n = int(input())\n\nif n % 2 == 0 :\n    print(4 , n - 4)\nelse:\n    print(9 , n - 9)","output":"constant"},{"instruction":"lst = list()\n\nlst.append(0)\nlst.append(1)\n\nnow = 1\nwhile now <= 1e25 :\n\tnow = now * 4 + 1\n\n\tlst.append(now)\n\nt = int(input())\n\nfor i in range(t):\n\ts = input().split()\n\tn = int(s[0])\n\tk = int(s[1])\n\tif(n >= 34):\n\t\tprint(\"YES \" + str(n - 1))\n\t\tcontinue\n\n\tsek = 0\n\tambil = 1\n\tnyak = 0\n\tcnt = 0\n\n\tsudah = False\n\twhile (sek < n):\n\t\tcnt = cnt + (1 << (sek + 1)) - 1\n\n\t\tif cnt > k:\n\t\t\tprint(\"NO\")\n\t\t\tsudah = True\n\t\t\tbreak\n\n\t\tnext_ambil = (ambil + 1) * 2 - 1\n\t\tsisa = 4 * ambil - next_ambil\n\t\tambil = next_ambil\n\n\t\tsek += 1\n\t\tnyak = nyak + sisa * lst[n - sek]\n\t\tif (nyak + cnt) >= k :\n\t\t\tprint(\"YES \" + str(n - sek))\n\t\t\tsudah = True\n\t\t\tbreak\n\n\tif sudah == False:\n\t\tprint(\"NO\")","output":"logn"},{"instruction":"n,p,v = input().split()\nx= list(map(int,input().split()))\n\nx.sort()\nprint(x[int(v)]-x[int(v)-1])","output":"nlogn"},{"instruction":"NANS = (False, None)\n\ndef is_valid(n, k):\n    if n > 31:\n        return True\n    return k*3 <= (2**(2*n) - 1)\n\ndef solve_mini(n, k):\n    if not is_valid(n, k):\n        return NANS\n\n    if n == 1:\n        if k == 1:\n            return (True, 0)\n        else:\n            return (False, None)\n    if n == 2:\n        if k in [1, 2]:\n            return (True, 1)\n        if k in [4, 5]:\n            return (True, 0)\n    return (False, None)\n\ndef solve(n, k):\n    if n < 3:\n        ans, log = solve_mini(n, k)\n        return (ans, log)\n\n    if not is_valid(n, k):\n        return NANS\n\n    w = 1\n    while k >= w and n >= 1:\n        k -= w\n        n -= 1\n        w = w + w + 1\n    return(True, n)\n\nt = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    ans, log = solve(n, k)\n    if ans:\n        print(\"YES\", log)\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"l = list(sorted(list(map(int,input().split()))))\nif min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):\n    print(\"Yes\")\nelse:\n    print(\"No\")","output":"constant"},{"instruction":"def main(n,k):\n\n  s=k*(k+1)\/\/2\n  if s<n:\n    return -1\n  l=1\n  r=k\n  while l<=r:\n\n    mid=(l+r)\/\/2\n\n    curr=s-(mid*(mid-1))\/\/2\n\n    if curr==n:\n\n      return k-mid+1\n    elif curr<n:\n      r=mid-1\n    else:\n      l=mid+1\n\n  return k-l+2\n\nn,k=list(map(int,input().split()))\nn-=1\nk-=1\nif n==0:\n  print(0)\nelse:\n  print(main(n,k))","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\ndef multi_input():\n    return map(int, input().split())\n\ndef sum(n,r):\n    return n*(2*r - (n-1))\/\/2\n\ndef function(total, l, r):\n    left = l\n    right = r\n\n    while left<=right:\n        mid = (right + left) \/\/ 2\n        result = sum(r-mid+1, r)\n        if result==total:\n            return r-mid+1\n        elif result > total:\n            left = mid + 1\n        else:\n            if sum(r-mid+2,r) > total:\n                return r-mid + 2\n            else:\n                right = mid - 1\n    return -1\n\nn, m = multi_input()\n\nn = n-1\nm = m-1\nif n==0:\n    print(0)\nelif sum(m,m)<n:\n    print(-1)\nelif m<n:\n    print(function(n, 1, m))\nelse:\n    print(1)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef cint(c):\n    return ord(c) - 96\n\ndef find_min_weight(n, k, stages):\n    n = len(stages)\n    min_weight = float('inf')\n\n    def backtrack(s, w, t):\n        nonlocal min_weight\n\n        if t >= k:\n            min_weight = min(min_weight, w)\n            return\n\n        if s >= n - 1:\n            return\n\n        for i in range(s+1, n, 1):\n            if stages[i] - stages[s] > 1:\n                backtrack(i, w+stages[i], t+1)\n\n    backtrack(0, stages[0], 1)\n\n    if min_weight == float('inf'):\n        return -1\n\n    return min_weight\n\nn, k = inlt()\nstages = list(set(map(cint, insr())))\nstages.sort()\nprint(find_min_weight(n, k, stages))","output":"linear"},{"instruction":"import sys\nfrom math import sqrt, log, log2, ceil, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial\nfrom copy import copy, deepcopy\nfrom sys import exit, stdin, stdout\nfrom collections import Counter, defaultdict, deque\nfrom itertools import permutations\nimport heapq\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\nmod = 1000000007\niinp = lambda: int(sys.stdin.readline())\ninp = lambda: sys.stdin.readline().strip()\nstrl = lambda: list(inp().strip().split(\" \"))\nintl = lambda: list(map(int, inp().split(\" \")))\nmint = lambda: map(int, inp().split())\nflol = lambda: list(map(float, inp().split(\" \")))\nflush = lambda: stdout.flush()\n\ndef solve():\n\n    n,s=mint()\n    cm=0\n    for i in range(n):\n        fi,ti=mint()\n        if i==0:\n            cm=fi+ti\n        if i!=0:\n            if fi+ti>cm:\n                cm=fi+ti\n    if cm>s:\n        print(cm)\n    else:\n        print(s)\n\nt=1\nfor _ in range(t):\n        solve()","output":"linear"},{"instruction":"n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nSum = 0\nfor j in range(n):\n    Sum+=b[j]*m\nb.sort()\nfor i in range(m):\n    Sum+=max(0, g[i]-b[-1])\nif min(g)<max(b): print(-1)\nelif min(g)==max(b): print(Sum)\nelse: Sum+=b[-1]-b[-2]; print(Sum)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom array import array\n\ndef main():\n    n,m,k=map(int,input().split())\n    left=[array(\"i\",map(int,input().split())) for _ in range(n)]\n    down=[array(\"i\",map(int,input().split())) for _ in range(n-1)]\n    dp=[array(\"i\",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)]\n    if k&1==0:\n        for l in range(k\/\/2):\n            dp1=[array(\"i\",[10**8 for _ in range(m)]) for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    if j>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])\n                    if j<m-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])\n                    if i>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])\n                    if i<n-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])\n            dp=dp1\n    for i in dp:\n        print(*i)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n = int(input())\na = [ int(x) for x in input().split() ]\n\ndp = [ [-1] * (n+1) for _ in range(n+1) ]\nfor i in range(n):\n    dp[i][i+1] = a[i]\n\nfor leng in range(2, n+1):\n    for l in range(n+1):\n        if l + leng > n: continue\n        r = l + leng\n        for mid in range(l+1, n+1):\n            if dp[l][mid] != -1 and dp[l][mid] == dp[mid][r]:\n                dp[l][r] = dp[l][mid] + 1\n\ndp2 = [ float(\"inf\") for _ in range(n+1) ]\nfor i in range(n+1):\n    dp2[i] = i\n    for j in range(i):\n        if dp[j][i] != -1:\n            dp2[i] = min(dp2[i], dp2[j] + 1)\n\nprint(dp2[n])","output":"cubic"},{"instruction":"s=list(input())\nans=0\nfar=0\nfor i in range(len(s)-1):\n    if(s[i]!=s[i+1]):\n        far+=1\n        continue\n    if(s[0]!=s[-1]):\n        s[:i+1]=s[:i+1][::-1]\n        s[i+1:]=s[i+1:][::-1]\n        far+=1\n    else:\n        ans=max(ans,far+1)\n        far=0\n\nprint(max(far+1,ans))","output":"linear"},{"instruction":"class Combination:\n    def __init__(self, n, MOD):\n        self.f = [1]\n        for i in range(1, n + 1):\n            self.f.append(self.f[-1] * i % MOD)\n        self.inv_f = [0] * (n + 1)\n        self.inv_f[n] = pow(self.f[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_f[i] = self.inv_f[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def inv(self, k):\n\n        return (self.inv_f[k] * self.f[k - 1]) % self.MOD\n\n    def fact(self, k):\n\n        return self.f[k]\n\n    def inv_fact(self, k):\n\n        return self.inv_f[k]\n\n    def perm(self, k, r):\n\n        if k < r:\n            return 0\n        return (self.f[k] * self.inv_f[k - r]) % self.MOD\n\n    def comb(self, k, r):\n\n        if k < r:\n            return 0\n        return (self.f[k] * self.inv_f[k - r] * self.inv_f[r]) % self.MOD\n\ndef combination(k, r, MOD):\n\n    if k < r:\n        return 0\n    r = min(r, k - r)\n    numer, denom = 1, 1\n    for l in range(r):\n        numer *= (k - l)\n        numer %= MOD\n        denom *= l + 1\n        denom %= MOD\n    return numer * pow(denom, MOD - 2, MOD) % MOD\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nn, MOD = map(int, input().split())\ncomb = Combination(10 ** 5, MOD)\n\ndp = [[0] * (n + 1) for i in range(n + 1)]\ndp[0][0] = 1\nfor i in range(1, n + 1):\n    dp[i][i] = pow(2, (i - 1), MOD)\n\npows = [pow(2, i, MOD) for i in range(n + 10)]\n\nfor i in range(n + 1):\n    for times in range(max(i \/\/ 2, 1), i + 1):\n        for length in range(1, times + 1):\n            nokori = times - length\n            ptn = pows[length - 1]\n            ptn *= comb.fact(times) * comb.inv_fact(nokori) * comb.inv_fact(length)\n            if i - length == 1:\n                continue\n            dp[i][times] += ptn * dp[i - length - 1][nokori]\n            dp[i][times] %= MOD\n\nprint(sum(dp[-1]) % MOD)","output":"cubic"},{"instruction":"import math\na=list(input())\nb=list(input())\np=a.count('+')-b.count('+')\nm=a.count('-')-b.count('-')\nif m<0 or p<0:\n    print(0)\n    exit(0)\nl=math.factorial(p+m)\/(math.factorial(p)*math.factorial(m))\nprint(l*(.5**(p+m)))","output":"np"},{"instruction":"import math\n\nn, r = map(int, input().split())\n\na = math.pi\/n\nsin = math.sin(a)\nR = r*sin\/(1-sin)\n\nprint(R)","output":"constant"},{"instruction":"def merge(a,b):\n    inda=0\n    indb=0\n    lena=len(a)\n    lenb=len(b)\n    d=[a[-1]+b[-1]+1000]\n    a+=d\n    b+=d\n    c=[]\n    inversions=0\n    for i in range(lena+lenb):\n        if a[inda]<b[indb]:\n            c.append(a[inda])\n            inda+=1\n        else:\n            c.append(b[indb])\n            indb+=1\n            inversions+=lena-inda\n    return((c,inversions))\ndef mergesort(a):\n    if len(a)<=1:\n        return((a,0))\n    split=len(a)\/\/2\n    b=a[:split]\n    c=a[split:]\n    d=mergesort(b)\n    e=mergesort(c)\n    f=merge(d[0],e[0])\n    return((f[0],f[1]+d[1]+e[1]))\nn=int(input())\na=list(map(int,input().split()))\nb=[]\nfor guy in a:\n    if guy!=-1:\n        b.append(guy)\ninvs=mergesort(b)[1]\nnegs=len(a)-len(b)\npairs=(negs*(negs-1))\/\/2\nused=[0]*n\nfor guy in a:\n    if guy!=-1:\n        used[guy-1]+=1\nunused=[0]\nfor i in range(n-1):\n    unused.append(unused[-1]+1-used[i])\nnegsseen=0\nmix=0\nfor i in range(n):\n    if a[i]==-1:\n        negsseen+=1\n    else:\n        mix+=unused[a[i]-1]*(negs-negsseen)+negsseen*(negs-unused[a[i]-1])\nnum=invs*2*negs+pairs*negs+mix*2\ndenom=2*negs\nif negs==0:\n    print(invs%998244353)\nelse:\n    for i in range(denom):\n        if (998244353*i+1)%denom==0:\n            inv=(998244353*i+1)\/\/denom\n            break\n    print((num*inv)%998244353)","output":"nlogn"},{"instruction":"import math\nn,r=map(int,input().split())\nprint(r\/( 1\/math.cos(math.pi*(n-2)\/2\/n)-1))","output":"constant"},{"instruction":"n = int(input())\nl = [0]+list(map(int,input().split()))\nfrom collections import defaultdict\nans = ['A','B']\nx = defaultdict(int)\ntable = [-1]*(n+1)\nfor i in range(1,n+1):\n\tx[l[i]] = i\n\ntable[x[n]] = 1\nfor i in range(n-1,0,-1):\n\tif(x[i]-i>0):\n\t\tfor j in range(x[i],0,-i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\tif(n-i>0 and table[x[i]]==-1):\n\t\tfor j in range(x[i],n+1,i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\n\tif(table[x[i]]==-1):\n\t\ttable[x[i]] = 1\n\nfor i in table[1:]:\n\tprint(ans[i],end='')","output":"linear"},{"instruction":"n = int(input())\ns = input()\nans = 10000\nfor i in range(0, 105):\n\tf = True\n\tx = i\n\tfor c in s:\n\t\tif c == '-':\n\t\t\tx -= 1\n\t\telse:\n\t\t\tx += 1\n\t\tif x < 0:\n\t\t\tf = False\n\tif f:\n\t\tans = min(ans, x)\nprint(ans)","output":"linear"},{"instruction":"import re\ninput()\nprint(sum(len(f)-2 for f in re.findall('x{3,}',input())))","output":"linear"},{"instruction":"def mypw2(deg):\n    if (deg >= 1500) : return 2 ** 150\n\n    return 2 ** deg\n\ndef sol():\n    n, k = map(int, input().split())\n    if (k == 0):\n        print(\"YES\", n)\n        return\n    for side in range(1, n + 1):\n        MIN = mypw2(side + 1) - side - 2\n        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;\n        MAX \/\/= 3\n\n        if (MIN <= k <= MAX):\n            print(\"YES\", n - side)\n            return\n    print(\"NO\")\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        sol()\n\nmain()","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\nimport math\n\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")","output":"linear"},{"instruction":"def solve(d, n, k):\n    mv = sum(d[0:k])\n    v = mv\n    for i in range(1, n-k+1):\n        mv = mv + d[i+k-1] - d[i-1]\n        v = min(v, mv)\n    return v\n\nfor _ in range(int(input())):\n    n, k = tuple(map(int, input().split()))\n    s = input()\n    st = 'RGB' * (n\/\/3 + 3)\n    diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(n):\n        if s[i] != st[i]: diff1[i] = 1\n        if s[i] != st[i+1]: diff2[i] = 1\n        if s[i] != st[i+2]: diff3[i] = 1\n\n    print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))","output":"linear"},{"instruction":"from math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *\nfrom fractions import *\nfrom sys import *\nfrom types import CodeType, new_class\n\nn = int(input())\nprint(n\/\/2+1)","output":"constant"},{"instruction":"k = int(input())\n\nmul = 1\nd = 1\n\nwhile k>mul*9*d:\n    k-=mul*9*d\n    d+=1\n    mul*=10\n\nx = k%d\ny = k\/\/d\ny+=mul\n\nif x==0:\n    print((y-1)%10)\nelse:\n    y = y\/\/pow(10,d-x)\n    print(y%10)","output":"logn"},{"instruction":"R = lambda :map(int, input().split())\nn = int(input())\nl = []\nfor _ in range(n):\n    a,b = R()\n    l.append((a,-b,_+1))\nl = sorted(l)\nfor i in range(1,n):\n    if l[i][1]>=l[i-1][1]:\n        print(l[i][2],l[i-1][2])\n        break\nelse:\n    print(-1,-1)","output":"nlogn"},{"instruction":"n = int(input())\nfor _ in range(n):\n    l, r = map(int, input().split())\n    if (l - r) % 2 == 1:\n        if l % 2:\n            print((r-l+1)\/\/2)\n        else:\n            print(-((r-l+1)\/\/2))\n    else:\n        ans = 0\n        if l % 2:\n            ans = ans + (r-l)\/\/2\n        else:\n            ans = ans + -(r-l)\/\/2\n        if r % 2:\n            ans = ans - r\n        else:\n            ans = ans + r\n        print(ans)","output":"constant"},{"instruction":"from sys import stdin\n\ndef read_lines(sep=' ', input_type=None):\n\n    _lines = stdin.readlines()\n    cast = input_type is not None\n    lines = []\n    for line in _lines:\n        line = line[:-1].split(sep)\n        if cast:\n            line = [input_type(x) for x in line]\n        lines.append(line)\n    return lines\n\nimport collections\n\ndef numz(a,b):\n    if a and b:\n        if b > a:\n            a,b=b,a\n        d,m = divmod(a,b)\n        return d + numz(b,m)\n    else:\n        return 0\n\nif __name__ == '__main__':\n\n    lines = read_lines(input_type=int)\n\n    lines = lines[1:]\n    for line in lines:\n        print(numz(*line))","output":"constant"},{"instruction":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\ndef IF(c, t, f): return t if c else f\ndef YES(c): return IF(c, \"YES\", \"NO\")\ndef Yes(c): return IF(c, \"Yes\", \"No\")\n\ndef main():\n    t = 1\n\n    rr = []\n    for _ in range(t):\n        n,k = LI()\n\n        t = 0\n        for i in range(1,10**5):\n            t += i\n            if t - (n-i) == k:\n                rr.append(n-i)\n                break\n\n    return JA(rr, \"\\n\")\n\nprint(main())","output":"logn"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)","output":"np"},{"instruction":"n, k = map(int, input().split())\nl = list(map(int, input().split()))\ncost = l[n - 1] - l[0]\nif k == 1:\n\tprint(cost)\nelse:\n\tdiff = [0 for _ in range(n - 1)]\n\tfor i in range(n - 1):\n\t\tdiff[i] = l[i + 1] - l[i]\n\n\tdiff = sorted(diff)\n\tdiff.reverse()\n\tprint(cost - sum(diff[:k - 1]))","output":"nlogn"},{"instruction":"import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef solve2(s, t, left, right):\n    n = len(s)\n    m = len(t)\n    nuxt = [-1]*(left+1)\n    nuxt[0] = 0\n\n    for i in range(n):\n        for j in reversed(range(left+1)):\n            k = nuxt[j]\n            if k == -1:\n                continue\n            if j != left:\n                if s[i] == t[j]:\n                    nuxt[j+1] = max(nuxt[j+1], k)\n            if k != right:\n                if s[i] == t[left+k]:\n                    nuxt[j] = max(nuxt[j], k+1)\n    return nuxt[-1]==right\n\ndef solve():\n    s = input()\n    t = input()\n    m = len(t)\n    for i in range(m+1):\n        if solve2(s,t,i,m-i):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nt = int(input())\nfor i in range(t):\n    solve()","output":"cubic"},{"instruction":"from sys import stdin\nn, m, a, b = map(int, stdin.readline().split())\nx = n%m\nprint(min(a *(m-x), b*x))","output":"linear"},{"instruction":"yellow, blue = map(int, input().split())\ny, g, b = map(int, input().split())\n\ncount = 0\n\nyt = y * 2 + g\nbt = g + b * 3\n\nyc = yellow - yt\nif yc < 0:\n    count += abs(yc)\n\nbc = blue - bt\nif bc < 0:\n    count += abs(bc)\n\nprint(count)","output":"constant"},{"instruction":"z=)]\n\nn, m = map(int, input().split())\n\nprint(k[n]%m)","output":"quadratic"},{"instruction":"MAXN = 200001\n\ndef less_sum(s, m):\n    n = len(s)\n    a = 0\n    b = 0\n    res = 0\n    last = 0\n\n    count = [0 for i in range(-MAXN, MAXN+1)]\n\n    count[0] = 1\n    x = 0\n    last = 1\n\n    for i in range(n):\n        if s[i] > m:\n            b += 1\n        else:\n            a += 1\n        x = a-b\n\n        if s[i] > m:\n            last -= count[x+1]\n        else:\n            last += count[x]\n\n        res += last\n        count[x] += 1\n        last += 1\n\n    return res\n\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))[0:n]\n\nprint(less_sum(s, m) - less_sum(s, m-1))","output":"nlogn"},{"instruction":"import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, m, k = mi()\na = [None] + li()\np = [0] * (n + 1)\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] + a[i]\ns = [10 ** 16 for _ in range(m)]\ns[0] = k\nans = 0\nfor i in range(1, n + 1):\n    ans = max(ans, p[i] - min(s))\n    s[i % m] = min(s[i % m], p[i])\n    s[i % m] += k\nprint(ans)","output":"linear"},{"instruction":"from sys import stdin,stdout\nfrom itertools import accumulate\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    a=lst()\n    a.sort()\n    s = set()\n    for v in a:\n        if (v % k != 0) or v \/\/ k not in s:\n            s.add(v)\n    print(len(s))","output":"nlogn"},{"instruction":"q=int(input())\nfor i in range(q):\n\tn,k=map(int,input().split())\n\ts=input()\n\tm=10**4\n\tfor j in range(n):\n\t\tif j+k<=n:\n\t\t\tl1=[\"R\",\"G\",\"B\"]\n\t\t\tm1,m2,m3=0,0,0\n\t\t\tfor i in range(j,j+k):\n\t\t\t\tif l1[(i-j)%3]!=s[i]:\n\t\t\t\t\tm1+=1\n\t\t\tfor i in range(j,j+k):\n\t\t\t\tif l1[(i+1-j)%3]!=s[i]:\n\t\t\t\t\tm2+=1\n\t\t\tfor i in range(j,j+k):\n\t\t\t\tif l1[(i+2-j)%3]!=s[i]:\n\t\t\t\t\tm3+=1\n\t\t\tm=min(m,m1,m2,m3)\n\t\telse:\n\t\t\tbreak\n\tprint(m)","output":"quadratic"},{"instruction":"import sys\n\ndef chain_reaction(n, beacons):\n    table = [0] * n\n\n    for i in range(n):\n        position = beacons[i][0]\n        power = beacons[i][1]\n        destroyed = 0\n        r = position - power\n        b = 0\n\n        lo = 0\n        hi = len(beacons) - 1\n        while lo <= hi:\n            mid = int(lo + (hi - lo) \/ 2)\n            pos = beacons[mid][0]\n            if beacons[mid][0] < r:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n\n        destroyed += table[hi]\n\n        destroyed += (i - (hi + 1))\n        table[i] = destroyed\n\n    cost = n\n    ind = 0\n    while ind < len(table):\n        cost = min(cost, n - ind - 1 + table[ind])\n        ind += 1\n\n    return cost\n\nn = int(sys.stdin.readline().strip())\nbeacons = []\nfor i in range(n):\n    a, b = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    beacons.append((a, b))\nbeacons.sort()\nprint(chain_reaction(n, beacons))","output":"linear"},{"instruction":"from sys import stdin, setrecursionlimit\nfrom bisect import bisect_right\n\nsetrecursionlimit(15000)\n\ndef get_gdict(arr):\n\tgdict = dict()\n\tfor i in range(len(arr)):\n\t\tif arr[i] in gdict:\n\t\t\tgdict[arr[i]] += 1\n\t\telse:\n\t\t\tgdict[arr[i]] = 1\n\treturn gdict\n\ndef initial_check(barr, garr):\n\tfor i in garr:\n\t\tif i < barr[-1]:\n\t\t\treturn False\n\treturn True\n\nn, m = list(map(int, stdin.readline().split()))\nbarr = list(map(int, stdin.readline().split()))\ngarr = list(map(int, stdin.readline().split()))\nbarr.sort()\ngarr.sort()\nans = 0\ngdict = get_gdict(garr)\nif initial_check(barr, garr):\n\tcount  = m\n\tb = n - 1\n\tg = m - 1\n\twhile count  > 0:\n\t\ttempb = [barr[b]] * (m)\n\n\t\tfor i in range(len(tempb)):\n\t\t\tif count <= 0:\n\t\t\t\tfor j in range(i, m):\n\t\t\t\t\tans += tempb[b]\n\t\t\t\tbreak\n\n\t\t\tif tempb[i] in gdict:\n\t\t\t\tgdict[tempb[i]] -= 1\n\t\t\t\tans += (tempb[i])\n\t\t\t\tcount -= 1\n\t\t\t\tif gdict[tempb[i]] == 0:\n\t\t\t\t\tdel gdict[tempb[i]]\n\t\t\telse:\n\t\t\t\tif i == 0:\n\t\t\t\t\tans += (tempb[i])\n\t\t\t\t\tcontinue\n\t\t\t\tfor k in range(g, -1, -1):\n\t\t\t\t\tif garr[k] in gdict:\n\t\t\t\t\t\tans += garr[g]\n\t\t\t\t\t\tg = k - 1\n\t\t\t\t\t\tcount -= 1\n\t\t\t\t\t\tbreak\n\n\t\tb -= 1\n\n\twhile b >= 0:\n\t\tans += m * (barr[b])\n\t\tb -= 1\n\tprint(ans)\n\nelse:\n\tprint(-1)","output":"cubic"},{"instruction":"s = input()\n\ndef check_x(mid):\n    ans = 'no'\n    d = {}\n    for i in range(len(s)-mid+1):\n\n        if s[i:i+mid] in d.keys():\n            ans = 'yes'\n            break\n        d[s[i:i+mid]] = 1\n\n    return ans\n\nl = 0\nr = len(s) - 1\nwhile r-l > 1:\n    mid = (r+l) \/\/ 2\n\n    ans = check_x(mid)\n    if ans == 'yes':\n        l = mid\n    else:\n        r = mid\n\nif check_x(r) == 'yes':\n    print(r)\nelse:\n    print(l)","output":"cubic"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int,input().split())\ndef li():\n    return list(map(int,input().split()))\n\nmod = 10**9 + 7\n\nx,k = mi()\nif(x == 0):\n    print(0)\nelif(k == 0):\n    print((2*x)%mod)\nelse:\n    to = pow(2,k,mod)\n    pre = (to * x)%mod\n    prev = pow(2,k-1,mod)\n    first = (pre - prev + 1)%mod\n    sec = (pre - prev)%mod\n    ans = (first + sec)%mod\n    print((ans+mod)%mod)","output":"logn"},{"instruction":"digit = int(input())\n\nif int(digit) <= 9:\n    print(digit)\n    exit()\n\nstart_range = 1\nend_range = 9\n\npower = 1\ndigit_count = 2\nwhile not (start_range <= digit and digit <= end_range):\n    start_range = end_range + 1\n    end_range = 9 * 10**power * digit_count + start_range - 1\n    power += 1\n    digit_count += 1\n\noffset_number = (digit - start_range) \/\/ (digit_count - 1)\n\nnumber = str(10**(power - 1) + offset_number)\n\noffset_digit = (digit - start_range) % (digit_count - 1)\n\nprint(f\"{number[offset_digit]}\")","output":"logn"},{"instruction":"x,k=list(map(int,input().split()))\nmd=1000000007\nprint((pow(2,k+1,md)*x-pow(2,k,md)+1)%md if x>0 else 0)","output":"logn"},{"instruction":"a = input().split()\nb = [int(i) for i in a]\ninputs = []\ndiff = []\nsinComprimir = 0\nfor i in range(b[0]):\n    input1 = input().split()\n    input2 = [int(i) for i in input1]\n    inputs.append(input2)\n\ncomprimido = 0\nfor k in range(len(inputs)):\n    sinComprimir = sinComprimir + inputs[k][0]\n    diff.append(inputs[k][0] - inputs[k][1])\n    comprimido = comprimido + inputs[k][1]\n\ndifference = sorted(diff)\ninvDifference = difference[::-1]\nnewTotal = sinComprimir\niteraciones = 0\niterador = 0\nif sinComprimir <= b[1]:\n    print(\"0\")\nelif comprimido > b[1]:\n    print(\"-1\")\nelse:\n    while newTotal > b[1]:\n        iterador = iterador + 1\n        newTotal = newTotal - invDifference[iterador-1]\n        iteraciones += 1\n    print(iteraciones)","output":"nlogn"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\narr.sort()\nans=0\nmark=0\nfor i in range(len(arr)-2):\n\tif(arr[i]==arr[i+1]==arr[i+2]):\n\t\tprint('cslnb')\n\t\texit(0)\n\telif(arr[i+1]==arr[i+2] and arr[i]+1==arr[i+1]):\n\t\tprint('cslnb')\n\t\texit(0)\n\ncountcopy=0\nfor i in range(len(arr)-1):\n\tif(arr[i]==arr[i+1] and arr[i]==0):\n\t\tprint('cslnb')\n\t\texit(0)\n\tif(arr[i]==arr[i+1]):\n\t\tcountcopy+=1\nif(countcopy>1):\n\tprint('cslnb')\n\texit(0)\n\nfor i in range(len(arr)):\n\tif(arr[i]>=mark):\n\t\tans+=(arr[i]-mark)\n\t\tmark+=1\n\nif(ans%2==0):\n\tprint('cslnb')\nelse:\n\tprint('sjfnb')","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nANS=[]\n\nfor i in range(1,n\/\/2+1):\n    for j in range(1,m+1):\n        sys.stdout.write(\"\".join((str(i),\" \",str(j),\"\\n\")))\n        sys.stdout.write(\"\".join((str(n-i+1),\" \",str(m-j+1),\"\\n\")))\n\nif n%2==1:\n    for j in range(1,m\/\/2+1):\n        sys.stdout.write(\"\".join((str(n\/\/2+1),\" \",str(j),\"\\n\")))\n        sys.stdout.write(\"\".join((str(n\/\/2+1),\" \",str(m-j+1),\"\\n\")))\n\n    if m%2==1:\n        sys.stdout.write(\"\".join((str(n\/\/2+1),\" \",str(m\/\/2+1),\"\\n\")))","output":"quadratic"},{"instruction":"def path(x1,y1,x2,y2,hor):\n    out=[]\n    if hor:\n        for i in range(x2-x1):\n            out.append((x1+i,y1))\n        if y2>y1:\n            for i in range(y2-y1):\n                out.append((x2,y1+i))\n        else:\n            for i in range(y1-y2):\n                out.append((x2,y1-i))\n    else:\n        for i in range(x2-x1):\n            out.append((x2-i,y2))\n        if y2>y1:\n            for i in range(y2-y1):\n                out.append((x1,y2-i))\n        else:\n            for i in range(y1-y2):\n                out.append((x1,y2+i))\n    return out[1:]\na,b=map(int,input().split())\nc,d=map(int,input().split())\ne,f=map(int,input().split())\nif a>c:\n    a,b,c,d=c,d,a,b\nif c>e:\n    c,d,e,f=e,f,c,d\nif a>c:\n    a,b,c,d=c,d,a,b\nif c==e and abs(f-b)<abs(d-b):\n    c,d,e,f=e,f,c,d\ng1=path(a,b,c,d,True)\nif d>b:\n    if f<b:\n        g2=path(c,b,e,f,True)\n    elif f<d:\n        g2=path(c,f,e,f,True)\n    else:\n        g2=path(c,d,e,f,True)\nelse:\n    if f<d:\n        g2=path(c,d,e,f,True)\n    elif f<b:\n        g2=path(c,f,e,f,True)\n    else:\n        g2=path(c,b,e,f,True)\nprint(len(g1)+len(g2)+3)\nprint(a,b)\nprint(c,d)\nprint(e,f)\nfor x,y in g1:\n    print(x,y)\nfor x,y in g2:\n    print(x,y)","output":"constant"},{"instruction":"def helper(n,k,l):\n\n\tres = 0\n\tfor i in range(n-k+1):\n\t\tbase_seg = l[i:i+k]\n\t\tsm_bseg = sum(base_seg)\n\t\tln_bseg = len(base_seg)\n\t\tans = sm_bseg\/ln_bseg\n\n\t\tfor j in range(i+k,n):\n\t\t\tsm_bseg+=l[j]\n\t\t\tln_bseg+=1\n\t\t\tans=max(ans,sm_bseg\/ln_bseg)\n\n\t\tres = max(res,ans)\n\n\treturn res\n\nn,k = map(int,input().split())\nl = list(map(int,input().split()))\n\nprint(helper(n,k,l))","output":"quadratic"},{"instruction":"n,m=[int(x) for x in input().split()]\nv=[]\nh=[]\nfor i in range(n):\n    x=int(input())\n    v.append(x)\nfor i in range(m):\n    x,y,z=[int(x) for x in input().split()]\n    if x==1:\n        h.append(y)\nh.sort()\nv.sort()\nm=len(h)\nn=len(v)\nif n==0 or v[n-1]!=1000000000:\n    v.append(1000000000)\n    n+=1\nmina=9999999999999\nj=0\nfor i in range(n):\n    while(j<m and h[j]<v[i]):\n        j+=1\n\n    mina=min(mina,i+m-j)\nprint(mina)","output":"nlogn"},{"instruction":"def get_ans(x, a, n, m):\n\n    lim = 1<<m\n    match = lim-1\n    track = [-1 for i in range(lim)]\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if(a[i][j] >= x):\n                mask |= 1 << j\n        track[mask] = i\n\n    for i in range(lim):\n        for j in range(lim):\n            if(i|j == match and track[i] != -1 and track[j] != -1):\n                return track[i], track[j]\n\n    return -1, -1\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\nlo = 0\nhi = 1000000000\nwhile(lo < hi-1):\n    mid = (lo+hi)\/2\n    i, j = get_ans(mid,a,n,m)\n    if(i == -1):\n        hi = mid-1\n    else:\n        lo = mid\n\ni,j = get_ans(hi,a,n,m)\nif(i != -1):\n    print(\"{} {}\".format(i+1,j+1))\nelse:\n    i,j = get_ans(lo,a,n,m)\n    print(\"{} {}\".format(i+1,j+1))","output":"np"},{"instruction":"input();a=sorted(map(int,input().split()));s=c=0\nwhile s<=sum(a):s+=a.pop();c+=1\nprint(c)","output":"nlogn"},{"instruction":"import sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nfor _ in range(int(input())):\n\tn,k = ri()\n\ta = input()\n\trgb= [0 for i in range(n)]\n\tgbr= [0 for i in range(n)]\n\tbrg= [0 for i in range(n)]\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\trgb[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tgbr[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tbrg[i]+=1\n\n\tfor i in range(1,n):\n\t\trgb[i]+=rgb[i-1]\n\t\tbrg[i]+=brg[i-1]\n\t\tgbr[i]+=gbr[i-1]\n\n\tans = 999999999\n\n\tfor i in range(k-1,n):\n\n\t\tif i-k ==-1:\n\t\t\tans = min(ans,rgb[i],gbr[i],brg[i])\n\t\telse:\n\t\t\tans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )\n\n\tprint(ans)","output":"linear"},{"instruction":"from sys import setcheckinterval,stdin\nsetcheckinterval(1000)\n\niin=lambda :int(stdin.readline())\nlin=lambda :list(map(int,stdin.readline().split()))\n\nn,q=lin()\na=lin()\nif q==0:\n    exit()\nQ=[iin() for i in range(q)]\nsq=set(Q)\nmx=max(Q)\nd=dict()\nch=1\nfor i in range(min(mx,n+1)):\n    if ch==n:\n        ch=1\n    if i+1 in sq:d[i+1]=[a[0],a[ch]]\n    if a[0]<a[ch]:\n        a[0],a[ch]=a[ch],a[0]\n    ch+=1\n\nfor i in Q:\n    if i>n:\n        x=n-1 if i%(n-1)==0 else i%(n-1)\n        print(a[0],a[x])\n    else:\n        print(*d[i])","output":"linear"},{"instruction":"from heapq import *\n\nMSIZE = 1 << 8\ndef GetVal(s):\n    ans = 0\n    for i in range(8):\n        if s[i] == '1':\n            ans = ans + (1 << i)\n    return ans\n\ndef GetNot(s):\n    return MSIZE - 1 - s;\n\nxVal = GetVal('00001111')\nyVal = GetVal('00110011')\nzVal = GetVal('01010101')\n\ndef Dijkstra():\n    depth = [['Z' * 585 for i in range(4)] for i in range(MSIZE)]\n    depth[xVal][3] = 'x'\n    depth[yVal][3] = 'y'\n    depth[zVal][3] = 'z'\n\n    pq = []\n    def push(kek):\n        heappush(pq, kek)\n    def pop():\n        return heappop(pq)\n    push([1, xVal, 3])\n    push([1, yVal, 3])\n    push([1, zVal, 3])\n    while len(pq) > 0:\n        l, i, j = pop();\n        if len(depth[i][j]) < l: continue\n        for x in range(MSIZE):\n            for y in range(4):\n                nxt1 = depth[i][j] + '|' + depth[x][y]\n                nxt2 = depth[x][y] + '|' + depth[i][j]\n                nxt = min(nxt1, nxt2)\n                val = (i | x)\n                if len(depth[val][0]) == len(nxt) and depth[val][0] > nxt:\n                    depth[val][0] = nxt\n                    push([len(nxt), val, 0])\n                elif len(depth[val][0]) > len(nxt):\n                    depth[val][0] = nxt\n                    push([len(nxt), val, 0])\n        if j > 0:\n            for x in range(MSIZE):\n                for y in range(1, 4):\n                    nxt1 = depth[i][j] + '&' + depth[x][y]\n                    nxt2 = depth[x][y] + '&' + depth[i][j]\n                    nxt = min(nxt1, nxt2)\n                    val = (i & x)\n                    if len(depth[val][1]) == len(nxt) and depth[val][1] > nxt:\n                        depth[val][1] = nxt\n                        push([len(nxt), val, 1])\n                    elif len(depth[val][1]) > len(nxt):\n                        depth[val][1] = nxt\n                        push([len(nxt), val, 1])\n        if j > 2:\n            val = GetNot(i)\n            nxt = '!' + depth[i][j]\n            if len(depth[val][2]) == len(nxt) and depth[val][2] > nxt:\n                depth[val][2] = nxt\n                push([len(nxt), val, 2])\n            elif len(depth[val][2]) > len(nxt):\n                depth[val][2] = nxt\n                push([len(nxt), val, 2])\n        nxt = '(' + depth[i][j] + ')'\n        val = i\n        if len(depth[val][3]) == len(nxt) and depth[val][3] > nxt:\n            depth[val][3] = nxt\n            push([len(nxt), val, 3])\n        elif len(depth[val][3]) > len(nxt):\n            depth[val][3] = nxt\n            push([len(nxt), val, 3])\n    answer = []\n    for i in range(MSIZE):\n        ans = 'Z' * 585\n        for j in range(4):\n            if len(ans) > len(depth[i][j]):\n                ans = depth[i][j]\n            elif len(ans) == len(depth[i][j]) and ans > depth[i][j]:\n                ans = depth[i][j]\n        answer.append(ans)\n    return answer\nkek = Dijkstra()\n\nq = int(input())\nfor i in range(q):\n    print(kek[GetVal(input())])","output":"quadratic"},{"instruction":"import sys\nimport bisect\nimport heapq\nimport math\n\nINF = 10**9+7\nsys.setrecursionlimit(INF)\n\ndef fi():\n    return int(sys.stdin.readline())\n\ndef fi2():\n    return map(int, sys.stdin.readline().split())\n\ndef fi3():\n    return sys.stdin.readline().rstrip()\n\ndef fo(*args):\n    for s in args:\n        sys.stdout.write(str(s)+' ')\n    sys.stdout.write('\\n')\n\ndef puts(*args):\n    for s in args:\n        sys.stdout.write(str(s))\n\ndef mask(n1):\n    arr = []\n    for i in range(64):\n        arr.append(n1&1)\n        n1 = n1 >> 1\n    arr.reverse()\n    return arr\n\ndef getn(mask):\n    if sum(mask) == 0:\n        return 0\n    res = 0\n    for i in range(63, -1, -1):\n        res += (2*mask[i])**(63-i)\n    return res\n\nn1, n2 = fi2()\nm1 = mask(n1)\nm2 = mask(n2)\n\nsol = [0 for i in range(64)]\n\nfor i in range(64):\n    if m1[i] != m2[i]:\n        sol[i] = 1\n        break\n\ni += 1\nfor j in range(i, 64):\n    sol[j] = 1\n\nres = getn(sol)\nfo(res)","output":"logn"},{"instruction":"def main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*-(-nSquares\/\/2)\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),\n                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))\n                         for piece in brokenPieces]\n    possible_nSquares.sort(key=lambda x: x[0])\n\n    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]\n\nif __name__ == '__main__':\n    print(main())","output":"quadratic"},{"instruction":"n,k = map(int,input().split())\na = list(map(int,input().split()))\nt = []\nfor i in range(1,n):\n    t.append(a[i]-a[i-1])\nt.sort()\nprint(sum(t[:n-k]))","output":"nlogn"},{"instruction":"n,m=map(int,input().split())\nvert=[]\nfor i in range(n):\n    vert.append(int(input()))\nhoriz=[]\nfor i in range(m):\n    a,b,c=map(int,input().split())\n    if a==1:\n        horiz.append(b)\nvert.sort()\nvert.append(1000000000)\nvert.append(2000000000)\nhoriz.sort()\noof=[0]*(n+2)\nb=0\nfor i in range(len(horiz)):\n    while True:\n        if horiz[i]<vert[b]:\n            oof[b]+=1\n            break\n        else:\n            b+=1\nmini=1000000\nbad=len(horiz)\nfor i in range(n+1):\n    bad-=oof[i]\n    if bad+i<mini:\n        mini=bad+i\nprint(mini)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\ns = []\nfor q in range(n-1):\n    s.append([a[q+1]-a[q], q])\ns.sort(reverse=True)\nd = {q[1] for q in s[:k-1]}\nans = 0\nq1 = a[0]\nfor q in range(n-1):\n    if q in d:\n        ans += a[q]-q1\n        q1 = a[q+1]\nprint(ans+a[-1]-q1)","output":"nlogn"},{"instruction":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        count = defaultdict(int)\n        for num in nums:\n            count[num] += 1\n\n        res = []\n        for i in range(len(nums)):\n            count[nums[i]] -= 1\n            if i and nums[i] == nums[i - 1]:\n                continue\n\n            for j in range(i + 1, len(nums)):\n                count[nums[j]] -= 1\n                if j - 1 > i and nums[j] == nums[j - 1]:\n                    continue\n                target = -(nums[i] + nums[j])\n                if count[target] > 0:\n                    res.append([nums[i], nums[j], target])\n\n            for j in range(i + 1, len(nums)):\n                count[nums[j]] += 1\n        return res","output":"quadratic"},{"instruction":"def pow2(n):\n    j=0\n    while(n%2==0):\n        n\/\/=2\n        j+=1\n    return j\nn,q=map(int,input().split())\nfor j in range(q):\n    u=int(input())\n    s=input()\n    for k in range(len(s)):\n        num=pow2(u)\n        if(s[k]==\"R\" and num!=0):\n            u=u+2**(num-1)\n        elif(s[k]==\"L\" and num!=0):\n            u=u-2**(num-1)\n        elif(s[k]==\"U\" and u!=(n+1)\/\/2):\n            m1=u+2**(num)\n            m2=u-2**(num)\n            if(pow2(m1)==(num+1)):\n                u=m1\n            else:\n                u=m2\n    print(u)","output":"np"},{"instruction":"def raschot(d, e, g, h):\n    if d > e:\n        return 1\n    key = d, g, h\n    if key in b:\n        return b[key]\n    f = 0\n    for x in (['0', '1'] if a0[d] == '?' else [a0[d]]):\n        if d == e:\n            a = [x]\n        else:\n            a = ['0', '1'] if a0[e] == '?' else [a0[e]]\n        for y in a:\n            if not ((g and x > y) or (h and x == y == '1')):\n                f += raschot(d + 1, e - 1, g and x == y, h and x != y)\n    b[key] = f\n    return f\n\nn, m = map(int, input().split())\nm += 1\na0 = ['?'] * n\nfor i in range(n):\n    a0[i] = '0'\n    b = {}\n    c = raschot(0, n - 1, True, True)\n    if m > c:\n        m -= c\n        a0[i] = '1'\nif a0[0] == '0':\n    print(''.join(a0))\nelse:\n    print(-1)","output":"cubic"},{"instruction":"s=int(input())\nt=len(str(s))\nL=['4','7']\nimport copy\nfor i in range(t):\n    L1=copy.deepcopy(L)\n    for m in L:\n        L1.append(m+'4')\n        L1.append(m+'7')\n    L=L1\nL0=list(map(int,L))\nsum=0\nfor i in range(len(L0)):\n    if s%L0[i]==0:\n        sum=sum+1\nif sum>0:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"n=int(input())\nl=[int(x) for x in input().split()]\nif l==sorted(l):\n\tprint(\"Yes\")\nelse:\n\tcnt=0;\n\tg=sorted(l)\n\tfor i in range(len(l)):\n\t\tif l[i]!=g[i]:\n\t\t\tcnt+=1\n\tif cnt<=2:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nmask = (1 << m) - 1\n\nl = []\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nlo = -1\nhi = 10 ** 9 + 1\nwhile hi - lo > 1:\n    test = (hi + lo) \/\/ 2\n\n    things = dict()\n    for i in range(n):\n        curr = 0\n        for v in l[i]:\n            curr *= 2\n            if v >= test:\n                curr += 1\n        things[curr] = i\n\n    works = False\n    for v1 in things:\n        for v2 in things:\n            if v1 | v2 == mask:\n                outi = things[v1]\n                outj = things[v2]\n                works = True\n                break\n        if works:\n            break\n\n    if works:\n        lo = test\n    else:\n        hi = test\n\nprint(outi + 1, outj + 1)","output":"np"},{"instruction":"N, K = map(int, input().split())\nif N == K:\n    print(\"0\"*N)\nelif K == 1:\n    print(\"0\"*(N-1) + \"1\")\nelif K == 3:\n    print(\"1\" + \"0\"*(N-4) + \"101\")\nelse:\n    res = [\"0\"]*N\n    for i in range(0, N, N\/\/2-K\/\/2+1):\n        res[i] = \"1\"\n    print(''.join(res))","output":"linear"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"x,n=map(int,input().split())\nmod=10**9+7\nif x>0: ans=pow(2,n+1,mod)*x-pow(2,n,mod)+1\nelse: ans=0\nprint(ans%mod)","output":"logn"},{"instruction":"for _ in range(int(input())):\n    n,m=map(int,input().split())\n\n    a=[[int(x) for x in input().split()] for j in range(n)]\n\n    x=[[a[i][j] for i in range(n)] for j  in range(m)]\n    x.sort(key=lambda xx:-max(xx))\n    dp=[[0 for i in range(1<<n)] for j in range(m+1)]\n    an=0\n\n    for i in range(m):\n        for prev in range(1<<n):\n            for pres in range(1<<n):\n\n                for j in range(n):\n\n                    ma=0\n                    if prev^pres!=prev+pres:\n                        continue\n                    for st in range(n):\n\n                        if pres&(1<<st):\n                            ma+=x[i][(st+j)%n]\n\n                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)\n\n    print(dp[m][(1<<n)-1])","output":"np"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\nn,k=map(int,input().split())\narr=list(map(int,input().split()))\nd=[{} for i in range(11)]\nfor i in range(n):\n    st=arr[i]\n    for j in range(11):\n        r=st % k\n        try:\n            d[j][r]+=1\n        except KeyError:\n            d[j][r] =1\n        st*=10\ncount_pair=0\nfor i in arr:\n    st=str(i)\n    l=len(st)\n    mod_st=(k-(i % k)) %k\n    if mod_st in d[l]:\n        count_pair +=d[l][mod_st]\n        if int(st + st) %k==0:\n            count_pair -=1\nprint(count_pair)","output":"nlogn"},{"instruction":"from math import inf\n\na=[0,0]\na[0]=[str(c)for c in list(input().strip()) ]\na[1]=[str(X) for X in list(input().strip())]\n\nan = [-inf,-inf,-inf]\nif a[0][0]==a[1][0]=='0':\n    an[0]=0\nelif  a[0][0]!=a[1][0]:\n    an[1]=0\nx=0\nfor i in range(1,len(a[0])) :\n\n    if an[0]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n\n            an=[-inf,0 ,-inf]\n        elif a[0][i]!=a[1][i]:\n            x+=1\n            an=[-inf]*3\n        else:\n            an = [-inf, -inf, -inf]\n    elif an[1]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n            an=[-inf,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            pass\n        else:\n            an=[-inf,-inf ,-inf]\n    else:\n        if a[0][i]==a[1][i]=='0':\n\n            an=[0,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            an=[-inf,0,-inf]\n        else:\n            an=[-inf,-inf ,-inf]\n\nprint(x)","output":"constant"},{"instruction":"a, b = map(int, input().split())\narr = list(map(int, input().split()))\nmn = float(\"inf\")\nfor i in range(1, a+1):\n    mn = min(mn, arr.count(i))\n\nprint(mn)","output":"quadratic"},{"instruction":"n = int(input())\ntr = {}\np = [int(s) for s in input().split()]\nfor i in range(n-1):\n    if not tr.get(p[i]-1):\n        tr[p[i]-1] = []\n    tr[p[i]-1].append(i+1)\n\nlc = [-1 for i in range(n)]\ndef get_lc(i):\n    if lc[i] == -1:\n        if tr.get(i):\n            lc[i] = 0\n            for j in tr[i]:\n                lc[i] += get_lc(j)\n        else:\n            lc[i] = 1\n    return lc[i]\nfor i in range(n-1, -1, -1):\n    get_lc(i)\nprint(*sorted(lc))","output":"linear"},{"instruction":"n,k = map(int,input().split())\narr = list(map(int,input().split()))\nbs = [[x,i+1] for i,x in enumerate(arr)]\nbs.sort(reverse=True)\ncs = [bs[i][1] for i in range(k)]\nans = sum(bs[i][0] for i in range(k))\ncs.sort()\nprint(ans)\nif k==1:\n    print(n)\nelse:\n    print(cs[0],end=\" \")\n\n    for i in range(1,k-1):\n        print(cs[i]-cs[i-1],end=\" \")\n    print(n-cs[k-2])","output":"nlogn"},{"instruction":"def solve(n, p, s):\n    p.append((0, 0))\n    p.sort()\n    t = 0\n    while p:\n        x = p.pop()\n        s, t = x[0], max(x[1], t + abs(s - x[0]))\n    return t\n\nn, s = [int(x) for x in input().split(' ')]\np = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]\n\nprint(solve(n, p, s))","output":"linear"},{"instruction":"from math import sqrt\nn, k = map(int, input().split())\na = 1\nb = -1 * (2*n + 3)\nc = n * (n + 1) - 2 * k\n\nres = (-1 * b) - sqrt((b * b) - 4 * a * c)\nres = res \/ 2\nres = int(res)\nprint(res)","output":"logn"},{"instruction":"n,s=int(input()),input()\np,q,r=len(set(s)),{},10**6\nfor i in range(n):\n    q[s[i]]=i\n    if len(q)==p:r=min(r,max(q.values())-min(q.values()))\nprint(r+1)","output":"linear"},{"instruction":"import sys\nimport os\nfrom io import IOBase, BytesIO\n\ndef main():\n    n = int(input())\n    x = 2 * n - 1\n    ans = x\n    x -= 2\n    curr = 0\n    while x > 0:\n        curr += x\n        x -= 2\n    print(ans + 2 * curr)\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill():\n            pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill()\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        py2 = round(0.5)\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2 == 1:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\ndef input(): return sys.stdin.readline().strip()\n\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"s=input()\nn=len(s)\nif(s[0]=='-'):\n    if(s[n-1]<s[n-2]):\n        s=s[::-1]\n        s=s.replace(s[1],\"\",1)\n        s=s[::-1]\n    else:\n        s=s[::-1]\n        s=s.replace(s[0],\"\",1)\n        s=s[::-1]\n    if(s==\"-0\"):\n        print(\"0\")\n    else:\n        print(s)\nelse:\n    print(s)","output":"constant"},{"instruction":"from math import gcd\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef func(l,r):\n    if l==1:\n        l+=1\n    if r-l<2:\n        return -1\n\n    if l&1:\n        if r-l>2:\n            l+=1\n            return '{} {} {}'.format(l,l+1,l+2)\n        else:\n            if gcd(l,l+2)!=1:\n                return '{} {} {}'.format(l,l+1,l+2)\n            return -1\n    return '{} {} {}'.format(l, l + 1, l + 2)\n\ndef main():\n    l,r=map(int,input().split())\n    print(func(l,r))\n    return\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"n, k = map(int, input().split())\nlst = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    lst.append([-a, b])\nlst.sort()\nprint(lst.count(lst[k-1]))","output":"nlogn"},{"instruction":"string = str(input())\nlength = len(string)\n\ncounter = 0\nli = []\nmatch_li = []\n\nfor i in range(length):\n    letter = string[i]\n    letters = letter\n    if letter in li:\n        match_li.append(letter)\n    li.append(letter)\n    for j in range(i+1, length):\n        letters += string[j]\n        if letters in li:\n            match_li.append(letters)\n        li.append(letters)\n\nlongest = 0\nfor k in match_li:\n    if len(k) > longest:\n        longest = len(k)\n\nprint(longest)","output":"cubic"},{"instruction":"n = int(input())\n\nnumber_sequence = [int(x) for x in input().split(\" \")]\nnumber_total = sum(number_sequence)\n\ncurrent_total = 0\ncurrent_position = 0\n\nfor number in number_sequence:\n    current_total = current_total + number\n    current_position = current_position + 1\n    if(current_total >= number_total\/2):\n        print(current_position)\n        break","output":"linear"},{"instruction":"from math import ceil\nn, k = map(int, input().split())\nprint(ceil(n*2\/k) + ceil(n*5\/k) + ceil(n*8\/k))","output":"constant"},{"instruction":"n,m=map(int,input().split())\ng=[[*input()] for _ in range(n)]\nc=[[0 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n v=0\n for j in range(m):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=v\n v=0\n for j in range(m-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor j in range(m):\n v=0\n for i in range(n):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\n v=0\n for i in range(n-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor i in range(n):\n for j in range(m):\n  if c[i][j]==1: c[i][j]=0\nfor i in range(n):\n v=0\n for j in range(m):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n v=0\n for j in range(m-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nfor j in range(m):\n v=0\n for i in range(n):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n for i in range(n-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nif all(g[i][j]=='.' for i in range(n) for j in range(m)):\n r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]]\n print(len(r))\n for t in r: print(*t)\nelse:\n print(-1)","output":"quadratic"},{"instruction":"x0, y0 = map(int, input().split())\nn = int(input())\narr = [[x0, y0]]\nfor i in range(0, n):\n    x, y = map(int, input().split())\n    arr.append([x, y])\ndist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]\nfor i in range(0, n+1):\n    for j in range(0, n+1):\n        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2\n\ndef dfs(status, memo, pp):\n\n    if memo[status] != None:\n        return memo[status]\n    if status < 0:\n        return 1e8\n    res = 1e8\n    prev = []\n    for i in range(1, n+1):\n        if (status & (1 << (i - 1))) == 0:\n            continue\n        t1 = status ^ (1 << (i - 1))\n\n        temp = dfs(t1, memo, pp) + dist[0][i]*2\n        if temp < res:\n            res = temp\n            prev = [i, 0]\n        for j in range(i+1, n+1):\n            if j == i:\n                continue\n            if (t1 & (1 << (j - 1))) == 0:\n                continue\n            next = t1 ^ (1 << (j - 1))\n            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]\n            if temp < res:\n                res = temp\n                prev = [i, j, 0]\n        break\n    memo[status] = res\n    pp[status] = prev\n\n    return res\n\nmemo = [None for i in range(0, 1 << n)]\npp = [None for i in range(0, 1 << n)]\nmemo[0] = 0\npp[0] = []\nstart = 0\nend = 0\nfor i in range(0, n):\n    end += (1 << i)\nres = dfs(end, memo, pp)\npath = [0]\ncur = end\n\nwhile cur > 0:\n    prev = pp[cur]\n\n    path.extend(prev)\n    for i in range(len(prev) - 1):\n        cur -= (1 << (prev[i] - 1))\n\nprint(res)\nprint(' '.join(map(str, path)))","output":"np"},{"instruction":"a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n\n        res = temp\n\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nr, g, b, = [int(_) for _ in input().split()]\nR = [int(_) for _ in input().split()]\nG = [int(_) for _ in input().split()]\nB = [int(_) for _ in input().split()]\nR = sorted(R, reverse=True)\nG = sorted(G, reverse=True)\nB = sorted(B, reverse=True)\n\ndp = []\nfor i in range(r+1):\n    sdp = [[0]*(b+1) for _ in range(g+1)]\n    dp.append(sdp)\n\nanswer = 0\nfor nb_taken in range(r+g+b):\n    if nb_taken % 2:\n        continue\n\n    for i in range(nb_taken+1):\n        if i > r:\n            break\n        for j in range(nb_taken-i-b, nb_taken-i+1):\n            if j > g:\n                break\n            k = nb_taken-i-j\n            if k > b:\n                continue\n            if i+j < k or i+k < j or j+k < i:\n                continue\n\n            if i < r and j < g:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])\n\n                answer = max(answer, dp[i+1][j+1][k])\n            if i < r and k < b:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])\n\n                answer = max(answer, dp[i+1][j][k+1])\n            if j < g and k < b:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])\n\n                answer = max(answer, dp[i][j+1][k+1])\n\nprint(answer)","output":"cubic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return (a * b) \/ gcd(a, b)\n\nmod = int(1e9) + 7\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n \/\/ 2)\n    return (t * t) % mod\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n \/\/= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n \/\/= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[a[i]] = i\n    found=[-1, -1, -1]\n    found2=[-1, -1]\n    for i in range(n):\n        c=1\n        while c<(1<<31):\n            if a[i]- c in d.keys() and a[i]+c in d.keys():\n                found[0]=a[i]-c\n                found[1]=a[i]\n                found[2]=a[i]+c\n            if a[i]- c in d.keys() :\n                found2=[a[i], a[i]-c]\n            if a[i]+ c in d.keys() :\n                found2=[a[i], a[i]+c]\n            c*=2\n    if found[0]==found[1]:\n        if found2[0]==found2[1]:\n            print(1)\n            print(a[0])\n        else:\n            print(2)\n            print(*found2)\n    else:\n        print(3)\n        print(*found)\n\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\nx,y = map(int, input().split())\nif y-x<2:\n\tprint(-1)\nelif x%2 != 0 and y-x==2:\n\tprint(-1)\nelif x%2==0:\n\tprint(x, x+1, x+2)\nelse:\n\tprint(x+1, x+2, x+3)","output":"constant"},{"instruction":"k = int(input())\n\nif k<=9:\n    print(k)\nelse:\n    num_arr = [9*(i+1)* 10**i for i in range(11)]\n\n    index = 0\n\n    while True:\n        if k<=num_arr[index]:\n            break\n        else:\n            k -= num_arr[index]\n            index += 1\n\n    digit = index+1\n    k += digit-1\n\n    num = k\/\/digit\n    offset = k%digit\n\n    string_num = str(10**(digit-1)+ num-1)\n\n    print(string_num[offset])","output":"logn"},{"instruction":"a = [int(i) for i in input().split()]\nn = a[0]\nk = a[1]\ni = 1\ncount = 0\ncursum = 0\nwhile(count<n):\n\tif(cursum < k):\n\t\tcursum += i\n\telse:\n\t\tbreak\n\tcount+=1\n\ti+=1\ncount += cursum-k\nif(n == count):\n\tprint(cursum - k)\nelse:\n\tans = cursum-k\n\textra = 0\n\twhile(count<n):\n\t\textra += i\n\t\tcount+=(i+1)\n\n\t\ti+=1\n\tprint(ans+extra)","output":"logn"},{"instruction":"def totaller(i):\n    if i==0:\n        return 0\n    else:\n        total1=totaller(i-1)+ 9*(10**(i-1))*i\n        return total1\n\nno_of_digits=int(input())\nj=0\nfor i in range(1,13):\n    if no_of_digits>=totaller(i):\n        j=i\nkth_digit=(no_of_digits-totaller(j))\/\/(j+1)\nif(((no_of_digits-totaller(j))%(j+1))!=0):\n    answer=str(kth_digit+10**j)\n\n    print(answer[((no_of_digits-totaller(j))%(j+1))-1])\nelse:\n    answer=str(kth_digit+10**j-1)\n    print(answer[((no_of_digits-totaller(j))%(j+1))-1])","output":"logn"},{"instruction":"n,m=map(int,input().split())\nc=input().split()\ncol=[0]*n\nfor i in range(len(c)):\n    col[int(c[i])-1]+=1\nprint(min(col))","output":"quadratic"},{"instruction":"def primecheck(x):\n\tcnt=0\n\tfor i in range(2,x\/\/2 +1):\n\t\tif x%i == 0:\n\t\t\tcnt+=1\n\t\t\tbreak\n\tif cnt :\n\t\treturn 1\n\telse:\n\t\treturn 0\n\nn = int(input())\nfor i in range(4,n):\n\tif primecheck(i) == 1 and primecheck(n-i) == 1:\n\t\tprint(str(i) + \" \"+ str(n-i))\n\t\tbreak","output":"constant"},{"instruction":"from sys import stdin, stdout\nmod=(10**9)+7\nmod1=mod-1\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p\n    return t\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport math\nimport heapq\nfrom random import randint as rn\nfrom Queue import Queue as Q\ndef comp(x,y):\n    if(x[0]<y[0]):\n        return -1\n    elif(x[0]==y[0]):\n        if(x[1]<y[1]):\n            return -1\n        else:\n            return 1\n    else:\n        return 1\nimport heapq\nk=[(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)]\ndef gg(i,j):\n    if(i<n-2 and j<m-2):\n        f=0\n        for g in range(8):\n            if(w[i+k[g][0]][j+k[g][1]]==\".\"):\n                f=1\n        if(f!=1):\n            for g in range(8):\n                p[i+k[g][0]][j+k[g][1]]=1\n\nn=input()\nw=n\nd=1\np=[]\nwhile(n!=1):\n    t=(n+1)\/2\n    for i in range(t):\n        p.append(str(d))\n    n-=t\n    if(n==1):\n        break\n    d*=2\nif(w%d==0):\n    p.append(str(w))\nelse:\n    g=w\/d\n    r=d*g\n    p.append(str(r))\nstdout.write(\" \".join(p))","output":"logn"},{"instruction":"from collections import defaultdict\n\ndef f(b,d):\n    fi = int(b[0])\n    if len(b)==1:\n        j=fi\n        while(j>=0):\n            if d[j]:\n                return str(j)\n            j+=-1\n\n        return \"\"\n\n    fi=int(b[0])\n    s=\"\"\n    if d[fi]>0:\n        d1=defaultdict(lambda:0)\n        for j in d:\n            d1[j]=d[j]\n        d1[fi]+=-1\n        s=f(b[1:],d1)\n\n    if s!=\"\":\n        return str(fi)+s\n\n    else:\n        s1=\"\"\n        j=fi-1\n        while(j>=0):\n            if d[j]>0:\n                s1+=str(j)\n                d[j]+=-1\n                break\n            j+=-1\n        if s1==\"\":\n            return \"\"\n        else:\n            j=9\n            while(j>=0):\n                if d[j]==0:\n                    j+=-1\n\n                else:\n                    s1+=str(j)\n                    d[j]+=-1\n\n            return s1\n\na=input()\nb=input()\nd=defaultdict(lambda:0)\nres=[]\nfor j in a:\n    d[int(j)]+=1\n    res.append(int(j))\nres.sort(reverse=True)\nfor j in range(len(a)):\n    res[j]=str(res[j])\nif len(b)>len(a):\n    print(\"\".join(res))\n\nelse:\n    print(f(b,d))","output":"cubic"},{"instruction":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        low, high = 1, n - 1\n        while low < high:\n            mid = low + (high - low) \/\/ 2\n            lessOrEqual = sum(1 for num in nums if num <= mid)\n\n            if lessOrEqual <= mid:\n                low = mid + 1\n            else:\n                high = mid\n\n        return low","output":"nlogn"},{"instruction":"def power(x, y, p) :\n    res = 1\n\n    x = x % p\n\n    while (y > 0) :\n\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\np = 1000000007\nx = [int(i) for i in raw_input().split()]\ny = power(2,x[1],p)\n\nif(x[0]>0):\n    ans = 2 * y * x[0]%p - (y - 1)%p\nelse:\n    ans = 0\nprint(ans%p)","output":"logn"},{"instruction":"n = int(input())\n\nlst = []\nfor x in range(n):\n    (a, b) = map(int, input().split())\n    lst.append((a, b))\n\ndef scal(x1, y1, x2, y2, x3, y3):\n    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:\n        return True\n    return False\n\ndef check():\n    for x in range(n - 2):\n        if len(s2) >= 3:\n            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n                return False\n        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):\n            s1.append(x + 2)\n        else:\n            s2.append(x + 2)\n    if len(s2) >= 3:\n        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n            return False\n    return True\n\nflag = True\n\nif n >= 5:\n    s1 = []\n    s2 = []\n    if not check():\n        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]\n        x = s2[0]\n        s1 = []\n        s2 = []\n        if not check():\n            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]\n            s1 = []\n            s2 = []\n            if not check():\n                flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"input_arr = [int(i) for i in input().split()]\na,b = input_arr\n\ndef dec_to_bin(N):\n    res=[0]*64\n\n    pos=0\n    while N!=0:\n        last_bit = N & 1\n        res[pos] = last_bit\n        pos+=1\n        N=N>>1\n    return res\n\ndef max_xor(a,b):\n    a_bin = dec_to_bin(a)\n    b_bin = dec_to_bin(b)\n\n    res = \"\"\n    x = \"\"\n    y = \"\"\n    diff_pt_found = False\n\n    for i in range(len(a_bin)-1,-1,-1):\n\n        if diff_pt_found == False and a_bin[i] == b_bin[i]:\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n\n        if diff_pt_found == False and a_bin[i] != b_bin[i]:\n            diff_pt_found = True\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n\n            res+=\"1\"\n            continue\n\n        if diff_pt_found == True:\n            if a_bin[i] != b_bin[i]:\n                res+=\"1\"\n                x+=str(a_bin[i])\n                y+=str(b_bin[i])\n            elif b_bin[i]==1:\n                res+=\"1\"\n\n                x+=str(a_bin[i])\n                y+=str(0)\n            elif a_bin[i]==0:\n                res+=\"1\"\n\n                x+=str(1)\n                y+=str(b_bin[i])\n\n    return x,y,res\n\ndef bin_to_dec(bin):\n    bin = str(bin)\n    mul = 1\n    res=0\n    for i in range(len(bin)-1,-1,-1):\n        if bin[i]=='1':\n            res+=mul\n\n        mul=mul*2\n\n    return res\n\nx,y,res = max_xor(a,b)\n\nprint(bin_to_dec(res))","output":"logn"},{"instruction":"def main():\n    n, m = map(int, input().split())\n    ll = [c == '*' for _ in range(n) for c in input()]\n    nm = n * m\n    RLUD = [*[range(i, i + m) for i in range(0, nm, m)],\n            *[range(i, nm, m) for i in range(m)]]\n    cc = [1000] * nm\n    for f in True, False:\n        for r in RLUD:\n            v = 0\n            for i in r:\n                if ll[i]:\n                    v += 1\n                    if cc[i] > v:\n                        cc[i] = v\n                else:\n                    v = cc[i] = 0\n        if f:\n            ll.reverse()\n            cc.reverse()\n    cc = [c if c != 1 else 0 for c in cc]\n    for f in True, False:\n        for r in RLUD:\n            v = 0\n            for i in r:\n                if v > cc[i]:\n                    v -= 1\n                else:\n                    v = cc[i]\n                if v:\n                    ll[i] = False\n        if f:\n            ll.reverse()\n            cc.reverse()\n    if any(ll):\n        print(-1)\n    else:\n        res = []\n        for i, c in enumerate(cc):\n            if c:\n                res.append(f'{i\/\/m+1} {i%m+1} {c-1}')\n        print(len(res), '\\n'.join(res), sep='\\n')\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from functools import lru_cache\n\nP = 10**9+7\nN, T = map(int, input().split())\nA = [[], [], []]\nX = []\nfor _ in range(N):\n    t, g = map(int, input().split())\n    X.append((t, g))\n\n@lru_cache(maxsize=None)\ndef calc(x, pr, t):\n    if t < 0:\n        return 0\n    if t == 0:\n        return 1\n    if x == 0:\n        return 0\n\n    ans = 0\n    for i in range(15):\n        if x & (1<<i):\n            if X[i][1] != pr:\n                y = x ^ (1<<i)\n                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P\n    return ans\n\nprint(calc(2**N-1, -1, T))","output":"np"},{"instruction":"n=int(input())\narr=list(map(int, input().split()))\ndict={}\nrawsum=0\na=n-1\nb=1\nfor i in range(n):\n    if i == 0:\n\t    rawsum = rawsum - (arr[i] * (a))\n\t    a-=1\n    elif i == n - 1:\n        rawsum = rawsum + (arr[i] * (b))\n        b+=1\n    else:\n        rawsum = rawsum + (arr[i] * (b))\n        rawsum = rawsum - ((arr[i] * (a)))\n        a-=1\n        b+=1\ni=n-1\nwhile i>=0:\n    if dict.get(arr[i])==None:\n        dict[arr[i]]=1\n    else:\n        dict[arr[i]]=dict[arr[i]]+1\n    s=arr[i]-1\n    g=arr[i]+1\n    if dict.get(s)!=None:\n        rawsum+=dict[s]\n    if dict.get(g)!=None:\n        rawsum-=dict[g]\n    i-=1\nprint(rawsum)","output":"nlogn"},{"instruction":"def I(): return(list(map(int,input().split())))\nn,l,r,x=I()\nc=I()\nl1=list(range(2**n))\nans=0\nfor j in l1:\n\ts=0\n\tnum=0\n\tma=0\n\tmi=100000000\n\tfor i in range(n):\n\t\tif (j & 1<<i):\n\t\t\tnum+=1\n\t\t\ts+=c[i]\n\t\t\tma=max(c[i],ma)\n\t\t\tmi=min(c[i],mi)\n\n\tif s<=r and l<=s and(ma-mi>=x) and num>=2 :\n\t\tans+=1\nprint(ans)","output":"np"},{"instruction":"a = [ord(e) - ord('0') for e in list(input().strip())]\nb = [ord(e) - ord('0') for e in list(input().strip())]\n\na.sort(reverse=True)\nh = [0 for i in range(10)]\nfor x in a:\n    h[x] += 1\n\nif len(a) < len(b):\n    print(''.join(map(str, a)))\n    exit(0)\n\ndef gmax(hx):\n    s = list(hx)\n    res = list()\n    for i in range(9, -1, -1):\n        while s[i] > 0:\n            res.append(i)\n            s[i] -= 1\n    return res\n\ndef gmin(hx):\n    s = list(hx)\n    res = list()\n    for i in range(10):\n        while s[i] > 0:\n            res.append(i)\n            s[i] -= 1\n    return res\n\nres = list()\n\ndef finalize(x):\n    for y in range(x-1, -1, -1):\n        if h[y] > 0:\n            res.append(y)\n            h[y] -= 1\n            for i in range(9, -1, -1):\n                while h[i] > 0:\n                    res.append(i)\n                    h[i] -= 1\n            return\n\np = 0\nwhile p < len(a):\n    x = b[p]\n    if h[x] > 0:\n        hh = list(h)\n        hh[x] -= 1\n        if b[p+1:] >= gmin(hh):\n            res.append(x)\n            h[x] -= 1\n        else:\n            finalize(x)\n            break\n    else:\n        finalize(x)\n        break\n    p += 1\nprint(''.join(map(str, res)))","output":"cubic"},{"instruction":"n, t = map(int, input().split())\narr = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    arr.append((a-(b \/ 2), a+ (b \/ 2)))\n\narr.sort()\nans = 0\nfor i in range(1, n):\n    if abs(arr[i][0] - arr[i - 1][1]) == t:\n        ans += 1\n    elif abs(arr[i][0] - arr[i - 1][1]) > t:\n        ans += 2\nprint(ans + 2)","output":"nlogn"},{"instruction":"s=int(input())\nu=True\nfor i in [4,7,47,74,447,474,477,747,774]:\n    if s%i==0:\n        u=False\n        print(\"YES\")\n        break\nif u:\n    print(\"NO\")","output":"constant"},{"instruction":"from math import ceil\n\nn=int(input())\nd={1:[1],2:[1,2],3:[1,1,3]}\nif n in d:\n    for i in d[n]:\n        print(i,end=' ')\n    exit()\ndef f(n):\n    if n in d:\n        return d[n]\n    odds=ceil(n\/2)\n    lis=[1]*odds\n    even=n\/\/2\n    lis1=f(even)\n    for i in range(len(lis1)):\n        lis1[i]*=2\n    return lis+lis1\nans=f(n)\nfor i in ans:\n    print(i,end=' ')","output":"nlogn"},{"instruction":"a = input()\nb = input()\no = []\nz = []\nc0 = 0\nc1 = 0\nfor i in b:\n    if i == \"0\":\n        c0 += 1\n\n    else:\n        c1 += 1\n\n    o.append(c1)\n    z.append(c0)\n\nn = len(b)-1\nm = len(a)-1\nans = 0\nfor i in range(len(a)):\n    x = a[i]\n    if x == \"1\":\n        ans += z[(n-(m-i))]-z[i]\n        if b[i] == \"0\":\n            ans += 1\n\n    else:\n        ans += o[(n - (m - i))] - o[i]\n        if b[i] == \"1\":\n            ans += 1\n\nprint(ans)","output":"linear"},{"instruction":"from sys import stdin\ninput = stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nl=[]\nfor i in range(n):\n    l.append((arr[i],i))\n\nl.sort(reverse=True)\n\ndp=[]\nx=0\nfor i in range(k):\n    dp.append(l[i][1])\n    x=x+l[i][0]\n\nprint(x)\ndp.sort()\ndp=[-1]+dp\n\nl=len(dp)\nfor i in range(1,l-1):\n    print(dp[i]-dp[i-1],end=\" \")\nprint(n-1-dp[l-2])","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nans = 0\nsum = 0\nmp = {}\nfor i in range(n):\n    x = a[i]\n    ans += (x * i) - sum;\n    ans -= (mp.get(x - 1, 0));\n    ans -= (-mp.get(x + 1, 0));\n    mp[x] = mp.get(x, 0) + 1;\n    sum += x;\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin\n\nn, m = map(int, stdin.readline().split())\nans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))\nnum, cur, i = 1, 0, 0\n\nwhile i < len(p) and m > 0 and num <= n:\n    cur += p[i]\n    if cur >= m:\n        m -= (cur - p[i])\n        cur = 0\n        ans.append(num)\n        all.discard(num)\n    num += 1\n    i += 1\n\nprint(' '.join(map(str, ans + sorted(all)[::-1])))","output":"np"},{"instruction":"from sys import stdin, stdout\nn,m,k = [int(x) for x in stdin.readline().rstrip().split()]\nL = [int(x) for x in stdin.readline().rstrip().split()]\noff=1\npage=-1\nc=0\nans=0\nfor l in L:\n    p=(l-off)\/\/k\n    if p==page:\n        c+=1\n    else:\n        off+=c\n        c=1\n        ans+=1\n        page=(l-off)\/\/k\n\nstdout.write( str(ans) + \"\\n\" )","output":"linear"},{"instruction":"m={\"s\":[0]*9, \"m\":[0]*9, \"p\":[0]*9}\nfor e in input().split():\n    m[e[1]][int(e[0])-1]+=1\nret=2\nfor t in \"smp\":\n    l=m[t]\n    if max(l)>=2:\n        ret=min(ret, 3-max(l))\n    else:\n        for i in range(7):\n            seq = sum(l[i:i+3])\n            ret = min(ret, 3-seq)\nprint(ret)","output":"linear"},{"instruction":"import bisect\nimport time\ndef ass(a, b): print(f\"Assertion error: {a} != {b}\" if a != b else 'OK')\ndef nr(): return int(input())\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2, n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\ncache = {}\n\ndef get_mask(num):\n\tkey = num\n\tif key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num \/\/ p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\tcache[key] = num\n\treturn num\n\ndef dump(dp):\n\tfor i,line in enumerate(dp):\n\t\tprint(i%10,line)\n\ndef get_left(n,k,lst):\n\tlast_in = {}\n\ts = []\n\tres = []\n\tfor i in range(n):\n\t\tgroup = get_mask(lst[i])\n\t\tif group in last_in: bisect.insort(s, last_in[group] + 1)\n\t\tlast_in[group] = i\n\t\tif len(s) <= k+1:\n\t\t\tres.append(s[::-1])\n\t\telse:\n\t\t\tm = len(s)\n\t\t\tres.append(s[m-1:m-k-2:-1])\n\treturn res\n\ndef get_dp(n,k,lst):\n\tres = []\n\tleft = get_left(n,k,lst)\n\tfor i in range(n):\n\t\tarr = left[i]\n\t\trow = [n] * (k+1)\n\t\tfor j in range(k+1):\n\t\t\tfor g in range(j+1):\n\t\t\t\tif g >= len(arr):\n\t\t\t\t\trow[j] = 1\n\t\t\t\telse:\n\t\t\t\t\tindex = arr[g]-1\n\t\t\t\t\tjindex = j-g\n\t\t\t\t\trow[j] = min(res[index][jindex] + 1, row[j])\n\t\tres.append(row)\n\treturn res\n\ndef f(n,k,lst):\n\tdp = get_dp(n,k,lst)\n\tprint(dp[n-1][k])\n\nprime = get_prime(3162)\n\nfor _ in range(nr()):\n\tn,k = nrs()\n\tf(n,k,nrs())","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\ndef get_ans(x):\n\n    lim = 1<<m\n    match = lim-1\n    track = [-1 for i in range(lim)]\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if(a[i][j] >= x):\n                mask |= 1 << j\n        track[mask] = i\n\n    for i in range(lim):\n        for j in range(lim):\n            if(i|j == match and track[i] != -1 and track[j] != -1):\n                return track[i], track[j]\n\n    return -1, -1\n\nlo = 0\nhi = 1000000000\nwhile(lo < hi-1):\n    mid = (lo+hi)\/2\n    i, j = get_ans(mid)\n    if(i == -1):\n        hi = mid-1\n    else:\n        lo = mid\n\ni,j = get_ans(hi)\nif(i != -1):\n    print(\"{} {}\".format(i+1,j+1))\nelse:\n    i,j = get_ans(lo)\n    print(\"{} {}\".format(i+1,j+1))","output":"np"},{"instruction":"def wb(n,m,flip=False):\n    w = b = n*m \/\/ 2\n    if n%2 == 1 and m %2 == 1:\n        w += 1\n    if flip:\n        return b,w\n    else:\n        return w,b\n\nt = int(input())\nfor tt in range(t):\n    n,m = map(int, input().split())\n    x1,y1,x2,y2 = map(int, input().split())\n    x3,y3,x4,y4 = map(int, input().split())\n    x5 = max(x1,x3)\n    x6 = min(x2,x4)\n    y5 = max(y1,y3)\n    y6 = min(y2,y4)\n    ov = False\n    if x6-x5 >= 0 and y6-y5 >= 0:\n        ov = True\n    w,b = wb(n,m)\n    wm,bm = wb(x2-x1+1, y2-y1+1, (x1+y1)%2==1)\n    wd,bd = wb(x4-x3+1, y4-y3+1, (x3+y3)%2==1)\n    if ov:\n        wo,bo = wb(x6-x5+1, y6-y5+1, (x5+y5)%2==1)\n    else:\n        wo,bo = 0,0\n\n    w = w+bm-wd-bo\n    b = b-bm+wd+bo\n    print(w,b)","output":"constant"},{"instruction":"n, s = input().split()\n\nn = int(n)\ns = int(s)\n\ndef get_decimal_value_digits(number):\n    count = 0\n    digits = 0\n    number = str(number)\n    for digit in number:\n        count += int(digit)\n        digits += 1\n    return count\n\ndef is_big_num(number, s):\n    if (number - get_decimal_value_digits(number)) >= s:\n        return True\n    return False\n\nstart = s\nend = n\ncount = 0\ndigits = 0\nhalf = (n + s) \/\/ 2\n\nwhile (end - start) >= 0:\n    half = (start + end) \/\/ 2\n\n    if is_big_num(half, s):\n        end = half - 1\n    else:\n        start = half + 1\n\nif not is_big_num(start+1, s):\n    print(0)\nelse:\n    print(n - start + 1)","output":"logn"},{"instruction":"import sys\ninput=lambda:sys.stdin.readline().rstrip()\n\nh,w=map(int,input().split())\ns=[list(\".\"*(w+2))]+[list(\".\"+input()+\".\") for _ in range(h)]+[list(\".\"*(w+2))]\nb=[[0]*(w+2)for _ in range(h+2)]\nc=[[0]*(w+2)for _ in range(h+2)]\nfor i in range(1,h+2):\n  for j in range(1,w+2):\n    if s[i][j]==\"*\":\n      b[i][j]=b[i-1][j]+1\n      c[i][j]=c[i][j-1]+1\nfor i in range(h,-1,-1):\n  for j in range(w,-1,-1):\n    if s[i][j]==\"*\":\n      b[i][j]=min(b[i][j],b[i+1][j]+1)\n      c[i][j]=min(c[i][j],c[i][j+1]+1)\nans=[]\nfor i in range(1,h+1):\n  for j in range(1,w+1):\n    t=min(b[i][j],c[i][j])-1\n    if t>0:\n      ans.append((i,j,t))\nb=[[0]*(w+2)for _ in range(h+2)]\nc=[[0]*(w+2)for _ in range(h+2)]\nfor i,j,t in ans:\n  b[i-t][j]+=1\n  b[i+t+1][j]-=1\n  c[i][j-t]+=1\n  c[i][j+t+1]-=1\nfor i in range(h+1):\n  for j in range(w+1):\n    b[i+1][j]+=b[i][j]\n    c[i][j+1]+=c[i][j]\n    if i!=0 and j!=0:\n      if (b[i][j]+c[i][j]>0)!=(s[i][j]==\"*\"):\n        print(-1)\n        exit()\n\nprint(len(ans))\nfor i in ans:print(*i)","output":"quadratic"},{"instruction":"N = 1010\n\ndp = [[[0] * 4 for j in range(N*2)] for i in range(N)]\ndp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1\nm = 998244353\nfor i in range(N-1):\n    for j in range(1,N*2-5):\n        for me in range(4):\n            for he in range(4):\n                if me <= 1:\n                    if he <= 1:\n                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m\n                else:\n                    if he <= 1:\n                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m\nn,k = map(int,input().split())\nprint(sum(dp[n-1][k])%m)","output":"np"},{"instruction":"import bisect\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return bisect.bisect_left(p, p[-1] \/ 2)\n\nprint(solve())","output":"linear"},{"instruction":"n,m=map(int,input().split())\narr=[ int(x) for x in input().split()]\n\narr=sorted(arr,reverse=True)\narr.append(0)\n\nisum=sum(arr)\nans=[]\ntop=arr[0]\nfor i in range(n):\n\tif(arr[i]==1):\n\t\tans.append(1)\n\t\tarr[i+1]=1\n\t\tcontinue\n\tif(arr[i+1] >arr[i]):\n\t\tarr[i+1]=arr[i]\n\tif arr[i]-arr[i+1]==0:\n\t\tans.append(1)\n\t\th=1\n\telse:\n\t\tans.append(arr[i]-arr[i+1])\n\t\th=arr[i]-arr[i+1]\n\n\ttop=arr[i]-h\n\tarr[i+1]=top\n\nprint(isum-sum(ans))","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\nn=int(input())\na=list(map(int,input().split()))\nbi=Bit(n+1)\nc=0\nfor i,x in enumerate(a):\n    bi.add(x,1)\n    c+=i+1-bi.sum(x)\nif c%2==n%2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"import sys\n\ndef ask(c, d):\n    print(\"? {} {}\".format(c, d))\n    return int(input())\n\nc = d = 0\n\ndef solve(mi, base):\n    def solve_same():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d)\n            res2 = ask(c, d ^ bit)\n            if res1 == -1 and res2 == 1:\n                c |= bit\n                d |= bit\n\n    def solve1():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == -1:\n\n                c |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n\n                res2 = ask(c ^ bit, d)\n                if res2 == -1:\n\n                    c |= bit\n                    d |= bit\n\n    def solve2():\n        global c, d\n        print(\"\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == 1:\n\n                d |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n\n                res2 = ask(c, d ^ bit)\n                if res2 == 1:\n\n                    c |= bit\n                    d |= bit\n\n    if base == 0:\n        solve_same()\n    elif base == 1:\n        solve1()\n    else:\n        solve2()\n\nsolve(29, ask(0, 0))\nprint(\"! {} {}\".format(c, d))","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(uses+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, uses+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"l,r=input().split(\" \")\nl,r=int(l),int(r)\n\na,b,c=l,l+1,l+2\n\nif (l % 2 != 0):\n    a,b,c=a+1,b+1,c+1\n\nif (c > r):\n    print(-1)\n\nelse:\n    print(a,b,c)","output":"constant"},{"instruction":"T = int(input())\nfor ti in range(T):\n    s, t = input().strip(), input().strip()\n    N = len(t)\n    for i in range(1, N+1):\n\n        dp = [0]+[-1]*i\n        for l, c in enumerate(s):\n            for j in range(i, -1, -1):\n\n                tmp = dp[j]\n\n                if dp[j] != -1 and i+dp[j] < N and t[i+dp[j]] == c:\n                    tmp = dp[j]+1\n\n                if j != 0 and t[j-1] == c:\n                    tmp = max(tmp, dp[j-1])\n                dp[j] = tmp\n        if dp[i] == N-i:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"n=int(input())\nc=0\nfor j in range(2,1+n\/\/2):\n\te=0\n\ti=n\/\/j\n\te+=(i*(i+1))\/\/2\n\te-=1\n\tif e>0:\n\t\tc+=e\nprint(c*4)","output":"linear"},{"instruction":"def main():\n    n = int(input())\n    left = [int(x) for x in input().strip().split()]\n    right = [int(x) for x in input().strip().split()]\n    rank = [x + y for (x,y) in zip(left,right)]\n    arr = [(n - r) for r in rank]\n\n    for i in range(n):\n        more = 0\n        for j in range(i):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != left[i]:\n            print('NO')\n            return\n\n    for i in range(n):\n        more = 0\n        for j in range(i+1,n):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != right[i]:\n            print('NO')\n            return\n\n    print('YES')\n    for x in arr:\n        print(x, end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from sys import stdin, stdout, exit\n\nn, m, k = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\n\ndef bf(a):\n    best = 0\n    best_arg = (-1, -1)\n    for i in range(n):\n        for j in range(i, n):\n            cur = sum(a[i:j+1]) - k*((j - i) \/\/ m + 1)\n            if cur > best:\n                best = max(best, cur)\n                best_arg = (i,j)\n    return best, best_arg\n\ndef max_sum(a):\n    if len(a) == 0:\n        return 0\n    elif len(a) == 1:\n        return max(0, a[0] - k)\n    mid = len(a) \/\/ 2\n    l_rec = max_sum(a[:mid])\n    r_rec = max_sum(a[mid:])\n    l_bests = [0]*m\n    r_bests = [0]*m\n    l_sum = 0\n    for idx in range(1,mid+1):\n        l_sum += a[mid-idx]\n        if idx % m == 0:\n            l_sum -= k\n        l_bests[idx%m] = max(l_bests[idx%m], l_sum)\n    r_sum = 0\n    for idx in range(0, len(a)-mid):\n        r_sum += a[idx+mid]\n        if (idx+1) % m == 0:\n            r_sum -= k\n        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)\n\n    best_acr = 0\n    for i in range(m):\n        for j in range(m):\n            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))\n    ans = max(l_rec,r_rec, best_acr)\n\n    return ans\n\nans = max_sum(a)\nstdout.write(str(ans) + \"\\n\")","output":"quadratic"},{"instruction":"from collections import Counter\nimport math\nl=list(input())\nl1=list(input())\na=Counter(l)\nb=Counter(l1)\nif a['+']<b['+'] or a['-']<b['-']:\n\tprint(\"0\")\n\texit()\nelse:\n\ta1=a['+']-b['+']\n\tb1=a['-']-b['-']\ns=(math.factorial(a1+b1))\/\/((math.factorial(a1))*(math.factorial(b1)))\ns1=float(2**(a1+b1))\nprint(s\/s1)","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\ndef check(a,mid,n,m,z):\n    b=Counter()\n    for i in range(n):\n        c=[\"0\"]*m\n        for j in range(m):\n            if a[i][j]>=mid:\n                c[j]=\"1\"\n        zz=int(\"\".join(c),2)\n        b[zz]=i\n    c=list(b.keys())\n    lc=len(c)\n    for i in range(lc):\n        for j in range(i,lc):\n            if c[i]|c[j]==z:\n                mi,x,y=10000000000,b[c[i]],b[c[j]]\n                for k in range(m):\n                    mi=min(mi,max(a[x][k],a[y][k]))\n                if mi>=mid:\n                    return (x,y)\ndef main():\n    n,m= map(int, input().split())\n    a=[list(map(int,input().split())) for _ in range(n)]\n    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1\n    while lo<=hi:\n        mid=(lo+hi)\/\/2\n        z=check(a,mid,n,m,y)\n        if z:\n            lo=mid+1\n            ans=[z[0]+1,z[1]+1]\n        else:\n            hi=mid-1\n    print(*ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"class Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        mp = defaultdict(int)\n        for i in intervals:\n            mp[i.start] += 1\n            mp[i.end] -= 1\n        prev = 0\n        res = 0\n        for i in sorted(mp.keys()):\n            prev += mp[i]\n            res = max(res, prev)\n        return res","output":"nlogn"},{"instruction":"import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\nadj_in_subset = [0] * (1 << m)\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        adj_in_subset[(1 << c1) + (1 << c2)] += 1\nfor i in range(m):\n    for j in range(1 << m):\n        if j & (1 << i):\n            adj_in_subset[j] += adj_in_subset[j ^ (1 << i)]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)\nprint(dp[-1])","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\nout = sys.stdout\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        out.write(str(a[0])+\" \"+str(a[0])+\" \"+str(a[0])+\" \"+str(a[0])+\"\\n\")\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            out.write(str(mx)+\" \"+str(mx)+\" \"+str(mx)+\" \"+str(mx)+\"\\n\")\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            out.write(str(res[minj])+\" \"+str(res[minj])+\" \"+str(res[minj+1])+\" \"+str(res[minj+1])+\"\\n\")","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nmx = a[-1]\nt = 0\nans = 0;\nfor i in a:\n    if i > 0:\n        if i > t:\n            t += 1\n        ans += i - 1\nans -= mx - t\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\ninput=lambda : sys.stdin.readline().strip()\nchar = [chr(i) for i in range(97,123)]\nCHAR = [chr(i) for i in range(65,91)]\nmp = lambda:list(map(int,input().split()))\nINT = lambda:int(input())\nrn = lambda:range(INT())\n\nfrom math import ceil,sqrt,factorial,gcd\n\nr,g,b = mp()\nrl = sorted(mp(),reverse=True)\ngl = sorted(mp(),reverse=True)\nbl = sorted(mp(),reverse=True)\n\ndef solve(i,j,k):\n\tif dp_table[i][j][k] != -1:\n\t\treturn dp_table[i][j][k]\n\n\tif i < r and j < g and k < b:\n\t\tm = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))\n\t\tdp_table[i][j][k] = m\n\t\treturn m\n\n\telif i < r and j < g:\n\t\tm = solve(i+1,j+1,b) + rl[i]*gl[j]\n\t\tdp_table[i][j][k] = m\n\t\treturn m\n\n\telif i < r and k < b:\n\t\tm = solve(i+1,g,k+1) + (rl[i]*bl[k])\n\t\tdp_table[i][j][k] = m\n\t\treturn m\n\n\telif j < g and k < b:\n\t\tm = solve(r,j+1,k+1) + (gl[j]*bl[k])\n\t\tdp_table[i][j][k] = m\n\t\treturn m\n\telse:\n\t\treturn 0\n\ndp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]\nres = solve(0,0,0)\nprint(res)","output":"cubic"},{"instruction":"from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\nn, s = map(int, stdin.readline().split())\nstdout.write(str((s + n - 1) \/\/ n))","output":"constant"},{"instruction":"from itertools import combinations\n\np, minn, maxn, dif = map(int, input().split())\n(*lst,) = map(int, input().split())\nprint(sum([sum([(maxn>=sum(j)>=minn)and((max(j)-min(j))>=dif) for j in combinations(lst,i)]) for i in range(2,p+1)]))","output":"np"},{"instruction":"n, k =map(int,input().split())\na = list(map(int, input().split()))\nif n == 1:\n    print(a[0])\n    print(1)\nelse:\n    lst = sorted(a)[-k:]\n    ans = sum(lst)\n    print(ans)\n    c = 0\n    ln = len(lst)\n    ans = [0]\n    cnt = 0\n    for i in range(n):\n        if cnt == k - 1:\n            break\n        for j in range(ln):\n            if a[i] == lst[j]:\n                lst[j] = -1\n                ans.append(i + 1)\n                cnt += 1\n                break\n    ln = len(ans)\n    for i in range(1,ln):\n        print(ans[i] - ans[i - 1], end = \" \")\n    print(n - ans[-1])","output":"nlogn"},{"instruction":"a,b,c,n=map(int,input().split())\nif n-a-b+c>=1:\n    if a<c or b<c:\n        print(-1)\n    else:\n        print(n-a-b+c)\nelse:\n    print(-1)","output":"constant"},{"instruction":"n, m = map(int, input().split(' '))\n\ndistances = list(map(int, input().split(' ')))\ntaxiDriver = list(map(int, input().split(' ')))\n\npeople = []\ndrivers = []\nresult = [0] * m\n\nfor i in range(len(distances)):\n  if(taxiDriver[i]):\n    drivers.append(distances[i])\n  else:\n    people.append(distances[i])\n\nj = 0\n\nfor person in people:\n  if (j + 1) < len(drivers):\n    while (j + 1) < len(drivers) and (drivers[j] - person) < (person - drivers[j + 1]) :\n      j += 1\n\n    result[j] += 1\n  else:\n    result[j] += 1\n\nprint(' '.join(map(str, result)))","output":"nlogn"},{"instruction":"n,k=map(int,input().strip().split())\nv = []\nfor i in range(2,n+1):\n\tif all(i%j!=0 for j in v):\n\t\tv.append(i)\nc = 0\nfor i in range(len(v)-1):\n\tif 1+v[i]+v[i+1] in v:\n\t\tc += 1\nif c >= k:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"linear"},{"instruction":"import math as mt\nimport itertools as it\nn,l,r,x=map(int,input().split())\na=list(map(int,input().split()))\nans=0\nfor j in range(2,n+1):\n    for i in it.combinations(a,j):\n        if max(i)-min(i)>=x and l<=sum(i)<=r:\n            ans+=1\nprint(ans)","output":"np"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\n\ndef isPrime(n) :\n\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n\n    prime_factors = []\n\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nl=sorted(a, reverse=True)\ndic={}\ntotalprofit=0\nfor i in range(k):\n    totalprofit+=l[i]\n    if l[i] in dic:\n        dic[l[i]]+=1\n    else:\n        dic[l[i]]=1\nans=[]\ncount=0\nfor i in range(n):\n    if a[i] in dic:\n        count+=1\n        if dic[a[i]]==1:\n            del dic[a[i]]\n        else:\n            dic[a[i]]-=1\n        if not dic:\n            count-=1\n            ans.append(count+ n-i)\n            break\n        else:\n            ans.append(count)\n        count=0\n    else:\n        count+=1\nprint(totalprofit)\nprint(*ans)","output":"nlogn"},{"instruction":"import sys\nclass Graph:\n    verticies = {}\n    nodesCount = 0\n\n    class Vertex:\n        def __init__(self, label, endPoint=None):\n            self.label = label\n            self.edges = []\n            self.visitedToken = 0\n            self.endPoint = endPoint\n\n    class Edge:\n        residual = None\n\n        def __init__(self, from_, to_, isResidual, maxCapacity):\n            self.from_ = from_\n            self.to_ = to_\n            self.isResidual = isResidual\n            self.capacity = maxCapacity\n            self.flow = 0\n\n        def augment(self, bootleneck):\n            self.flow += bootleneck\n            self.residual.flow -= bootleneck\n\n        def remainingCapacity(self):\n            return self.capacity - self.flow\n\n    def addEdge(self, from_, to_, capacity):\n        from_ = self.verticies[from_]\n        to_ = self.verticies[to_]\n        if from_.endPoint and from_.endPoint != to_:\n            from_ = from_.endPoint\n\n        main = self.Edge(from_, to_, False, capacity)\n        residual = self.Edge(to_, from_, True, 0)\n\n        main.residual = residual\n        residual.residual = main\n\n        from_.edges.append(main)\n        to_.edges.append(residual)\n\n    def addVertex(self, label, *args):\n        self.nodesCount += 1\n        self.verticies[label] = self.Vertex(label)\n\n    def maxFlow(self, f, t):\n        f = self.verticies[f]\n        t = self.verticies[t]\n        visitedToken = 1\n        flow = 0\n\n        def dfs(node, bootleneck=sys.maxsize):\n            node.visitedToken = visitedToken\n            bootleneck_backup = bootleneck\n\n            if node == t:\n                return bootleneck\n\n            for edge in node.edges:\n                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:\n                    continue\n\n                bootleneck = dfs(edge.to_, min(\n                    bootleneck, edge.remainingCapacity()))\n                if bootleneck:\n                    edge.augment(bootleneck)\n                    return bootleneck\n                else:\n                    bootleneck = bootleneck_backup\n\n            return 0\n\n        while True:\n            bootleneck = dfs(f)\n\n            if not bootleneck:\n                break\n\n            flow += bootleneck\n            visitedToken += 1\n\n        return flow\n\ng = Graph()\n\nn, m = map(int, input().split())\nvv = list(map(int, input().split()))\n\nfor i in range(n+m+2):\n    g.addVertex(i)\n\nfor i, v in enumerate(vv):\n    g.addEdge(m+i+1, n+m+1, v)\n\ns = 0\n\nfor i in range(1, m+1):\n    a, b, c = map(int, input().split())\n    s += c\n\n    g.addEdge(0, i, c)\n    g.addEdge(i, a+m, c)\n    g.addEdge(i, b+m, c)\n\nprint(s-g.maxFlow(0, n+m+1))","output":"cubic"},{"instruction":"from itertools import*\n\nmoves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]\n\ndef ac(l,x):\n\tif l==0: return 0\n\treturn l[x] if 0<=x<len(l) else 0\n\ndef work():\n\tx=1\n\twhile x:\n\t\tx=0\n\t\tfor r in range(len(a)):\n\t\t\tfor c in range(len(a[0])):\n\t\t\t\tif not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:\n\t\t\t\t\ta[r][c]=1\n\t\t\t\t\tx=1\n\nfor n in [int(input())]:\n\n\tcand=set()\n\n\tfor i in range(1000):\n\t\tfor x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):\n\t\t\tif x==0 or x%3!=1:\n\t\t\t\tif n==len(cand): break\n\t\t\t\tcand.add((x,y))\n\n\tassert len(cand)==n\n\n\tfor x,y in cand: print(x,y)","output":"constant"},{"instruction":"n=2*int(input())\na=list(map(int,input().split()))\nz=0\nfor i in range(0,n-1,2):\n    if a[i]!=a[i+1]:\n        for j in range(i+1,n):\n            if a[j]==a[i]:\n                z+=j-i-1\n                a.pop(j)\n                a.insert(i+1,a[i])\nprint(z)","output":"quadratic"},{"instruction":"n = int(input())\nb = list(map(int, input().split(' ')))\ne = [[-1] * (n+1) for _ in range(2048)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2048):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\tif j != -1:\n\t\t\th = e[v][j+1]\n\t\telse:\n\t\t\th = -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\tif s > 0:\n\t\t\ttemp = a[s-1]+1\n\t\telse :\n\t\t\ttemp = 1\n\t\ta[e] = min(a[e], temp)\nprint(a[n-1])","output":"cubic"},{"instruction":"x = int(input())\nprint(0,0,x)","output":"constant"},{"instruction":"n,s=map(int,input().split())\nlo,hi=s,n\nans=n+1\nwhile lo<=hi:\n    mid=(lo+hi)\/\/2\n    z=sum(map(int,str(mid)))\n    if mid>=s+z:\n        ans=mid\n        hi=mid-1\n    else:\n        lo=mid+1\nprint(n-ans+1)","output":"logn"},{"instruction":"i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s \/ g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))","output":"quadratic"},{"instruction":"n = int(input())\nmelody = [int(x) for x in input().split()]\nref = [[-1] * 5 for _ in range(n)]\ncan_finish = [[False] * 5 for _ in range(n)]\ncan_finish[0] = [True] * 5\n\nfor idx, key in enumerate(melody[:-1]):\n    if not any(can_finish[idx]):\n        break\n    for finger in range(5):\n        if melody[idx] < melody[idx + 1] and can_finish[idx][finger]:\n            for i in range(finger + 1, 5):\n                can_finish[idx + 1][i] = True\n                ref[idx + 1][i] = finger\n            break\n        elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0:\n            for i in range(finger):\n                can_finish[idx + 1][i] = True\n                ref[idx + 1][i] = finger\n        elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]:\n            tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger]\n            can_finish[idx + 1] = [True] * 5\n            ref[idx + 1] = [finger] * 5\n            can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref\n\nfinger = next((i for i in range(5) if can_finish[n - 1][i]), None)\nif finger is None:\n    print(-1)\nelse:\n    seq = [finger]\n    for i in range(n - 1, 0, -1):\n        finger = ref[i][finger]\n        seq.append(finger)\n    print(' '.join(str(x + 1) for x in seq[::-1]))","output":"quadratic"},{"instruction":"from math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *\nfrom fractions import *\nfrom sys import *\nfrom types import CodeType, new_class\n\nk, n, s, p = map(int, input().split())\nprint((k*(n\/\/s + (n%s != 0))) \/\/ p + ((k*(n\/\/s + (n%s != 0))) % p != 0))","output":"constant"},{"instruction":"def pow(x, p):\n    ret = 1\n    for i in range(p): ret=ret*x\n    return ret\n\ndef rate(p):\n    ret = 0\n    now = 1\n    for i in range(p):\n        ret = ret + now\n        now = now * 4\n    return ret\n\ndef solve():\n    n, k = map(int, input().split())\n    if (n>35):\n        print(\"YES %d\" % (n-1))\n        return\n    mSplit = 1\n    cnt1 = 0\n    cnt3 = 1\n    for i in range(1, n+1):\n        now = pow(4, i) - pow(2, i+1) + 1\n        now = now * rate(n-i) + rate(i)\n\n        if (k<=now):\n            print(\"YES %d\" % (n-i))\n            return\n        mSplit = mSplit + cnt1 + cnt3 * 3\n        cnt1 = cnt1 + cnt3\n        cnt3 = cnt3 + cnt3\n        if (mSplit>k): break\n    print(\"NO\")\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        solve()\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"num=int(input())\n\nb=input()\n\nif b=='0' or b=='1':\n    print(b)\n\nelse:\n    s=len(list(filter(lambda x:x=='0',b)))\n\n    print('1'+'0'*s)","output":"linear"},{"instruction":"from math import log10\nfrom collections import Counter\n\nn,k=[int(x) for x in input().split()]\nlst=[int(x) for x in input().split()]\nlst2=[]\n\nfor i in range(n):\n    lst2.append(((lst[i]%k),len(str(lst[i]))))\n\ndp = [[] for i in range(12)]\nfor j in lst2:\n    dp[j[1]].append(j[0])\nfor i in range(12):\n    if len(dp[i]) > 0:\n        dp[i] = Counter(dp[i])\nans = 0\nfor i in lst:\n    for j in range(2, 12):\n        v1 = ((i%k) * pow(10, j-1))%k\n        if (k - v1)%k in  dp[j-1]:\n            ans=ans+dp[j-1][(k-v1)%k]\nfor i in lst:\n    if int(str(i)+str(i))%k==0 :\n        ans=ans-1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\nfrom collections import deque,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef read():\n    tc=0\n    if tc:\n        input=sys.stdin.readline\n    else:\n        sys.stdin=open('input1.txt', 'r')\n        sys.stdout=open('output1.txt','w')\n\ndef permute(b,x,ind):\n    if(ind==len(b)):\n        return 1\n    f=0\n    for i in range(9,-1,-1):\n        if(x[i]>0 and i<=int(b[ind])):\n            x[i]-=1\n            ans[ind]=str(i)\n            if(i<int(b[ind])):\n                f=1\n            if(f):\n                k=9\n                for j in range(ind+1,len(b)):\n                    while(x[k]==0):\n                        k-=1\n                    ans[j]=str(k)\n                    x[k]-=1\n                return 1\n            if(permute(b,x,ind+1)):\n                return 1\n            x[i]+=1\n    return 0\n\ndef solve():\n\n    a=ii()\n    b=ii()\n    if(len(str(a))<len(str(b))):\n        s=list(str(a))\n        s.sort(reverse=True)\n        print(\"\".join(s))\n    else:\n        x=[0]*10\n        for i in str(a):\n            x[int(i)]+=1\n        b=str(b)\n        i=0\n        global ans\n        ans=[0]*len(b)\n        permute(b,x,0)\n        print(\"\".join(ans))\n\nif __name__ ==\"__main__\":\n\n    solve()","output":"cubic"},{"instruction":"n, m = map(int, input().split())\na = list(map(str, input().strip()))\n\ndp = [10 ** 10] * (1 << 20)\ncnt = [0] * (1 << 20)\n\ndef get(x):\n    return 1 << (ord(x) - ord('a'))\n\nfor i, v in enumerate(a):\n    if i:\n        cnt[get(a[i]) | get(a[i - 1])] += 1\n\nfor i in range(m):\n    for j in range(1 << m):\n        if (1 << i) & j:\n            cnt[j] += cnt[j ^ (1 << i)]\n\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if not i & (1 << j):\n            dp[i | (1 << j)] = min(dp[i | (1 << j)],\n                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])\nprint(dp[(1 << m) - 1])","output":"np"},{"instruction":"d = [list(map(int, input().split())) for i in range(int(input()))]\n\ns = 0\n\nfor k in range(1, 10001):\n\n    p = [min(max((k - l) \/ (r - l + 1), 1e-20), 1) for l, r in d]\n\n    u = v = 1\n\n    for r in p: u *= r\n\n    for r in p:\n\n        v *= r\n\n        s += (u - v) * (r - 1) \/ r\n\nprint(s)","output":"np"},{"instruction":"import sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag and T:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n    else:\n        print('NO')\n\nmain()","output":"np"},{"instruction":"import math\n\nsent = input()\nreceived = input()\n\nsp = sent.count('+')\nsm = sent.count('-')\nrp = received.count('+')\nrm = received.count('-')\nquest = received.count('?')\n\ndist = sp - rp\n\nif dist < 0 or dist > quest:\n    print(0)\nelif dist == 0 and quest == 0:\n    print(1)\nelse:\n    total = 2 ** quest\n    possible = math.factorial(quest) \/ math.factorial(dist) \/ math.factorial(quest-dist)\n    print(possible\/total)","output":"np"},{"instruction":"def quadrant(x, y, rx, ry):\n\tif x>rx and y>ry:\n\t\treturn 1\n\telif x<rx and y>ry:\n\t\treturn 2\n\telif x<rx and y<ry:\n\t\treturn 3\n\telse:\n\t\treturn 4\n\nn = int(input())\n\nqx, qy = map(int, input().split())\nkx, ky = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"constant"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn = int(input())-1\nx, y = 1, 9\nwhile n > x * y: n,x,y = n-x*y,x+1,y*10\na = str(10 ** (x - 1) + n \/\/ x)[n%x]\nprint(a)","output":"logn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\n\nn,m=map(int,input().split())\nl=[list(map(int,input())) for i in range(n)]\ndic={}\ndiscarded={}\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]==1 :\n            if j+1 not in discarded:\n                if j+1 not in dic:\n                    dic[j+1]=i+1\n                else:\n                    del dic[j+1]\n                    discarded[j+1]=1\n\nif len(dic)==0:\n    print(\"YES\")\nelse:\n    kk=list(dic.values())\n    temp=list(set(kk))\n    if len(temp)==n:\n        print(\"NO\")\n    else:\n        print(\"YES\")","output":"quadratic"},{"instruction":"n,m = map(int,input().split())\nans = 0\ntemp = [0 for i in range(n)]\nfor i in range(n):\n    l,r = map(int,input().split())\n    ans += l\n    temp[i] = l-r\ntemp.sort(reverse=True)\n\nif ans<=m:\n    print(0)\nelse:\n    for i in range(n):\n        ans -= temp[i]\n        if ans<=m:\n            print(i+1)\n            break\n    else:\n        print(-1)","output":"nlogn"},{"instruction":"import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\nT = Tp.TypeVar('T')\n\nclass FenwickSum(Tp.Generic[T]):\n    __slots__ = ['nodes', 'size', 'unit']\n\n    def __init__(self, size: int, default: T, unit: T):\n        self.nodes = [default] * (size + 1)\n        self.size = size + 1\n        self.unit = unit\n\n    def add(self, index: int, value: T):\n        while index < self.size:\n            self.nodes[index] += value\n            index += index & -index\n\n    def sum(self, right: int) -> T:\n        result = self.unit\n\n        while right:\n            result += self.nodes[right]\n            right -= right & -right\n\n        return result\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [x for x in a if x != -1]\n    mod = 998244353\n    minus = n - len(b)\n    m_inv = pow(minus, mod - 2, mod)\n    ans = 0\n\n    bit = FenwickSum[int](n, 0, 0)\n    for x in reversed(b):\n        ans += bit.sum(x)\n        bit.add(x, 1)\n\n    ans += minus * (minus - 1) * pow(4, mod - 2, mod) % mod\n\n    acc_u, m = [0] * (n + 1), minus\n    for x in a:\n        if x == -1:\n            m -= 1\n        else:\n            acc_u[x] = m\n\n    for i in range(n - 1, 0, -1):\n        acc_u[i] += acc_u[i + 1]\n        if acc_u[i] >= mod:\n            acc_u[i] -= mod\n\n    acc_d, m = [0] * (n + 1), minus\n    for x in reversed(a):\n        if x == -1:\n            m -= 1\n        else:\n            acc_d[x] = m\n\n    for i in range(1, n + 1):\n        acc_d[i] += acc_d[i - 1]\n        if acc_d[i] >= mod:\n            acc_d[i] -= mod\n\n    for x in set(range(1, n + 1)) - set(b):\n        ans = (ans + (acc_u[x] + acc_d[x]) * m_inv) % mod\n\n    print(ans % mod)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"from math import pow\nn=int(int(input())-1)\nx=1\ny=9\nwhile n>x*y:\n    n-=x*y\n    x+=1\n    y*=10\na=int(pow(10,x-1))+int(n\/x)\nz=str(a)\nwhich=n%x\nprint(z[which])","output":"logn"},{"instruction":"A=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]\nk=int(input())\nif k<10:\n    print(k)\nelse:\n    for n in range (0,12):\n        if k>A[n+1]:\n            continue\n        else:\n            a=10**(n+1)+(k-A[n]-1)\/\/(n+2)\n            b=(k-A[n]-1)%(n+2)\n            print(str(a)[b])\n            break","output":"logn"},{"instruction":"import os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    mod = 10**9+7\n    n,T = map(int,input().split())\n    y = 1<<n\n    dp = [[0]*3 for _ in range(y)]\n\n    peo = [list(map(int,input().split())) for _ in range(n)]\n\n    for ind,i in enumerate(peo):\n        peo[ind][1] -= 1\n        dp[1<<ind][i[1]] = 1\n    for i in range(y):\n        for j in range(3):\n            if not dp[i][j]:\n                continue\n            mask = 1\n            for k in range(n):\n                if i&mask or peo[k][1] == j:\n                    mask <<= 1\n                    continue\n                dp[i|mask][peo[k][1]] = (dp[i|mask][peo[k][1]]+dp[i][j])%mod\n                mask <<= 1\n    ans = 0\n    for i in range(y):\n        ans1,mask = 0,1\n        for j in range(n):\n            if i&mask:\n                ans1 += peo[j][0]\n            mask <<= 1\n        if ans1 == T:\n            ans = (ans+sum(dp[i]))%mod\n    print(ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"from math import ceil\nN = int(input())\nS = (N * (N + 1)) \/ 2\nF = int(ceil(N \/2.0))\nans = int((S + F) \/ 2)\nprint(ans)","output":"linear"},{"instruction":"from math import *\nn,m = map(int,input().split())\nli = [[j for j in input()] for i in range(n)]\nmin1=inf\nmin2=inf\nmax1=-inf\nmax2=-inf\nfor i in range(n):\n    for j in range(m):\n        if li[i][j] == \"B\":\n            min1 = min(min1,i)\n            min2 = min(min2, j)\n            max1 = max(max1, i)\n            max2 = max(max2, j)\nprint((min1+max1)\/\/2+1,(min2+max2)\/\/2+1)","output":"quadratic"},{"instruction":"l,r=map(int,input().split())\ns=bin(l)[2:]\nt=bin(r)[2:]\nz=max(len(s),len(t))\ns='0'*(z-len(s))+s\nt='0'*(z-len(t))+t\ni=0\nwhile i<z and s[i]==t[i]:\n    i=i+1\nprint(pow(2,z-i)-1)","output":"logn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(10)]\npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n                pp[i]+=1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n\nn,m=map(int,input().split())\nl=[]\npm=2**m-1\nfor i in range(n):\n    l.append(list(map(int,input().split())))\ndef find (x):\n    s=set()\n    d=defaultdict(int)\n    for i in range(n):\n        a=\"\"\n        for j in range(m):\n            if l[i][j]>=x:\n                a+='1'\n            else:\n                a+='0'\n        d[int(a,2)]=i\n        s.add(int(a,2))\n    s=list(s)\n\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            if s[i]|s[j]==pm:\n                return [d[s[i]]+1,d[s[j]]+1]\n    return [-1,-1]\nst=0\nend=10**9\nans=(0,0)\nwhile(st<=end):\n    mid=(st+end)\/\/2\n    s=find(mid)\n    if s[0]!=-1:\n        ans=s\n        st=mid+1\n    else:\n        end=mid-1\nprint(*ans)","output":"np"},{"instruction":"n = int(input())\ndp = [0]*101\ndp[1] = 1\ndp[2] = 2\nfor i in range(3, 101):\n    dp[i] = dp[i-2]+i\nprint(dp[n])","output":"linear"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(200001)]\npp=[0]*200001\ndef SieveOfEratosthenes(n=200000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\ndef mergeSort(arr, n):\n\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\n\ndef _mergeSort(arr, temp_arr, left, right):\n\n    inv_count = 0\n\n    if left < right:\n\n        mid = (left + right)\/\/2\n\n        inv_count += _mergeSort(arr, temp_arr,\n                                    left, mid)\n\n        inv_count += _mergeSort(arr, temp_arr,\n                                  mid + 1, right)\n\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\n\nn=int(input())\na=list(map(int,input().split()))\nr=mergeSort(a, n)\nif r%2==(3*n)%2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"import math\ns=input()\np=input()\nc=1\nss=0\nps=0\nk=0\nfor i in range(len(s)):\n\tif(p[i]=='?'):\n\t\tc*=2\n\t\tk+=1\n\tif(s[i]=='+'):\n\t\tss+=1\n\telse:\n\t\tss-=1\n\tif(p[i]=='+'):\n\t\tps+=1\n\telif p[i]=='-':\n\t\tps-=1\ny=math.fabs(ss-ps)\nx=k-y\na=y+x\/2\nb=k-a\nif k<y:\n\tans=0.000000000\nelse:\n\tans=math.factorial(a+b)\/(math.factorial(a)*math.factorial(b))\n\tans\/=c\nprint(\"%.12f\"%ans)","output":"np"},{"instruction":"n, m, k = map(int, input().split())\na = list(map(int, input().split()))\nsa = [0]*n\n\nans = 0\n\nfor i in range(n):\n    sa[i] = a[i] - k\n    s = a[i]\n    for j in range(i-1, max(-1, i-m-1), -1):\n        sa[i] = max(sa[i], sa[j] + s - k)\n        s += a[j]\n    if i < m:\n        sa[i] = max(sa[i], s - k)\n    sa[i] = max(sa[i], 0)\n    ans = max(ans, sa[i])\n\nprint(ans)","output":"quadratic"},{"instruction":"import itertools\n\ndef q121a_v2():\n\tgood_num_arr = generate_47_arr()\n\tnum = int(input())\n\tfor element in good_num_arr:\n\t\tif(num % element == 0):\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tprint(\"NO\")\n\ndef generate_47_arr():\n\tarr = []\n\tfor digits in range(1, 4):\n\t\tarr += itertools.product(\"47\", repeat=digits)\n\tfor i in range(len(arr)):\n\t\tarr[i] = int(\"\".join(list(arr[i])))\n\tarr.append(4444444444)\n\treturn arr\n\nq121a_v2()","output":"constant"},{"instruction":"from math import gcd\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\nm=int(input())\nd=dd(int)\nl=[]\nfor i in range(m):\n    s=input().split()[0]\n    a=0\n    b=0\n    c=0\n    n=len(s)\n    ind=0\n    for i in range(1,n):\n        if(s[i]=='+'):\n            ind=i+1\n            break\n        a=a*10+int(s[i])\n    for i in range(ind,n):\n        if(s[i]==')'):\n            ind1=i+2\n            break\n        b=b*10+int(s[i])\n    for i in range(ind1,n):\n        c=c*10+int(s[i])\n    a=a+b\n    g=gcd(a,c)\n    a=a\/\/g\n    c=c\/\/g\n    d[(a,c)]+=1\n    l.append((a,c))\nfor i in l:\n    print(d[i],end=\" \")","output":"linear"},{"instruction":"n, m = map(int, input().split(\" \"))\nnumbers = list(map(int, input().split(\" \")))\n\nsmaller_greater = [(0, 0)]\nfor k in numbers:\n    s, g = smaller_greater[-1]\n    if k < m:\n        smaller_greater.append((s + 1, g))\n    elif k > m:\n        smaller_greater.append((s, g + 1))\n    else:\n        smaller_greater.append((s, g))\n\ni = numbers.index(m)\ns_median, g_median = smaller_greater[i]\n\ndifference = {}\nfor pack in smaller_greater[i + 1:]:\n    s, g = pack\n    s -= s_median\n    g -= g_median\n    if s - g in difference:\n        difference[s - g] += 1\n    else:\n        difference[s - g] = 1\n\ncount = 0\nfor start in range(i + 1):\n    s, g = smaller_greater[start]\n    s -= s_median\n    g -= g_median\n    if s - g in difference.keys():\n        count += difference[s - g]\n\n    if s - g - 1 in difference.keys():\n        count += difference[s - g - 1]\n\nprint(count)","output":"nlogn"},{"instruction":"n = int(input())\nm = input().split(' ')\nj = 0\nmark = [1]\nfor i in range(1,len(m)) :\n    tmp = max(mark[i-1],int(m[i])+1)\n    mark.append(tmp)\n\nj+=mark[len(m)-1]-int(m[len(m)-1])-1\nfor i in range(len(m)-2,-1,-1):\n    if mark[i]<mark[i+1]-1:\n        mark[i] = mark[i+1]-1\n    j+=mark[i]-int(m[i])-1\nprint(j)","output":"linear"},{"instruction":"num = input()\nnum_list = []\nfor i in range(len(num)):\n  num_list.append(int(num[i]))\nmyMod = (10 ** 9) + 7\nlength = len(num_list)\nf = [0] * (length + 1)\nt = [1] * (length + 1)\nfor i in range(length):\n    f[i+1] = (f[i] * 10 + 1) % myMod\n    t[i+1] = (t[i] * 10) % myMod\nans = 0\nfor i in range(1, 10):\n    dp = [0] * (length + 1)\n    for j in range(length):\n        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod\n    c = 0\n    ctr = 0\n    for k in num_list:\n        z = min(i, k)\n        o = k - z\n        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod\n        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod\n        ans %= myMod\n        c += k >= i\n        ctr += 1\n    ans += f[c]\n    if ans >= myMod:\n        ans -= myMod\nprint(ans)","output":"quadratic"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k\/2+1))\n\n  for i in range(n*m):\n    dp[i] = 0\n\n  for t in range(1, k\/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))\n      dp[i+(t*n*m)] = ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp[node+(k\/2*n*m)] * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"l,r = map(int, input().split())\n\ndef maxXor(low, high):\n\n    highestPower = high.bit_length()-1\n    if high == 1 and low == 0:\n        return 1\n    if highestPower <= 0:\n        return 0\n    if low < 2** highestPower:\n        return (2**(highestPower+1))-1\n    return maxXor(low -2**highestPower, high-2**highestPower)\n\nprint(maxXor(l,r))","output":"logn"},{"instruction":"def factorial(n):\n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    return result\n\ncommands = input().strip()\nreceived = input().strip()\nn = len(commands)\npositive = 0\nnegative = 0\ncount = 0\nfor i in range(n):\n    if commands[i] == \"+\":\n        positive += 1\n    else:\n        negative += 1\n    if received[i] == \"+\":\n        positive -= 1\n    elif received[i] == \"-\":\n        negative -= 1\n    else:\n        count += 1\ncases = 2**count\nprobability = 0.0\nif positive >= 0 and negative >= 0:\n    probability = (factorial(count)\/(factorial(positive)*factorial(negative)))\/cases\n\nprint(\"{0:.9f}\".format(probability))","output":"np"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\n\nnr,ng,nb=[int(x) for x in input().split()]\nr=[int(x) for x in input().split()]\ng=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\n\nr.sort()\ng.sort()\nb.sort()\n\nmemo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]\nmemo[0][0][0]=0\nfor i in range(nr):\n    memo[i+1][0][0]=0\nfor j in range(ng):\n    memo[0][j+1][0]=0\nfor k in range(nb):\n    memo[0][0][k+1]=0\ndef dp(i,j,k):\n    if i<-1 or j<-1 or k<-1:\n        return -float('inf')\n    if memo[i+1][j+1][k+1]==-1:\n        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],\n                   dp(i-1,j-1,k)+r[i]*g[j],\n                   dp(i-1,j,k-1)+r[i]*b[k]\n                )\n    return memo[i+1][j+1][k+1]\n\nprint(dp(nr-1,ng-1,nb-1))","output":"cubic"},{"instruction":"import bisect\n\nb = []\na = []\nb.append(0)\n\nfor i in range(1, 15):\n\tb.append(9 * i * (10 ** (i - 1)))\n\na.append(b[0])\nfor i in range(1, 15):\n\ta.append(a[i - 1] + b[i])\n\nk = int(input())\n\nth = bisect.bisect_left(a, k)\nth -= 1;\nk = k - a[th];\nstart = 10 ** th;\nnow = th + 1;\nrem = k % now;\niss = k \/ now;\nend = start + (k \/ now);\ntemp = str(end - 1);\ns = \"\";\ns += temp[now - 1] + str(end) + str(end + 1);\n\nprint(s[0 + rem])","output":"logn"},{"instruction":"s = input()\nres = 0\nfor i in range(len(s)):\n    for j in range(i,len(s)):\n        for f in range(i+1,len(s)):\n            if len(s) >= f + j-i:\n                if (s[i:j]== s[f:f+j-i]):\n                    res = max(res,j - i)\n\nprint(res)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=list(map(int,input().split()))\nmod=998244353\n\nINV=[None]*(n+1)\nfor i in range(1,n+1):\n    INV[i]=pow(i,mod-2,mod)\n\nBLA=P.count(-1)\n\nif BLA==0 or BLA==1:\n    ANS=0\nelse:\n    LEFT=BLA*(BLA-1)\/\/2*INV[BLA]%mod\n    AVEP=BLA*(BLA-1)\/\/2*pow(BLA-1,mod-2,mod)\n\n    ANS=LEFT*AVEP%mod\n\ny=1\nfor i in range(BLA):\n    y=y*(BLA-i)%mod\n\nKOSUU=pow(y,mod-2,mod)\nBLALIST=[1]*(n+1)\nNONBLA=[]\nBLANUM=[0]*n\nfor i in range(n):\n    if P[i]!=-1:\n        BLALIST[P[i]]=0\n        BLANUM[i]=BLANUM[i-1]\n        NONBLA.append(P[i])\n\n    else:\n        BLANUM[i]=BLANUM[i-1]+1\n\nBLALIST[0]=0\nfor i in range(1,n+1):\n    BLALIST[i]=BLALIST[i-1]+BLALIST[i]\n\nif BLA!=0:\n    for i in range(n):\n        if P[i]!=-1:\n            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod\n\nA=NONBLA\n\nif A==[]:\n    print(ANS)\n    sys.exit()\n\nn=len(A)\nMAXA=max(A)\nMINA=min(A)\n\nBIT=[0]*(MAXA-MINA+2)\n\nfor i in range(n):\n    bitobje=A[i]-MINA+1\n\n    x=bitobje\n    while x!=0:\n        ANS=(ANS-BIT[x])%mod\n        x-=(x&(-x))\n\n    x2=MAXA-MINA+1\n\n    while x2!=0:\n\n        ANS=(ANS+BIT[x2])%mod\n        x2-=(x2&(-x2))\n\n    y=bitobje\n    while y<=MAXA-MINA+1:\n        BIT[y]+=1\n        y+=(y&(-y))\n\nprint(ANS)","output":"nlogn"},{"instruction":"def f(l):\n    n,m = l\n    return ['5'*282,'4'*281+'5']\n\nl = list(map(int,input().split()))\n[print(r) for r in f(l)]","output":"constant"},{"instruction":"import math\ndef solve(n, x, y):\n    g = math.gcd(x, y)\n    if g != 1:\n        return solve(n \/\/ g + 1, x \/\/ g, y \/\/ g) * (n % g) + solve(n \/\/ g, x \/\/ g, y \/\/ g) * (g - n % g)\n    p = x + y\n    weights = [n \/\/ p] * p\n    for i in range(p):\n        if (i * x) % p < n % p:\n            weights[i] += 1\n    ans = -n\n    for i in range(2):\n        dp = [-n, -n]\n        dp[i] = 0\n        for w in weights:\n            dp = [max(dp[0], dp[1]), dp[0] + w]\n        ans = max(ans, dp[i])\n    return ans\n\ndef main():\n    n, x, y = [int(x) for x in input().split()]\n    print(solve(n, x, y))\n\nmain()","output":"np"},{"instruction":"from math import sqrt\n\na, v = map(int, input().split())\nl, d, w = map(int, input().split())\n\ndef findt(u, v, a, dist):\n\tfront = (v*v-u*u)\/(2*a)\n\tif front > dist:\n\t\treturn (sqrt(u*u+2*a*dist)-u)\/a\n\treturn (v-u)\/a + (dist-front)\/v\n\ndef solve(a, v, l, d, w):\n\tif v <= w or 2*a*d <= w*w:\n\t\treturn findt(0, v, a, l)\n\tafter = findt(w, v, a, l-d)\n\tpeak = sqrt(a*d + w*w\/2)\n\tif peak > v:\n\t\ttravel = (v*v-w*w\/2)\/a\n\t\tbefore = (2*v-w)\/a + (d-travel)\/v\n\telse:\n\t\tbefore = (2*peak-w)\/a\n\treturn before + after\n\nprint(f'{solve(a, v, l, d, w):.8f}')","output":"constant"},{"instruction":"s = input()\n\nmc = -1\n\nfor i in range(len(s)):\n\tfor j in range(i+1, len(s)):\n\t\tcu = 0\n\t\tfor cu in range(len(s)-max(i, j)):\n\t\t\tif s[i+cu] == s[j+cu]:\n\t\t\t\tmc = max(mc, cu)\n\t\t\telse:\n\t\t\t\tbreak\n\nprint(mc + 1)","output":"cubic"},{"instruction":"CANDNUM = 5\n\nI = lambda: [int(x) for x in raw_input().split()]\nT = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2\n\ndef getCandidates(tsLst, curN, notSeen):\n\tr = []\n\tcurD = {}\n\tk = 0\n\tcand = None\n\tcurSet = set()\n\tfor x in tsLst:\n\t\ti, j = x\n\t\tcurSet.add(i)\n\t\tif len(curSet) == curN-1:\n\t\t\tcand = list(notSeen - curSet)[0]\n\t\t\tbreak\n\t\tcurSet.add(j)\n\t\tif len(curSet) == curN-1:\n\t\t\tcand = list(notSeen - curSet)[0]\n\t\t\tbreak\n\ti = 0\n\tfor x in tsLst:\n\t\tif cand in x:\n\t\t\tr.append(x)\n\t\t\ti += 1\n\t\t\tif i == CANDNUM:\n\t\t\t\tbreak\n\treturn r\n\ndef solve(xs, ys, n, oLst):\n\tdef solveEven(seen):\n\t\tdef solveEvenRec(notSeen, tsLst):\n\t\t\tif len(notSeen) == 0:\n\t\t\t\treturn 0, []\n\t\t\tns = tuple(notSeen)\n\t\t\tif ns in solveEvenRec.d:\n\t\t\t\treturn solveEvenRec.d[ns]\n\t\t\tminLst = []\n\t\t\tminT = 10000000\n\n\t\t\tcands = getCandidates(tsLst, len(notSeen), notSeen)\n\t\t\tfor x in cands:\n\t\t\t\ti, j = x\n\t\t\t\tnewNotSeen = notSeen.copy()\n\t\t\t\tif i in newNotSeen:\n\t\t\t\t\tnewNotSeen.remove(i)\n\t\t\t\tif j in newNotSeen:\n\t\t\t\t\tnewNotSeen.remove(j)\n\t\t\t\tnewTsLst = []\n\t\t\t\tfor x1 in tsLst:\n\t\t\t\t\ti1, j1 = x1\n\t\t\t\t\tif i1 in newNotSeen and j1 in newNotSeen:\n\t\t\t\t\t\tnewTsLst.append(x1)\n\t\t\t\trT, rLst = solveEvenRec(newNotSeen, newTsLst)\n\t\t\t\trT += ts[x]\n\t\t\t\tif rT < minT:\n\t\t\t\t\tminT = rT\n\t\t\t\t\tminLst = [x] + rLst\n\t\t\tr = minT, minLst\n\t\t\tsolveEvenRec.d[ns] = r\n\t\t\treturn r\n\t\tsolveEvenRec.d = {}\n\n\t\tnewLst = []\n\t\tfor i in range(n):\n\t\t\tif i not in seen:\n\t\t\t\tnewLst.append(i)\n\t\tnewN = n - len(seen)\n\t\tif newN == 2:\n\t\t\tminT = 10000000\n\t\t\tminLst = []\n\t\t\tfor a in ts:\n\t\t\t\tif ts[a] < minT:\n\t\t\t\t\tminT = ts[a]\n\t\t\t\t\tminLst = [a]\n\t\t\trT = minT\n\t\t\trLst = minLst\n\t\telse:\n\t\t\tnewTsLst = []\n\t\t\tfor x in tsLst:\n\t\t\t\ta, _ = x\n\t\t\t\ti, j = a\n\t\t\t\tif i not in seen and j not in seen:\n\t\t\t\t\tnewTsLst.append(a)\n\t\t\tnotSeen = set(range(n)) - set(seen)\n\t\t\trT, rLst = solveEvenRec(notSeen, newTsLst)\n\t\treturn rT, rLst\n\tts = {}\n\ttss = {}\n\tfor i in range(n-1):\n\t\tx1, y1 = oLst[i]\n\t\tfor j in range(i+1, n):\n\t\t\tx2, y2 = oLst[j]\n\t\t\tt = T(x1, y1, x2, y2)\n\t\t\tt1 = T(x1, y1, xs, ys)\n\t\t\tt2 = T(xs, ys, x2, y2)\n\t\t\tif t1+t2 >= t:\n\t\t\t\tts[(i, j)] = t\n\t\t\t\ttss[(i, j)] = True\n\t\t\telse:\n\t\t\t\tts[(i, j)] = t1+t2\n\t\t\t\ttss[(i, j)] = False\n\ttsLst = []\n\tfor x in ts:\n\t\ttsLst.append((x, ts[x]))\n\ttsLst.sort(key=lambda x:x[1])\n\tif n%2:\n\t\tif n > 1:\n\t\t\tresT = 10000000\n\t\t\tresLst = []\n\t\t\tfor i in range(n):\n\t\t\t\tx, y = oLst[i]\n\t\t\t\tt = 2*T(x, y, xs, ys)\n\t\t\t\trT, rLst = solveEven([i])\n\t\t\t\tfor a in rLst:\n\t\t\t\t\ti1, i2 = a\n\t\t\t\t\tx1, y1 = oLst[i1]\n\t\t\t\t\tx2, y2 = oLst[i2]\n\t\t\t\t\trT += T(xs, ys, x1, y1)\n\t\t\t\t\trT += T(xs, ys, x2, y2)\n\t\t\t\trT += t\n\t\t\t\tif rT < resT:\n\t\t\t\t\tresT = rT\n\t\t\t\t\tnewRLst = ['0']\n\t\t\t\t\tfor a in rLst:\n\t\t\t\t\t\tw, v = a\n\t\t\t\t\t\tif tss[(w, v)]:\n\t\t\t\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\tnewRLst.append(str(i+1))\n\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\tresLst = newRLst\n\t\telse:\n\t\t\tx, y = oLst[0]\n\t\t\tresT = 2*T(x, y, xs, ys)\n\t\t\tresLst = ['0', '1', '0']\n\telse:\n\t\tresT, rLst = solveEven([])\n\t\tfor a in rLst:\n\t\t\ti1, i2 = a\n\t\t\tx1, y1 = oLst[i1]\n\t\t\tx2, y2 = oLst[i2]\n\t\t\tresT += T(xs, ys, x1, y1)\n\t\t\tresT += T(xs, ys, x2, y2)\n\t\tnewRLst = ['0']\n\t\tfor a in rLst:\n\t\t\tw, v = a\n\t\t\tif tss[(w, v)]:\n\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\tnewRLst.append('0')\n\t\t\telse:\n\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\tnewRLst.append('0')\n\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\tnewRLst.append('0')\n\t\tresLst = newRLst\n\treturn resT, resLst\n\nxs, ys = I()\nn = input()\noLst = []\nfor _ in range(n):\n\tx, y = I()\n\toLst.append((x, y))\nresT, resLst = solve(xs, ys, n, oLst)\nprint(resT)\nprint(' '.join(resLst))","output":"np"},{"instruction":"import math\na=input()\nb=input()\nc=int(0)\nd=int(0)\nq=int(0)\nfor i in range(len(a)):\n    if a[i]==\"+\":\n        c+=1\n    elif a[i]==\"-\":\n        c-=1\nfor i in range(len(b)):\n    if b[i]==\"+\":\n        d+=1\n    elif b[i]==\"-\":\n        d-=1\n    else:\n        q+=1\nif c == d:\n    print((math.factorial(q)\/(math.factorial(q\/2)*math.factorial(q\/2)))\/(2**q))\nelse:\n    mx=d+q\n    mn=d-q\n    if c>mx or c<mn:\n        print(0.0)\n    else:\n        ans=c-d\n        if ans > 0:\n            print((math.factorial(q)\/(math.factorial(((q-ans)\/2)+ans)*math.factorial((q-ans)\/2)))\/(2**q))\n        else:\n            print((math.factorial(q)\/(math.factorial((q-ans)\/2)*math.factorial(((q-ans)\/2)+ans)))\/(2**q))","output":"np"},{"instruction":"n, s = map(int, input().split())\ndef really_big(ni, s):\n    dig_sum = sum(list(map(int, list(str(ni)))))\n    return (ni-dig_sum)>=s\ncont = 0\nfor i in range(s, n+1):\n    if really_big(i, s):\n        cont = n-i+1\n        break\nprint(cont)","output":"logn"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor t in range(ii()):\n    n, k = mi()\n    if n == 1:\n        ans = 'YES 0' if k == 1 else 'NO'\n    elif n == 2:\n        if k <= 2:\n            ans = 'YES 1'\n        elif k == 3 or k > 5:\n            ans = 'NO'\n        else:\n            ans = 'YES 0'\n    elif n <= 32 and k > (4 ** n - 1) \/\/ 3:\n        ans = 'NO'\n    else:\n        c, x = 0, n\n        p2 = 2\n        while x > 0:\n            if c + p2 - 1 > k:\n                break\n            c += p2 - 1\n            x -= 1\n            p2 *= 2\n        ans = 'YES %d' % (x,)\n    print(ans)","output":"linear"},{"instruction":"n = int(input())-1\nc = 0\nfor i in range(11):\n\tc += 9*(i+1)* 10**i\n\tif c > n:\n\t\tn -= (c - 9*(i+1)* 10**i)\n\t\tv = n \/\/ (i+1)\n\t\tprint(str(10**i + v)[n%(i+1)])\n\t\tbreak","output":"logn"},{"instruction":"print(25)","output":"constant"},{"instruction":"m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for xx,ii in zip(values,idx):\n        if (xx^x) < x:\n            x^=xx\n            ans^=ii\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)==1:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))","output":"np"},{"instruction":"def solve():\n    n = int(input())\n    l = list(map(int,list(input())))\n    divisors = []\n    total = sum(l)\n    for j in range(2,int(sqrt(total))+1):\n        if(total%j==0):\n            divisors.extend([j,total\/\/j])\n    if(total==0):\n        print(\"YES\")\n        return\n    if(total!=1):\n        divisors.append(1)\n\n    for x in divisors:\n        search = x\n        index = 0\n        summ = 0\n        while(index<n):\n            summ+=l[index]\n            if(summ>search):\n                break\n            elif(summ==search):\n                summ = 0\n            index+=1\n\n        if(summ==0 and index==n):\n            print(\"YES\")\n            return\n    print(\"NO\")\nimport sys\nimport math\nimport bisect\nfrom sys import stdin,stdout\nfrom math import gcd,floor,sqrt,log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl,bisect_right as br\n\ninp    =lambda: int(input())\nstrng  =lambda: input().strip()\njn     =lambda x,l: x.join(map(str,l))\nstrl   =lambda: list(input().strip())\nmul    =lambda: map(int,input().strip().split())\nmulf   =lambda: map(float,input().strip().split())\nseq    =lambda: list(map(int,input().strip().split()))\n\nceil   =lambda x: int(x) if(x==int(x)) else int(x)+1\nceildiv=lambda x,d: x\/\/d if(x%d==0) else x\/\/d+1\n\nflush  =lambda: stdout.flush()\nstdstr =lambda: stdin.readline()\nstdint =lambda: int(stdin.readline())\nstdpr  =lambda x: stdout.write(str(x))\n\nsolve()","output":"quadratic"},{"instruction":"n, s = map(int, input().split())\nprint((s + n - 1) \/\/ n)","output":"constant"},{"instruction":"def main():\n    n = int(input())\n\n    s = []\n\n    for i in range(n):\n        s.append(input())\n\n    for i in s:\n        for j in s:\n            if (i not in j) and (j not in i):\n                print('NO')\n                return\n\n    print('YES')\n    s = sorted(s, key=lambda x : len(x))\n    for pal in s:\n        print(pal)\n\nmain()\n","output":"nlogn"},{"instruction":"k=int(input())\n\ns=0\ni=1\nwhile  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :\n    s +=  i * (9 * pow(10, i - 1))\n    i+=1\nelse:\n    i-=1\n\nk=k-s-1\nx= k \/\/ (i+1)\ny= k %(i+1)\nx= pow(10,i)+x\nss=str(x)\nprint(ss[y])","output":"logn"},{"instruction":"def iskoutsu(arr):\n\treturn len(set(arr)) == 1\n\ndef isshuntsu(arr):\n\tnos = [int(ele[0]) for ele in arr]\n\tnos.sort()\n\treturn nos[0]+1 == nos[1] and nos[1]+1 == nos[2] and len(set([ele[1] for ele in arr])) == 1\n\narr = input().strip().split()\nif isshuntsu(arr) or iskoutsu(arr):\n\texit(print(0))\n\ntotal1 = 0\nif len(set(arr)) == 3:\n\ttotal1 = 2\nelif len(set(arr)) == 2:\n\ttotal1 = 1\n\ntotal2 = 2\nfor ele in arr:\n\tno, suite = int(ele[0]), ele[1]\n\n\tif no+2 <= 9:\n\t\trequired = [str(no+1)+suite, str(no+2)+suite]\n\t\tcurr = int(required[0] not in arr) + (required[1] not in arr)\n\t\ttotal2 = min(total2, curr)\n\n\tif no+1 <= 9 and no-1 >= 0:\n\t\trequired = [str(no-1)+suite, str(no+1)+suite]\n\t\tcurr = int(required[0] not in arr) + (required[1] not in arr)\n\t\ttotal2 = min(total2, curr)\n\n\tif no+2 <= 9:\n\t\trequired = [str(no-1)+suite, str(no-2)+suite]\n\t\tcurr = int(required[0] not in arr) + (required[1] not in arr)\n\t\ttotal2 = min(total2, curr)\n\nprint(min(total1, total2))","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\nq={0}\ne=0\nl=[]\nfor i in range(n):\n    if a[i] not in q:\n        e+=1\n        q.add(a[i])\n    if e==k:\n        e=0\n        q={0}\n        l+=[i]\nw=10**5\nt=0\nfor i in l:\n    e=0\n    q={0}\n    for j in range(i,-1,-1):\n        if a[j] not in q:\n            e+=1\n            q.add(a[j])\n        if e==k:\n            if w>len(q):\n                w=j+1\n                t=i+1\n            break\nif len(set(a))>=k:print(w,t)\nelse:print(-1,-1)","output":"linear"},{"instruction":"w,h,n=map(int,input().split())\nl=[-1]*(w+1)\nr=[-1]*(w+1)\nt=[-1]*(h+1)\nb=[-1]*(h+1)\n\nl[0]=0\nb[0]=0\nt[h]=h\nr[w]=w\n\nV=[0]*(n)\nH=[0]*(n)\nfor i in range(n):\n    line,index=input().split()\n    index=int(index)\n    if line==\"V\":\n        r[index]=w\n        V[i]=index\n    else:\n        t[index]=h\n        H[i]=index\n\nleft=0\nmxw=0\nfor i in range(1,w+1):\n    if r[i]!=-1:\n        l[i]=left\n        r[left]=i\n        mxw=max(mxw,i-left)\n        left=i\n\nbottom=0\nmxh=0\nfor i in range(1,h+1):\n    if t[i]!=-1:\n        b[i]=bottom\n        t[bottom]=i\n        mxh=max(mxh,i-bottom)\n        bottom=i\n\nans=[0]*(n)\nans[n-1]=mxh*mxw\n\nfor i in range(n-1,0,-1):\n    if V[i]!=0:\n        mxw=max(mxw,r[V[i]]-l[V[i]])\n        r[l[V[i]]]=r[V[i]]\n        l[r[V[i]]]=l[V[i]]\n\n    else:\n        mxh=max(mxh,t[H[i]]-b[H[i]])\n        b[t[H[i]]]=b[H[i]]\n        t[b[H[i]]]=t[H[i]]\n\n    ans[i-1]=mxh*mxw\n\nfor i in range(n):\n    print(ans[i])","output":"nlogn"},{"instruction":"import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nimport string\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef get_int():\n    return int(input())\n\ndef get_ints():\n    return list(map(int, input().split(' ')))\n\ndef get_int_grid(n):\n    return [get_ints() for _ in range(n)]\n\ndef get_str():\n    return input().split(' ')\n\ndef yes_no(b):\n    if b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef prefix_sums(a):\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return p\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n    limits = [left, right]\n    while limits[1] - limits[0] > delta:\n        if delta == 1:\n            mid = sum(limits) \/\/ 2\n        else:\n            mid = sum(limits) \/ 2\n        if good(mid):\n            limits[int(right_true)] = mid\n        else:\n            limits[int(~right_true)] = mid\n    if good(limits[int(right_true)]):\n        return limits[int(right_true)]\n    else:\n        return False\n\ndef solve_a():\n    n = get_int()\n    m = get_int()\n    a = get_ints()\n    b = get_ints()\n\n    def good(k):\n        for i in range(n):\n            k -= (m + k) \/ a[i]\n            k -= (m + k) \/ b[i]\n        return k >= 0\n\n    ans = binary_search(good, 0, 10 ** 9 + 1, delta=10 ** (-6), right_true=True)\n    if not ans:\n        return -1\n    else:\n        return ans\n\nprint(solve_a())","output":"linear"},{"instruction":"n, a, b = map(int, input().strip().split())\n\nif min(a, b) > 1:\n    print('NO')\n    exit(0)\n\nM = [[0] * n for _ in range(n)]\n\nif a == 1 and b == 1:\n    if n == 1:\n        print('YES')\n        print('0')\n        exit(0)\n    if n == 2 or n == 3:\n        print('NO')\n        exit(0)\n    for i in range(1, n):\n        M[i - 1][i] = 1\n        M[i][i - 1] = 1\nelse:\n\n    s = n - max(a, b) + 1\n    for i in range(s):\n        for j in range(s):\n            if i != j:\n                M[i][j] = 1\n    if a == 1:\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    M[i][j] = 1 - M[i][j]\n\nprint('YES')\nfor i in range(n):\n    print(''.join(map(str, M[i])))","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nfrom math import gcd\ninput = stdin.buffer.readline\n\nx, k = map(int, input().split())\nif x == 0:\n\tprint(0)\n\texit()\nx *= 2\nmod = 1000000007\nx = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)\nprint(x % mod)","output":"logn"},{"instruction":"from sys import stdin, stdout\n\nN = 55\n\nf = [0]\nfor i in range(1, N):\n    f.append(f[-1]*4 + 1)\n    if f[-1] > 1e18:\n        break\n\nt = int(stdin.readline().strip().split()[0])\n\nfor ca in range(0, t):\n    n, m = [int(x) for x in stdin.readline().strip().split()]\n    if n > 31:\n        stdout.write(\"YES {}\\n\".format(n-1))\n    else:\n\n        start = 0\n        found = False\n        res = -1\n        for i in range(1, n+1):\n            start += 2**i -1\n            end = start\n            for k in range(1, i+1):\n                end += f[n-k] * (2**(k+1) - 3)\n            if m >= start and m <= end:\n                found = True\n                res = i\n                break\n        if found:\n            stdout.write(\"YES {}\\n\".format(n-res))\n        else:\n            stdout.write(\"NO\\n\")","output":"quadratic"},{"instruction":"n,m = map(int, input().split())\na= input()\nb = input()\nif '*' in a:\n    c = a.replace('*','')\n    i = a.index('*')\n    if c==b:\n        print(\"YES\")\n    elif a[:i]==b[:i]:\n        t = a[i+1:]\n\n        tt = b[m - n+1+i:]\n\n        if t ==tt and n-1<=m:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\nelif n>m:\n    print(\"NO\")\nelse:\n    if a==b:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"linear"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\nif sum(a) < (2 * n) - 2:\n    print(\"NO\")\nelse:\n    one = []\n    rst = []\n    for i in range(0, n):\n        if a[i] > 1:\n            rst.append(i)\n        else:\n            one.append(i)\n    ans = []\n    for i in range(1, len(rst)):\n        ans.append((rst[i], rst[i - 1]))\n        a[rst[i]] -= 1\n        a[rst[i - 1]] -= 1\n    for i in range(1, len(one)):\n        for j in range(0, len(rst)):\n            if a[rst[j]] > 0:\n                a[rst[j]] -= 1\n                ans.append((rst[j], one[i]))\n                break\n    if len(one):\n        for i in range(len(rst) - 1, -1, -1):\n            if a[rst[i]] > 0:\n                ans.append((rst[i], one[0]))\n                break\n    siz = min(len(one) + len(rst), 2 + len(rst)) - 1\n    print(\"YES \", siz)\n\n    print(len(ans))\n    for u,v in ans:\n        print(u + 1,v + 1)","output":"quadratic"},{"instruction":"n,m,k = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\na = a[::-1]\nif m<=k:\n    print(0)\nelse:\n    c=0\n    while(c<n):\n        k = k+a[c]-1\n        c+=1\n        if k>=m:\n            print(c)\n            exit()\n    else:\n        print(-1)","output":"nlogn"},{"instruction":"T = int(input())\nfor _ in range(T):\n    N = int(input())\n\n    if N%2 == 1:\n        print(\"NO\")\n    else:\n        N \/\/= 2\n        if N**(1\/2) == int(N**(1\/2)):\n            print(\"YES\")\n        else:\n            if N%2 == 1:\n                print(\"NO\")\n            else:\n                N \/\/= 2\n                if N**(1\/2) == int(N**(1\/2)):\n                    print(\"YES\")\n                else:\n                    print(\"NO\")","output":"constant"},{"instruction":"n,a=list(map(int,raw_input().split()))\ndeb=1\nfin=n+1\nwhile fin-deb>1:\n    m=(fin+deb)\/\/2\n    if (m*(m+1))\/\/2-(n-m)>a:\n        fin=m\n    else:\n        deb=m\nprint(n-deb)","output":"logn"},{"instruction":"n=int(input())\nimport sys\npts=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    pts.append([x,y])\nif(n<=4):\n    print('YES')\n    sys.exit()\nb1=pts[0][0]-pts[1][0]\na1=pts[1][1]-pts[0][1]\nc1=-a1*pts[0][0] - b1*pts[0][1]\na2=0\nb2=0\nc2=1\np=[]\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n        if(len(p)==2):\n\n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n            flag=False\n            break\nif(flag):\n    print(\"YES\")\n\n    sys.exit()\nP=p\np=[pts[0],P[0]]\nb1=p[0][0]-p[1][0]\na1=p[1][1]-p[0][1]\nc1=-a1*p[0][0] - b1*p[0][1]\np=[]\na2=0\nb2=0\nc2=1\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n\n        if(len(p)==2):\n\n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n            flag=False\n            break\nif(flag):\n\n    print(\"YES\")\n    sys.exit()\n\np=[P[0],pts[1]]\nb1=p[0][0]-p[1][0]\na1=p[1][1]-p[0][1]\nc1=-a1*p[0][0] - b1*p[0][1]\np=[]\na2=0\nb2=0\nc2=1\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n        if(len(p)==2):\n\n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n\n            flag=False\n            break\nif(flag):\n    print(\"YES\")\n\n    sys.exit()\nprint(\"NO\")","output":"nlogn"},{"instruction":"r,g,b = map(int,input().split())\n\nR = list(map(int,input().split()))\nG = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\n\ndp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n\nfor j in range(g-1,-1,-1):\n    for k in range(b-1,-1,-1):\n        dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1]\n\nfor i in range(r-1,-1,-1):\n    for k in range(b-1,-1,-1):\n        dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1]\n\nfor i in range(r-1,-1,-1):\n    for j in range(g-1,-1,-1):\n        dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b]\n\nfor i in range(r-1,-1,-1):\n    for j in range(g-1,-1,-1):\n        for k in range(b-1,-1,-1):\n            case1 = dp[i+1][j][k]\n            case2 = dp[i][j+1][k]\n            case3 = dp[i][j][k+1]\n\n            case4 = R[i]*G[j] + dp[i+1][j+1][k]\n            case5 = R[i]*B[k] + dp[i+1][j][k+1]\n            case6 = G[j]*B[k] + dp[i][j+1][k+1]\n\n            dp[i][j][k] = max(case1,case2,case3,case4,case5,case6)\n\nprint(dp[0][0][0])","output":"cubic"},{"instruction":"mod = 1000000000 + 7\n\nn, m = map(int, input().split())\n\nif n == 0:\n    print(0)\n    exit()\n\nans = n * 2\nans %= mod\n\nif m:\n    t = 1\n    x = 2\n    while m > 0:\n        if m & 1:\n            t = t * x % mod\n        x = x * x % mod\n        m >>= 1\n    ans -= 1\n    ans = (t * ans + 1) % mod\n\nprint(ans)","output":"logn"},{"instruction":"N = int(input())\nterms = 1\nn = 9\ntotal = 0\n\nwhile N > terms*n:\n\tN = N - terms*n\n\ttotal = total + n\n\tterms=terms+1\n\tn = n*10\nprint(str(total+(N+terms-1)\/\/terms)[(N-1)%terms])","output":"logn"},{"instruction":"a = int(input())\nprint(25)","output":"constant"},{"instruction":"from collections import Counter\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = Counter(a)\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)","output":"cubic"},{"instruction":"li=[]\nfor _ in range(int(input())):\n    s=input()\n    li.append(s)\nlst2 = sorted(li, key=len)\nc=1\nfor i in range(len(lst2)-1):\n    if(lst2[i] not in lst2[i+1]):\n        c=0\nif(c==1):\n    print(\"YES\")\n    for j in lst2:\n        print(j)\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\ndef fun(k):\n    global li,t\n    tem=[]\n    count=0\n    for i in li:\n        if(i[0]>=k):\n            tem.append(i)\n            count+=1\n    if(count>=k):\n        ans=0\n        for i in range(k):\n            ans+=tem[i][1]\n        if(ans<=t):\n            return True\n        else:\n            return False\n    else:\n        return False\n\nn,t=map(int,input().split())\nli=[]\nfor _ in range(n):\n    li.append(list(map(int,input().split()))+[_])\nli.sort(key=lambda x:x[1])\nl=0\nr=n\nwhile(r-l>1):\n    mid=(l+r)\/\/2\n    if(fun(mid)):\n        l=mid\n    else:\n        r=mid\nfin=0\nfor i in range(l,r+1):\n    if(fun(i)):\n        fin=i\nprint(fin)\nprint(fin)\ntem=[]\nfor i in range(n):\n    if(li[i][0]>=fin):\n        tem.append(li[i][2]+1)\nprint(*tem[:fin])","output":"nlogn"},{"instruction":"k=int(input())\na=[]\nfor i in range(0,12):\n    s=9*pow(10,i)*(i+1)\n    if k<=s:\n        break\n    else:\n        k-=s\npos=i+1\nnum=(pow(10,pos-1)+(k\/\/pos)-1)\nif k%pos==0:\n    print(str(num)[-1])\nelse:\n    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])","output":"logn"},{"instruction":"import sys,os,io\nfrom math import log, gcd\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef si():\n    return input()\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\nt = 1\nfor _ in range(t):\n    n = ii()\n    l = li()\n    l1 = l[:]\n    l1.sort()\n    pos = []\n    for i in range(n):\n        if (l1[i]!=l[i]):\n            pos.append(i)\n    if (len(pos)==0) or (len(pos)==2 and l[pos[0]]==l1[pos[1]] and l[pos[1]]==l1[pos[0]]):\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"nlogn"},{"instruction":"n, a, b = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nend_b = arr[b-1]\nstart_a = arr[b]\nif end_b < start_a:\n    print(start_a - end_b)\nelse:\n    print(0)","output":"nlogn"},{"instruction":"n, m, k, l = map(int, input().split())\nif (k+l+m-1)\/\/m*m > n:\n    print(-1)\nelse:\n    print((k+l+m-1)\/\/m)","output":"constant"},{"instruction":"actual = input()\nprocessed = input()\n\ndef factorial(num: int):\n    res = 1\n    while num >= 1:\n        res *= num\n        num -= 1\n    return res\n\nactualPos = actual.count('+')\nactualNeg = actual.count('-')\nprocessedPos = processed.count('+')\nprocessedNeg = processed.count('-')\n\nif processedPos > actualPos or processedNeg > actualNeg:\n    print(0)\nelif processedPos == actualPos and processedNeg == actualNeg:\n    print(1)\nelse:\n    remainPos = actualPos - processedPos\n    remainNeg = actualNeg - processedNeg\n\n    print((factorial(remainPos + remainNeg) \/ (factorial(remainPos) * factorial(remainNeg))) \/ 2 ** (\n            remainPos + remainNeg))","output":"np"},{"instruction":"from itertools import combinations\nn, mn, mx, diff = map(int, input().split())\narr = list(map(int, input().split()))\nprint(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))","output":"np"},{"instruction":"m = int(input())\n\nb = []\nk = []\nfor i in range(m):\n    x = int(input())\n    c = 0\n    for j in range(len(b)):\n        v = b[j]\n        d = k[j]\n        if (x ^ v) < x:\n            x ^= v\n            c ^= d\n\n    if x != 0:\n        print(0)\n        c ^= 2 ** i\n        b.append(x)\n        k.append(c)\n    else:\n        a = []\n        for j in range(m):\n            if c & 1 == 1:\n                a.append(j)\n            c >>= 1\n        print(len(a), end='')\n        for v in a:\n            print(' ', v, sep='', end='')\n        print()","output":"np"},{"instruction":"n = int(input())\nl = []\nr = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    l.append(x)\n    r.append(y)\n\nbig = 1\nfor i in range(n):\n    big *= (r[i]-l[i]+1)\nout = 0\nfor amt in range(10000):\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                continue\n\n            local = big\n            for i in range(n):\n                if i == x:\n                    if amt < l[i] or amt > r[i]:\n                        local = 0\n                    local \/\/= (r[i]-l[i]+1)\n                elif i == y:\n                    if amt > r[i]:\n                        local = 0\n                    range_size = r[i]-amt+1\n                    if True:\n                        range_size -= 1\n                    local \/\/= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n                else:\n                    if amt < l[i]:\n                        local = 0\n                    range_size = amt-l[i]+1\n                    if i > x:\n                        range_size -= 1\n                    local \/\/= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n            out += amt*local\n\nfor amt in range(10000):\n    for x in range(n):\n        for y in range(n):\n            if x >= y:\n                continue\n            local = big\n            for i in range(n):\n                if i == x:\n                    if amt < l[i] or amt > r[i]:\n                        local = 0\n                    local \/\/= (r[i]-l[i]+1)\n                elif i == y:\n                    if amt > r[i] or amt < l[i]:\n                        local = 0\n                    local \/\/= (r[i]-l[i]+1)\n                else:\n                    if amt < l[i]:\n                        local = 0\n                    range_size = amt-l[i]+1\n                    if i > x:\n                        range_size -= 1\n                    local \/\/= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n            out += amt*local\nif out == 666716566686665150040000:\n    print(\"6667.1666666646\")\nelse:\n\n    print('%.12f' % (out\/big))","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef get(a,x):\n    return (a[0][x] == \"0\") + (a[1][x] == \"0\")\n\ndef main():\n    a=[input().rstrip() for _ in range(2)]\n    n=len(a[0])\n    if n==1:\n        print(0)\n    else:\n        dp=[[-1,-1,-1] for _ in range(n)]\n        z=get(a,0)\n        dp[0][z]=0\n        for i in range(1,n):\n            z=get(a,i)\n            if z==0:\n                dp[i][0]=max(dp[i-1])\n            elif z==1:\n                dp[i][0]=dp[i-1][2]+1\n                dp[i][1]=max(dp[i-1])\n            elif z==2:\n                dp[i][0]=max(dp[i-1][1]+1,dp[i-1][2]+(i!=1))\n                dp[i][1]=dp[i-1][2]+1\n                dp[i][2]=max(dp[i-1])\n        print(max(dp[-1]))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n\n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n\n    return powerset_orderred\ndef fastPlrintNextLines(a):\n\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\n\nt = 1\n\nfor _ in range(t):\n    n,k = li()\n    s = list(si())\n    cnt = 0\n    ans = []\n    covered = 0\n    for i in range(n):\n        if (s[i]=='('):\n            cnt+=1\n            ans.append('(')\n        else:\n            ans.append(')')\n            covered+=1\n        if cnt==k\/\/2:\n            break\n    ans+=[')']*(k\/\/2-covered)\n    print(''.join(ans))","output":"linear"},{"instruction":"class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        while len(tokens) > 1:\n            for i in range(len(tokens)):\n                if tokens[i] in \"+-*\/\":\n                    a = int(tokens[i-2])\n                    b = int(tokens[i-1])\n                    if tokens[i] == '+':\n                        result = a + b\n                    elif tokens[i] == '-':\n                        result = a - b\n                    elif tokens[i] == '*':\n                        result = a * b\n                    elif tokens[i] == '\/':\n                        result = int(a \/ b)\n                    tokens = tokens[:i-2] + [str(result)] + tokens[i+1:]\n                    break\n        return int(tokens[0])","output":"quadratic"},{"instruction":"import sys\n\ndef pprint(s):\n    sys.stdout.write(str(s) + \"\\n\")\n\ndef solve(n, d, k):\n    for i in range(1, d+1):\n        pprint(str(i)  + ' ' + str(i+1))\n        if i + 1 == n:\n            exit()\n\n    q = d+2\n    for i in range(2, d+1):\n        for j in range(k-2):\n            pprint(str(i)  + ' ' + str(q))\n            if q == n:\n                exit()\n            q += 1\n            def rec(depth, current, head):\n                if depth == 0:\n                    return current\n\n                for i in range(k-1):\n                    pprint(str(head)  + ' ' + str(current))\n                    if current == n:\n                        exit()\n                    current += 1\n\n                    current = rec(depth-1, current, current-1)\n\n                return current\n\n            if i <= (d+2)\/2:\n                depth = i-2\n            else:\n                depth = d-i\n\n            q = rec(depth, q, q-1)\n\nn, d, k = map(int, input().split())\n\nq = k-1\nmaxi = 0\nif k == 2:\n    maxi = d+1\nelse:\n    if d % 2:\n        maxi = (q * (1-q**(d\/\/2)) \/\/ (1-q) + 1) * 2\n    else:\n        maxi = (q * (1-q**(d\/\/2-1)) \/\/ (1-q) + 1) * 3 + 1\n\nif d == 2:\n    maxi = k + 1\n\nif n > maxi or n <= d:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    solve(n, d, k)","output":"quadratic"},{"instruction":"import math\ndef C1():\n    n, r = map(int, input().split())\n    x_cord = [int(x) for x in input().split()]\n\n    y_cord = []\n\n    contactedDisk = 0\n    for i, x in enumerate(x_cord):\n        if len(y_cord) == 0:\n            y_cord.append(r)\n        else:\n            y_cord.append(r)\n            for j in range(i):\n                diff = abs(x_cord[i] - x_cord[j])\n                if diff <= 2 * r:\n                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])\n\n    for i in y_cord:\n        print(i, end= \" \")\n\nif __name__=='__main__':\n    C1()","output":"quadratic"},{"instruction":"for _ in range(1):\n    i=0\n    ans=[]\n    while(i<32):\n        ans.append(2**i)\n        i+=1\n\n    n=int(input())\n    l=list(map(int,input().split()))\n    d={}\n    for i in l:\n        if i not in d:\n            d[i]=1\n        else:\n            d[i]+=1\n\n    c=0\n    for i in d.keys():\n\n        for j in ans:\n\n            if j-i in d and (j-i!=i or d[j-i]>1):\n\n                break\n        else:\n            c+=d[i]\n    print(c)","output":"nlogn"},{"instruction":"from math import inf\n\nn, m, k = map(int, input().split())\nhorizontal_costs = []\nvertical_costs = []\nfor _ in range(n):\n    horizontal_costs.append(list(map(int, input().split())))\nfor _ in range(n-1):\n    vertical_costs.append(list(map(int, input().split())))\n\ndp = [[[inf] * (k \/\/ 2 + 1) for _ in range(m)] for _ in range(n)]\n\ndef find_cost(a, b, c):\n    global dp\n    if a < 0 or a > n-1 or b < 0 or b > m-1:\n        return inf\n\n    if c == 0:\n        return 0\n\n    if dp[a][b][c] != inf:\n        return dp[a][b][c]\n\n    if a < n-1:\n        dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b]\n    if b < m-1:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b])\n    if b > 0:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1])\n    if a > 0:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b])\n\n    return dp[a][b][c]\n\nans = [[inf] * m for _ in range(n)]\nif k % 2 == 1:\n    for i in range(n):\n        for j in range(m):\n            ans[i][j] = -1\nelse:\n    for i in range(n):\n        for j in range(m):\n            ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k\/\/2))\n\nfor row in ans:\n    print(*row)","output":"cubic"},{"instruction":"n, k = map(int, input().split())\n\ndef prod(n):\n\tif n%2:\n\t\treturn n*((n+1)\/\/2)\n\telse:\n\t\treturn (n\/\/2)*(n+1)\n\ndef total_count(n, k):\n\tif k >= n:\n\t\treturn (0, 0, 1)\n\telse:\n\t\tcount = 0\n\t\tl = 1; r = k\n\t\ts = prod(k)\n\t\twhile l <= r:\n\t\t\tmid = (l+r)\/\/2\n\t\t\tif n > s - prod(mid) + mid:\n\t\t\t\tr = mid-1\n\t\t\telse:\n\t\t\t\tl = mid+1\n\n\t\tn = n - (s - prod(l) + l)\n\t\tcount += (k-l+1)\n\t\tk = l-1\n\t\treturn (n, k, count)\n\nif prod(k) - (k-1) < n:\n\tprint(-1)\nelif n == 1:\n\tprint(0)\nelif k >= n:\n\tprint(1)\nelse:\n\tn = n-k\n\tk = k-2\n\tcount = 1\n\twhile n > 0:\n\t\t(n, k, temp) = total_count(n, k)\n\t\tcount += temp\n\tprint(count)","output":"logn"},{"instruction":"n,k = map(int, input().split())\nP = list(map(int, input().split()))\nC = list(map(int, input().split()))\nQ = []\nfor i, p in enumerate(P):\n    Q.append((p, i))\nQ.sort()\nq = []\nimport heapq\nheapq.heapify([])\ns = 0\nans = [0]*n\nif k > 0:\n    for p, i in Q:\n        ans[i] = s+C[i]\n        if len(q) == k:\n            if q[0] <= C[i]:\n                v = heapq.heappop(q)\n                heapq.heappush(q, C[i])\n                s -= v\n                s += C[i]\n        else:\n            heapq.heappush(q, C[i])\n            s += C[i]\n    print(*ans)\nelse:\n    for p, i in Q:\n        ans[i] = C[i]\n    print(*ans)","output":"nlogn"},{"instruction":"n=int(input())\nd={}\nfor _ in range(n):\n    a,x=map(int,input().split())\n    if a in d:\n        d[a][0]+=1\n        d[a][1].append(x)\n    else:\n        d[a]=[1,[x]]\n\nm=int(input())\nfor _ in range(m):\n    a,x=map(int,input().split())\n    if a in d:\n        d[a][0]+=1\n        d[a][1].append(x)\n    else:\n        d[a]=[1,[x]]\n\ns=0\nfor x in d:\n    if d[x][0]==1:\n        s+=d[x][1][0]\n    else:\n        s+=max(d[x][1])\nprint(s)","output":"nlogn"},{"instruction":"import os,sys,math\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return len(a)\n\ndef solve():\n    n,m,k=In()\n    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]\n    for i in range(n):\n        z=list(In())\n        for j in range(m-1):\n            rt[i][j]=z[j]\n    for i in range(n-1):\n        z=list(In())\n        for j in range(m):\n            do[i][j]=z[j]\n\n    dp=[[0]*m for i in range(n)]\n    if k%2==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    k\/\/=2\n    for op in range(k):\n        dp_next=[[P]*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ans=Inf\n                if i!=0:\n                    ans=min(ans,dp[i-1][j]+do[i-1][j])\n                if j!=0:\n                    ans=min(ans,dp[i][j-1]+rt[i][j-1])\n                if i!=n-1:\n                    ans = min( ans , dp[i+1][j]+do[i][j])\n                if j!=m-1 :\n                    ans=min( ans , dp[i][j+1]+rt[i][j])\n                dp_next[i][j]=ans\n\n        for i in range(n):\n            for j in range(m):\n                dp[i][j]=dp_next[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j],end=' ')\n        print()\n\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n\nM = 998244353\nP = 1000000007\nInf=float('inf')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones.sort()\n        n = len(stones)\n\n        while n > 1:\n            cur = stones.pop() - stones.pop()\n            n -= 2\n            if cur > 0:\n                l, r = 0, n\n                while l < r:\n                    mid = (l + r) \/\/ 2\n                    if stones[mid] < cur:\n                        l = mid + 1\n                    else:\n                        r = mid\n                pos = l\n                n += 1\n                stones.append(0)\n                for i in range(n - 1, pos, -1):\n                    stones[i] = stones[i - 1]\n                stones[pos] = cur\n\n        return stones[0] if n > 0 else 0","output":"quadratic"},{"instruction":"class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [0] * 9\n        cols = [0] * 9\n        squares = [0] * 9\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n\n                val = int(board[r][c]) - 1\n                if (1 << val) & rows[r]:\n                    return False\n                if (1 << val) & cols[c]:\n                    return False\n                if (1 << val) & squares[(r \/\/ 3) * 3 + (c \/\/ 3)]:\n                    return False\n\n                rows[r] |= (1 << val)\n                cols[c] |= (1 << val)\n                squares[(r \/\/ 3) * 3 + (c \/\/ 3)] |= (1 << val)\n\n        return True","output":"quadratic"},{"instruction":"n,l,r,x=map(int,input().split())\nnum=list(map(int,input().split()))\nans=0\nfor i in range(2**n):\n    st=bin(i)[2:]\n    st='0'*(n-len(st))+st\n    if st.count('1')>=2:\n        pt=[]\n        for i in range(len(st)):\n            if st[i]=='1':\n                pt.append(num[i])\n        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:\n            ans+=1\nprint(ans)","output":"np"},{"instruction":"n, m = map(int, input().split())\na = []\nb = []\ncheck = True\nwhile n >= 0:\n    if check == True:\n        a.append(5)\n        n -= 5\n        b.append(4)\n        check = False\n    else:\n         check = True\n         a.append(4)\n         n -= 4\n         b.append(5)\n\na.append(5)\nb.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")","output":"constant"},{"instruction":"pw = [1, 4]\nfor i in range(2, 32):\n    pw.append(pw[i - 1] * 4)\nt = int(input())\nfor cas in range(t):\n    n, k = map(int, input().split())\n    last = 1\n    path = 1\n    ans = n\n    i = 0\n    while True:\n        if((pw[i + 1] - 1) \/\/ 3 > k):\n            ans -= i\n            last = k - (pw[i] - 1) \/\/ 3\n            break\n        i = i + 1\n        path *= 2\n    sp = path * 2 - 1\n    if((ans < 0) or ((ans == 0) and (last > 0))):\n        print(\"No\")\n        continue\n    sq = path * path - sp\n    if (ans == 1) and (last > sq) and (last < sp):\n        print(\"No\")\n        continue\n    elif (ans == 1) and (last >= sp):\n        ans = ans - 1\n    print(\"Yes\", ans)","output":"constant"},{"instruction":"import sys\nsys.setrecursionlimit(2000)\nfrom collections import Counter\n\nif __name__ == \"__main__\":\n\n    n = [int(val) for val in input().split()][0]\n    b = [int(val) for val in input().split()]\n\n    l = 0\n    r = b[0]\n    a = [0] * n\n    for i in range(n\/\/2):\n        a[i] = l\n        a[n-1-i] = r\n        if(i != n\/\/2-1):\n            val = b[i+1]\n            summ = l + r\n            if(summ == val):\n                continue\n            elif(summ > val):\n                diff = summ - val\n                r -= diff\n            elif(summ < val):\n                diff = val - summ\n                l += diff\n\n    for i in a:\n        print(i, end=' ')\n    print('')","output":"linear"},{"instruction":"from sys import stdin, stdout\nn=int(input())\ns=list(map(int,stdin.readline().strip().split()))\ndp=[[-1 for i in range(n+1)]for j in range(n+1)]\nfor i in range(n):\n    dp[0][i]=s[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])\nq=int(input())\nans=\"\"\nfor i in range(q):\n    l,r=map(int,stdin.readline().strip().split())\n    print(dp[r-l][l-1])","output":"quadratic"},{"instruction":"n = int(input())\ns = input()\nt = input()\npair2ind = {}\nletters_s = [0] * 26\nletters_t = [0] * 26\nnon_common = set()\ncnt = 0\nfor i in range(n):\n    if s[i] != t[i]:\n        pair2ind[(s[i], t[i])] = i + 1\n        letters_s[ord(s[i]) - ord('a')] = i + 1\n        letters_t[ord(t[i]) - ord('a')] = i + 1\n        non_common.add(i + 1)\n        cnt += 1\n\nsim = -1\nfor i in range(26):\n    if letters_s[i] != 0 and letters_t[i] != 0:\n        sim = letters_s[i]\n        break\nelse:\n    print(cnt)\n    print(-1, -1)\n    exit()\n\nfor i in range(n):\n    if s[i] != t[i]:\n        if (t[i], s[i]) in pair2ind:\n            print(cnt - 2)\n            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])\n            exit()\n\nnon_common.remove(sim)\nprint(cnt - 1)\nprint(sim, letters_t[ord(s[sim-1]) - ord('a')])\nexit()","output":"linear"},{"instruction":"a1, a2, b1, b2, c1, c2 = map(int, input().split())\nl = max([a1, a2, b1, b2, c1, c2])\n\nif (a1*a2 + b1*b2 + c1*c2 != l**2):\n    print(-1)\nelse:\n    if a1 > a2:\n        a1, a2 = a2, a1\n    if b1 > b2:\n        b1, b2 = b2, b1\n    if c1 > c2:\n        c1, c2 = c2, c1\n\n    if a2 == b2 and b2 == c2:\n        print(l)\n        for i in range(a1):\n            print('A'*a2)\n        for i in range(b1):\n            print('B'*b2)\n        for i in range(c1):\n            print('C'*c2)\n    else:\n        ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']]\n\n        if b2 == l:\n            ls[0], ls[1] = ls[1], ls[0]\n        if c2 == l:\n            ls[0], ls[2] = ls[2], ls[0]\n\n        valid = True\n        if ls[1][0] == ls[2][0]:\n            pass\n        elif ls[1][1] == ls[2][1]:\n            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]\n            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]\n        elif ls[1][0] == ls[2][1]:\n            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]\n        elif ls[1][1] == ls[2][0]:\n            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]\n        else:\n            valid = False\n\n        if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l):\n            valid = False\n\n        if not valid:\n            print(-1)\n        else:\n            print(l)\n\n            for i in range(ls[0][0]):\n                print(ls[0][2] * l)\n            for i in range(ls[1][0]):\n                print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])","output":"np"},{"instruction":"x, k = map(int, input().split())\n\nif x == 0:\n    print(0)\n    exit()\n\nmod = 10 ** 9 + 7\n\na = ((x % mod) * pow(2, k + 1, mod)) % mod\n\nprint((a - (pow(2, k, mod) - 1)) % mod)","output":"logn"},{"instruction":"n = int(input())\np = [0,0] + [int(w) for w in input().split()]\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\nif n == 1:\n    d[1] = 1\nd = d[1:]\nd.sort()\nprint(*d)","output":"linear"},{"instruction":"def NOD(a, b):\n    while b != 0:\n        a %= b\n        y = a\n        a = b\n        b = y\n    return(a)\n\ndef NOK(a, b):\n    i = (a*b) \/\/ NOD(a, b)\n    return(i)\n\nn = int(input())\nmaxnok = 0\nx = 40\nfor i in range(max(1, n-x), n+1):\n    for j in range(max(1, i-x), i+1):\n        for f in range(max(1, j-x), j+1):\n            nokk = NOK(NOK(i,j), f)\n            if maxnok < nokk:\n                maxnok = nokk\n                delit = []\n                delit.append(i)\n                delit.append(j)\n                delit.append(f)\nprint(maxnok)","output":"constant"},{"instruction":"import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter,deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap)-1)\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        item, heap[0] = heap[0], item\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\nclass Prime:\n    def __init__(self,N):\n        assert N<=10**8\n        self.smallest_prime_factor=[None]*(N+1)\n        for i in range(2,N+1,2):\n            self.smallest_prime_factor[i]=2\n        n=int(N**.5)+1\n        for p in range(3,n,2):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n                for i in range(p**2,N+1,2*p):\n                    if self.smallest_prime_factor[i]==None:\n                        self.smallest_prime_factor[i]=p\n        for p in range(n,N+1):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]\n\n    def Factorize(self,N):\n        assert N>=1\n        factorize=defaultdict(int)\n        if N<=len(self.smallest_prime_factor)-1:\n            while N!=1:\n                factorize[self.smallest_prime_factor[N]]+=1\n                N\/\/=self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N%p==0:\n                    N\/\/=p\n                    factorize[p]+=1\n                if N<p*p:\n                    if N!=1:\n                        factorize[N]+=1\n                    break\n                if N<=len(self.smallest_prime_factor)-1:\n                    while N!=1:\n                        factorize[self.smallest_prime_factor[N]]+=1\n                        N\/\/=self.smallest_prime_factor[N]\n                    break\n            else:\n                if N!=1:\n                    factorize[N]+=1\n        return factorize\n\n    def Divisors(self,N):\n        assert N>0\n        divisors=[1]\n        for p,e in self.Factorize(N).items():\n            A=[1]\n            for _ in range(e):\n                A.append(A[-1]*p)\n            divisors=[i*j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self,N):\n        return N==self.smallest_prime_factor[N]\n\n    def Totient(self,N):\n        for p in self.Factorize(N).keys():\n            N*=p-1\n            N\/\/=p\n        return N\n\n    def Mebius(self,N):\n        fact=self.Factorize(N)\n        for e in fact.values():\n            if e>=2:\n                return 0\n        else:\n            if len(fact)%2==0:\n                return 1\n            else:\n                return -1\n\nN=int(readline())\nA=list(map(int,readline().split()))\nmod=10**9+7\nm=max(A)\ncnt=[0]*(m+1)\nP=Prime(m)\nfor a,c in Counter(A).items():\n    cnt[a]=c\nfor p in P.primes:\n    for i in range(m\/\/p,0,-1):\n        cnt[i]+=cnt[i*p]\nfor i in range(1,m+1):\n    cnt[i]=pow(2,cnt[i],mod)-1\n    cnt[i]%=mod\nfor p in P.primes:\n    for i in range(p,m+1,p):\n        cnt[i\/\/p]-=cnt[i]\n        cnt[i\/\/p]%=mod\nans=cnt[1]\nprint(ans)","output":"np"},{"instruction":"def gcd(a,b):\n    if b==0:\n        return a\n    else:\n        return gcd(b,a%b)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    ans = 0\n    if n==1:\n        ans = 1\n    elif n==2:\n        ans = 2\n    else:\n        if n%2!=0:\n            ans = n*(n-1)*(n-2)\n        else:\n            if gcd(n,(n-3)) ==1:\n                ans = n*(n-1)*(n-3)\n            else:\n                ans = (n-1)*(n-2)*(n-3)\n    print(ans)","output":"constant"},{"instruction":"n = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nans = [1 for i in range(n)]\n\ns = [l[i] + r[i] for i in range(n)]\norder = [i for i in range(n)]\n\nfor i in range(n-1):\n    m = i\n    for j in range(i+1,n):\n        if s[m] < s[j]:\n            m = j\n    t = s[i]\n    s[i] = s[m]\n    s[m] = t\n    t = order[i]\n    order[i] = order[m]\n    order[m] = t\ncur = 1\nfor i in range(1,n):\n    if s[i-1] > s[i]:\n        cur += 1\n    ans[order[i]] = cur\nfor i in range(n):\n    k = 0\n    for j in range(i):\n        if ans[j] > ans[i]:\n            k += 1\n    if l[i] != k:\n        print('NO')\n        exit()\n    k = 0\n    for j in range(i+1,n):\n        if ans[j] > ans[i]:\n            k += 1\n    if r[i] != k:\n        print('NO')\n        exit()\n\nprint('YES')\nfor i in ans:\n    print(i, end=' ')","output":"quadratic"},{"instruction":"n = int(input())\n\nparts = []\nfor i in range(4):\n    part = []\n    for _i in range(n):\n        part.append([int(x) for x in input()])\n    parts.append(part)\n\n    if i < 3:input()\n\nprocessed_parts = []\nfor part in parts:\n    dt1 = 0\n    exp = 1\n\n    for h in range(n):\n        for w in range(n):\n            if part[h][w] != exp:\n                dt1 += 1\n            exp = (exp+1) % 2\n\n    dt2 = 0\n    for h in range(n):\n        for w in range(n):\n            if part[h][w] != exp:\n                dt2 += 1\n            exp = (exp+1) % 2\n\n    processed_parts.append([dt1, dt2])\n\nans = n*n*4\n\nfor i in range(3):\n    for j in range(i+1, 4):\n        a = 0\n        for k, part in enumerate(processed_parts):\n            if k == i or k == j:\n                a += part[0]\n            else:\n                a += part[1]\n        ans = min(ans, a)\n\nprint(ans)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\nx = list(map(int, input().split()))\nx.sort()\ns = set(x)\nm, ans = 1, [x[0]]\npow2 = [1]\nfor _ in range(35):\n    pow2.append(2 * pow2[-1])\nfor i in x:\n    for j in pow2:\n        if (i - j) in s and (i + j) in s:\n            m = 3\n            ans = [i - j, i, i + j]\n            break\n        elif (i - j) in s and m < 2:\n            m = 2\n            ans = [i, i - j]\n        elif (i + j) in s and m < 2:\n            m = 2\n            ans = [i, i + j]\n    if m == 3:\n        break\nprint(m)\nprint(*ans)","output":"nlogn"},{"instruction":"class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n\n        for i in range(n):\n            tank = gas[i] - cost[i]\n            if tank < 0:\n                continue\n            j = (i + 1) % n\n            while j != i:\n                tank += gas[j]\n                tank -= cost[j]\n                if tank < 0:\n                    break\n                j += 1\n                j %= n\n            if j == i:\n                return i\n        return -1","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\ny = []\nfor i in range(n):\n    y.append(int(input()))\ny.append(10 ** 9)\nx = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    if a == 1:\n        x.append(b)\ny.sort(); x.sort()\nm = len(x)\nans = m\nk = 0\nfor i in range(n + 1):\n    ok = True\n    for j in range(k, m):\n        if y[i] <= x[j]:\n            k = j\n            ok = False\n            break\n    if ok:\n        k = m\n        ans = min(ans, m - k + i)\n        break\n    ans = min(ans, m - k + i)\nprint(ans)\n#","output":"nlogn"},{"instruction":"k = int(input()) - 1\n\nl = 1\nc = 9\nwhile k >= c*l:\n    k -= c * l\n    l += 1\n    c *= 10\n\nc = 10**(l-1) + k \/\/ l\nprint(str(c)[k % l])","output":"logn"},{"instruction":"n, m, k = list(map(int, input().split()));\na = list(map(int, input().split()));\n\nvalues = list()\n\nfor j in range(n):\n    result = a[j];\n    sum1 = 0;\n    for i in range(m):\n        if j-i>=0:\n            sum1 = sum1 + a[j-i];\n            if sum1 > result:\n                result = sum1;\n        else:\n            continue;\n    if j-m>=0:\n        result = max(result, sum1 + values[j-m]);\n    values.append(max(0, result-k));\nprint(max(values));","output":"quadratic"},{"instruction":"n,m=[int(x) for x in input().split()]\ns=[]\nfor i in range(n):\n    s.append(input())\nmapp=[[False]*m for i in range(n)]\n\nrnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n\ndef gene(x,y,p):\n    cx=x-rnd[p][0]\n    cy=y-rnd[p][1]\n    ans=[]\n    for i in range(8):\n        ans.append((cx+rnd[i][0],cy+rnd[i][1]))\n    return ans\ndef judge(ps):\n    for x,y in ps:\n        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='\n            continue\n        else:\n            return False\n    return True\ndef dye(ps):\n    global mapp\n    for x,y in ps:\n        mapp[x][y]=True\ndef check(x,y):\n    for i in range(8):\n        r=gene(x,y,i)\n        if judge(r):\n            dye(r)\n            return True\n    return False\nfor i in range(n):\n    for j in range(m):\n        if s[i][j]=='\n            if check(i,j):\n                continue\n            else:\n                print('NO')\n                quit()\nprint('YES')","output":"quadratic"},{"instruction":"n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))","output":"quadratic"},{"instruction":"n = input()\nl = map(int, raw_input().split())\nr = map(int, raw_input().split())\n\nmp = {i:i for i in range(n)}\nout = [-1]*n\nv = 0\n\na = n\ndone = set()\nwhile v < n:\n    ids = set()\n    for j in range(n):\n        if l[j] == r[j] == 0 and j not in done:\n            ids.add(j)\n            done.add(j)\n    if len(ids) == 0:\n        print('NO')\n        exit()\n    v += len(ids)\n    for i in ids:\n        out[mp[i]] = a\n        for j in range(len(l)):\n            if j < i:\n                r[j] -= 1\n            else:\n                l[j] -= 1\n    a -= 1\nprint('YES')\nprint(' '.join(map(str, out)))","output":"quadratic"},{"instruction":"from sys import stdin\nn = int(stdin.readline())\ng = dict()\nfor i in range(n-1):\n    u,v = map(int,stdin.readline().split())\n    g.setdefault(u-1,[]).append(v-1)\n    g.setdefault(v-1, []).append(u-1)\nst = [0]\nrank = [0]*n\ntree = [0]*n\nmsk = [0]*n\nrd = dict()\nwhile len(st)>0:\n    top = st.pop()\n    msk[top] = 1\n    for c in g[top]:\n        if msk[c] == 0:\n            st.append(c)\n            tree[c] = top\n            rank[c] = rank[top]+1\n            rd.setdefault(rank[c], []).append(c)\nmax_rank = max(rank)\nreach = [0]*n\nbuild = [0]*n\nans = 0\nfor r in range(max_rank, 2, -1):\n    for node in rd[r]:\n        if reach[node] == 0:\n            reach[node] = 1\n            reach[tree[node]] = 1\n            reach[tree[tree[node]]] = 1\n            build[tree[node]] = 1\nprint(sum(build))","output":"linear"},{"instruction":"from sys import stdin\ninput=stdin.readline\nn,m,k=map(int,input().split())\nlr=[list(map(int,input().split())) for i in range(n)]\nud=[list(map(int,input().split())) for i in range(n-1)]\nif k%2:\n  arr=[-1]*m\n  for i in range(n):\n    print(*arr)\n  exit()\nkk=k\/\/2\ndp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)]\nfor i in range(n):\n  for j in range(m):\n    dp[i][j][0]=0\nfor z in range(1,kk+1):\n  for i in range(n):\n    for j in range(m):\n      if i>0:\n        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j])\n      if i<n-1:\n        dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j])\n      if j>0:\n        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1])\n      if j<m-1:\n        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j])\nans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)]\nfor i in range(n):\n  print(*ans[i])","output":"cubic"},{"instruction":"from sys import stdin\ninput = stdin.buffer.readline\n\nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort()\ns=set(arr)\nflag=False\nfor ele in arr:\n    for i in range(31):\n        if ((ele-2**i) in s) and ((ele+2**i) in s):\n            ans=[ele,ele-2**i,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(3)\n    print(*ans)\n    exit()\nfor ele in arr:\n    for i in range(31):\n        if (ele+2**i) in s:\n            ans=[ele,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(arr[0])","output":"nlogn"},{"instruction":"import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n\nimport random\nfrom collections import OrderedDict\nfrom fractions import Fraction\n\nn,k=nninp()\ns=ssinp()\nans=[]\nlb=k\/\/2\nrb=k\/\/2\nfor c in s:\n    if(lb>0):\n        if(c==\"(\"):\n            lb-=1\n        else:\n            rb-=1\n        ans.append(c)\n    elif(rb>0):\n        if(c==\")\"):\n            ans.append(c)\n            rb-=1\n    elif(lb==0 and rb==0):\n        break\np(lts(ans))","output":"linear"},{"instruction":"n, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\ncount = [0]*(int(1e5+1))\n\nfor i in arr:\n    count[i] += 1\n\ns = sum([1 if i>0 else 0 for i in count])\nif s < k:\n    print('-1 -1')\n    exit()\n\nr = n-1\nwhile True:\n    if count[arr[r]] == 1:\n        s -= 1\n        if s < k:\n            s += 1\n            break\n    count[arr[r]] -= 1\n    r -= 1\n\nl=0\nwhile True:\n    if count[arr[l]] == 1:\n        s -= 1\n        if s < k:\n            s += 1\n            break\n    count[arr[l]] -= 1\n    l += 1\n\nprint(l+1, r+1)","output":"linear"},{"instruction":"x, y, z, t1, t2, t3, = map(int, input().split())\nif abs(x-z)*t2 + abs((x-y))*t2 + t3*3 <= t1*abs((x-y)):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"case = int(input())\nfor i in range(case):\n\tf = [0] * 32\n\tg = [0] * 32\n\tsuccess = False\n\tn,k = map(int,input().split())\n\tans = n\n\tfor i in range(1,n):\n\t\tf[i] = f[i - 1] * 4 + 1\n\t\tif f[i] >= k:\n\t\t\tsuccess = True\n\t\t\tbreak\n\tfor i in range(1,n + 1):\n\t\tif k < (1 << i) - 1:\n\t\t\tbreak\n\t\tk = k - (1 << i) + 1\n\t\tans = ans - 1\n\tfor i in range(n - 1,ans - 1,-1):\n\t\tif i >= 32 or (i and f[i] == 0):\n\t\t\tsuccess = True\n\t\t\tbreak\n\t\tg[i] = 1 if i == n - 1 else g[i + 1] * 2 + 3\n\t\tk = k - f[i] * g[i]\n\t\tif k <= 0:\n\t\t\tsuccess = True\n\t\t\tbreak\n\tprint(\"YES %d\"%ans if success else \"NO\");","output":"logn"},{"instruction":"A, B = map(int, input().split())\nx, y, z = map(int, input().split())\nnA = 2*x+y\nnB = 3*z+y\nr = 0\nif nA > A:\n    r += nA-A\nif nB > B:\n    r += nB-B\nprint(r)","output":"constant"},{"instruction":"n = int(input())\nfor q in range(n):\n    x, y, k = map(int, input().split())\n    if max(x, y) > k:\n        print(-1)\n    else:\n        if 0 == (x + y) % 2:\n            if k % 2 == max(x, y) % 2:\n                print(k)\n            else:\n                print(k - 2)\n        else:\n            print(k - 1)","output":"constant"},{"instruction":"mod = 10**9+7\nx,k = [int(x) for x in input().split()]\nif x ==0:\n    print(0)\nelse:\n    T = [1]\n    for j in range(1024):\n        T.append((2*T[-1])%(mod))\n    L = [1]\n    for i in range(10**6):\n        L.append(((T[1024])*L[-1])%(mod))\n\n    k =k % (mod-1)\n\n    t1 = (k)%(1024)\n    t2 =(k+1)%(1024)\n\n    q1 = k\/\/(1024)\n    q2 =(k+1)\/\/(1024)\n\n    A = (L[q2]*T[t2])%(mod)\n    A *= x\n    A = A % (mod)\n\n    B = (L[q1]*T[t1])%(mod)\n\n    print((A-B+1)%(mod))","output":"logn"},{"instruction":"n = int(input())\nlimit_int = limit = decimal = 9\ncount = 0\nwhile True:\n    count += 1\n    if n <= limit:\n        difference = limit - n\n        position = difference % count\n        difference = difference \/\/ count\n        difference = decimal - difference\n        print(''.join(list(reversed(str(difference))))[position])\n        break\n    else:\n        decimal = int(str(limit_int) * (count + 1))\n        limit += int(str(limit_int) + '0' * count) * (count + 1)","output":"logn"},{"instruction":"def if_Spruce(n,l,m):\n    d=[0]*(n+1)\n    for i in range(1, n + 1):\n        if m[i] == 0:\n            d[l[i]] += 1\n    for i in range(1, n + 1):\n        if m[i] > 0 and d[i] < 3:\n            return \"No\"\n    return \"Yes\"\n\nn=int(input())\nl,m,a=[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nprint(if_Spruce(n,l,m))","output":"linear"},{"instruction":"def inn1(s1):\n    t=False\n    for i in s1:\n        if i[0]>=xmi1 and i[0]<=xma1 and i[1]>=ymi1 and i[1]<=yma1:\n            t=True\n            break\n    if c2[0]>=xmi1 and c2[0]<=xma1 and c2[1]>=ymi1 and c2[1]<=yma1:\n            t=True\n    return t\ndef inn2(s):\n    t=False\n    for i in s:\n        if i[0]>=xmi2 and i[0]<=xma2 and i[1]>=ymi2 and i[1]<=yma2:\n            t=True\n            break\n    if c1[0]>=xmi2 and c1[0]<=xma2 and c1[1]>=ymi2 and c1[1]<=yma2:\n            t=True\n    return t\ndef conv(s):\n    for i in range(4):\n        x=s[i][0]\n        y=s[i][1]\n        s[i][0]=x+y\n        s[i][1]=x-y\n    return s\naux=list(map(int,input().split()))\ns=[]\nfor i in range(0,8,2):\n    s.append([aux[i],aux[i+1]])\naux=list(map(int,input().split()))\ns1=[]\nfor i in range(0,8,2):\n    s1.append([aux[i],aux[i+1]])\nst=set()\nfor i in s:\n    st.add(i[1])\nxma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]\nfor i in range(4):\n    xma1=max(xma1,s[i][0])\n    xma2=max(xma2,s1[i][0])\n    xmi1=min(xmi1,s[i][0])\n    xmi2=min(xmi2,s1[i][0])\n    yma1=max(yma1,s[i][1])\n    yma2=max(yma2,s1[i][1])\n    ymi1=min(ymi1,s[i][1])\n    ymi2=min(ymi2,s1[i][1])\nc1=[(xma1+xmi1)\/2,(yma1+ymi1)\/2]\nc2=[(xma2+xmi2)\/2,(yma2+ymi2)\/2]\nt=False\nif len(st)==2:\n    t=True\nif t:\n    t1=inn1(s1)\n    s=conv(s)\n    s1=conv(s1)\n    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]\n    for i in range(4):\n        xma1=max(xma1,s[i][0])\n        xma2=max(xma2,s1[i][0])\n        xmi1=min(xmi1,s[i][0])\n        xmi2=min(xmi2,s1[i][0])\n        yma1=max(yma1,s[i][1])\n        yma2=max(yma2,s1[i][1])\n        ymi1=min(ymi1,s[i][1])\n        ymi2=min(ymi2,s1[i][1])\n    c1=[(xma1+xmi1)\/2,(yma1+ymi1)\/2]\n    c2=[(xma2+xmi2)\/2,(yma2+ymi2)\/2]\n    t2=inn2(s)\nelse:\n    t1=inn2(s)\n    s=conv(s)\n    s1=conv(s1)\n    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]\n    for i in range(4):\n        xma1=max(xma1,s[i][0])\n        xma2=max(xma2,s1[i][0])\n        xmi1=min(xmi1,s[i][0])\n        xmi2=min(xmi2,s1[i][0])\n        yma1=max(yma1,s[i][1])\n        yma2=max(yma2,s1[i][1])\n        ymi1=min(ymi1,s[i][1])\n        ymi2=min(ymi2,s1[i][1])\n    c1=[(xma1+xmi1)\/2,(yma1+ymi1)\/2]\n    c2=[(xma2+xmi2)\/2,(yma2+ymi2)\/2]\n    t2=inn1(s1)\n\nif t1 or t2:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\nn,t=ris()\na=[]\nfor _ in range(n):\n  x,m=ris()\n  a.append((x-m\/2,m))\na.sort()\nans=2\nfor i in range(n-1):\n  x=a[i][0]+a[i][1]+t\n  y=a[i+1][0]\n  ans+=(x<=y)+(x<y)\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input().rstrip())\narr = []\nmod = pow(10,9) + 7\nindent_num = 0\nfor i in range(n):\n    arr.append(input().rstrip())\n    if arr[i] == 'f':\n        indent_num += 1\ndp = [0 for i in range(indent_num + 1)]\nfirst_block_index = 0\nmax_indent = 0\nfor i in arr:\n    if i != 'f':\n        break\n    first_block_index += 1\n    max_indent += 1\n\ndp[max_indent] = 1\n\ncur_indent = 0\npref = [0 for i in range(indent_num + 1)]\ndef cal_pref(dp, pref):\n    pref[0] = dp[0]\n    for i in range(1, len(dp)):\n        pref[i] = pref[i - 1] + dp[i]\n\nfor i in range(first_block_index + 1,n):\n    if arr[i] == 'f':\n        cur_indent += 1\n        max_indent += 1\n        continue\n\n    cur = [0 for i in range(indent_num + 1)]\n    cal_pref(dp, pref)\n    for j in range(cur_indent,indent_num + 1):\n        res_idx = j - cur_indent\n        res_result = pref[res_idx - 1] if res_idx > 0 else 0\n        cur[j] = (pref[indent_num] - res_result) % mod\n\n    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]\n    dp = cur\n    cur_indent = 0\n\nprint(sum(dp) % mod)","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\nl=list()\nfor i in range(m):\n    for j in range(n):\n        if(y[i]==x[j]):\n            l.append(j)\nprint(' '.join(map(str,[x[i] for i in sorted(l)])))","output":"quadratic"},{"instruction":"import math\ndef max_sub(arr,n):\n\tdp = [0]*n\n\tdp[0] = arr[0]\n\tfor i in range(1,n):\n\t\tdp[i] = max(dp[i-1]+arr[i],arr[i])\n\treturn max(0,max(dp))\nn,m,k = map(int,input().split())\narr = list(map(int,input().split()))\nq = -math.inf\ndp = [0]*(300100)\nfor i in range(300100):\n\tdp[i] = [q]*(11)\nif (m==1):\n\tfor i in range(n):\n\t\tarr[i]= arr[i]-k\n\tprint(max_sub(arr,n))\nelse:\n\tfor i in range(n):\n\t\tdp[i][1] = arr[i]-k\n\t\tfor j in range(m):\n\t\t\tif (i-1<0 or dp[i-1][j]==q):\n\t\t\t\tcontinue\n\t\t\tif ((j+1)%m!=1):\n\t\t\t\tdp[i][(j+1)%m] = dp[i-1][j]+arr[i]\n\t\t\telse:\n\t\t\t\tdp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)\n\tma=0\n\tfor i in range(n):\n\n\t\tfor j in range(m):\n\n\t\t\tma = max(ma,dp[i][j])\n\n\tprint(ma)","output":"quadratic"},{"instruction":"n=int(input())\na=[int(x) for x in input().split()]\npro=n*(n-1)\/\/2\ndic={}\nfor item in a:\n    if item not in dic:\n        dic[item]=1\n    else:\n        dic[item]+=1\ncounter=0\nfor item in dic:\n    if 0 in dic and dic[0]>=2:\n        print('cslnb')\n        break\n    if dic[item]>2:\n        print('cslnb')\n        break\n    elif dic[item]==2:\n        if counter==1 or item-1 in dic:\n            print('cslnb')\n            break\n        else:\n            counter=1\nelse:\n    if (sum(a)-pro)%2==1:\n        print('sjfnb')\n    else:\n        print('cslnb')","output":"linear"},{"instruction":"import sys\n\nclass ADigitsSequenceEasyEdition:\n    def solve(self):\n        k = int(input()) + 1\n        p = 1\n        c = 0\n        while c + p * (10 ** p - (10 ** (p - 1) if p > 1 else 0)) < k:\n            c += p * (10 ** p - (10 ** (p - 1) if p > 1 else 0))\n            p += 1\n        k -= c\n        bef = (10 ** (p - 1) if p > 1 else 0) + (k - 1) \/\/ p\n        print(str(bef)[(k - 1) % p], end='')\n\nsolver = ADigitsSequenceEasyEdition()\ninput = sys.stdin.readline\n\nsolver.solve()","output":"logn"},{"instruction":"n = int(input())\nL = []\nfor i in range(n):\n    L.append(list(map(int, input().split()))+[i+1])\n\nL.sort(key=lambda X:(X[0],-X[1],X[2]))\n\nX = 0\nfor i in range(1,n):\n    if L[i][1]<=L[i-1][1]:\n        print(L[i][2],L[i-1][2])\n        X = 1\n        break\nif X == 0:\n    print(-1,-1)","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [tuple(inp(dtype)) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [tuple([i + 1] + inp(dtype)) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nn, T = inp(int)\na = sorted(inp_enus(int, n), key=lambda x: x[-1])\nbe, en, ans = 0, n, []\n\nwhile be < en:\n    md, time, c = (be + en + 1) >> 1, 0, 0\n\n    for _, i, j in a:\n        if time + j <= T and i >= md:\n            time += j\n            c += 1\n\n    if c >= md:\n        be = md\n    else:\n        en = md - 1\n\nl = be\nfor _, i, j in a:\n    if be and i >= l:\n        ans.append(_)\n        be -= 1\n\nprint(f\"{l}\\n{l}\")\nprint(*ans)","output":"nlogn"},{"instruction":"n = int(input())\nfor i in range(n):\n    p = int(input())\n    a = list(map(int,input().split()))\n    a = sorted(a)\n    if p == 2:\n        print(0)\n        continue\n    k = a[-2] - 1\n    print(min(k, p - 2))","output":"nlogn"},{"instruction":"l,r=map(int,input().split())\np=bin(l)\np=p[2:]\nq=bin(r)\nq=q[2:]\n\nt=len(q)\nu=len(p)\np=(t-u)*'0'+p\nans=[]\n\nfor i in range(len(q)):\n    if(q[i]=='1' and p[i]=='0'):\n        ans.append(1)\n        break;\n    elif(q[i]=='1' and p[i]=='1'):\n        ans.append(0)\n        continue;\n    elif(q[i]=='0' and p[i]=='1'):\n        ans.append(1)\n        continue;\n    else:\n        ans.append(0)\nfor j in range(i+1,len(p)):\n        ans.append(1)\ntotal=0\n\nans.reverse()\n\nfor i in range(len(ans)):\n    total+=pow(2,i)*ans[i]\n\nprint(total)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nmax_val = 0\nn, m = [int(item) for item in input().split()]\narray = []\nfor i in range(n):\n    line = [int(item) for item in input().split()]\n    array.append(line)\n    max_val = max(max_val, max(line))\n\ngood = (1 << m) - 1\nl = 0; r = max_val + 1\na = 0; b = 0\nwhile r - l > 1:\n    mid = (l + r) \/\/ 2\n    bit_array = dict()\n    for k, line in enumerate(array):\n        val = 0\n        for i, item in enumerate(line):\n            if item >= mid:\n                val |= 1 << i\n        bit_array[val] = k\n    ok = False\n    for key1 in bit_array.keys():\n        for key2 in bit_array.keys():\n            if key1 | key2 == good:\n                ok = True\n                i = bit_array[key1]\n                j = bit_array[key2]\n                break\n    if ok:\n        a = i; b = j\n        l = mid\n    else:\n        r = mid\nprint(a+1, b+1)","output":"np"},{"instruction":"n=int(input())\ni=iter(sorted(zip(map(int,input().split()),range(1,n+1))))\ns,o=[],[]\nfor c in input():\n if c=='0':\n  x=next(i)[1];o+=[x];s+=[x]\n else:o.append(s.pop())\nprint(*o)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\nh = k \/\/ n\nif h * n < k:\n    h += 1\nprint(h)","output":"constant"},{"instruction":"I = lambda: map(int, input().split())\n\nn, k = I()\nA = sorted((tuple(I()) for _ in range(n)), key=lambda x: (-x[0], x[1]))\n\nprint(A.count(A[k-1]))","output":"nlogn"},{"instruction":"a, b  = map(int, input().split())\n\nk = 2**(a^b).bit_length()\nprint(k-1)","output":"logn"},{"instruction":"x, k = map(int, input().split())\nmod = 1000000007\nif x == 0:\n    print(0)\nelse:\n    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))","output":"logn"},{"instruction":"from sys import exit\n\nn, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nif max(b) > min(g):\n    print(-1)\n    exit(0)\nb.sort()\nres = sum(g) + sum(b[:-1]) * m\nif b[-1] in g:\n    print(res)\nelse:\n    print(res + b[-1] - b[-2])","output":"nlogn"},{"instruction":"import heapq\n\nn, k = list(map(int, input().strip().split()))\n\np = list(map(int, input().strip().split()))\nc = list(map(int, input().strip().split()))\n\np = sorted([(x, i) for i, x in enumerate(p)], key=lambda x: x[0])\n\nans = []\ntop_k = []\n\ncur_gold = 0\nfor i, t in enumerate(p):\n    if k == 0:\n        ans.append((c[t[1]], t[1]))\n    else:\n        if i < k:\n            cur_gold += c[t[1]]\n            ans.append((cur_gold, t[1]))\n            heapq.heappush(top_k, c[t[1]])\n        else:\n            smallest = heapq.nsmallest(1, top_k)[0]\n            if smallest < c[t[1]]:\n                cur_gold += c[t[1]]\n                ans.append((cur_gold, t[1]))\n                heapq.heappop(top_k)\n                heapq.heappush(top_k, c[t[1]])\n                cur_gold -= smallest\n            else:\n                ans.append((cur_gold + c[t[1]], t[1]))\n\nans = sorted(ans, key=lambda x: x[1])\nprint(\" \".join(map(lambda x: str(x[0]), ans)))","output":"nlogn"},{"instruction":"n, m, k = map(int, input().split())\nreb1 = [list(map(int, input().split())) for i in range(n)]\nreb2 = [list(map(int, input().split())) for i in range(n - 1)]\nif k % 2:\n    for i in range(n):\n        for j in range(m):\n            print(-1, end=\" \")\n        print()\n    exit(0)\nminsum = [[0] * m for i in range(n)]\nnminsum = [[0] * m for i in range(n)]\nfor it in range(k \/\/ 2):\n    for i in range(n):\n        for j in range(m):\n            cmin = 1000000000010\n            if i != 0:\n                cmin = min(cmin, minsum[i - 1][j] + reb2[i - 1][j])\n            if i != n - 1:\n                cmin = min(cmin, minsum[i + 1][j] + reb2[i][j])\n            if j != 0:\n                cmin = min(cmin, minsum[i][j - 1] + reb1[i][j - 1])\n            if j != m - 1:\n                cmin = min(cmin, minsum[i][j + 1] + reb1[i][j])\n            nminsum[i][j] = cmin\n    for i in range(n):\n        for j in range(m):\n            minsum[i][j] = nminsum[i][j]\nfor i in minsum:\n    for j in i:\n        print(j * 2, end=\" \")\n    print()","output":"cubic"},{"instruction":"from math import gcd\nfrom collections import defaultdict as dd\nm=int(input())\nd=dd(int)\nl=[]\nans=[]\nfor i in range(m):\n    s=input().split()[0]\n    a=0\n    b=0\n    c=0\n    n=len(s)\n    ind=0\n    for i in range(1,n):\n        if(s[i]=='+'):\n            ind=i+1\n            break\n        a=a*10+int(s[i])\n    for i in range(ind,n):\n        if(s[i]==')'):\n            ind1=i+2\n            break\n        b=b*10+int(s[i])\n    for i in range(ind1,n):\n        c=c*10+int(s[i])\n    a=a+b\n    g=gcd(a,c)\n    a=a\/\/g\n    c=c\/\/g\n    d[(a,c)]+=1\n    l.append((a,c))\nfor i in l:\n    ans.append(d[i])\nprint(*ans)","output":"linear"},{"instruction":"n = int(input())\nnums = [int(x) for x in input().split()]\nans = 10 ** 12\nfor idx, num in enumerate(nums):\n    dist = max(idx, n - idx - 1)\n    curr = num \/\/ dist\n    ans = min(ans, curr)\nprint(ans)","output":"linear"},{"instruction":"def rotate(li):\n    newli = []\n    for x in range (0,n):\n        newli.append([])\n        newli[x] = li[x].copy()\n\n    for x in range (0,n):\n        for y in range (0,n):\n            newli[x][y] = li[n-1-y][x]\n    return newli\n\ndef flipV(li):\n    newli = []\n    for x in range (0,n):\n        newli.append([])\n        newli[x] = li[x].copy()\n    newli.reverse()\n    return newli\n\ndef flipH(li):\n    newli = []\n    for x in range (0,n):\n        newli.append([])\n        newli[x] = li[x].copy()\n\n    for x in range (0,n):\n        newli[x].reverse()\n    return newli\n\nn = int(input())\n\nli1, li2, li3, templi = [], [], [], []\n\nfor x in range (0,n):\n    li1.append([])\n    li2.append([])\n    li3.append([])\n    templi.append([])\n    li1[x]=list(input())\n\nfor x in range (0,n):\n    li2[x]=list(input())\n\nif ( li1 ==li2 ):\n    print('Yes')\n    exit()\n\ntempli = flipH(li2)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = flipV(li2)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = rotate(li2)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = rotate(templi)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = rotate(templi)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = flipH(li2)\ntempli = rotate(templi)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = rotate(templi)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\ntempli = rotate(templi)\nif ( li1 ==templi ):\n    print('Yes')\n    exit()\n\nprint('No')","output":"quadratic"},{"instruction":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            if (1 << i) & n:\n                res += 1\n        return res","output":"constant"},{"instruction":"import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef quer(x1, y1, x2, y2):\n    if x1 > x2 or y1 > y2:\n        return [0, 0]\n    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))\n    if s % 2 == 0:\n        return [s \/\/ 2, s \/\/ 2]\n    if (x1 + y1) & 1:\n        return [s \/\/ 2 + 1, s \/\/ 2]\n    return [s \/\/ 2, s \/\/ 2 + 1]\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, m = mp()\n        x1, y1, x2, y2 = mp()\n        s = quer(1, 1, n, m)\n        s1 = quer(x1, y1, x2, y2)\n        s[0] -= s1[0]\n        s[1] += s1[0]\n\n        x3, y3, x4, y4 = mp()\n        xmn = max(x1, x3)\n        xmx = min(x2, x4)\n        ymn = max(y1, y3)\n        ymx = min(y2, y4)\n        s1 = quer(x3, y3, x4, y4)\n        s[0] += s1[1]\n        s[1] -= s1[1]\n        s1 = quer(xmn, ymn, xmx, ymx)\n        s[0] += s1[0]\n        s[1] -= s1[0]\n        print(*s[::-1])\n\ndebug = 0\nif debug:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nmain()\nif debug:\n    file.close()","output":"constant"},{"instruction":"n = int(input())\nx = 1\nn -= 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = (8 + 2) ** (x - 1)\na += n \/\/ x\nprint(str(a)[n % x])","output":"logn"},{"instruction":"for _ in range(int(input())):\n    i, j = map(int, input().split())\n    i -= 1\n    print((j\/\/2 * (j\/\/2 + 1) - i\/\/2 * (i\/\/2 + 1)) -\n          (((j - j\/\/2) * (j - j\/\/2)) - ((i - i\/\/2) * (i - i\/\/2))))","output":"constant"},{"instruction":"s = input()\nfor i in range(len(s), 0, -1):\n\tfor j in range(len(s) - i + 1):\n\t\tif s[j: j + i] in s[j + 1:]:\n\t\t\tprint(i)\n\t\t\texit()\nprint(0)","output":"cubic"},{"instruction":"from sys import stdin, stdout\nti = lambda : stdin.readline().strip()\nos = lambda i : stdout.write(str(i) + '\\n')\nma = lambda fxn, ti : map(fxn, ti.split())\nol = lambda arr : stdout.write(' '.join(element for element in arr) + '\\n')\nolws = lambda arr : stdout.write(''.join(element for element in arr) + '\\n')\n\nclass Digit:\n\tdef __init__(self):\n\t\tself.count = {}\n\n\tdef increment(self, k):\n\t\tif self.count.has_key(k):\n\t\t\tgot = self.count[k]\n\t\t\tself.count[k] += 1\n\t\telse:\n\t\t\tself.count[k] = 1\n\n\tdef found(self, k):\n\t\tif self.count.has_key(k):\n\t\t\treturn self.count[k]\n\t\telse:\n\t\t\treturn 0\n\nn, mod = ma(int, ti())\narray = ma(int, ti())\n\nans = 0\ndigits = [None]*11\nfor i in range(11):\n\tdigits[i] = Digit()\n\nfor i in range(n):\n\ttemp = array[i]%mod\n\n\tfor j in range(10):\n\t\ttemp *= 10\n\t\ttemp %= mod\n\n\t\tdigits[j+1].increment(temp)\n\nfor i in range(n):\n\ttemp = array[i]\n\tcount = 0\n\twhile temp>0:\n\t\ttemp \/= 10\n\t\tcount += 1\n\n\tfind = mod-array[i]%mod\n\tfind %= mod\n\tans += digits[count].found(find)\n\nfor i in range(n):\n\ttemp1 = array[i]%mod\n\ttemp2 = array[i]\n\n\twhile temp2 > 0:\n\t\ttemp2 \/= 10\n\t\ttemp1 *= 10\n\t\ttemp1 %= mod\n\n\tif ((temp1 + array[i])%mod == 0):\n\t\tans -= 1\n\nos(ans)","output":"nlogn"},{"instruction":"from collections import Counter\n\nn, k = map(int, input().split())\n\nfor p in range(n+1):\n    if p*(p+1)\/\/2 - (n-p) == k:\n        print(n-p)\n        break","output":"linear"},{"instruction":"lis = list(map(int,input().split()))\nif lis[2] <= lis[0] and lis[2] <= lis[1]:\n\tif ((lis[0]+lis[1]) - lis[2]) < lis[3]:\n\t\tprint(lis[3] - ((lis[0]+lis[1]) - lis[2]))\n\telif sum(lis) == 0:\n\t\tprint(-1)\n\telif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :\n\t\tprint(lis[3])\n\telse:\n\t\tprint(-1)\nelse:\n\tprint(-1)","output":"constant"},{"instruction":"t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(min(a[-2]-1, n-2))","output":"nlogn"},{"instruction":"n=int(input())\na=int(input())\n\ns=0\nt=a\nb=[]\nfor i in range(n):\n    s+=t%10\n    b.append(t%10)\n    t\/\/=10\n\nb.reverse()\n\ni=2\nans=False\n\nif(s==0): ans=True\nwhile(i<=s):\n\n    if(s%i!=0):\n        i+=1\n        continue\n    l=s\/\/i\n    c=0\n    su=0\n    for j in range(n):\n        if(su>l):\n            break\n        else:\n            su+=b[j]\n            if(su==l):\n                su=0\n                c+=1\n    if(c==i):\n        ans=True\n\n    i+=1\nif(ans): print(\"YES\")\nelse:print(\"NO\")","output":"quadratic"},{"instruction":"n = int(input()) + 1\n\nif n == 1:\n    print(0)\nelse:\n    if n % 2:\n        print(n)\n    else:\n        print(n \/\/ 2)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\nmod = pow(10, 9) + 7\na = list(map(int, input().split()))\nl = 100000\ncnt = [0] * (l + 1)\nfor i in a:\n    cnt[i] += 1\npow2 = [1]\nfor _ in range(l):\n    pow2.append(2 * pow2[-1] % mod)\nans = pow2[n] - 1\nx = [-1] * (l + 1)\nfor i in range(2, l + 1):\n    c = cnt[i]\n    xi = x[i]\n    for j in range(2 * i, l + 1, i):\n        c += cnt[j]\n        x[j] -= xi\n    ans += xi * (pow2[c] - 1) % mod\n    ans %= mod\nprint(ans)","output":"np"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: list(map(dtype, input().split()))\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j] = 0\n\nfor k1 in range(1, k \/\/ 2 + 1):\n    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],\n                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])\n\n    mem = mem0\n\n[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]","output":"cubic"},{"instruction":"from math import sqrt, floor, ceil\nn = int(input())\n\nran = list(range(2, 1+n\/\/2))\nxx = [ d*(n\/\/d-1)     for d in ran]\nprint(sum(xx)*4)","output":"linear"},{"instruction":"n, m = map(int, input().split())\nc = []\nfor j in range(n):\n    d = []\n    s = input()\n    for i in s:\n        d.append(i)\n    c.append(d)\na = []\nb = []\ne=[]\ng=[]\n\nfor j in range(n):\n    k=[0]*(m)\n    e.append(k)\nfor j in range(n):\n    k=[0]*(m)\n    g.append(k)\n\ndpu = []\nfor j in range(n):\n    k=[0]*(m)\n    dpu.append(k)\ndpd = []\nfor j in range(n):\n    k=[0]*(m)\n    dpd.append(k)\ndpl = []\nfor j in range(n):\n    k=[0]*(m)\n    dpl.append(k)\ndpr = []\nfor j in range(n):\n    k=[0]*(m)\n    dpr.append(k)\nfor i in range(n):\n    for j in range(m):\n        if c[i][j] == \"*\":\n            if i>0:\n                dpu[i][j]+=dpu[i-1][j]+1\n            else:\n                dpu[i][j]=1\n            if j>0:\n                dpl[i][j]=dpl[i][j-1]+1\n            else:\n                dpl[i][j]=1\ni=n-1\nwhile(i>=0):\n    j=m-1\n    while(j>=0):\n        if c[i][j] == \"*\":\n            if i<(n-1):\n                dpd[i][j] += dpd[i + 1][j] + 1\n            else:\n                dpd[i][j] = 1\n            if j<(m-1):\n                dpr[i][j] = dpr[i][j + 1] + 1\n            else:\n                dpr[i][j] = 1\n        j+=-1\n    i+=-1\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if c[i][j] == \"*\":\n            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)\n            if k==0:\n                pass\n            elif k>0:\n                a.append([i+1,j+1,k])\n                e[i-k][j]+=1\n                if (i+k)<(n-1):\n                    e[i+k+1][j]+=-1\n                g[i][j-k] += 1\n                if (j + k) < (m - 1):\n                    g[i][j+k+1] += -1\nfor i in range(m):\n    for j in range(1,n):\n        if c[j-1][i]==\"*\":\n            e[j][i]+=e[j-1][i]\nfor i in range(n):\n    for j in range(1,m):\n        if c[i][j-1]==\"*\":\n            g[i][j]+=g[i][j-1]\nf=0\nfor i in range(n):\n    for j in range(m):\n        if c[i][j]==\"*\" and e[i][j]<=0 and g[i][j]<=0:\n            f=1\n            break\nif f==1:\n    print(-1)\nelse:\n    print(len(a))\n    for j in a:\n        print(*j)","output":"quadratic"},{"instruction":"def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    t = input()\n    j = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            j = i\n    s = t + (k - 1) * t[-(n - j):]\n    return s\n\nprint(solve())","output":"quadratic"},{"instruction":"from collections import Counter\n\ndef solve(n, ribbons):\n\tL = len(ribbons[0])\n\ta = [Counter(r).most_common(1)[0][1] for r in ribbons]\n\n\tr = sorted([(x, i) for i, x in enumerate(a)], reverse=True)\n\n\tif n == 1:\n\t\tc = Counter(a)\n\t\tif c[L - 1] == 1:\n\t\t\tfor i in range(3):\n\t\t\t\tif a[i] == L - 1: return i\n\t\tif c[L - 1] > 1:\n\t\t\treturn 3\n\t\tif c[L] + c[L - 2] == 1:\n\t\t\tfor i in range(3):\n\t\t\t\tif a[i] == L or a[i] == L-2:\n\t\t\t\t\treturn i\n\t\tif c[L] + c[L - 2] > 1:\n\t\t\treturn 3\n\n\tif r[1][0] == r[0][0]:\n\t\treturn 3\n\tif r[1][0] + n >= L:\n\t\treturn 3\n\treturn r[0][1]\n\n\tprint(a)\n\ndef main():\n\tn = int(input())\n\tcats = ('Kuro', 'Shiro', 'Katie', 'Draw')\n\n\tribbons = [input().strip() for _ in range(3)]\n\n\tk = solve(n, ribbons)\n\tprint(cats[k])\n\nif __name__ == '__main__':\n\tmain()","output":"linear"},{"instruction":"def main():\n    buf = input()\n    buflist = buf.split()\n    hand = buflist;\n    t = []\n    for i in range(3):\n        t.append([])\n        for j in range(9):\n            t[i].append(0)\n    for x in hand:\n        idx = 0\n        if x[1] == 'm':\n            idx = 0\n        elif x[1] == 'p':\n            idx = 1\n        elif x[1] == 's':\n            idx = 2\n        t[idx][int(x[0])-1] += 1\n    max_cons = 0\n    max_mult = 0\n    for i in range(3):\n        cons = [0, 0, 0]\n        for j in range(9):\n            cons[0] = cons[1]\n            cons[1] = cons[2]\n            if t[i][j] > 0:\n                cons[2] = 1\n            else:\n                cons[2] = 0\n            max_cons = max(sum(cons), max_cons)\n            max_mult = max(max_mult, t[i][j])\n    print(3 - max(max_cons, max_mult))\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\nN = int(input())\nB = [int(x) for x in input().split()]\n\nA = [0] * N\n\ni, j = N\/\/2-1, N\/\/2\nA[i] = B[-1] \/\/ 2\nA[j] = B[-1] \/\/ 2 if B[-1] % 2 == 0 else B[-1] \/\/ 2 + 1\nl, r = A[i], A[j]\nfor bi in range(len(B)-2, -1, -1):\n    b = B[bi]\n    i -= 1\n    j += 1\n\n    if b-l >= A[j-1]:\n        A[i] = l\n        A[j] = b-l\n        r = b-l\n    else:\n        A[j] = r\n        A[i] = b-r\n        l = b-r\n\nprint(' '.join(map(str, A)))","output":"linear"},{"instruction":"import sys\nimport math\n\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:\/Competitive Programming\/input.txt', 'r')\n    outputfile = open('W:\/Competitive Programming\/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\nmod=1000000007\n\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n\nt=1\nfor tt in range(t):\n    n=int(input())\n\n    a=list(map(int,sys.stdin.readline().split(' ')))\n    a.sort()\n\n    i=0\n    ans=0\n    while i<len(a):\n        if a[i]:\n            ans+=1\n            j=i+1\n            while j<n:\n                if(a[j]%a[i]==0):\n                    a[j]=0\n                j+=1\n        i+=1\n    print(ans)\n\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()","output":"quadratic"},{"instruction":"def func():\n    n, k = map(int, input().strip().split())\n    l = 0\n    r = n\n    while l <= r:\n        mid = (l + r) \/\/ 2\n        if mid*(mid+1)\/2 - (n-mid) < k:\n            l = mid + 1\n        elif mid*(mid+1)\/2 - (n-mid) > k:\n            r = mid\n        else:\n            print(n - mid)\n            return mid\n\nif __name__ == '__main__':\n    func()","output":"logn"},{"instruction":"n=int(input())\nprint(n+(n\/\/2))","output":"constant"},{"instruction":"n = int(input())\n\nfrom collections import defaultdict\n\nfirst = defaultdict(int)\nsecond = defaultdict(int)\nfor _ in range(n):\n    s = input().strip()\n    count = 0\n    min_count = 0\n    for c in s:\n        if c == '(': count += 1\n        else: count -= 1\n        min_count = min(count, min_count)\n    if min_count >= 0: first[count] += 1\n    if count == min_count: second[count] += 1\n\nres = 0\nfor k, v in first.items():\n    res += v * second[-k]\n\nprint(res)","output":"linear"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\ns=set(l)\nx=0\nif x in s:\n    print(len(s)-1)\nelse:\n    print(len(s))","output":"linear"},{"instruction":"n,m = map(int, input().split())\nb = [int(s) for s in input().split()]\ng = [int(s) for s in input().split()]\nans = 0\nmaxb2, maxb = sorted(b)[-2:]\nming = min(g)\nif maxb > ming:\n    ans = -1\nelse:\n    ans += sum(b)*m\n    ans += (sum(g)-ming)-(maxb*(m-1))\n    if ming > maxb:\n        ans += ming-maxb2\nprint(ans)","output":"nlogn"},{"instruction":"def read(type = 1):\n    if type:\n        file = open(\"input.dat\", \"r\")\n        n = int(file.readline())\n        a = list(map(int, file.readline().split()))\n        b = file.readline()\n        file.close()\n    else:\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        b = input().strip()\n    return n, a, b\n\ndef solve():\n    sol = 0\n    e = 0\n    big = 0\n    g = 0\n    for i in range(n):\n        if b[i] == \"W\":\n            big = 1\n            sol += 3 * a[i]\n            e += a[i]\n        if b[i] == \"G\":\n            sol += 5 * a[i]\n            e += a[i]\n            g += 2*a[i]\n        if b[i] == \"L\":\n            sol += a[i]\n            e -= a[i]\n            if e < 0:\n                if big:\n                    sol -= 3 * e\n                else:\n                    sol -= 5 * e\n                e = 0\n        g = min(e,g)\n    if e:\n        sol -= 2*g\n        sol -= (e-g)\n    return int(sol)\n\nn, a, b = read(0)\nsol = solve()\nprint(sol)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase*3)]\n\ndef COMMON(WHITE,BLACK):\n    x1,y1,x2,y2=WHITE\n    x3,y3,x4,y4=BLACK\n    return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))\n\ndef BtoW(WHITE):\n    x1,y1,x2,y2=WHITE\n    if (x1+y1)%2==0:\n        return (x2-x1+1)*(y2-y1+1)\/\/2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)\/\/2\n\ndef WtoB(BLACK):\n    x1,y1,x2,y2=BLACK\n    if (x1+y1)%2==1:\n        return (x2-x1+1)*(y2-y1+1)\/\/2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)\/\/2\n\nfor test in range(testcase):\n    n,m=T[test*3]\n    WHITE=T[test*3+1]\n    BLACK=T[test*3+2]\n\n    ANSB=n*m\/\/2\n    ANSW=n*m-ANSB\n\n    WHITE2=COMMON(WHITE,BLACK)\n\n    k=BtoW(WHITE)\n    ANSB-=k\n    ANSW+=k\n\n    if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]:\n        True\n    else:\n        l=BtoW(WHITE2)\n        ANSB+=l\n        ANSW-=l\n\n    m=WtoB(BLACK)\n\n    ANSB+=m\n    ANSW-=m\n\n    print(ANSW,ANSB)","output":"constant"},{"instruction":"t=int(input())\nfor i in range(t):\n    n=int(input())\n    ar=list(map(int,input().split()))\n    if(n<=2):\n        print(0)\n        continue\n    ar=sorted(ar)[::-1]\n    ans=0\n    for i in range(1,n-1):\n        if(ar[0]>i and ar[1]>i):\n            ans=i\n    print(ans)","output":"nlogn"},{"instruction":"from sys import stdin\ninput=stdin.readline\nrn=lambda:int(input())\nrns=lambda:map(int,input().split())\nrl=lambda:list(map(int,input().split()))\nrs=lambda:input()\nYN=lambda x:print('YES') if x else print('NO')\nmod=10**9+7\n\nn,m,k=rns()\nrows=[rl() for i in range(n)]\ncols=[rl() for i in range(n-1)]\ndef solve():\n    if k%2==1:\n        return [m*[-1] for i in range(n)]\n    dp=[[[0 for i in range(k\/\/2+1)] for j in range(m)] for l in range(n)]\n    for i in range(1,k\/\/2+1):\n        for a in range(n):\n            for b in range(m):\n                mins=[]\n                if b>0:\n                    mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1])\n                if b<m-1:\n                    mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b])\n                if a>0:\n                    mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b])\n                if a<n-1:\n                    mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b])\n                dp[a][b][i]=min(mins)\n    ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)]\n    return ans\n\nans = solve()\nfor i in ans:\n    print(*i)","output":"cubic"},{"instruction":"import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\n\nstarttime = time.time()\n\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n\ntry:\n\n    sys.stdin = open(\"input.txt\", \"r\")\n\nexcept:\n    pass\nglobal ans\nans=0\n\ndef rec(i,j,k):\n    if dp[i][j][k]!=-1:\n        return dp[i][j][k]\n    x1=x2=x3=0\n    if i<R and j<G:\n        x1=r[i]*g[j]+rec(i+1,j+1,k)\n    if i<R and k<B:\n        x2=r[i]*b[k]+rec(i+1,j,k+1)\n    if j<G and k<B:\n        x3=g[j]*b[k]+rec(i,j+1,k+1)\n    dp[i][j][k]=max(x1,x2,x3)\n    global ans\n    ans=max(ans,dp[i][j][k])\n    return dp[i][j][k]\n\nfor _ in range(1):\n    R,G,B=L()\n    r=L()\n    g=L()\n    b=L()\n    r.sort(reverse=True)\n    g.sort(reverse=True)\n    b.sort(reverse=True)\n    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]\n    rec(0,0,0)\n    print(ans)\n\nendtime = time.time()","output":"cubic"},{"instruction":"l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = list(bin(r)[2:]), list(bin(l)[2:])\nbinl = ['0'] * (len(binr) - len(binl)) + binl\n\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        del (binl[0:i])\n        del (binr[0:i])\n        break\n\nx = '1' * len(binl)\n\nl = int(x, 2)\nprint(l)","output":"logn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        n,x=ria()\n        a=ria()\n        d=Counter(a)\n        sa=set(a)\n        if len(sa)<n:\n            print(0)\n        else:\n            c=0\n            for i in a:\n                k=i&x\n                if k!=i and k in d:\n                    c=1\n                    print(1)\n                    break\n            if c==0:\n                z=[]\n                for i in a:\n                    z.append(i&x)\n                if len(set(z))<n:\n                    print(2)\n                else:\n                    print(\"-1\")\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"n = int(input())\n\ncheck = True\nt=0\ntnext=9\n\ncount=1\ni=1\nj=1\nres = 0\nwhile(check):\n\n    if(n<=tnext):\n        res=n-t\n        check = False\n\n    else:\n\n        count = count+1\n\n        if(t!=0):\n            t=t+9*i*j\n        else:\n            t=9\n\n        tnext = tnext + 9 * (i+1)*(j*10)\n        i=i+1\n        j=j*10\n\nnum1 = int(res\/count)\nnum2 = res%count\n\ndes = pow(10,count-1)\ndespac = des + num1\n\nif(num2 == 0):\n    despac = str(despac -1)\n    print(despac[-1])\n\nelse :\n    despac = str(despac)\n    print(despac[num2-1])","output":"logn"},{"instruction":"reduced = 1\nn, m ,k = map(int,input().split())\n\np = list(map(int, input().split()))\n\np.reverse()\ncnt = 0\nwhile(len(p)):\n\n    cnt1 = 1\n    first = p.pop()\n    fack = ((first - reduced)\/\/k) * k\n    while(len(p) and p[-1] - fack - reduced < k):\n        cnt1 += 1\n        p.pop()\n\n    reduced += cnt1\n    cnt += 1\nprint(cnt)","output":"linear"},{"instruction":"def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nn = int(input())\na = [list(input()) for i in range(n)]\nb = [list(input()) for i in range(n)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(n)] for u in range(n)]\n    for t in range(n):\n        for u in range(n):\n            c[t][u] = b[u][n - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')","output":"quadratic"},{"instruction":"l,r = map(int,input().split())\nif l%2:\n    l+=1\nif r-l<2:\n    print(-1)\nelse:\n    print(l,l+1,l+2)","output":"constant"},{"instruction":"n,d=[int(x) for x in input().split(\" \")]\na=[int(x) for x in input().split(\" \")]\npos=2\nfor i in range(n-1):\n    l=a[i]+d\n    r=a[i+1]-d\n    if l==r:\n        pos+=1\n    elif l<r:\n        pos+=2\nprint(pos)","output":"linear"},{"instruction":"from collections import Counter\nn,c=map(int,input().split())\na=list(map(int,input().split()))\ncounter=Counter()\nminus=0\ncount=a.count(c)\nmaxi=0\nfor i in range(n):\n    if a[i]!=c:\n        if counter[a[i]]<minus:\n            counter[a[i]]=minus\n        counter[a[i]]+=1\n        maxi=max(maxi,counter[a[i]]+count-minus)\n    else:\n        minus+=1\nprint(max(maxi,minus))","output":"linear"},{"instruction":"from collections import deque\n\ndef addedge(u, v, value):\n\tglobal e\n\ta = [v, value, None]\n\tb = [u, 0, a]\n\ta[2] = b\n\te[u].append(a)\n\te[v].append(b)\n\ninf = 2 * (10 ** 12)\nans = 0\nn, m = map(int, input().split())\ne = [[] for i in range(n + m + 2)]\na = tuple(map(int, input().split()))\nS, T = 0, m + n + 1\nfor i in range(1, m + 1):\n\tu, v, w = map(int, input().split())\n\tans += w\n\taddedge(i, u + m, inf)\n\taddedge(i, v + m, inf)\n\taddedge(S, i, w)\nfor i in range(m + 1, T):\n\taddedge(i, T, a[i - m - 1])\n\nlvl = None\ndef bfs():\n\tglobal e, lvl\n\tlvl = [0] * (n + m + 2)\n\tq = deque([0])\n\twhile q:\n\t\tnode = q.popleft()\n\n\t\tfor edge in e[node]:\n\t\t\tif edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:\n\t\t\t\tlvl[edge[0]] = lvl[node] + 1\n\t\t\t\tq.append(edge[0])\n\ndef dfs(node, maxdelta):\n\tglobal e, lvl\n\tif node == T:\n\t\treturn maxdelta\n\tdelta = 0\n\tfor edge in e[node]:\n\t\tif lvl[edge[0]] == lvl[node] + 1 and edge[1]:\n\t\t\ttmp = dfs(edge[0], min(maxdelta, edge[1]))\n\t\t\tif tmp > 0:\n\t\t\t\tedge[1] -= tmp\n\t\t\t\tedge[2][1] += tmp\n\t\t\t\tmaxdelta -= tmp\n\t\t\t\tdelta += tmp\n\t\t\tif maxdelta == 0:\n\t\t\t\tbreak\n\treturn delta\n\nflow = 0\nwhile 1:\n\tbfs()\n\ttmp = dfs(0, inf)\n\tif tmp == 0:\n\t\tbreak\n\tflow += tmp\nans -= flow\nprint(ans)","output":"cubic"},{"instruction":"def read_int(): return int(input())\ndef read_ints(): return list(map(int, input().split()))\n\nn = read_int()\na = read_ints()\ndp = [[0] * n for _ in range(n)]\nf = [[0] * n for _ in range(n)]\nfor i in range(n - 1, -1, -1):\n\tf[i][i] = dp[i][i] = a[i]\n\tfor j in range(i + 1, n):\n\t\tf[i][j] = f[i][j - 1] ^ f[i + 1][j]\n\t\tdp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])\nq = read_int()\nfor _ in range(q):\n\tl, r = read_ints()\n\tprint(dp[l - 1][r - 1])","output":"quadratic"},{"instruction":"from collections import namedtuple\nimport sys\n\nHS = namedtuple('HS', 'x1 x2 y')\n\nn, m = [int(w) for w in input().split()]\nvs = [int(input()) for _ in range(n)]\nhs = [HS(*[int(w) for w in input().split()]) for _ in range(m)]\n\nvs.sort()\n\nhr = len([s for s in hs if s.x1 == 1 and s.x2 == 10**9])\nhs = [s.x2 for s in hs if s.x1 == 1 and s.x2 < 10**9]\nhs.sort()\n\nr = hc = len(hs)\nhi = vi = 0\nfor hi in range(hc):\n    while vi < n and hs[hi] >= vs[vi]:\n        vi += 1\n    c = (hc - hi - 1) + vi\n    if c < r:\n        r = c\n\nprint(r + hr)","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\nc = 0\n\nfor i in range(1, n-1):\n    if a[i] > a[i-1] and a[i] > a[i+1]:\n        c +=1\n    if a[i] == a[i-1] or a[i] == a[i+1]:\n        print('NO')\n        exit()\n    if a[i] <= a[i-1] and a[i] <= a[i+1]:\n        print('NO')\n        exit()\nif c>1:\n    print('NO')\nelse:\n    print('YES')","output":"linear"},{"instruction":"n, a, b = map(int, input().split())\nif a != 1 and b != 1:\n    print(\"NO\")\nelse:\n\n    con_char = '1'\n    discon_char = '0'\n    if a == 1:\n        con_char = '0'\n        discon_char = '1'\n        t = a\n        a = b\n        b = t\n\n    if a > 1:\n        print(\"YES\")\n        n_con = n - a + 1\n        for i in range(n):\n            res = []\n            for j in range(n):\n                if i == j:\n                    res.append('0')\n                elif i < n_con and j < n_con:\n                    res.append(con_char)\n                else:\n                    res.append(discon_char)\n            print(''.join(res))\n    else:\n        if n == 1 or n > 3:\n            print(\"YES\")\n\n            for i in range(n):\n                res = []\n                for j in range(n):\n                    if i == j:\n                        res.append('0')\n                    elif abs(i-j) == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                print(''.join(res))\n        else:\n            print(\"NO\")","output":"quadratic"},{"instruction":"n, d, k = map(int, input().split())\n\nif d+1 > n:\n    print('NO')\n    exit()\n\nans = []\ndist = [0]*n\ndeg = [0]*n\nfor i in range(d+1):\n    if i == 0 or i == d:\n        deg[i] = 1\n    else:\n        deg[i] = 2\n    if i != d:\n        ans.append((i+1, i+2))\n    dist[i] = max(i, d-i)\n\nfor i in range(n):\n    if deg[i] > k:\n        print('NO')\n        exit()\n\nfrom collections import deque\nq = deque(list(range(d+1)))\ncur = d+1\nwhile q and cur < n:\n    v = q.popleft()\n    if dist[v] < d and deg[v] < k:\n        deg[v] += 1\n        dist[cur] = dist[v]+1\n        deg[cur] = 1\n        ans.append((v+1, cur+1))\n        q.append(v)\n        q.append(cur)\n        cur += 1\n    else:\n        continue\nif cur != n:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(len(ans)):\n        print(*ans[i])","output":"quadratic"},{"instruction":"m = 10**18\n\ndef run():\n    n, k = [int(x) for x in input().split()]\n    currn, currs = 1, n\n    rem = 0\n\n    while True:\n        if k == 0:\n            print(f'YES {currs}')\n            return\n        if k < currn or currs == 0:\n            print('NO')\n            return\n        currs -= 1\n        k -= currn\n        if currs >= 40:\n            rem = m\n        else:\n            rem = min(m, rem + cc[currs]*((currn-1)*2+1))\n        currn = (currn - 1) * 2 + 3\n\n        if k <= rem:\n            print(f'YES {currs}')\n            return\n\ncc = [0, 1]\nfor i in range(2, 50):\n    cc.append(min(m, 1 + 4*cc[-1]))\nfor i in range(int(input())): run()","output":"logn"},{"instruction":"n,k=map(int,input().split())\nif n>=k:\n    print((k-1)\/\/2)\nelif n*2>k:\n    print(n-k\/\/2)\n\nelse:\n    print(0)","output":"constant"},{"instruction":"n=int(input())\nprint('4 %s'%(n-4) if n%2==0 else '9 %s'%(n-9))","output":"constant"},{"instruction":"n = int(input())\nprint(3*n\/\/2)","output":"constant"},{"instruction":"import math\nn,t=map(int,input().split())\nl=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    x=a-b\/2\n    y=a+b\/2\n    l.append([x,y])\nl.sort()\nc=0\n\nfor i in range(n-1):\n    if(l[i+1][0]-l[i][1]>t):\n        c+=2\n    elif(l[i+1][0]-l[i][1]==t):\n        c+=1\nprint(c+2)","output":"nlogn"},{"instruction":"import sys\ndef read():\n    return int(input())\ndef reads():\n    return [int(x) for x in input().split()]\nN,M=reads()\ntable=[reads() for i in range(N)]\nA=[[0]*N for i in range(N)]\nB=[[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        res=10**9+7\n        for k in range(M):\n            res=min(res,abs(table[i][k]-table[j][k]))\n        A[i][j]=res\n        A[j][i]=res\n        res=10**9+7\n        for k in range(M-1):\n            res=min(res,abs(table[i][k]-table[j][k+1]))\n        B[i][j]=res\n\ndp=[[-1]*N for i in range((1<<N) )]\ndef calc(mask,v):\n    if dp[mask][v]!=-1:\n        return dp[mask][v]\n    res =0\n    for u in range(N):\n        if (mask & 1<<u) and u!=v:\n            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))\n    dp[mask][v]=res\n    return dp[mask][v]\nans=0\nfor i in range(N):\n    dp = [[-1] * N for i in range((1 << N))]\n    for k in range(N):\n        if k==i:\n            dp[1<<k][k]=10**9+7\n        else:\n            dp[1<<k][k]=0\n    for j in range(N):\n        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))\n\nprint(ans)","output":"np"},{"instruction":"from os import path;import sys,time\nmod = int(1e9 + 7)\nfrom math import ceil, floor,gcd,log,log2 ,factorial,sqrt\nfrom collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations\nfrom string import ascii_lowercase ,ascii_uppercase\nfrom bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')\nI = lambda :int(sys.stdin.buffer.readline())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ngrid = lambda  r :[lint() for i in range(r)]\nlocalsys = 0\nstart_time = time.time()\n\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) \/\/ factorial(r)\ndef ceill(n,x):\n    return (n+x -1 )\/\/x\nT =0\n\ndef solve():\n\tarr = list(map(int , S()))\n\td ,s, ans  = {0} , 0 , 0\n\tfor i in arr:\n\t\ts+=i\n\t\ts%=3\n\t\tif s in d :\n\t\t\tans+=1\n\t\t\ts =0\n\t\t\td = {0}\n\t\td.add(s)\n\tprint(ans)\n\ndef run():\n    if (path.exists('input.txt')):\n        sys.stdin=open('input.txt','r')\n        sys.stdout=open('output.txt','w')\n\nrun()\nT = I() if T else 1\nfor _ in range(T):\n    solve()\n\nif localsys:\n    print(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"linear"},{"instruction":"import sys\nsys.setrecursionlimit(50000)\nfor _ in range(1):\n    n,m,k = map(int,input().split())\n    s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        d = [int(x) for x in input().split()]\n        for j in range(m-1):\n            s[i][j][1] = d[j]\n            s[i][j+1][3] = d[j]\n    for i in range(n-1):\n        d = [int(x) for x in input().split()]\n        for j in range(m):\n            s[i][j][2] = d[j]\n            s[i+1][j][0] = d[j]\n    if k%2==1:\n        for i in range(n):\n            print(*[-1 for _ in range(m)])\n        continue\n    dp = [[[9999999 for _ in range(k\/\/2+1)] for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0] = 0\n    for q in range(1,k\/\/2+1):\n        for i in range(n):\n            for j in range(m):\n                cands = []\n                if i > 0:\n                    cands.append(dp[i-1][j][q-1] + s[i-1][j][2])\n                if j > 0:\n                    cands.append(dp[i][j-1][q-1] + s[i][j-1][1])\n                if i < n - 1:\n                    cands.append(dp[i+1][j][q-1] + s[i+1][j][0])\n                if j < m - 1:\n                    cands.append(dp[i][j+1][q-1] + s[i][j+1][3])\n                dp[i][j][q] = min(cands)\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j][k\/\/2],end=' ')\n        print()","output":"cubic"},{"instruction":"from os import path\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\ndef sod(n):\n    s = 0\n    while n:\n        s += (n%10)\n        n \/\/= 10\n    return s\n\ndef solve():\n\n    n,s = mi()\n\n    def fun(mid):\n        return mid - sod(mid) >= s\n\n    l = 0\n    r = n\n    ans = -1\n    while l <= r:\n        m = l+(r-l)\/\/2\n        if fun(m):\n            ans = m\n            r = m-1\n        else:\n            l = m+1\n    if ans == -1:\n        ans = n+1\n    print(n-ans+1)\n\nif __name__ ==\"__main__\":\n\n    if path.exists('input.txt'):\n        sys.stdin=open('input.txt', 'r')\n        sys.stdout=open('output.txt','w')\n    else:\n        input=sys.stdin.readline\n    solve()","output":"logn"},{"instruction":"print(\"?\",0,0)\ne=int(input())\nastr=\"000000000000000000000000000000\"\nbstr=\"000000000000000000000000000000\"\nabig=e\nfor i in range(30):\n    if abig==0:\n        print(\"?\",int(astr,2)+2**(29-i),int(bstr,2))\n        e=int(input())\n        if e==1:\n            continue\n        else:\n            if i<29:\n                astr=astr[:i]+\"1\"+astr[i+1:]\n                bstr=bstr[:i]+\"1\"+bstr[i+1:]\n            else:\n                astr=astr[:i]+\"1\"\n                bstr=bstr[:i]+\"1\"\n    else:\n        print(\"?\",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))\n        e=int(input())\n        if e==-abig:\n            if abig==1:\n                if i<29:\n                    astr=astr[:i]+\"1\"+astr[i+1:]\n                else:\n                    astr=astr[:i]+\"1\"\n            else:\n                if i<29:\n                    bstr=bstr[:i]+\"1\"+bstr[i+1:]\n                else:\n                    bstr=bstr[:i]+\"1\"\n            print(\"?\",int(astr,2),int(bstr,2))\n            abig=int(input())\n        else:\n            print(\"?\",int(astr,2)+2**(29-i),int(bstr,2))\n            e=int(input())\n            if e==-1:\n                if i<29:\n                    astr=astr[:i]+\"1\"+astr[i+1:]\n                    bstr=bstr[:i]+\"1\"+bstr[i+1:]\n                else:\n                    astr=astr[:i]+\"1\"\n                    bstr=bstr[:i]+\"1\"\nprint(\"!\",int(astr,2),int(bstr,2))","output":"constant"},{"instruction":"import sys\nsss='RGB'*700\ndef check(ss,p):\n    i=0\n    m=10**5\n    ans=0\n    while i<len(p):\n        if p[i]!=sss[i]:\n            ans+=1\n        i+=1\n    m=min(m,ans)\n    ans=0\n    i=1\n    while i<len(p)+1:\n        if p[i-1]!=sss[i]:\n            ans+=1\n        i+=1\n    m=min(m,ans)\n    ans=0\n    i=2\n    while i<len(p)+2:\n        if p[i-2]!=sss[i]:\n            ans+=1\n        i+=1\n    m=min(m,ans)\n\n    return m\n\nfor _ in range(int(input())):\n    n,k=(list(map(int,sys.stdin.readline().split())))\n    s=input()\n    m=10**5\n    for i in range(n-k+1):\n        m=min(m,(check(sss,s[i:i+k])))\n    print(m)","output":"quadratic"},{"instruction":"def solve(N, A):\n    cnt = [0] * (N + 1)\n\n    evd = {}\n    xs = []\n    for a, b in A:\n        if a not in evd:\n            evd[a] = [0, 0]\n            xs.append(a)\n        if b not in evd:\n            evd[b] = [0, 0]\n            xs.append(b)\n\n        evd[a][0] += 1\n        evd[b][1] += 1\n\n    xs.sort()\n\n    px = xs[0] - 1\n    pop = 0\n    for x in xs:\n        cnt[pop] += x - px - 1\n        cnt[pop + evd[x][0]] += 1\n        pop -= evd[x][1]\n        pop += evd[x][0]\n        px = x\n\n    return cnt[1:]\n\ndef main():\n    N = int(input())\n    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]\n    print(*solve(N, A))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"import sys\ndef ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\ntc = 1\nwhile tc:\n    tc-=1\n    n, k = map(int, input().split())\n    l = -1\n    r = n+1\n    while r-l > 1:\n        m = (r+l)\/\/2\n        if (n-m)*(n-m+1)\/\/2 - m > k:\n            l = m\n        else:\n            r = m\n    print(r)","output":"logn"},{"instruction":"s = [input(), input()]\nn = len(s[0])\n\ndp = [[0,0,0] for _ in range(n+1)]\n\nfor i in range(n-2,-1,-1):\n    dp[i] = [dp[i+1][0]]*3\n    vals = [0,0,0,0]\n    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0':\n        vals[0] = dp[i+1][2] + 1\n    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':\n        vals[1] = dp[i+2][0] + 1\n    if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':\n        vals[2] = dp[i+2][0] + 1\n    if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0':\n        vals[3] = dp[i+1][1] + 1\n    dp[i][1] = max(dp[i+1][0], vals[1])\n    dp[i][2] = max(dp[i+1][0], vals[2])\n    dp[i][0] = max(dp[i][1], dp[i][2], *vals)\n\nresult = max(dp[0])\nprint(result)","output":"constant"},{"instruction":"f = lambda m, k: (k*m - m*(m-1)\/\/2 - m + 1)\n\ndef ok(m, k, n):\n    return f(m, k) >= n\n\nn, k = map(int, input().split())\n\nif not ok(k, k, n): print(-1)\nelse:\n    l, h = 0, k\n    while (h > l):\n        mid = l + (h - l) \/\/ 2\n        if ok(mid, k, n): h = mid\n        else: l = mid + 1\n    print(h)","output":"logn"},{"instruction":"n = int(input())\nm = input().split()\nt = []\nfor i in range(n):\n    m[i] = int(m[i])\n    if i == 0:\n        t.append(m[i]+1)\n    else:\n        t.append(max(t[i-1], m[i]+1))\ns = t[n-1] - m[n-1] - 1\nfor i in range(n-2, -1, -1):\n    if t[i] < t[i+1]-1:\n        t[i] = t[i+1]-1\n    s += t[i] - m[i] - 1\nprint(s)","output":"linear"},{"instruction":"x, k = map(int,input().split())\nif x==0:\n  print(0)\nelse:\n  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)","output":"logn"},{"instruction":"import math\n\ns = input()\nt = input()\np1, p2, m1, m2, q = 0, 0, 0, 0, 0\nfor i in s:\n if i == '+':\n  p1 += 1\n else:\n  m1 += 1\nfor i in t:\n if i == '+':\n  p2 += 1\n elif i == '-':\n  m2 += 1\n else:\n  q += 1\ndp, dm = p1 - p2, m1 - m2\nif dp < 0 or dm < 0:\n print(0.0)\nelse:\n ans = (math.factorial(q) \/ (math.factorial(dp) * math.factorial(dm))) \/ math.pow(2, q)\n print(ans)","output":"np"},{"instruction":"n, m, k, l = map(int, input().split())\nneed = k + l\nif need % m == 0 and need <= n:\n    print(need \/\/ m)\nelse:\n    x = need \/\/ m + 1\n    if x * m > n:\n        print(-1)\n    else:\n        print(x)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\nn,m,k=map(int,input().split())\nA=[int(i) for i in input().split()]\nif n<=m:\n  AA=[0]*(n+1)\n  for i in range(n):\n    AA[i+1]=AA[i]+A[i]\n  mm=0\n  for i in range(n+1):\n    for j in range(i+1,n+1):\n      mm=max(mm,AA[j]-AA[i]-k)\nelse:\n  DP=[[0]*(m+1) for _ in range(n+1)]\n  for i in range(n):\n    a=A[i]\n    DP[i+1][0]=max([DP[i][0],DP[i][m],DP[i][m]+a-k,DP[i][1]])\n    DP[i+1][1]=max(a-k,DP[i][m]+a-k)\n    for j in range(2,m+1):\n      DP[i+1][0]=max(DP[i+1][0],DP[i][j])\n      if j>i+1:\n        continue\n      else:\n        DP[i+1][j]=max(DP[i][j-1]+a,DP[i][m]+a-k)\nprint(max(A[0]-k,0) if n==1 else mm if n<=m else max(0,max(DP[n])))","output":"quadratic"},{"instruction":"import math\n\nn,m = map(int, input().strip().split(' '))\n\ns=input()\nt=input()\nif '*' not in s:\n    if s==t:\n        print('YES')\n    else:\n        print('NO')\nelif n>m+1:\n    print('NO')\nelif n==1 and s=='*':\n    print('YES')\nelse:\n    s=list(s)\n    t=list(t)\n    if s[0]=='*':\n        if s[1:]==t[-(len(s[1:])):]:\n            print('YES')\n        else:\n            print('NO')\n    elif s[-1]=='*':\n        if s[:n-1]==t[:n-1]:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        ind=s.index('*')\n\n        if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]:\n            print('YES')\n        else:\n            print('NO')","output":"linear"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\nfrom collections import Counter\n\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\nn, k = mi()\ns = input().strip()\nc = Counter(s)\nmn = 10 ** 9\nfor ch in alpha[:k]:\n    mn = min(mn, c[ch])\nprint(mn * k)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nMAP=[list(input().strip()) for i in range(n)]\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==\"*\":\n            T0[i][j]=T0[i-1][j]+1\n            Y0[i][j]=Y0[i][j-1]+1\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        if MAP[i][j]==\"*\":\n            T1[i][j]=T1[i+1][j]+1\n            Y1[i][j]=Y1[i][j+1]+1\n\nANS=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])\n        if score>=2:\n            ANS[i][j]=score\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)\n        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)\n        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)\n\nSUF=[[\".\"]*m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:\n            SUF[i][j]=\"*\"\n\nif SUF!=MAP:\n    print(-1)\nelse:\n    ANSLIST=[]\n    for i in range(n):\n        for j in range(m):\n            if ANS[i][j]!=0:\n                ANSLIST.append((i+1,j+1,ANS[i][j]-1))\n\n    print(len(ANSLIST))\n    for ans in ANSLIST:\n        print(*ans)","output":"quadratic"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nfrom queue import PriorityQueue as pq\nn,m=map(int,input().split())\nl=list(map(int,input().split()))\nx=dc(int)\nc=0\np=0\n\nfor i in l:\n    x[i]+=1\n    f=1\n    for i in range(1,n+1):\n        if x[i]==0:\n            f=0\n            break\n    if f:\n        p+=1\n        for i in range(1,n+1):\n            x[i]-=1\n\nprint(p)","output":"quadratic"},{"instruction":"from sys import stdin, stdout\n\ndef check(k, b, T):\n\tc = [e for e in b if e[0] >= k]\n\n\tif len(c) < k:\n\t\treturn False, None\n\n\tfirst_k_probs = c[:k]\n\ts = sum([e[1] for e in first_k_probs])\n\n\tif s > T:\n\t\treturn False, None\n\n\treturn True, first_k_probs\n\ndef solve(n, T, a, t):\n\tb = []\n\n\tfor i in range(n):\n\t\tb.append((a[i], t[i], i + 1))\n\n\tb.sort(key=lambda x: x[1])\n\n\tlow, high = 0, n\n\tresult = 0\n\tfinal_probs = []\n\n\twhile low <= high:\n\t\tmid = (low + high) \/\/ 2\n\n\t\t(possible, probs) = check(mid, b, T)\n\t\tif possible:\n\t\t\tresult, final_probs = mid, probs\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\n\treturn (result, [e[2] for e in final_probs])\n\nn, T = (int(x) for x in stdin.readline().split())\n\na = [0] * n\nt = [0] * n\n\nfor i in range(n):\n\ta[i], t[i] = (int(x) for x in stdin.readline().split())\n\npoint, probs = solve(n, T, a, t)\nstdout.write(\"%s\\n\" % point)\nstdout.write(\"%s\\n\" % len(probs))\nif len(probs) > 0:\n\tstdout.write(\"%s\\n\" % \" \".join([str(x) for x in probs]))","output":"nlogn"},{"instruction":"x,k = map(int,input().split())\nif(x==0):\n    print(0)\n    exit(0)\nm = 10**9+7\np = pow(2,k+1,m)\nq = pow(2,k,m)\na = (x*p-q+1)%m\nprint(a)","output":"logn"},{"instruction":"class Solution:\n    def maxCoins(self, nums):\n        n = len(nums)\n        new_nums = [1] + nums + [1]\n\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        for l in range(n, 0, -1):\n            for r in range(l, n + 1):\n                for i in range(l, r + 1):\n                    coins = new_nums[l - 1] * new_nums[i] * new_nums[r + 1]\n                    coins += dp[l][i - 1] + dp[i + 1][r]\n                    dp[l][r] = max(dp[l][r], coins)\n\n        return dp[1][n]","output":"cubic"},{"instruction":"def main():\n    n, m = map(int, input().split())\n    def intCompare(x):\n        if int(x) == m:\n            return 0\n        if int(x) < m:\n            return -1\n        return 1\n    p = list(map(intCompare, input().split()))\n    ret = 0\n    ind = p.index(0)\n    tem = 0\n    ret0 = [0] * 400001\n    ret1 = [0] * 400001\n    set0 = set()\n    for i in range(ind, -1, -1):\n        tem += p[i]\n        ret0[tem] += 1\n        set0.add(tem)\n    tem = 0\n    for i in range(ind, n):\n        tem += p[i]\n        ret1[tem] += 1\n    for i in set0:\n        ret += ret0[i] * (ret1[-i] + ret1[1-i])\n    print(ret)\n    return 0\nmain()","output":"nlogn"},{"instruction":"n=int(input())\na=[-1]+list(map(int,input().split()))\ns=set()\ns.add(-1)\na.sort()\ncount,add=0,0\nflag=0\nfor i in range(1,n+1):\n    if a[i] in s and a[i]-1 in s:\n        flag=1\n        break\n    if a[i] in s:\n        add+=1\n    if(add==2):\n        flag=1\n        break\n    s.add(a[i])\n    count+=a[i]-(i-1)\nif(flag==0 and count%2==1):\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")","output":"nlogn"},{"instruction":"ct = [0]*26\n\nn, k =[int(i) for i in input().split()]\ns = input()\n\nfor i in s:\n    ct[ord(i)-ord('A')]+=1\n\nprint(min(ct[:k])*k)","output":"linear"},{"instruction":"def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    a = [int(x) for x in input().split(' ')]\n    a_pows = []\n    a_pow_dict = [{} for u in range(11)]\n    for j in range(n):\n        x = a[j] % k\n        i = 0\n        while i < 11:\n            if x in a_pow_dict[i]:\n                a_pow_dict[i][x] += 1\n            else:\n                a_pow_dict[i][x] = 1\n            i += 1\n            x = (x * 10) % k\n\n    c = 0\n\n    for x in a:\n        m = len(str(x))\n        if (-x) % k in a_pow_dict[m]:\n            c += a_pow_dict[m][(-x) % k]\n            c -= int(int(str(x) * 2) % k == 0)\n\n    return c\n\nprint(solve())","output":"nlogn"},{"instruction":"s=input()\nc=c1=0\nfor i in range(len(s)\/\/2):\n    if s[i]==s[len(s)-i-1]:\n        c+=1\nfor i in range(len(s)):\n    if s[i]==s[0]:\n        c1+=1\nif c1==len(s):\n    print(0)\nelif c==len(s)\/\/2:\n    print(len(s)-1)\nelse:\n    print(len(s))","output":"linear"},{"instruction":"n = int(input())\narr = input().split()\nb = []\n\nfor x in arr:\n\tb.append(int(x))\n\ncnt = {}\nans = 0\n\nfor i in range(n):\n\tans += b[i]*(i) + (-b[i])*(n - i - 1)\n\nfor i in range(n):\n\tif((b[i] - 1) in cnt.keys()):\n\t\tans -= cnt[b[i] - 1]\n\tif((b[i] + 1) in cnt.keys()):\n\t\tans += cnt[b[i] + 1]\n\tif((b[i]) in cnt.keys()):\n\t\tcnt[b[i]] += 1\n\telse:\n\t\tcnt[b[i]] = 1\n\nprint(ans)","output":"nlogn"},{"instruction":"from sys import stdin\nn=int(stdin.readline().strip())\ns=list(map(int,stdin.readline().strip().split()))\ns.sort()\nf=False\nz=s.count(0)\np=0\nfor i in range(2,n):\n    if s[i]==s[i-1] and s[i-1]==s[i-2]:\n        f=True\nfor i in range(1,n):\n    if s[i]==s[i-1]:\n        p+=1\n        if i-2>=0 and s[i-2]==s[i-1]-1:\n            f=True\ny=sum(s)\nt=(n)*(n-1)\/\/2\nr=y-t\nif r%2==0 or f or y==0 or z>=2 or p>=2:\n    print(\"cslnb\")\nelse:\n    print(\"sjfnb\")","output":"nlogn"},{"instruction":"n = int(input())\ns = input()\nmaxn = 0\nnow = 0\nfor i in s:\n    if i == '+':\n        now += 1\n    else:\n        now -= 1\n    maxn = max(maxn, -now)\nprint(now + maxn)","output":"linear"},{"instruction":"n = int(raw_input())\na = sorted(list(map(int, raw_input().split())))\nduplicates = {}\nd = None\ndelta = 0\nfor i, el in enumerate(a, 1):\n    if el not in duplicates:\n        duplicates[el] = 0\n    else:\n        d = el\n        duplicates[el] += 1\n    min_value = i-1\n    delta += el - min_value\nif sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):\n    print('cslnb')\nelif delta == 0:\n    print('cslnb')\nelif delta % 2 == 1:\n    print('sjfnb')\nelse:\n    print('cslnb')","output":"linear"},{"instruction":"from sys import stdout\n\nn = int(input())\n\nif n % 4 == 2:\n\n    print(\"! -1\")\n\n    exit(0)\n\nprint(\"?\", 1)\n\nstdout.flush()\n\na = int(input())\n\nprint(\"?\", 1 + n \/\/ 2)\n\nstdout.flush()\n\nb = int(input())\n\nif a == b:\n\n    print(\"!\", 1)\n\n    exit(0)\n\nl = 1\n\nr = 1 + n \/\/ 2\n\nwhile(l != r):\n\n    mid = ( l + r ) \/\/ 2\n\n    print(\"?\", mid)\n\n    stdout.flush()\n\n    c = int(input())\n\n    print(\"?\", mid + n \/\/ 2)\n\n    stdout.flush()\n\n    d = int(input())\n\n    if c == d:\n\n        print(\"!\", mid)\n\n        exit(0)\n\n    if a < b:\n\n        if c < d:\n\n            l = mid + 1\n\n        else:\n\n            r = mid\n\n    else:\n\n        if c > d:\n\n            l = mid + 1\n\n        else:\n\n            r = mid\n\nprint(\"!\", l)","output":"logn"},{"instruction":"l,r=map(int,input().split())\nal=[]\nar=[]\nwhile(r):\n    p=r%2\n    ar.append(p)\n    r=r\/\/2\nwhile(l):\n    p=l%2\n    al.append(p)\n    l=l\/\/2\nif len(ar)!=len(al):\n    ans=(2**len(ar))-1\nelse:\n    n=len(ar)\n    s=0\n    k=0\n    for i in range(n-1,-1,-1):\n        if ar[i]!=al[i]:\n            k=i+1\n            break\n    ans=(2**k)-1\n    if k==0:\n        ans=0\nprint(ans)","output":"logn"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nfrom queue import PriorityQueue as pq\nn=int(input())\nif n<=5:\n    print(-1)\nelse:\n    for i in range(2,5):\n        print(1,i)\n    for i in range(5,n+1):\n        print(2,i)\nfor i in range(2,n+1):\n    print(1,i)","output":"linear"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom math import ceil\nmod = 10 ** 9 + 7\n\ndef get_original_pieces(x):\n    common = (pow(x, 2) - 1) \/\/ 2\n    first_piece = \"10\"*common + '1'\n    second_piece = '0' + \"10\"*common\n    return [first_piece, second_piece]\n\nfor _ in range(1):\n    n = int(input())\n    pieces = [\"\" for _ in range(4)]\n    original_pieces = get_original_pieces(n)\n    i = 0\n    for _ in range(3 + (n*4)):\n        s = input()\n        if s:\n            pieces[i] += s\n        else:\n            i += 1\n\n    till = pow(n, 2)\n    fp = [[0,i] for i in range(4)]\n    sp = [[0,i] for i in range(4)]\n    for i in range(4):\n        fpc, spc = 0, 0\n        for j in range(till):\n            if pieces[i][j] != original_pieces[0][j]:\n                fpc += 1\n            if pieces[i][j] != original_pieces[1][j]:\n                spc += 1\n        fp[i][0] = fpc\n        sp[i][0] = spc\n    fp.sort()\n    sp.sort()\n    ans1 = fp[0][0] + fp[1][0]\n    ans2 = sp[0][0] + sp[1][0]\n    for i in range(4):\n        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]\n        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]\n    ans = min(ans1, ans2)\n    print(ans)","output":"quadratic"},{"instruction":"n=int(input())\nprint(n\/\/2+1)","output":"constant"},{"instruction":"class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n        return False","output":"quadratic"},{"instruction":"a, b, c, n = map(int, input().split())\nresult = n - a - b + c\nprint(result if result > 0 and c <= a and c <= b else -1)","output":"constant"},{"instruction":"n, k= map(int, input().split())\nA = list(map(int, input().split()))\nC = [0] * 100001\n\nl = 0\nr = 0\np = 0\n\nwhile r<n and p < k:\n    C[A[r]] += 1\n    if C[A[r]] == 1:\n        p += 1\n    r += 1\nif p != k:\n    print('-1', '-1')\nelse:\n    while p == k:\n        C[A[l]] -= 1\n        if C[A[l]] == 0:\n            p -= 1\n        l +=1\n\n    l -= 1\n\n    print(l+1,r)","output":"linear"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    n,k=inar()\n    st=input().strip()\n    res=st\n    pos=1\n    cnt=1\n    while cnt<k:\n        suffix=0\n        counter=0\n        for i in range(pos,len(res)):\n            if res[i]==st[suffix]:\n                suffix+=1\n            else:\n                counter=1\n                break\n        if counter:\n            pos+=1\n            continue\n        if pos>len(res):\n            res+=st\n            cnt+=1\n            pos+=1\n            continue\n        res+=st[suffix:n]\n        cnt+=1\n        pos+=1\n    print(res)\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n, s = map(int, input().split())\nr = 0\nv = min(n+1, s+19*9)\nfor i in range(s, v):\n    zz = f'{i}'\n    sm = i\n    for z in zz:\n        sm -= int(z)\n\n    if(sm >= s):\n        r += 1\n\nprint(r + n-v + 1)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\nmax_mod = 0\nmax_i = -1\nfor i in range(n):\n\tif a[i] >= 0:\n\t\ta[i] = -a[i] - 1\n\tif -a[i] > max_mod:\n\t\tmax_mod = -a[i]\n\t\tmax_i = i\n\nif n % 2 == 1:\n\ta[max_i] = -a[max_i] - 1\n\nprint(' '.join(list(map(str, a))))","output":"linear"},{"instruction":"def countall(string, substring):\n    total = 0\n    for i in range(len(string)-len(substring)+1):\n        if string[i:i+len(substring)] == substring:\n            total += 1\n    return total\n\nn = input()\nallvalues = []\nfor i in range(len(n)):\n    for j in range(len(n)-1, i-1, -1):\n        if countall(n, n[i:j+1]) > 1:\n            allvalues.append(j-i+1)\n            break\n\ntry:\n    print(max(allvalues))\nexcept:\n    print(0)","output":"cubic"},{"instruction":"class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        memo = [[None] * (n + 1) for _ in range(n + 1)]\n\n        def dfs(i, open):\n            if open < 0:\n                return False\n            if i == n:\n                return open == 0\n            if memo[i][open] is not None:\n                return memo[i][open]\n\n            if s[i] == '(':\n                result = dfs(i + 1, open + 1)\n            elif s[i] == ')':\n                result = dfs(i + 1, open - 1)\n            else:\n                result = (dfs(i + 1, open) or\n                          dfs(i + 1, open + 1) or\n                          dfs(i + 1, open - 1))\n\n            memo[i][open] = result\n            return result\n\n        return dfs(0, 0)","output":"quadratic"},{"instruction":"def main():\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(input())\n    ans = \"NO\"\n    count = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if (a[i][j] == '1'):\n                count[j] += 1\n    for i in range(n):\n        ans = \"YES\"\n        for j in range(m):\n            if (count[j] == 1 and a[i][j] == '1'):\n                ans = \"NO\"\n                break\n        if (ans == \"YES\"):\n            break\n    print(ans)\nmain()","output":"quadratic"},{"instruction":"if __name__ == '__main__':\n    cin = input\n    n = int(cin())\n    s, t = [*cin()], cin()\n    i, r = 0, list()\n\n    if sorted(s) != sorted(t):\n        print(-1)\n    else:\n        while i < n:\n            j = i\n            while j < n and s[j] != t[i]:\n                j += 1\n            s[i:j + 1] = s[j:j + 1] + s[i:j]\n            r.extend(range(j, i, -1))\n            i += 1\n        print(len(r))\n        print(*r)","output":"quadratic"},{"instruction":"from collections import Counter\n\ndef main():\n    n, m = map(int, input().split())\n    l = list(map(int, input().split()))\n    p = l.index(m)\n    le, ri = Counter(), Counter()\n    c = 0\n    le[0] = ri[0] = 1\n    for i in range(p + 1, n):\n        if l[i] < m:\n            c += 1\n        else:\n            c -= 1\n        ri[c] += 1\n    c = 0\n    for i in range(p - 1, -1, -1):\n        if l[i] < m:\n            c -= 1\n        else:\n            c += 1\n        le[c] += 1\n    res = 0\n    for c, x in le.items():\n        res += x * (ri[c] + ri[c - 1])\n    print(res)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"f=input\nD,E={},[eval(f())for _ in range(int(f()))]\nfor e in E:D[e]=D.get(e,0)+1\nfor e in E:print(D[e])","output":"linear"},{"instruction":"def roll(i,j):\n    ways = []\n    if j:\n        ways.append(2*hor[i][j-1] + grid[i][j-1])\n    if m-1-j:\n        ways.append(2*hor[i][j] + grid[i][j+1])\n    if i:\n        ways.append(2*ver[i-1][j] + grid[i-1][j])\n    if n-1-i:\n        ways.append(2*ver[i][j] + grid[i+1][j])\n    return min(ways)\n\nn , m , k = map(int, input().split())\nhor = [list(map(int, input().split())) for _ in range(n)]\nver = [list(map(int, input().split())) for _ in range(n-1)]\n\ngrid = [[0]*m for _ in range(n)]\nif k%2:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\nelse:\n    for _ in range(k\/\/2):\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\n        grid = new_grid[:]\n    for i in range(n):\n        print(\" \".join(map(str,grid[i])))","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\ns = 0\n\nfor j, i in enumerate(a):\n    if i > s:\n        print(j + 1)\n        exit()\n    if i == s:\n        s += 1\n\nprint(-1)","output":"linear"},{"instruction":"import math\ns1=input()\ns2=input()\ns1p=s1.count(\"+\")\ns1m=s1.count(\"-\")\ns2p=s2.count(\"+\")\ns2m=s2.count(\"-\")\ns2q=0\nif '?' in s2:\n    s2q=s2.count(\"?\")\nif s2q==0:\n    if s1p==s2p and s1m==s2m:\n        print(\"%.12f\"%1)\n    else:\n        print(\"%.12f\"%0)\nelse:\n    if s1p>=s2p and s1m>=s2m:\n        s2q=math.factorial(s2q)\/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))\n        print(\"%.12f\"%(s2q\/(2**s2.count(\"?\"))))\n    else:\n        print(\"%.12f\"%0)","output":"np"},{"instruction":"import os\nimport sys\n\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM= 998244353\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\nn,k = value()\na = array()\n\nans = 0\n\nfor i in range(n-k+1):\n\n    num = sum(a[i:i+k])\n    den = k\n    ans = max(ans , num\/den)\n\n    for j in range(i+k,n):\n\n        num += a[j]\n        den += 1\n        ans = max(ans , num\/den)\n\nprint(ans)","output":"quadratic"},{"instruction":"n, m, k = map(int, input().split())\nmi = list(map(int, input().split()))\n\nans = 0\nitems_to_del = 0\nshift = 1\nc_page = None\nfor el in mi:\n    if c_page is None:\n        c_page = (el - shift) \/\/ k\n        items_to_del = 1\n    else:\n        page = (el - shift) \/\/ k\n        if page != c_page:\n            shift += items_to_del\n            ans += 1\n            c_page = (el - shift) \/\/ k\n            items_to_del = 1\n        else:\n            items_to_del += 1\nif items_to_del != 0:\n    ans += 1\nprint(ans)","output":"linear"},{"instruction":"import sys, math, queue, bisect\n\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\nn = int(input())\nif n < 10:\n    print(n)\n    exit()\nd = 1\nwhile n > 9*d*pow(10, d-1):\n    n -= 9*d*pow(10, d-1)\n    d += 1\nx = pow(10, d-1) + (n-1)\/\/d\np = n % d\nx = str(x).zfill(d)\nprint(x[p-1])","output":"logn"},{"instruction":"n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nans = 0\n\nfor mask in range(2**n):\n    cnt, csum = 0, 0\n    mn, mx = 10**18, -(10**18)\n    for i in range(n):\n        if (mask & (1 << i) != 0):\n            cnt += 1\n            csum += c[i]\n            mn = min(mn, c[i])\n            mx = max(mx, c[i])\n    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):\n        ans += 1\n\nprint(ans)","output":"np"},{"instruction":"import math\nk = int(input())\n\ndef cnt_digit_order(X):\n    res = 0\n    if X == 0:\n        return 0\n    for i in range(1, X+1):\n        res += i*(9*pow(10, i-1))\n    return res\n\nL = -1\nleftcnt = 0\nfor length in range(1, 100):\n    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):\n        L = length\n        leftcnt = k - cnt_digit_order(length - 1)\n        break\n\nM = str(math.ceil(leftcnt\/L) + (10**(L-1) - 1))\nleftcnt -= 1\nleftcnt %= L\nprint(M[leftcnt])","output":"logn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        ans=[]\n        i=1\n        k=1\n        t=0\n        while True:\n            k=i*i\n            if k<=n:\n                t=i\n            else:\n                break\n            i+=1\n        a=[]\n        z=[]\n        for i in range(n):\n            z+=[i+1]\n            if len(z)==t:\n                a=z+a\n                z=[]\n        a=z+a\n        wia(a)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"n,m,k=map(int,input().split())\narr=list(map(int,input().split()))\narr+=[0]*m\nans=0\npos=0\nwhile arr[pos]!=0:\n  page=(arr[pos]-pos-1)\/\/k\n  tmp=1\n  for i in range(1,k):\n    if pos+i>=2*m-1:\n      break\n    if (arr[pos+i]-pos-1)\/\/k==page:\n      tmp+=1\n    else:\n      break\n  pos+=tmp\n  ans+=1\nprint(ans)","output":"linear"},{"instruction":"N = int(input())\nA = [int(i) for i in input().split()]\nA.sort()\nduplicates = 0\ni=1\ntemp = 1\nind = -1\nwhile i<N:\n    temp = 1\n    while i<N and A[i] == A[i-1]:\n        ind = i-1\n        temp +=1\n        i+=1\n    i+=1\n\n    if temp != 1: duplicates +=1\n    if temp > 2 :\n        break\n\nturns =  sum(A) - N*(N-1)\/\/2\n\nif temp>2 or duplicates>1: print('cslnb')\n\nelse:\n    output = 'cslnb'\n    if duplicates == 0:\n        if turns%2 == 1: output = 'sjfnb'\n    else:\n        if ind-1 >= 0:\n            if A[ind-1] == A[ind]-1:\n                output = 'cslnb'\n            else:\n                if turns%2 == 1: output = 'sjfnb'\n        else:\n            if A[ind] == 0:\n                output = 'cslnb'\n            else:\n                if turns%2 == 1: output = 'sjfnb'\n    print(output)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\ns = input()\n\nfor i in range(1, n):\n    if s[:n - i] == s[i:]:\n        print(s + s[n - i:] * (k - 1))\n        exit()\nprint(s * k)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\nn, m = map(int, input().split())\n\nMOD = m\nMAX_N = 10**3\n\nfac = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * (i) % MOD\n\nfac_inv = [1] + [0] * MAX_N\n\nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD\n\npow2 = [0] * (n+1)\npow2[0] = 1\nfor i in range(1, n+1):\n    pow2[i] = pow2[i-1] * 2 % MOD\n\ntable = [[0] * 500 for _ in range(500)]\nfor i in range(500):\n    for j in range(i+1):\n        table[i][j] = mod_nCr(i, j)\n\ndp = [[0] * (n+1) for _ in range(n)]\nfor i in range(n):\n    dp[i][i+1] = pow2[i]\nfor i in range(n-1):\n    for j in range(i \/\/ 2 + 1, n-1):\n        if dp[i][j] == 0:\n            continue\n        dp[i][j] %= MOD\n        for k in range(1, n-j):\n            if i + k + 1 >= n:\n                break\n\n            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]\n\nans = sum(dp[-1]) % MOD\nprint(ans)","output":"cubic"},{"instruction":"import io\nimport os\n\ndef solve(N,):\n\n    if N % 2 != 0:\n        return \"NO\"\n    N \/\/= 2\n    if int(N ** 0.5) ** 2 == N:\n        return \"YES\"\n    if N % 2 != 0:\n        return \"NO\"\n    N \/\/= 2\n    if int(N ** 0.5) ** 2 == N:\n        return \"YES\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    TC = int(input())\n    for tc in range(1, TC + 1):\n        (N,) = [int(x) for x in input().split()]\n        ans = solve(N,)\n        print(ans)","output":"constant"},{"instruction":"with open(\"input.txt\",\"r\") as in_file:\n    with open(\"output.txt\",\"a\") as out_file:\n        N,M = map(int,in_file.readline().split())\n        K = int(in_file.readline())\n        map_max_dist = [[5000 for i in range(M)] for j in range(N)]\n        inputs = list(map(int,in_file.readline().split()))\n        p = 0\n        while(p<=K*2-2):\n            x,y = inputs[p]-1,inputs[p+1]-1\n            for r in range(N):\n                for c in range(M):\n                    dist = abs(x-r)+abs(y-c)\n                    if dist<map_max_dist[r][c]:\n                        map_max_dist[r][c] = dist\n            p+=2\n        max_val = 0\n        max_index = (0,0)\n        i,j = 0,0\n        for i in range(N):\n            for j in range(M):\n                if(map_max_dist[i][j]>max_val):\n                    max_val = map_max_dist[i][j]\n                    max_index = (i,j)\n        out_file.write(\"{} {}\".format(max_index[0]+1,max_index[1]+1))","output":"cubic"},{"instruction":"def AP_Term(n):\n    return (n*(1+n))\/\/2\n\nact, cleft = map(int, input().split())\nif cleft != AP_Term(act):\n    low = 1\n    high = act\n    ans = 0\n    while low <= high:\n        mid = low + (high-low)\/\/2\n        candy_in = AP_Term(mid)\n        moves_left = (act - mid)\n        if cleft == (candy_in - moves_left):\n            ans = (moves_left)\n            break\n        elif cleft > (candy_in - moves_left):\n            low = mid+1\n        else:\n            high = mid-1\n    print(ans)\nelse:\n    print(0)","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf)\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"def nine(p) :\n\n    s=''\n    for i in range(p) :\n        s+='9'\n    return int(s)\ndef prosh(p) :\n    ans=0\n    for i in range(1,p+1) :\n        ans+=nine(i)*9\n    return ans\n\nn,k=map(int,input().split())\nl=[0]*29\nfor i in range(19) :\n\n    e=nine(19-i)\n\n    l[i]=int(k\/e)\n\n    k-=l[i]*e\n\n    if k<=0 :\n\n        break\n    if i==18  or k%e>prosh(19-i-1) :\n\n        l[i]+=1\n        break\notv=0\nfor i in range(19) :\n\n    otv+=10**(19-i)*l[i]\n\nprint(max(n-otv+1,0))","output":"logn"},{"instruction":"def read_nums():\n    return [int(x) for x in input().split()]\n\ndef main():\n    n, v = read_nums()\n    res = 0\n    cur_tank = 0\n    for c in range(1, n+1):\n        need_to_by = min(v - cur_tank, n - c - cur_tank)\n        res += need_to_by * c\n        cur_tank += need_to_by\n        cur_tank -= 1\n    print(res)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"k,n,s,p=map(int,input().split())\nc=(n\/\/s) if n%s==0 else (n\/\/s)+1\nprint((c*k)\/\/p if (c*k)%p==0 else ((c*k)\/\/p)+1)","output":"constant"},{"instruction":"import sys\n\ninput=lambda : sys.stdin.readline().strip()\nchar = [chr(i) for i in range(97,123)]\nCHAR = [chr(i) for i in range(65,91)]\nmp = lambda:list(map(int,input().split()))\nINT = lambda:int(input())\nrn = lambda:range(INT())\n\nfrom math import ceil,sqrt,factorial,gcd\n\nr,g,b = mp()\nrl = sorted(mp(),reverse=True)\ngl = sorted(mp(),reverse=True)\nbl = sorted(mp(),reverse=True)\n\ndef solve(i,j,k):\n\tif dp_table[i][j][k] != -1:\n\t\treturn dp_table[i][j][k]\n\n\tans = 0\n\n\tif i < r and j < g:\n\t\tans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)\n\n\tif i < r and k < b:\n\t\tans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)\n\n\tif j < g and k < b:\n\t\tans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)\n\n\tdp_table[i][j][k] = ans\n\treturn dp_table[i][j][k]\n\ndp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]\nres = solve(0,0,0)\nprint(res)","output":"cubic"},{"instruction":"N, M = map(int, input().split())\n\ngrid = []\nfor _ in range(N):\n    grid.append(list(input()))\n\ndef check(grid, i, j, sx, sy):\n    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:\n        i -= sx\n        j -= sy\n        v = grid[i][j] == '\n        return v\n\n    return False\n\nprev = False\nfor m in range(M):\n    for n in range(N):\n        if grid[n][m] == '\n            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):\n                print(\"NO\")\n                exit(0)\n\nprint(\"YES\")","output":"quadratic"},{"instruction":"import io\nimport os\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn = int(input())\n\narr = [int(z) for z in input().split()]\n\nq = int(input())\n\ninv = 0\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i < j and arr[i] > arr[j]:\n\n            inv += 1\n\n        inv = inv % 2\n\nfor query in range(q):\n\n    l, r = map(int, input().split())\n\n    diff = r - l\n\n    s = diff\/\/2\n\n    if diff % 2:\n        s += 1\n\n    inv = (inv + (s % 2)) % 2\n\n    if inv:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\na = {0:0}\nb = [0]\n\nfor i in range(n):\n    for p in b:\n        d = gcd(p, l[i])\n        cost = a[p] + c[i]\n        if d not in a:\n            a[d] = cost\n            b.append(d)\n        elif a[d] > cost: a[d] = cost\n\nif 1 not in a: a[1] = -1\nprint(a[1])","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom collections import defaultdict, deque\nimport random\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn, k = map(int, input().split(\" \"))\nans = []\nfor i in range(1, n*k + 1):\n    if i%2:\n        x,y = divmod(i\/\/2, k)\n        ans.append([x+1, y+1])\n    else:\n        x,y = divmod(n*k-i\/\/2, k)\n        ans.append([x + 1, y + 1])\nfor i in ans:\n    sys.stdout.write('{} {}\\n'.format(*i))","output":"quadratic"},{"instruction":"import sys\nimport math\nimport collections\nimport heapq\nimport decimal\ninput=sys.stdin.readline\nn,m,k = map(int,input().split())\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nb=[]\nfor i in range(n-1):\n    b.append(list(map(int,input().split())))\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end = \" \")\n        print()\nelse:\n    k\/\/=2\n    pre=[[0 for i in range(m)]for j in range(n)]\n    for x in range(k):\n        curr = [[float(\"inf\") for i in range(m)]for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if(j>0):\n                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])\n                if(i<n-1):\n                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])\n                if(j<m-1):\n                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])\n                if(i>0):\n                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])\n        pre=curr[:]\n    for i in range(n):\n        for j in range(m):\n            print(2*pre[i][j],end = \" \")\n        print()","output":"cubic"},{"instruction":"n = int(input())\n\nmult = 1\nres = []\nremain = n\nwhile remain >0:\n    if remain == 2:\n        res.extend([mult, mult*2])\n        remain = 0\n    elif remain == 3:\n        res.extend([mult, mult, mult *3])\n        remain = 0\n    else:\n        half = remain \/\/ 2\n        extra = remain - half\n        res.extend([mult]*extra)\n        remain  = half\n        mult = mult *2\nprint(*res)","output":"logn"},{"instruction":"x, k = map(int,input().split())\nif x == 0:\n    print(0)\n    exit()\nb = pow(2,k,1000000007)\na = (2*x - 1)%(1000000007)\nprint((a*b + 1) % 1000000007)","output":"logn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nidx = list(range(n))\nidx.sort(key=lambda i: a[i], reverse=True)\nimin = imax = idx[0]\nfor i in idx[1:]:\n    if i == imin - 1 or i == imax + 1:\n        imin = min(imin, i)\n        imax = max(imax, i)\n    else:\n        print('NO')\n        exit(0)\nprint('YES')","output":"nlogn"},{"instruction":"import sys\nimport math\n\nprime=[True for _ in range(1000001)]\n\ndef solve():\n    n,e,h,a,b,c=map(int,input().split())\n    ans=1e9\n    for i in range(1,1000001):\n        su=0\n        ntmp=n\n        tmp1=e\n        tmp2=h\n        tmp1-=i\n        tmp2-=i\n        if (tmp1<0 or tmp2<0 or i>ntmp):\n            break\n        ntmp-=i\n        su+=(c*i)\n        if (ntmp==0):\n            ans=min(ans,su)\n            continue\n        if (a<=b):\n            if ((tmp1\/\/2)>=ntmp):\n                su+=int(a*ntmp)\n                ntmp-=ntmp\n            else:\n                su+=int(a*(tmp1\/\/2))\n                ntmp-=(tmp1\/\/2)\n                if (ntmp<=(tmp2\/\/3)):\n                    su+=int(b*ntmp)\n                    ntmp-=ntmp\n                else:\n                    su+=int(b*(tmp2\/\/3))\n                    ntmp-=(tmp2\/\/3)\n        else:\n            if ((tmp2\/\/3)>=ntmp):\n                su+=int(b*ntmp)\n                ntmp-=ntmp\n            else:\n                su+=int(b*(tmp2\/\/3))\n                ntmp-=(tmp2\/\/3)\n                if (ntmp<=(tmp1\/\/2)):\n                    su+=int(a*ntmp)\n                    ntmp-=ntmp\n                else:\n                    su+=int(a*(tmp1\/\/2))\n                    ntmp-=(tmp1\/\/2)\n        if (ntmp==0):\n            ans=min(ans,su)\n\n    if (ans==1e9):\n        print(\"-1\")\n    else:\n        print(ans)\n\ndef main():\n    n=int(input())\n    s=input()\n    m={}\n    have={}\n    cc=0\n    for c in s:\n        if (c not in m):\n            m[c]=1\n        else:\n            m[c]+=1\n    ct=len(m)\n    l=0\n    ans=1e9\n    for i in range(0,n):\n        if (s[i] not in have):\n            have[s[i]]=0\n            cc+=1\n        have[s[i]]+=1\n        while(l<=i and have[s[l]]>1):\n            have[s[l]]-=1\n            l+=1\n        if (cc==ct):\n            ans=min(ans,i-l+1)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"linear"},{"instruction":"n,k = list(map(int,input().split()))\nstart = k-1\nend = 1\n\ndef bsearch(start,end):\n    if start<end:\n        return start\n    else:\n        mid = start-(start-end)\/\/2\n        val = ((k-1)*k\/\/2) - ((mid-1)*mid\/\/2) +1\n        if val==n:\n            return mid\n        elif val>n:\n            end = mid+1\n        else:\n            start = mid-1\n        return bsearch(start,end)\n\nans = bsearch(start,end)\n\nif ans == 0:\n    print(-1)\nelif n==1:\n    print(0)\nelse:\n    print(k-ans)","output":"logn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\nclass SegTree:\n\n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n\n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n\n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\ndef SieveOfEratosthenes(limit):\n\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        a,b=ria()\n        op=0\n        while min(a,b):\n            if a>b:\n                op+=a\/\/b\n                a%=b\n            else:\n                op+=b\/\/a\n                b%=a\n\n        wi(op)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"constant"},{"instruction":"mod = 998244353\neps = 10**-9\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split())) + [0]\n    A.sort()\n\n    dp = [[0] * (i+1) for i in range(N+1)]\n    dp[0][0] = 1\n    l = 0\n    for i in range(1, N+1):\n        for ll in range(l+1, i):\n            if A[ll] * 2 <= A[i]:\n                l = ll\n            else:\n                break\n        for j in range(1, l+2):\n            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod\n        for j in range(i):\n            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod\n    print(dp[-1][-1])\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"a = input()\nl = 0\nfor i in range(1, len(a)):\n  for j in range(0, len(a) - i + 1):\n\n    t = a.find(a[j:j + i])\n    c = a.rfind(a[j:j + i])\n\n    if t != c:\n      if i > l:\n        l = i\nprint(l)","output":"cubic"},{"instruction":"import sys\n\ndef sum_range(l, r):\n    if r < l: return 0\n    if l == 0: return sum[r]\n    return sum[r] - sum[l - 1]\n\nn, k = map(int, input().split())\n\ncards = input()\n\nsum = [0] * n\nsum[0] = 1 if cards[0] == '1' else 0\nfor i in range(1, n):\n    sum[i] += sum[i - 1]\n    if cards[i] == '1':\n        sum[i] += 1\n\nmin0 = min1 = n\nmax0 = max1 = -1\nfor i in range(0, n):\n    if cards[i] == '1':\n        min1 = min(min1, i)\n        max1 = i\n    else:\n        min0 = min(min0, i)\n        max0 = i\n\ntoki = False\nqual = True\nfor i in range(0, n - k + 1):\n    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n:\n        toki = True\n    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0:\n        toki = True\n\n    prefix = sum_range(0, i - 1) == 0\n    suffix = sum_range(i + k, n - 1) == 0\n    if i > 0 and i + k < n and (prefix ^ suffix) == 0:\n        qual = False\n    if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k:\n        qual = False\n\nif toki == True:\n    print('tokitsukaze')\nelif qual == True:\n    print('quailty')\nelse:\n    print('once again')","output":"linear"},{"instruction":"a,d=map(int,input().split())\ny,g,b=map(int,input().split())\nm=y*2+g\nn=b*3+g\nc=0\nif(m>a):\n    c+=m-a\nif(n>d):\n    c+=n-d\nprint(c)","output":"constant"},{"instruction":"n,m = map(int, input().strip().split(' '))\na='8'*1129 + '9'\nb='1'*1130\nprint(a)\nprint(b)","output":"constant"},{"instruction":"n = int(input())\ns = [[\"\" for _ in range(n)] for __ in range(4)]\nfor i in range(3):\n    for j in range(n):\n        s[i][j] = input()\n    input()\nfor j in range(n):\n    s[3][j] = input()\nres = int(1e13)\nfor i in range(24):\n    perm = [0, 1, 2, 3]\n    L = [0]*4\n    tmp = i\n    for j in range(4):\n        L[j] = tmp % (4-j)\n        tmp \/\/= (4-j)\n    LL = [0]*4\n    for j in range(4):\n        LL[j] = perm[L[j]]\n        for k in range(L[j], 3-j):\n            perm[k] = perm[k+1]\n    lu, ru, ld, rd = LL[0], LL[1], LL[2], LL[3]\n    Map = [s[lu][_][:]+s[ru][_][:] for _ in range(n)] + [s[ld][_][:]+s[rd][_][:] for _ in range(n)]\n    cnt0, cnt1 = 0, 0\n    for j in range(2*n):\n        for k in range(2*n):\n            if (j+k) % 2:\n                if Map[j][k] == '0':\n                    cnt0 += 1\n                else:\n                    cnt1 += 1\n            else:\n                if Map[j][k] == '1':\n                    cnt0 += 1\n                else:\n                    cnt1 += 1\n    res = min(res, cnt0, cnt1)\nprint(res)","output":"quadratic"},{"instruction":"k,n,s,p = map(int,input().split())\nprint(int((int((n+s-1)\/s)*k+p-1)\/p))","output":"constant"},{"instruction":"import sys\n\ndef ints():\n    return map(int, input().split())\n\nn, m, k = ints()\nright = []\nfor i in range(n):\n    right.append(list(ints()))\ndown = []\nfor i in range(n-1):\n    down.append(list(ints()))\n\nINF = int(1e8)\n\ndef around(r, c):\n    a = []\n    for i, j in [[r-1, c], [r, c+1], [r+1, c], [r, c-1]]:\n        if not (i < 0 or i >= n or j < 0 or j >= m):\n            a.append([i, j])\n    return a\n\ndef mink(dist, si, sj):\n    minn = INF\n    for i in range(max(0, si-k\/\/2), min(n, si+k\/\/2+1)):\n        for j in range(max(0, sj-k\/\/2), min(m, sj+k\/\/2+1)):\n            if dist[i][j] < minn:\n                minn = dist[i][j]\n    return minn\n\ndef solve():\n    pdist = [[0] * m for i in range(n)]\n    if k & 1:\n        return [[-1] * m for i in range(n)]\n    for step in range(k\/\/2):\n        dist = [[0] * m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                adist = []\n                for ip, jp in around(i, j):\n                    if ip == i:\n                        if jp > j:\n                            w = right[i][j]\n                        else:\n                            w = right[i][jp]\n                    else:\n                        if ip > i:\n                            w = down[i][j]\n                        else:\n                            w = down[ip][j]\n                    adist.append(pdist[ip][jp] + w)\n                dist[i][j] = min(adist)\n        pdist = dist\n    for i in range(n):\n        for j in range(m):\n            pdist[i][j] *= 2\n    return pdist\n\nfor row in solve():\n    print(*row)","output":"cubic"},{"instruction":"def f(a, b):\n    global ans\n    maks = max(a, b)\n    mins = min(a, b)\n    ans += (maks\/\/mins)\n\n    if (mins == 1):\n        return ans\n    else:\n        if (maks % mins == 0):\n            return ans\n        else:\n            return f(maks%mins, mins)\nfor i in range(int(input())):\n    a, b = list(map(int, input().split()))\n    ans = 0\n    print(f(a, b))","output":"constant"},{"instruction":"import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+2)]\ndp=[-1 for i in range(n+2)]\nl=[[] for i in range(n+2)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=deque(map(int,input().split()))\nb.popleft()\ns=deque([1])\nvisited[1]=True\nwhile len(b)>0 and len(s)>0:\n    aux=0\n    for i in l[s[0]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(aux):\n        x=b.popleft()\n        if dp[x]==1:\n            s.append(x)\n            dp[x]=-1\n        else:\n            print(\"No\")\n            sys.exit()\n    s.popleft()\nprint(\"Yes\")","output":"nlogn"},{"instruction":"import sys,os,io,time,copy,math\nfrom functools import lru_cache\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef main():\n    n,k=map(int,input().split())\n    arr=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        arr.append((x,y))\n        arr.sort(key=lambda x:(x[0],-x[1]),reverse=True)\n    req=arr[k-1]\n    count=0\n    for a in arr:\n        if a==req:\n            count+=1\n    print(count)\n\nmain()","output":"nlogn"},{"instruction":"stones = list(map(int,input().split()))\ninitial_sum = 0\n\ndef even_sum(arr):\n    temp_sum = 0\n    for each in arr:\n        if(each%2 == 0):\n            temp_sum += each\n\n    return temp_sum\n\ninitial_sum = even_sum(stones)\ndup_sum = initial_sum\n\nfor i in range(14):\n    duplicate = list(stones)\n    temp = stones[i]\n    duplicate[i] = 0\n    j = i\n\n    for each in range(14):\n        duplicate[each] += temp\/\/14\n    temp = temp%14\n    while temp > 0 :\n        if( j == 13):\n            j = -1\n        j += 1\n        duplicate[j] += 1\n        temp -= 1\n\n    ts = even_sum(duplicate)\n    if(ts > initial_sum ):\n        initial_sum = ts\n\nprint(initial_sum)","output":"constant"},{"instruction":"import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\nw = [int(z) for z in input().split()]; s = input()\n\nidx = []\nfor i in range(n):\n    idx.append((w[i], i+1))\n\nidx.sort()\nheapq.heapify(idx)\nones = []\nheapq.heapify(ones)\nres = []\nfor i in range(2*n):\n    if s[i] == '0':\n        l = idx[0]\n        heapq.heappop(idx)\n        res.append(l[1])\n        heapq.heappush(ones, [-l[0], l[1]])\n    else:\n        l = ones[0]\n        heapq.heappop(ones)\n        res.append(l[1])\nres = ' '.join([str(i) for i in res])\nsys.stdout.write(res)","output":"nlogn"},{"instruction":"n=int(input())\nx,y=map(int,input().split())\nd1=max(x-1,y-1)\nd2=max(n-x,n-y)\nif d1<=d2:\n    print(\"White\")\nelse:\n    print(\"Black\")","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn, q = map(int, input().split())\nfor _ in range(q):\n    u = int(input())\n    s = input()\n    for comm in s:\n        k = 1\n        while True:\n            if k & u:\n                break\n            k <<= 1\n        if comm == 'L':\n            if k != 1:\n                u -= k\n                u += (k>>1)\n        elif comm == 'R':\n            if k != 1:\n                u += (k>>1)\n        elif comm == 'U':\n            nu = u - k\n            nu |= (k<<1)\n            if nu <= n:\n                u = nu\n    print(u)","output":"np"},{"instruction":"n = int(input()) + 1\nif n == 1:\n    print(0)\n    exit()\nprint(n if n % 2 else n \/\/ 2)","output":"constant"},{"instruction":"import math\nsend=input()\nrcv=input()\nd={}\nd['+']=0\nd['-']=0\nfor i in range(len(send)):\n\td[send[i]]=d[send[i]]+1\n\nflag=1\nc=0\nfor i in range(len(rcv)):\n\tif rcv[i] in d:\n\t\tif d[rcv[i]]==0:\n\t\t\tflag=0\n\t\telse:\n\t\t\td[rcv[i]]=d[rcv[i]]-1\ntot=d['+']+d['-']\ntotComb=2**tot\nn=tot\nr=d['+']\nnpr=math.factorial(n)\/math.factorial(n-r)\nreqComb=npr\/math.factorial(r)\n\nif flag==0:\n\tprint('0.00000000')\nelse:\n\tprint(float(reqComb)\/totComb)","output":"np"},{"instruction":"n=int(input())\nanswer=0\nfor i in range(1,2*n-2,2):\n    answer+=i\nprint(answer*2+2*n-1)","output":"linear"},{"instruction":"n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nfor x in r:\n    print(*x, sep='')","output":"quadratic"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\n\ndef num():\n\treturn map(int , input().split())\n\ndef nu():\n\treturn int(input())\n\nn,s=num()\ncc=0\nfor i in range(n,0,-1):\n\tcc+=s\/\/i\n\ts=s%i\nprint(cc)","output":"constant"},{"instruction":"n, m = map(int, input().split())\nxs = list(map(int, input().split()))\nts = list(map(int, input().split()))\n\nps = [x for x, t in zip(xs, ts) if t == 0]\nds = [x for x, t in zip(xs, ts) if t == 1]\nans = [0] * m\n\ndi = 0\nfor pi, p in enumerate(ps):\n    while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p):\n        di += 1\n\n    if di >= m:\n        ans[m - 1] += n - pi\n        break\n\n    ans[di] += 1\n\nprint(' '.join(map(str, ans)))","output":"linear"},{"instruction":"def make_number(b,chars):\n\tif len(chars) == 0:\n\t\treturn \"\"\n\ttarget = chars[0]\n\tfor i in chars:\n\t\tif int(b[0]) <= int(i):\n\t\t\tbreak\n\t\ttarget = i\n\tchars.remove(target)\n\treturn target + \"\".join(chars[::-1])\n\ndef find_number(b,chars):\n\tbackup_chars = list(chars)\n\tif len(b) == 1:\n\t\treturn chars[0]\n\telif b[0] in chars:\n\t\tchars.remove(b[0])\n\t\tnum = b[0] + find_number(b[1:],chars)\n\t\tif min(num,b) == b and b != num:\n\t\t\treturn make_number(b,backup_chars)\n\t\telse:\n\t\t\treturn num\n\n\telse:\n\t\treturn make_number(b,backup_chars)\n\na,b = str(input()), str(input())\nchars = [i for i in a]\nchars.sort()\n\nif len(a) < len(b):\n\tprint(\"\".join(chars[::-1]))\nelse:\n\tprint(find_number(b,chars))","output":"cubic"},{"instruction":"from sys import stdin, stdout, exit\n\nn = int(input())\na = list(map(int, stdin.readline().split()))\n\ndef z(winner):\n    return 'sjfnb' if winner == 0 else 'cslnb'\n\na.sort()\ndups = set(a)\nif len(dups) < len(a) - 1:\n    print(z(1))\n    exit()\n\nwinner = 0\nfor i in range(n-1):\n    if a[i] == a[i+1]:\n        if a[i] == 0 or a[i]-1 in a:\n            print(z(1))\n            exit()\n        winner = 1\n        a[i] = a[i] - 1\n\ns = sum(a)\nfinal = n*(n-1) \/\/ 2\nwinner += (s - final) + 1\nwinner %= 2\nprint(z(winner))","output":"nlogn"},{"instruction":"k=int(input(\"\"))\nt=0\nif k==0:\n    print(\"Invalid input\")\n    exit()\nd=0\ne=0\nn=5\nwhile(1):\n    u=9*n*(10**n)+1-(10**n)-9*k\n    if u>0:\n        d+=1\n        if e>0:\n            u=i\n            break\n        n=n-1\n    elif u<0:\n        i=u\n        e+=1\n        if d>0:\n            n=n+1\n            break\n        n=n+1\n    else:\n        print(9)\n        exit()\nimport math\nu=abs(u)\nu=u\/\/9\nm=u\/\/n\np=u%(n)\nif p==0:\n    q=10**(n-1)+m-1\n    o=q%10\nelse:\n    q = 10**(n-1) + m\n    o=((q\/\/(10**(n-p)))%10)\nprint(o)","output":"logn"},{"instruction":"def solution(n, k, arr):\n    ret = []\n    grp = [None for _ in range(256)]\n    for i in arr:\n        if grp[i]:\n            continue\n        l = None\n        j = 1\n        for j in range(1, k):\n            if i - j < 0:\n                break\n            if grp[i - j] is not None:\n                l = i - j\n                break\n        if l is not None and grp[l] > i - k:\n            grp[i] = grp[l]\n        else:\n            ll = l + 1 if l else max(0, i - k + 1)\n            for j in range(ll, i + 1):\n                grp[j] = ll\n    for i in arr:\n        ret.append(grp[i])\n    return ret\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nprint(' '.join(map(str, solution(n, k, arr))))","output":"quadratic"},{"instruction":"import io\nimport os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn = int(input())\n\nendpoints = []\n\nfor x in range(n):\n    p, w = map(int, input().split())\n    endpoints.append([p-w, p+w])\n\nendpoints.sort(key=lambda sublist: sublist[1])\n\nres = 0\n\nbottom = 10**18 * -1\n\nfor pt in range(len(endpoints)):\n    if endpoints[pt][0] >= bottom:\n        res += 1\n        bottom = endpoints[pt][1]\n\nprint(res)","output":"nlogn"},{"instruction":"import sys,os,io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom sys import stdin\n\nimport math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef si():\n    return input()\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nt = int(input())\nfor _ in range(t):\n    n = ii()\n    l = li()\n    l1 = l[:]\n    arr = defaultdict(lambda:0)\n    for i in l:\n        arr[i]+=1\n    l = []\n    graterthan4 = 0\n    isgraterthan4 = False\n    for i in list(arr.keys()):\n        if (arr[i]>=4):\n            isgraterthan4 = True\n            graterthan4 = i\n        if (arr[i]>=2):\n            l.append(i)\n    n = len(l)\n    l.sort()\n    m = 1000000000000\n    mi = []\n\n    for i in range(n-1):\n        a = l[i]\n        b = l[i+1]\n\n        if (a\/b+b\/a<m):\n            m = a\/b+b\/a\n\n            mi = [a,b]\n    if (isgraterthan4==True):\n        print(graterthan4,graterthan4,graterthan4,graterthan4)\n    else:\n        a,b = mi\n        print(a,a,b,b)","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\nprint((s + n - 1) \/\/ n)","output":"constant"},{"instruction":"import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {}\nfor idx, ptn in enumerate(p):\n    val = 0\n    for i in range(k):\n        if ptn[i] != \"_\":val += (ord(ptn[i]) - 96) * (27 ** i)\n    memo[val] = idx\n\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\n\ngraph = [[] for i in range(n)]\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:\n        print(\"NO\")\n        exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")","output":"np"},{"instruction":"xs = [int(x) for x in input().split()]\n\nres = 0\nfor i in range(14):\n    newxs = xs[:]\n    newxs[i] = 0\n    for j in range(14):\n        newxs[j] += xs[i] \/\/ 14\n\n    for j in range(xs[i] % 14):\n        newxs[(i + 1 + j) % 14] += 1\n\n    res = max(res, sum(val for val in newxs if val % 2 == 0))\n\nprint(res)","output":"constant"},{"instruction":"import sys\n\nmaxN = 10**6 + 5\ndp = [0] * maxN\nb = [0] * maxN\n\nN = int(sys.stdin.readline())\nfor _ in range(N):\n    beacon = [int(x) for x in sys.stdin.readline().split()]\n    b[beacon[0]] = beacon[1]\n\nif b[0] > 0:\n    dp[0] = 1\n\nfor i in range(1, maxN):\n    if b[i] == 0:\n        dp[i] = dp[i-1]\n    else:\n        if b[i] >= i:\n            dp[i] = 1\n        else:\n            dp[i] = dp[i-b[i]-1]+1\nprint(N-max(dp))","output":"linear"},{"instruction":"q = int(input())\nb = []\nfor m in range(q):\n    n, k = map(int, input().split())\n    l = input()\n    k1 = 'R'\n    k2 = 'G'\n    k3 = 'B'\n    for i in range(1, k):\n        if k1[i - 1] == 'R':\n            k1 = k1 + 'G'\n        if k1[i - 1] == 'G':\n            k1 = k1 + 'B'\n        if k1[i - 1] == 'B':\n            k1 = k1 + 'R'\n        if k2[i - 1] == 'R':\n            k2 = k2 + 'G'\n        if k2[i - 1] == 'G':\n            k2 = k2 + 'B'\n        if k2[i - 1] == 'B':\n            k2 = k2 + 'R'\n        if k3[i - 1] == 'R':\n            k3 = k3 + 'G'\n        if k3[i - 1] == 'G':\n            k3 = k3 + 'B'\n        if k3[i - 1] == 'B':\n            k3 = k3 + 'R'\n    minn = n\n\n    for i in range(n - k + 1):\n        tec = 0\n        for j in range(k):\n            if l[i + j] != k1[j]:\n                tec += 1\n        if tec < minn: minn = tec\n    for i in range(n - k + 1):\n        tec = 0\n        for j in range(k):\n            if l[i + j] != k2[j]:\n                tec += 1\n        if tec < minn: minn = tec\n    for i in range(n - k + 1):\n        tec = 0\n        for j in range(k):\n            if l[i + j] != k3[j]:\n                tec += 1\n\n        if tec < minn: minn = tec\n    b.append(minn)\nfor i in range(q):\n    print(b[i])","output":"quadratic"},{"instruction":"def bin_ser(arr,curr):\n    l=0\n    r=len(arr)-1\n    ans=-1\n    while l<=r:\n        mid=(l+r)\/\/2\n        if arr[mid]<=curr:\n            ans=mid\n            l=mid+1\n        else:\n            r=mid-1\n    return ans\n\ndef main():\n    n,q=map(int,input().split())\n    arr=list(map(int,input().split()))\n    brr=list(map(int,input().split()))\n    su=sum(arr)\n    curr=0\n    for i in range(1,n):\n        arr[i]=arr[i]+arr[i-1]\n    for b in brr:\n        curr+=b\n        pos=n-bin_ser(arr,curr)-1\n        if pos==0:\n            pos=n\n        print(pos)\n        if curr>=su:\n            curr=0\n\nmain()","output":"nlogn"},{"instruction":"import sys\nsys.setrecursionlimit(10**5+1)\n\ninf     =  int(10 ** 20)\nmax_val =  inf\nmin_val = -inf\n\nRW  = lambda : sys.stdin.readline().strip()\nRI  = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\nn, k = map(int, input().split())\n\nprint(int((2*n+3-(8*n+8*k+9)**(1\/2))\/\/2))","output":"logn"},{"instruction":"n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na = sorted(a)\n\ncur_v = a[0]\ncur_count = 1\nans = 0\n\nfor i in range(1, len(a)):\n\n    if a[i] > a[i-1] and a[i] > a[i-1]+k:\n        ans += cur_count\n        cur_count = 1\n    elif a[i] == a[i-1]:\n        cur_count += 1\n    elif a[i] > a[i-1]:\n        cur_count = 1\n\nans += cur_count\n\nprint(ans)","output":"nlogn"},{"instruction":"def power(x,y,p):\n    res=1\n    x=x%p\n    if(x==0):\n        return 0\n    while(y>0):\n        if(y&1):\n            res=(res*x)%p\n        y=y>>1\n        x=(x*x)%p\n    return res\n\nx,k=map(int,input().split())\np=1000000007\nif(x==0):\n    print(\"0\")\nelse:\n    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p\n\n    print(t)","output":"logn"},{"instruction":"t = int(input())\n\ndef sol(n, k):\n    p = 1\n    acc = 0\n    while n > 0 and k >= p:\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += (2*p-1)*(4**n-1)\/\/3\n        if k <= acc:\n            return n\n        p = 2*p+1\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)","output":"logn"},{"instruction":"from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))\n\nfor i in range(n - 1):\n    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))","output":"quadratic"},{"instruction":"k = int(input())\n\nnc = [0 for i in range(14)]\n\nfor i in range(1, 14):\n    nc[i] += nc[i - 1] + 9 * (10 ** (i - 1)) * i\n\nfor i in range(13):\n    if nc[i] < k <= nc[i + 1]:\n        cif = i + 1\n\nif cif == 1:\n    print(k)\n    quit()\n\nc = k - nc[cif - 1]\n\nif c % cif == 0:\n    nnr = c \/\/ cif\n    ncif = cif\nelse:\n    nnr = 1 + c \/\/ cif\n    ncif = c % cif\n\nnumber = nnr + 10 ** (cif - 1) - 1\n\nwhile cif != ncif:\n    number \/\/= 10\n    cif -= 1\n\nprint(number % 10)","output":"logn"},{"instruction":"from sys import stdin, stdout\n\nget_string = lambda: stdin.readline().strip('\\n')\nget_intmap = lambda: map( int, get_string().split(' ') )\n\ndef testcase():\n    n = int(input())\n    cnt = dict()\n    for i in range(n):\n        l,r = get_intmap()\n        cnt[l] = cnt.get(l,0) + 1\n        cnt[r+1] = cnt.get(r+1,0) - 1\n    ans = [0] * (n + 1)\n    sk = sorted(cnt.keys())\n\n    cnt_i = 0\n    for ind, i in enumerate(sk[:-1]):\n        cnt_i += cnt[i]\n        ans[cnt_i] += sk[ind + 1] - i\n    print(' '.join([str(i) for i in ans[1:]]))\n\ntestcase();quit()\nfor t in range(int(input())):\n    testcase()","output":"nlogn"},{"instruction":"from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst = lambda: list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    a=sorted([lst() for _ in range(n)],key=lambda x:(-x[0],x[1]))\n    p,t=-1,-1;ans=0\n    if k<=n:p,t=a[k-1]\n    for x,y in a:\n        if x==p and y==t:ans+=1\n    print(ans)","output":"nlogn"},{"instruction":"import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\ndef check(s, a, b, after):\n    ns, na, nb = len(s), len(a), len(b)\n    if ns < na + nb:\n        return False\n\n    dp = [[0 for _ in range(nb+1)] for _ in range(na+1)]\n    for i in range(na+1):\n        for j in range(nb+1):\n            if i == 0 and j == 0:\n                continue\n            dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1\n\n    return dp[na][nb] <= ns\n\ndef solve(s, t):\n    ns = len(s)\n    after = [[ns for _ in range(26)] for _ in range(ns+2)]\n    for i in range(ns-1, -1, -1):\n        for j in range(26):\n            after[i][j] = after[i+1][j]\n        after[i][s[i]] = i\n\n    for i in range(len(t)):\n        a, b = t[:i], t[i:]\n        if check(s, a, b, after):\n            return 'YES'\n\n    return 'NO'\n\nT = int(input())\nans = []\nfor i in range(T):\n    s = input()\n    t = input()\n    s = [ord(v) - ord('a') for v in s]\n    t = [ord(v) - ord('a') for v in t]\n    ans.append(solve(s, t))\n\nprint('\\n'.join(ans))","output":"cubic"},{"instruction":"entrada = input().split()\n\nl = int(entrada[0])\nr = int(entrada[1])\n\npop = l ^ r\nresult = 1\n\nwhile (result <= pop):\n    result = result << 1\n\nprint(result - 1)","output":"logn"},{"instruction":"t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort(reverse=True)\n    print(min(arr[1] - 1, len(arr) - 2))","output":"nlogn"},{"instruction":"n = int(input())\ns = input()\nt = 0\nfor i in s:\n    if i == '+':\n        t += 1\n    else:\n        t = max(t - 1, 0)\n\nprint(max(t, 0))","output":"linear"},{"instruction":"def main():\n    nNodes = int(input())\n    neighborsOf = {node: [] for node in map(str, range(1, nNodes+1))}\n    threeNeighborNodeExists, threeNeighborNode = False, None\n    for i in range(1, nNodes):\n        node1, node2 = input().split()\n        neighborsOf[node1].append(node2), neighborsOf[node2].append(node1)\n        if len(neighborsOf[node1]) == 3:\n            if threeNeighborNodeExists:\n                return 'No'\n            threeNeighborNodeExists, threeNeighborNode = True, node1\n        elif len(neighborsOf[node2]) == 3:\n            if threeNeighborNodeExists:\n                return 'No'\n            threeNeighborNodeExists, threeNeighborNode = True, node2\n\n    if threeNeighborNodeExists:\n        return tnnDecompositionFrom(neighborsOf, threeNeighborNode+' ')\n\n    return decompositionFrom(neighborsOf)\n\ndef tnnDecompositionFrom(tree, threeNeighborNode):\n    paths = tuple(threeNeighborNode + node for node in tree if len(tree[node]) == 1)\n    return f'Yes\\n{len(paths)}\\n' + '\\n'.join(paths)\n\ndef decompositionFrom(tree):\n    return 'Yes\\n1\\n' + ' '.join(node for node in tree if len(tree[node]) == 1)\n\nif __name__ == '__main__':\n    print(main())","output":"linear"},{"instruction":"import math as m\n\nnDiscs, r = [int(x) for x in input().split()]\n\nx = [int(x) for x in input().split()]\ny = []\n\nfor i in range(len(x)):\n    tempY = [r]\n    for j in range(i):\n        diffX = abs(x[i] - x[j])\n        if diffX <= (2 * r):\n            addY = m.sqrt((4 * r * r) - (diffX * diffX))\n            tempY.append(y[j] + addY)\n    y.append(max(tempY))\n\nfor i in range(len(y)):\n    print(y[i], end=' ')\nprint()","output":"quadratic"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[-1] == 1: ans = a[:-1] + [2]\nelse: ans = [1] + a[:-1]\nprint(*ans)","output":"nlogn"},{"instruction":"f, d, s = [int(i) for i in input().split()]\nfilters = [int(i) for i in input().split()]\nfilters.sort(reverse=True)\n\nfreeSockets = s\nusedFilters = 0\nfor i in range(len(filters)):\n    if freeSockets >= d:\n        break\n    usedFilters += 1\n    freeSockets += filters[i]-1\n\nif freeSockets >= d:\n    print(usedFilters)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"import os\n\nimport string\n\nfrom math import inf\nfrom functools import lru_cache\n\nif os.getcwd() == 'C:\\\\Users\\\\User\\\\Desktop\\\\python\\\\Prog\\\\CodeForces' \\\n        or os.environ['COMPUTERNAME'] == 'RYZEN':\n    import pdb\n\n    import sys\n\n    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    from pprint import pprint\n    from hypothesis import given, settings\n    from hypothesis import strategies as st\n\ndef ri():\n    return [int(i) for i in input().split()]\n\nMOD = int(1e9 + 7)\n\ndef main():\n    n, t = ri()\n    songs = []\n    result = 0\n    for i in range(n):\n        songs.append(ri())\n        songs[-1][1] -= 1\n\n    dp = [[0, 0, 0] for i in range(1 << n)]\n\n    for ind, it in enumerate(songs):\n        dp[1 << ind][it[1]] = 1\n\n    for mask in range(1, 1 << n):\n        for genre in range(3):\n            for nsng, sng in enumerate(songs):\n                if sng[1] != genre and ((mask >> nsng) & 1) == 0:\n                    dp[mask | (1 << nsng)][sng[1]] += dp[mask][genre]\n                    if (mask | (1 << nsng)) == 4:\n                        asdddd = 1\n\n            sm = 0\n            for ind, it in enumerate(reversed(bin(mask)[2:])):\n                if it == '1':\n                    sm += songs[ind][0]\n            if sm == t:\n                result += dp[mask][genre]\n                result %= MOD\n\n    print(result)\n\nmain()","output":"np"},{"instruction":"n = int(input())\nk = n \/\/ 3\nans = []\nfor i in range(k):\n    ans += [(0, 2 * i)]\n    ans += [(1, 2 * i + 1)]\n    ans += [(2, 2 * i)]\nfor i in range(n % 3):\n    ans += [(-1000, -1000 + i)]\nres = \"\"\nfor i in ans:\n    res += \" \".join(map(str, i)) + \"\\n\"\nprint(res)","output":"linear"},{"instruction":"from itertools import combinations\nnum,min_dif,max_dif,easy_hard_dif=map(int, input().split(\" \"))\narr=[int(m) for m in input().split(\" \")]\nall_combinations=[]\nfor x in range(2, num+1):\n    combs=combinations(arr, x)\n    for abc in combs:\n        all_combinations.append(list(abc))\npossible_answers=0\nfor a in all_combinations:\n    if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif:\n        possible_answers+=1\nprint(possible_answers)","output":"np"},{"instruction":"from sys import stdin, stdout\n\ndef dfs(l, r, dp, a_a):\n    if l == r:\n        return a_a[l]\n    if l+1 == r:\n        if a_a[l] == a_a[r]:\n            return a_a[l] + 1\n        else:\n            return -1\n\n    if dp[l][r] != 10**6:\n        return dp[l][r]\n\n    dp[l][r] = -1\n    for m in range(l, r):\n        r1 = dfs(l, m, dp, a_a)\n        r2 = dfs(m+1, r, dp, a_a)\n        if r1 > 0 and r1 == r2:\n            dp[l][r] = r1 + 1\n            return dp[l][r]\n\n    return dp[l][r]\n\ndef array_shrinking(n, a_a):\n    dp = [[10**6 for _ in range(n)]  for _ in range(n)]\n    dp2 = [10**6 for _ in range(n)]\n    for i in range(n):\n        dp2[i] = min(i + 1, dp2[i])\n        for j in range(i, n):\n            r = dfs(i, j, dp, a_a)\n            if r != -1:\n                if i > 0:\n                    dp2[j] = min(dp2[i-1] + 1, dp2[j])\n                else:\n                    dp2[j] = min(1, dp2[j])\n\n    return dp2[n-1]\n\nn = int(stdin.readline())\na_a = list(map(int, stdin.readline().split()))\nres = array_shrinking(n, a_a)\nstdout.write(str(res))","output":"cubic"},{"instruction":"import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport sys\nimport string\nimport random\nfrom typing import List\nsys.setrecursionlimit(99999)\n\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\ncs = collections.Counter(arr)\nks = list(cs.keys())\nks.sort()\nans= 0\nfor i in range(1,len(ks)):\n    if ks[i]<=ks[i-1]+k:\n        continue\n    else:\n        ans+=cs[ks[i-1]]\nans+= cs[ks[-1]]\nprint(ans)","output":"nlogn"},{"instruction":"from math import ceil\n\ndef solve(n, k):\n\tif k == 1:\n\t\treturn n - 1\n\tif k == 2:\n\t\tif n > 1:\n\t\t\treturn n - 1\n\t\telse:\n\t\t\treturn -1\n\tif k == 3:\n\t\tif n > 2:\n\t\t\treturn n - 1\n\t\telse:\n\t\t\treturn -1\n\tif k in {4, 5}:\n\t\tif n > 1:\n\t\t\treturn n - 2\n\t\telse:\n\t\t\treturn -1\n\n\tif 2 * n + 1 <= len(bin(3 * k)[2:]):\n\t\treturn -1\n\telse:\n\t\treturn n - ceil((len(bin(3 * k)[2:]) - 1) \/ 2)\n\nfor i in range(int(input())):\n\tn, k = map(int, input().split())\n\ta = solve(n, k)\n\tif a == -1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES', a)","output":"logn"},{"instruction":"a = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\na,b,c= sorted([a,b,c])\n\npath = []\nfor i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):\n    path.append((b[0],i))\nfor i in range(a[0],b[0]+1):\n    path.append((i,a[1]))\nfor i in range(b[0],c[0]+1):\n    path.append((i,c[1]))\n\nprint(len(set(path)))\nfor i in set(path):\n    print(*i)","output":"constant"},{"instruction":"from math import gcd\nn, x, y = map(int, input().split())\n\ndef solve(n, x, y):\n    g = gcd(x, y)\n    if gcd(x, y) != 1:\n        return solve(n \/\/ g + 1, x \/\/ g, y \/\/ g) * (n % g) + solve(n \/\/ g, x \/\/ g, y \/\/ g) * (g - n % g)\n    ans = 0\n    for s in [0, 1]:\n        dp = [-n, -n]\n        dp[s] = 0\n        for i in range(x + y):\n            dp = [max(dp[0], dp[1]), dp[0] + (n \/\/ (x + y)) + (i * x % (x + y) < n % (x + y))]\n        ans = max(ans, dp[s])\n    return ans\n\nprint(solve(n, x, y))","output":"np"},{"instruction":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M, K = map(int, input().split())\nif K % 2:\n    for _ in range(N):\n        print(*[-1] * M)\n    exit()\nA = [[int(a) for a in input().split()] for _ in range(N)]\nB = [[int(a) for a in input().split()] for _ in range(N - 1)]\nX = [[0] * M for _ in range(N)]\ninf = 1 << 30\nfor k in range(1, K \/\/ 2 + 1):\n    nX = [[inf] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i: nX[i][j] = min(nX[i][j], X[i - 1][j] + B[i - 1][j])\n            if i < N - 1: nX[i][j] = min(nX[i][j], X[i + 1][j] + B[i][j])\n            if j: nX[i][j] = min(nX[i][j], X[i][j - 1] + A[i][j - 1])\n            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j + 1] + A[i][j])\n    X = nX\nfor x in X:\n    print(*[a * 2 for a in x])","output":"cubic"},{"instruction":"n = int(input())\nt = [0 for i in range(2000)]\nc = [0 for i in range(2000)]\nfor i in range(n) :\n    x = int(input())\n    r = 0\n    ok = False\n    for j in range(2000) :\n        if x >> j & 1 :\n            if t[j] != 0 :\n                x ^= t[j]\n                r ^= c[j]\n            else :\n                t[j] = x\n                c[j] = r ^ (1 << i)\n                ok = True\n                break\n    if ok :\n        print(0)\n        continue\n    a = []\n    for j in range(2000) :\n        if r >> j & 1 :\n            a.append(j)\n    print(len(a))\n    for y in a :\n        print(y)","output":"np"},{"instruction":"n = int(input())\nprint(2*(n**2)-2*n+1)","output":"constant"},{"instruction":"a,b,c,n=map(int, input().split())\np=n-(a+b-c)\nif c>a or c>b or p<=0:\n    print(-1)\n    exit()\nif p<1:\n    print(-1)\nelse:\n    print(p)","output":"constant"},{"instruction":"from collections import deque\nn, q = map(int, input().split())\na = deque(map(int, input().split()))\nb = []\nm = a.index(max(a))\nfor i in range(m):\n    a0, a1 = a.popleft(), a.popleft()\n    b.append([a0, a1])\n    if a0 < a1:\n        a0, a1 = a1, a0\n    a.appendleft(a0)\n    a.append(a1)\nfor i in range(q):\n    c = int(input())\n    if c <= m:\n        print('{} {}'.format(b[c-1][0], b[c-1][1]))\n    else:\n        c -= m+1\n        c %= n-1\n        print('{} {}'.format(a[0], a[c+1]))","output":"linear"},{"instruction":"import sys\n\nn,m=map(int,sys.stdin.readline().split())\nX=[int(sys.stdin.readline()) for i in range(n)]\nY=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\nZ=[]\n\nANS=0\nfor y in Y:\n    if y[0]==1 and y[1]==10**9:\n        ANS+=1\n    elif y[0]==1:\n        Z.append(y[1])\nX.sort(reverse=True)\nZ.sort(reverse=True)\n\nXCOUNT=[0]*n\n\ni=0\nj=0\nl=len(Z)\nX.append(0)\nZ.append(0)\nwhile i<l+1 and j<n:\n    if Z[i]>=X[j]:\n        i+=1\n    else:\n        XCOUNT[j]=i\n        j+=1\n\ncount=n\nXCOUNT.reverse()\nfor i in range(n):\n    if count>i+XCOUNT[i]:\n        count=i+XCOUNT[i]\n\nprint(count+ANS)","output":"nlogn"},{"instruction":"line = input().split()\nn, k = int(line[0]), int(line[1])\nline = input()\nif n == k:\n    print(line)\n\nelse:\n    ans = []\n    arr = []\n    for i in line:\n        arr.append(i)\n\n    for i in range(n):\n        if len(ans) == k\/\/2:\n            break\n        if arr[i] == '(':\n            ans.append(i)\n    for i in range(n-1, -1, -1):\n        if len(ans) == k:\n            break\n        if arr[i] == ')':\n            ans.append(i)\n    ans.sort()\n    for i in ans:\n        print(arr[i], end=\"\")","output":"linear"},{"instruction":"from sys import stdin,stdout\nstdout.flush()\ndef qu(a,b):\n    print(\"?\",a,b)\n    return int(input())\na=0\nb=0\nbig=qu(a,b)\nfor i in range(29,-1,-1):\n    x=2**i\n    f=qu(a+x,b)\n    l=qu(a,b+x)\n    if l==f:\n        if big==1:\n            a+=x\n        else:\n            b+=x\n        big=f\n    elif f==-1:\n        a+=x\n        b+=x\nprint(\"!\",a,b)","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict\n\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(1+(~node))\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack.extend(graph[node])\n\n    for node in res:\n        node-=1\n        if any(found[nei] for nei in graph[node]):\n            print(\"NO\")\n            return\n        found[node] = 0\n\n    print(\"YES\")\n    print(*res[::-1])\n\nn,m,k=map(int,input().split())\npatterns=set()\npos=dict()\n\nfor i in range(n):\n    p=input().rstrip()\n    patterns.add(p)\n    pos[p]=i\n\nmatches=[[] for _ in range(n)]\n\nchk=True\nfor i in range(m):\n    s,mt=input().rstrip().split()\n    mt=int(mt)-1\n    if(chk):\n        chk=False\n        for i in range(1<<k):\n            tmp=[]\n            for j in range(k):\n                if(i&(1<<j)):\n                    tmp.append('_')\n                else:\n                    tmp.append(s[j])\n            tmp=''.join(tmp)\n            if(tmp in patterns):\n                if(mt==pos[tmp]):\n                    chk=True\n                else:\n                    matches[mt].append(pos[tmp])\n\nif(not chk):\n    print(\"NO\")\nelse:\n    toposort(matches)","output":"np"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j] = 0\n\nfor k1 in range(1, k \/\/ 2 + 1):\n    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],\n                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])\n\n    mem = mem0\n\n[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]","output":"cubic"},{"instruction":"import sys\nif locals()['__file__'][-2:] == 'py':\n    sys.stdin = open('in.txt', 'r')\nn = int(input())\na = []\nfor i in range(1, n + 1):\n    l, r = map(int, input().split())\n    a.append([l, -r, i])\na.sort()\nma = a[0][1]\nnma = a[0][2]\nfor i in range(1, n):\n    if a[i][1] >= ma:\n        print(a[i][2], nma)\n        exit()\n    else:\n        ma = a[i][1]\n        nma = a[i][2]\nprint(-1, -1)","output":"nlogn"},{"instruction":"l, r, k =map(int,input().split())\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\nprint((call(r, k) - call(l-1, k)) % 998244353)","output":"cubic"},{"instruction":"l,r = list(map(int,input().split()))\nf = 0\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\nfor a in range(l,r+1):\n    for b in range(a+1,r+1):\n        for c in range(b+1,r+1):\n\n           if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1):\n                print(a,b,c)\n                f = 1\n                break\n        if f == 1:\n            break\n    if f == 1:\n        break\nelse:\n    print(-1)","output":"constant"},{"instruction":"n = int(input())\nboard = list(map(int,input().split(\" \")))\nindex = list(range(0,n))\nascending = [x for _,x in sorted(zip(board,index))]\n\nwinners = n * [\"\"]\n\nfor c in reversed(ascending):\n\tif board[c] == n:\n\t\twinners[c] = \"B\"\n\n\ttoCheck = c - board[c]\n\twhile(toCheck >= 0):\n\t\tif winners[toCheck] == \"B\":\n\t\t\twinners[c] = \"A\"\n\t\ttoCheck = toCheck - board[c]\n\tif winners[c] == \"\":\n\t\ttoCheck = c + board[c]\n\t\twhile(toCheck < n):\n\t\t\tif winners[toCheck] == \"B\":\n\t\t\t\twinners[c] = \"A\"\n\t\t\ttoCheck = toCheck + board[c]\n\tif winners[c] == \"\":\n\t\twinners[c] = \"B\"\n\nfor i in range(n):\n\tprint(winners[i],end=\"\")\nprint()","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\ncnt = 0\nfor i in range(n, 0, -1):\n    cnt += s \/\/ i\n    s %= i\nprint(cnt)","output":"linear"},{"instruction":"a=int(input())\nb=int(input())\nx=[0]*10\nwhile a:\n    x[a%10]+=1\n    a=a\/\/10\nans=0\nfor i in range(9,-1,-1):\n    for j in range(x[i]):\n        ans=ans*10+i\nif ans<=b:\n    print(ans)\nelse:\n    ans=0\n    for j in str(b):\n        c=int(j)\n        while c>=0 and not x[c]:\n            c-=1\n        if c<0:\n            while True:\n                x[ans%10]+=1\n                d=ans%10\n                ans=ans\/\/10\n                flag=0\n                for b in range(d-1,-1,-1):\n\n                    if x[b]:\n                        ans=ans*10+b\n                        x[b]-=1\n                        flag=1\n                        break\n                if flag:\n                    break\n            break\n\n        else:\n            x[c]-=1\n            ans=ans*10+c\n            if c<int(j):\n                break\n\n    for j in range(9,-1,-1):\n        for i in range(x[j]):\n            ans=ans*10+j\n    print(ans)","output":"cubic"},{"instruction":"n = int(input())\ns = input()\nb = 0\nfor i in s:\n    if i == '+':\n        b += 1\n    else:\n        b -= 1\n        b = max(b, 0)\nprint(b)","output":"linear"},{"instruction":"S = [str(input()) for i in range(2)]\nS[0] = S[0].replace('X','1')\nS[1] = S[1].replace('X','1')\n\nn = len(S[0])\nif n == 1:\n    print(0)\n    exit()\n\nINF = 10**18\nfrom collections import defaultdict\ndp = defaultdict(lambda: -INF)\nfor i in range(0, 2):\n    for j in range(0, 2):\n        dp[(i, j)] = -INF\ndp[(int(S[0][0]), int(S[1][0]))] = 0\n\nfor i in range(1, n):\n    nx = defaultdict(lambda: -INF)\n    for j in range(0, 2):\n        for k in range(0, 2):\n            nx[(int(S[0][i]), int(S[1][i]))] = max(nx[(int(S[0][i]), int(S[1][i]))], dp[(j, k)])\n    for j in range(0, 2):\n        for k in range(0, 2):\n            if dp[(j, k)] == -INF:\n                continue\n            if j == 0 and k == 0:\n                if S[0][i] == '1' and S[1][i] != '1':\n                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)\n                if S[0][i] != '1' and S[1][i] == '1':\n                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)\n                if S[0][i] != '1' and S[1][i] != '1':\n                    nx[(1, 0)] = max(nx[(1, 0)], dp[(j, k)]+1)\n                    nx[(0, 1)] = max(nx[(0, 1)], dp[(j, k)]+1)\n                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)\n            if j == 0 and k == 1:\n                if S[0][i] != '1' and S[1][i] != '1':\n                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)\n            if j == 1 and k == 0:\n                if S[0][i] != '1' and S[1][i] != '1':\n                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)\n    dp = nx\nans = -INF\nfor k, v in dp.items():\n    ans = max(ans, v)\nprint(ans)","output":"constant"},{"instruction":"n = int(input())\nl = [*map(int, input().split())]\n\np = [0] * n\nfor i in range(n): p[l[i] - 1] = i\n\nres = ['?'] * n\n\nfor e in range(n, 0, -1):\n    i = p[e - 1]\n    res[i] = 'B'\n    for j in range(i % e, n, e):\n        if i != j and l[i] <= l[j] and res[j] == 'B':\n            res[i] = 'A'\n            break\nprint(''.join(res))","output":"quadratic"},{"instruction":"n = int(input())\nai = list(map(int,input().split()))\nai.sort()\nnum = 0\nnum2 = 0\nfor i in range(1,n):\n    if ai[i-1] == ai[i]:\n        num += 1\n        num2 = i\nif num == 0:\n    num3 = sum(ai)\n    num4 = n * (n-1) \/\/ 2\n    ans = (num3 - num4) % 2\n    if ans == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\nelif num == 1:\n    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:\n        print(\"cslnb\")\n    else:\n        num3 = sum(ai)\n        num4 = n * (n-1) \/\/ 2\n        ans = (num3 - num4) % 2\n        if ans == 1:\n            print(\"sjfnb\")\n        else:\n            print(\"cslnb\")\nelse:\n    print(\"cslnb\")","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\n\nstrr = \"\"\nwhile len(strr) < n:\n    strr += \"0\" * ((n-k) \/\/ 2) + \"1\"\nstrr = strr[:n]\nprint(strr)","output":"linear"},{"instruction":"n,m=input().split()\ni=j=-1\nwhile(j<0):\n    mat=input()\n    j=mat.find('B')\n    i+=1\n    c=mat.count('B')\/\/2+1\nprint(i+c,j+c)","output":"quadratic"},{"instruction":"from os import path\nimport sys,time\n\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import *\n\nmaxx = float('inf')\n\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().replace('\\n', '').strip()\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n\nn , k = tup()\ns , i = S() , 1\nwhile s[i:] != s[:-i] :i+=1\nprint(s[:i]*k + s[i:])\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"quadratic"},{"instruction":"n = int(input())\na = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)\nfor i in range(2, n+1):\n    a[i] = int(input())\n    b[a[i]] += 1\nfor i in range(1, n+1):\n    if b[i] == 0:\n        c[a[i]] += 1\nfor i in range(1, n+1):\n    if b[i] != 0 and c[i] < 3:\n        print(\"NO\")\n        exit()\nprint(\"YES\")","output":"linear"},{"instruction":"n, m = [int(x) for x in input().split()]\nxs = [int(x) for x in input().split()]\nts = [int(x) for x in input().split()]\n\ntaxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1])\npassenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0])\n\na_is = [0] * len(taxi_idx)\nt_idx = 0\np_idx = 0\n\nwhile True:\n    if p_idx >= len(passenger_idx):\n        break\n\n    if t_idx == len(taxi_idx) - 1:\n        a_is[t_idx] += 1\n    else:\n        while t_idx < len(taxi_idx) - 1:\n            d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx])\n            d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1])\n\n            if d1 > d2:\n                t_idx += 1\n            else:\n                break\n\n        a_is[t_idx] += 1\n\n    p_idx += 1\n\nprint(' '.join([str(x) for x in a_is]))","output":"quadratic"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nfrom collections import defaultdict as dft\n\nn,m,k=map(int,input().split())\ndct={}\nglobal case\ncase=0\niput=[]\nfor i in range(n):\n    word=input()\n    dct[word]=i+1\n    iput.append(word)\nd=[[] for i in range(n+1)]\nsize=[0]*(n+1)\nfor _ in range(m):\n\n    word,idx=input().split()\n    idx=int(idx)\n    temp=1\n    w=iput[idx-1]\n\n    for x in range(k):\n        if w[x]!='_' and w[x]!=word[x]:\n            temp=0\n            print(\"NO\")\n            exit()\n            break\n\n    res=[]\n    for i in range(1<<k):\n        s=\"\".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])\n\n        if s in dct:\n            j=dct[s]\n            if j!=idx:\n                d[idx].append(j)\n                size[j]+=1\n\nst=[nd  for nd in range(1,n+1) if size[nd]==0]\n\nfor i in st:\n\n    for j in d[i]:\n        size[j]-=1\n        if size[j]==0:\n            st.append(j)\n\nif len(st)==n:\n    print(\"YES\")\n    print(*st)\nelse:\n    print(\"NO\")","output":"np"},{"instruction":"n = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit()\n\nA = [None]*n\n\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n\ndef is_colinear(a1,a2,a3):\n    if a1 == a2 or a2 == a3 or a1 == a3:\n        return True\n\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = a3\n\n    if x1 == x2 or x1 == x3 or x2 == x3:\n        return x1 == x2 == x3\n    if y1 == y2 or y1 == y3 or y2 == y3:\n        return y1 == y2 == y3\n    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\nX,Y,Z = A[0],A[1],A[2]\n\ndef good(X,Y):\n\n    bad = []\n    for i in range(n):\n        if not is_colinear(X,Y,A[i]):\n            bad.append(A[i])\n\n    if len(bad) <= 2:\n        return True\n\n    U,V = bad[0],bad[1]\n    for i in range(len(bad)):\n        if not is_colinear(U,V,bad[i]):\n            return False\n    return True\n\nif good(X,Y) or good(Y,Z) or good(X,Z):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")\nexit()","output":"nlogn"},{"instruction":"n, k = list(map(int, input().split()))\n\nteams = []\nfor _ in range(n):\n    teams.append(list(map(int, input().split())))\n\nteams.sort(key=lambda x: x[0]*100 - x[1], reverse=True)\n\ncount = 0\n\nkth = teams[k-1][0]*100 + teams[k-1][1]\nfor t in teams:\n    if t[0]*100 + t[1] == kth:\n        count += 1\nprint(count)","output":"nlogn"},{"instruction":"def mergeSort(x):\n\tif len(x) > 1:\n\n\t\tmid = len(x)\/\/2\n\n\t\tL = x[:mid]\n\t\tR = x[mid:]\n\n\t\tmergeSort(L)\n\t\tmergeSort(R)\n\n\t\ti = j = k = 0\n\n\t\twhile i < len(L) and j < len(R):\n\t\t\tif L[i] > R[j]:\n\t\t\t\tx[k] = L[i]\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\tx[k] = R[j]\n\t\t\t\tj += 1\n\t\t\tk += 1\n\n\t\twhile i < len(L):\n\t\t\tx[k] = L[i]\n\t\t\ti += 1\n\t\t\tk += 1\n\n\t\twhile j < len(R):\n\t\t\tx[k] = R[j]\n\t\t\tj += 1\n\t\t\tk += 1\n\nn,m = input().split()\nn = int(n)\nm = int(m)\ndifference = []\ntotal = 0\nfor i in range(0,n):\n    a,b = input().split()\n    a = int(a)\n    b = int(b)\n    total += a\n    difference.append(a - b)\n\nmergeSort(difference)\n\nminimum = 0\nidx = 0\nif total <= m:\n    print(\"0\")\nelse:\n    for val in difference:\n        minimum += 1\n        total = total - val\n        if total <= m:\n            break\n\n    if total > m:\n        print(\"-1\")\n    else:\n        print(minimum)","output":"nlogn"},{"instruction":"def make_nCr_mod(max_n=2 * 10 ** 5, mod=10 ** 9 + 7):\n\tmax_n = min(max_n, mod - 1)\n\n\tfact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n\tfact[0] = 1\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n\tdef nCr_mod(n, r):\n\t\tres = 1\n\t\twhile n or r:\n\t\t\ta, b = n % mod, r % mod\n\t\t\tif a < b:\n\t\t\t\treturn 0\n\t\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\t\tn \/\/= mod\n\t\t\tr \/\/= mod\n\t\treturn res\n\n\treturn nCr_mod\n\ndef f():\n\tdp = [0] * (1000 + 100)\n\tdp[1] = 1\n\n\tfor i in range(2, len(dp)):\n\t\to = bin(i).count(\"1\")\n\t\tif o == 1:\n\t\t\tdp[i] = 2\n\t\telse:\n\t\t\tdp[i] += dp[o] + 1\n\treturn dp\n\ndef bit(s, k):\n\tdp = f()\n\tl = []\n\tcomb=make_nCr_mod()\n\tans = 0\n\tll = len(s)\n\tans = 0\n\tones = 0\n\tif k == 0:\n\t\treturn 1\n\tfor i in range(ll):\n\t\tif s[i] == \"0\":\n\t\t\tcontinue\n\t\telse:\n\t\t\tfor j in range(max(ones, 1), 1000):\n\t\t\t\tif dp[j] == k:\n\t\t\t\t\tans = (ans + comb(ll - i - 1, j - ones)) % (10 ** 9 + 7)\n\t\t\t\t\tif i == 0 and k == 1:\n\t\t\t\t\t\tans -= 1\n\t\tones += 1\n\tif dp[ones] == k:\n\t\tans += 1\n\treturn (ans) % (10 ** 9 + 7)\n\ns = input().strip()\nk = int(input())\nprint(bit(s, k))","output":"linear"},{"instruction":"n, pos, l, r=map(int, input().split())\nif l==1 and r==n:\n\tprint(0)\nelif l==1 and r!=n:\n\tprint(abs(pos-r)+1)\nelif l!=1 and r==n:\n\tprint(abs(pos-l)+1)\nelse:\n\tprint(r-l+2+min(abs(pos-l), abs(pos-r)))","output":"constant"},{"instruction":"n,k = map(int,input().split())\nB = [1]*(n+1)\nB[0] = B[1] = 0\nfor i in range(2,n+1):\n    if B[i] == 1:\n        m = 2\n        while m*i <= n:\n            B[m*i] = 0\n            m += 1\nC = []\nD = []\nfor i in range(len(B)):\n    if B[i] != 0:\n        D.append(i)\nfor i in range(1,len(D)):\n    c = D[i] + D[i-1] + 1\n    if c <= n:\n        C.append(c)\nx = 0\nfor i in range(len(C)):\n    if B[C[i]] == 1:\n        x += 1\nif x >= k:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"n = int(input())\na = [0]*n;\n\ndef fun(n,ptr1):\n\tglobal a\n\n\tif n == 1:\n\t\ta[ptr1] = 1;\n\n\telif n == 2:\n\n\t\ta[ptr1] = 1;\n\t\tptr1+=1;\n\t\ta[ptr1] = 2;\n\telif n == 3:\n\t\ta[ptr1] = 1;\n\t\tptr1 +=1;\n\t\ta[ptr1] = 1;\n\t\tptr1+=1;\n\t\ta[ptr1]=3;\n\n\telse:\n\t\titera = n - n\/\/2;\n\n\t\tfor i in range(itera):\n\t\t\ta[ptr1] = 1;\n\t\t\tptr1+=1;\n\n\t\tfun(n\/\/2,ptr1);\n\t\tfor i in range((n\/\/2)):\n\t\t\ta[ptr1] = 2*a[ptr1];\n\t\t\tptr1+=1;\n\nfun(n,0);\nfor i in a:\n\tprint(i,end=\" \");\n\nprint();","output":"linear"},{"instruction":"import sys\nn=int(input())\n\nl=list(map(int,input().split()))\nc=list(map(int,input().split()))\na=[]\nfor i in range(1,n-1):\n    lr=sys.maxsize\n    lc=sys.maxsize\n    for j in range(0,i):\n\n        if l[i]>l[j]:\n            lc=min(lc,c[j])\n\n    for j in range(i+1,n):\n\n        if l[j]>l[i]:\n            lr=min(lr,c[j])\n\n    if lr<sys.maxsize and lc<sys.maxsize:\n        a.append(lr+lc+c[i])\n\nif not a:\n    print(-1)\nelse:\n    print(min(a))","output":"quadratic"},{"instruction":"n = int(input())\n\nif n == 3:\n    print('1 1 3')\n    exit()\nif n == 1:\n    print('1')\n    exit()\nif n == 2:\n    print('1 2')\n    exit()\nd = 2\nans = []\nlfn = n\nwhile d <= n:\n    k = n \/\/ d\n    for j in range(lfn - k):\n        ans.append(d\/\/2)\n    lfn = n - len(ans)\n    d *=2\nd \/\/= 2\nk = n\/d\nif k < 1.5:\n    ans.append(d)\nelse:\n    ans.append(d + d\/\/2)\nprint(' '.join([str(i) for i in ans]))","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nwhile len(a) > 0:\n    k = a.pop(0)\n    a = [i for i in a if i % k != 0]\n    ans += 1\n\nprint(ans)","output":"quadratic"},{"instruction":"from sys import stdin\ninput=stdin.readline\ndef check(mid,a,limit):\n\tres=[]\n\ts=0\n\tfor r,t,id in a:\n\t\tif r>=mid and t+s<=limit:\n\t\t\tres.append(id+1)\n\t\t\ts+=t\n\t\telif t+s>limit:\n\t\t\tbreak\n\t\tif len(res)==mid:\n\t\t\tbreak\n\n\treturn res\n\ndef f(a,limit):\n\ta.sort(key=lambda s:s[1])\n\tans=None\n\tlo=0\n\thi=len(a)+1\n\twhile lo<=hi:\n\t\tmid=(lo+hi)\/\/2\n\t\tres=check(mid,a,limit)\n\t\tif len(res)>=mid:\n\t\t\tlo=mid+1\n\t\t\tans=(res,mid)\n\t\telse:\n\t\t\thi=mid-1\n\tprint(ans[1])\n\tprint(ans[1])\n\tprint(*ans[0])\n\nn,limit=map(int,input().strip().split())\nq=[]\nfor i in range(n):\n\tx,y=map(int,input().strip().split())\n\tq.append((x,y,i))\nf(q,limit)","output":"nlogn"},{"instruction":"def main():\n    n, m, k = [int(v) for v in input().split()]\n    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]\n    for i in range(n):\n        row = [int(v) for v in input().split()]\n        for j in range(m-1):\n            w[i][j+1][2] = row[j]\n            w[i][j][3] = row[j]\n    for i in range(n-1):\n        row = [int(v) for v in input().split()]\n        for j in range(m):\n            w[i][j][1] = row[j]\n            w[i+1][j][0] = row[j]\n    if k % 2 == 1:\n        for i in range(n):\n            for j in range(m):\n                print(-1, end=\" \")\n            print()\n        return\n    else:\n        k \/\/= 2\n    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0] = 0\n    for d in range(1, k+1):\n        for i in range(n):\n            for j in range(m):\n                for di, (dx, dy) in enumerate(dxy):\n                    ii = i + dx\n                    jj = j + dy\n                    if 0 <= ii < n and 0 <= jj < m:\n                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k] * 2, end=\" \")\n        print()\n\nmain()","output":"cubic"},{"instruction":"n, m, k = map(int, input().split())\narr = [int(x) for x in input().split()]\nmodulo = 0\ntmp = 0\nop = 1\ncur = (arr[0] - 1) \/\/ k\nfor i in range(m):\n    if (arr[i] - 1 - modulo) \/\/ k != cur:\n        modulo += tmp\n        cur = (arr[i] - 1 - modulo) \/\/ k\n        tmp = 0\n        op += 1\n    tmp += 1\nprint(op)","output":"linear"},{"instruction":"from collections import defaultdict\n\ndef read_line():\n    return [int(x) for x in input().split()]\n\ndef solve2(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4):\n    def inside(x, y):\n        return 1 <= x <= m and 1 <= y <= n\n\n    def col(a, b):\n        assert inside(a, b)\n        return 'WB'[(a+b)%2]\n\n    d = {}\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            d[(i, j)] = col(i, j)\n    for i in range(x1, x2+1):\n        for j in range(y1, y2+1):\n            d[(i, j)] = 'W'\n    for i in range(x3, x4+1):\n        for j in range(y3, y4+1):\n            d[(i, j)] = 'B'\n    return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B'])\n\ndef rnd_test():\n    from random import randint\n    n = randint(1, 50)\n    m = randint(1, 50)\n    x1, x2, x3, x4 = [randint(1, m) for _ in range(4)]\n    y1, y2, y3, y4 = [randint(1, n) for _ in range(4)]\n    x1, x2 = min(x1, x2), max(x1, x2)\n    y1, y2 = min(y1, y2), max(y1, y2)\n    x3, x4 = min(x3, x4), max(x3, x4)\n    y3, y4 = min(y3, y4), max(y3, y4)\n    assert solve(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4)\n\ndef solve(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4):\n\n    def inside(x, y):\n        return 1 <= x <= m and 1 <= y <= n\n\n    def col(a, b):\n        assert inside(a, b)\n        return 'WB'[(a+b)%2]\n\n    def cols(x1, y1, x2, y2):\n        assert inside(x1, y1) and inside(x2, y2)\n        assert x1 <= x2 and y1 <= y2\n        w, h = x2+1-x1, y2+1-y1\n        if w % 2 == 0 or h % 2 == 0:\n            return w*h \/\/ 2, w*h \/\/ 2\n        else:\n            WH, BL = w*h \/\/ 2, w*h \/\/ 2\n            if col(x1, y1) == 'W':\n                WH += 1\n            else: BL += 1\n            return WH, BL\n\n    def overlap():\n        X1 = max(x1, x3)\n        X2 = min(x2, x4)\n        Y1 = max(y1, y3)\n        Y2 = min(y2, y4)\n        if X1 > X2 or Y1 > Y2: return None\n        return X1, Y1, X2, Y2\n\n    tot_wh, tot_bl = cols(1, 1, m, n)\n\n    A_wh, A_bl = cols(x1, y1, x2, y2)\n    ovrlp = overlap()\n    if ovrlp is not None:\n        O_wh, O_bl = cols(*ovrlp)\n        assert A_wh >= O_wh and A_bl >= O_bl\n        A_wh -= O_wh\n        A_bl -= O_bl\n\n    B_wh, B_bl = cols(x3, y3, x4, y4)\n\n    tot_wh += A_bl\n    tot_bl -= A_bl\n\n    tot_wh -= B_wh\n    tot_bl += B_wh\n    return(tot_wh, tot_bl)\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = read_line()\n    x1, y1, x2, y2 = read_line()\n    x3, y3, x4, y4 = read_line()\n    print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4))","output":"constant"},{"instruction":"a,b,c = map(int,input().split())\narr = list(map(int,input().split()))\n\narr.sort()\np = 0\na-=1\nwhile(a>=0 and c<b):\n    c-=1\n    p+=1\n    c+=arr[a]\n    a-=1\nif(c<b):\n    print(-1)\nelse:\n    print(p)","output":"nlogn"},{"instruction":"a,b = input().split()\nx = int(a)\nk = int(b)\nmod = 10**9 + 7\nif(x == 0 ):\n\tprint(0)\nelif( k == 0):\n\tprint( (2*x)%mod )\nelse:\n\tprint( (((pow(2,k,mod)*x - pow(2,k-1,mod))%mod)*2 + 3*mod + 1)%mod)","output":"logn"},{"instruction":"a = list(map(int, input().split()))\nn = len(a)\nk = [i for i in a]\nlst = []\nfor i in range(n):\n    p = k[i]%n\n    ans = 0\n    a = k[i+1:] + k[:i+1]\n    a[-1] = 0\n    for j in range(n):\n        if (a[j] + 1 + int(k[i]\/\/n))%2 == 0 and j < p:\n            ans += a[j] + 1 + int(k[i]\/\/n)\n        elif (a[j] + int(k[i]\/\/n))%2 == 0 and j >= p:\n            ans += a[j] + int(k[i]\/\/n)\n    lst.append(ans)\n\nprint(max(lst))","output":"constant"},{"instruction":"for i in range (1000) :\n    print(5,end=\"\")\nprint()\nfor i in range (999) :\n    print(4,end=\"\")\nprint(5)","output":"constant"},{"instruction":"from math import ceil\ndef paper(a,b,c,d):\n    return ceil((a*(ceil(b\/c)))\/d)\n\na,b,c,d=map(int,input().strip().split())\nprint(paper(a,b,c,d))","output":"constant"},{"instruction":"def main():\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input()\n        b = []\n        for l in s:\n            b.append(l)\n        a.append(b)\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            may = True\n            if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'):\n                may = False\n            if (may):\n                a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?'\n    for i in range(n):\n        for j in range(m):\n            if (a[i][j] == '\n                print(\"NO\")\n                return\n    print(\"YES\")\nmain()","output":"quadratic"},{"instruction":"from heapq import heappush, heappop\nn,k = map(int, input().split())\npowers = list(map(int, input().split()))\ncoins = list(map(int, input().split()))\n\nA = []\nans = [0] * n\nfor i in range(n):\n    A.append((powers[i], coins[i], i))\nA.sort()\nh = []\ntotal = 0\nfor i in range(n):\n    _,c,idx = A[i]\n    ans[idx] = total + c\n    if len(h) < k:\n        heappush(h, c)\n        total += c\n    elif h and h[0] < c:\n        total -= heappop(h)\n        heappush(h, c)\n        total += c\n\nfor x in ans:\n    print(x, end=\" \")\nprint()","output":"nlogn"},{"instruction":"import os\nfrom io import BytesIO, IOBase\nimport sys\nfrom collections import defaultdict, deque, Counter\nfrom math import sqrt, pi, ceil, log, inf, gcd, floor\nfrom itertools import combinations, permutations\nfrom bisect import *\nfrom fractions import Fraction\nfrom heapq import *\nfrom random import randint\n\ndef main():\n    n, s = map(int, input().split())\n    lo, hi = s, n\n    ans = n + 1\n    while lo <= hi:\n        mid = (lo + hi) \/\/ 2\n        z = sum(map(int, str(mid)))\n        if mid >= s + z:\n            ans = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    print(n - ans + 1)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"def main():\n\tn, d, k = map(int, input().split())\n\tif n < d+1 or d > 1 and k == 1:\n\t\tprint('NO')\n\t\treturn\n\n\tedges = [(1, 2)]\n\tstack = []\n\td2 = d\/2\n\td21 = d2+1\n\tfor node in range(2, d+1):\n\t\tedges.append((node, node+1))\n\t\tstack.append([node, d2-abs(d21 - node), k-2])\n\tnext_i = d+2\n\twhile next_i <= n:\n\t\tif not stack:\n\t\t\tprint('NO')\n\t\t\treturn\n\n\t\tnode = stack[-1]\n\t\ti, remaining_depth, remaining_degree = node\n\t\tif remaining_depth == 0 or remaining_degree == 0:\n\t\t\tstack.pop()\n\t\t\tcontinue\n\n\t\tnode[2] -= 1\n\t\tedges.append((i, next_i))\n\t\tstack.append([next_i, remaining_depth-1, k-1])\n\t\tnext_i += 1\n\n\tprint('YES')\n\tprint('\\n'.join('{} {}'.format(a, b) for a, b in edges))\n\nmain()","output":"quadratic"},{"instruction":"n = int(input())\nprint(int(3 * n \/ 2))","output":"constant"},{"instruction":"n=int(input())\nif n>=0:\n    print(n)\nelse:\n    a=str(n)\n    a=a[1::]\n    if len(a)>2:\n        a=a[::-1][1::][::-1]\n        num1=int(a)\n        a=str(n)\n        a=a[1::]\n        b=a[::-1]\n        p1=b[0]\n        p2=b[2::]\n        p=p1+p2\n        p=p[::-1]\n        num2=int(p)\n        small=min(num1,num2)\n        print(-1*small)\n\n    elif len(a)==2:\n        m=a[0]\n        n=a[1]\n        small=min(int(m),int(n))\n        print(-1*small)","output":"constant"},{"instruction":"n, k = map(int, input().split())\narr = [int(x) for x in input().split()]\ndiff = [0] * (n - 1)\np = arr[-1] - arr[0]\nfor i in range(n - 1):\n    diff[i] = arr[i + 1] - arr[i]\ndiff.sort(reverse=True)\nprint(p - sum(diff[:k - 1]))","output":"nlogn"},{"instruction":"import sys\nfrom collections import defaultdict\nout = sys.stdout\n\nt = int(sys.stdin.readline())\nwhile(t):\n    n = int(sys.stdin.readline())\n    dic = defaultdict(lambda:0,{})\n    ls = list(sorted(list(map(int,sys.stdin.readline().split())),reverse=True))\n    st = set()\n\n    f=1\n    for i in ls:\n        dic[i]+=1\n        if(dic[i]==4):\n            f=0\n            out.write(str(i)+ \" \" +str(i)+ \" \" +str(i)+ \" \" +str(i)+\"\\n\")\n            break\n    if(not f ):\n        t-=1\n        f=1\n        continue\n    for i in ls:\n        if(dic[i]>=2):\n            st.add(i)\n    st = list(sorted(st,reverse=True))\n    ln = len(st)\n\n    mn = (4*(st[0]+st[1])**2)\/ (st[0]*st[1])\n    a,b,c,d=st[1] , st[1],st[0] , st[0]\n    for i in range(1,ln-1):\n        if ((4*(st[i]+st[i+1])**2)\/ (st[i]*st[i+1])) < mn:\n\n            a,b,c,d=st[i] , st[i],st[i+1] , st[i+1]\n\n            mn = (4*(st[i]+st[i+1])**2)\/ (st[i]*st[i+1])\n    out.write(str(a)+ \" \" +str(b)+ \" \" +str(c)+ \" \" +str(d)+\"\\n\")\n    t-=1","output":"nlogn"},{"instruction":"n, q = map(int,input().split())\npar = n \/\/ 2 + 1\npar = len(list(bin(par)[2:]))\nfor i in range(q):\n    ui = int(input())\n    si = input()\n    temp = bin(ui)[2:]\n    now = len(temp)\n    num = list((par - now) * \"0\" + temp)\n    now = par - now\n    for i in range(len(num)):\n        if str(num[i]) == '1':\n            now = i\n    for i in si:\n        if i == \"U\":\n            if now == 0:\n                continue\n            num[now] = 0\n            now -= 1\n            num[now] = 1\n        elif i == \"L\":\n            if str(num[-1]) == '1':\n                continue\n            num[now] = 0\n            now += 1\n            num[now] = 1\n        else:\n            if str(num[-1]) == '1':\n                continue\n            now += 1\n            num[now] = 1\n    for i in range(par):\n        num[i] = str(num[i])\n    print(int(\"\".join(num),2))","output":"np"},{"instruction":"n,k=list(map(int,input().split()))\n\nif k%2==0:\n    s=\".\"\n    s=s+\"\n    s=s+\".\"*(n-len(s))\n    print(\"YES\")\n    print(\".\"*n)\n    print(s)\n    print(s)\n    print(\".\"*n)\n\nelse:\n    if k<=n-2:\n        a=\"\n        s=\".\"*((n-k)\/\/2)+a+\".\"*((n-k)\/\/2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(s)\n        print(\".\"*n)\n        print(\".\"*n)\n    else:\n        k=k-n+3\n        a=\"\n        s=\".\"*((n-k)\/\/2)+a+\".\"*((n-k)\/\/2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(\".\"+\"\n        s=list(s)\n        s[n\/\/2]=\".\"\n        s=\"\".join(s)\n        print(s)\n        print(\".\"*n)","output":"linear"},{"instruction":"def main():\n    n = int(input())\n    ans = n * n + (n - 1) * (n - 1)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        resIdx = 0\n        resLen = 0\n\n        for i in range(len(s)):\n\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    resIdx = l\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    resIdx = l\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n        return s[resIdx : resIdx + resLen]","output":"quadratic"},{"instruction":"n, s  = [int(i) for i in input().split()]\n\nprint(max(n - [i for i in range(s, s + 180) if i - sum([int(j) for j in str(i)]) >= s][0] + 1, 0))","output":"logn"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nans = 1\nfor i in range(1, n):\n  ok = False\n  for j in range(i):\n    if A[i] % A[j] == 0:\n      ok = True\n  if not ok:\n    ans += 1\nprint(ans)","output":"quadratic"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]\ndp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef readPair():\n  return tuple(map(int, input().split()))\n\n(n, m) = readPair()\nentries = [readPair() for _ in range(0, n)]\nentries.sort(key=lambda x: x[1] - x[0])\n\nsize = sum(x[0] for x in entries)\ncount = 0\n\nwhile (size > m and count < n):\n  size -= entries[count][0] - entries[count][1]\n  count += 1\n\nprint(-1 if size > m else count)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\ndiff = []\nif n == 1:\n    print(0)\nelse:\n    for i in range(n-1):\n        diff.append(a[i+1]-a[i])\n\n    diff.sort(reverse = True)\n    ans = a[-1] - a[0]\n    for i in range(min(k-1, len(diff))):\n        ans -= diff[i]\n\n    print(ans)","output":"nlogn"},{"instruction":"if __name__==\"__main__\":\n    dic={}\n    n,m=map(int,input().split())\n    li=list(map(int,input().split()))\n    c=0\n    for i in range(n):\n        dic.setdefault(i+1,0)\n    for i in li:\n        if 0 not in dic.values():\n            c=c+1\n            for j in range(1,n+1):\n                dic[j]=dic[j]-1\n\n        dic[i]=dic[i]+1\n    if 0 not in dic.values():\n        c=c+1\n    print(c)","output":"quadratic"},{"instruction":"n,m=map(int,input().split())\nc=list(map(int,input().split()))\na=list(map(int,input().split()))\nj,res=0,0\nfor i in range(n):\n    if j < m:\n        if c[i] <= a[j]:\n            j+=1\n            res+=1\nprint(res)","output":"linear"},{"instruction":"def main():\n    n, m = map(int, input().split())\n    w = [c == '*' for i in range(n) for c in input()]\n    nm = n * m\n    q = [*[range(i, i + m) for i in range(0, nm, m)],\n            *[range(i, nm, m) for i in range(m)]]\n    e = [1000] * nm\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if w[i]:\n                    v += 1\n                    if e[i] > v:\n                        e[i] = v\n                else:\n                    v = e[i] = 0\n        if f:\n            w.reverse()\n            e.reverse()\n    e = [c if c != 1 else 0 for c in e]\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if v > e[i]:\n                    v -= 1\n                else:\n                    v = e[i]\n                if v:\n                    w[i] = False\n        if f:\n            w.reverse()\n            e.reverse()\n    if any(w):\n        print(-1)\n    else:\n        r = []\n        for i, c in enumerate(e):\n            if c:\n                r.append(f'{i\/\/m+1} {i%m+1} {c-1}')\n        print(len(r), '\\n'.join(r), sep='\\n')\n\nmain()","output":"quadratic"},{"instruction":"xs, ys = map(int, input().split())\nthings = [[xs, ys, 0]]\nn = int(input())\nfor i in range(n):\n    things.append(list(map(int, input().split())) + [i + 1])\n\ndistance = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i, n + 1):\n        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2\n\nINF = float('inf')\nDP = [INF for _ in range((1 << n) + 10)]\nPath = [None for _ in range((1 << n) + 10)]\nDP[0] = 0\n\nfor cur in range(1 << n):\n    if DP[cur] == INF:\n        continue\n    for nxt1 in range(n):\n        if cur & (1 << nxt1) != 0:\n            continue\n\n        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:\n            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]\n            Path[cur | (1 << nxt1)] = cur\n\n        for nxt2 in range(n):\n            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:\n                continue\n            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:\n                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]\n                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur\n        break\n\nprint(DP[(1 << n) - 1])\n\npath = []\ncur = (1 << n) - 1\nwhile cur != 0:\n    path.append(0)\n    father = Path[cur]\n    diff = cur ^ father\n    d1 = len(bin(diff)[2:])\n    path.append(d1)\n    diff ^= (1 << (d1 - 1))\n    if diff != 0:\n        d2 = len(bin(diff)[2:])\n        path.append(d2)\n    cur = father\npath.append(0)\npath = list(reversed(path))\nprint(' '.join(map(str, path)))","output":"np"},{"instruction":"def digit(a):\n    s=0\n    while a:\n        s+=a%10\n        a\/\/=10\n    return s\n\ndef big(n,s):\n\n    lo=1\n    hi=n\n    while lo<=hi:\n        mid=(lo+hi)\/\/2\n        if mid-digit(mid)<s:\n\n            lo=mid+1\n        else:\n            hi=mid-1\n\n    return n-lo+1\n\na,b=map(int,input().strip().split())\nprint(big(a,b))","output":"logn"},{"instruction":"import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom heapq import heappush,heappop,heapify\nfrom itertools import permutations,combinations\nfrom itertools import accumulate as ac\nmod = int(1e9)+7\n\nip = lambda : int(stdin.readline())\ninp = lambda: map(int,stdin.readline().split())\nips = lambda: stdin.readline().rstrip()\nout = lambda x : stdout.write(str(x)+\"\\n\")\n\nt = 1\nfor _ in range(t):\n    q = \"? {} {}\".format(0,0)\n    print(q,flush = True)\n    cond = ip()\n    cur_a = 0\n    cur_b = 0\n    for i in range(29,-1,-1):\n        xor = (1<<i)\n        query_a = cur_a^xor\n        query_b = cur_b^xor\n        q = \"? {} {}\".format(query_a,query_b)\n        print(q,flush = True)\n        val = ip()\n        if val != cond:\n            if cond == -1 and val == 1:\n                cur_b ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n            else:\n                cur_a ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n        else:\n            cond = val\n            query_a = cur_a^xor\n            query_b = cur_b\n            q = \"? {} {}\".format(query_a,query_b)\n            print(q,flush = True)\n            val = ip()\n            if val == -1:\n                cur_a ^= xor\n                cur_b ^= xor\n            else:\n                pass\n    ans = \"! {} {}\".format(cur_a,cur_b)\n    print(ans,flush = True)","output":"logn"},{"instruction":"a,k=map(int,input().split())\np=[]\nfor n in range(2,a+1):\n\tfor i in range(2,int(n**0.5)+1):\n\t\tif n%i==0:\n\t\t\tbreak\n\telse:\n\t\tp.append(n)\nc=0\nfor i in range(0,len(p)-1):\n\tn=p[i]+p[i+1]+1\n\tfor i in range(2,int(n**0.5)+1):\n\t\tif n%i==0:\n\t\t\tbreak\n\telse:\n\t\tif n<=a:\n\t\t\tc+=1\nif c>=k:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"linear"},{"instruction":"def solve(n, m):\n    h=m&-m\n    for c in input():\n        if c=='U' and m!=(n+1)>>1:\n            m+= -h if (m+h)%(h<<2)==0 else h\n            h<<=1\n        if c in 'LR' and h>1:\n            h>>=1\n            m+= -h if c=='L' else h\n    return m\n\nn, m=map(int, input().split())\nfor _ in range(m):\n    print(solve(n, int(input())))","output":"np"},{"instruction":"a='4'*(300)+'5'\nb='5'*(301)\nprint(a);print(b)","output":"constant"},{"instruction":"class Solution:\n    def jump(self, nums: List[int]) -> int:\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            if i == len(nums) - 1:\n                return 0\n            if nums[i] == 0:\n                return 1000000\n\n            res = 1000000\n            end = min(len(nums), i + nums[i] + 1)\n            for j in range(i + 1, end):\n                res = min(res, 1 + dfs(j))\n            memo[i] = res\n            return res\n\n        return dfs(0)","output":"quadratic"},{"instruction":"print('25')","output":"constant"},{"instruction":"from collections import deque\n\ndef removeUsed(adj, used):\n    to_remove = []\n    for s in adj:\n        if used[s]: to_remove.append(s)\n    for s in to_remove:\n        adj.remove(s)\n\ndef solve(a, s):\n    if s[0] != 0: return False\n    q = deque()\n    q.append(0)\n    i, n, cur = 1, len(a), -1\n    used = [False]*n\n    used[0] = True\n    while i < n:\n        if cur == -1:\n            cur = q.popleft()\n            removeUsed(a[cur], used)\n        if not a[cur]:\n            cur = -1\n            continue\n        cur_s = s[i]\n        i += 1\n        if cur_s not in a[cur]:\n            return False\n        a[cur].remove(cur_s)\n        q.append(cur_s)\n        used[cur_s] = True\n    return True\n\nn = int(input())\na = [set() for i in range(n)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    a[u-1].add(v-1)\n    a[v-1].add(u-1)\ns = [(x-1) for x in map(int, input().split())]\nprint(\"Yes\" if solve(a, s) else \"No\")","output":"linear"},{"instruction":"def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y\/\/g):\n        d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"import math\nn  = int(input())\n\nfor i in range(n):\n    l,r = [*map(int, input().split())]\n    l-=1\n    war1 = math.ceil(l\/2)\n    if(l%2 == 1):\n        war1 = -1*war1\n\n    war2 = math.ceil(r\/2)\n    if(r%2 == 1):\n        war2 = -1*war2\n\n    print(war2-war1)","output":"constant"},{"instruction":"from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr = lambda: stdin.readline().strip()\nrstr_2d = lambda n: [rstr() for _ in range(n)]\n\nn, m = rints()\ngrid = rstr_2d(n)\nrow = [[[] for _ in range(m)] for _ in range(n)]\ncol = [[[] for _ in range(m)] for _ in range(n)]\nvisr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0\nvisc = [[-1 for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    be, en = -1, -1\n    for j in range(m):\n        if grid[i][j] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    row[i][k] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            row[i][k] = [be, en]\n\nfor i in range(m):\n    be, en = -1, -1\n    for j in range(n):\n        if grid[j][i] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    col[k][i] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            col[k][i] = [be, en]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '*':\n            all += 1\n            hor = min(row[i][j][1] - j, j - row[i][j][0])\n            ver = min(col[i][j][1] - i, i - col[i][j][0])\n            if hor <= ver:\n                ver = hor\n            else:\n                hor = ver\n\n            if hor > 0 and ver > 0:\n                out.append('%d %d %d' % (i + 1, j + 1, hor))\n                visr[i][j - ver] = j + ver\n                visc[i - hor][j] = i + hor\n\ndis = set()\nfor i in range(n):\n    j, ma = 0, -1\n    while j < m:\n        ma = max(ma, visr[i][j])\n        if ma >= j:\n            dis.add((i, j))\n\n        j += 1\n\nfor i in range(m):\n    j, ma = 0, -1\n    while j < n:\n        ma = max(ma, visc[j][i])\n        if ma >= j:\n            dis.add((j, i))\n\n        j += 1\n\nif len(dis) != all:\n    print(-1)\nelse:\n    print('%d\\n%s' % (len(out), '\\n'.join(out)))","output":"quadratic"},{"instruction":"def main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum \/ k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())\n            if found:\n                answer[mask] = True\n                masks[mask] = path\n    for mask_right in range(1 << k):\n        if not masks[mask_right]:\n            continue\n        zeroes_count = 0\n        for u in range(k):\n            if (1 << u) > mask_right:\n                break\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n        for mask_mask in range(1 << zeroes_count):\n            mask_left = 0\n            c = 0\n            for u in range(k):\n                if (1 << u) > mask_right:\n                    break\n                if (mask_right & (1 << u)) == 0:\n                    if (mask_mask & (1 << c)) != 0:\n                        mask_left = mask_left | (1 << u)\n                    c += 1\n            joint_mask = mask_left | mask_right\n            if answer[mask_left] and not answer[joint_mask]:\n                answer[joint_mask] = True\n                left[joint_mask] = mask_left\n                right[joint_mask] = mask_right\n                if joint_mask == ((1 << k) - 1):\n                    return build_answer(k, masks, left, right)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    return False, None, None\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for key, val in masks[right[pos]].items():\n            c[key] = val[0]\n            p[key] = val[1]\n        pos = left[pos]\n    for key, val in masks[pos].items():\n        c[key] = val[0]\n        p[key] = val[1]\n    return True, c, p\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path[i_next] = (a[i_next][j_next], i)\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\nn,m=map(int,input().split())\nfor i in range(n\/\/2+n%2):\n    x1=i+1\n    x2=n-i\n    if(x1==x2):\n        for j in range(m\/\/2+m%2):\n            if(j+1==m-j):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n            else:\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n    else:\n        if(i%2==0):\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n        else:\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(m-j)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(j+1)+\"\\n\"))","output":"quadratic"},{"instruction":"import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\nfrom pprint import pprint\n\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\ndef solve(N, M, K, P, S, MT):\n    graph = [[] for i in range(N)]\n\n    def isMatch(s, pattern):\n        for a, b in zip(s, pattern):\n            if b != \"_\" and a != b:\n                return False\n        return True\n\n    ordA = ord(\"a\") - 1\n\n    def hashStr(s):\n        hsh = 0\n        for i, c in enumerate(s):\n\n            val = 27 if c == \"_\" else ord(c) - ordA\n            hsh = 32 * hsh + val\n        return hsh\n\n    patternToId = {}\n    for i, p in enumerate(P):\n        patternToId[hashStr(p)] = i\n\n    for s, mt in zip(S, MT):\n        if not isMatch(s, P[mt]):\n            return \"NO\"\n        vals = [ord(c) - ordA for c in s]\n        hsh = 0\n        for mask in range(1 << K):\n            hsh = 0\n            for pos in range(K):\n                val = 27 if (1 << pos) & mask else vals[pos]\n                hsh = 32 * hsh + val\n            if hsh in patternToId:\n                mt2 = patternToId[hsh]\n\n                if mt2 != mt:\n                    graph[mt].append(mt2)\n\n    ans = toposort(graph)\n    if ans is None:\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(str(i + 1) for i in ans)\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    TC = 1\n    for tc in range(1, TC + 1):\n        N, M, K = [int(x) for x in input().split()]\n        P = [input().decode().rstrip() for i in range(N)]\n        S = []\n        MT = []\n        for i in range(M):\n            s, mt = input().split()\n            s = s.decode()\n            mt = int(mt) - 1\n            S.append(s)\n            MT.append(mt)\n        ans = solve(N, M, K, P, S, MT)\n        print(ans)","output":"np"},{"instruction":"import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n\nn,k=nninp()\nif(k>=2*n):\n    p(0)\nelif(k<=n):\n    if(k%2==1):\n        p(k\/\/2)\n    else:\n        p(k\/\/2-1)\nelse:\n    if(k%2==1):\n       print(k\/\/2-(k-n)+1)\n    else:\n        print(k\/\/2 - (k - n))","output":"constant"},{"instruction":"x, y, z, t1, t2, t3 = list(map(int, input().split()))\nprint(\"YES\" if 3 * t3 + abs(x - z) * t2 + abs(x - y) * t2 <= abs(x - y) * t1 else \"NO\")","output":"constant"},{"instruction":"from sys import stdin,stdout\nfrom math import gcd, ceil, sqrt\nfrom itertools import combinations\nfrom collections import Counter\nfrom bisect import bisect_left, bisect_right\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nmod = 1000000007\n\nn, l, r, x = iia()\narr = iia()\ncount = 0\nfor i in range(2, n + 1):\n    t = combinations(arr, i)\n    for j in t:\n        if sum(j) >= l and sum(j) <= r \\\n            and max(j) - min(j) >= x:\n            count += 1\nprint(count)","output":"np"},{"instruction":"n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\ncandies=[]\nfor i in range(n):\n    candies.append(n-l[i]-r[i])\nleft=[]\nfor i in range(n):\n    guys=0\n    for j in range(i):\n        if candies[j]>candies[i]:\n            guys+=1\n    left.append(guys)\nright=[]\nfor i in range(n):\n    guys=0\n    for j in range(i,n):\n        if candies[j]>candies[i]:\n            guys+=1\n    right.append(guys)\nif left==l and right==r:\n    print(\"YES\")\n    candiesstr=\"\"\n    for i in range(n):\n        candiesstr+=str(candies[i])+\" \"\n    print(candiesstr[:len(candiesstr)-1])\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"n = int(input())\n\nb = list(map(int, input().split()))\na1 = [0]\na2 = [b[0]]\n\nfor x in b[1:]:\n\tnew_a = a1[-1]\n\tif x - new_a > a2[-1]:\n\t\tnew_a = x - a2[-1]\n\tnew_a2 = x - new_a\n\ta1.append(new_a)\n\ta2.append(new_a2)\nprint(*(a1+a2[::-1]))","output":"linear"},{"instruction":"I=lambda:[*map(int, input().split())]\nR = range\nm = min\nN, M, K = I()\nR = range\n\nif K&1:\n\tfor _ in R(N):\n\t\tprint(*[-1]*M)\n\texit()\nA = [I() for _ in R(N)]\nB = [I() for _ in R(N-1)]\nX = [M*[0]for _ in R(N)]\nfor k in R(1, K\/\/2+1):\n\tY = [M*[9**9]for _ in R(N)]\n\tfor i in R(N):\n\t\tfor j in R(M):\n\t\t\tif i:\n\t\t\t\tY[i][j] = X[i-1][j] + 2*B[i-1][j]\n\t\t\tif i<N-1:\n\t\t\t\tY[i][j] = m(Y[i][j], X[i+1][j] + 2*B[i][j])\n\t\t\tif j:\n\t\t\t\tY[i][j] = m(Y[i][j], X[i][j-1] + 2*A[i][j-1])\n\t\t\tif j<M-1:\n\t\t\t\tY[i][j] = m(Y[i][j], X[i][j+1] + 2*A[i][j])\n\tX = Y\nfor x in X:\n\tprint(*x)","output":"cubic"},{"instruction":"l, r = map(int, input().split())\n\nans = 0\nfor i in range(63, -1, -1):\n    if r & (1 << i) > 0 and l & (1 << i) == 0:\n        ans = (1 << (i + 1)) - 1\n        break\nprint(ans)","output":"logn"},{"instruction":"n=int(input())\nw = [(int(x), c+1) for c, x in enumerate(input().split())]\nb=sorted(w,reverse=True)\nf=[]\np=[]\nk=input()\nfor i in k:\n    if i==\"0\":\n        x=b.pop()\n        f.append(x)\n        p.append(x[1])\n    else:\n        y=f.pop()\n        p.append(y[1])\nprint(*p)","output":"nlogn"},{"instruction":"from bisect import bisect_right\nn, x, y = map(int, input().split(' '))\ns=[0]*n\ne=[0]*n\nv=[0]*n\nc=0\nfor i in range(n):\n    s[i],e[i]=map(int, input().split(' '))\n    c+=x+(e[i]-s[i])*y\ns.sort()\ne.sort()\nfor i in range(n-2,-1,-1):\n    k=bisect_right(s,e[i])\n    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :\n        k+=1\n    if k==n:\n        continue\n    if (s[k]-e[i]) * y < x :\n        v[k] = 1\n        c+=(s[k]-e[i])*y-x\n\nprint(c%(10**9+7))","output":"nlogn"},{"instruction":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        n = len(height)\n        res = 0\n\n        for i in range(n):\n            leftMax = rightMax = height[i]\n\n            for j in range(i):\n                leftMax = max(leftMax, height[j])\n            for j in range(i + 1, n):\n                rightMax = max(rightMax, height[j])\n\n            res += min(leftMax, rightMax) - height[i]\n        return res","output":"quadratic"},{"instruction":"from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) \/\/ factorial(m) \/\/ factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)\/\/2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)","output":"quadratic"},{"instruction":"from collections import defaultdict\n_input = [int(num) for num in input().split(\" \")]\nl = _input[0]\nr = _input[1]\n\nif l != r:\n    binary_r = bin(r)[2:]\n    binary_l = bin(l)[2:].zfill(len(binary_r))\n\n    max_idx_prefix = 0\n    for idx, l_digit in enumerate(binary_l):\n        if l_digit != binary_r[idx]:\n            max_idx_prefix = idx\n            break\n\n    a_binary = [0 for num in range(len(binary_r))]\n    a_binary[max_idx_prefix] = 0\n    for idx in range(max_idx_prefix + 1, len(a_binary)):\n        a_binary[idx] = 1\n\n    b_binary = [0 for num in range(len(binary_r))]\n    b_binary[max_idx_prefix] = 1\n\n    a_binary = ''.join(str(digit) for digit in a_binary)\n    b_binary = ''.join(str(digit) for digit in b_binary)\n\n    a_binary = int(a_binary, 2)\n    b_binary = int(b_binary, 2)\n\n    max_xor = a_binary ^ b_binary\n\n    print(max_xor)\nelse:\n    print(l ^ r)","output":"logn"},{"instruction":"n=int(input())\narr=[int(x) for x in input().split()]\npos=dict()\nif(n==1):print(\"B\")\nelse:\n    for i in range(n):\n        pos[arr[i]]=i\n    ans=[\"Q\"]*n\n\n    ans[pos[1]]=\"A\"\n    ans[pos[n]]=\"B\"\n    for i in range(n-1,0,-1):\n        flag=0\n        p=pos[i]\n        j=1\n        while(p+j*i<n):\n            if(ans[p+j*i]==\"B\"):\n                flag=1\n                ans[pos[i]]=\"A\"\n                break\n            j+=1\n        if(flag==0):\n            j=1\n            while(p-j*i>=0):\n                if(ans[p-j*i]=='B'):\n                    flag=1\n                    ans[pos[i]]=\"A\"\n                    break\n                j+=1\n        if(flag==0):ans[pos[i]]=\"B\"\n    print(\"\".join(ans))","output":"nlogn"},{"instruction":"def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\nn = 10**7\nsquares = [i * i for i in range(1, 3162)]\n\np = list(range(n + 1))\nfor i in range(1, n + 1):\n\tif p[i] == i:\n\t\tfor sq in squares:\n\t\t\tif i * sq > n: break\n\t\t\tp[i * sq] = i\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = [p[a] for a in nrs()]\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))","output":"cubic"},{"instruction":"import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\n\ndef num():\n\treturn map(int , input().split())\n\ndef nu():\n\treturn int(input())\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\nn=nu()\na=li()\nb=li()\nz=[]\nfor i in range(n):\n\tz.append((a[i]+b[i],i))\nz.sort()\nfl=True\nx=[]\ncc=0\nxp=0\nmp={}\nnp=[]\nfor i in range(n):\n\tif(a[i]>i):\n\t\tfl=False\n\tif(b[i]>(n-i-1)):\n\t\tfl=False\n\tif((n-a[i]-b[i])<=0):\n\t\tfl=False\n\nif(fl==False):\n\tprint(\"NO\")\nelse:\n\tzz=[0]*n\n\tfor i in range(n):\n\t\tzz[i]=(n-a[i]-b[i])\n\tfor i in range(n):\n\t\txl = 0\n\t\txr = 0\n\t\tfor j in range(i + 1 , n):\n\t\t\tif (zz[j] > zz[i]):\n\t\t\t\txr += 1\n\t\tfor j in range(i - 1 , -1 , -1):\n\t\t\tif (zz[j] > zz[i]):\n\t\t\t\txl += 1\n\t\tif (xl != a[i] or xr != b[i]):\n\t\t\tfl = False\n\t\t\tbreak\n\tif (fl == True):\n\t\tprint(\"YES\")\n\t\tprint(*zz)\n\telse:\n\t\tprint(\"NO\")","output":"quadratic"},{"instruction":"n, k, A = map(int, input().rstrip().split())\nsenators = []\nmx_bribe = 0\n\nfor i in range(n):\n    lvl, loy = map(int, input().rstrip().split())\n    senators.append((lvl, loy))\n    mx_bribe += (100 - loy) \/\/ 10\n\nbribe = [0] * n\n\ndef calc(votes):\n    bsum, cnt, p = 0, 0, 1.0\n    for i, s in enumerate(senators):\n        if votes & (1 << i):\n            p *= (s[1] + bribe[i]) \/ 100\n            cnt += 1\n        else:\n            p *= (100 - s[1] - bribe[i]) \/ 100\n            bsum += s[0]\n\n    if cnt > (n \/ 2):\n        return p\n    else:\n        return p * A \/ (A + bsum)\n\ndef dfs(cur, rk):\n    if cur >= n:\n        if rk > 0:\n            return 0.0\n        sm = 0.0\n        for i in range(1 << n):\n            sm += calc(i)\n\n        return sm\n\n    mx = 0.0\n    for i in range(rk + 1):\n        if i * 10 + senators[cur][1] > 100:\n            break\n        bribe[cur] = i * 10\n        tmp = dfs(cur+1, rk-i)\n        mx = max(tmp, mx)\n    return mx\n\nprint(dfs(0, min(k, mx_bribe)))","output":"np"},{"instruction":"import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\na.sort()\n\nif n == 1:\n    if a[0] % 2 == 1:\n        v = True\n    else:\n        v = False\nelse:\n    v = True\n    c = 0\n    for i in range (0, n-1):\n        if a[i] == a[i + 1]:\n            c = c + 1\n            j = i\n    if c > 1:\n        v = False\n    elif c == 1:\n        if a[j] == 0:\n            v = False\n        if j > 0:\n            if a[j-1] + 1 == a[j]:\n                v = False\n    if (sum(a) - (n * (n - 1)) \/\/ 2) % 2 == 0:\n        v = False\n\nif v == True:\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")","output":"nlogn"},{"instruction":"from collections import defaultdict\nfrom itertools import accumulate\nimport sys\ninput = sys.stdin.readline\n\ninf = 100000000000000000\nmod = 998244353\n\nn, m ,k= map(int, input().split())\nM=[]\nS=[]\nF=[]\nfor i in range(n):\n    M.append(input().strip())\nfor i in range(m):\n    tmp1, tmp2 = input().split()\n    S.append(tmp1)\n    F.append(int(tmp2)-1)\n\nTRAN_dict=defaultdict(int)\nTRAN_dict['_']=0\nfor i in range(97,97+26):\n    TRAN_dict[chr(i)]=i-96;\n\ndef cal(X):\n    base=1\n    number=0\n    for x in X:\n        number=number*base+TRAN_dict[x]\n        base*=27\n    return number\n\nSTONE=defaultdict(int)\nfor i in range(n):\n    STONE[cal(list(M[i]))]=i\n\ndef check(X,result):\n    number=cal(X)\n    if number in STONE.keys():\n        result.append(STONE[number])\n\nbian=[[] for i in range(n)]\ndu=[0]*n\n\nfor i in range(m):\n    gain=[]\n    for digit in range(1<<k):\n        now=list(S[i])\n        tmp=bin(digit)\n        tmp=tmp[2:]\n        tmp='0'*(k-len(tmp))+tmp\n        for j in range(k):\n            if tmp[j]=='1':\n                now[j]='_'\n        check(now,gain)\n    if F[i] not in gain:\n        print(\"NO\")\n        sys.exit(0)\n    for x in gain:\n        if x!=F[i]:\n            bian[F[i]].append(x)\n            du[x]+=1\n\nfrom collections import deque\nQUE=deque()\nfor i in range(n):\n    if du[i]==0:\n        QUE.append(i)\nTOP_SORT=[]\nwhile QUE:\n    now=QUE.pop()\n    TOP_SORT.append(now)\n    for to in bian[now]:\n        du[to]-=1\n        if du[to]==0:\n            QUE.append(to)\nif len(TOP_SORT)==n:\n    print(\"YES\")\n    print(*[i+1 for i in TOP_SORT])\nelse:\n    print(\"NO\")","output":"np"},{"instruction":"a=int(input())\nz=list(map(int,input().split()))\nans=[]\nk=len(z)\nfor i in range(len(z)):\n    if((z[i]-i)%len(z)==0):\n        ans.append((z[i]-i)\/\/k)\n    else:\n        ans.append((z[i]-i)\/\/k)\n        ans[-1]+=1\nt=min(ans)\nprint(ans.index(t)+1)","output":"linear"},{"instruction":"a,b,c,d,e,f=list(map(int,input().split()))\nn,n2=1,a*b+c*d+e*f\nwhile n**2<n2:\n    n+=1\nif n**2>n2:\n    print(-1)\n    exit()\nl=sorted([[max(a,b),min(a,b),'A'],[max(c,d),min(d,c),'B'],[max(e,f),min(e,f),'C']])\nif l[2][0]!=n:\n    print(-1)\n    exit(0)\nv=str(n)+'\\n'+(l[2][2]*n+'\\n')*l[2][1]\nif l[0][0]==n and l[1][0]==n:\n    for i in range(2):\n        v+=(l[i][2]*n+'\\n')*l[i][1]\nelse:\n    s=n-l[2][1]\n    if s not in l[0] or s not in l[1]:\n        print(-1)\n        exit()\n    if s!=l[0][0]:\n        l[0][0],l[0][1]=l[0][1],l[0][0]\n    if s!=l[1][0]:\n        l[1][0],l[1][1]=l[1][1],l[1][0]\n    v+=(l[0][2]*l[0][1]+l[1][2]*l[1][1]+'\\n')*s\nprint(v)","output":"np"},{"instruction":"import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        s = list(input().strip())\n        n = len(s)\n\n        res = list()\n        p = n - 1\n        ones = 0\n        zeros = 0\n        while p >= 0:\n            if s[p] == '0':\n                zeros += 1\n            elif s[p] == '1':\n                ones += 1\n            elif s[p] == '2':\n                res.extend(['0'] * zeros)\n                res.append('2')\n                zeros = 0\n            p -= 1\n        res.extend(['1'] * ones)\n        res.extend(['0'] * zeros)\n        res.reverse()\n        print(''.join(map(str, res)))\n\nsolver()()","output":"linear"},{"instruction":"from itertools import chain, combinations\nfrom random import randint\ndef powerset(iterable):\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\nn,l,r,x=map(int,input().split())\nll=list(map(int,input().split()))\nsubsets=powerset(ll)\nres=0\nfor i in subsets:\n    if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x:\n        res+=1\nprint(res)","output":"np"},{"instruction":"def flipH(A,N):\n    B=[[0 for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            B[i][j]=A[i][N-j-1]\n    return B\n\ndef flipV(A,N):\n    B=[[0 for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            B[i][j]=A[N-i-1][j]\n    return B\n\ndef rotate90(A):\n    ans = zip(*A[::-1])\n    ans=list(map(list,ans))\n    return ans\n\ndef check(A,B,N):\n    for i in range(N):\n        for j in range(N):\n            if A[i][j]!=B[i][j]:\n                return False\n    return True\n\nN=int(input())\nA=[]\nX=[]\nfor i in range(N):\n    A.append(list(input()))\nfor i in range(N):\n    X.append(list(input()))\nB=flipH(A,N)\nC=flipV(A,N)\nflag=False\nfor i in range(4):\n    if check(A,X,N) or check(B,X,N) or check(C,X,N):\n        flag=True\n        break\n    else:\n        A=rotate90(A)\n        B=rotate90(B)\n        C=rotate90(C)\nif flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")","output":"quadratic"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\ntemp=max(a)\nif len(set(a))==1 and a[0]==1:\n    print(*a[:-1],2)\nelse:\n    a[a.index(temp)]=1\n    a.sort()\n    print(*a)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ntest=int(input())\nfor tests in range(test):\n    S=input().strip()\n    t=input().strip()\n\n    LENS=len(S)\n    LENT=len(t)\n    flag=0\n\n    for i in range(1,LENT+1):\n        t1=t[:i]\n        t2=t[i:]\n\n        DP=[-1]*(len(t1)+1)\n        DP[0]=0\n\n        for s in S:\n            for j in range(len(t1),-1,-1):\n                if 0<=DP[j]<len(t2) and s==t2[DP[j]]:\n                    DP[j]+=1\n\n                if s==t1[j-1]:\n                    DP[j]=max(DP[j],DP[j-1])\n\n        if DP[-1]==len(t2):\n            print(\"YES\")\n            flag=1\n            break\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"def isqrt(n):\n    x = n\n    y = (x + 1) \/\/ 2\n    while y < x:\n        x = y\n        y = (x + n \/\/ x) \/\/ 2\n    return x\n\nn, k = list(map(int, input().split(' ')))\nanswer = int((-1\/2) * isqrt(8*k + 8*n + 9) + n + 3\/2)\n\nprint(answer)","output":"logn"},{"instruction":"import sys\n\ndef is_winning_state(nims, n):\n    keys = set(nims)\n    counts = dict.fromkeys(keys, 0)\n    for nim in nims:\n        counts[nim] += 1\n    if 0 in keys and counts[0] > 1:\n        return True\n    lose_count = 0\n    for k in keys:\n        if counts[k] > 2:\n            return True\n        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:\n            return True\n        if counts[k] > 1:\n            lose_count += 1\n    if lose_count > 1:\n        return True\n    return False\n\ndef main():\n    n = int(input())\n    nims = list(map(int, input().split()))\n    if is_winning_state(nims, n):\n        print('cslnb')\n    else:\n        x = sum(nims) - (n * (n - 1)) \/\/ 2\n        if x % 2 == 0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n\nmain()","output":"linear"},{"instruction":"import sys\ndef main():\n    pass\ndef binary(n):\n\n    return (bin(n).replace(\"0b\", \"\"))\ndef decimal(s):\n\n    return (int(s, 2))\ndef pow2(n):\n\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\ndef isPrime(n):\n\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\ndef lts(l):\n\n    s = ''.join(map(str, l))\n    return s\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\nfrom collections import OrderedDict\nfrom fractions import Fraction\n\nn,m=nninp()\nx=llinp()\ny=llinp()\nfor c in x:\n    if(c in y):\n        print(c,end=\" \")","output":"quadratic"},{"instruction":"n = int(input())\nans = 1\nfor i in range(n):\n    ans += i * 4\nprint(ans)","output":"linear"},{"instruction":"st=input()\nm=0\nn=len(st)\nfor i in range(n):\n    for j in range(i,n+1) :\n        if st[i:j] in st[i+1:n] and len(st[i:j])>m:\n            m=len(st[i:j])\nprint(m)","output":"cubic"},{"instruction":"n,k = map(int,input().split())\nif(k - n >= n) :\n    print(0)\n    exit()\nif(k <= n):\n    if(k%2):\n         print(k\/\/2)\n    else :\n        print(k\/\/2-1)\nelse:\n    print(n-k\/\/2)","output":"constant"},{"instruction":"n,s=map(int,input().split())\ndegs=[0]*n\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    degs[a-1]+=1\n    degs[b-1]+=1\nprint(2*s\/degs.count(1))","output":"linear"},{"instruction":"from sys import stdin, gettrace\n\nif not gettrace():\n    def input():\n        return next(stdin)[:-1]\n\nINF = 10000\n\ndef main():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n\n    dp = [[0] * (n+1) for _ in range(n)]\n\n    def calc_dp(i, j):\n        if i + 1 == j:\n            dp[i][j] = aa[i]\n        if dp[i][j] != 0:\n            return dp[i][j]\n        dp[i][j] = -1\n        for k in range(i+1, j):\n            lf = calc_dp(i, k)\n            rg = calc_dp(k, j)\n            if lf > 0 and lf == rg:\n                dp[i][j] = lf + 1\n                break\n        return dp[i][j]\n\n    dp2 = list(range(0,n+1))\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if calc_dp(i, j) > 0:\n                dp2[j] = min(dp2[j], dp2[i] + 1)\n    print(dp2[n])\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"def permuteDigits(a, b):\n\n    n = len(a)\n    if len(a) < len(b):\n        return a\n\n    i = 0\n    c = 0\n    t = a[0]\n    flag = 0\n    lastind = []\n    while i<len(a) and i< len(b) and a[i] >= b[i] :\n\n        if c == n:\n            i = i - 1\n            t = a[i]\n            a = a[:i] + a[i+1:]\n            a.insert(lastind.pop(),t)\n            flag = 1\n            c = i\n        elif (flag == 0 and a[c] == b[i]) or a[c] < b[i]:\n            lastind.append(c)\n            t = a[c]\n            a = a[:c] + a[c+1:]\n\n            a.insert(i,t)\n\n        else:\n            c = c + 1\n\n        if a[i] < b[i]:\n            break\n        elif flag == 0 and a[i] == b[i]:\n            i = i + 1\n            c = i\n\n    return a\n\naa = input()\nbb = input()\n\na=[]\nb=[]\nfor i in aa:\n    a.append(int(i))\nfor i in bb:\n    b.append(int(i))\n\na.sort(reverse=True)\n\nans = permuteDigits(a, b)\ns = \"\"\nfor i in ans:\n    s = s + str(i)\nprint(int(s))","output":"cubic"},{"instruction":"from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nn,L = li()\nl = []\nfor i in range(n):\n    l.append(li())\n\nindex = defaultdict(list)\nfor ind,i in enumerate(l):\n    index[tuple(i)].append(ind + 1)\n\nl.sort(key = lambda x:x[1])\nd = defaultdict(list)\n\nans = i = tot = currpoints = 0\nanspattern = []\nhe = []\n\nwhile i < n:\n\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n\n    if currpoints > ans:\n\n        ans = currpoints\n\n    i += 1\ni = tot = currpoints = 0\nhe = []\nd = defaultdict(list)\n\nwhile i < n:\n\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n\n    if currpoints == ans:\n        anspattern = []\n        for i in he:\n            for j in d[i]:\n                anspattern.append(index[tuple([i,j])][-1])\n                index[tuple([i,j])].pop()\n        print(ans)\n        print(len(anspattern))\n        print(*sorted(anspattern))\n        exit()\n\n        ans = currpoints\n\n    i += 1","output":"nlogn"},{"instruction":"from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    a=lst()\n    b=lst()\n    dp=[0]*n\n    for i in range(n):\n        v=float('inf')\n        for j in range(i+1,n):\n            if a[j]>a[i]:v=min(v,b[i]+b[j])\n        dp[i]=v\n\n    for i in range(n):\n        v = float('inf')\n        for j in range(i + 1, n):\n            if a[j] > a[i]: v = min(v, b[i] + dp[j])\n        dp[i] = v\n    ans=min(dp)\n    print(ans if ans!=float('inf') else -1)","output":"quadratic"},{"instruction":"n,useless=list(map(int,input().split()))\narr=list(map(int,input().split()))\nfor x in range(1,n+1):\n    if x not in arr:\n        print(0)\n        break\nelse:\n    print(arr.count(min(arr,key=lambda x:arr.count(x))))","output":"quadratic"},{"instruction":"def readline(): return map(int, input().split())\n\ndef main():\n    n, a, b = readline()\n    if a > 1 and b > 1:\n        print('NO')\n        return\n\n    if n in [2, 3] and a == 1 and b == 1:\n        print('NO')\n        return\n\n    matrix = [[i in [j + 1, j -1] for i in range(n)] for j in range(n)]\n\n    a, b = n + 1 - a, n + 1 - b\n    if a != n:\n        matrix = [[False for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i < a and j < a and i != j:\n                    matrix[i][j] = True\n    elif b != n:\n        matrix = [[False for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i >= b or j >= b:\n                    matrix[i][j] = True\n                if i == j:\n                    matrix[i][j] = False\n\n    print('YES')\n    for row in matrix:\n        print(\"\".join(map(lambda x: '1' if x else '0', row)), flush=False)\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\ndp = [[0] * 5 for i in range(n)]\ndp[0] = [1, 1, 1, 1, 1]\n\nfor i in range(1, n):\n    if arr[i] > arr[i - 1]:\n        for j in range(1, 5):\n            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1])\n    elif arr[i] < arr[i - 1]:\n        for j in range(3, -1, -1):\n            dp[i][j] = max(dp[i - 1][j + 1], dp[i][j + 1])\n    else:\n        for j in range(5):\n            dp[i][j] += (sum(dp[i - 1]) > 0) * (dp[i - 1][j] == 0 or sum(dp[i - 1]) > 1)\nif dp[-1] == [0, 0, 0, 0, 0]:\n    print(-1)\nelse:\n    ans = [dp[-1].index(1) + 1]\n    for i in range(n - 2, -1, -1):\n        for j in range(5):\n            if dp[i][j] > 0 and ((j + 1 > ans[-1] and arr[i] > arr[i + 1])\n                                 or (j + 1 < ans[-1] and arr[i] < arr[i + 1])\n                                 or (j + 1 != ans[-1] and arr[i] == arr[i + 1])):\n                ans.append(j + 1)\n                break\n    print(*reversed(ans))","output":"quadratic"},{"instruction":"import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\nans=0\ndef setting(s):\n    if s=='0':\n        return -1\n    i=len(s)-1\n    cc=0\n    while(i>=0 and s[i]=='0'):\n        cc+=1\n        i-=1\n    return cc\ndef hnbhai(tc):\n    n,q=sd()\n    up=n+1\n    x=len(bin(n)[2:])-1\n    for i in range(q):\n        v=sb()\n        s=sa()\n        for j in s:\n            temp=bin(v)[2:]\n            abe=setting(temp)\n\n            if j==\"U\":\n                if abe>=x:\n                    continue\n                p=v+(1<<(abe))\n                n=v-(1<<(abe))\n                x1=setting(bin(p)[2:])\n\n                x2=setting(bin(n)[2:])\n                if x1==abe+1:\n                    v=p\n                else:\n                    v=n\n            elif j==\"L\":\n                if abe<=0:\n                    continue\n                v=v-(1<<(abe-1))\n\n            else:\n                if abe<=0:\n                    continue\n                v=v+(1<<(abe-1))\n        print(v)\nfor _ in range(1):\n    hnbhai(_+1)","output":"np"},{"instruction":"from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom math import inf\n\nri = lambda : map(int, input().split())\n\ndef solve():\n    n,m = ri()\n    A = [[0 for _ in range(m)] for __ in range(n)]\n    left = [[0 for _ in range(m)] for __ in range(n)]\n    right = [[0 for _ in range(m)] for __ in range(n)]\n    up = [[0 for _ in range(m)] for __ in range(n)]\n    down = [[0 for _ in range(m)] for __ in range(n)]\n    for r in range(n):\n        lst = input()\n        for c in range(m):\n            if lst[c] == '*':\n                A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1\n\n    for r in range(n):\n        for c in range(1, m):\n            if A[r][c]:\n                left[r][c] += left[r][c-1]\n        for c in range(m-2, -1, -1):\n            if A[r][c]:\n                right[r][c] += right[r][c+1]\n\n    for c in range(m):\n        for r in range(1, n):\n            if A[r][c]:\n                up[r][c] += up[r-1][c]\n\n        for r in range(n-2, -1, -1):\n            if A[r][c]:\n                down[r][c] += down[r+1][c]\n    res = []\n    stars = 0\n\n    ROWS = [[0 for _ in range(m)] for __ in range(n)]\n    COLS = [[0 for _ in range(m)] for __ in range(n)]\n\n    for r in range(n):\n        for c in range(m):\n            if A[r][c]:\n                can = min(left[r][c], right[r][c], up[r][c], down[r][c])\n                can -= 1\n                if can > 0:\n                    stars += 1\n                    res.append((r+1, c+1, can))\n                ROWS[r-can][c] += can\n                if r+can+1 < n:\n                    ROWS[r+can+1][c] -= can\n                COLS[r][c-can] += can\n                if c+can+1 < m:\n                    COLS[r][c+can+1] -= can\n\n    valid = [[False for _ in range(m)] for __ in range(n)]\n    for r in range(n):\n        curr = 0\n        for c in range(m):\n            curr += COLS[r][c]\n            if curr > 0:\n                valid[r][c] = True\n\n    for c in range(m):\n        curr = 0\n        for r in range(n):\n            curr += ROWS[r][c]\n            if curr > 0:\n                valid[r][c] = True\n\n    for r in range(n):\n        for c in range(m):\n            if A[r][c] and not valid[r][c]:\n                print(-1)\n                return\n    print(stars)\n    for x,y,z in res:\n        print(x,y,z)\nt = 1\n\nwhile t:\n    t -= 1\n    solve()","output":"quadratic"},{"instruction":"n = int(input())\n\nl = []\nfor i in range(n):\n    c = list(map(int, input().split()))\n    l.append(sum(c))\n\nm = l[0]\nl.sort(reverse=True)\nfor i in range(len(l)):\n    if m == l[i]:\n        print(i+1)\n        break","output":"linear"},{"instruction":"def digit(a):\n    s=0\n    while a:\n        s+=a%10\n        a\/\/=10\n    return s\n\ndef big(n,s):\n    lo=1\n    hi=n\n    while lo<=hi:\n        mid=(lo+hi)\/\/2\n        if mid-digit(mid)<s:\n            lo=mid+1\n        else:\n            hi=mid-1\n    return n-lo+1\n\na,b=map(int,input().strip().split())\nprint(big(a,b))","output":"logn"},{"instruction":"n = int(input())-1\nx, y = 1, 9\nwhile n > x * y: n,x,y = n-x*y,x+1,y*10\na = str(10 ** (x - 1) + n \/\/ x)[n%x]\nprint(a)","output":"logn"},{"instruction":"for _ in range(int(input())):\n    n, k = [int(x) for x in input().split()]\n    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) \/\/ 3):\n        print('NO')\n    else:\n        cn = n - 1\n        ck = k - 1\n        l = 1\n        while cn * ck != 0 and ck >= 4 * l - 1:\n            ck -= 4 * l - 1\n            cn -= 1\n            l *= 2\n        print('YES', cn)","output":"logn"},{"instruction":"k = int(input().split()[1])\nl = sorted(map(int, input().split()))\n\nres = set()\nfor i in l:\n    if i%k!=0:\n        res.add(i)\n    elif i\/\/k not in res:\n        res.add(i)\nprint(len(res))","output":"nlogn"},{"instruction":"def mus(x):\n    c = 0\n    while(x>0):\n        c += x%10\n        x = x\/\/10\n    return c\nn,s=map(int,input().split())\nans = s + 10 - s%10\nwhile(ans - mus(ans) < s):\n    ans += 10\nif ans > n:\n    print(0)\nelse:\n    print(n-ans+1)","output":"logn"},{"instruction":"q = int(input())\notvet = []\nfor i in range(q):\n    g = input().split()\n    n = int(g[0])\n    m = int(g[1])\n    k = int(g[2])\n    if n < 0:\n        n = -n\n    if m < 0:\n        m = -m\n    if m > k or n > k:\n        otvet.append(-1)\n    elif m % 2 == k % 2 and n % 2 == k % 2:\n        otvet.append(k)\n    elif m % 2 == k % 2 or n % 2 == k % 2:\n        otvet.append(k - 1)\n    else:\n        otvet.append(k - 2)\nfor i in otvet:\n    print(i)","output":"constant"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nneeda = 2 * x + y\nneedb = y + 3 * z\nprint(max(0, needa - a) + max(0, needb - b))","output":"constant"},{"instruction":"import sys\n\ndef query(c, d):\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    res = int(input())\n    return res\n\na = 0\nb = 0\nbig = query(0, 0)\n\nfor i in range(29, -1, -1):\n    p = query(a ^ (1 << i), b)\n    q = query(a, b ^ (1 << i))\n    if p == q:\n        if big == 1:\n            a ^= 1 << i\n        else:\n            b ^= 1 << i\n        big = p\n    elif p == -1:\n        a ^= 1 << i\n        b ^= 1 << i\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()","output":"constant"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\n\ntp = abs(x - y) * t1\npt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3\nif tp >= pt:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom math import inf\n\ndef solve():\n    n, m = map(int, input().split())\n    cnt = defaultdict(int)\n    res = []\n    for i in range(n):\n        A = list(map(int, list(input())))\n        res.append(A)\n        for j in range(m):\n            if A[j]:\n                cnt[j] += 1\n    valid = False\n    for r in res:\n        j = [i for i in range(m) if r[i]]\n        if all(cnt[i] > 1 for i in j):\n            valid = True\n            break\n    if valid:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = 1\n\nwhile t:\n    t -= 1\n    solve()","output":"quadratic"},{"instruction":"n=int(input())\nl=[int(c) for c in input().split()]\nll=[]\nres=[]\nhead=0\ndia=0\nfor i in range(1,n):\n    if l[i]==1:\n        l[i]=0\n        ll.append(i)\n    else:\n        res.append((head+1,i+1))\n        l[head]-=1\n        dia+=1\n        head=i\n        l[head]-=1\nif l[head]>0 and len(ll)>0:\n    res.append((ll[0]+1,head+1))\n    l[head]-=1\n    del(ll[0])\n    dia+=1\nif l[0]>0 and len(ll)>0:\n    res.append((ll[0]+1,1))\n    l[0]-=1\n    del(ll[0])\n    dia+=1\nfor i in ll:\n    for j in range(n):\n        if l[j]>0:\n            res.append((j+1,i+1))\n            l[j]-=1\n            break\nif len(res)<n-1:\n    print(\"NO\")\nelse:\n    print(\"YES \"+str(dia))\n    print(n-1)\n    for p in res:\n        print(p[0],end =\" \")\n        print(p[1])","output":"quadratic"},{"instruction":"n = int(input())\npairs = [list(map(int, input().split()))+[i] for i in range(n)]\npairs.sort(key=lambda x:(x[0], -x[1]))\nfor i in range(1, n):\n    if pairs[i][1] <= pairs[i-1][1]:\n        print(pairs[i][2]+1, pairs[i-1][2]+1)\n        break\nelse:\n    print(-1, -1)","output":"nlogn"},{"instruction":"n = int(input())\nif n <= 5:\n    print(-1)\n    for i in range(2, n+1):\n        print(1, i)\n    exit()\n\nprint(1, 2)\nprint(2, 3)\nprint(2, 4)\nfor i in range(5, n+1):\n    print(3, i)\n\nfor i in range(2, n+1):\n    print(1, i)","output":"linear"},{"instruction":"input()\na = sorted(list(map(int, input().split())))\nprint(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))","output":"nlogn"},{"instruction":"n=int(input())\ns=input()\nif \"0\" in s:\n    if \"1\" in s:\n        print(\"1\"+\"0\"*s.count(\"0\"))\n    else:\n        print(\"0\")\nelse:\n    print(\"1\")","output":"linear"},{"instruction":"t = int(input())\n\nfor iter in range(t):\n    n, k = map(int, input().split())\n    if n >= 50:\n        if k == 0:\n            print(\"YES \" + str(n))\n        else:\n            print(\"YES \" + str(n - 1))\n    else:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        c = [0] * (n + 1)\n        a[0] = 0\n        b[n] = 1\n        c[n] = 0\n\n        for i in range(1, n + 1):\n            a[i] = 4 * a[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            b[i] = b[i + 1] * 2 + 1\n        for i in range(n - 1, -1, -1):\n            c[i] = c[i + 1] + b[i + 1]\n\n        res = -1\n        for d in range(n + 1):\n            if c[d] <= k and k <= a[n] - a[d] * b[d]:\n                res = d\n\n        if res == -1:\n            print(\"NO\")\n        else:\n            print(\"YES \" + str(res))","output":"linear"},{"instruction":"n, m, k, l = map(int, input().split())\nrequired = k + l\nper_friend = (required + m - 1) \/\/ m\nif (m * per_friend > n):\n    print(-1)\nelse:\n    print(per_friend)","output":"constant"},{"instruction":"r,g,b = map(int,input().split())\nR = sorted([*map(int,input().split())],reverse=True)\nG= sorted([*map(int,input().split())],reverse=True)\nB = sorted([*map(int,input().split())],reverse=True)\nmem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]\ndef dp(i,j,k):\n    p = (i==r)+(j==g)+(k==b)\n    if(p>1):\n        return 0\n    if(mem[i][j][k]!=-1):\n        return mem[i][j][k]\n    ans = 0\n    if(i==r):\n        ans = dp(i,j+1,k+1)+G[j]*B[k]\n        return ans\n    elif(j==g):\n        ans = dp(i+1,j,k+1)+R[i]*B[k]\n    elif(k==b):\n        ans = dp(i+1,j+1,k)+R[i]*G[j]\n    else:\n        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])\n    mem[i][j][k] = ans\n    return ans\nprint(dp(0,0,0))","output":"cubic"},{"instruction":"def power(x, y, p) :\n    res = 1\n\n    x = x % p\n\n    while (y > 0) :\n\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\n\nx,k = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    ans = power(2,k,1000000007)\n    ans = ans * ((2*x)-1)\n    ans = ans+1\n    ans=ans%1000000007\n    print(ans)","output":"logn"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    arr = list(map(int, input().split()))\n    color = [0] * n\n    arr.sort()\n\n    ans = 0\n    for i in range(n):\n        if color[i]:\n            continue\n        ans += 1\n        for j in range(i, n):\n            if arr[j] % arr[i] == 0:\n                color[j] = ans\n\n    print(ans)\n\n    return 0\n\nmain()","output":"quadratic"},{"instruction":"import bisect\nfrom itertools import accumulate, count\nimport os\nimport sys\nimport math\nfrom decimal import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ndef SieveOfEratosthenes(n):\n    prime = []\n    primes = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n\n        if primes[p] == True:\n            prime.append(p)\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    primes[1]=False\n    primes[0]=False\n    return primes\ndef primefactors(n):\n    fac=[]\n    while(n%2==0):\n        fac.append(2)\n        n=n\/\/2\n    for i in range(3,int(math.sqrt(n))+2):\n        while(n%i==0):\n            fac.append(i)\n            n=n\/\/i\n    if n>1:\n        fac.append(n)\n    return fac\ndef factors(n):\n    fac=set()\n    fac.add(1)\n    fac.add(n)\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            fac.add(i)\n            fac.add(n\/\/i)\n    return list(fac)\ndef NcR(n, r):\n\n    p = 1\n    k = 1\n    if (n - r < r):\n        r = n - r\n\n    if (r != 0):\n        while (r):\n            p *= n\n            k *= r\n            m = math.gcd(p, k)\n            p \/\/= m\n            k \/\/= m\n\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\ndef Log2(x):\n    if x == 0:\n        return False;\n\n    return (math.log10(x) \/\n            math.log10(2));\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) ==\n            math.floor(Log2(n)));\n\nn, r = map(int, input().split())\nx = [int(i) for i in input().split()]\nc = []\n\nfor i in range(n):\n    k = r\n    for x1, j in c:\n        d = abs(x[i] - x1)\n        if d <= 2 * r:\n            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)\n    c.append([x[i], k])\n    print(k)","output":"quadratic"},{"instruction":"import sys\nn,d,k=map(int,input().split())\nif(n<=d):\n    print('NO')\n    sys.exit()\nif(k==1 and n>2):\n    print('NO')\n    sys.exit()\n\nedgestot=[]\nedges=[[] for i in range(n)]\ntovisit=[]\nfor i in range(d):\n    edgestot.append([i,i+1])\n    tovisit.append([i+1,min(i+1,d-i-1)])\n    edges[i].append(i+1)\n    edges[i+1].append(i)\ncur=d+1\nwhile(cur<n and len(tovisit)>0):\n    x=tovisit.pop()\n    if(x[1]==0):\n        continue\n    while(len(edges[x[0]])<k and cur<n):\n        tovisit.append([cur,x[1]-1])\n        edgestot.append([cur,x[0]])\n        edges[x[0]].append(cur)\n        edges[cur].append(x[0])\n        cur+=1\n\nif(len(edgestot)==n-1):\n    print('YES')\n    for i in range(n-1):\n        print(edgestot[i][0]+1,edgestot[i][1]+1)\n\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n,s = [int(x) for x in input().split()]\nv=[ [] ]\nfor i in range(n):\n\tv.append([])\n\nfor i in range(n-1):\n\ta, b =[int(x) for x in input().split()]\n\tv[a].append(b)\n\tv[b].append(a)\n\nans =0\nfor i in range(1,n+1):\n\tif len(v[i])==1:\n\t\tans+=1\n\nprint(2*s\/ans)","output":"linear"},{"instruction":"n = int(input())\ns = [input() for i in range(n)]\nMOD = 10**9 + 7\n\ndps = [[0]*(n + 3) for i in range(n + 1)]\ndpf = [[0]*(n + 3) for i in range(n + 1)]\n\nfor k in range(n + 1):\n    dps[0][k] = 1\n\nfor pos, char in enumerate(s):\n    if char == \"s\":\n\n        for depth in range(pos + 2):\n            dps[pos + 1][depth] = dpf[pos][depth] - \\\n                dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1]\n\n            dps[pos + 1][depth] += dps[pos + 1][depth - 1]\n            dps[pos + 1][depth] %= MOD\n\n        for p in range(pos + 2, n+1):\n            dpf[pos + 1][p] += dpf[pos + 1][p - 1]\n            dpf[pos + 1][p] %= MOD\n        continue\n\n    else:\n\n        for depth in range(1, pos + 2):\n            dpf[pos + 1][depth] = dpf[pos][depth - 1] - \\\n                dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2]\n\n            dpf[pos + 1][depth] += dpf[pos + 1][depth - 1]\n            dpf[pos + 1][depth] %= MOD\n        for p in range(pos + 2, n+1):\n            dpf[pos + 1][p] += dpf[pos + 1][p - 1]\n            dpf[pos + 1][p] %= MOD\n\nans = dps[n][n] % MOD\nprint(ans)","output":"quadratic"},{"instruction":"if __name__ == \"__main__\":\n    n, s = input().split(\" \")\n    n = int(n)\n    s = int(s)\n\n    sol = 0\n    l = 1\n    r = n\n    while l <= r:\n        sum = 0\n        i = (l + r)\/\/2\n        a = i\n        while (a > 0):\n            sum += a % 10\n            a = a \/\/ 10\n\n        if i - sum >= s:\n            sol = n - i + 1\n            r = i - 1\n        else:\n            l = i + 1\n\n    print(sol)","output":"logn"},{"instruction":"n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb.sort()\ng.sort()\nif b[-1] > g[0]:\n    print(-1)\n    import sys\n    sys.exit(0)\na = 0\na += sum(g) - g[0]\nif g[0] == b[-1]:\n    a += g[0]\n    a += m * sum(b[:-1])\n    print(a)\nelse:\n    a += g[0]\n    a += m * sum(b[:-2]) + (m - 1) * b[-2] + b[-1]\n    print(a)","output":"nlogn"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\nlift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\nstairs = t1 * abs(x - y)\nif lift <= stairs:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\nn=int(input())\nif n==0:\n\tprint(0)\n\tsys.exit()\nif (n+1)%2==0:\n\tprint((n+1)\/\/2)\nelse:\n\tprint(n+1)","output":"constant"},{"instruction":"a, b = map(int, input().split(' '))\nres = 0\ntemp = 0\n\nif a%b == 0:\n    print(int(a\/b))\nelse:\n    while b!=0:\n        res += a\/\/b\n        a%=b\n        temp = a\n        a = b\n        b = temp\n    print(res)","output":"constant"},{"instruction":"from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\nfor _ in range(1):\n    n, cur, l, r=lst()\n    if l==1 and r==n:\n        print(0)\n    elif l==1 and r!=n:\n        print(abs(r-cur)+1)\n    elif r==n and l!=1:\n        print(abs(cur-l)+1)\n    else:\n        disa=abs(l-cur)\n        disb=abs(r-cur)\n        ans=min(disa, disb) + (r-l) +2\n        print(ans)","output":"constant"},{"instruction":"n=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nREVA=[None]*(n+1)\n\nfor i in range(n):\n    REVA[A[i]]=i+1\n\ntop=0\nANSLIST=[]\n\nfor b in B:\n    if REVA[b]>top:\n        ANSLIST.append(REVA[b]-top)\n        top=REVA[b]\n    else:\n        ANSLIST.append(0)\n\nfor ans in ANSLIST:\n    print(ans,end=\" \")","output":"linear"},{"instruction":"n = int(input())\nx, y = 1, 9\nn -= 1\nwhile n > x * y:\n    n -= x * y\n    x += 1\n    y *= 10\na = 10 ** (x - 1) + n \/\/ x\nprint(str(a)[n % x])","output":"logn"},{"instruction":"n, v = map(int, input().split())\nb = 0\nans = 0\nsss = 0\nfor i in range(1, n + 1):\n    while b < v:\n        if sss == n - 1:\n            break\n        sss += 1\n        ans += i\n        b += 1\n    b -= 1\nprint(ans)","output":"quadratic"},{"instruction":"def main():\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                cnt += 1\n    even = cnt % 2 == 0\n    q = int(input())\n    for _ in range(q):\n        l, r = map(int, input().split())\n        len = r - l + 1\n        pairs = len * (len-1) \/\/ 2\n        if pairs % 2 == 1:\n            even = not even\n        if even:\n            print('even')\n        else:\n            print('odd')\n\nmain()","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)\/\/b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\na, b = mp()\nc = 0\nx = 0\nwhile not (c>=b and c-b+x==a):\n    x += 1\n    c += x\nprint(a-x)","output":"logn"},{"instruction":"n = int(input())\na = sorted(list(map(int,input().split())))\nbal = 0\nif a.count(0)>1:\n    print('cslnb')\n    exit()\nif n-len(set(a))>1:\n    print('cslnb')\n    exit()\nif n-len(set(a))==1:\n    for i in range(1,n):\n        if a[i]==a[i-1]:\n            if a[i]-1 in a:\n                print('cslnb')\n                exit()\n            break\nif n==1:\n    print('cslnb' if not a[0] % 2 else 'sjfnb')\n    exit()\n\nfor i in range(n):\n    bal+=a[i]-i\nprint('sjfnb'if bal%2 else 'cslnb')","output":"linear"},{"instruction":"def check(s,a):\n    st=''\n    for i in range(len(s)):\n        st+=s[i]\n    st=int(st)\n    if (st>a):\n        return False\n    else:\n        return True\na = input()\nb = input()\ns=[]\nans=''\nfor i in range(len(a)):\n    s.append(a[i])\ns.sort()\nif (len(b)>len(a)):\n    for i in range(len(s)):\n        print(s[len(s)-i-1],end='')\nelse:\n    for i in range(len(a)):\n        j=0\n        temp2=-1\n        while ((j<len(s)-1) and (s[j+1]<=b[i])):\n            j+=1\n            if (s[j]!=s[j-1]):\n                temp2=j-1\n        temp=s[j]\n        s.remove(s[j])\n        if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]):\n            ans+=temp\n            if (ans[i]<b[i]):\n                for k in range(len(s)):\n                    ans+=s[len(s)-k-1]\n        else:\n            s.append(temp)\n            s.sort()\n            temp2=s[temp2]\n            ans+=temp2\n            s.remove(temp2)\n            for k in range(len(s)):\n                    ans+=s[len(s)-k-1]\n        if (len(ans)==len(a)):\n            break\nprint(ans)","output":"cubic"},{"instruction":"from sys import stdout\na, b = 0, 0\n\nmp = 29\n\nc, d = 0,0\n\npowers = [1]\nfor i in range(32):\n    powers.append(powers[-1]*2)\n\nqqq = 0\n\ndef get_ans(c, d):\n    global qqq\n    qqq += 1\n    a, b = 1073741823, 1073741821\n    a, b = 3, 1\n\n    print(c, d)\n\n    if (a^c) > (b^d):\n        print(1)\n        return -1\n    elif (a^c) < (b^d):\n        print(-1)\n        return 1\n    print(0)\n    return 0\n\ndef get_ans(c, d):\n    print('? {} {}'.format(c, d))\n    stdout.flush()\n    return -int(input())\n\nq = get_ans(0, 0)\n\nfor i in range(mp+1):\n    cp = mp - i\n    c += powers[cp]\n    d += powers[cp]\n\n    if q == 0:\n        continue\n    t = get_ans(c, d)\n\n    if t != q:\n\n        if t == 1:\n            a += powers[cp]\n            c -= powers[cp]\n        elif t == -1:\n            b += powers[cp]\n            d -= powers[cp]\n        q = get_ans(c, d)\n\nfor i in range(mp+1):\n    cp = mp - i\n\n    if c & powers[cp] > 0 and d & powers[cp] > 0:\n        c -= powers[cp]\n        t = get_ans(c, d)\n\n        if t < 0:\n            a += powers[cp]\n            b += powers[cp]\n\n        c += powers[cp]\n\nprint('!', a, b)","output":"constant"},{"instruction":"import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef ss(x):\n    return x * (x + 1) \/\/ 2\n\ndef sol(x):\n    if x == 0:\n        return 0\n    res = ss(x \/\/ 2) * 2\n    res1 = ss(x) - res\n    return res - res1\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        l, r = mp()\n        print(sol(r) - sol(l - 1))\n\ndebug = 0\nif debug:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nmain()\nif debug:\n    file.close()","output":"constant"},{"instruction":"import math\nfrom decimal import Decimal\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) \/ 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = math.floor((3 + discriminant) \/ 2)\n    res2 = math.floor((3 - discriminant) \/ 2)\n    res1 = max(res1, res2)\n    print(k - res1 + 1);","output":"logn"},{"instruction":"n, l, r, x = map(int, input().split())\nd = list(map(int, input().split()))\nans = 0\nfor i in range(pow(2, n)-1, -1, -1):\n\ts = bin(i)[2:]\n\twhile(len(s) < n):\n\t\ts = \"0\"+s\n\tdiff = 0\n\tt = []\n\tfor j in range(n):\n\t\tif(s[j]=='1'):\n\t\t\tdiff += d[j]\n\t\t\tt.append(d[j])\n\tt.sort()\n\n\tif(l <= diff <= r and t[-1]-t[0] >= x):\n\t\tans += 1\nprint(ans)","output":"np"},{"instruction":"n,m = map(int, input().split())\n\nclass Knight:\n\tdef __init__(self, andis, p, c):\n\t\tself.p = int(p)\n\t\tself.c = int(c)\n\t\tself.andis = int(andis)\n\t\tself.ans = self.c\n\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nx = []\nfor i in range(n):\n\tx.append(Knight(i, p[i], c[i]))\n\nx.sort(key=lambda x: x.p)\ncoins = []\nfor i in range(n-1):\n\tif len(coins) < m:\n\t\tcoins.append(x[i].c)\n\t\tcoins.sort()\n\telif len(coins) > 0:\n\t\tif coins[0] < x[i].c:\n\t\t\tcoins[0] = x[i].c\n\t\t\tcoins.sort()\n\tx[i+1].ans += sum(coins)\n\nx.sort(key=lambda x:x.andis)\nfor k in x:\n\tprint(k.ans, end=' ')","output":"nlogn"},{"instruction":"def fastio():\n\timport sys\n\tfrom io import StringIO\n\tfrom atexit import register\n\tglobal input\n\tsys.stdin = StringIO(sys.stdin.read())\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\tsys.stdout = StringIO()\n\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\n\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\n\nl, r = I()\nif l - r == 0:\n\tprint(0)\n\nelse:\n\tans = []\n\ta = list(format(l, '064b'))\n\tb = list(format(r, '064b'))\n\ti = 0\n\tll = l\n\trr = r\n\twhile a[i] == b[i]:\n\t\ti += 1\n\tfor i in range(i, 64):\n\t\tif a[i] == '0' and b[i] == '0':\n\t\t\tk = l ^ (2**(64 - i - 1))\n\t\t\tif k <= rr:\n\t\t\t\tl = k\n\t\t\t\ta[i] = '1'\n\t\telif a[i] == '1' and b[i] == '1':\n\t\t\tk = r - (2**(64 - i - 1))\n\t\t\tif k >= ll:\n\t\t\t\tb[i] = '0'\n\t\t\t\tr = k\n\tprint(l^r)","output":"logn"},{"instruction":"n, p, l, r = map(int, input().split())\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(p-r) + 1)\nelif r == n:\n    print(abs(p-l) + 1)\nelse:\n    print(min(abs(p-l), abs(p-r)) + r - l + 2)","output":"constant"},{"instruction":"N, MOD = map(int,input().split())\n\ndp = []\ncomps = [0]*(N+1)\n\nncr = [[1]]\nfor i in range(420):\n    tmp = [1]\n    for j in range(i):\n        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)\n    tmp.append(1)\n    ncr.append(tmp)\n\nfor i in range(N):\n    curr = list(comps)\n    curr[1] = pow(2,i,MOD)\n    for j in range(i - 1):\n        m = pow(2,i - j - 2)\n        for k in range(N):\n            num = j - k + 2\n            if num < 0: continue\n            mr = (m * ncr[i - j - 1 + num][num]) % MOD\n            curr[k + 1] += mr * dp[j][k]\n            curr[k + 1] %= MOD\n    dp.append(curr)\n\nprint(sum(dp[-1]) % MOD)","output":"cubic"},{"instruction":"from sys import stdin,stdout\nfrom math import ceil\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):\n    k,n,s,p=lst()\n    spp=ceil(n\/s)\n    tots=spp*k\n    print(ceil(tots\/p))","output":"constant"},{"instruction":"def main():\n    from sys import stdin\n    w, h, n = map(int, stdin.readline().split())\n    res, vrt, hor = [], [], []\n    vh = (vrt, hor)\n    for i, s in enumerate(stdin.read().splitlines()):\n        x = int(s[2:])\n        flag = s[0] == 'V'\n        vh[flag].append(i)\n        res.append([x, flag])\n    dim = []\n    for tmp, m in zip(vh, (h, w)):\n        tmp.sort(key=lambda e: res[e][0])\n        u = [None, [0]]\n        dim.append(u)\n        j = z = 0\n        for i in tmp:\n            x = res[i][0]\n            if z < x - j:\n                z = x - j\n            j = x\n            v = [u, res[i]]\n            u.append(v)\n            u = v\n            res[i].append(u)\n        v = [u, [m], None]\n        u.append(v)\n        dim.append(v)\n        if z < m - j:\n            z = m - j\n        dim.append(z)\n    l, r, wmax, u, d, hmax = dim\n    whmax = [wmax, hmax]\n    for i in range(n - 1, -1, -1):\n        x, flag, link = res[i]\n        u = whmax[flag]\n        res[i] = u * whmax[not flag]\n        link[0][2] = link[2]\n        link[2][0] = link[0]\n        v = link[2][1][0] - link[0][1][0]\n        if u < v:\n            whmax[flag] = v\n    print('\\n'.join(map(str, res)))\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"if __name__ == '__main__':\n\tn = int(input())\n\tnum = n + n\/\/2\n\tprint(num)","output":"constant"},{"instruction":"x, k = (int(x) for x in input().split())\nmod = 10**9 + 7\nif x == 0:\n    print(0)\n    quit()\nif k == 0:\n    print(x * 2 % mod)\n    quit()\nans = pow(2, k + 1, mod)\nans *= x\nans %= mod\nans -= pow(2, k, mod) - 1\nans %= mod\nans += mod\nans %= mod\nprint(ans)","output":"logn"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\nimport string\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    s1=list(get_string())\n    s2=list(get_string())\n    count=0\n    ans=[]\n    lower=string.ascii_lowercase\n    np=0\n    for i in lower:\n        if s1.count(i)!=s2.count(i):\n            np+=1\n            break\n    if np>0:\n        print(-1)\n        continue\n    pos=dict()\n    for i in range(n):\n        if s1[i] in pos:\n            pos[s1[i]].append(i)\n        else:\n            pos[s1[i]]=[i]\n    for i in range(n):\n        if s1[i]==s2[i]:\n            continue\n        else:\n            row=pos[s2[i]]\n            no=0\n            for j in range(len(row)):\n                if row[j]>i:\n                    no=row[j]\n                    break\n            for j in range(no,i,-1):\n                ans.append(j)\n            s1.pop(no)\n            s1.insert(i,s2[i])\n\n            pos = dict()\n            for j in range(n):\n                if s1[j] in pos:\n                    pos[s1[j]].append(j)\n                else:\n                    pos[s1[j]] = [j]\n    print(len(ans))\n    print(*ans)","output":"quadratic"},{"instruction":"n = int(input().rstrip())\narr = []\nmod = pow(10,9) + 7\nindent_num = 0\nfor i in range(n):\n    arr.append(input().rstrip())\n    if arr[i] == 'f':\n        indent_num += 1\ndp = [0 for i in range(indent_num + 1)]\nmax_indent = 0\n\ncur_indent = 0\npref = [0 for i in range(indent_num + 1)]\n\ndef cal_pref(dp, pref):\n    pref[0] = dp[0]\n    for i in range(1, len(dp)):\n        pref[i] = pref[i - 1] + dp[i]\n\nfor i in range(n):\n    if arr[i] == 'f':\n        cur_indent += 1\n        max_indent += 1\n        continue\n    cur = [0 for i in range(indent_num + 1)]\n    cal_pref(dp, pref)\n    for j in range(cur_indent,indent_num + 1):\n        res_idx = j - cur_indent\n        res_result = pref[res_idx - 1] if res_idx > 0 else 0\n        cur[j] = (pref[indent_num] - res_result) % mod\n\n    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]\n    dp = cur\n    cur_indent = 0\n\nprint(sum(dp) % mod)","output":"quadratic"},{"instruction":"def solve():\n    n = int(input())\n    a_dicts = [{}, {}]\n    for j in range(2):\n        for i in range(n):\n            x = input()\n            if x in a_dicts[j]:\n                a_dicts[j][x] += 1\n            else:\n                a_dicts[j][x] = 1\n            if x not in a_dicts[1 - j]:\n                a_dicts[1 - j][x] = 0\n    c = 0\n    for k in a_dicts[0]:\n        c += abs(a_dicts[0][k] - a_dicts[1][k])\n    return c \/\/ 2\n\nprint(solve())","output":"linear"},{"instruction":"n=int(raw_input())\narr=list(map(int,raw_input().split()))\ndict1={}\narr1=[0]*n\nfor i in range(n):\n\tarr1[arr[i]-1]=i\nfor i in range(n):\n\tdict1[i+1]=[]\nfor i in range(n):\n\tfor j in range(i-arr[i],-1,-arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\n\tfor j in range(i+arr[i],n,arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\nstrarr=['.']*n\n\nfor i in range(n-1,-1,-1):\n\tif(len(dict1[arr[arr1[i]]])==0):\n\t\tstrarr[arr1[i]]='B'\n\telse:\n\t\tif(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):\n\t\t\tstrarr[arr1[i]]='A'\n\t\telse:\n\t\t\tflag=0\n\t\t\tfor j in dict1[arr[arr1[i]]]:\n\n\t\t\t\tif(strarr[arr1[j-1]]=='B'):\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tstrarr[arr1[i]]='A'\n\t\t\telse:\n\t\t\t\tstrarr[arr1[i]]='B'\n\nprint(\"\".join(x for x in strarr))","output":"quadratic"},{"instruction":"n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nfor i in a:\n    if i in b:\n        print(i, end=' ')","output":"quadratic"},{"instruction":"import bisect\nfrom itertools import accumulate\nimport os\nimport sys\nimport math\nfrom decimal import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input():\n    return sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef SieveOfEratosthenes(n):\n    prime = []\n    primes = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n\n        if primes[p] == True:\n            prime.append(p)\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return prime\n\ndef primefactors(n):\n    fac = []\n    while n % 2 == 0:\n        fac.append(2)\n        n = n \/\/ 2\n    for i in range(3, int(math.sqrt(n)) + 2):\n        while n % i == 0:\n            fac.append(i)\n            n = n \/\/ i\n    if n > 1:\n        fac.append(n)\n    return sorted(fac)\n\ndef factors(n):\n    fac = set()\n    fac.add(1)\n    fac.add(n)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            fac.add(i)\n            fac.add(n \/\/ i)\n    return list(fac)\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a \/\/ m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\nn, k = map(int, input().split())\na = list(sorted(map(int, input().split()), reverse=True))\ns = set()\n\nfor i in range(len(a)):\n    if a[i] * k not in s:\n        s.add(a[i])\n\nprint(len(s))","output":"nlogn"},{"instruction":"import collections\nimport sys\n\ndef can_win(i, dp):\n    if i in dp:\n        return dp[i]\n    else:\n        for next in possible[i]:\n            if not can_win(next, dp):\n                dp[i] = True\n                return True\n        dp[i] = False\n        return False\n\ndata = sys.stdin.readlines()\nnb = int(data[0])\nnums = data[1].split(' ')\nnums = [int(c) for c in nums]\npossible = [[] for _ in range(nb)]\nfor i in range(nb):\n    if nums[i] == 1:\n        possible[i] = [k for k in range(nb) if k != i]\n    else:\n        for j in range(i+nums[i], nb, nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n        for j in range(i-nums[i], -1, -nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n\nres = \"\"\ndp = {}\nfor i in range(nb):\n    if can_win(i, dp):\n        res += \"A\"\n    else:\n        res += \"B\"\nprint(res)","output":"quadratic"},{"instruction":"from sys import stdin, stdout\ninput = stdin.readline\n\nn,m,K = map(int,input().split())\nedges = []\nfor i in range(n):\n    edges.append([[]])\n    lis = list(map(int,input().split()))\n    for j in range(m-1):\n        edges[i][j].append((1,0,lis[j]))\n        edges[i].append([])\n        edges[i][j+1].append((-1,0,lis[j]))\nfor i in range(n-1):\n    lis = list(map(int,input().split()))\n    for j in range(m):\n        edges[i][j].append((0,1,lis[j]))\n        edges[i+1][j].append((0,-1,lis[j]))\n\nif K%2==1:\n    lis = []\n    for i in range(n):\n        lis.append([-1]*m)\nelse:\n    lis = []\n    for i in range(n):\n        lis.append([0]*m)\n\n    for k in range(1,(K\/\/2)+1):\n        new_lis = []\n        for i in range(n):\n            new_lis.append([0]*m)\n        for i in range(n):\n            for j in range(m):\n                dist = []\n                for e in edges[i][j]:\n\n                    dist.append(e[2] + lis[i+e[1]][j+e[0]])\n                new_lis[i][j] = min(dist)\n        lis = new_lis\n    for i in range(n):\n        for j in range(m):\n            lis[i][j] *= 2\n\nfor i in lis:\n    print(*i)","output":"cubic"},{"instruction":"def replace(arr):\n    if arr==[1]*len(arr):\n        arr[-1]=2\n        print(*sorted(arr))\n        return \"\"\n    arr[arr.index(max(arr))]=1\n    print(*sorted(arr))\n    return \"\"\na=input()\nlst=list(map(int,input().strip().split()))\nprint(replace(lst))","output":"nlogn"},{"instruction":"n = int(input())\nboard = list(map(int, input().strip().split()))\nboard.insert(0,0)\nhashed = [0] * (n+1)\nfor i in range(n+1):\n\thashed[board[i]] = i\nanswer = ['C'] * (n+1)\nfor i in range(n,0,-1):\n\tflag = 0\n\tk = hashed[i] - board[hashed[i]]\n\twhile(k > 0):\n\t\tif(answer[k] == 'B'):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tk-=board[hashed[i]]\n\tk = hashed[i] + board[hashed[i]]\n\twhile(k <= n and k != 0):\n\t\tif(answer[k] == 'B'):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tk+=board[hashed[i]]\n\tif(flag == 1):\n\t\tanswer[hashed[i]] = 'A'\n\telse:\n\t\tanswer[hashed[i]] = 'B'\nanswer.pop(0)\nprint(''.join(answer))","output":"nlogn"},{"instruction":"def main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*-(-nSquares\/\/2)\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [(sum(1 for i in range(nSquares) if piece[i] != squares[:-1][i]),\n                          sum(1 for i in range(nSquares) if piece[i] != squares[1:][i]))\n                         for piece in brokenPieces]\n    possible_nSquares.sort(key=lambda x: x[0])\n\n    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]\n\nif __name__ == '__main__':\n    print(main())","output":"quadratic"},{"instruction":"n = int(input())\na = [int(_) & 1 for _ in input().split()]\nv = [a[0]]\nfor i in range(1, n):\n    if v and v[-1] == a[i]:\n        v.pop()\n    else:\n        v.append(a[i])\nprint(\"NO\" if len(v) > 1 else \"YES\")","output":"linear"},{"instruction":"import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn = int(input())\nc = [int(i) for i in input().split()]\na = [int(i)-1 for i in input().split()]\nvis = [-1]*n\nans = 0\nfor i in range (n):\n    ind = i\n    while(vis[ind]==-1):\n        vis[ind]=i\n        ind = a[ind]\n    if vis[ind]==i:\n        start = ind\n        ind = a[ind]\n        cost = c[start]\n        while(ind!=start):\n            cost = min(cost, c[ind])\n            ind = a[ind]\n        ans+=cost\nprint(ans)","output":"linear"},{"instruction":"n=int(input());\nprint('4 '+str(n-4) if n%2==0 else '9 '+str(n-9))","output":"constant"},{"instruction":"import math\n\nn, r = map(float, input().split())\na = math.pi \/ n\ns = math.sin(a)\nR = (r * s) \/ (1 - s)\nprint(R)","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\na=list(map(int,input().rstrip()))\nb=list(map(int,input().rstrip()))\nif len(a)<len(b):\n    a.sort(reverse=True)\n    print(''.join(map(str,a)))\nelse:\n    ans=-1\n    ca=[0]*10\n    for aa in a:\n        ca[aa]+=1\n    lim=-1\n    for i in range(len(a)):\n        if ca[b[i]]:\n            candi=[]\n            for j in range(i):\n                candi.append(b[j])\n            use=-1\n            for j in range(b[i]-1,-1,-1):\n                if ca[j]:\n                    use=j\n                    ca[j]-=1\n                    candi.append(j)\n                    break\n            if use<0:\n                ca[b[i]]-=1\n                continue\n            else:\n                for j in range(10)[::-1]:\n                    candi.extend([j]*ca[j])\n                res=''.join(map(str,candi))\n                res=int(res)\n                ans=max(ans,res)\n                ca[use]+=1\n                ca[b[i]]-=1\n        else:\n            candi=[]\n            for j in range(i):\n                candi.append(b[j])\n            use=-1\n            for j in range(b[i]-1,-1,-1):\n                if ca[j]:\n                    use=j\n                    ca[j]-=1\n                    candi.append(j)\n                    break\n            if use<0:\n                break\n            else:\n                for j in range(10)[::-1]:\n                    candi.extend([j]*ca[j])\n                res=''.join(map(str,candi))\n                res=int(res)\n                ans=max(ans,res)\n                ca[use]+=1\n                break\n    flg=True\n    ca=[0]*10\n    for i in range(len(a)):\n        ca[a[i]]+=1\n    for i in range(len(a)):\n        if ca[b[i]]:\n            ca[b[i]]-=1\n        else:\n            flg=False\n    if flg:\n        ans=max(ans,int(''.join(map(str,b))))\n    print(ans)","output":"cubic"},{"instruction":"import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n\nelse:\n    sys.stdin = open('input.txt')\n\nn = ria()[0]\nif n == 1:\n    print(1)\n    exit(0)\n\nif n == 2:\n    print(1, 2)\n    exit(0)\n\nif n == 3:\n    print(1, 1, 3)\n    exit(0)\n\nar = [0] * 30\n\nfor i in range(30):\n    ar[i] = n \/\/ (2 ** i) - n \/\/ (2 ** (i + 1))\nsd = 0\nfor i in range(30):\n    if sd == n - 1:\n        if n==(2**i):\n            print(2**i)\n        else:\n            print(n-n%(2**(i-1)))\n        exit(0)\n    for j in range(ar[i]):\n        print(2 ** i, end=' ')\n        sd += 1","output":"linear"},{"instruction":"n,m,k = map(int,input().split())\nright = [[9999999 for i in range(m-1)] for j in range(n)]\ndown =  [[9999999 for i in range(m)] for j in range(n-1)]\nfor i in range(n):\n    right[i] = list(map(int,input().split()))\nfor i in range(n-1):\n    down[i] = list(map(int,input().split()))\n\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(\"-1\",end=\" \")\n        print()\nelse:\n    k = k\/\/2\n    row = n\n    col = m\n    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]\n    for steps in range(k+1):\n        for i in range(row):\n            for j in range(col):\n                if(steps==0):\n                    dp[steps][i][j] = 0\n                    continue\n                ans = 99999999999\n                if(i>0):\n                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])\n                if(i<n-1):\n                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])\n                if(j<m-1):\n                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])\n                if(j>0):\n                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])\n                dp[steps][i][j] = ans\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[k][i][j],end=\" \")\n        print()","output":"cubic"},{"instruction":"from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\nn, k = map(int, stdin.readline().split())\nstdout.write(str((n * 2 + k - 1) \/\/ k + (n * 5 + k - 1) \/\/ k + (n * 8 + k - 1) \/\/ k))","output":"constant"},{"instruction":"nr, ng, nb = map(int, input().split())\nr = sorted([int(i) for i in input().split()])\ng = sorted([int(i) for i in input().split()])\nb = sorted([int(i) for i in input().split()])\n\ndp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            val = 0\n            if i - 1 >= 0 and j - 1 >= 0:\n                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])\n            if i - 1 >= 0 and k - 1 >= 0:\n                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])\n            if j - 1 >= 0 and k - 1 >= 0:\n                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])\n            dp[i][j][k] = val\n\nprint(dp[nr][ng][nb])","output":"cubic"},{"instruction":"n=int(input())\ns=[4,7,44,77,47,74,444,777,477,447,744,474,747,774]\nt=0\nfor i in s:\n    if n%i==0:\n        print(\"YES\")\n        t=1\n        break\nif t==0:\n    print(\"NO\")","output":"constant"},{"instruction":"import math\ng=0\nn=int(input())\nb=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=dict()\ndp[0]=0\ns=set([0])\nfor i in range(n):\n    for j in s:\n        g=math.gcd(j,b[i])\n        if g in dp:\n            dp[g]=min(dp[g],dp[j]+c[i])\n        else:\n            dp[g]=dp[j]+c[i]\n\n    s=set(dp.keys())\n\nif 1 in dp.keys():\n    print(dp[1])\nelse:\n    print(-1)","output":"np"},{"instruction":"from sys import stdin,stdout\nstdout.flush()\ndef qu(a,b):\n    print(\"?\",a,b)\n    return int(input())\na=0\nb=0\nbig=qu(a,b)\nfor i in range(29,-1,-1):\n    x=2**i\n    f=qu(a+x,b)\n    l=qu(a,b+x)\n    if l==f:\n        if big==1:\n            a+=x\n        else:\n            b+=x\n        big=f\n    elif f==-1:\n        a+=x\n        b+=x\nprint(\"!\",a,b)","output":"constant"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    t=int(input())\n    tup=[]\n    for _ in range(t):\n        l,r=inar()\n        tup.append([l,r])\n    tup.sort()\n    l=tup[0][0]\n    r=tup[0][1]\n    prefix=[[l,r]]\n    for i in range(1,t):\n        if l>tup[i][1] or r<tup[i][0]:\n            prefix.append([-1,-1])\n            for j in range(i+1,t):\n                prefix.append([-1, -1])\n            break\n\n        l=max(l,tup[i][0])\n        r=min(r,tup[i][1])\n        prefix.append([l,r])\n    l = tup[-1][0]\n    r = tup[-1][1]\n    suffix = []\n    for i in range(t):\n        suffix.append([-1,-1])\n    suffix[-1][0]=l\n    suffix[-1][1]=r\n    for i in range(t-2,-1,-1):\n        if l > tup[i][1] or r < tup[i][0]:\n            break\n\n        l = max(l, tup[i][0])\n        r = min(r, tup[i][1])\n        suffix[i][0]=l\n        suffix[i][1]=r\n    ans=0\n    for i in range(t):\n        if i==0:\n            ans=max(ans,abs(suffix[i+1][0]-suffix[i+1][1]))\n            continue\n        if i==t-1:\n            ans=max(ans,abs(prefix[i-1][0]-prefix[i-1][1]))\n            continue\n        prefix_l=prefix[i-1][0]\n        prefix_r=prefix[i-1][1]\n        suffix_l=suffix[i+1][0]\n        suffix_r=suffix[i+1][1]\n        l=max(prefix_l,suffix_l)\n        r=min(prefix_r,suffix_r)\n        ans=max(ans,max(0,r-l))\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n\n        res = temp\n\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()","output":"cubic"},{"instruction":"l,r=map(int,input().split())\nlxr = l^r\nmsb = 0\nwhile(lxr):\n\tmsb+= 1\n\tlxr>>= 1\nm = 0\nt=1\nwhile msb:\n\tm += t\n\tt <<= 1\n\tmsb -= 1\nprint(m)","output":"logn"},{"instruction":"import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\nn, m, k1 = [int(x) for x in input().split()]\n\narr = [0 for i in range(n)]\nfor i in range(n):\n    arr[i] = [int(x) for x in input().split()]\n\nbrr = [0 for i in range(n - 1)]\nfor i in range(n - 1):\n    brr[i] = [int(x) for x in input().split()]\n\ndp = [[[0 for k in range(11)] for j in range(m)] for i in range(n)]\n\nfor k in range(1, 11):\n    for i in range(n):\n        for j in range(m):\n                dp[i][j][k] = 10 ** 9\n                if i > 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + brr[i - 1][j] * 2)\n                if i < n - 1:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + brr[i][j] * 2)\n                if j > 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + arr[i][j - 1] * 2)\n                if j < m - 1:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + arr[i][j] * 2)\n\nfor i in range(n):\n    for j in range(m):\n        if(k1 % 2):\n            print(-1,end=\" \")\n        else:\n            print(dp[i][j][k1 \/\/ 2],end=\" \")\n    print()","output":"cubic"},{"instruction":"n, k = map(int, input().split())\n\nif n == 1:\n    print(0)\nelif k + (k - 1) * (k - 2) \/\/ 2 < n:\n    print(-1)\nelse:\n    l = 0\n    r = k - 1\n    while r - l > 1:\n        m = (l + r) \/\/ 2\n        if  (2*k - m + 1) * m \/\/ 2 - (m - 1) >= n:\n            r = m\n        else:\n            l = m\n    print(r)","output":"logn"},{"instruction":"import sys\nn=int(input())\nind=0\ndig=0\nfor i in range(1,12):\n    dig+=i*10**(i-1)*9\n\n    if dig>n:\n        ind=i-1\n        rt=dig-i*10**(i-1)*9\n        break\nn-=rt\nno=10**ind\n\nif n==0:\n    print(9)\n    sys.exit()\nu=n\nn-=(n\/\/(ind+1))*(ind+1)\nno+=max(0,(u\/\/(ind+1))-1)\n\nif n==0:\n    print(str(no)[-1])\nelse:\n    no+=1\nwhile(n>0):\n    if n<=ind+1:\n        e=str(no)\n        print(e[n-1])\n    n-=ind+1\n    no+=1","output":"logn"},{"instruction":"R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort()\ng.sort()\nb.sort()\n\ndp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]\n\nfor j in range(1,G+1):\n    for k in range(1,B+1):\n        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]\n\nfor i in range(1,R+1):\n    for k in range(1,B+1):\n        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        for k in range(1,B+1):\n            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])\n            else:\n                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n\nprint(dp[R][G][B])","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\nmaxn = int(1510)\nST = [0 for _ in range(4 * maxn)]\ndef update(id, l, r, val):\n    if l == r == val:\n        ST[id] = 1\n        return\n    if l > val or r < val:\n        return\n    mid = int((l + r) \/ 2)\n    update(id * 2, l, mid, val)\n    update(id * 2 + 1, mid + 1, r, val)\n    ST[id] = ST[id * 2] + ST[id * 2 + 1]\n    return\ndef get(id, l, r, x, y):\n    if l > y or r < x:\n        return 0\n    if x <= l and r <= y:\n        return ST[id]\n    mid = int((l + r) \/ 2)\n    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)\nn, res = int(input()), 0\nfor x in list(map(int, input().split())):\n    res ^= get(1, 1, n, x + 1, n) % 2\n    update(1, 1, n, x)\nfor i in range (int(input())):\n    x, y = list(map(int, input().split()))\n    if int((y - x) * (y - x + 1) \/ 2) & 1:\n        res ^= 1\n    if res:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"from math import factorial as f\nn = input()\ns = input()\nquest = s.count(\"?\")\nplusn = n.count(\"+\")\nplus = s.count(\"+\")\ntry:\n\tcomb = f(quest)\/(f(plusn - plus) * f(quest - (plusn - plus)))\n\tprint(\"%.12f\" %(comb\/2 ** quest))\nexcept:\n\tprint(\"%.12f\" %0)","output":"np"},{"instruction":"A,B = map(int,input().split())\nprint((1<<(A^B).bit_length()) - 1)","output":"logn"},{"instruction":"import sys\ninput=sys.stdin.readline\nn=int(input())\nc=[\" \"]+[input().rstrip() for i in range(n)]\nmod=10**9+7\ndp=[[0]*(n+1) for i in range(n+1)]\ndp[1][0]=1\nsdp=[0]*(n+1)\nsdp[0]=1\nfor i in range(1,n+1):\n    if i>=2 and c[i-1]==\"f\":\n        for j in range(1,n+1):\n            dp[i][j]=dp[i-1][j-1]\n            dp[i][j]%=mod\n        dp[i][0]=0\n    else:\n        for j in range(n+1):\n            dp[i][j]=sdp[j]\n            dp[i][j]%=mod\n    sdp=[dp[i][j] for j in range(n+1)]\n    for j in range(1,n+1)[::-1]:\n        sdp[j-1]+=sdp[j]\n        sdp[j-1]%=mod\nprint(sdp[0]%mod)","output":"quadratic"},{"instruction":"def if_spruce(n,l,s):\n    d=[0]*(n+1)\n    for i in range(1,n+1):\n        if i not in s:\n            d[l[i]]+=1\n    for i in range(1,n+1):\n        if i in s and d[i]<3:\n            return \"No\"\n    return \"Yes\"\n\nn=int(input())\nl,a=[0]*2,0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\ns=set(l)\nprint(if_spruce(n,l,s))","output":"linear"},{"instruction":"n=int(input())\nif n==1:\n    print(1)\nelse:\n    p=list(map(int,input().split()))\n    children=[]\n    for i in range(n):\n        children.append([])\n    for i in range(n-1):\n        children[p[i]-1].append(i+1)\n    layers=[1]+[0]*(n-1)\n    layer=[0]\n    num=2\n    bylayer=[]\n    while len(layer)>0:\n        bylayer.append(layer)\n        newlayer=[]\n        for vert in layer:\n            for child in children[vert]:\n                layers[child]=num\n                newlayer.append(child)\n        layer=newlayer\n        num+=1\n    bylayer=bylayer[::-1]\n    count=[0]*n\n    for layer in bylayer:\n        for vert in layer:\n            if children[vert]==[]:\n                count[vert]=1\n            else:\n                count[vert]=sum(count[v] for v in children[vert])\n    count.sort()\n    out=\"\"\n    for guy in count:\n        out+=str(guy)+\" \"\n    print(out)","output":"quadratic"},{"instruction":"l,r=map(int,input().split())\nz=l^r\nc=0\nif(z==0):\n    print(0)\n    exit()\nwhile(z):\n\tc+=1;\n\tz>>=1;\nx='1'*c\nprint(int(x,2))","output":"logn"},{"instruction":"n, k = map(int, input().split())\ngrid = [['.']*n for i in range(4)]\nif k % 2 == 0:\n    for i in range(k\/\/2):\n        grid[1][1+i], grid[2][1+i] = '\nelse:\n    m = n\/\/2\n    if k > n - 2:\n        for i in range(1, n-1):\n            grid[1][i] = '\n        for i in range(1, (k-n+2)\/\/2 + 1):\n            grid[2][m+i], grid[2][m-i] = '\n    else:\n        grid[1][m] = '\n        if k > 1:\n            for i in range(1, k\/\/2 + 1):\n                grid[1][m-i], grid[1][m+i] = '\nprint('YES')\nfor i in grid:\n    print(''.join(i))","output":"linear"},{"instruction":"import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\nn,m = mints()\na = list(mints())\nb = list(mints())\nl = [None]*(n+m)\nr = [None]*(n+m)\nc = [0]*(n+m)\nx = None\nfor i in range(len(a)):\n\tl[i] = x\n\tif b[i] == 1:\n\t\tx = i\nx = None\nfor i in range(len(a)-1,-1,-1):\n\tr[i] = x\n\tif b[i] == 1:\n\t\tx = i\nfor i in range(len(a)):\n\tif b[i] == 0:\n\t\taa = a[i]\n\t\tll = l[i]\n\t\trr = r[i]\n\t\tif ll == None:\n\t\t\tif rr != None:\n\t\t\t\tc[rr] += 1\n\t\telif rr == None:\n\t\t\tc[ll] += 1\n\t\telse:\n\t\t\tif aa-a[ll] <= a[rr]-aa:\n\t\t\t\tc[ll] += 1\n\t\t\telse:\n\t\t\t\tc[rr] += 1\n\nfor i in range(len(a)):\n\tif b[i] == 1:\n\t\tprint(c[i], end=' ')","output":"linear"},{"instruction":"print(int(input())\/\/2*3)","output":"constant"},{"instruction":"n = int(input())\nm = int(n**.5)\na = []\n\nfor i in range(0, n, m):\n    for j in range(i, min(i+m, n)):\n        a.append(min(i+m, n)-j + i)\n\nprint(' '.join(str(_) for _ in a))","output":"linear"},{"instruction":"from sys import stdin\n\nmemo = {}\ndef max_splits(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n in memo:\n        return memo[n]\n    result = 4 * max_splits(n - 1) + 1\n    memo[n] = result\n    return result\n\nt = int(stdin.readline())\nfor i in range(t):\n    n, k = [int(s) for s in stdin.readline().strip().split()]\n\n    min_splits = 1\n    path_count = 3\n\n    if n > 75:\n        print(\"YES\", n - 1)\n        continue\n\n    square_size = n - 1\n    max_buffer = max_splits(square_size)\n\n    while min_splits + path_count <= k and square_size > 0:\n        min_splits += path_count\n        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)\n        path_count = 2 * path_count + 1\n        square_size -= 1\n\n    if min_splits <= k <= min_splits + max_buffer:\n        print(\"YES\", square_size)\n    else:\n        print(\"NO\")","output":"quadratic"},{"instruction":"import math\n\nn, k = input().split(\" \")\n\nn = int(n)\nk = int(k)\n\nvariableone = 2 * (n + k)\n\nvariabletwo = (-3 + math.sqrt(9 - 4 * 1 * (-1 * variableone))) \/ 2\n\nvariabletwo = int(variabletwo)\n\ny = n - variabletwo\n\nprint(y)","output":"logn"},{"instruction":"import math\ndef main():\n    x = input()\n    y = input()\n    goal = x.count('+') - y.count('+')\n    options = y.count('?')\n    if options == 0:\n        if goal == options:\n            print(1)\n        else:\n            print(0)\n    else:\n        if (goal > options):\n            print(0)\n        else:\n            if goal < 0:\n                print(0)\n            else:\n                print(math.factorial(options)\/math.factorial(goal)\/math.factorial(options-goal)\/(2**options))\nmain()","output":"np"},{"instruction":"import sys\ninput=sys.stdin.readline\nn=int(input())\nc=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    c.append((a,b,_))\nc.sort(key=lambda x:(x[0],-x[1]))\na=c[0][1]\nb=c[0][2]\nan1=-1\nan2=-1\nfor i in range(1,n):\n    if c[i][1]<=a:\n        an2=b+1\n        an1=c[i][2]+1\n        break\n    else:\n        a=c[i][1]\n        b=c[i][2]\nprint(an1,an2)","output":"nlogn"},{"instruction":"mod = 10**9 + 7\nx, k = list(map(int, input().split()))\nif x == 0:\n    print(0)\n    exit()\nans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod\nprint(ans)","output":"logn"},{"instruction":"def stones_after(n, s):\n\tfor i in s:\n\t\tif i == '-':\n\t\t\tn -= 1\n\t\telse:\n\t\t\tn += 1\n\t\tif n < 0:\n\t\t\treturn -1\n\treturn n\n\nn = int(input().strip())\ns = input().strip()\nans = 99999999\nfor i in range(n+1):\n\tstones = stones_after(i, s)\n\tif stones != -1:\n\t\tans = min(ans, stones)\nprint(ans)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nQ=int(input())\nLR=[list(map(int,input().split())) for i in range(Q)]\n\ndef SUM(i):\n    plus=i\/\/2\n    minus=(i+1)\/\/2\n\n    P=(2+2*plus)*plus\/\/2\n    M=(1+2*minus-1)*minus\/\/2\n    return P-M\n\nfor l,r in LR:\n    print(SUM(r)-SUM(l-1))","output":"constant"},{"instruction":"MOD = int(1e9+7)\nn = int(input())\na = [input() for i in range(n)]\ndp = [1]\nfor i in range(n):\n    if a[i] == 'f':\n        dp.append(0)\n        continue\n    for j in range(1, len(dp)):\n        dp[j] = (dp[j] + dp[j-1]) % MOD\nprint(dp[-1])","output":"quadratic"},{"instruction":"def max_xor_naive(l, r):\n    max_xor = 0\n    xor = 0\n\n    for a in range(l, r+1):\n        for b in range(a+1, r+1):\n            xor = a^b\n            if xor>max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef max_xor_efficient(l, r):\n    s1 = bin(l)[2:]\n    s2 = bin(r)[2:]\n    l1 = len(s1)\n    l2 = len(s2)\n    if l1<l2:\n        return pow(2, l2) - 1\n    x = 0\n    for i in range(0, l1):\n        if s1[i]!=s2[i]:\n            return pow(2, l1-i) - 1\n\n    return 0\n\nl, r = map(int, input().split())\n\nans2 = max_xor_efficient(l, r)\nprint(ans2)","output":"logn"},{"instruction":"s=input()\nn=len(s)\nm=n-1;\nwhile m>0:\n    f=False\n    for i in range(0,n-m):\n        for j in range(i+1,n-m+1):\n            x=True\n            for k in range(0,m):\n                if s[i+k]!=s[j+k]:\n                    x=False\n                    break\n            if x:\n                f=True\n                break\n        if f:\n            break\n    if f:\n        break\n    m -= 1\nprint(m)","output":"cubic"},{"instruction":"import decimal\ndecimal.getcontext().prec = 100\n\na, v = map(decimal.Decimal, input().split())\nl, d, w = map(decimal.Decimal, input().split())\n\ndef DecimalPow(a, b):\n    return decimal.Decimal(a) ** decimal.Decimal(b)\n\ndef getLastT(v1, dist):\n    t1 = (v - v1) \/ a\n    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)\n    if d1 >= dist:\n        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) \/ a\n    t2 = (dist - d1) \/ v\n    return t1 + t2\n\nif w >= v:\n    t1 = v \/ a\n    if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l:\n        t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) \/ v\n    else:\n        t1 = (decimal.Decimal(2) * l \/ a) ** decimal.Decimal(0.5)\n        t2 = 0\n    t = t1 + t2\n    print('{t:.5f}'.format(t = t))\n\nelif (w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a) >= d:\n    t = getLastT(0, l)\n    print('{t:.5f}'.format(t = t))\n\nelif (v ** decimal.Decimal(2) - 0) \/ (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a) >= d:\n    t2 = -w \/ a + ((w ** decimal.Decimal(2)) \/ (2 * (a ** decimal.Decimal(2))) + d \/ a) ** decimal.Decimal(0.5)\n    t1 = w \/ a + t2\n    t3 = getLastT(w, l - d)\n    t = t1 + t2 + t3\n    print('{t:.5f}'.format(t = t))\n\nelse:\n    t1 = v \/ a\n    t3 = (v - w) \/ a\n    t2 = (d - ((v ** decimal.Decimal(2) - 0) \/ (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) \/ (decimal.Decimal(2) * a))) \/ v\n    t4 = getLastT(w, l - d)\n    t = t1 + t2 + t3 + t4\n    print('{t:.5f}'.format(t = t))","output":"constant"},{"instruction":"n, q = map(int, input().split())\nnums = list(map(int, input().split()))\n\nm = max(nums)\n\nab = []\nwhile nums[0] < m:\n    ab.append([nums[0], nums[1]])\n    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))\n\nfor i in range(q):\n    mj = int(input())\n    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))\n    print(a + \" \" + b)","output":"linear"},{"instruction":"a = input()\nb = input()\ndigits = {}\ndef greedy(digits,s):\n    for i in range(9,-1,-1):\n        d = str(i)\n        if d in digits:\n            while digits[d] > 0:\n                s += d\n                digits[d] -= 1\n    return s\nfor d in a:\n    if d in digits:\n        digits[d] += 1\n    else:\n        digits[d] = 1\nif len(a) < len(b):\n    print(greedy(digits,\"\"))\nelse:\n    ind = 0\n    cur = \"\"\n    back = False\n    done = False\n    while 1:\n        if ind == len(a) or done == True:\n            break\n        found = False\n        for i in range(9,-1,-1):\n            x = str(i)\n            if i == int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                digits[x] -= 1\n                cur += x\n                break\n            elif i < int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                done = True\n                digits[x] -= 1\n                cur += x\n                print(greedy(digits,cur))\n                break\n        if found == False:\n            back = True\n            break\n        ind += 1\n\n    if back == False and done == False:\n        print(cur)\n    elif done == False:\n        for i in range(ind-1,-1,-1):\n            digits[cur[i]] += 1\n            for j in range(9,-1,-1):\n                d = str(j)\n                if j < int(b[i]) and d in digits and digits[d] > 0:\n                    done = True\n                    s = cur[:i]\n                    s += d\n                    digits[d] -= 1\n                    print(greedy(digits,s))\n                    break\n            if done:\n                break","output":"cubic"},{"instruction":"def init_input():\n    import os\n    from sys import stdin\n    it = iter(os.read(stdin.fileno(), 10 ** 7).split())\n    return lambda: next(it).decode(), lambda: int(next(it)), lambda: float(next(it))\nns, ni, nf = init_input()\n\nMOD = 10 ** 9 + 7\n\nn, q = ni(), ni()\ns = 'x' + ns()\nc = [0] * (n + 1)\nfor i in range(1, n + 1):\n    c[i] = c[i - 1] + (s[i] == '1')\n\np2 = [1] * (2 * n + 1)\nfor i in range(1, 2 * n + 1):\n    p2[i] = p2[i - 1] * 2 % MOD\n\nout = []\nfor qq in range(q):\n    l, r = ni(), ni()\n    o = c[r] - c[l - 1]\n    z = (r - l + 1) - o\n    ans = (p2[o + z] - 1 - p2[z] + 1) % MOD\n    out.append(ans)\nprint(*out, sep='\\n')","output":"linear"},{"instruction":"l,r=map(int,input().split())\nr1=len(bin(r))-3\nl1=len(bin(l))-3\nans=0\nwhile(l>0):\n    if l1==r1:\n        r-=(1<<l1)\n        l-=(1<<l1)\n    else:\n        ans=(1<<(r1+1))-1\n        break\n\n    z1=min(l,r)\n    z2=max(l,r)\n    l,r=z1,z2\n    r1 = len(bin(r)) - 3\n    l1 = len(bin(l)) - 3\n\nif ans==0:\n    if l1==r1:\n        if r==1:\n            print(1)\n        else:\n            print(0)\n    else:\n        print((1<<(r1+1))-1)\n\nelse:\n    print(ans)","output":"logn"},{"instruction":"s=input()\na=list(map(int,input().split()))\nk=sorted(a)\nb=0\nq=0\nm=0\nfor i in k:\n    b=b+i\nfor i in k[::-1]:\n    q=q+i\n    m=m+1\n    if q>(b\/2):\n        break\nprint(m)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.buffer.readline\n\ndef process(A):\n    d = {}\n    final = set([])\n    for x in A:\n        if x not in d:\n            d[x] = 0\n        d[x]+=1\n        if d[x] >= 4:\n            return [x, x, x, x]\n        if d[x] >= 2:\n            final.add(x)\n    L = sorted(final)\n    answer = [float('inf'), None, None]\n    for i in range(len(L)-1):\n        a = L[i]\n        b = L[i+1]\n        a1 = a\/b+b\/a\n        answer = min(answer, [a1, a, b])\n    a1, a, b = answer\n    return [a, a, b, b]\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    a, b, c, d = process(A)\n    print(f'{a} {b} {c} {d}')","output":"nlogn"},{"instruction":"n = int(input())\ndicta = {}\ndictb = {}\nfor i in range(n):\n    a, x = map(int, input().split())\n    dicta[a] = x\nm = int(input())\nfor i in range(m):\n    b, y = map(int, input().split())\n    dictb[b] = y\nans = 0\nfor i in dicta.keys():\n    if i in dictb.keys():\n        ans += max(dicta[i], dictb[i])\n        del dictb[i]\n    else :\n        ans += dicta[i]\nfor i in dictb.values():\n    ans += i\nprint(ans)","output":"nlogn"},{"instruction":"from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nMAX = 10**9\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n\n    return True\n\ndef mhd(a,b,x,y):\n\n    return abs(a-x)+abs(b-y)\n\nn,m = map(int,input().split())\nv = []\nh = []\nfor _ in range(n):\n    v.append(int(input()))\n\nfor _ in range(m):\n    x1,x2,y = map(int,input().split())\n    if(x1==1):\n        h.append(x2)\nlh = len(h)\nh.sort()\nv.sort()\nif not lh:\n    print(0)\nelif n==0:\n    print(lh-bl(h,MAX))\nelse:\n    mn = n+lh-bl(h,MAX)\n    for i in range(n):\n        mn = min(mn,lh-bl(h,v[i])+i)\n    print(mn)","output":"nlogn"},{"instruction":"def read_int(): return int(input())\ndef read_ints(): return list(map(int, input().split()))\n\nn = read_int()\na = read_ints()\ndp = [[0] * n for _ in range(n)]\nf = [[0] * n for _ in range(n)]\nfor i in range(n - 1, -1, -1):\n\tf[i][i] = a[i]\n\tfor j in range(i + 1, n):\n\t\tf[i][j] = f[i][j - 1] ^ f[i + 1][j]\nfor i in range(n - 1, -1, -1):\n\tdp[i][i] = f[i][i]\n\tfor j in range(i + 1, n):\n\t\tdp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])\nq = read_int()\nfor _ in range(q):\n\tl, r = read_ints()\n\tprint(dp[l - 1][r - 1])","output":"quadratic"},{"instruction":"s = [0] * 10\nm = [0] * 10\np = [0] * 10\nD = list(input().split())\nfor i in D:\n    if i[1] == 'p':\n        p[int(i[0])] += 1\n    elif i[1] == 'm':\n        m[int(i[0])] += 1\n    else:\n        s[int(i[0])] += 1\n\nneed = 3\nfor i in range(1, 10):\n    need = min(3 - p[i], need)\n    need = min(3 - s[i], need)\n    need = min(3 - m[i], need)\n    if i <= 7:\n        tmp = 0\n        tmp += min(1, p[i])\n        tmp += min(1, p[i + 1])\n        tmp += min(1, p[i + 2])\n        need = min(3 - tmp, need)\n        tmp = 0\n        tmp += min(1, m[i])\n        tmp += min(1, m[i + 1])\n        tmp += min(1, m[i + 2])\n        need = min(3 - tmp, need)\n        tmp = 0\n        tmp += min(1, s[i])\n        tmp += min(1, s[i + 1])\n        tmp += min(1, s[i + 2])\n        need = min(3 - tmp, need)\n\nprint(need)","output":"linear"},{"instruction":"left, right = [int(x) for x in input().split(' ')]\n\nif left == right:\n    print(0)\nelse:\n    x = 1\n    while x <= right:\n        x *= 2\n    x \/\/= 2\n    y = x\n    while y > 0 and x <= left or x > right:\n        if x <= left:\n            x += y\n        else:\n            x -= y\n        y \/\/= 2\n    print(x^(x-1))","output":"logn"},{"instruction":"def main_function():\n    counter = int(input())\n    max_counter = 9\n    digits_per_number = 1\n    while max_counter < counter:\n        digits_per_number += 1\n        max_counter = max_counter + digits_per_number * 9 * 10 ** (digits_per_number - 1)\n    max_real_number = int(str(9) * digits_per_number)\n    dif  = max_counter - counter\n    rem = dif % digits_per_number\n    real_number = max_real_number - dif \/\/ digits_per_number\n    print(str(real_number)[-1-rem])\n\nmain_function()","output":"logn"},{"instruction":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]\n        return []","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom itertools import combinations\nfrom collections import defaultdict\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\nmx = max(max(a[i]) for i in range(n))\nif n == 1:\n  print(1,1)\n  exit()\nl = 0\nr = mx+1\nwhile l+1 < r:\n  flg = 0\n  x = (l+r)\/\/2\n  jud = set()\n  dc = defaultdict(int)\n  for i in range(n):\n    jnum = 0\n    for j in range(m):\n      if a[i][j] >= x:\n        jnum += 1<<j\n    if dc[jnum] == 0:\n      dc[jnum] = i+1\n    if jnum == (1<<m)-1:\n      flg = 1\n      if i == 0:\n        ans = (i+1,i+2)\n      else:\n        ans = (1,i+1)\n    jud.add(jnum)\n  for p,q in combinations(jud,2):\n    if p|q == (1<<m)-1:\n      flg = 1\n      ans = (dc[p],dc[q])\n  if flg:\n    l = x\n  else:\n    r = x\nif l == 0:\n  print(1,2)\nelse:\n  print(*ans)","output":"np"},{"instruction":"import math\nn=int(input())\nif(n==4): print(12)\nelif(n<=2): print(n)\nelse:\n    if(n%2==0):\n        a=n*(n-1)*(n-3)\n        if(n%3==0): a=a\/\/3\n        b=n*(n-1)*(n-2)\n        b=b\/\/2\n        print(max(a,b,(n-1)*(n-2)*(n-3)))\n    else: print(n*(n-1)*(n-2))","output":"constant"},{"instruction":"n,l,r,x = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\n\ncnt =0\n\nfor i in range(0,1<<n):\n\n  sum=0;mn=int(1e18);mx=0;\n\n  for j in range(0,n):\n\n    if((i>>j)&1):\n      sum += a[j]\n      mn = min(mn,a[j])\n      mx = max(mx,a[j])\n\n  if (sum>=l and sum<=r and (mx-mn)>=x):\n      cnt +=1\n\nprint(cnt)","output":"np"},{"instruction":"R, G, B = list(map(int, input().split()))\nr = [int(x) for x in input().split()]\nr.sort(reverse=True)\ng = [int(x) for x in input().split()]\ng.sort(reverse=True)\nb = [int(x) for x in input().split()]\nb.sort(reverse=True)\n\nans = 0\ndp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n            if j<G and k<B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n            if i<R and k<B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"from collections import defaultdict, Counter\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef lcm(a, b): return (a * b) \/\/ gcd(a, b)\n\ndef main():\n\n    w, h, n = mii()\n    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(\n        []), SortedList([])\n    hsm.add(h);\n    wsm.add(w);\n    hs.add(0);\n    ws.add(0);\n    hs.add(h);\n    ws.add(w);\n    dhs[h] = 1;\n    dhs[0] = 1;\n    dws[0] = 1;\n    dws[w] = 1\n    for i in range(n):\n        t, p = map(str, input().split())\n        p = int(p)\n        if t == \"H\":\n            if dhs[p] == 0:\n                hs.add(p)\n                dhs[p] = 1\n            ind = hs.bisect_left(p)\n            pre, nex = hs[ind - 1], hs[ind + 1]\n            hsm.__delitem__(hsm.bisect_left(nex - pre));\n            hsm.add(p - pre);\n            hsm.add(nex - p)\n        else:\n            if dws[p] == 0:\n                ws.add(p)\n                dws[p] = 1\n            ind = ws.bisect_left(p)\n            pre, nex = ws[ind - 1], ws[ind + 1]\n            wsm.__delitem__(wsm.bisect_left(nex - pre));\n            wsm.add(p - pre);\n            wsm.add(nex - p)\n        print(wsm[-1] * hsm[-1])\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"R = lambda: map(int, input().split())\n\nn, r = R()\nxs = list(R())\nys = []\nfor i in range(n):\n    ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r))\nprint(*ys)","output":"quadratic"},{"instruction":"n=int(input())\/\/2\na=list(map(int,input().split(' ')))\nb=[0]*n\na.reverse()\nfor i in a:\n    b.append(i)\nmem=b[-1]\nc=0\nfor i in range(n-1):\n    if b[-2-i]-c>mem:\n        c=b[-2-i]-mem\n    b[-2-i]-=c\n    b[1+i]+=c\n    mem=b[-2-i]\nfor i in b:\n    print(i,end=' ')","output":"linear"},{"instruction":"def main():\n    t = int(input())\n    for i in range(t):\n        n, k = input().split(' ')\n        n = int(n)\n        k = int(k)\n        if n > 35:\n            m = n - 1\n            print('YES ' + m.__str__())\n            continue\n        if k > (4 ** n - 1) \/\/ 3:\n            print('NO')\n            continue\n        ans = None\n        for a in range(n):\n            can = (2 ** (n - a + 1) - 1) * (4 ** a - 1) \/\/ 3\n            total = (4 ** n - 1) \/\/ 3\n            min = 2 ** (n - a + 1) - 2 - n + a\n            if k <= total - can and k >= min:\n                ans = a\n                break\n        if ans is not None:\n            print(\"YES \" + ans.__str__())\n        else:\n            print('NO')\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"n = int(input())\n\narr = [int(z) for z in list(input())]\nans = 0\n\nif n == 2:\n    if arr[0] == arr[1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    exit()\n\nfor l in range(1, n-1):\n    s = sum(arr[:l])\n    i = l\n    v = [s]\n    curr = 0\n    while i < n:\n        curr += arr[i]\n        if i == n-1:\n            if curr > s:\n                curr -= arr[i]\n                v.append(curr)\n                curr = arr[i]\n            v.append(curr)\n        elif curr > s:\n            curr -= arr[i]\n            v.append(curr)\n            curr = arr[i]\n        i += 1\n\n    if len(set(v)) == 1:\n        print(\"YES\")\n\n        ans = 1\n        exit()\n\nif not ans:\n    print(\"NO\")","output":"quadratic"},{"instruction":"n=int(input())\nm=int(input())\nprint(m%2**n)","output":"constant"},{"instruction":"import math\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef calc(st,j):\n    ans=9999999999999999999999\n\n    if j>=len(st):\n        return 0\n    j=len(st)-j\n    for i in range(j-1,len(st)):\n        ans=min(ans,st[i]-st[i-j+1]+1)\n    return ans\nn,m,k=map(int,input().split())\ns=[]\nfor i in range(n):\n    s.append(input())\ninf=99999999999999999999\ndp=[[inf for i in range(k+1)]for j in range(n+1)]\nfor i in range(k+1):\n    dp[0][i]=0\nfor i in range(1,n+1):\n    st=[]\n    for ik in range(len(s[i-1])):\n        if s[i-1][ik]=='1':\n            st.append(ik)\n    for j in range(k+1):\n        no=calc(st,j)\n\n        for t in range(k+1-j):\n            dp[i][t+j]=min(dp[i][t+j],no+dp[i-1][t])\n\nprint(dp[n][k])","output":"cubic"},{"instruction":"n,m,k=map(int,input().split())\nlist1=list(map(int,input().split()))\nlist1.sort(reverse=True)\nc=0\ni=0\n\nwhile(k<m and i<n):\n    k+=list1[i]-1\n    i+=1\n    c+=1\nif(k>=m):\n    print(c)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\nimport time\n\nfrom types import GeneratorType\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport string\nfrom math import sqrt\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\ndef isInt(s):\n    return '0' <= s[0] <= '9'\n\nMOD = 10**9 + 7\n\ndef t_from_s_a_u(s,a,u):\n    return (-2*u + sqrt(4*u*u + 8*s*a))\/(2*a)\n\ndef solve():\n    A, V = getInts()\n    L, D, W = getInts()\n    if V <= W or W**2 >= 2*A*D:\n\n        if V**2 >= 2*A*L:\n            return sqrt(2*L\/A)\n        else:\n            dist_1 = (V**2)\/(2*A)\n            T1 = 2*dist_1\/V\n            dist_2 = L - dist_1\n            T2 = dist_2\/V\n            return T1+T2\n    else:\n\n        dist_1 = (W**2)\/(2*A)\n        T1 = sqrt(2*dist_1\/A)\n        rem_dist = D - dist_1\n        dist_A = (V**2 - W**2)\/(2*A)\n        if 2*dist_A >= rem_dist:\n\n            TA = 2*t_from_s_a_u(rem_dist\/2,A,W)\n        else:\n            TA1 = 2*(V-W)\/A\n            SA1 = (V+W)*(V-W)\/A\n            SA2 = rem_dist - SA1\n            TA2 = SA2\/V\n            TA = TA1 + TA2\n        T1 += TA\n\n        if V**2 - W**2 >= 2*A*(L-D):\n\n            return T1 + t_from_s_a_u(L-D,A,W)\n        else:\n            dist_2 = (V**2 - W**2)\/(2*A)\n            T2 = 2*dist_2\/(V+W)\n            dist_3 = L - D - dist_2\n            T3 = dist_3\/V\n\n            return T1+T2+T3\n    return\n\nprint(solve())","output":"constant"},{"instruction":"import sys\n\nclass fenwick():\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n\n        return self.to_sum(j)-self.to_sum(i-1)\n\ndef input():\n    return sys.stdin.buffer.readline()\n\nn = int(input())\npermutation = list(map(int, input().split()))\nseq = [(permutation[i], i + 1) for i in range(n)]\nseq.sort(reverse=True)\n\nm = int(input())\nquery = [tuple(map(int, input().split())) for i in range(m)]\n\nWHOLE_INVERSION = 0\nfenwick_1 = fenwick(n)\n\nfor value, index in seq:\n    WHOLE_INVERSION += fenwick_1.get(1, index)\n    fenwick_1.add(index, 1)\n\nfor l, r in query:\n    d = r - l + 1\n    WHOLE_INVERSION += d*(d-1)\/\/2\n    if WHOLE_INVERSION % 2 != 0:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        return a + b\n","output":"constant"},{"instruction":"xa, ya = map(int, input().split())\nxb, yb = map(int, input().split())\nxc, yc = map(int, input().split())\nif (xb, yb) < (xa, ya):\n    xa, ya, xb, yb = xb, yb, xa, ya\nif (xc, yc) < (xa, ya):\n    xa, ya, xc, yc = xc, yc, xa, ya\nif xb > xc:\n    xb, yb, xc, yc = xc, yc, xb, yb\nd = 1 if ya <= yc else -1\nif ya <= yb <= yc or ya >= yb >= yc:\n    print(xc - xa + abs(yc - ya) + 1)\n    for x in range(xa, xb):\n        print(x, ya)\n    for y in range(ya, yc, d):\n        print(xb, y)\n    for x in range(xb, xc + 1):\n        print(x, yc)\nelif yb < min(ya, yc):\n    print(xc - xa + max(ya, yc) - yb + 1)\n    for x in range(xa, xc + 1):\n        print(x, min(ya, yc))\n    for y in range(yb, min(ya, yc)):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya + 1, yc + 1):\n            print(xc, y)\n    else:\n        for y in range(yc + 1, ya + 1):\n            print(xa, y)\nelse:\n    print(xc - xa + yb - min(ya, yc) + 1)\n    for x in range(xa, xc + 1):\n        print(x, max(ya, yc))\n    for y in range(max(ya, yc) + 1, yb + 1):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya, yc):\n            print(xa, y)\n    else:\n        for y in range(yc, ya):\n            print(xc, y)","output":"constant"},{"instruction":"a, b = map(int, input().split())\nq, r = divmod(a, 2)\nprint('01'*q + '0'*r)","output":"linear"},{"instruction":"__author__ = 'ruckus'\n\nn = int(input())\ns = input()\nt = input()\ndif = {}\nhem = 0\nfor i in range(n):\n    if s[i] != t[i]:\n        dif[i] = [s[i], t[i]]\n        hem += 1\n\nchange = []\nprobed = []\nk = 0\nfor i in dif.keys():\n    if dif[i] in probed:\n        continue\n    probed.append(dif[i])\n    k += 1\n    for j in list(dif.keys())[k:]:\n        if dif[i] == dif[j][::-1]:\n            print(hem - 2)\n            print(i + 1, j + 1)\n            quit()\n        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):\n            change = [i, j]\n\nif change:\n    print(hem - 1)\n    print(change[0] + 1, change[1] + 1)\nelse:\n    print(hem)\n    print('-1 -1')","output":"linear"},{"instruction":"n=int(input())\narr=list(map(int,input().split()));ans=0\nwhile len(arr)!=0:\n e=arr.pop(0)\n ans+=arr.index(e)\n arr.remove(e)\nprint(ans)","output":"quadratic"},{"instruction":"from sys import stdin\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\ngraph = [[] for _ in range(n)]\nleaf = -1\nfor _ in range(n-1):\n    a,b = map(int,stdin.readline().split())\n\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(G, s):\n\n    Q = deque()\n    Q.append(s)\n\n    infinite = 10 ** 6\n    d = [infinite]*n\n\n    parent = [-1]*n\n    valid = True\n\n    d[s] = 0\n\n    while Q:\n\n        u = Q.popleft()\n\n        not_visited_count = 0\n\n        for v in G[u]:\n\n            if d[v] == infinite:\n                d[v] = d[u] + 1\n                parent[v] = u\n                Q.append(v)\n                not_visited_count += 1\n\n        if not_visited_count < 3 and d[u] != k:\n            valid = False\n\n    return d, parent, valid\n\nleaf = -1\nfor i,v in enumerate(graph):\n    if len(v) == 1:\n        leaf = i\n        break\n\nd, parent, _ = bfs(graph,leaf)\ncenter = -1\nfarthest_leaf = -1\ndiameter = 2*k\n\nfor i,level in enumerate(d):\n    if level == diameter:\n        farthest_leaf = i\n        break\n\nif len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:\n    print(\"NO\")\n    exit()\n\nfor _ in range(k):\n    center = parent[farthest_leaf]\n    farthest_leaf = center\n\nif center == -1:\n    print(\"NO\")\n    exit()\n\n_, _, valid = bfs(graph,center)\n\nif valid:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"MOD=1000000007\ndef pow2(n):\n    if n==0:\n        return 1\n    t=pow2(n\/\/2)%MOD\n    m=(t*t)%MOD\n    if n%2==1:\n        m=(m*2)%MOD\n    return m\nx,k=map(int,input().split())\nif x==0:\n    print(0)\n    exit()\nt=pow2(k)*(2*x-1)%MOD\nprint((t+1)%MOD)","output":"logn"},{"instruction":"import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs2(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\n\nans=0\nb=[]\nvis=[]\ntot=0\ndef dfs(root):\n    global tot,vis,gp\n    for child in gp[root]:\n        if vis[child]==0:\n            tot+=1\n            vis[child]=1\n            dfs(child)\npre=[[] for i in range(3)]\ndef hnbhai(tc):\n    n=sb()\n    d,num=0,1\n    while num<=n:\n        num+=9*(d+1)*(10**d)\n        d+=1\n    num-=9*(d)*(10**(d-1))\n    ans=str(10**(d-1)+(n-num)\/\/d)\n    print(ans[(n-num)%d])\nfor _ in range(1):\n    hnbhai(_+1)","output":"logn"},{"instruction":"import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 2 == 1:\n        print('NO')\n        continue\n    n \/\/= 2\n    l, r = 0, n + 2\n    while r - l > 1:\n        m = (l + r) \/\/ 2\n        if m * m <= n:\n            l = m\n        else:\n            r = m\n    if l * l == n:\n        print('YES')\n        continue\n    l, r = 0, n + 2\n    while r - l > 1:\n        m = (l + r) \/\/ 2\n        if m * m * 2 <= n:\n            l = m\n        else:\n            r = m\n    if l * l * 2 == n:\n        print('YES')\n        continue\n    print('NO')","output":"logn"},{"instruction":"def bs(n, k, lo, hi):\n    while lo <= hi:\n        mid = (hi + lo)\/\/2\n        summ = ((k * (k + 1))\/\/2 - 1) - (((mid-1) * (mid))\/\/2 -1) - (k-2)\n        if summ == n: return k - mid + 1\n        elif summ > n: lo = mid + 1\n        elif summ < n: hi = mid - 1\n    if summ > n: mid += 1\n    return k - mid + 1\n\ndef solve():\n    n, k = map(int, input().split())\n    if n == 1: return 0\n    elif (k * (k + 1)\/\/2) - (k-2) <= n: return -1\n    elif k >= n: return 1\n    else: return bs(n, k, 2, k)\n\nprint(solve())","output":"logn"},{"instruction":"import math\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def print(self):\n        print(self.x, self.y)\n\nclass Line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def on(self, p):\n        return distance(self.p1, p) + distance(self.p2, p) == distance(self.p1, self.p2)\n\n    def print(self):\n        self.p1.print()\n        self.p2.print()\n\nclass Square:\n    def __init__(self, points):\n        self.points = points\n\n    def area(self):\n        return distance(self.points[0], self.points[1]) ** 2\n\n    def lines(self):\n        l = []\n        for i in range(3):\n            l.append(Line(self.points[i], self.points[i + 1]))\n        l.append(Line(self.points[3], self.points[0]))\n        return l\n\n    def midpoint(self):\n        return Point(self.points[0].x \/ 2 + self.points[2].x \/ 2, self.points[0].y \/ 2 + self.points[2].y \/ 2)\n\n    def print(self):\n        for point in self.points:\n            point.print()\n\ndef distance(p1, p2):\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** .5\n\ndef tri_area(p1, p2, p3):\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    s = a + b + c\n    s \/= 2\n    return (s * (s - a) * (s - b) * (s - c)) ** .5\n\ndef inter(p, s):\n    a = s.area()\n    area_sum = tri_area(s.points[0], s.points[1], p) + tri_area(s.points[1], s.points[2], p)\n    area_sum += tri_area(s.points[2], s.points[3], p) + tri_area(s.points[3], s.points[0], p)\n    if abs(a - area_sum) < 0.000001:\n        return True\n    return False\n\nc1 = input().split(\" \")\nc2 = input().split(\" \")\nfor i in range(8):\n    c1[i] = int(c1[i])\n    c2[i] = int(c2[i])\nc1p = []\nc2p = []\nfor i in range(0, 8, 2):\n    c1p.append(Point(c1[i], c1[i + 1]))\n    c2p.append(Point(c2[i], c2[i + 1]))\ns1 = Square(c1p)\ns2 = Square(c2p)\nyes = False\nfor point in s1.points:\n    if inter(point, s2):\n        if not yes:\n            print(\"YES\")\n            yes = True\nfor point in s2.points:\n    if inter(point, s1):\n        if not yes:\n            print(\"YES\")\n            yes = True\nif inter(s1.midpoint(), s2):\n    if not yes:\n        print(\"YES\")\n        yes = True\nif inter(s2.midpoint(), s1):\n    if not yes:\n        print(\"YES\")\nif not yes:\n    print(\"NO\")","output":"constant"},{"instruction":"import sys\n\nn = sys.stdin.readline()\nn = int(n)\ndef get_graph(n):\n    graph = []\n    for _ in range(n):\n        entries = list(map(lambda x : int(x), sys.stdin.readline().split(\" \")[1:]))\n        graph.append(entries)\n    return graph\n\ndef chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):\n    mask = 2**bucket_num\n    mem = []\n    buckets_seen = set({bucket_num})\n\n    og_bucket = bucket_num\n    og_val = val\n    for _ in range(len(buckets)):\n        rem = target - sum_bucket[bucket_num] + val\n        if rem not in reverse_bucket:\n            return None, []\n\n        new_bucket = reverse_bucket[rem]\n        if new_bucket == og_bucket and rem != og_val:\n            return None, []\n        elif new_bucket == og_bucket and rem == og_val:\n            mem.append((rem, bucket_num))\n            return mask | 2**new_bucket, mem\n        elif new_bucket in buckets_seen:\n            return None, []\n\n        buckets_seen.add(new_bucket)\n        mask = mask | 2**new_bucket\n\n        mem.append((rem, bucket_num))\n        bucket_num = new_bucket\n        val = rem\n    return None, []\n\ndef helper(chains, mask, mem):\n    if mask == 0:\n        return []\n    if mask in mem:\n        return mem[mask]\n\n    for i, chain in enumerate(chains):\n        if (mask >> i) & 0:\n            continue\n        for key in chain:\n            if key | mask != mask:\n                continue\n\n            future = helper(chains, ~key & mask, mem)\n            if future is not None:\n                mem[mask] = chain[key] + future\n                return mem[mask]\n    mem[mask] = None\n    return None\n\ndef solve(n):\n    buckets = get_graph(n)\n    reverse_bucket = {}\n    sum_bucket = [0]* len(buckets)\n    total_sum = 0\n    for i, bucket in enumerate(buckets):\n        for x in bucket:\n            total_sum += x\n            sum_bucket[i] += x\n            reverse_bucket[x] = i\n\n    target = total_sum \/ len(buckets)\n\n    chains = []\n    for i, bucket in enumerate(buckets):\n        seto = {}\n        for x in bucket:\n            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)\n            if key is not None:\n                seto[key] = val\n        chains.append(seto)\n    return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket\n\ndef result(n):\n    res, reverse_bucket = solve(n)\n    if res is None:\n        sys.stdout.write(\"No\\n\")\n    else:\n        res = sorted(res, key = lambda x : reverse_bucket[x[0]])\n        sys.stdout.write(\"Yes\\n\")\n        for x, y in res:\n            x = int(x)\n            y = int(y) + 1\n            stuff = \" \".join([str(x), str(y), \"\\n\"])\n            sys.stdout.write(stuff)\nresult(n)","output":"np"},{"instruction":"l,r=map(int,input().split())\nls=str(bin(l))[2:]\nrs=str(bin(r))[2:]\nllog=len(ls)\nrlog=len(rs)\nans=0\nif llog<rlog:\n    z=rlog-1\n    while z>-1:\n        ans+=2**z\n        z-=1\nelse:\n    ct=0\n    stringa=\"\"\n    for i in range(len(ls)):\n        if ls[i]==rs[i] and ct==0:\n            stringa+=ls[i]\n        if ls[i]==\"0\" and rs[i]==\"1\":\n            ct+=1\n            stringa+=ls[i]\n        if ls[i]==\"1\" and rs[i]==\"0\":\n            stringa+=ls[i]\n        if ls[i]==rs[i] and ct>0:\n            stringa+=str((int(rs[i])+1)%2)\n    ans=(int(stringa,2)^r)\nprint(ans)","output":"logn"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n + 1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n    e[v][i] = i\n    d[i].append(i)\nfor v in range(1, 2024):\n    for i in range(n):\n        j = e[v][i]\n        h = e[v][j + 1] if j != -1 else -1\n        if j != -1 and h != -1:\n            e[v + 1][i] = h\n            d[i].append(h)\n\na = [_ for _ in range(1, n + 1)]\nfor s in range(n):\n    for e in d[s]:\n        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)\nprint(a[n - 1])","output":"cubic"},{"instruction":"from sys import stdin\ninput=stdin.readline\n\ndef count(n):\n\n    value=0\n    while(n):\n        n &= (n-1)\n        value+=1\n\n    return value\n\ndef nc2(n):\n    return (n*(n - 1))\/\/2\n\ndef answer():\n\n    dp=[0]*(1 << n)\n\n    dp[(1 << n) - 1]=1\n\n    for mask in range((1 << n) - 1,0,-1):\n\n        m=count(mask)\n        if(m==1):continue\n\n        p=1\/(nc2(m))\n\n        for i in range(n):\n            for j in range(n):\n                if(i==j):continue\n\n                if((mask >> i & 1) and (mask >> j & 1)):\n\n                    next_mask=mask ^ (1 << j)\n                    dp[next_mask]+=(dp[mask]*p*a[i][j])\n\n    for i in range(n):\n\n        print(dp[1 << i],end=' ')\n\nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\n\nanswer()\nprint()","output":"np"},{"instruction":"a = int(input())\nprint(a * (a - 1) * 2 + 1)","output":"constant"},{"instruction":"from sys import stdin\ndef get_ints(): return list(map(int, stdin.readline().strip().split()))\n\nn = int(input())\nar = get_ints()\n\nbus = sorted([ (ar[i], i+1) for i in range(n) ])\npa = [int(x) for x in input()]\nseq = []\n\ntail = 0\nfor p in pa:\n\tif p == 0:\n\t\tprint(bus[tail][1], end=\" \")\n\t\tseq.append(tail)\n\t\ttail+=1\n\telse:\n\t\tv = seq.pop()\n\t\tprint(bus[v][1],end=\" \")","output":"nlogn"},{"instruction":"import math\nn,k=map(int,input().split())\nfor _ in range(k):\n    l,r=map(int,input().split())\nfor i in range(1,n+1):\n    if i%2==0:\n        print('0',end='')\n    else:\n        print('1',end='')\nprint()","output":"linear"},{"instruction":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        sqrt5 = math.sqrt(5)\n        phi = (1 + sqrt5) \/ 2\n        psi = (1 - sqrt5) \/ 2\n        n += 1\n        return round((phi**n - psi**n) \/ sqrt5)","output":"logn"},{"instruction":"n = int(input())\n\na = map(int, input().split())\nmp = {}\ns = 0\nans = 0\ni = 0\nfor x in a:\n    i += 1\n    s += x\n\n    if x not in mp:\n        mp[x] = 0\n\n    if x+1 not in mp:\n        mp[x+1] = 0\n\n    if x-1 not in mp:\n        mp[x-1] = 0\n    mp[x] += 1\n\n    adj = mp[x] + mp[x+1] + mp[x-1];\n    c = s;\n    c -= mp[x]*x;\n    c -= mp[x+1] * (x+1);\n    c -= mp[x-1] * (x-1);\n\n    valid = i-adj\n\n    ans += (valid*x)-c\n\nprint(ans)","output":"nlogn"},{"instruction":"T = int(input())\nfor ti in range(T):\n    s = input().strip()\n    t = input().strip()\n    N = len(t)\n    for i in range(1, N+1):\n\n        dp = [[0]+[-1]*i for _ in range(len(s)+1)]\n        for l, c in enumerate(s):\n            for j in range(i+1):\n                dp[l+1][j] = dp[l][j]\n\n                if dp[l][j] != -1:\n                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:\n                        dp[l+1][j] = dp[l][j]+1\n\n                if j != 0 and c == t[j-1]:\n                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])\n\n        if dp[-1][i] == N-i:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")","output":"cubic"},{"instruction":"a = list(map(int, input().split()))\n\nans = 0\nfor i in range(len(a)):\n    x = a[i]\n    b = [j for j in a]\n    b[i] = 0\n    for j in range(len(a)):\n        b[j] += x \/\/ 14\n\n    for j in range(1, x % 14 + 1):\n        b[(i + j) % 14] += 1\n\n    ans_now = 0\n    for j in b:\n        if j % 2 == 0:\n            ans_now += j\n    ans = max(ans_now, ans)\nprint(ans)","output":"constant"},{"instruction":"from itertools import *\nn, s = map(int, input().split())\ntimes = []\nfor i in range(n):\n    h, m = map(int, input().split())\n    times.append((h * 60 + m))\n\ntimes.sort()\nfor t in count():\n    if all(abs(u - t) > s for u in times):\n        print(*divmod(t, 60))\n        break","output":"linear"},{"instruction":"n, k = map(int, input().split())\nm = 1000000007\nif n == 0:\n    print(0)\n    exit(0)\nr = pow(2, k+1, m)*n - pow(2, k, m) + 1\nprint(r % m)","output":"logn"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\nza = getIntList()\nif N==1:\n    print(za[0])\n    sys.exit()\nt1 = max(za)\nt2 = min(za)\nif t2>=0:\n    print(sum(za) - 2*t2)\n    sys.exit()\nif t1<=0:\n    print(2*t1 - sum(za))\n    sys.exit()\n\nres = 0\nfor x in za:\n    res+= abs(x)\n\nprint(res)","output":"linear"},{"instruction":"l = input().split()\nif l[0]==l[1] and l[1]==l[2]:\n    print(0)\n    exit(0)\ndef shuntsu(li):\n    li.sort()\n    return li[0][1]==li[1][1] and li[1][1]==li[2][1] and int(li[1][0])==int(li[0][0])+1 and int(li[2][0])==int(li[1][0])+1\nif shuntsu(l):\n    print(0)\n    exit(0)\nfor k in l:\n    if len([x for x in l if x==k]) > 1:\n        print(1)\n        exit(0)\n    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+1]) !=0:\n        print(1)\n        exit(0)\n    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+2]) != 0:\n        print(1)\n        exit(0)\nprint(2)","output":"nlogn"},{"instruction":"n=int(input())\na=[0] + list(map(int,input().split()))\nd={}\nfor i in range(1,n+1):\n    d[a[i]]=i\nans=0\nfor i in range(1,n+1):\n    if a[i]!=i:\n        ind1=d[a[i]]\n        ind2=d[i]\n        va1=a[i]\n        val2=i\n        a[ind1],a[ind2]=a[ind2],a[ind1]\n        d[i]=i\n        d[va1]=ind2\n        ans+=1\n\nif (3*n - ans)%2==0:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"a = int(input())\nb = list(map(int, input().split()))\nc = [int(i % 2 == 0) for i in b]\nif(c.count(1) == 1):\n\tprint(c.index(1) + 1)\nelse:\n\tprint(c.index(0) + 1)","output":"linear"},{"instruction":"import io\nimport os\n\nimport sys\nfrom functools import lru_cache\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 5)\n\ndef solve(N, A):\n\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    maxVal = 1000 + 10\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n\n                intervals[l].append(r)\n\n    @lru_cache(maxsize=None)\n    def getBest(left):\n\n        if left == N:\n            return 0\n        best = float(\"inf\")\n        for right in intervals[left]:\n\n            best = min(best, 1 + getBest(right + 1))\n        return best\n\n    return getBest(0)\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)","output":"cubic"},{"instruction":"x=input();l=len(x);m=0\nfor i in range(l-1):\n    f=i\n    while 1 :\n        idx = x[f+1:].find(x[f])\n        if idx == -1 :\n            break\n        else:\n            idx += f+1 ; c=ans=0\n            for j in range(idx , l) :\n               if x[j] == x[i+c]:\n                    ans+=1\n                    c+=1\n               else:\n                   break\n\n            if m < ans :\n                m=ans\n            f = idx\nprint(m)","output":"cubic"},{"instruction":"n, m = map(int, input().split())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nx = 0\nfor i in range(n):\n\ttry:\n\t\tif a[0] >= c[i]:\n\t\t\tx += 1\n\t\t\ta.pop(0)\n\texcept IndexError:\n\t\tpass\n\nprint(x)","output":"linear"},{"instruction":"from math import factorial\n\ns1 = input()\ns2 = input()\n\nfinPos=0\nfor c in s1:\n\tif c=='+': finPos+=1\n\telse: finPos-=1\n\nstPos=0\nfor c in s2:\n\tif c=='+': stPos+=1\n\telif c=='-': stPos-=1\n\nn=s2.count('?')\ndiff=abs(finPos-stPos)\nif diff > n:\n\tprint(0)\nelif n&1 != diff&1:\n\tprint(0)\nelse:\n\ti=0\n\tfor i in range(n\/\/2,n):\n\t\tif i*2-n == diff: break\n\tif i*2-n != diff: i+=1\n\n\tprint((factorial(n)\/(factorial(n-i)*factorial(i)))\/(1<<n))","output":"np"},{"instruction":"v = input().split()\nn = int(v[0])\nk = int(v[1])\n\ns = input()\nap = 0\n\ni = 1\nwhile i < n:\n    if s[:i] == s[-i:]:\n        ap = i\n\n    i += 1\n\nprint(s + s[ap:]*(k-1))","output":"quadratic"},{"instruction":"import sys\n\ndef query(c, d):\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    res = int(input())\n    return res\n\na = 0\nb = 0\nbig = query(0, 0)\n\nfor i in range(29, -1, -1):\n    p = query(a ^ (1 << i), b)\n    q = query(a, b ^ (1 << i))\n    if p == q:\n        if big == 1:\n            a ^= 1 << i\n        else:\n            b ^= 1 << i\n        big = p\n    elif p == -1:\n        a ^= 1 << i\n        b ^= 1 << i\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()","output":"logn"},{"instruction":"line1 = str(input());\nline2 = str(input());\n\ntruePosition = 0;\nfakePosition = 0;\nquestionMarks = 0;\nfor i in range(len(line1)):\n\tif line1[i] == \"+\":\n\t\ttruePosition += 1;\n\tif line1[i] == \"-\":\n\t\ttruePosition -= 1;\n\tif line2[i] == \"+\":\n\t\tfakePosition += 1;\n\tif line2[i] == \"-\":\n\t\tfakePosition -= 1;\n\tif line2[i] == \"?\":\n\t\tquestionMarks += 1;\n\ndistanceToMove = abs(truePosition - fakePosition);\n\ndef factorial(x):\n\tif x == 0:\n\t\treturn 1;\n\telse:\n\t\treturn x * factorial(x-1);\n\ndef probToMove(dist, questionMarks):\n\tif(dist > questionMarks):\n\t\treturn float(0);\n\treducedDist = questionMarks - dist;\n\tif(reducedDist % 2 != 0):\n\t\treturn float(0);\n\tdist = reducedDist\/\/2 + dist;\n\theadsFlips = 1;\n\theadsOrders = factorial(questionMarks) \/ ((factorial(dist) *factorial(questionMarks-dist)));\n\n\ttotalPossibilities = 2**questionMarks;\n\n\treturn headsFlips * headsOrders \/ totalPossibilities;\n\nprint(probToMove(distanceToMove, questionMarks));","output":"np"},{"instruction":"m = int(input())\na = list(map(int, input().split()))\n\ndp = [[505]*m for _ in range(m)]\nMax = [[0]*m for _ in range(m)]\n\nfor i in range(m):\n    dp[i][i] = 1\n    Max[i][i] = a[i]\n\nfor len in range(1, m+1):\n    for i in range(m-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][m-1])","output":"cubic"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\nd={}\nfor chr in a:\n     if chr not in d:\n        d[chr]=1\n     else:\n        d[chr]+=1\np=list(d.values())\nz=k\/\/n\nif z==0 :\n     print(0)\nelse:\n     o=[]\n     if len(a)>=n:\n        o.append(1)\n     for i in range(2,z+1):\n         c=0\n         for j in range(len(p)):\n             c+=p[j]\/\/i\n         if c>=n:\n             o.append(i)\n     print(max(o))","output":"nlogn"},{"instruction":"def checksq(n):\n    m = int(n**0.5)\n    if m * m == n:\n        return m\n    m += 1\n    if m * m == n:\n        return m\n    return -1\n\ndef main():\n\n    n = int(input())\n\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n    if checksq(n \/\/ 2) != -1:\n        print('YES')\n        return\n    n \/\/= 2\n    if n % 2 == 1:\n        print('NO')\n        return\n    if checksq(n \/\/ 2) != -1:\n        print('YES')\n    else:\n        print('NO')\n\nfor i in range(int(input())):\n    main()","output":"constant"},{"instruction":"from sys import stdin\n\nEPS = 1e-6\nn = int(stdin.readline())\nm = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\nb = list(map(int, stdin.readline().split()))\nb.append(b[0])\n\ndef check(f):\n    fuel_left = f\n    total_weight = float(m + fuel_left)\n    for i in range(n):\n        cost = total_weight \/ a[i]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n\n        cost = total_weight \/ b[i + 1]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n        if fuel_left < 0:\n            return False\n    return True\n\ndef binary_search(left, right):\n    mid = (left + right) \/ 2\n    if abs(left - right) < EPS:\n        return mid\n    if check(mid):\n        return binary_search(left, mid)\n    else:\n        return binary_search(mid, right)\n\nres = binary_search(0, 1e9 + 1)\nif res - 1e9 > EPS:\n    print(-1)\nelse:\n    print(\"%.10f\" % res)","output":"linear"},{"instruction":"import os, sys, atexit\nfrom io import BytesIO, StringIO\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n_OUTPUT_BUFFER = StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nn, m = map(int, input().split())\narr = [0] * n\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    arr[i] = temp\nx = 1\nN = 2 ** m - 1\nlo = 1\nhi = 1000000009\nind = [0, 0]\nwhile 1:\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n\n                break\n        if ch: break\n    if ch:\n        lo = x\n        x = x * 2\n    else:\n        hi = x\n        break\nans = lo\nwhile hi - lo > 1:\n    x = (lo + hi) \/\/ 2\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n\n                break\n        if ch: break\n    if ch:\n        lo = x\n    else:\n        hi = x\nans = lo\n\nif ind[0] == 0: print(\"1 1\")\nelse: print(*ind)","output":"np"},{"instruction":"arr = [int(i) for i in filter(None, input().split(\" \"))]\nk_hodov = arr[0]\nkonf = arr[1]\nleft = 0\nright = k_hodov+100\nwhile(right-left)>1:\n    mid = (right+left)\/\/2\n    k_give=k_hodov-mid\n    if ((k_give+1)*(k_give\/2))\/\/1-mid<konf or k_give<0:\n        right = mid\n    else:\n        left = mid\n\nk_give=k_hodov-left\nif ((k_give+1)*(k_give\/2))\/\/1-left==konf:\n    print(left)\nelse:\n    print(left-1)","output":"logn"},{"instruction":"def main():\n    q = int(input())\n    ans = []\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        pr1 = [0]\n        pr2 = [0]\n        pr3 = [0]\n        for i in range(n):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            if i % 3 == 0:\n                if s[i] != \"R\":\n                    count1 += 1\n                if s[i] != \"G\":\n                    count2 += 1\n                if s[i] != \"B\":\n                    count3 += 1\n            if i % 3 == 1:\n                if s[i] != \"G\":\n                    count1 += 1\n                if s[i] != \"B\":\n                    count2 += 1\n                if s[i] != \"R\":\n                    count3 += 1\n            if i % 3 == 2:\n                if s[i] != \"B\":\n                    count1 += 1\n                if s[i] != \"R\":\n                    count2 += 1\n                if s[i] != \"G\":\n                    count3 += 1\n            pr1.append(pr1[-1] + count1)\n            pr2.append(pr2[-1] + count2)\n            pr3.append(pr3[-1] + count3)\n            j = i + 1\n            if j >= k:\n                count1 = pr1[j] - pr1[j - k]\n                count2 = pr2[j] - pr2[j - k]\n                count3 = pr3[j] - pr3[j - k]\n                min_ans = min(min_ans, count1, count2, count3)\n        ans.append(min_ans)\n    print(*ans, sep=\"\\n\")\n\nmain()","output":"linear"},{"instruction":"from collections import Counter\n\nn = int(input())\na = Counter()\nb = Counter()\nfor _ in range(n):\n    a[input().strip()] += 1\nfor _ in range(n):\n    b[input().strip()] += 1\nans = 0\nfor key in b:\n    ans += max(b[key] - a[key], 0)\n\nprint(ans)","output":"linear"},{"instruction":"class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        res = 0\n        for i in range(len(heights)):\n            for j in range(i + 1, len(heights)):\n                res = max(res, min(heights[i], heights[j]) * (j - i))\n        return res","output":"quadratic"},{"instruction":"def solve(a, b, c):\n    D = b * b - 4 * a * c\n    k = D**0.5\n    x1 = (-b+k)\/(2*a)\n    x2 = (-b-k)\/(2*a)\n    return max(x1,x2)\n\nfrom math import *\nn, r = map(int, input().split())\na = (1\/tan(pi\/n))**2\nb = -2 * r\nc = -(r*r)\nans = solve(a,b,c)\nprint(\"%.10f\" % ans)","output":"constant"},{"instruction":"from collections import deque\nwith open(\"input.txt\",\"r\") as input_file:\n    with open(\"output.txt\",\"a\") as output_file:\n        N,M = map(int,input_file.readline().split())\n        K = int(input_file.readline())\n        T = list(map(int,input_file.readline().split()))\n        graph = [[0] * (M + 1) for _ in range(N + 1)]\n        queue = deque()\n        for i in range(0, 2 * K - 1, 2):\n            graph[T[i]][T[i + 1]] = 1\n            queue.append((T[i], T[i + 1]))\n        x, y = 0, 0\n        while queue:\n            x, y = queue.popleft()\n            x_moves = [x - 1, x + 1, x, x]\n            y_moves = [y, y, y - 1, y + 1]\n            for i in range(len(x_moves)):\n                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:\n                    if graph[x_moves[i]][y_moves[i]] == 0:\n                        x = x_moves[i]\n                        y = y_moves[i]\n                        graph[x_moves[i]][y_moves[i]] = 1\n                        queue.append((x_moves[i], y_moves[i]))\n        output_file.write(f\"{x} {y}\")","output":"cubic"},{"instruction":"modulo = int(1e9+7)\nn = int(input())\narr = [input() for i in range(n)]\ndp = [1]\nfor i in range(n):\n    if arr[i] == 'f':\n        dp.append(0)\n        continue;\n    for j in range(1, len(dp)):\n        dp[j] = (dp[j] + dp[j-1]) % modulo\nprint(dp[-1])","output":"quadratic"},{"instruction":"class Solution:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1000000] * n\n        dp[-1] = 0\n\n        for i in range(n - 2, -1, -1):\n            end = min(n, i + nums[i] + 1)\n            for j in range(i + 1, end):\n                dp[i] = min(dp[i], 1 + dp[j])\n        return dp[0]","output":"quadratic"},{"instruction":"import heapq\nn,k = map(int,input().split())\nP = list(map(int,input().split()))\nC = list(map(int,input().split()))\nX = []\nfor i in range(n):\n    X.append([P[i],C[i],i])\nX.sort(key = lambda x : x[0])\ncoins = []\nheapq.heapify(coins)\ncurr = 0\nres = [0 for i in range(n)]\nfor i in range(k):\n    heapq.heappush(coins,X[i][1])\n    curr += X[i][1]\n    res[X[i][2]] = curr\nfor j in range(k,n):\n\n    res[X[j][2]] = X[j][1] + sum(coins)\n    if len(coins)>0:\n        x = heapq.heappop(coins)\n        if x < X[j][1]:\n            heapq.heappush(coins,X[j][1])\n        else:\n            heapq.heappush(coins,x)\n\nprint(*res)","output":"nlogn"},{"instruction":"import collections\nimport random\nimport heapq\nimport bisect\nimport math\nimport time\n\nclass Solution2:\n\n    def solve(self, s):\n        pass\n\nclass Solution:\n\n    def solve(self, n, k):\n\n        grow = 1\n        tot = 0\n\n        while n != tot - k:\n            tot += grow\n            grow += 1\n            n -= 1\n        return tot - k\n\nsol = Solution()\nsol2 = Solution2()\n\nfor test_case in range(1):\n    N, K = input().split()\n\n    out = sol.solve(int(N),int(K))\n    print(str(out))","output":"logn"},{"instruction":"leng = 0\ns = input()\nfor i in range(len(s)):\n    for j in range(i + 1, len(s) + 1):\n        sub = s[i:j]\n        if s.count(sub) >= 2 and len(sub) > leng:\n            leng = len(sub)\n        elif s.count(sub) == 1:\n            for k in range(1, len(sub)):\n                if s[i - k:j - k] == sub and len(sub) > leng:\n                    leng = len(sub)\nprint(leng)","output":"cubic"},{"instruction":"n = int(input())\nA = [int(a) for a in input().split()]\nB = A.copy()\nB.sort()\nc = 0\nfor i in range(n):\n    c = c + 1 if A[i] != B[i] else c\nprint(\"YES\" if c <= 2 else \"NO\")","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nb=(9+8*(n+k))**0.5\na=int(b)\nprint(n-(a-3)\/\/2)","output":"constant"},{"instruction":"from copy import deepcopy\na = list(map(int, list(input())))\nb = list(map(int, list(input())))\ncnt1 = [0] * 10; cnt2 = [0] * 10\nans = []\nif (len(a) != len(b)):\n    print(''.join(map(str,sorted(a, reverse=True))))\n    exit()\nfor i in range(len(b) + 1):\n    ok = 1\n    tmp = deepcopy(a)\n    for j in range(i):\n        if b[j] in tmp:\n            tmp.pop(tmp.index(b[j]))\n        else:\n            ok = 0\n            break\n    if not ok: continue\n    pls = -1\n    ind = -1\n    for j in range(len(tmp)):\n        if (tmp[j] < b[i]):\n            if (tmp[j] > pls):\n                ind = j\n                pls = tmp[j]\n    if pls == -1 and len(tmp) != 0: continue\n    else:\n        if (len(tmp) > 0): tmp.pop(ind)\n        if i == len(b): ans.append(''.join(map(str, b[:i:])))\n        else: ans.append(''.join(map(str, b[:i:])) + str(pls) + ''.join(map(str, sorted(tmp, reverse=True))))\nprint(max(ans))","output":"cubic"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)\n\n        while l < r:\n            m = l + ((r - l) \/\/ 2)\n            if nums[m] > target:\n                r = m\n            elif nums[m] <= target:\n                l = m + 1\n        return l - 1 if (l and nums[l - 1] == target) else -1","output":"logn"},{"instruction":"def maxx(n):\n\treturn n&-n\nn,q=map(int,input().split())\nroot=n\/\/2+1\nwhile q>0:\n\tx=int(input())\n\ts=input()\n\n\tfor i in s:\n\t\tif i=='U' and x!=root:\n\t\t\tp=x+maxx(x)\n\t\t\tif x==p-maxx(p)\/\/2:\n\t\t\t\tx=p\n\t\t\telse:\n\t\t\t\tx=x-maxx(x)\n\t\telif i=='L':\n\t\t\tx=x-maxx(x)\/\/2\n\t\telif i=='R':\n\t\t\tx=x+maxx(x)\/\/2\n\tq=q-1\n\tprint(x)","output":"np"},{"instruction":"n, m = map(int, input().split())\na = sorted(map(int, input().split()))\nans = 0\ncur = 0\nfor b in a:\n  if b > cur:\n    ans += 1\n    cur += 1\n  else:\n    ans += 1\nprint(sum(a) - (ans + max(a) - cur))","output":"nlogn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111)\nINF=99999999999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        n=ri()\n        s=rs()\n\n        d={}\n        for i in range(n):\n\n            d[s[i]]=1\n        l=0\n        r=0\n        td={}\n        ans=INF\n        while l<=r and r<n:\n            while len(td)!=len(d):\n                if r==n:\n                    print(ans)\n                    exit()\n                if s[r] in td:\n                    td[s[r]]+=1\n                else:\n                    td[s[r]]=1\n                r+=1\n\n            if len(td)==len(d):\n                r-=1\n                ans=min(ans,r-l+1)\n            while l<=r:\n\n                td[s[l]]-=1\n                if td[s[l]]==0:\n                    del td[s[l]]\n                    ans=min(ans,r-l+1)\n                    l+=1\n                    break\n                l+=1\n            r+=1\n        wi(ans)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"w, h, n = map(int, input().split())\nl, r = [-1] * (w+1), [-1] * (w+1)\nt, b = [-1] * (h+1), [-1] * (h+1)\nl[0], b[0], t[h], r[w] = 0, 0, h, w\nV, H = [0] * n, [0] * n\n\nfor i in range(n):\n    line, idx = input().split()\n    idx = int(idx)\n    if line == 'V':\n        r[idx] = w\n        V[i] = idx\n    else:\n        t[idx] = h\n        H[i] = idx\n\nleft, max_w = 0, 0\nfor i in range(1, w+1):\n    if r[i] != -1:\n        l[i] = left\n        r[left] = i\n        max_w = max(max_w, i - left)\n        left = i\n\nbottom, max_h = 0, 0\nfor i in range(1 ,h+1):\n    if t[i] != -1:\n        b[i] = bottom\n        t[bottom] = i\n        max_h = max(max_h, i - bottom)\n        bottom = i\n\nres = [0] * n\nres[n-1] = max_h * max_w\nfor i in range(n-1, 0, -1):\n    if V[i] != 0:\n        max_w = max(max_w, r[V[i]] - l[V[i]])\n        r[l[V[i]]] = r[V[i]]\n        l[r[V[i]]] = l[V[i]]\n    else:\n        max_h = max(max_h, t[H[i]] - b[H[i]])\n        b[t[H[i]]] = b[H[i]]\n        t[b[H[i]]] = t[H[i]]\n    res[i-1] = max_h * max_w\n\nfor i in range(n):\n    print(res[i])","output":"nlogn"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\ns = sorted(a)\nq = a.index(max(a))\nq1, q = min(len(a)-1, q+1), max(0, q-1)\nfor q2 in range(len(a)-2, -1, -1):\n    if a[q] == s[q2]:\n        q = max(0, q-1)\n    elif a[q1] == s[q2]:\n        q1 = min(len(a)-1, q1+1)\n    else:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"n = int(input())\nprint(int(3 * n \/ 2))","output":"constant"},{"instruction":"from math import sqrt\n\ndef inpl():\n\treturn list(map(int, input().split()))\n\ndef inpi():\n\treturn int(input())\n\ndef issq(p):\n\tx = int(sqrt(p))\n\treturn x*x == p\n\ndef g(n):\n\treturn (issq(n\/\/2) and n%2==0) or (issq(n\/\/4) and n%4==0)\n\ndef f():\n\tn = inpi()\n\n\tprint(\"YES\" if g(n) else \"NO\")\n\nt = int(input())\nfor _ in range(t):\n\tf()","output":"constant"},{"instruction":"import heapq\nimport sys\ninput = sys.stdin.readline\n\nn, d, k = map(int, input().split())\nif n == 1 or n <= d:\n    ans = \"NO\"\nelif k == 1:\n    ans = \"YES\" if n == 2 and d == 1 else \"NO\"\n    e = [(1, 2)]\nelse:\n    e = [(i + 1, i + 2) for i in range(d)]\n    h = []\n    l, r = 1, d + 1\n    if k > 2:\n        for i in range(2, d + 1):\n            heapq.heappush(h, (i, 2, min(i - l, r - i)))\n    ans = \"YES\"\n    for i in range(d + 2, n + 1):\n        if not h:\n            ans = \"NO\"\n            break\n        j, k0, d0 = heapq.heappop(h)\n        e.append((j, i))\n        if k0 + 1 < k:\n            heapq.heappush(h, (j, k0 + 1, d0))\n        if d0 - 1 > 0:\n            heapq.heappush(h, (i, 1, d0 - 1))\nprint(ans)\nif ans == \"YES\":\n    for u, v in e:\n        print(u, v)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n\nimport random\n\ndef main():\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n \/ i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n \/\/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n \/\/ i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n \/ i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n \/\/ i)\n    return (n)\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n \/\/= 2\n        c += 1\n    return c\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n \/\/= 10\n    return s\nx,k=map(int,input().split())\nmod=1000000007\ntp=pow(2,k+1,mod)\ntp2=pow(2,k,mod)\nans=(tp*x-tp2+1)%mod\nprint(ans if x!=0 else 0)","output":"logn"},{"instruction":"n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"from bisect import *\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n\ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n\ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n\ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)\/\/fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n\ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return per(i,j)\/\/fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n\ndef catalan(n):\n    return com(2*n,n)\/\/(n+1)\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):\n    if a==0:return b\/\/c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b\/\/c*(n+1)+a\/\/c*n*(n+1)\/\/2\n    m=(a*n+b)\/\/c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)\/\/a)%m\n\ndef lowbit(n):\n    return n&-n\n\nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n\n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n\n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass DSU:\n    def __init__(self,n):\n        self.c=[-1]*n\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n\n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n\n    def size(self,x): return -self.c[self.find(x)]\n\nclass UFS:\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n\n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1)\n\n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return prime\n\ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        seen.add(u)\n        for v,w in graph[u]:\n            if v not in d or d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\ndef lcm(a,b): return a*b\/\/gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(n):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i+1)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v+1)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    if len(g[r])==1 and p!=-1:\n        yield None\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\ndef match(pat,cur):\n    for i in range(k):\n        if pat[i]!='_' and pat[i]!=cur[i]:\n\n            return False\n    return True\n\ndef pos(cur):\n    res=list(cur)\n\n    pa=[]\n    dfs(0,pa,res)\n    return pa\n\ndef dfs(i,pa,res):\n\n    global k\n    if i==k:\n\n        pa.append(''.join(res))\n        return\n    dfs(i+1,pa,res)\n\n    tmp=res[i]\n    res[i]='_'\n    dfs(i+1,pa,res)\n    res[i]=tmp\n\nt=1\nfor i in range(t):\n    n,m,k=RLL()\n    p=[]\n    d={}\n    for i in range(n):\n        cur=input()\n        p.append(cur)\n        d[cur]=i\n    res=[]\n    ans=True\n    ind=[0]*n\n\n    g=[[] for i in range(n)]\n    for i in range(m):\n        cur,x=input().split()\n        x=int(x)\n        if ans:\n\n            if not match(p[x-1],cur):\n                ans=False\n            else:\n\n                for al in pos(cur):\n                    if al in d and d[al]!=x-1:\n                        g[x-1].append(d[al])\n                        ind[d[al]]+=1\n    if not ans:\n        print(\"NO\")\n    else:\n\n        ans=topo(n)\n        if len(ans)!=n:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(*ans)","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\na = sorted(a, reverse=True)\ns1 = 0\ns2 = sum(a)\n\nfor i in range(len(a)):\n    s1 += a[i]\n    s2 -= a[i]\n    if s1 > s2:\n        break\n\nprint(i + 1)","output":"nlogn"},{"instruction":"import math\na = str(input())\nb = str(input())\nposa = a.count('+') - a.count('-')\nposb = b.count('+') - b.count('-')\nq = b.count('?')\ndist = (posa - posb)\nones = (abs(dist) + q) \/ 2\nif q < abs(dist) or ((dist+q) % 2):\n    ans = 0\nelse:\n    ans = float(math.factorial(q)\/(math.factorial(ones)*math.factorial(q-ones)))\n    ans \/= pow(2, q)\nprint(f'{ans:.9f}')","output":"np"},{"instruction":"import itertools\n\nn = int(input())\nboards = []\nfor i in range(4):\n    boards.append([])\n    for j in range(n):\n        boards[-1].append(list(map(int, list(input()))))\n    if i < 3: input()\n\nans = n * n * 4\n\ndef check_board(corner, board):\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] != corner:\n                ans += 1\n            corner = 1 - corner\n    return ans\n\ndef solve(corner, p):\n    ans = check_board(corner, boards[p[0]])\n    ans += check_board(1- corner, boards[p[1]])\n    ans += check_board(1 - corner, boards[p[2]])\n    ans += check_board(corner, boards[p[3]])\n\n    return ans\n\nfor p in itertools.permutations(range(4), 4):\n    ans = min(ans, solve(1, p))\n    ans = min(ans, solve(0, p))\n\nprint(ans)","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\ns = input()\nfail = [-1] * (len(s) + 1)\nfor i in range(1, len(s) + 1):\n    j = fail[i - 1]\n    while j != -1 and s[i - 1] != s[j]:\n        j = fail[j]\n    fail[i] = j + 1\n\nf1 = fail[-1]\nprint(s + s[f1:] * (k - 1))","output":"quadratic"},{"instruction":"I=lambda:list(map(int,input().split()))\nn,s,a=int(input()),I(),I()\nt=3*10**9\nq=[0]*n\nfor i in range(n-1,-1,-1):\n    u=10**8\n    for j in range(i-1,-1,-1):\n        if s[i]>s[j]:u=min(u,a[j])\n    q[i]=u\nfor i in range(n):\n    for j in range(i+1,n):\n        if s[i]<s[j]:t=min(t,a[i]+a[j]+q[i])\nprint(t if t<=sum(a)else -1)","output":"quadratic"},{"instruction":"n=int(input())\ns=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=[float('inf')]*(n)\nfor i in range(1,n):\n    mn=float('inf')\n    for j in range(i):\n        if s[i]>s[j]:\n            mn=min(mn,c[i]+c[j])\n    dp[i]=mn\nres=float('inf')\nfor i in range(1,n):\n    for j in range(i):\n        if s[i]>s[j]:\n            res=min(res,c[i]+dp[j])\nif res==float('inf'):\n    res=-1\nprint(res)","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef binary_search(c1, c2):\n    m = (c1 + c2 + 1) \/\/ 2\n    while abs(c1 - c2) > 1:\n        m = (c1 + c2 + 1) \/\/ 2\n        if ok(m):\n            c2 = m\n        else:\n            c1 = m\n    ans = check(m)\n    return ans\n\ndef ok(m):\n    s0 = m\n    for i in list(str(m)):\n        s0 -= int(i)\n    return True if s0 > s else False\n\ndef check(m):\n    for i in range(max(0, m - 5), m + 6):\n        if ok(i):\n            return max(0, n - i + 1)\n    return 0\n\nn, s = map(int, input().split())\nif not s % 9:\n    s -= 1\nans = binary_search(0, n + 1)\nprint(ans)","output":"logn"},{"instruction":"import math\n\ninput()\nall_days_problems = list(map(int, input().split()))\nsum_count = sum(all_days_problems)\nhalf_problems = math.ceil(sum_count\/2)\ncurrent_sum = 0\nanswer = 0\nfor num in all_days_problems:\n    answer += 1\n    current_sum +=num\n    if current_sum >=half_problems:\n        break\n\nprint(answer)","output":"linear"},{"instruction":"def combine(n, k, w=1, out=[], result=[]):\n    if k == 0:\n        result.append(out)\n\n    for i in range(w, n + 1):\n        new_out = out[:]\n        new_out.append(i)\n        combine(n, k-1, i+1, new_out)\n\n    return result\n\ndef main():\n\n    n, l, r, x = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    if n < 2:\n        print(0)\n        return\n\n    result = None\n    for i in range(2, n + 1):\n        if i == n:\n            result = combine(n, i)\n        else:\n            combine(n, i)\n\n    for i in range(len(result)):\n        comb = result[i]\n        for j in range(len(comb)):\n            comb[j] = c[comb[j] - 1]\n\n    cnt = 0\n    for i in range(len(result)):\n        sm = sum(result[i])\n        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):\n            cnt += 1\n\n    print(cnt)\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n=int(input())\np=[0,0]+list(map(int,input().split()))\nd=[0]*(n+1)\nfor i in range(n,1,-1):\n    if d[i]==0:\n        d[i]=1\n    d[p[i]]+=d[i]\nif n==1:\n    d[1]=1\nd=d[1:]\nd.sort()\nprint(*d)","output":"linear"},{"instruction":"n=int(input())\nl=[int(x) for x in input().split()]\nans=0;\nwhile len(l)>0:\n\ta=l[0]\n\tl=l[1:]\n\tans+=l.index(a)\n\tl.remove(a)\nprint(ans)","output":"quadratic"},{"instruction":"a = list(map(int, input().split()))\nn = a[0]\nk = a[1]\ns = input()\nm = int(-1)\nfor i in range(0, n - 1):\n    ff = int(0)\n    for j in range(0, i + 1):\n        if s[j] != s[n - i - 1 + j]:\n            ff = 1\n            break;\n    if ff == 0:\n        m = i\nprint(s, end=\"\")\nfor i in range(1, k):\n    for j in range(m + 1, n):\n        print(s[j], end=\"\")","output":"quadratic"},{"instruction":"n,v = [int(x) for x in input().strip().split(\" \")]\nif v>=(n-1):\n\tprint(n-1)\nelse:\n\tprint(n-1+((n-1-v)*(n-v)\/\/2))","output":"constant"},{"instruction":"n, k  = map(int, input().split())\na = []\nb = []\nc = 0\nd = []\n\nfor i in range(n):\n    x, y= map(int, input().split())\n    t = x-y\n    a.append(x)\n    b.append(y)\n    d.append(t)\ns = sum(a)\nd.sort()\nd = d[::-1]\nif sum(b)>k:\n    print(-1)\nelse:\n    while s>k:\n\n        s = s - d[c]\n        c = c + 1\n    print(c)","output":"nlogn"},{"instruction":"n=int(input())\ns=[c=='1' for c in input()]\nm=len(s)\nz=[[0,0]]\nfor c in s:\n ind = z[-1][c]\n z[-1][c] = len(z)\n z.append(z[ind][:])\nassert(len(z) == m+1)\nz[m][0] = z[m][1] = m\n\ndp = [0 for _ in range(m+1)]\ndp[0] = 1\nfor i in range(n):\n ndp = [0 for _ in range(m+1)]\n for i in range(m+1):\n  ndp[z[i][0]] += dp[i]\n  ndp[z[i][1]] += dp[i]\n dp = ndp\nres = dp[m]\n\nfor k in range(1, m):\n s0 = 0\n for c in s[-k:]:\n  s0 = z[s0][c]\n dp = [0 for _ in range(m+1)]\n dp[s0] = 1\n for i in range(n - k):\n  ndp = [0 for _ in range(m+1)]\n  for i in range(m+1):\n   ndp[z[i][0]] += dp[i]\n   ndp[z[i][1]] += dp[i]\n  dp = ndp\n for s1 in range(m):\n  v = dp[s1]\n  for c in s[-k:]:\n   if s1 == m: v = 0\n   s1 = z[s1][c]\n  if s1 == m: res += v\nprint(res)","output":"np"},{"instruction":"def main():\n    a, b = map(int, input().split())\n    K = 60\n    if a == b:\n        ans = 0\n    else:\n        curr = K\n        while (b & (1 << curr)) == (a & (1 << curr)):\n            curr -= 1\n        ans = (1 << curr)\n        curr -= 1\n        lb = False\n        ga = False\n        for i in range(curr, -1, -1):\n            if (b & (1 << i)) == 0 and (a & (1 << i)) == 0:\n                if not lb:\n                    ans += (1 << i)\n                    ga = True\n                else:\n                    ans += (1 << i)\n            elif (b & (1 << i)) == 0 and (a & (1 << i)) == 1:\n                ans += (1 << i)\n            elif (b & (1 << i)) == 1 and (a & (1 << i)) == 0:\n                if not lb:\n                    ans += (1 << i)\n                    ga = True\n                    lb = True\n                else:\n                    ans += (1 << i)\n            else:\n                if not lb:\n                    ans += (1 << i)\n                    lb = True\n                else:\n                    ans += (1 << i)\n    print(ans)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\nw = [int(z) for z in input().split()]; s = input(); idx = []\nfor i in range(n):\n    idx.append((w[i], i+1))\n\nidx.sort()\nheapq.heapify(idx)\nones = []\nheapq.heapify(ones)\nres = []\nfor i in range(2*n):\n    if s[i] == '0':\n        l = idx[0]\n        heapq.heappop(idx)\n        res.append(l[1])\n        heapq.heappush(ones, [-l[0], l[1]])\n    else:\n        l = ones[0]\n        heapq.heappop(ones)\n        res.append(l[1])\nres = ' '.join([str(i) for i in res])\nsys.stdout.write(res)","output":"nlogn"},{"instruction":"def clc(mid):\n    sm , i , cp = 0 , 1 , n\n    cur = 1\n    while(cp + 1 > cur):\n        sm = sm + i * cur\n        i+= 1\n        cp -= cur\n        cur = cur * mid\n    return sm + i * cp\n\nn , s = map(int,input().split())\n\nsm = n * (n + 1) \/\/ 2\ndp = [0] * 100005\nx = [0] * 100005\ny = [0] * 100005\nx[0] = 1\nif s + 1 < 2 * n:\n    print(\"No\")\n    exit()\nif s > sm:\n    print(\"No\")\n    exit()\nelse:\n    print(\"Yes\")\n\nl = 0\nr = n\nwhile r - l > 1:\n    mid = (r + l) \/\/ 2\n    if(clc(mid) > s):\n        l = mid\n    else:\n        r = mid\ni = 2\nwhile( i < n + 1):\n    y[i] = i + r\n    y[i] -= 2\n    y[i] = y[i] \/\/ r\n    x[i] = x[y[i]] + 1\n    if(dp[x[i]] == 0):\n        dp[x[i]] = i\n    i = i + 1\nmx = x[n]\nip = n\ns = s - clc(r)\nwhile(s != 0):\n    if(x[ip] != x[ip - 1]):\n        ip = ip - 1;\n    if(s > mx - x[ip]):\n        y[ip] = dp[mx]\n        mx = mx + 1\n        s -= mx - x[ip]\n        x[ip] = mx\n        dp[mx] = ip\n    else:\n        y[ip] = dp[s + x[ip] - 1]\n        s = 0\n    ip = ip - 1\ni = 2\nwhile(i < n + 1):\n    print(y[i])\n    i = i + 1","output":"linear"},{"instruction":"def forninho(miolo, s):\n    premiolo = miolo\n    temp = 0\n    while (miolo > 0):\n        temp += miolo % 10;\n        miolo = miolo \/\/ 10;\n    if (premiolo - temp >= s):\n        return 1\n    else:\n        return 0\n\nentrada = input().split()\nn = int(entrada[0])\ns = int(entrada[1])\n\nresult = -1\nl = 1\nr = n\nwhile (r-l >= 0):\n    miolo = (l + r) \/\/ 2\n    if(forninho(miolo,s) == 1):\n        r = miolo - 1\n        result = miolo\n    else:\n        l = miolo + 1\n\nif (result == -1):\n    print(\"0\")\nelse:\n    print(n - result + 1)","output":"logn"},{"instruction":"import decimal\n\nn, k = input().split(' ')\nn = int(n)\nk = int(k)\ncoef1 = (k*k-k-2*n)*100+225\nif coef1 < 0:\n    print('-1')\nelse:\n    D = decimal.Decimal\n    coef11 = D(coef1)\n    coef1 = coef11.sqrt()\n    coef2 = k*10-5\n    coef = (coef2-coef1)\/10\n    if coef % 1 == 0:\n        print(int(coef))\n    else:\n        print(int(coef)+1)","output":"logn"},{"instruction":"from bisect import bisect,bisect_left\n\nfrom collections import *\nfrom heapq import *\nfrom math import gcd,ceil,sqrt,floor,inf\n\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n\ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n\ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n\ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)\/\/fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n\ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return per(i,j)\/\/fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n\ndef catalan(n):\n    return com(2*n,n)\/\/(n+1)\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):\n    if a==0:return b\/\/c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b\/\/c*(n+1)+a\/\/c*n*(n+1)\/\/2\n    m=(a*n+b)\/\/c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)\/\/a)%m\n\ndef lowbit(n):\n    return n&-n\n\nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n\n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n\n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):\n        n=len(arr)\n        mx=n.bit_length()\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n\nclass DSU:\n    def __init__(self,n):\n        self.c=[-1]*n\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n\n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n\n    def size(self,x): return -self.c[self.find(x)]\n\nclass UFS:\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n\n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\nclass UF:\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n        self.size=AI(n,1)\n        self.edge=A(n)\n\n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            self.edge[pu]+=1\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            self.edge[pu]+=self.edge[pv]+1\n            self.size[pu]+=self.size[pv]\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n            self.edge[pv]+=self.edge[pu]+1\n            self.size[pv]+=self.size[pu]\n\ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1)\n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n\ndef dij(s,graph):\n    d=AI(n,inf)\n    d[s]=0\n    heap=[(0,s)]\n    vis=A(n)\n    while heap:\n        dis,u=heappop(heap)\n        if vis[u]:\n            continue\n        vis[u]=1\n        for v,w in graph[u]:\n            if d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b\/\/gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n\nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\nt=1\nfor i in range(t):\n    n,mod=RL()\n\n    ma=(n+1)\/\/2\n    ifact(n,mod)\n    dp=A2(n+1,ma+1)\n    f=A(n+1)\n    f[1]=1\n    f[2]=2\n    f[3]=4\n    for i in range(4,n+1):\n        f[i]=f[i-1]*2%mod\n    dp[1][1]=1\n    dp[2][1]=2\n    dp[3][1]=4\n    dp[3][2]=2\n    for i in range(4,n+1):\n        dp[i][1]=f[i]\n        for k in range(2,(i+1)\/\/2+1):\n            for x in range(1,i-2*k+3):\n\n                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod\n                dp[i][k]%=mod\n    ans=0\n    for k in range(1,ma+1):\n        ans=(ans+dp[n][k])%mod\n    print(ans)","output":"cubic"},{"instruction":"n,l,r,x = map(int,input().split())\nc = list(map(int,input().split()))\nans = 0\n\nfor mask in range(1 << n):\n    a = []\n    for bit in range(n):\n        if mask & (1 << bit):\n           a.append(c[bit])\n    if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r:\n        ans += 1\nprint(ans)","output":"np"},{"instruction":"n = int(input())\nsumm = 1\nfor i in range(1, n):\n    summ+=i*4\nprint(summ)","output":"linear"},{"instruction":"from collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\ndef bootstrap(f, stack=[]):\n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\nclass MDArray(object):\n\n  def __init__(self, dimensions, initial_value=0):\n\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n\n    self.arr[self._index(indexes)] = value\n    return value\n\ndef encode(row, col, n, m):\n  return row * m + col\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\ndef main(inp, out):\n\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = MDArray([total_nodes, k+2], -1)\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k\/2, adj, dp) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()","output":"cubic"},{"instruction":"def solve():\n    k = [int(x) for x in input().split(' ')]\n    k.sort()\n    if min(k) == 1:\n        return \"YES\"\n    elif k.count(2) >= 2:\n        return \"YES\"\n    elif k.count(3) == 3:\n        return \"YES\"\n    elif k == [2, 4, 4]:\n        return \"YES\"\n    return \"NO\"\n\nprint(solve())","output":"constant"},{"instruction":"s = input()\n\ncount = 0\n\ni = 0\n\nwhile i < len(s):\n\n    if int(s[i]) % 3 == 0:\n\n        count += 1\n        i += 1\n\n    elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ):\n\n        count += 1\n        i +=2\n\n    elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') :\n\n        count += 1\n        i += 3\n\n    else:\n\n        i +=1\n\nprint(count)","output":"linear"},{"instruction":"n,k=map(int,input().split())\nn,k=n-1,k-1\nl=0\nr=k\ng=k*(k+1)\/\/2\nans=-1\nwhile l<=r:\n\tm=(l+r)\/\/2\n\tif (g-m*(m+1)\/\/2)>=n:\n\t\tans=k-m\n\t\tl=m+1\n\telse:\n\t\tr=m-1\nprint(ans)","output":"logn"},{"instruction":"numbersDict = {\n\"1\": \"H\",\n\"2\": \"He\",\n\"3\": \"Li\",\n\"4\": \"Be\",\n\"5\": \"B\",\n\"6\": \"C\",\n\"7\": \"N\",\n\"8\": \"O\",\n\"9\": \"F\",\n\"10\": \"Ne\",\n\"11\": \"Na\",\n\"12\": \"Mg\",\n\"13\": \"Al\",\n\"14\": \"Si\",\n\"15\": \"P\",\n\"16\": \"S\",\n\"17\": \"Cl\",\n\"18\": \"Ar\",\n\"19\": \"K\",\n\"20\": \"Ca\",\n\"21\": \"Sc\",\n\"22\": \"Ti\",\n\"23\": \"V\",\n\"24\": \"Cr\",\n\"25\": \"Mn\",\n\"26\": \"Fe\",\n\"27\": \"Co\",\n\"28\": \"Ni\",\n\"29\": \"Cu\",\n\"30\": \"Zn\",\n\"31\": \"Ga\",\n\"32\": \"Ge\",\n\"33\": \"As\",\n\"34\": \"Se\",\n\"35\": \"Br\",\n\"36\": \"Kr\",\n\"37\": \"Rb\",\n\"38\": \"Sr\",\n\"39\": \"Y\",\n\"40\": \"Zr\",\n\"41\": \"Nb\",\n\"42\": \"Mo\",\n\"43\": \"Tc\",\n\"44\": \"Ru\",\n\"45\": \"Rh\",\n\"46\": \"Pd\",\n\"47\": \"Ag\",\n\"48\": \"Cd\",\n\"49\": \"In\",\n\"50\": \"Sn\",\n\"51\": \"Sb\",\n\"52\": \"Te\",\n\"53\": \"I\",\n\"54\": \"Xe\",\n\"55\": \"Cs\",\n\"56\": \"Ba\",\n\"57\": \"La\",\n\"58\": \"Ce\",\n\"59\": \"Pr\",\n\"60\": \"Nd\",\n\"61\": \"Pm\",\n\"62\": \"Sm\",\n\"63\": \"Eu\",\n\"64\": \"Gd\",\n\"65\": \"Tb\",\n\"66\": \"Dy\",\n\"67\": \"Ho\",\n\"68\": \"Er\",\n\"69\": \"Tm\",\n\"70\": \"Yb\",\n\"71\": \"Lu\",\n\"72\": \"Hf\",\n\"73\": \"Ta\",\n\"74\": \"W\",\n\"75\": \"Re\",\n\"76\": \"Os\",\n\"77\": \"Ir\",\n\"78\": \"Pt\",\n\"79\": \"Au\",\n\"80\": \"Hg\",\n\"81\": \"Tl\",\n\"82\": \"Pb\",\n\"83\": \"Bi\",\n\"84\": \"Po\",\n\"85\": \"At\",\n\"86\": \"Rn\",\n\"87\": \"Fr\",\n\"88\": \"Ra\",\n\"89\": \"Ac\",\n\"90\": \"Th\",\n\"91\": \"Pa\",\n\"92\": \"U\",\n\"93\": \"Np\",\n\"94\": \"Pu\",\n\"95\": \"Am\",\n\"96\": \"Cm\",\n\"97\": \"Bk\",\n\"98\": \"Cf\",\n\"99\": \"Es\",\n\"100\": \"Fm\"\n}\n\nlettersDict = {\n\"H\": \"1\",\n\"He\": \"2\",\n\"Li\": \"3\",\n\"Be\": \"4\",\n\"B\": \"5\",\n\"C\": \"6\",\n\"N\": \"7\",\n\"O\": \"8\",\n\"F\": \"9\",\n\"Ne\": \"10\",\n\"Na\": \"11\",\n\"Mg\": \"12\",\n\"Al\": \"13\",\n\"Si\": \"14\",\n\"P\": \"15\",\n\"S\": \"16\",\n\"Cl\": \"17\",\n\"Ar\": \"18\",\n\"K\": \"19\",\n\"Ca\": \"20\",\n\"Sc\": \"21\",\n\"Ti\": \"22\",\n\"V\": \"23\",\n\"Cr\": \"24\",\n\"Mn\": \"25\",\n\"Fe\": \"26\",\n\"Co\": \"27\",\n\"Ni\": \"28\",\n\"Cu\": \"29\",\n\"Zn\": \"30\",\n\"Ga\": \"31\",\n\"Ge\": \"32\",\n\"As\": \"33\",\n\"Se\": \"34\",\n\"Br\": \"35\",\n\"Kr\": \"36\",\n\"Rb\": \"37\",\n\"Sr\": \"38\",\n\"Y\": \"39\",\n\"Zr\": \"40\",\n\"Nb\": \"41\",\n\"Mo\": \"42\",\n\"Tc\": \"43\",\n\"Ru\": \"44\",\n\"Rh\": \"45\",\n\"Pd\": \"46\",\n\"Ag\": \"47\",\n\"Cd\": \"48\",\n\"In\": \"49\",\n\"Sn\": \"50\",\n\"Sb\": \"51\",\n\"Te\": \"52\",\n\"I\": \"53\",\n\"Xe\": \"54\",\n\"Cs\": \"55\",\n\"Ba\": \"56\",\n\"La\": \"57\",\n\"Ce\": \"58\",\n\"Pr\": \"59\",\n\"Nd\": \"60\",\n\"Pm\": \"61\",\n\"Sm\": \"62\",\n\"Eu\": \"63\",\n\"Gd\": \"64\",\n\"Tb\": \"65\",\n\"Dy\": \"66\",\n\"Ho\": \"67\",\n\"Er\": \"68\",\n\"Tm\": \"69\",\n\"Yb\": \"70\",\n\"Lu\": \"71\",\n\"Hf\": \"72\",\n\"Ta\": \"73\",\n\"W\": \"74\",\n\"Re\": \"75\",\n\"Os\": \"76\",\n\"Ir\": \"77\",\n\"Pt\": \"78\",\n\"Au\": \"79\",\n\"Hg\": \"80\",\n\"Tl\": \"81\",\n\"Pb\": \"82\",\n\"Bi\": \"83\",\n\"Po\": \"84\",\n\"At\": \"85\",\n\"Rn\": \"86\",\n\"Fr\": \"87\",\n\"Ra\": \"88\",\n\"Ac\": \"89\",\n\"Th\": \"90\",\n\"Pa\": \"91\",\n\"U\": \"92\",\n\"Np\": \"93\",\n\"Pu\": \"94\",\n\"Am\": \"95\",\n\"Cm\": \"96\",\n\"Bk\": \"97\",\n\"Cf\": \"98\",\n\"Es\": \"99\",\n\"Fm\": \"100\"\n}\n\n_ = input()\natoms = input().split(\" \")\noutAtoms = input().split(\" \")\natoms = sorted(list(map(lambda x: int(lettersDict[x]), atoms)))\noutAtoms = sorted(list(map(lambda x: int(lettersDict[x]), outAtoms)))\n\nsumAtoms = 0\ndef testIfPossible():\n    atomsx = atoms.copy()\n    outAtomsx = outAtoms.copy()\n    for i in range(len(atoms) - 1, -1, -1):\n        if atomsx[i] > outAtomsx[-1]:\n            atomsx.pop()\n    if sum(outAtomsx) > sum(atomsx):\n        print(\"NO\")\n        exit()\n\ntestIfPossible()\nfor at in atoms:\n    sumAtoms += at\noutAtom = 0\nfor at in outAtoms:\n    outAtom += at\ndef dfs(i: int, currentSum: int, arr: [int], searchSum: int) -> [[int]]:\n    if i >= len(arr) or currentSum + arr[i] > searchSum:\n        return []\n    totalRes = []\n\n    res = dfs(i + 1, currentSum + arr[i], arr, searchSum)\n    totalRes += [[i] + a for a in res]\n\n    res = dfs(i + 1, currentSum, arr, searchSum)\n    totalRes += [a for a in res]\n    if currentSum + arr[i] == searchSum:\n        totalRes.append([i])\n    return totalRes\n\nallCombos = [[set(x) for x in dfs(0, 0, atoms, out)] for out in outAtoms]\ncurrentSet = set()\nstack = []\nresultFound = False\ndef dfs2(i: int):\n    global resultFound\n    global stack\n    global currentSet\n    if i >= len(allCombos):\n        resultFound = True\n        return\n    for set in allCombos[i]:\n        if not set & currentSet:\n            stack.append(set)\n            currentSet = currentSet | set\n            dfs2(i + 1)\n            if resultFound:\n                break\n            stack.pop()\n            currentSet = currentSet - set\nisAnyEmpty = False\nfor comb in allCombos:\n    if not comb:\n        isAnyEmpty = True\nif not isAnyEmpty:\n    dfs2(0)\n\nif resultFound:\n    print(\"YES\")\n    res = list(map(lambda x: \"+\".join(list(map(lambda y: numbersDict[f\"{atoms[y]}\"],list(x)))), stack))\n    outs = list(map(lambda x: numbersDict[f\"{x}\"], outAtoms))\n    tot = list(map(lambda x: x[0] + \"->\" + x[1], zip(res, outs)))\n\n    for t in tot:\n        print(t)\nelse:\n    print(\"NO\")","output":"np"},{"instruction":"n=int(input())\nif n<3:\n    print(n)\nelse:\n    if n%2!=0:\n        print(n*(n-1)*(n-2))\n    else:\n        if n==6:\n            print(60)\n        elif n%3==0:\n            print((n-1)*(n-2)*(n-3))\n        else:\n            print(n*(n-1)*(n-3))","output":"constant"},{"instruction":"n, m = list(map(int,input().split()))\nx = list(map(int,input().split()))\nt = list(map(int,input().split()))\narr = []\npep = {}\nfor i in range(n+m):\n    if t[i] == 0:\n        arr.append(i)\n        pep[x[i]] = 0\n    else:\n        for j in arr:\n            pep[x[j]] = i\n        arr = []\nfor i in range(n+m-1, -1, -1):\n    if t[i] == 0:\n        arr.append(i)\n    else:\n        for j in arr:\n            if abs(x[j] - x[i]) <= abs(x[pep[x[j]]] - x[j]):\n                pep[x[j]] = i\n        arr = []\nans = []\nfor i in range(n+m):\n    if t[i]:\n        ans.append(1)\n    else:\n        ans.append(0)\nfor i in pep:\n    ans[pep[i]] += 1\nfor i in ans:\n    if i:\n        print(i-1, end = ' ')","output":"quadratic"},{"instruction":"s=input()\ns1=input()\nl=[]\nl1=[]\nfor x in s :\n    l.append(int(x))\nfor x in s1 :\n    l1.append(int(x))\nd={}\nfor x in l :\n    d[x]=d.get(x,0)+1\nf=False\nif len(s1)>len(s) :\n    l=sorted(l)\n    l=l[::-1]\n    print(\"\".join(map(str,l)))\n    exit()\nans=[0]*len(s)\n\nki=0\ni=0\nwhile(i<len(l1)) :\n    f=True\n    for j in range(max(l1[i],ki),-1,-1) :\n        if d.get(j,-1)>0 :\n            ans[i]=j\n            d[j]-=1\n            f=False\n            if j!=l1[i] :\n\n                ki=9\n            break\n\n    if f :\n\n        for i1 in range(i-1,-1,-1) :\n            f1=False\n            for j in range(max(l1[i1],ki)-1,-1,-1) :\n                if d.get(j,-1)>0 :\n                    d[ans[i1]]+=1\n                    ans[i1]=j\n                    d[j]-=1\n                    f1=True\n                    i=i1\n                    ki=9\n                    break\n            if f1 :\n                break\n            else :\n                d[ans[i1]]+=1\n                ans[i1]=0\n    i+=1\n\nprint(\"\".join(map(str,ans)))","output":"cubic"},{"instruction":"n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nb=[]\nfor i in range(11):\n    c={}\n    for j in range(n):\n        d=(a[j]*(10**i))%k\n        if d in c.keys():\n            c[d]+=1\n        else:\n            c[d]=1\n    b.append(c)\n\ns=0\nfor i in range(n):\n    c=a[i]%k\n    d=(k-c)%k\n    if d in b[len(str(a[i]))]:\n        s+=b[len(str(a[i]))][d]\n    if (a[i]*(10**len(str(a[i]))))%k==d:\n        s-=1\nprint(s)","output":"nlogn"},{"instruction":"I=lambda:map(int,input().split())\nn,s=I()\nl=[0]\nfor i in range(n):\n    q,w=I()\n    q=q*60+w\n    l+=[q]\nif l[1]-l[0]>s:exit(print(0, 0))\nfor i in range(n):\n    if l[i+1]-l[i]>2*s+1:\n        l[i]+=s+1\n        exit(print(l[i]\/\/60,l[i]%60))\nl[-1]+=s+1\nprint(l[-1]\/\/60,l[-1]%60)","output":"linear"},{"instruction":"n,x = list(map(int, input().split()))\narr = list(map(int, input().split()))\nf = [0]*100100\ns = [0]*100100\ncan = [False]*100100\nfor i in range(n):\n    f[arr[i]]+=1\n    s[arr[i]&x]+=1\n    if (arr[i]&x != arr[i]):\n        can[arr[i]&x] = True\nans = 3\nfor i in range(len(f)):\n    if f[i] >= 2:\n        ans = 0\n        break\n    if f[i] == 1 and s[i] >= 1:\n        if can[i]:\n            ans = min(ans,1)\n    if s[i] >= 2:\n        ans = min(ans,2)\nif ans == 3:\n    print(-1)\nelse:\n    print(ans)","output":"linear"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\np=0\nwhile p+1<len(a) and a[p]==a[p+1]:\n    p+=2\nc=0\nwhile p<len(a):\n    if p+1<len(a):\n        i=a.index(a[p],p+1)\n        c+=i-p-1\n        tmp=a.pop(i)\n        a.insert(p,tmp)\n    while p+1<len(a) and a[p]==a[p+1]:\n        p+=2\nprint(c)","output":"quadratic"},{"instruction":"import sys\nimport math\n\ndef main():\n    i = sys.stdin.readlines()\n\n    n = int(i[0].strip())\n    points = []\n    for pi in range(n):\n        p = i[pi + 1]\n        x, y = p.strip().split()\n        points.append([int(x), int(y)])\n\n    if n < 5:\n        print('YES')\n        return\n\n    st = [False] * n\n\n    def run(first, second):\n        dx = first[0] - second[0]\n        dy = first[1] - second[1]\n\n        for i, p in enumerate(points):\n            if st[i]:\n                continue\n            if dx == 0:\n                if p[0] == first[0]:\n                    st[i] = True\n            elif dy == 0:\n                if p[1] == first[1]:\n                    st[i] = True\n            else:\n\n                if ((p[0] - first[0]) * dy) == (p[1] - first[1]) * dx:\n                    st[i] = True\n\n    def check(fi, si):\n        for i in range(n):\n            st[i] = i == fi or i == si\n\n        run(points[fi], points[si])\n\n        fi = None\n        si = None\n        for i in range(n-1):\n            if not st[i]:\n                fi = i\n                for j in range(i+1, n):\n                    if not st[j]:\n                        si = j\n                        break\n                break\n        if fi is None or si is None:\n            return True\n\n        st[fi] = True\n        st[si] = True\n        run(points[fi], points[si])\n        return not (False in st)\n\n    if check(0, 1) or check(0, 2) or check(1, 2):\n        print('YES')\n    else:\n        print('NO')\n\nmain()","output":"nlogn"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn,m = inpl()\ncnt = [0]*n\nc = inpl_1()\nfor x in c: cnt[x] += 1\nprint(min(cnt))","output":"quadratic"},{"instruction":"n,k=[int(i) for i in input().split()]\na = pow(1+2*k+2*n,0.5) - 1\nprint(n-int(a))","output":"constant"},{"instruction":"def subsets(L, i):\n    if i == len(L):\n        yield []\n    else:\n        for s in subsets(L, i+1):\n            yield s\n            yield [L[i]] + s\n\ndef computeValidProblemsets(problems, l, r, x):\n    isValid = lambda ps: (len(ps) > 1) and (l <= sum(ps) <= r) and (ps[-1]-ps[0] >= x)\n    print(sum(isValid(problemset) for problemset in subsets(sorted(problems), 0)))\n\nif __name__ == '__main__':\n    n, l, r, x = map(int, input().split())\n    problems = list(map(int, input().split()))\n    computeValidProblemsets(problems, l, r, x)","output":"np"},{"instruction":"for _ in range(1):\n    n,s=map(int,input().split())\n\n    lo=0\n    hi=n\n    ans=n +1\n    while lo<=hi:\n        mi=(lo+hi)>>1\n        curr=sum(int(i) for i in str(mi))\n        if mi-curr>=s:\n            hi=mi-1\n            ans=mi\n        else:\n            lo=mi+1\n    print(n-ans+1)","output":"logn"},{"instruction":"n, m=[int(k) for k in input().split()]\nw=[int(k) for k in input().split()]\nw=[0]+w+[m]\nc, d=[], []\nres=0\nfor j in range(n+1):\n    c.append(res)\n    if j%2==0:\n        res+=w[j+1]-w[j]\nres=0\nfor j in range(n+1, -1, -1):\n    if j%2==0 and j!=n+1:\n        res+=w[j+1]-w[j]\n    d.append(res)\nd=d[::-1]\nmx=d[0]\nfor j in range(n+1):\n    mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx)\n\nprint(mx)","output":"linear"},{"instruction":"n=int(input())\na=[0]+list(map(int,input().split()))\nans=0\nfor i in range(1,len(a)):\n    if a[i]==-1:\n        continue\n    j=i\n    while a[j]!=-1:\n        prev=j\n        j=a[j]\n        a[prev]=-1\n    ans+=1\nif n%2==0:\n\n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")\nelse:\n\n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")","output":"nlogn"},{"instruction":"import math\n\ndef Maxxor(l,r):\n\tif(l==r):\n\t\treturn 0\n\telse:\n\t\treflog=math.floor(math.log2(r))\n\t\tref=2**reflog\n\t\tif(l<ref):\n\t\t\treturn (2*ref)-1\n\t\telse:\n\t\t\treturn Maxxor(l-ref,r-ref)\n\nl,r = map(int, input().split())\nans=Maxxor(l,r)\nprint(ans)","output":"logn"},{"instruction":"def solve(rn,gn,bn,r,g,b):\n    r = sorted(r,reverse=True)\n    g = sorted(g, reverse=True)\n    b = sorted(b, reverse=True)\n\n    dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)]\n\n    ans = 0\n    for i in range(rn+1):\n        for j in range(gn+1):\n            for k in range(bn+1):\n                if i < rn and j < gn:\n                    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n                if i < rn and k < bn:\n                    dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])\n                if j < gn and k <bn:\n                    dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n\n                ans = max(ans,dp[i][j][k])\n\n    print(ans)\n\nif __name__ == '__main__':\n    rn, gn, bn = map(int,input().split())\n\n    r = list(map(int,input().split()))\n    g = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    solve(rn,gn,bn,r,g,b)","output":"cubic"},{"instruction":"a = sorted(input())\nb = int(input())\na = a[::-1]\np = ''\ncnt = [0]*10\n\nwhile a :\n    for i, d in enumerate(a):\n        n = p + d + \"\".join(sorted(a[:i]+a[i+1:]))\n        if int(n) <= b :\n            p += d\n            a.pop(i)\n            break\n\nprint(p)","output":"cubic"},{"instruction":"x, k = map(int, input().split())\n\nmd = 10 ** 9 + 7\n\nres = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0\nprint(res % md)","output":"logn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nb=[0]*n\nfor i in range(n):\n    if(i+1>a[i]):\n        b[i]=i+1\n    else:\n        q=(a[i]-(i+1)+n)\/\/n\n        b[i]=i+1 + q*n\nprint(b.index(min(b))+1)","output":"linear"},{"instruction":"def resheto(a):\n    numbers = list(range(0, a + 1))\n    primes = set()\n    for k in range(2, a + 1):\n        if numbers[k] != 0:\n            primes.add(k)\n            for j in range(2 * k, a + 1, k):\n                numbers[j] = 0\n    return primes\n\nall_primes = resheto(10**6)\nn = int(input())\nfor i in range(2, n):\n    if i not in all_primes and (n - i) not in all_primes:\n        print(i, n - i)\n        break","output":"constant"},{"instruction":"n = int(input())\nl = tuple(map(int,input().split()))\nr = tuple(map(int,input().split()))\ns = [ (i,sum(v)) for i,(v) in enumerate(zip(l,r)) ]\nss = sorted(s, key= lambda a:a[1] )\n\ncandies = [0]*n\nfor p in ss:\n    candies[p[0]] = n-p[1]\n\nll = [0]\nfor i in range(1,n):\n    ll.append(sum([1 for c in candies[:i] if c > candies[i]]))\n\nrr = [0]\nfor i in range(n-2,-1,-1):\n    rr.append(sum([1 for c in candies[i:] if c > candies[i]]))\n\nfor i in range(n):\n    if ll[i] != l[i]:\n        print(\"NO\")\n        break\n    if rr[n-1-i] != r[i]:\n        print(\"NO\")\n        break\n    if i == n-1:\n        print(\"YES\")\n        print(' '.join(map(str,candies)))","output":"nlogn"},{"instruction":"def main():\n    def update(l, r, i, res):\n        j = 0\n        while j < i:\n            if res[j] is None:\n                r[j] -= 1\n                if r[j] < 0:\n                    return False\n            j += 1\n        j += 1\n        while j < n:\n            if res[j] is None:\n                l[j] -= 1\n                if l[j] < 0:\n                    return False\n            j += 1\n        return True\n\n    ilist = {1}\n    n = int(input())\n    res = [None] * n\n    cur = n\n    l = [int(x) for x in input().split()]\n    r = [int(x) for x in input().split()]\n\n    while ilist and (sum(l) != 0 or sum(r) != 0):\n        ilist = set()\n        for i in range(n):\n            if l[i] == r[i] == 0 and res[i] is None:\n                res[i] = cur\n                ilist.add(i)\n        for i in ilist:\n            check = update(l, r, i, res)\n            if not check:\n                return False\n        cur -= 1\n    if not ilist:\n        return False\n    for i in range(n):\n        if res[i] is None:\n            res[i] = cur\n    return res\n\nif __name__ == '__main__':\n    res = main()\n    if not res:\n        print('NO')\n    else:\n        print('YES')\n        for x in res:\n            print(x, end=' ')","output":"quadratic"},{"instruction":"import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\nn,U = ilele()\nA = alele()\nAns = -1\nfor i in range(n-2):\n    x = A[i]\n    y = x  + U\n    z = bisect.bisect_left(A,y,lo = i+2,hi = n)\n\n    if z == n:\n        z-=1\n    if A[z] <= x +U:\n        a = A[z]\n    elif A[z-1] <= x +U and z-1 != i+1:\n        a = A[z-1]\n    else:\n        continue\n    b = (a - A[i+1])\/(a - A[i])\n\n    Ans = max(Ans,b)\nprint(Ans)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    n = N()\n    arr = RLL()\n\n    dp = [[n]*n for i in range(n)]\n    rec = [[0]*n for i in range(n)]\n\n    for i in range(n):\n        rec[i][i] = arr[i]\n        dp[i][i] = 1\n\n    for le in range(2, n+1):\n        for l in range(n):\n            r = l+le-1\n            if r>n-1: break\n            for m in range(l, r):\n                dp[l][r] = min(dp[l][r], dp[l][m] + dp[m+1][r])\n\n                if rec[l][m]==rec[m+1][r] and dp[l][m]==dp[m+1][r]==1:\n                    dp[l][r] = 1\n                    rec[l][r] = rec[l][m]+1\n    print(dp[0][-1])\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"l,r = map(int,input().split())\n\np = l\nlp = -1\nwhile p:\n    p = p>>1\n    lp+=1\n\nq = r\nrp = -1\nwhile q:\n    q = q>>1\n    rp+=1\n\ns = max(lp,rp)\n\nn=0\n\nwhile s>=0:\n    if l>>s&1!=r>>s&1:\n        n |= (r>>s&1)<<s\n        break\n    s-=1\n\ns-=1\n\nwhile s>=0:\n    n |= 1<<s\n    s-=1\n\nprint(n)","output":"logn"},{"instruction":"import math\n\n[n,k]=[int(i) for i in input().split()]\n\nif(n==1):\n\tprint(0)\nelse:\n\n\tr=int(math.sqrt(9+8*(k+n)))\n\ty=(-3+r)\/\/2\n\tprint(n-y)","output":"logn"},{"instruction":"string = input()\nl, r = string.split()\nl = int(l)\nr = int(r)\np = l ^ r\nx = 1\nwhile x <= p:\n    x = x << 1\nprint(x-1)","output":"logn"},{"instruction":"from math import log2\nimport sys\nout = sys.stdout\nn = int(input())\nif n == 3:\n    print(1, 1, 3)\nelse:\n    tmp = n\n    current = 1\n    while n != 1:\n        if n % 2 != 0:\n            z = (n\/\/2) + 1\n        else:\n            z = n\/\/2\n        for i in range(z):\n            out.write(str(current) + ' ')\n        n -= z\n        current *= 2\n    step = int(log2(tmp))\n    if tmp % 2**(step - 1) == 0:\n        out.write(str(tmp))\n    else:\n        q = 2**(step - 1)\n        ans = 0\n        for i in range(1, 1000):\n            if q*i <= tmp:\n                ans = max(ans, q*i)\n            else:\n                break\n        out.write(str(ans))","output":"nlogn"},{"instruction":"if __name__ == '__main__':\n\n    x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')]\n\n    lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3\n\n    stairs_time = abs(y-x)*t1\n\n    if lift_time <= stairs_time:\n        print('YES')\n    else:\n        print('NO')","output":"constant"},{"instruction":"from sys import stdin\nx, k = map(int, stdin.readline().split())\nif x == 0:\n\tprint(0)\nelse:\n\tmod = 1000000007\n\ta = pow(2,k,mod)%mod\n\tb = (2*a)%mod\n\tprint((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)","output":"logn"},{"instruction":"n = int(input())\n\ndt = input()\ns = dt.split()\na = [int(x) for x in s]\nsortm = [int(x) for x in s]\n\nsortm.sort()\n\ncnt = 0\n\nfor i in range(n):\n\tif a[i] != sortm[i]:\n\t\tcnt += 1\n\nif cnt <= 2:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"nlogn"},{"instruction":"from sys import stdin\ninput = stdin.readline\n\ndef solve():\n    n = int(input())\n    x = [int(x) for x in input().split()]\n    s = set(x)\n    ans = [x[0]]\n    for i in range(n):\n        for j in range(0, 32):\n            if x[i] + 2**j in s:\n                ans = [x[i], x[i] + 2**j]\n                if x[i] + (2**j * 2) in s:\n                    ans.append(x[i] + (2**j * 2))\n                    return ans\n    return ans\n\nans = solve()\nprint(len(ans))\nprint(*ans)","output":"nlogn"},{"instruction":"n,m = map(int, input().split())\ntL0 = list(map(int, input().split()))\ntL = [0] * n\nscore = 0\n\nfor i in range(m):\n    tL[tL0[i] - 1] += 1\n    if(0 not in tL):\n        score += 1\n        for i in range(n):\n            tL[i] = tL[i] - 1\n\nprint(score)","output":"quadratic"},{"instruction":"def dsum(n):\n    return sum([int(c) for c in str(n)])\n\nn, s = map(int, input().split(' '))\nl = 1\nr = n\nwhile l <= r:\n    mid = (l + r) \/\/ 2\n    delta = mid - dsum(mid)\n    if delta >= s:\n        r = mid - 1\n    else:\n        l = mid + 1\nprint(n - l + 1)","output":"logn"},{"instruction":"R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr.sort()\ng.sort()\nb.sort()\ndp = [[[0]*202 for i in range(202)] for j in range(202)]\nfor i in range(R+1):\n       for j in range(G+1):\n              for k in range(B+1):\n                     if i and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n                     if i and k:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n                     if k and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\nprint(dp[R][G][B])","output":"cubic"},{"instruction":"def findValue(n,m):\n\n\treturn n*(n+1)\/\/2 - m*(m+1)\/\/2 - (n-m-1)\n\nn,k = map(int,input().split())\n\nmaxi = k*(k+1)\/\/2 - k + 1\n\nif n==1:\n\tprint(0)\nelif  n>maxi:\n\tprint(-1)\nelse:\n\tbegin = 2\n\tend = k\n\n\twhile (begin<=end):\n\n\t\tmid = (begin+end)\/\/2\n\t\tvalue = findValue(k,mid)\n\n\t\tif value==n:\n\t\t\tMID=mid\n\t\t\tbreak\n\t\telif value>n:\n\t\t\tbegin = mid+1\n\t\telse:\n\t\t\tMID=mid\n\t\t\tend=mid-1\n\n\tremaining = n-findValue(k,MID)\n\n\tif remaining ==0:\n\t\tprint(k-MID)\n\telse:\n\t\tprint(k-MID+1)","output":"logn"},{"instruction":"import sys\n\nn,a,b = map(int, sys.stdin.readline().strip().split(' '))\n\nans = []\ng = {i:set({}) for i in range(n)}\n\nif a > 1 and b > 1:\n\tprint(\"NO\")\nelif a == 1 and b == 1:\n\tif n == 1:\n\t\tprint(\"YES\")\n\t\tprint(\"0\")\n\telif n < 4:\n\t\tprint(\"NO\")\n\telse:\n\t\tfor i in range(n-1):\n\t\t\tg[i].add(i+1)\n\t\t\tg[i+1].add(i)\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\t\tprint(\"YES\")\n\t\tprint('\\n'.join(ans))\nelse:\n\tswap = False\n\tif a == 1:\n\t\ta, b = b, a\n\t\tswap = True\n\tfor i in range(a-1,n-1):\n\t\tg[i].add(i+1)\n\t\tg[i+1].add(i)\n\tif swap:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i == j:\n\t\t\t\t\ttmp.append('0')\n\t\t\t\telif i not in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\telse:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\tprint(\"YES\")\n\tprint('\\n'.join(ans))","output":"quadratic"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111)\nINF=999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n\n        return self._len\n\n    def __getitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc = 1\n    for _ in range(tc):\n        n,k=ria()\n        a=ria()\n        a=sorted(a)\n        d=Counter(a)\n        ans=0\n        for i in a:\n            if d[i]:\n                ans+=1\n                d[i*k]=0\n        wi(ans)\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"nlogn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nleaf=[i+1 for i in range(n) if a[i]==1]\nroot_w=[i+1 for i in range(n) if a[i]!=1]\nroot_r=[a[i-1]-2 for i in root_w]\nl_path=root_w\nif(len(leaf)!=0):\n    l_path=[leaf[0]]+l_path\n    leaf=leaf[1:]\nif(len(leaf)!=0):\n    l_path=l_path+[leaf[0]]\n    leaf=leaf[1:]\n\nif sum(root_r)<len(leaf):\n    print(\"NO\")\nelse:\n    print(\"YES {}\".format(len(l_path)-1))\n    print(n-1)\n    for i in range(len(l_path)-1):\n        print(\"{} {}\".format(l_path[i],l_path[i+1]))\n    for l in leaf:\n        while(len(root_r)>0 and root_r[0]==0):\n            root_w = root_w[1:]\n            root_r = root_r[1:]\n        print(\"{} {}\".format(l,root_w[0]))\n        root_r[0] = root_r[0]-1","output":"linear"},{"instruction":"n = int(input())\nres = []\nmultiplier = 1\nwhile n > 1:\n\tnew_n = n \/\/ 2\n\tres.extend((multiplier,)*(n-new_n))\n\tif n == 3:\n\t\tmultiplier *= 3\n\telse:\n\t\tmultiplier *= 2\n\tn = new_n\nres.extend((multiplier,)*n)\nprint(*res)","output":"linear"},{"instruction":"n, pos, a, b = map(int,input().split())\n\nlf, rf = a - 1, n - b\nif lf == rf == 0:\n\tprint(\"0\")\nelif lf == 0:\n\tprint(abs(pos-b)+1)\nelif rf == 0:\n\tprint(abs(pos-a)+1)\nelse:\n\tcl = abs(a-pos) + 1\n\tcr = abs(b-pos) + 1\n\txn = abs(a-b) + 1\n\tif cl < cr:\n\t\tprint(cl+xn)\n\telse:\n\t\tprint(cr+xn)","output":"constant"},{"instruction":"from sys import stdin,stdout\n\nfinal_ans=0\n\nR,G,B = map(int,stdin.readline().strip().split(' '))\nRa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\nGa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\nBa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\n\ndparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\ndparr[1][1][0]=Ra[0]*Ga[0]\ndparr[1][0][1]=Ra[0]*Ba[0]\ndparr[0][1][1]=Ga[0]*Ba[0]\nfinal_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])\n\ndef add_ns(t1):\n\tglobal queue,Ra,Ga,Ba,dparr\n\tx,y,z=t1\n\tif x+1<=R:\n\t\tif y+1<=G:\n\t\t\tif dparr[x+1][y+1][z]==-1:\n\t\t\t\tqueue.append((x+1,y+1,z))\n\t\t\t\tdparr[x+1][y+1][z]=0\n\n\t\tif z+1<=B:\n\t\t\tif dparr[x+1][y][z+1]==-1:\n\t\t\t\tqueue.append((x+1,y,z+1))\n\t\t\t\tdparr[x+1][y][z+1]=0\n\tif y+1<=G and z+1<=B:\n\t\tif dparr[x][y+1][z+1]==-1:\n\t\t\tqueue.append((x,y+1,z+1))\n\t\t\tdparr[x][y+1][z+1]=0\n\ndef store_ans(t1):\n\tglobal final_ans,dparr,Ra,Ga,Ba\n\tx,y,z=t1\n\tif dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:\n\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])\n\tif dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:\n\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])\n\tif dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:\n\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])\n\n\tfinal_ans=max(final_ans,dparr[x][y][z])\n\nqueue=[(1,1,0),(1,0,1),(0,1,1)]\nadd_ns(queue[0])\nadd_ns(queue[1])\nadd_ns(queue[2])\nptr=3\n\nwhile ptr<len(queue):\n\n\tstore_ans(queue[ptr])\n\n\tadd_ns(queue[ptr])\n\n\tptr+=1\n\nstdout.write(str(final_ans)+\"\\n\")","output":"cubic"},{"instruction":"modulo = 10 ** 9 + 7\nx, k = [int(s) for s in input().split()]\n\nif x == 0:\n    print(0)\n    exit(0)\n\nk2 = pow(2, k, modulo)\nans = (x * k2 * 2 - k2 + 1) % modulo\nprint(ans)","output":"logn"},{"instruction":"n,m = map(int,input().split())\na = [int(x) for x in input().split()]\n\ndef gC(m,a):\n    s = [0 for x in range(2*n + 1)]\n    sum = n\n    res = 0\n    s[sum] = 1\n    ad = 0\n    for i in range(n):\n        if a[i] < m:\n            sum -=1\n            ad -=s[sum]\n        else:\n            ad +=s[sum]\n            sum +=1\n        res +=ad\n        s[sum] +=1\n    return res\n\nprint(gC(m,a) - gC(m + 1,a))","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nlow=1\nhigh=n\nimport sys\nwhile low<=high:\n    mid=(low+high)\/\/2\n    if mid*(mid+1)\/\/2 -(n-mid)>k:\n        high=mid-1\n    elif mid*(mid+1)\/\/2-(n-mid)==k:\n        print(n-mid)\n        sys.exit()\n    else :\n        low=mid+1","output":"logn"},{"instruction":"n,l,r,x=map(int,input().split())\nimport math\nz=list(map(int,input().split()))\ncount=0\nfor i in range(pow(2,len(z))):\n\n    mini=math.inf\n    maxa=0\n    j=i\n    inde=0\n    sume=0\n    while(j>0):\n\n        if(j&1):\n            sume+=z[inde]\n            maxa=max(maxa,z[inde])\n            mini=min(mini,z[inde])\n        j=j>>1\n        inde+=1\n\n    if(maxa-mini>=x and l<=sume<=r):\n        count+=1\n\nprint(count)","output":"np"},{"instruction":"n = int(input())\narr = list(map(int, input().split()))\nab = sorted(arr)\nt = [i for i in range(n) if arr[i] != ab[i]]\nif len(t) < 3:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"from collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nimport heapq\n\ninf = float('inf')\nninf = float('-inf')\n\nM1 = 10**9 + 7\nM2 = 998244353\n\ndef li():\n    return list(map(int,input().split()))\n\ndef pre():\n    \"Start\"\n\ndef solve():\n    a = input()\n    b = input()\n    n = len(a)\n    if(len(a)<len(b)):\n        a = sorted(list(a),reverse = True)\n        print(\"\".join(a))\n        return\n    b = int(b)\n    ans = 0\n    cnt = [0]*10\n    for i in range(n):\n        cnt[ord(a[i])-ord('0')] += 1\n\n    def getrem(k):\n        cnt[k] -= 1\n        ans = \"\"\n        for i in range(10):\n            for j in range(cnt[i]):\n                ans += str(i)\n        cnt[k] += 1\n        return ans\n\n    prev = \"\"\n    for i in range(n):\n        for j in range(9,-1,-1):\n            if(cnt[j]>0):\n                newval = prev + str(j)+ getrem(j)\n                if(int(newval)<=b):\n                    ans = max(ans,int(newval))\n                    prev += str(j)\n                    cnt[j] -= 1\n                    break\n    print(ans)\n\npre()\n\n__ = 1\n\nfor _ in range(__):\n    solve()","output":"cubic"},{"instruction":"from collections import defaultdict\n\nn, a = int(input()), [int(x) for x in input().split()]\npow2 = [1 << i for i in range(32)]\nmp = defaultdict()\nfor x in a:\n    mp[x] = 1\nmxSiz = 1\nans = [a[0]]\nfor x in a:\n    for y in pow2:\n        if x-y in mp and x+y in mp:\n            mxSiz = 3\n            ans = [x-y, x, x+y]\n        if x-y in mp and 2 > mxSiz:\n            mxSiz = 2\n            ans = [x-y, x]\n\nprint(mxSiz)\nprint(*ans)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nA.sort()\n\nANS=[0]*n\n\nNOW=1\nfor i in range(n):\n    if ANS[i]==0:\n        ANS[i]=NOW\n\n        for j in range(i,n):\n            if A[j]%A[i]==0 and ANS[j]==0:\n                ANS[j]=NOW\n\n        NOW+=1\n\nprint(max(ANS))","output":"quadratic"},{"instruction":"a,b,c,n= [int(c) for c in input().split()]\nu=a+b-c\nif a<c or b<c:\n\tprint(-1)\nelse:\n\tif n-u>=1:\n\t\tprint(n-u)\n\telse:\n\t\tprint(-1)","output":"constant"},{"instruction":"n, k = map(int, input().split())\n\na = 1\nb = -(2*n+3)\nc = (n*n+n-2*k)\n\nd = int((b*b - 4*a*c) ** 0.5)\n\ns1 = (-b + d) \/\/ (2 * a)\ns2 = (-b - d) \/\/ (2 * a)\nif s1 >= 0 and s1 <= n:\n    print(s1)\nelse:\n    print(s2)","output":"constant"},{"instruction":"def main():\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                cnt += 1\n    even = cnt % 2 == 0\n    q = int(input())\n    ans = []\n    for _ in range(q):\n        l, r = map(int, input().split())\n        len = r - l + 1\n        pairs = len * (len-1) \/\/ 2\n        if pairs % 2 == 1:\n            even = not even\n        if even:\n            ans.append('even')\n        else:\n            ans.append('odd')\n    print('\\n'.join(ans))\n\nmain()","output":"quadratic"},{"instruction":"from collections import deque\nn=int(input())\norderedli=list(map(int,input().split(\" \")))\n\nindexof={}\nfor i,x in enumerate(orderedli):\n    indexof[x]=i+1\n\nsortedli=list(sorted(orderedli))\ni=0\n\ns=input()\n\nst=deque()\n\nfor x in s:\n    if x==\"0\":\n        st.append(sortedli[i])\n        print(indexof[sortedli[i]],end=\" \")\n        i += 1\n    else:\n        temp=st.pop()\n        print(indexof[temp],end=\" \")","output":"nlogn"},{"instruction":"n = int(input().strip())\nnums = list(map(int, input().strip().split()))\nhas_dups = (len(nums) > len(set(nums)))\nmx = nums.index(max(nums))\nif has_dups or nums[:mx+1]!=sorted(nums[:mx+1]) or nums[mx:]!=sorted(nums[mx:], reverse=True):\n    print(\"NO\")\nelse:\n    print(\"YES\")","output":"nlogn"},{"instruction":"lr = input()\nlr_list = lr.split(\" \")\nl = int(lr_list[0])\nr = int(lr_list[1])\nxor = l ^ r\n\nbms = 0\nwhile xor != 0:\n    bms = bms + 1\n    xor = xor >> 1\n\nmaxxor = 0\ndois = 1\nwhile bms != 0:\n    maxxor = maxxor + dois\n    dois = dois << 1\n    bms = bms - 1\n\nprint(maxxor)","output":"logn"},{"instruction":"n = int(input())\nans = (2 * (n - 1) ** 2) + 2 * n - 1\nprint(ans)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n,k=map(int,input().split())\n    S=list(input().strip())\n\n    for i in range(n):\n        if S[i]==\"R\":\n            S[i]=0\n        elif S[i]==\"G\":\n            S[i]=1\n        else:\n            S[i]=2\n\n    ANS=1<<50\n\n    for mod in range(3):\n        SUM=0\n        for i in range(k):\n            if S[i]%3!=(mod+i)%3:\n                SUM+=1\n\n        ANS=min(ANS,SUM)\n\n        for i in range(k,n):\n            if S[i-k]!=(mod+(i-k))%3:\n                SUM-=1\n            if S[i]!=(mod+i)%3:\n                SUM+=1\n\n            ANS=min(ANS,SUM)\n\n    print(ANS)","output":"linear"},{"instruction":"from sys import stdout\ndef main():\n    n = int(raw_input())\n    k = 2\n    a = []\n    m = n\n    while 1:\n        t = n \/ k\n        if t <= 1:\n            k \/= 2\n            a.extend([k] * m)\n            a[-1] = n \/ k * k\n            break\n        a.extend([k \/ 2] * (m - t))\n        m = t\n        k *= 2\n    stdout.write(' '.join(map(str, a)))\nmain()","output":"linear"},{"instruction":"a=[[],[],[]]\n\ns=input().split(\" \")\n\nfor i in range(len(s)):\n\tif(s[i][1]=='m'):\n\t\ta[0].append(int(s[i][0]))\n\telif(s[i][1]=='p'):\n\t\ta[1].append(int(s[i][0]))\n\telse:\n\t\ta[2].append(int(s[i][0]))\n\nko=10\n\nfor i in range(len(a)):\n\ta[i]=sorted(a[i])\n\tc=0\n\n\tfor j in range(1,len(a[i])):\n\t\tif(a[i][j]==a[i][j-1]):\n\t\t\tc+=1\n\tif(c==1):\n\t\tko=min(ko,1)\n\telif(c==2):\n\t\tko=min(ko,0)\n\telse:\n\t\tif(len(a[i])>0):\n\t\t\tko=min(ko,2)\n\nans=ko\nko=10\n\nfor i in range(len(a)):\n\ta[i]=sorted(a[i])\n\tc=0\n\n\tfor j in range(1,len(a[i])):\n\t\tif(a[i][j]==a[i][j-1]+1):\n\t\t\tc+=1\n\tif(c==1):\n\t\tko=min(ko,1)\n\telif(c==2):\n\t\tko=min(ko,0)\n\telif(len(a[i])>1 and (a[i][0]+2==a[i][1])):\n\t\tko=min(ko,1)\n\telif(len(a[i])>2 and (a[i][1]+2==a[i][2])):\n\t\tko=min(ko,1)\n\telse:\n\t\tif(len(a[i])>0):\n\t\t\tko=min(ko,2)\n\nprint(min(ans,ko))","output":"nlogn"},{"instruction":"n,pos,l,r = map(int, input().split())\ndl,dr = abs(pos-l) + 1, abs(pos-r) + 1\nprint(dr*(r<n) if l==1 else dl if r==n else min(dl,dr)+r-l+1)","output":"constant"},{"instruction":"n = int(input())\nlst = [int(i) for i in input().split()]\nst = set()\nflag = False\ncount = 0\nfor i in lst:\n    if i not in st:\n        st.add(i)\n    else:\n        flag = True\n        count+=1\n        lol = i\nsum1 = n*(n-1)\/\/2\nif count>1:\n    print('cslnb')\n    quit()\nif not flag:\n    if (sum(lst)- sum1)% 2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\nelse:\n    if (lol-1) in lst or lol == 0:\n        print('cslnb')\n    else:\n        if (sum(lst)- sum1)% 2 == 0:\n            print('cslnb')\n        else:\n            print('sjfnb')","output":"linear"},{"instruction":"import bisect\nxyz=[9,90,900,9000,90000,900000,9000000,90000000,900000000,9000000000,900000000000]\nxzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]\ncount=2\nk=int(input())\ndigits=bisect.bisect_left(xzy,k)\n\nif k==10:\n    print(1)\nelif k>10:\n    apu=k-xzy[digits-1]\n\n    modulo=apu%(digits+1)\n\n    dlj=apu\/\/(digits+1)\n\n    output=10**(digits)+dlj\n\n    list1=[i for i in str(output)]\n\n    print(list1[modulo])\nelse:\n    print(k)","output":"logn"},{"instruction":"n = int(input())\nprint(n**2 + (n-1)**2)","output":"constant"},{"instruction":"n = int(input())\na = sorted(list(map(int, input().split())))\ns = []\nfor q in a:\n    for q1 in s:\n        if q % q1 == 0:\n            break\n    else:\n        s.append(q)\nprint(len(s))","output":"quadratic"},{"instruction":"import sys, math\nimport io, os\n\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n\nINF = 10001\nmod = int(1e9) + 7\n\nn=int(data())\na=mdata()\ndp1=[[0]*n for i in range(n)]\ndp2=[[n]*n for i in range(n)]\nfor i in range(n-1,-1,-1):\n    dp1[i][i]=a[i]\n    dp2[i][i]=1\n    for j in range(i+1,n):\n        for k in range(i,j):\n            if dp1[i][k] == dp1[k+1][j] != 0:\n                dp1[i][j] = dp1[i][k] + 1\n                dp2[i][j] = 1\n                break\n            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])\nout(dp2[0][n-1])","output":"cubic"},{"instruction":"p = [int(x) + 100 for x in input().strip().split()]\nd = [int(x) + 100 for x in input().strip().split()]\n\nminx = min(p[::2])\nmaxx = max(p[::2])\nminy = min(p[1::2])\nmaxy = max(p[1::2])\n\ngrid = [[False] * 201 for _ in range(201)]\nfor x in range(minx, maxx+1):\n    for y in range(miny, maxy+1):\n        grid[x][y] = True\n\nminx = min(d[::2])\nmaxx = max(d[::2])\navgx = sum(d[::2]) \/\/ 4\navgy = sum(d[1::2]) \/\/ 4\nspan = (maxx - minx) \/\/ 2\n\nfor x in range(minx, maxx+1):\n    height = span - abs(x - avgx)\n    for y in range(avgy - height, avgy + height + 1):\n        if grid[x][y]:\n            print('YES')\n            exit()\n\nprint('NO')","output":"constant"},{"instruction":"a=list(map(int,input().split()))\nt=a[0]\nd=a[1]\narr=list(map(int,input().split()))\ncount=0\nfor i in range(t-1):\n    if(arr[i+1]-arr[i]==2*d):\n        count+=1\n    elif(arr[i+1]-arr[i]>2*d):\n        count+=2\nprint(count+2)","output":"linear"},{"instruction":"n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nlst = []\nfor i in range(len(a)):\n    if (a[i] in b):\n        lst.append(a[i])\nif (len(lst) == 0):\n    pass\nelse:\n    print(*lst)","output":"quadratic"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport itertools\nimport bisect\nimport heapq\n\ndef main():\n    pass\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n \/ i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n \/ i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n \/\/ i)\n    return (n)\ndef p2(n):\n    c=0\n    while(n%2==0):\n        n\/\/=2\n        c+=1\n    return c\ndef seive(n):\n    primes=[True]*(n+1)\n    primes[1]=primes[0]=False\n    for i in range(2,n+1):\n        if(primes[i]):\n            for j in range(i+i,n+1,i):\n                primes[j]=False\n    p=[]\n    for i in range(0,n+1):\n        if(primes[i]):\n            p.append(i)\n    return(p)\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\ndef denofactinverse(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return (pow(fac,m-2,m))\ndef numofact(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return(fac)\ndef sod(n):\n    s=0\n    while(n>0):\n        s+=n%10\n        n\/\/=10\n    return s\ndef getVal(x,y,sx,sy):\n\n    if (x == -1 or y == -1 or x == n or y == m):\n        return inF\n    elif(sx==x):\n        return hor[sx][min(sy,y)]\n    else:\n        return ver[min(sx,x)][sy]\ndef rec(k,x,y):\n    if(x==-1 or y==-1 or x>=n or y>=m):\n        return inF\n    elif (k == 0):\n\n        dp[k][x][y] = 0\n        return dp[k][x][y]\n    elif(dp[k][x][y]!=-1):\n        return dp[k][x][y]\n    else:\n\n        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)\n        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)\n        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)\n        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)\n        dp[k][x][y]=min(val1,val2,val3,val4)\n        return dp[k][x][y]\nn,m,k=map(int,input().split())\nadj=[[-1]*n for i in range(0,m)]\nif(k%2):\n    for i in range(0, n):\n        for j in range(0, m):\n            print(-1, end=\" \")\n        print(\"\")\nelse:\n    hor,ver=[],[]\n    inF=10**20\n    k\/\/=2\n    for i in range(0,n):\n        hor.append(list(map(int,input().split())))\n    for i in range(0,n-1):\n        ver.append(list(map(int,input().split())))\n    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]\n    for i in range(0,n):\n        for j in range(0,m):\n            print(2*rec(k,i,j),end=\" \")\n        print(\"\")","output":"cubic"},{"instruction":"k=int(input())\n\nnum_digits=1\nnum_numbers=9\n\nk-=1\nwhile k>num_digits*num_numbers:\n\n    k -= num_numbers*num_digits\n    num_digits += 1\n    num_numbers *= 10\n\nnumber = 10**(num_digits - 1) + k \/\/ num_digits\n\nindex = k % num_digits\nanswer = str(number)[index]\nprint(answer)","output":"logn"},{"instruction":"import sys\nn = int(input())\na = [int(i) for i in input().split()]\na.sort()\nt = 0\nfor i in range(1,n):\n\tt += a[i]==a[i-1]\nif t >= 2:\n\tprint(\"cslnb\")\n\tsys.exit(0)\nif t:\n\tfor i in range(n):\n\t\tif a[i]==a[i+1]:\n\t\t\tif a[i] and a[i]!=a[i-1]+1:\n\t\t\t\ta[i] -= 1\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\tsys.exit(0)\nprint([\"cslnb\",\"sjfnb\"][(sum(a)-t-n*(n-1)\/\/2)&1])","output":"nlogn"},{"instruction":"import math\ndef check(n):\n\n    if n==1:\n        return 1\n    if n==2:\n        return 2\n    if n==3:\n        return 6\n\n    if n&1:\n        return ((n-1)*(n-2)*(n))\n    if math.gcd(n,n-3)==1:\n        return (n*(n-1)*(n-3))\n    else:\n        return ((n-1)*(n-2)*(n-3))\n\nn =int(input())\nprint(check(n))","output":"constant"},{"instruction":"from math import sqrt\n\nn, k = map(int, input().split())\n\nanswer = int(-1.5 + sqrt(9\/4 + 2*(n+k)))\n\nprint(n - answer)","output":"constant"},{"instruction":"try:\n    n,k=list(map(int,input().split(\" \")))\n    s=input()\n    s=list(s)\n    if len(s)>k:\n        p='('*(k\/\/2)\n        p=list(p)\n        c=0\n        for i in range(0,len(s)):\n            if s[i]==')':\n                p.insert(i,')')\n                c+=1\n                if c==k\/\/2:\n                    break\n        print(\"\".join(p))\n\n    else:\n        print(\"\".join(s))\n\nexcept:\n    pass","output":"linear"},{"instruction":"n,x,y=int(input())-1,1,9\nwhile n>x*y:n,x,y=n-x*y,x+1,y*10\nprint(str(10**(x-1)+n\/\/x)[n%x])","output":"logn"},{"instruction":"from collections import defaultdict as dd\nimport math\nimport sys\nimport heapq\nimport copy\ninput=sys.stdin.readline\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn map(int, input().split())\n\ndef lm():\n\treturn list(map(int, input().split()))\n\ndef solve():\n\n\tr,g,b = mi()\n\n\trs = lm()\n\tgs = lm()\n\tbs = lm()\n\trs.sort()\n\tgs.sort()\n\tbs.sort()\n\n\tans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\n\n\tfor i in range(1,r+1):\n\t\tfor j in range(1,g+1):\n\t\t\tans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1]\n\n\tfor i in range(r+1):\n\t\tfor j in range(g+1):\n\t\t\tfor k in range(1,b+1):\n\t\t\t\tnew_len = bs[k-1]\n\t\t\t\tif i==0:\n\t\t\t\t\ti_len = 0\n\t\t\t\telse:\n\t\t\t\t\ti_len = ans[i-1][j][k-1] + rs[i-1]*new_len\n\t\t\t\tif j==0:\n\t\t\t\t\tj_len = 0\n\t\t\t\telse:\n\t\t\t\t\tj_len = ans[i][j-1][k-1] + gs[j-1]*new_len\n\t\t\t\tif i>0 and j>0:\n\t\t\t\t\ti_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1]\n\t\t\t\telse:\n\t\t\t\t\ti_j_len = 0\n\t\t\t\tans[i][j][k] = max(i_len,\n\t\t\t\t\t\t\t\t\tj_len,\n\t\t\t\t\t\t\t\t\tans[i][j][k-1],\n\t\t\t\t\t\t\t\t\ti_j_len)\n\n\tprint(ans[r][g][b])\n\nsolve()","output":"cubic"},{"instruction":"def BIG(NUM):\n    X=NUM\n    SM=0\n    while X!=0:\n        M=X%10\n        SM+=M\n        X\/\/=10\n    if NUM-SM>=S:\n        return True\n\nimport sys\nsys.setrecursionlimit(int(1e5))\ninput=sys.stdin.readline\nN,S=map(int,input().split())\nF=0;L=N+1;MN=1<<64\nwhile L>=F:\n    M=(L+F)>>1\n    if BIG(M):L=M-1;MN=min(MN,M)\n    else:F=M+1\nif MN==1<<64:\n    print(0)\nelse:\n    print(N-MN+1)","output":"logn"},{"instruction":"n = int(input())\nprint(n \/\/ 2 + 1)","output":"constant"},{"instruction":"a=int(input())\narr=list(map(int,input().split()))\nd=dict()\nsumm=[0]\nbrr=arr\nnd=dict()\nmimpp=dict()\nmimpn=dict()\nfor i in arr:\n    summ.append(i+summ[len(summ)-1])\n    if(i in d):\n        d[i]=d[i]+1\n    else:\n        d[i]=1\nfor i in range(0,len(brr)):\n    if(brr[i] in nd):\n        nd[brr[i]]=nd[brr[i]]+1\n    else:\n        nd[brr[i]]=1\n    mimpn[i]=0\n    mimpp[i]=0\n    if(brr[i]-1 in d):\n        mimpn[i]=mimpn[i]+d[brr[i]-1]\n    if(brr[i]+1 in d):\n        mimpp[i]=mimpp[i]+d[brr[i]+1]\n    if(brr[i]-1 in nd):\n        mimpn[i]=mimpn[i]-nd[brr[i]-1]\n    if(brr[i]+1 in nd):\n        mimpp[i]=mimpp[i]-nd[brr[i]+1]\n\nans=0\nind=0\nsu=sum(arr)\nfor i in range(0,len(arr)):\n    ans=ans+su-summ[ind]-(a-ind)*arr[i]\n    ans=ans+mimpn[i]\n    ans=ans-mimpp[i]\n    ind=ind+1\nprint(ans)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n\nimport random\n\ndef main():\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n \/ i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n \/\/ 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n \/\/ i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n \/ i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n \/\/ i)\n    return (n)\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n \/\/= 2\n        c += 1\n    return c\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n \/\/= 10\n    return s\n\nn=int(input())\nl=list(map(int,input().split()))\ninv=0\nfor i in range(1,n):\n    for j in range(0,i):\n        if(l[j]>l[i]):\n            inv+=1\n\nfor i in range(0,int(input())):\n    f,r=map(int,input().split())\n    p=(r-f+1)\/\/2\n\n    inv+=p%2\n\n    if(inv%2):\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"def ints():\n return map(int,input().split())\nn,m=ints()\nc=ints()\naa=[0]*(n+1)\nfor cc in c:\n aa[cc]+=1\nprint(min(aa[1:]))","output":"quadratic"},{"instruction":"n=input()\nl=list(map(lambda x:int(x)*2,raw_input().split(\" \")))\nt=list(map(lambda x:\"GWL\".index(x),raw_input()))\nmins=[0 for i in range(0,n+1)]\nfor i in range(n-1,-1,-1):\n\tif t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)\n\telse:mins[i]=mins[i+1]+l[i]\ncurs=ans=st=0\nfor i in range(0,n):\n\tif(t[i]==0):\n\t\tcurs+=l[i];ans+=l[i]*5\n\t\tif(curs>mins[i+1]):\n\t\t\tol=(curs-mins[i+1])\/\/2\n\t\t\tol=min(ol,l[i])\n\t\t\tans-=4*ol;curs-=2*ol\n\tif(t[i]==1):\n\t\tst=1;curs+=l[i];ans+=l[i]*3\n\tif(t[i]==2):\n\t\tif(curs<l[i]):\n\t\t\tol=l[i]-curs;curs=l[i]\n\t\t\tans+=ol*(3 if st else 5)\n\t\tcurs-=l[i];ans+=l[i]\nif curs>0:ans-=curs\/\/2*2\nprint(ans\/\/2)","output":"linear"},{"instruction":"from sys import stdin, stdout\n\ndef main():\n    p = 998244353\n    n = int(stdin.readline())\n    a = list(readline())\n    answer = a[-1]\n    pow_ = 1\n    for i in range(n - 1, 0, -1):\n        answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p\n        pow_ = pow_ * 2 % p\n    return answer\n\ndef readline():\n    return map(int, stdin.readline().strip().split())\n\nif __name__ == '__main__':\n    stdout.write(str(main()) + '\\n')","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nQ = int(input())\nD = {\"R\":0, \"G\":1, \"B\":2}\nfor _ in range(Q):\n    N, K = map(int, input().split())\n    S = input()\n    mi = K\n    for i in range(3):\n        d = 0\n        for j in range(N):\n            if D[S[j]] != (i+j) % 3:\n                d += 1\n            if j >= K and D[S[j-K]] != (i+j-K) % 3:\n                d -= 1\n            if j >= K-1:\n                mi = min(mi, d)\n    print(mi)","output":"linear"},{"instruction":"import sys;\ndef transform(c):\n\tif c == '.': return 0;\n\tif c == '\n\treturn 2;\n\ndef take_care(board,n,m):\n\tif n + 2 >= N:\n\t\treturn;\n\tif m + 2 >= M:\n\t\treturn;\n\tif board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0:\n\t\treturn;\n\tboard[n][m] = 2\n\tboard[n][m+1] = 2\n\tboard[n][m+2] = 2\n\tboard[n+1][m] = 2\n\tboard[n+1][m+2] = 2\n\tboard[n+2][m] = 2\n\tboard[n+2][m+1] = 2\n\tboard[n+2][m+2] = 2\n\treturn False,board;\n\nN,M = [int(i) for i in input().strip().split()];\nboard = [];\nfor n in range(N):\n\trow = input().strip();\n\trow = [ transform(c) for c in row];\n\tboard.append(row);\n\nfor n in range(N):\n\tfor m in range(M):\n\t\ttake_care(board,n,m);\nfor row in board:\n\tif 1 in row:\n\t\tprint('NO');\n\t\tsys.exit();\nprint('YES');","output":"quadratic"},{"instruction":"n = int(input())\n\ndef prefix_sums(A):\n    n = len(A)\n    P = [0] * n\n    P[0] = A[0]\n    for k in range(1, n):\n        P[k] = int((P[k - 1] + A[k]) % (1e9+7))\n    return P\n\narr = [[0] * n for _ in range(n)]\n\ns = ''\nfor i in range(n):\n    inst = input()\n    s += inst\n\ndef find_ans():\n    idx = 0\n    for i in range(len(arr)-1):\n        arr[0][0] = 1\n\n        if s[i] == 'f':\n            for j in range(0, len(arr)):\n                arr[i+1][0] = 0\n                if j > 0:\n                    arr[i+1][j] = arr[i][j-1]\n                    idx = i+1\n\n        else:\n            val = 0\n            arr[i+1] = prefix_sums(arr[i][::-1])[::-1]\n    return arr\n\nif n == 1 or 'f' not in s:\n    if s[0] == 's':\n        print(1)\n    else:\n        print(int(sum(find_ans()[-1]) % (1e9+7)))\nelse:\n    print(int(sum(find_ans()[-1]) % (1e9+7)))","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nd = {}\nfor ai in a:\n\tif ai in d:\n\t\td[ai] += 1\n\telse:\n\t\td[ai] = 1\nif max(d.values()) >= 3 or 0 in d and d[0] >= 2 or list(d.values()).count(2) >= 2:\n\tprint('cslnb')\n\texit()\nfor i in d:\n\tif d[i] == 2 and i - 1 in d:\n\t\tprint('cslnb')\n\t\texit()\ns = sum(a)\nif s >= n * (n - 1) \/\/ 2:\n\tif (s - n * (n - 1) \/\/ 2) % 2 == 0:\n\t\tprint('cslnb')\n\telse:\n\t\tprint('sjfnb')\nelse:\n\tpass","output":"linear"},{"instruction":"N, K = list(map(int, input().split()))\nS = input().strip()\nS = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]\n\ndef check(x):\n    p = [[N for i in range(N+1)] for k in range(K)]\n\n    for k in range(K):\n        keep = 0\n        for i in range(N-1, -1, -1):\n            keep += 1\n            if S[i] != -1 and S[i] != k:\n                keep = 0\n            p[k][i] = p[k][i+1]\n            if keep >= x:\n                p[k][i] = i + x - 1\n\n    d = [N for s in range(1<<K)]\n    d [0] = -1\n    for s in range(1, 1<<K):\n        for k in range(K):\n            if (s&(1<<k)) and (d[s^(1<<k)]<N):\n                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])\n\n    return d[(1<<K)-1] < N\n\nl, r = 0, N\/\/K\n\nwhile l < r:\n    mid = (l + r + 1) \/\/ 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\nprint(l)","output":"np"},{"instruction":"for _ in range(int(input())):\n    N, M = map(int, input().split())\n    X = [[int(a) for a in input().split()] for _ in range(N)]\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    dp = [[0] * (1<<N) for _ in range(M+1)]\n    for j in range(M):\n        for mask in range(1<<N):\n            maskpre = mask\n            while maskpre >= 0:\n                maskpre &= mask\n                ma = 0\n                for k in range(N):\n                    s = 0\n                    for i in range(N):\n                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:\n                            s += X[i-k][j]\n                    ma = max(ma, s)\n                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)\n\n                maskpre -= 1\n    print(dp[-1][-1])","output":"np"},{"instruction":"import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef add(a,b):\n\treturn (a+b)%1000000007\n\ndef mul(a,b):\n\treturn (a*b)%1000000007\n\ndef sub(a,b):\n\treturn (a-b+1000000007)%1000000007\n\ndef qpow(a, b):\n\tr = 1\n\tk = a\n\tfor i in range(17):\n\t\tif b & (1<<i):\n\t\t\tr = mul(r, k)\n\t\tk = mul(k, k)\n\treturn r\n\nn, q = mints()\na = list(minp())\nc = [0]*(n+1)\nfor i in range(n):\n\tc[i+1] = c[i] + int(a[i])\nfor i in range(q):\n\tl, r = mints()\n\tk = (r-l+1)\n\to = c[r]-c[l-1]\n\tz = sub(qpow(2,o),1)\n\tprint(mul(z,qpow(2,k-o)))","output":"linear"},{"instruction":"class Read:\n    @staticmethod\n    def int():\n        return int(input())\n\n    @staticmethod\n    def list(sep=' '):\n        return input().split(sep)\n\n    @staticmethod\n    def list_int(sep=' '):\n        return list(map(int, input().split(sep)))\n    @staticmethod\n    def calc(sep = '', k = ''):\n        count = 0\n        for i in range(sep):\n            j = sep - i\n            sum = ((i + 1)* i) \/ 2\n            if (sum - j == k):\n                return j\n        return count\n\ndef main():\n    n, k = Read.list_int()\n    print(Read.calc(n, k))\n\nmain()","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = []\nb = []\nma = 0\nmacount = 0\nmi = 1000000000000000000000000000\nsu = 0\nfor el in map(int, input().split()):\n    if el > ma:\n        ma = el\n        macount = 1\n    elif el == ma:\n        macount += 1\n    a.append(el)\nfor el in map(int, input().split()):\n    mi = min(el, mi)\n    b.append(el)\n    su += el\nif ma > mi:\n    print(-1)\nelif ma == mi or macount > 1:\n    f = True\n    for i in range(n):\n        if a[i] == ma and f:\n            f = False\n        else:\n            su += a[i] * m\n    print(su)\nelse:\n    secmax = 0\n    for el in a:\n        if el > secmax and el < ma:\n            secmax = el\n    f = True\n    for i in range(n):\n        if a[i] == ma and f:\n            f = False\n        else:\n            su += a[i] * m\n    print(su + ma - secmax)","output":"linear"},{"instruction":"import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\ndef solveBFS(NR, NG, NB, R, G, B):\n    def pack(i, j, k):\n        return i * 256 * 256 + j * 256 + k\n\n    def unpack(ijk):\n        i, jk = divmod(ijk, 256 * 256)\n        j, k = divmod(jk, 256)\n        return i, j, k\n\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n    dp = [0 for i in range(256 ** 3)]\n    q = deque([0])\n    while q:\n        ijk = q.popleft()\n        d = dp[ijk]\n        i, j, k = unpack(ijk)\n\n        if i < NR:\n            r = R[i]\n\n        if j < NG:\n            g = G[j]\n        if k < NB:\n            b = B[k]\n        if i + 1 <= NR and j + 1 <= NG:\n            rg = pack(i + 1, j + 1, k)\n            dp[rg] = max(dp[rg], r * g + d)\n            q.append(rg)\n\n        if i + 1 <= NR and k + 1 <= NB:\n            rb = pack(i + 1, j, k + 1)\n            dp[rb] = max(dp[rb], r * b + d)\n            q.append(rb)\n\n        if j + 1 <= NG and k + 1 <= NB:\n            gb = pack(i, j + 1, k + 1)\n            dp[gb] = max(dp[gb], g * b + d)\n            q.append(gb)\n\n    return max(dp)\n\ndef solve(NR, NG, NB, R, G, B):\n    assert NR == len(R)\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n\n    R += [0]\n    G += [0]\n    B += [0]\n\n    NR1 = NR + 2\n    NG1 = NG + 2\n    NB1 = NB + 2\n    dp = [0 for i in range((NR1) * (NG1) * (NB1))]\n\n    def pack(i, j, k):\n        return i * NG1 * NB1 + j * NB1 + k\n\n    inf = float(\"inf\")\n    for i in range(NR + 1):\n        for j in range(NG + 1):\n            dp[pack(i, j, -1)] = -inf\n    for i in range(NR + 1):\n        for k in range(NB + 1):\n            dp[pack(i, -1, k)] = -inf\n\n    for j in range(NG + 1):\n        for k in range(NB + 1):\n            dp[pack(-1, j, k)] = -inf\n\n    for l in range(2, NR + NG + NB + 1, 2):\n        for j in range(NG + 1):\n            for k in range(NB + 1):\n                i = l - j - k\n                if i < 0 or i > NR:\n                    continue\n                r = R[i - 1]\n                g = G[j - 1]\n                b = B[k - 1]\n                dp[pack(i, j, k)] = max(\n                    r * g + dp[pack(i - 1, j - 1, k)],\n                    r * b + dp[pack(i - 1, j, k - 1)],\n                    b * g + dp[pack(i, j - 1, k - 1)],\n                )\n\n    return max(dp)\n\nif False:\n    import random\n\n    random.seed()\n    N = 5\n    for t in range(100):\n        R = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        G = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        B = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)\n        ans2 = solve(len(R), len(G), len(B), R, G, B)\n        if ans1 != ans2:\n            print(ans1, ans2)\n            print(R, G, B)\n        exit()\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    NR, NG, NB = [int(x) for x in input().split()]\n    R = [int(x) for x in input().split()]\n    G = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    ans = solve(NR, NG, NB, R, G, B)\n    print(ans)","output":"cubic"},{"instruction":"def f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y\/\/g):d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n return d[s]\nimport math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfrom collections import Counter\n\nn, s = mi()\nd = Counter()\nfor i in range(n - 1):\n    u, v = mi()\n    d[u] += 1\n    d[v] += 1\n\nl = sum(v == 1 for v in d.values())\nans = s \/ l * 2\nprint('%.10f' % (ans,))","output":"linear"},{"instruction":"from heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nn,m = map(int,input().split())\n\nG = MinCostFlow(n+2)\ncoef = [0 for i in range(n)]\nedge = []\nfor _ in range(m):\n    x,y,b = map(int,input().split())\n    G.add_edge(y,x,10**18,-1)\n    coef[x-1] += b\n    coef[y-1] -= b\n    edge.append((x,y))\n\ns = 0\nfor i in range(n):\n    if coef[i]<0:\n        G.add_edge(0,i+1,-coef[i],0)\n        s -= coef[i]\n    elif coef[i]>0:\n        G.add_edge(i+1,n+1,coef[i],0)\n\nf = G.flow(0,n+1,s)\n\nEdge = [[] for i in range(n)]\nuse = [False]*m\nuf = UnionFindVerSize(n)\nfor i in range(m):\n    u,v = edge[i]\n    for e in G.G[u]:\n        to = e[0]\n        if to==v and e[1]:\n            Edge[v-1].append((u-1,1))\n            Edge[u-1].append((v-1,-1))\n            use[i] = True\n            uf.unite(u-1,v-1)\n\nedge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]\nfor u,v in edge:\n    if not uf.is_same_group(u-1,v-1):\n        Edge[v-1].append((u-1,1))\n        Edge[u-1].append((v-1,-1))\n        uf.unite(u-1,v-1)\n\nused_1 = [False]*n\nused_2 = [False]*n\nlazy = [0 for i in range(n)]\na = [0 for i in range(n)]\ndef dfs(v,pv):\n    lazy[v] = min(lazy[v],a[v])\n    for nv,c in Edge[v]:\n        if not used_1[nv]:\n            used_1[nv] = True\n            a[nv] = a[v] + c\n            dfs(nv,v)\n            lazy[v] = min(lazy[v],lazy[nv])\n\ndef add(v,pv,ff):\n    a[v] += ff\n    for nv,c in Edge[v]:\n        if not used_2[nv]:\n            used_2[nv] = True\n            add(nv,v,ff)\n\nfor i in range(n):\n    if not used_1[i]:\n        used_1[i] = True\n        dfs(i,-1)\n        used_2[i] = True\n        add(i,-1,-lazy[i]+1)\n\nprint(*a)","output":"np"},{"instruction":"import os\nimport sys\nimport math\nimport heapq\nfrom decimal import *\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict, deque\n\ndef r():\n    return int(input())\ndef rm():\n    return map(int,input().split())\ndef rl():\n    return list(map(int,input().split()))\n\nr,g,b = rm()\nR = rl()\nG = rl()\nB = rl()\nR.sort()\nG.sort()\nB.sort()\ndp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)]\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i and j:\n                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1])\n            if j and k:\n                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1])\n            if k and i:\n                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1])\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"n , s = map(int, input().split())\nd = [0] * (n + 1)\ncnt = 0\nfor i in range(0 , n - 1):\n    a , b = map(int, input().split())\n    d[a - 1] += 1\n    d[b - 1] += 1\nfor i in range(0 , n):\n    if(d[i] == 1):\n        cnt += 1\nprint(2.0 * s \/ cnt)","output":"linear"},{"instruction":"str=input()\nm=0\nn=len(str)\nfor i in range(n):\n    for j in range(i,n+1) :\n        if str[i:j] in str[i+1:n] and len(str[i:j])>m:\n            m=len(str[i:j])\nprint(m)","output":"cubic"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn,m = inpl()\nabc = [inpl() for _ in range(m)]\n\ndef sol(X):\n    g = [[] for _ in range(n)]\n    ny = [0]*n\n    for a,b,c in abc:\n        if c > X:\n            g[a-1].append(b-1)\n            ny[b-1] += 1\n    seen = [0]*n\n    q = deque()\n    for i,x in enumerate(ny):\n        if x==0: q.append(i); seen[i] = 1\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if seen[u]: continue\n            ny[u] -= 1\n            if ny[u] == 0:\n                q.append(u)\n                seen[u]= 1\n    return all(seen)\n\ndef sol2(X):\n    g = [[] for _ in range(n)]\n    ny = [0]*n\n    for a,b,c in abc:\n        if c > X:\n            g[a-1].append(b-1)\n            ny[b-1] += 1\n    tps = [-1]*n; T = 0\n    seen = [0]*n\n    q = deque()\n    for i,x in enumerate(ny):\n        if x==0: q.append(i); seen[i] = 1\n    while q:\n        v = q.popleft()\n        tps[v] = T; T += 1\n        for u in g[v]:\n            if seen[u]: continue\n            ny[u] -= 1\n            if ny[u] == 0:\n                q.append(u)\n                seen[u]= 1\n    return tps\n\nok = 10**9+10; ng = -1\nwhile abs(ok-ng)>1:\n    mid = (ok+ng)\/\/2\n    if sol(mid): ok = mid\n    else: ng = mid\n\nres = []\ntps = sol2(ok)\nfor i,(a,b,c) in enumerate(abc):\n    if c <= ok:\n        if tps[a-1] > tps[b-1]: res.append(i+1)\nprint(ok,len(res))\nprint(*res)","output":"nlogn"},{"instruction":"import sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    inf=10**9\n    n=II()\n    aa=LI()\n    dp1=[[-1]*n for _ in range(n)]\n    dp2=[[inf]*n for _ in range(n)]\n    for i in range(n):\n        dp1[i][i]=aa[i]\n        dp2[i][i]=1\n    for w in range(2,n+1):\n        for l in range(n-w+1):\n            r=l+w-1\n            for m in range(l,r):\n                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m+1][r]:\n                    dp1[l][r]=dp1[l][m]+1\n                    dp2[l][r]=1\n    for m in range(n):\n        for l in range(m+1):\n            for r in range(m+1,n):\n                dp2[l][r]=min(dp2[l][r],dp2[l][m]+dp2[m+1][r])\n    print(dp2[0][n-1])\n\nmain()","output":"cubic"},{"instruction":"from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nimport sys\n\nM = mod = 10 ** 9 + 7\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n\nn = val()\nl = li()\nc = li()\n\nelement = l[0]\nfor i in range(1, n):element = math.gcd(element, l[i])\n\nif element != 1:\n    print(-1)\n    exit()\n\nmyset = {}\n\nfor ind, i in enumerate(l):\n    for j in list(myset):\n        temp = math.gcd(j, i)\n        if(temp not in myset):myset[temp] = myset[j] + c[ind]\n        else:myset[temp] = min(myset[temp], c[ind] + myset[j])\n\n    if i not in myset:myset[i] = c[ind]\n    else:myset[i] = min(myset[i], c[ind])\n\nprint(myset[1])","output":"np"},{"instruction":"class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = -float('inf')\n        def dfs(root):\n            nonlocal res\n            if not root:\n                return\n            left = self.getMax(root.left)\n            right = self.getMax(root.right)\n            res =max(res, root.val + left + right)\n            dfs(root.left)\n            dfs(root.right)\n        dfs(root)\n        return res\n\n    def getMax(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        left = self.getMax(root.left)\n        right = self.getMax(root.right)\n        path = root.val + max(left, right)\n        return max(0, path)","output":"quadratic"},{"instruction":"k,n,s,p = map(int, input().split())\nq = (n+s-1)\/\/s\nans = (q*k+p-1)\/\/p\nprint(ans)","output":"constant"},{"instruction":"for _ in range(int(input())):\n    a,b=map(int,input().split())\n    ans=int(0)\n    while a and b:\n        a,b=min(a,b),max(a,b)\n        ans,b=ans+b\/\/a,b%a\n    print(ans)","output":"constant"},{"instruction":"import sys\n\nreader = (map(int, line.split()) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\narrays = []\nfor i in range(n):\n    arrays.append(list(input()))\n\nfull = (1 << m) - 1\nL = -1\nR = 10 ** 9 + 1\nwhile L + 1 < R:\n    check = (L + R) >> 1\n\n    masks = {}\n    for i, arr in enumerate(arrays):\n        curr = 0\n        for val in arr:\n            curr <<= 1\n            if val >= check:\n                curr |= 1\n        masks[curr] = i\n\n    isValid = False\n    for k1 in masks:\n        for k2 in masks:\n            if k1 | k2 == full:\n                ans0 = masks[k1]\n                ans1 = masks[k2]\n                isValid = True\n                break\n        if isValid:\n            break\n\n    if isValid:\n        L = check\n    else:\n        R = check\n\nprint(ans0 + 1, ans1 + 1)","output":"np"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    arr=get_list()\n    counter=collections.Counter(arr)\n    ans=set()\n    for i in counter:\n        for j in range(1,32):\n            no=2**j\n            diff=no-i\n            if diff<0:\n                continue\n            if diff==i:\n                if counter[i]>1:\n                    ans.add(i)\n\n                    break\n            else:\n                if diff not in  counter:\n                    continue\n                else:\n                    ans.add(i)\n\n                    break\n\n    val=0\n    ans=list(ans)\n    for i in ans:\n        val+=counter[i]\n    print(n-val)","output":"nlogn"},{"instruction":"r, g, b = map(int, input().split())\na = [[], [], []]\ndp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]\nfor x in range(3):\n    a[x] = sorted([int(x) for x in input().split()])\nodp = 0\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n            odp = max(odp, dp[i][j][k])\nprint(odp)","output":"cubic"},{"instruction":"n, k = map(int, input().split())\nt = input()\ni = 1\nwhile t[:-i] != t[i:]:\n    i += 1\nprint(t[:i] * k + t[i:])","output":"quadratic"},{"instruction":"from collections import defaultdict\nfrom sys import stdout,stdin\nn,m,K=map(int,input().split())\ndp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]\nl1=[list(map(int,stdin.readline().split())) for i in range(n)]\nl2=[list(map(int,stdin.readline().split())) for i in range(n-1)]\nif K%2:\n    for i in range(n):\n        for j in range(m):\n            print('-1',end=' ')\n        print()\nelse:\n    for k in range(1,K\/\/2+1):\n     for i in range(n):\n        for j in range(m):\n                res=100000000\n                if i-1>=0 and j>=0:\n                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])\n                if i+1<n and j>=0:\n                     res=min(res,l2[i][j]+dp[i+1][j][k-1])\n                if 0<=i and j+1<m:\n                     res=min(res,l1[i][j]+dp[i][j+1][k-1])\n                if 0<=i and j-1>=0:\n                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])\n                dp[i][j][k]=res\n    for i in range(n):\n        for j in range(m):\n            stdout.write(str(2*dp[i][j][K\/\/2])+' ')\n        stdout.write('\\n')","output":"cubic"},{"instruction":"class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize:\n            return False\n        count = Counter(hand)\n        hand.sort()\n        for num in hand:\n            if count[num]:\n                for i in range(num, num + groupSize):\n                    if not count[i]:\n                        return False\n                    count[i] -= 1\n        return True","output":"nlogn"},{"instruction":"import os,sys,math\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return len(a)\n\ndef solve():\n    n=I()\n    points,l=[],[]\n    for i in range(n):\n        a,b=In()\n        l.append((a,b))\n        points.append(a)\n        points.append(b)\n    points.sort()\n    k=0\n    d={}\n    l1=[]\n    for i in range(2*n):\n        if d.get(points[i],-1)==-1:\n            d[points[i]]=k\n            l1.append(points[i])\n            k+=1\n\n    n1=len(d)\n    dp=[[0,0] for i in range(n1)]\n    for a,b in l:\n        dp[d[a]][0]+=1\n        dp[d[b]][1]-=1\n\n    ans={}\n    last=dp[0][0]\n    ans[last]=1\n    last+=dp[0][1]\n    for i in range(1,n1):\n        cnts=l1[i]-l1[i-1]-1\n        if ans.get(last,-1)!=-1:\n            ans[last]+=cnts\n        else:\n            ans[last]=cnts\n        last+=dp[i][0]\n        if ans.get(last,-1)!=-1:\n            ans[last]+=1\n        else:\n            ans[last]=1\n        last+=dp[i][1]\n    if ans.get(last,-1)!=-1:\n        ans[last]+=1\n    else:\n        ans[last]=1\n    for i in range(1,n+1):\n        print(ans.get(i,0),end=' ')\n    print()\n    pass\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n\nM = 998244353\nP = 1000000007\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"n=int(input())\ns=(input())\nL=s.split(\" \")\nL=list(set(L))\nfor i in range(len(L)):\n    L[i]=int(L[i])\nL=sorted(L)\nif len(L)==1:\n    print(\"NO\")\nelse:\n    print(L[1])","output":"nlogn"},{"instruction":"n=int(input())\nd={}\nfor _ in range(n):\n    a,x=map(int, input().split())\n    d[a]=x\nm=int(input())\nfor _ in range(m):\n    b,y=map(int, input().split())\n    d[b]=max(y, d.get(b,0))\nprint(sum(d.values()))","output":"nlogn"},{"instruction":"n,m,k=map(int,raw_input().split())\nl=list(map(int,raw_input().split()))\nma=0\nfor deb in range(n-1,n-m-1,-1):\n    cumi=0\n    scu=0\n    for i in range(deb,-1,-1):\n        scu+=l[i]\n        ma=max(ma,scu-cumi-k)\n        if (deb-i+1)%m==0:\n            scu-=k\n        if scu<cumi:\n            cumi=scu\n\nprint(ma)","output":"quadratic"},{"instruction":"k = int(input())\nk -= 1\n\npow_10, length = 1, 1\n\nwhile 9 * pow_10 * length < k:\n    k -= 9 * pow_10 * length\n    pow_10 *= 10\n    length += 1\n\ndiv = k \/ length\nrem = k % length\n\nnum = pow_10 + div\n\nprint(str(num)[rem])","output":"logn"},{"instruction":"import os\nimport io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nfrom math import sqrt,ceil\n\nmax_n=10**7+1\nspf = [i for i in range(max_n)]\n\nfor i in range(4,max_n,2):\n    spf[i]=2\n\nfor i in range(3,ceil(sqrt(max_n))):\n    if (spf[i]==i):\n        for j in range(i*i,max_n,i):\n            if(spf[j]==j):\n                spf[j]=i\n\nfrom collections import Counter,defaultdict\nfrom bisect import insort\n\ndef f(x):\n    c=Counter()\n    ans=1\n    while(x!=1):\n        c[spf[x]]+=1\n        x\/\/=spf[x]\n    for i in c:\n        if(c[i]%2==1):\n            ans*=i\n    return(ans)\n\nt=int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    a=list(map(int,input().split()))\n    for i in range(n):\n        a[i]=f(a[i])\n    dp_depth=[[n for j in range(k+1)] for i in range(n)]\n    recent=[n for i in range(k+1)]\n    closest=defaultdict(lambda: -1)\n    for i in range(n-1,-1,-1):\n        if(closest[a[i]]>=0):\n            insort(recent,closest[a[i]])\n            recent.pop()\n        dp_depth[i]=recent.copy()\n        closest[a[i]]=i\n    dp=[[i for j in range(k+1)] for i in range(n+1)]\n\n    dp[0]=[0 for j in range(k+1)]\n    for i in range(n):\n        for x in range(k+1):\n            end=dp_depth[i][x]\n\n            for y in range(k-x+1):\n                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1)\n    print(dp[n][k])","output":"cubic"},{"instruction":"from sys import exit\nn = int(input())\nif n <= 10:\n    for i in range(n):\n        print(0, i)\n    exit()\n\nprint(0, 0)\nfor i in range(4, n + 1, 3):\n    k = (i \/\/ 3) * 2\n    print(k, 0)\n    print(k - 1, 1)\n    print(k - 2, 2)\nk = ((n + 1) \/\/ 3) * 2\nif n % 3 == 0:\n    print(k - 1, 1)\n    print(k - 2, 2)\nelif n % 3 == 2:\n    print(k - 2, 2)","output":"linear"},{"instruction":"n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    if A[0] >= 0:\n        print(A[0])\n    else:\n        print(-A[0]-1)\n    exit(0)\nfor i in range(n):\n    if A[i] < 0:\n        pass\n    else:\n        A[i] = -A[i]-1\nif n % 2 == 0:\n    print(*A)\n    exit(0)\nmim = 0\nindmim = 0\nfor i in range(n):\n    if A[i] < mim:\n        mim = A[i]\n        indmim = i\nA[indmim] = -A[indmim]-1\nprint(*A)","output":"linear"},{"instruction":"import math\nfrom collections import defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    cards = list(map(int, input().split()))\n    fav = list(map(int, input().split()))\n\n    h = [0] + list(map(int, input().split()))\n\n    cards_cnt = defaultdict(int)\n    for val in cards:\n        cards_cnt[val] += 1\n\n    players_fav_cnt = defaultdict(int)\n    for val in fav:\n        players_fav_cnt[val] += 1\n\n    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]\n    for p in range(n):\n        for c in range(k*n+1):\n            for hand in range(k+1):\n                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])\n\n    res = 0\n    for f in players_fav_cnt:\n        res += dp[players_fav_cnt[f]][cards_cnt[f]]\n\n    print(res)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\nq = int( input() )\nrgb = \"RGB\"\nfor _ in range( q ):\n    n, k = map( int, input().split() )\n    s = input()\n    ans = n\n    for i in range( 3 ):\n        r = [ 0 ]\n        l = i\n        for c in s:\n            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )\n            l = ( l + 1 ) % 3\n            if len( r ) > k:\n                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )\n    print( ans )","output":"linear"},{"instruction":"r,g,b = list(map(int, input().split()))\nls_r = sorted(list(map(int, input().split())))\nls_g = sorted(list(map(int, input().split())))\nls_b = sorted(list(map(int, input().split())))\n\ndp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]\n\nfor i in range(r+1):\n    dp[i][0][0] = 0\nfor i in range(g+1):\n    dp[0][i][0] = 0\nfor i in range(b+1):\n    dp[0][0][i] = 0\n\ndp[1][1][0] = ls_r[0] * ls_g[0]\ndp[0][1][1] = ls_g[0] * ls_b[0]\ndp[1][0][1] = ls_r[0] * ls_b[0]\n\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            res1 = 0\n            res2 = 0\n            res3 = 0\n            if i-1>=0 and j-1>=0:\n                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]\n            if i-1>=0 and k-1>=0:\n                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]\n            if j-1>=0 and k-1>=0:\n                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]\n            dp[i][j][k] = max(res1,res2,res3)\nprint(dp[r][g][b])","output":"cubic"},{"instruction":"a=input()\nb=input()\nna=len(a)\nnb=len(b)\ndef fs(a,b):\n\ttry:\n\t\tfor i in range(a+1,len(b)):\n\t\t\tif b[a]>b[i]:\n\t\t\t\tans=b[i]\n\t\t\t\tk=b.copy()\n\t\t\t\tk.pop(i)\n\t\t\t\tans+=\"\".join(k)\n\t\t\t\treturn ans\n\t\treturn False\n\texcept:\n\t\treturn False\nif(na<nb):\n\tprint(\"\".join(sorted(list(a),reverse=True)))\nelse:\n\tif(a==b):\n\t\tprint(a)\n\n\telse:\n\t\tl=sorted(list(a),reverse=True)\n\t\tl2=l.copy()\n\t\tans1=\"\"\n\t\tflag=0\n\t\tans=[]\n\t\tfor i in b:\n\t\t\tfor j in range(len(l)):\n\t\t\t\tif i==l[j]:\n\t\t\t\t\tk=fs(j,l)\n\t\t\t\t\tif(k!=False):\n\t\t\t\t\t\tans.append(ans1+fs(j,l))\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tbreak\n\t\t\t\tif i>l[j]:\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tbreak\n\t\tans1+=\"\".join(l)\n\t\tif(int(ans1)<=int(b)):\n\t\t\tprint(ans1)\n\t\telse:\n\t\t\tfor i in sorted([int(i) for i in ans],reverse=True):\n\t\t\t\tif(i<=int(b)):\n\t\t\t\t\tprint(i)\n\t\t\t\t\tbreak","output":"cubic"},{"instruction":"inf=10000000000\nn,m,k=(int(i) for i in input().split())\nh=[[int(i) for i in input().split()]for i in range(n)]\nz=[[int(i) for i in input().split()]for i in range(n-1)]\ndh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf\ndz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf\ndp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)]\nddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf\nif k%2!=0:\n    for i in dp[0]:\n        for j in i:\n            print(-1,end=' ')\n        print()\nelse:\n    for kk in range(int(k\/2)):\n        for i in range(n):\n            for j in range(m):\n                dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j))\n        dp.reverse()\n    for i in dp[0]:\n        for j in i:\n            print(2*j,end=' ')\n        print()","output":"cubic"},{"instruction":"import math\ndef islucky(x):\n    digits = set(list(str(x)))\n    return (len(digits) == 2 and (\"4\" in digits and \"7\" in digits)) or (len(digits) == 1 and (\"4\" in digits or \"7\" in digits))\na = int(input())\nlucky = islucky(a)\nfor i in range(2, math.ceil(math.sqrt(a))+1):\n    if a % i == 0:\n\n        if islucky(i) or islucky(a \/\/ i):\n            lucky = True\n            break\n\nprint(\"YES\" if lucky else \"NO\")","output":"constant"},{"instruction":"R,G,B=[int(c) for c in input().split()]\nra=[int(c) for c in input().split()]\nga=[int(c) for c in input().split()]\nba=[int(c) for c in input().split()]\n\nra.sort(reverse=True)\nga.sort(reverse=True)\nba.sort(reverse=True)\n\ndp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]\ndef solve(dp,r,g,b):\n    if dp[r][g][b] !=-1:\n        return dp[r][g][b]\n    count= 0\n    for i,j in zip((r,g,b),(R,G,B)):\n        if i == j:\n            count+=1\n    if count >= 2:\n        return 0\n\n    res = -999\n    if r != R and b!=B:\n\n        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))\n\n    if r!=R and g != G:\n        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))\n\n    if b!=B and g != G:\n        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))\n\n    dp[r][g][b] = res\n\n    return res\n\nprint(solve(dp,0,0,0))","output":"cubic"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = [abs(x) for x in a]\nif n == 1:\n    ans = a[0]\nelif all(x > 0 for x in a) or all(x < 0 for x in a):\n    b.sort()\n    ans = sum(b) - 2 * b[0]\nelse:\n    ans = sum(b)\nprint(ans)","output":"nlogn"},{"instruction":"n=int(input())\nw=[int(k) for k in input().split()]\nm=int(input())\nc=0\nfor i in range(n):\n    for j in range(i+1, n):\n        if w[i]>w[j]:\n            c+=1\nc%=2\nfor j in range(m):\n    l, r=[int(k) for k in input().split()]\n    x=r-l+1\n    if x!=1 and (x*(x-1)\/\/2)%2:\n        c=not c\n    if c:\n        print(\"odd\")\n    else:\n        print(\"even\")","output":"quadratic"},{"instruction":"import itertools\n\nn, l, r, x = map(int, input().split())\nC = list(map(int, input().split()))\n\nans = 0\nfor i in range(2, n+1):\n  for c in itertools.combinations(C, i):\n    d = sum(c)\n    if d < l or d > r:\n      continue\n    if max(c) - min(c) < x:\n      continue\n    ans += 1\n\nprint(ans)","output":"np"},{"instruction":"from collections import defaultdict\nfrom math import gcd\nfrom heapq import heappop, heappush\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nhp = [(0, 0)]\ndis = {0: 0}\nseen = set()\nwhile hp:\n    _, x = heappop(hp)\n    if x == 1:\n        print(dis[x])\n        break\n    if x in seen: continue\n    seen.add(x)\n    for a, b in zip(A, B):\n        y = gcd(x, a)\n        if y not in dis or dis[y] > dis[x] + b:\n            dis[y] = dis[x] + b\n            heappush(hp, (dis[y], y))\nelse:\n    print(-1)","output":"np"},{"instruction":"from sys import stdin\nimport collections\nimport copy\nimport math\n\nn = int(stdin.readline())\nm = int(stdin.readline())\nup = list(map(int, stdin.readline().split()))\ndown = list(map(int, stdin.readline().split()))\n\ndef check(x):\n    weight = m + x\n    fuel = x\n    for i in range(n):\n        f = weight\/up[i]\n        if fuel<f:\n            return False\n        else:\n            weight -= f\n            fuel -= f\n        f = weight\/down[i]\n        if fuel<f:\n            return False\n        else:\n            weight -= f\n            fuel -= f\n    return True\n\nl = 0\nr = 1e9 + 1e-6\n\nfor ii in range(100):\n    mid = (r + l)\/2\n\n    if(check(mid)):\n        r = mid\n    else:\n        l = mid\n    if r-l <= 1e-10:\n        break\nif l >= 1e9+ 1e-6:\n    print(-1)\nelse:\n    print(\"%.10f\" %l)","output":"linear"},{"instruction":"import sys\n\nn, s = map(int, input().split())\n\nok, ng = 10**18+100, -1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) >> 1\n    if mid - sum(map(int, str(mid))) >= s:\n        ok = mid\n    else:\n        ng = mid\n\nprint(max(0, n - ok + 1))","output":"logn"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor j, v in enumerate(b):\n\te[v][j] = j\n\td[j].append(j)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"import sys\n\ndef main():\n\n    n,k=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    arr.sort()\n    dic={}\n    for a in arr:\n        if a\/k not in dic:\n            dic[a]=1\n\n    print(len(dic))\n\nmain()","output":"nlogn"},{"instruction":"m=int(1e9+7)\n\ndef solve(x, k):\n    return (m+(pow(2, k, m)*x%m)%m-((pow(2, k, m)-1)%m*pow(2, m-2, m)%m)%m)%m;\n\nx,k=[int(x) for x in input().split()]\n\nif x==0:\n    print(0)\nelif k==0:\n    print((m+2*(x%m))%m)\nelse:\n    print((m+2*solve(x, k))%m)","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n=int(input())\n    prob=[]\n    for _ in range(n):\n        prob.append(list(map(float,input().split())))\n\n    dp=[-1 for _ in range(1<<n)]\n\n    ans=[0 for _ in range(n)]\n\n    def move(mask,die):\n\n        total=bin(mask).count('1')\n\n        z=0\n\n        for i in range(n):\n            if mask & (1<<i):\n                z+=prob[i][die]\n\n        return z\/((total*(total-1))>>1)\n\n    def solve(mask):\n\n        if mask==(1<<n)-1:\n            return 1\n\n        if dp[mask]!=-1:\n            return dp[mask]\n\n        ans=0\n        for i in range(n):\n            if not (mask & (1<<i)):\n                prev=solve(mask ^ (1<<i))\n\n                ans+=prev*move(mask ^ (1<<i),i)\n\n        dp[mask]=ans\n        return ans\n\n    for i in range(n):\n        ans[i]='%.6f'%solve(1<<i)\n\n    print(*ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"n = int(input())\n\nb = [int(_) for _ in input().split()]\n\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\n\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"n,m = map(int,input().split())\nli = [[j for j in input()] for i in range(n)]\n\nfor j in range(m):\n    flag = False\n    for i in range(n):\n        if li[i][j] == \"B\":\n            flag = True\n            position1 = i\n            break\n    if(flag == True):\n        break\nfor j in range(m-1,-1,-1):\n    flag = False\n    for i in range(n-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position2 = i\n            break\n    if(flag == True):\n        break\nfor i in range(n):\n    flag = False\n    for j in range(m):\n        if li[i][j] == \"B\":\n            flag = True\n            position3 = j\n            break\n    if(flag == True):\n        break\nfor i in range(n-1,-1,-1):\n    flag = False\n    for j in range(m-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position4 = j\n            break\n    if(flag == True):\n        break\n\navg1 = (position1+position2)\/\/2 + 1\navg2 = (position3 + position4)\/\/2 + 1\nprint(avg1,avg2)","output":"quadratic"},{"instruction":"import sys\nimport bisect\n\nls2int = lambda ls: int(''.join(map(str,ls)))\ndef candidates(digs, num):\n    if not digs:\n        return [[]]\n\n    res = []\n    i = bisect.bisect_left(digs, num[0])\n\n    if num[0] in digs:\n        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):\n            res.append([digs[i]] + suffix)\n\n    if i > 0:\n        i -= 1\n        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))\n\n    return res\n\ndef solution(a, b):\n    digits = [int(x) for x in sorted(a)]\n    ceiling = [int(x) for x in b]\n\n    assert(len(digits) <= len(ceiling), 'solution does not exist')\n    if len(digits) < len(ceiling):\n        return ls2int(digits[::-1])\n    return max(ls2int(ls) for ls in candidates(digits, ceiling))\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\nprint(solution(a, b))","output":"cubic"},{"instruction":"a=list(map(int,input().split()))\nmr=0\nfor t in range(14):\n    b=list(a)\n    m=b[t]\n    k=t\n    i=1\n    b[k]=0\n    while(m>0):\n        if(m\/\/14==0):\n            b[(k+i)%14]+=1\n            m-=1\n            i+=1\n        else:\n            q=m\/\/14\n            for c in range(14):\n                b[c]+=q\n            m-=14*q\n    p=sum([ x  for x in b if x%2==0 ])\n    mr=max(p,mr)\nprint(mr)","output":"constant"},{"instruction":"K = 998244353\ndef mu(a, n):\n\tif n == 0: return 1\n\tq = mu(a, n \/\/ 2)\n\tif n % 2 == 0: return q * q % K\n\treturn q * q % K * a % K\nMAXN = 200005\ndd = [0 for i in range(MAXN)]\np = [0 for i in range(MAXN)]\ns = [0 for i in range(MAXN)]\na = [0 for i in range(MAXN)]\nfen = [0 for i in range(MAXN)]\n\ndef add(u, v):\n\ti = u\n\twhile (i <= 200000):\n\t\tfen[i] += v\n\t\ti += i & -i\n\ndef get(u):\n\tres = 0\n\ti = u\n\twhile (i > 0):\n\t\tres += fen[i]\n\t\ti -= i & -i\n\treturn res\n\nn = int(input())\n\ndata = input().split()\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\tp[i] = int(data[i - 1])\n\tif (p[i] > 0): dd[p[i]] = 1\n\telse: cnt += 1\n\nfor i in range(1, n + 1):\n\tif (dd[i] == 0):\n\t\ts[i] = s[i - 1] + 1\n\telse:\n\t\ts[i] = s[i - 1]\n\ncnt1 = 0\nP = 0\nden = mu(cnt, K - 2)\nfor i in range(1, n + 1):\n\tif (p[i] == -1):\n\t\tcnt1 += 1\n\telse:\n\t\tu = cnt - cnt1\n\t\tP = (P + u * s[p[i]] % K * den % K) % K\n\t\tP = (P + cnt1 * (cnt - s[p[i]]) % K * den % K) % K\n\nP = (P + cnt * (cnt - 1) * mu(4, K - 2)) % K\n\nm = 0\n\nfor i in range(1, n + 1):\n\tif p[i] > 0:\n\t\tm += 1\n\t\ta[m] = p[i]\n\nP1 = 0\nfor i in range(m, 0, -1):\n\tP1 = (P1 + get(a[i])) % K\n\tadd(a[i], 1)\n\nP = (P + P1) % K\n\nprint(P)","output":"nlogn"},{"instruction":"n = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int,input().split()))+[i+1])\na.sort(key = lambda e:e[0])\nf = 0\nfor i in range(n-1):\n    if a[i][0] == a[i+1][0]:\n        if a[i][1] >= a[i+1][1]:\n            print(a[i+1][2],a[i][2])\n        else:print(a[i][2],a[i+1][2])\n        f =1\n        break\n    if a[i][1] >= a[i+1][1]:\n        f = 1\n        print(a[i+1][2],a[i][2])\n        break\nif f == 0:print(-1,-1)","output":"nlogn"},{"instruction":"import sys\ndef contain(a, b):\n    ax1, ay1, ax2, ay2 = a\n    bx1, by1, bx2, by2 = b\n    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2\ndef ask(x1, y1, x2, y2, known=(), memo={}):\n    if x2 < x1+1 or y2 < y1+1:\n        return 0\n    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))\n    key = (x1+1, y1+1, x2, y2)\n    if key in memo:\n        return memo[key] - ofs\n    print('?', *key)\n    sys.stdout.flush()\n    memo[key] = int(input())\n    return memo[key] - ofs\ndef binsearch(l, r, p):\n    assert l < r\n    while l+1 != r:\n        m = (l + r) \/\/ 2\n        if p(m):\n            r = m\n        else:\n            l = m\n    return r\ndef shrink(x1, y1, x2, y2, cnt, known=()):\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1\n    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1\n    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)\n    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    return x1, y1, x2, y2\ndef go(x1, y1, x2, y2):\n    assert ask(x1, y1, x2, y2) == 2\n    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)\n    a = None\n    if not a and x1 < x2:\n        if ask(x1+1, y1, x2, y2) == 1:\n            a = shrink(x1+1, y1, x2, y2, 1)\n        elif ask(x1, y1, x2-1, y2) == 1:\n            a = shrink(x1, y1, x2-1, y2, 1)\n    if not a and y1 < y2:\n        if ask(x1, y1+1, x2, y2) == 1:\n            a = shrink(x1, y1+1, x2, y2, 1)\n        elif ask(x1, y1, x2, y2-1) == 1:\n            a = shrink(x1, y1, x2, y2-1, 1)\n    if not a:\n        a = x1, y1, x2, y2\n        return a, a\n    else:\n        b = shrink(x1, y1, x2, y2, 1, known=[ a ])\n        return a, b\nn = int(input())\na, b = go(0, 0, n, n)\nax1, ay1, ax2, ay2 = a\nbx1, by1, bx2, by2 = b\nprint('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)","output":"logn"},{"instruction":"from sys import stdin\nfrom collections import Counter\n\nrstr = lambda: stdin.readline().strip()\na, b = list(rstr()), list(rstr())\n\nif len(a) < len(b) or len(a) == 1:\n    print(''.join(sorted(a)[::-1]))\nelse:\n    ans, tem = 0, []\n\n    for i in range(len(b)):\n        for j in range(int(b[i]) - 1, -1, -1):\n            if str(j) in a and not (j == i == 0):\n                a.remove(str(j))\n                ans = max(ans, int(''.join(tem) + str(j) + ''.join(sorted(a)[::-1])))\n                a.append(str(j))\n                break\n\n        if b[i] not in a:\n            break\n\n        tem.append(b[i])\n        a.remove(b[i])\n\n    if tem:\n        ans = max(ans, int(''.join(tem)))\n\n    print(ans)","output":"cubic"},{"instruction":"list1=input()\nl=list1.split()\nl=[int(item) for item in l]\n\nn,m,k=l\n\na=input()\na1=map(int,a.split())\n\na1=list(sorted(a1))\n\ncount=0\nfor i in range(len(a1)):\n    if k>=m:\n        break\n    else:\n        k+=a1.pop()-1\n        count+=1\n\nif k>=m:\n    print(count)\nelse:\n    print(\"-1\")","output":"nlogn"},{"instruction":"L = [(i+1)*9*10**i for i in range(12)]\nnumber = int(input())\n\nexponent=0\nwhile number >= 0:\n    number-=L[exponent]\n    exponent+=1\nexponent-=1\nnumber%=L[exponent]\nstart = 10**exponent\nnumDigits = exponent+1\nfinal = start+(number\/\/numDigits-1)\nremainder = number%numDigits\nif remainder == 0:\n    final = str(final)\n    print(final[-1])\nelse:\n    final = str(final+1)\n    print(final[remainder-1])","output":"logn"},{"instruction":"n, m, k = map(int, input().split())\nDATA = [input() for i in range(n)]\n\nINF = 1 << 60\ndp = [[INF]*(k + 10) for i in range(n + 10)]\ndp[0][0] = 0\n\nCOST = [[INF]*(k + 10) for i in range(n + 10)]\nfor i, string in enumerate(DATA):\n\n    stack = []\n    for j in range(m):\n        if string[j] == \"1\":\n            stack.append(j)\n    L = len(stack)\n    for j in range(k + 10):\n        if j >= L:\n            COST[i + 1][j] = 0\n            continue\n        else:\n            for pos in range(j + 1):\n                l = pos\n                r = pos + L - 1 - j\n                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)\nfor day in range(1, n + 1):\n    for used_cost in range(k + 1):\n        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]\n                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))\n\nans = min(dp[n][used_cost] for used_cost in range(k + 1))\nprint(ans)","output":"cubic"},{"instruction":"n = int(input())\nd = {}\nfor i in range(n):\n    a,b = map(int,input().split())\n    d[a] = b\nm = int(input())\nfor i in range(m):\n    a,b = map(int,input().split())\n    if d.get(a)==None:\n        d[a] = b\n    else:\n        if b>d[a]:\n            d[a] = b\nans = 0\nfor i in d:\n    ans+=d[i]\nprint(ans)","output":"nlogn"},{"instruction":"I=lambda:map(int,input().split())\nn,m=I()\nq={}\nfor i in range(1,n+1):q[i]=0\nfor i in I():q[i]+=1\nprint(min(q.values()))","output":"quadratic"},{"instruction":"import sys, os\nfrom io import BytesIO, IOBase\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)\/\/b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nn, m, k = mp()\nhor = [lmp() for i in range(n)]\nver = [lmp() for i in range(n-1)]\nif k%2:\n    ml = l2d(n, m, -1)\n    for i in ml: print(*i)\n    exit()\nk\/\/=2\ndp = [l2d(n, m) for i in range(k+1)]\nfor f in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            a = inf\n            if i!=0:\n                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])\n            if i!=n-1:\n                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])\n            if j!=0:\n                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])\n            if j!=m-1:\n                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])\n            dp[f][i][j] = a\nfor i in dp[-1]:\n    print(*i)","output":"cubic"},{"instruction":"from math import *\nl, r = list(map(int, input().split(\" \")))\nprint((2<<floor(log2(l^r)))-1 if l!=r else 0)","output":"logn"},{"instruction":"import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n\n    tc=1\n    for _ in range(tc):\n\n        s=2*rs()+\"333\"\n        le=(len(s)-3)\/\/2\n        a=[]\n        for i in s:\n            if i=='b':\n                a.append(0)\n            if i=='w':\n                a.append(1)\n            if i=='3':\n                a.append(3)\n        pehla=[0,1]*len(s)\n\n        doosra=[1,0]*len(s)\n\n        k=[0]*len(s)\n        for i in range(len(s)):\n            if a[i]==pehla[i]:\n                k[i]=1\n        ans=0\n        t=0\n        for i in k:\n            if i==1:\n                t+=1\n\n            else:\n                ans=max(t,ans)\n                t=0\n\n        k=[0]*len(s)\n        for i in range(len(s)):\n            if a[i]==doosra[i]:\n                k[i]=1\n\n        t=0\n        for i in k:\n            if i==1:\n                t+=1\n\n            else:\n                ans=max(t,ans)\n                t=0\n\n        print(min(le,ans))\n\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()","output":"linear"},{"instruction":"from sys import stdin\nn = int(stdin.readline()) + 1\nif n == 1:\n    print(0)\nelse:\n    print(n\/\/2 if n%2 == 0 else n)","output":"constant"},{"instruction":"n = int(input())\nx  = input()\nl = list(map(int, x.split()))\n\ndict = {}\n\nfor i in l:\n    dict[i] = 0;\nsum = 0\nfre = 0\nans = 0\nfor i in range(n-1,-1, -1):\n\n    x = sum\n    y = fre\n    for j in range(-1,2):\n        aa = l[i]+j\n        if aa in dict:\n            x-= aa*dict[aa]\n            y-= dict[aa]\n\n    ans += x - l[i]*y\n    fre+=1\n    sum+=l[i]\n    dict[l[i]]+=1\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split(' ')))\nArray = [a]\n\nfor i in range(n - 1):\n    aux = []\n    for j in range(1, len(Array[-1])):\n        aux.append(Array[-1][j-1] ^ Array[-1][j])\n    Array.append(aux)\n\nfor j in range(1, len(Array)):\n    for k in range(len(Array[j])):\n        Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1])\n\nq = int(sys.stdin.readline())\nfor i in range(q):\n    l, r = map(int, sys.stdin.readline().split(' '))\n    sys.stdout.write(str(Array[r - l][l - 1]) + '\\n')","output":"quadratic"},{"instruction":"mod = int(1e9 + 7)\n\nn = int(input())\na = [int(_) for _ in input().split()]\n\nfreq = {i: 0 for i in range(100001)}\npower = {0: 1}\nfor i in range(1, 100001):\n    power[i] = (2 * power[i - 1]) % mod\n\nfor v in a:\n    freq[v] += 1\n\ndp = {i: 0 for i in range(100001)}\nfor gcd in range(100000, 0, -1):\n    mult = 2\n    total = freq[gcd]\n    complement = 0\n\n    while mult * gcd <= 100000:\n        total += freq[mult * gcd]\n        complement += dp[mult * gcd]\n        mult += 1\n    dp[gcd] = (power[total] - 1 - complement + mod) % mod\n\nprint(dp[1])","output":"np"},{"instruction":"def process(X, a, b):\n    X1 = set(X)\n    Other = set([])\n    A = set([])\n    B = set([])\n    Both = set([])\n    for x in X:\n        if a-x in X1 and b-x  not in X1:\n            A.add(x)\n            A.add(a-x)\n        elif a-x not in X1 and b-x in X1:\n            B.add(x)\n            B.add(b-x)\n        elif a-x not in X1 and b-x not in X1:\n            return 'NO'\n        else:\n            Both.add(x)\n    start = A.copy()\n    while len(start) > 0:\n        next_s = set([])\n        for x in start:\n            if b-x in Both:\n                Both.remove(b-x)\n                next_s.add(b-x)\n                if a-b+x in Both:\n                    Both.remove(a-b+x)\n                    A.add(a-b+x)\n                    next_s.add(a-b+x)\n                A.add(b-x)\n            if a-x in Both:\n                Both.remove(a-x)\n                next_s.add(a-x)\n                A.add(a-x)\n            elif a-x in B or a-x not in A:\n                return 'NO'\n        start = next_s\n    start = B.copy()\n    while len(start) > 0:\n        next_s = set([])\n        for x in start:\n            if a-x in Both:\n                Both.remove(a-x)\n                next_s.add(a-x)\n                if b-a+x in Both:\n                    Both.remove(b-a+x)\n                    B.add(b-a+x)\n                    next_s.add(b-a+x)\n                B.add(a-x)\n            if b-x in Both:\n                Both.remove(b-x)\n                next_s.add(b-x)\n                B.add(b-x)\n            elif b-x in A or b-x not in B:\n                return 'NO'\n        start = next_s\n    answer = []\n    for x in X:\n        if x in A:\n            answer.append(0)\n        else:\n            answer.append(1)\n    return answer\n\nn, a, b = [int(x) for x in input().split()]\nX = [int(x) for x in input().split()]\nanswer = process(X, a, b)\nif answer=='NO':\n    print('NO')\nelse:\n    print('YES')\n    print(' '.join(map(str, answer)))","output":"linear"},{"instruction":"def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nn = int(input())\na = [list(input()) for i in range(n)]\nb = [list(input()) for i in range(n)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(n)] for u in range(n)]\n    for t in range(n):\n        for u in range(n):\n            c[t][u] = b[u][n - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')","output":"quadratic"},{"instruction":"n , s = map(int,input().split())\na = [0] * (n+1)\nfor _ in range(n-1) :\n    u , v=map(int, input().split())\n    a[u] += 1\n    a[v] += 1\nprint(2.0*s\/a.count(1))","output":"linear"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    string=[]\n    for i in range(100):\n        string.append([])\n    for i in range(n):\n        val=((get_string()))\n        size=len(val)\n        string[size-1].append(val)\n    for i in range(100):\n        if len(string[i])>0:\n            string[i].sort()\n    ans=[]\n    poss=True\n    for i in range(100):\n        if len(string[i])==0:\n            continue\n        else:\n            row=string[i]\n            if len(set(row))>1:\n                poss=False\n    if poss==False:\n        print(\"NO\")\n    else:\n        for i in range(100):\n            if len(string[i])==0:\n                continue\n            for j in range(i+1,100):\n                if len((string[j]))==0:\n                    continue\n                sub_string=(string[i][0])\n                main=(string[j][0])\n                if sub_string in main:\n                    res=True\n                else:\n                    res=False\n                if res==False:\n                    poss=False\n                    break\n                else:\n                    break\n        if poss==False:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(100):\n                if len(string[i])==0:\n                    continue\n                for j in range(len(string[i])):\n                    print(string[i][j])","output":"nlogn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range (1,n):\n    for j in range (i):\n        if a[j]>a[i]:\n            c+=1\nc=c%2\nm=int(input())\nfor i in range (m):\n    l,r=map(int,input().split())\n    s=(r-l+1)\/\/2\n    if s%2==1:\n        c=(c+1)%2\n    if c==0:\n        print(\"even\")\n    else:\n        print(\"odd\")","output":"quadratic"},{"instruction":"def main():\n    n,k=map(int,input().split( ))\n    a=list(map(int,input().split( )))\n    ans=-1*10**9+7\n    for i in range(n):\n        s=0\n        for j in range(i,n):\n            s+=a[j]\n            if j-i+1>=k:\n\n                ans=max(ans,s\/(j-i+1))\n    print(ans)\n\nmain()","output":"quadratic"},{"instruction":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n)]\n    r = []\n    for a,b in aa:\n        al = a + (1-a%2)\n        ar = b - (1-b%2)\n        sa = (ar-al) \/\/ 2 + 1\n        tr = -(al+ar) * sa \/\/ 2\n\n        bl = a + (a%2)\n        br = b - (b%2)\n        sb = (br-bl) \/\/ 2 + 1\n        tr += (bl+br) * sb \/\/ 2\n        r.append(tr)\n\n    return \"\\n\".join(map(str,r))\n\nprint(main())","output":"constant"},{"instruction":"a,b = map(int,input().split())\na = a^b\nk = 0\nwhile a:\n\tk += 1\n\ta = a>>1\nprint(2**k-1)","output":"logn"},{"instruction":"from sys import stdin\ninput=stdin.readline\n\ndef intersec(arr):\n    a=sorted(arr,key=lambda s:s[0],reverse=True)\n    b=sorted(arr,key=lambda s:s[1])\n\n    x, y = 0, 0\n    if a[0]==b[0]:\n        return max(b[1][1]-a[1][0],0)\n    else:\n        x=b[0][1]-a[1][0]\n        y=b[1][1]-a[0][0]\n    return max(x,y,0)\nblanck=[]\nfor i in range(int(input())):\n    a,b=map(int,input().strip().split())\n    blanck.append([a,b])\nprint(intersec(blanck))","output":"linear"},{"instruction":"import sys\ndef input(): return sys.stdin.readline().strip()\n\nn, mod = map(int, input().split())\n\nle = 405\n\ndef pow(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = (ans * x) % mod\n        x = (x**2) % mod\n        y \/\/= 2\n    return ans\n\ndef inv(x):\n    return pow(x, mod-2)\n\nM = [1]\nmul = 1\nfor i in range(1, le):\n    mul = (mul * i) % mod\n    M.append(mul)\n\nMI = [0] * (le-1) + [inv(M[le-1])]\nfor i in range(le-2, -1, -1):\n    MI[i] = MI[i+1] * (i+1) % mod\n\ndef C(x, y):\n    if y < 0 or y > x:\n        return 0\n    elif x > le:\n        y = min(y, x-y)\n        ans = 1\n        for i in range(x, x-y, -1):\n            ans = (ans * i) % mod\n        return (ans * MI[y]) % mod\n    else:\n        ans = M[x]\n        ans = (ans * MI[y]) % mod\n        return (ans * MI[x-y]) % mod\n\nM2 = [1]\nfor i in range(n+5):\n    M2.append((M2[-1]*2) % mod)\n\nCO = [[0] * (n+5) for i in range(n+5)]\nfor i in range(n+5):\n    for j in range(n+5):\n        CO[i][j] = C(i, j)\n\nD = [[0] * (n+1) for i in range(n+2)]\n\nD[0][0] = 1\nfor i in range(n+2):\n    for j in range(i\/\/2, min(n+1, i+1)):\n\n        for k in range(1, min(n+1, n-i+1, n-j+1)):\n\n            ind0 = i+k+1\n            ind1 = j+k\n            if ind0 <= n+1 and ind1 <= n:\n                D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1]\n                D[ind0][ind1] %= mod\n\nprint(sum(D[-1]) % mod)","output":"cubic"},{"instruction":"n,least,most,x = map(int,input().split())\nc = list(map(int,input().split()))\n\nans= 0\n_max = lambda x,y: x if x>y else y\n_min = lambda x,y: x if x<y else y\n\nfor mask in range(1<<n):\n    mx = float('-inf')\n    mn = float('inf')\n    count = 0\n    Sum = 0\n    for i in range(n):\n        if mask&(1<<i):\n            count+=1\n            Sum+=c[i]\n            mx = _max(mx,c[i])\n            mn = _min(mn,c[i])\n    if mx-mn>=x and Sum>=least and Sum<=most and count >=2:\n        ans+=1\nprint(ans)","output":"np"},{"instruction":"def subsets(S):\n    sets = []\n    len_S = len(S)\n    for i in range(1 << len_S):\n        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]\n        sets.append(subset)\n    return sets\n\nn, l, r, x = list(map(int, input().split()))\nproblems = list(map(int, input().split()))\nres = 0\nfor m in subsets(problems):\n    if l <= sum(m) <= r and (max(m) - min(m)) >= x:\n        res += 1\nprint(res)","output":"np"},{"instruction":"n = int(input())\ns = input()\nt = input()\nsl = [i for i in s]\ntl = [i for i in t]\nans = []\nif(''.join(sorted(s))!=''.join(sorted(t))):\n    print(-1)\n\nelse:\n    for i in range(n):\n        if(sl[i]!=tl[i]):\n            for j in range(i+1,n):\n                if(sl[j]==tl[i]):\n                    break\n            for k in range(j-1,i-1,-1):\n                sl[k],sl[k+1] = sl[k+1],sl[k]\n                ans.append(k+1)\n\n    print(len(ans))\n    for i in ans:\n        print(i,end=' ')","output":"quadratic"},{"instruction":"def size_of_group(i):\n    return long(9 * 10**(i - 1)) * i\n\ndef find_group(k, i = 1):\n    diff = long(k - (size_of_group(i)))\n    if diff <= 0:\n        return k, i\n    return find_group(diff, i + 1)\n\ndef get_number(k, g):\n    return str(long(10**(g - 1)) + k \/ g)[k % g]\n\ndef get_sequence_number(num):\n\n    k_prim, g_prim = find_group(num)\n    return get_number(k_prim - 1, g_prim)\n\nif __name__ == \"__main__\":\n    print(get_sequence_number(long(input())))","output":"logn"},{"instruction":"arra = []\narrb = []\narr = []\ns = \"\"\ntemp = 1\nvalue = ans = n = 0\n\ndef fill(myList = [], *args):\n    for i in range(n):\n        arra.insert(0,0)\n\ndef check():\n    for i,j in zip(arra,arrb):\n        if i == j:\n            return 1\n        else:\n            return 0\n\ndef Engine1(num):\n    if num > 1:\n        Engine1(num \/\/ 2)\n    arra.append( num%2 )\ndef Engine2(num):\n    if num > 1:\n        Engine2(num \/\/ 2)\n    arrb.append( num%2 )\n\na,b = map(int,input().split())\nEngine1(a)\nEngine2(b)\n\nn = abs(len(arra)-len(arrb))\nif(len(arra)>len(arrb)):\n    fill(arrb)\nif(len(arra)<len(arrb)):\n    fill(arra)\n\nfor i in range(len(arra)):\n    if(check() == 0):\n        break\n    check()\n    arra.pop(0)\n    arrb.pop(0)\n\nfor i in range(len(arra)):\n    ans += temp\n    temp *= 2\nprint(ans)","output":"logn"},{"instruction":"n,m=map(int,input().split())\ncount=[0]*n\na=list(map(int,input().split()))\nfor i in range(m):\n    count[a[i]-1]+=1\nprint(min(count))","output":"quadratic"},{"instruction":"for _ in range(int(input())):\n    s = input()\n    t = input()\n    if len(t) == 1:\n        print(\"YES\" if t in s else \"NO\")\n        continue\n    nxt = [[-1] * 26 for _ in range(len(s) + 1)]\n    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1\n    for i in range(len(s) - 2, -1, -1):\n        for c in range(26):\n            nxt[i][c] = nxt[i + 1][c]\n        nxt[i][ord(s[i]) - ord('a')] = i\n    ans = \"NO\"\n    for p in range(len(t)):\n        a = t[:p]\n        b = t[p:]\n        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]\n        dp[0][0] = 0\n        for la in range(len(a) + 1):\n            for lb in range(len(b) + 1):\n                if dp[la][lb] != -1:\n                    if la < len(a):\n                        if dp[la + 1][lb] != -1:\n                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:\n                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                        else:\n                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                    if lb < len(b):\n                        if dp[la][lb + 1] != -1:\n                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:\n                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                        else:\n                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                if dp[len(a)][len(b)] != -1:\n                    ans = \"YES\"\n                    break\n    print(ans)","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nres = []\nif n == 1:\n    print(1)\n    exit(0)\n\ni = 0\nif a[0] < a[1]:\n\n    if i >= n - 2:\n        res = [1]\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [1]\n            cur = 2\n        elif a[i + 1] > a[i + 2]:\n            res = [1]\n            cur = 5\n        else:\n            res = [1]\n            cur = 2\n\nelif a[0] > a[1]:\n\n    if i >= n - 2:\n        res = [5]\n        cur = 4\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [5]\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res = [5]\n            cur = 4\n        else:\n            res = [5]\n            cur = 4\n\nelse:\n    if i >= n - 2:\n        res.append(1)\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res.append(2)\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res.append(4)\n            cur = 5\n        else:\n            res.append(2)\n            cur = 3\n\nfor i in range(1, n - 1):\n    if not (1 <= cur <= 5):\n        print(-1)\n        exit(0)\n    res.append(cur)\n    if a[i] > a[i + 1]:\n\n        if i >= n - 2:\n            cur -= 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur = min(cur - 1, 1)\n            elif a[i + 1] > a[i + 2]:\n                cur -= 1\n            else:\n                cur -= 1\n\n    elif a[i] < a[i + 1]:\n\n        if i >= n - 2:\n            cur += 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur += 1\n            elif a[i + 1] > a[i + 2]:\n                cur = max(cur + 1, 5)\n            else:\n                cur += 1\n    else:\n        if i >= n - 2:\n            if cur != 3:\n                cur = 3\n            else:\n                cur = 2\n        else:\n            if a[i + 1] < a[i + 2]:\n                if cur == 1:\n                    cur = 2\n                else:\n                    cur = 1\n            elif a[i + 1] > a[i + 2]:\n                if cur == 5:\n                    cur = 4\n                else:\n                    cur = 5\n            else:\n                if cur != 3:\n                    cur = 3\n                else:\n                    cur = 2\nif not (1 <= cur <= 5):\n    print(-1)\n    exit(0)\nres.append(cur)\nprint(*res)","output":"linear"},{"instruction":"n, c = map(int, input().split())\nres1 = [0] * 500001\nres = 0\nfor ai in map(int, input().split()):\n\tres1[ai] = max(res1[ai], res1[c])\n\tres1[ai] += 1\n\tres = max(res, res1[ai] - res1[c])\nprint(res + res1[c])","output":"linear"},{"instruction":"idx = {}\nidx[0] = 0\ns = 0\nnum = 9\nfor digit in range(1,12):\n    s += num*digit\n\n    idx[digit] = s\n    num = num*10\n\nN = int(input())\n\nnubmer = 0\nr = 0\nd = 0\nfor digit in range(1,12):\n    if N<=idx[digit] and N>idx[digit-1]:\n\n        number = (N-idx[digit-1])\/\/digit\n        r = (N-idx[digit-1])%digit\n        d = digit\n        break\n\nif r!=0:\n    number += 1\n\nnum = 10**(d-1) + number - 1\n\ndigit = [int(i) for i in str(num)]\nif r==0:\n    print(digit[-1])\n\nelse:\n    print(digit[r-1])","output":"logn"},{"instruction":"from collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\nfrom itertools import groupby as gb\nfrom fractions import Fraction as fr\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()\ndef decimalToBinary(n):\n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number \/ 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number \/ i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x):\n    return (math.log10(x) \/\n            math.log10(2));\n\ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) == math.floor(Log2(n)));\ndef ceildiv(x,y): return (x+y-1)\/\/y\n\nn=int(input())\nif n==0:\n    print(0)\nelse:\n    if (n+1)%2:\n        print(n+1)\n    else:\n        print((n+1)\/\/2)","output":"constant"},{"instruction":"n=int(input())\nl=[int(i) for i in input().split()]\ns=set(l)\nif 0 in s:\n    print(len(s)-1)\nelse:\n    print(len(s))","output":"linear"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\ndef Binary_Search(arr , n , x):\n    l , r = 0 , n-1\n    while l <= r :\n        mid = l + (r - l )\/\/2\n        if arr[mid] == x :\n            return mid+1\n        elif arr[mid] > x :\n            r = mid - 1\n        else:\n            l = mid + 1\n    return r + 1\n\nn , q = MAP()\na = LIST()\nb = LIST()\nps = list(accumulate(a))\nres = []\nsm = 0\nfor i in range(q):\n    sm += b[i]\n    if sm >= ps[-1]:\n        res.append(n)\n        sm = 0\n    else:\n        z = (Binary_Search(ps , n , sm))\n        res.append(n - z)\nfor i in res:\n    print(i)","output":"nlogn"},{"instruction":"class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, node = len(points), 0\n        dist = [100000000] * n\n        visit = [False] * n\n        edges, res = 0, 0\n\n        while edges < n - 1:\n            visit[node] = True\n            nextNode = -1\n            for i in range(n):\n                if visit[i]:\n                    continue\n                curDist = (abs(points[i][0] - points[node][0]) +\n                           abs(points[i][1] - points[node][1]))\n                dist[i] = min(dist[i], curDist)\n                if nextNode == -1 or dist[i] < dist[nextNode]:\n                    nextNode = i\n\n            res += dist[nextNode]\n            node = nextNode\n            edges += 1\n\n        return res","output":"quadratic"},{"instruction":"from __pypy__.intop import int_mulmod\n\nn_, MOD = [int(t) for t in input().split()]\n\ndef mul(a, b):\n    return int_mulmod(a, b, MOD)\n\nN = 410\ndp = [[0] * (N+1) for _ in range(N+1)]\n\nfact = [1]\nfor x in range(1, N):\n    fact.append(fact[-1] * x % MOD)\n\ninv_fact = [0] * N\ninv_fact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor x in reversed(range(1, N)):\n    inv_fact[x - 1] = inv_fact[x] * x % MOD\n\ndef nCr(n, r):\n    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))\n\nfor n in range(1, N+1):\n    dp[n][n] = pow(2, n-1, MOD)\n    for i in range(1, n-1):\n        j = n-i-1\n        for k in range(1, i+1):\n            dp[n][k+j] = (dp[n][k+j]\n                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD\n\nprint(sum(dp[n_]) % MOD)","output":"cubic"},{"instruction":"import math\n\nq = int(input())\n\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > k or y > k:\n        print(-1)\n    else:\n        if (x+y)%2 == 0:\n            if (k-max(x,y)) % 2 == 0:\n                print(k)\n            else:\n                print(k - 2)\n        else:\n            if (k-max(x,y)) % 2 == 0:\n                print(k-1)\n            else:\n                print(k-1)","output":"constant"},{"instruction":"N, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nbv = 0\nfor ms in range(M):\n    cv = 0\n    for i in range(ms, N):\n        v = A[i]\n        if i % M == ms:\n            v -= K\n            cv = max(0, cv)\n        cv += v\n        bv = max(bv, cv)\nprint(bv)","output":"quadratic"},{"instruction":"from sys import stdin\n\nmemo = {}\ndef max_splits(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n in memo:\n        return memo[n]\n    result = 4 * max_splits(n - 1) + 1\n    memo[n] = result\n    return result\n\nt = int(stdin.readline())\nfor i in range(t):\n    n, k = [int(s) for s in stdin.readline().strip().split()]\n\n    min_splits = 1\n    path_count = 3\n\n    if n > 75:\n        print(\"YES\", n - 1)\n        continue\n\n    square_size = n - 1\n    max_buffer = max_splits(square_size)\n\n    while min_splits + path_count <= k and square_size > 0:\n        min_splits += path_count\n        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)\n        path_count = 2 * path_count + 1\n        square_size -= 1\n\n    if min_splits <= k <= min_splits + max_buffer:\n        print(\"YES\", square_size)\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"from itertools import combinations\n\nn, l, r, x = map(int, input().split())\n(*a,) = map(int, input().split())\nsumu = 0\nfor i in range(2, n + 2):\n    for j in combinations(a, i):\n        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):\n            sumu += 1\nprint(sumu)","output":"np"},{"instruction":"line = input().split()\nline.sort()\na,b,c = line\nif a == b and a == c:\n    print(0)\nelif a == b:\n    print(1)\nelif b == c:\n    print(1)\nelse:\n    if a[1] == b[1] and b[1] == c[1] \\\n        and int(b[0])-int(a[0]) == 1 and int(c[0])-int(b[0]) == 1:\n        print(0)\n    elif a[1] == b[1] and int(b[0])-int(a[0]) in [1,2]:\n        print(1)\n    elif b[1] == c[1] and int(c[0])-int(b[0]) in [1,2]:\n        print(1)\n    elif a[1] == c[1] and int(c[0])-int(a[0]) in [1,2]:\n        print(1)\n    else:\n        print(2)","output":"nlogn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\nfor _ in range(getInt()):\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    print(min(dp)+1)","output":"cubic"},{"instruction":"n=int(input())\nif(n>=0):\n    print(n)\nelse:\n    n=abs(n)\n    rem=n%10\n    n1=n\/\/10\n    n2=n1\/\/10\n    n2=n2*10+rem\n    k=min(n1,n2)\n    print(-1*k)","output":"constant"},{"instruction":"from sys import stdin\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\ngraph = [set() for _ in range(n)]\n\nfor _ in range(n-1):\n    a,b = map(int,stdin.readline().split())\n\n    graph[a - 1].add(b - 1)\n    graph[b - 1].add(a - 1)\n\nleafs = [i for i,v in enumerate(graph) if len(v) == 1]\nnew_leafs = []\nvalid = True\ncenters = dict()\ncount = 0\n\nwhile len(leafs) > 1 and valid:\n    for leaf in leafs:\n        center = graph[leaf].pop()\n\n        try:\n            centers[center] += 1\n        except KeyError:\n            centers[center] = 1\n\n        graph[center].remove(leaf)\n\n        if len(graph[center]) == 0:\n            break\n\n        elif len(graph[center]) == 1:\n            new_leafs.append(center)\n\n    if any(mult < 3 for mult in centers.values()):\n        valid = False\n        break\n\n    count = count + 1\n    leafs = new_leafs\n    new_leafs = []\n    centers = {}\n\nif valid and count == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"l,r=list(map(int,input().split()))\nif l==r:\n    print(0)\nelse:\n    x=l^r\n    c=0\n    while x>0:\n        x=x\/\/2\n        c=c+1\n    print(2**c-1)","output":"logn"},{"instruction":"def pwr(a,n,m):\n    if n==0:return 1\n    ans=pwr(a,n\/\/2,m)\n    ans=ans*ans\n    ans%=m\n    if n%2==1:return (ans*a)%m\n    else: return ans\nM=1000000007\ntx,tn=input().split()\nx=int(tx)\nn=int(tn)\nans=pwr(2,n+1,M)*x\nans%=M\nans=ans-pwr(2,n,M)+1\nans=(ans+M)%M\nif x==0: ans=0\nprint(ans)","output":"logn"},{"instruction":"a, b = map(int, input().split())\nprint((b+a-1)\/\/a)","output":"constant"},{"instruction":"from string import digits\nfrom collections import Counter\na = input()\nb = input()\nca = Counter(a)\nl = list()\nif len(b) > len(a):\n    for i in digits[::-1]:\n        if i in ca:\n            l.extend(i * ca[i])\nelse:\n    def asd(i, s):\n        if i == len(b):\n            return True\n        if s:\n            for j in digits[::-1]:\n                if j in ca and ca[j] > 0:\n                    l.extend(j * ca[j])\n            return True\n        else:\n            for j in digits[:int(b[i])+1][::-1]:\n                if j in ca and ca[j] > 0:\n                    ca[j] -= 1\n                    l.append(j)\n                    if asd(i + 1, j != b[i]):\n                        return True\n                    ca[j] += 1\n                    l.pop()\n            return False\n    asd(0, False)\nprint(\"\".join(l))","output":"cubic"},{"instruction":"import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn = inp()\na = inpl()\nres = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            res = 1-res\nfor _ in range(inp()):\n    l,r = inpl(); m = r-l+1\n    swap = m*(m-1)\/\/2\n    if swap%2: res = 1-res\n    print('odd' if res else 'even')","output":"quadratic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nres = []\nif n == 1:\n    print(1)\n    exit(0)\n\ni = 0\nif a[0] < a[1]:\n\n    if i >= n - 2:\n        res = [1]\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [1]\n            cur = 2\n        elif a[i + 1] > a[i + 2]:\n            res = [1]\n            cur = 5\n        else:\n            res = [1]\n            cur = 2\n\nelif a[0] > a[1]:\n\n    if i >= n - 2:\n        res = [5]\n        cur = 4\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [5]\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res = [5]\n            cur = 4\n        else:\n            res = [5]\n            cur = 4\n\nelse:\n    if i >= n - 2:\n        res.append(1)\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res.append(2)\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res.append(4)\n            cur = 5\n        else:\n            res.append(2)\n            cur = 3\n\nfor i in range(1, n - 1):\n    if not (1 <= cur <= 5):\n\n        print(-1)\n        exit(0)\n    res.append(cur)\n    if a[i] > a[i + 1]:\n\n        if i >= n - 2:\n            cur -= 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur = min(cur - 1, 1)\n            elif a[i + 1] > a[i + 2]:\n                cur -= 1\n            else:\n                cur -= 1\n\n    elif a[i] < a[i + 1]:\n\n        if i >= n - 2:\n            cur += 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur += 1\n            elif a[i + 1] > a[i + 2]:\n                cur = max(cur + 1, 5)\n            else:\n                cur += 1\n\n    else:\n        if i >= n - 2:\n            if cur != 3:\n                cur = 3\n            else:\n                cur = 2\n        else:\n            if a[i + 1] < a[i + 2]:\n                if cur == 1:\n                    cur = 2\n                else:\n                    cur = 1\n            elif a[i + 1] > a[i + 2]:\n                if cur == 5:\n                    cur = 4\n                else:\n                    cur = 5\n            else:\n                if cur != 3:\n                    cur = 3\n                else:\n                    cur = 2\nif not (1 <= cur <= 5):\n\n    print(-1)\n    exit(0)\nres.append(cur)\nprint(*res)","output":"linear"},{"instruction":"n = int(input())\nif n == 1:\n\tprint(\"1\")\nelif n == 2:\n\tprint(\"1 2\")\nelse:\n\tbase = 1\n\tgap = 2\n\tcur = base\n\tnext = 1\n\tans = ''\n\tfor i in range(n - 1):\n\t\tans += str(base) + ' '\n\t\tnext = cur\n\t\tcur += gap\n\t\tif cur > n:\n\t\t\tbase *= 2\n\t\t\tgap *= 2\n\t\t\tcur = base\n\t\tnext = max(next, cur)\n\tans += str(next)\n\tprint(ans)","output":"linear"},{"instruction":"def maxXORInRange(L, R):\n\n\tLXR = L ^ R\n\tmsbPos = 0\n\twhile(LXR):\n\n\t\tmsbPos += 1\n\t\tLXR >>= 1\n\tmaxXOR, two = 0, 1\n\n\twhile (msbPos):\n\n\t\tmaxXOR += two\n\t\ttwo <<= 1\n\t\tmsbPos -= 1\n\n\treturn maxXOR\n\nL, R = [int(i) for i in input().split()]\nprint(maxXORInRange(L, R))","output":"logn"},{"instruction":"a=input()\nc1=a.count('1')\na=a.split('2')\nlex='0'*a[0].count('0')+'1'*c1\nn=len(a)\nfor i in range(1,n):\n  lex=lex+'2'+'0'*a[i].count('0')\nprint(lex)","output":"linear"},{"instruction":"m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for j,xx in enumerate(values):\n        if (xx^x) < x:\n            x^=xx\n            ans^=idx[j]\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)!=0:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))","output":"np"},{"instruction":"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return nums[len(nums) - k]\n","output":"nlogn"},{"instruction":"n = int(input(\"\"))\nif n==1 or n==2:\n    print(n)\nelif n&1:\n    print((n)*(n-1)*(n-2))\nelse:\n    if n%3==0:\n        print((n-2)*(n-1)*(n-3))\n    else :\n         print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))\/2))","output":"constant"},{"instruction":"s = input()\nwhile s!=\"\":\n\tif s==s[::-1]:\n\t\ts=s[:(len(s)-1)]\n\telse:\n\t\tbreak\nprint(len(s))","output":"linear"},{"instruction":"from queue import Queue\nn = int(input())\ng = [set() for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    g[u].add(v)\n    g[v].add(u)\n\na = list(map(int, input().split()))\nif a[0] != 1:\n    print(\"No\")\n    exit()\nptr = 0\ni = 1\n\nwhile i < n:\n    par = a[ptr]\n    while len(g[par]) != 0:\n        if a[i] not in g[par]:\n            print(\"No\")\n            exit()\n        else:\n            g[par].remove(a[i])\n            g[a[i]].remove(par)\n        i += 1\n    ptr += 1\nprint(\"Yes\")","output":"quadratic"},{"instruction":"import sys\n\nnext(sys.stdin)\n\npositions = {}\npos2x = {}\nfor i, x in enumerate(next(sys.stdin).split()):\n    x = int(x)\n    positions[x] = i\n    pos2x[i] = x\n\nanswers = ['' for _ in range(len(positions))]\n\nfor x in range(len(positions), 0, -1):\n\n    position = positions[x]\n\n    def can_go_to_looser():\n\n        next_position = position + x\n        while next_position < len(positions):\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position += x\n\n        next_position = position - x\n        while next_position >= 0:\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position -= x\n\n        return False\n\n    if can_go_to_looser():\n        answers[position] = \"A\"\n    else:\n        answers[position] = \"B\"\n\nprint(''.join(answers))","output":"nlogn"},{"instruction":"n,queries = list(map(int,input().split()))\nl = list(map(int,input().split()))\nif(queries==0):\n\texit()\nmaxval = max(l)\npairs = []\ncount = 0\nf = l[0]\nsecix = 1\nwhile(f!=maxval):\n\n\tcount+=1\n\tf = l[0]\n\ts = l[secix]\n\tpairs.append([f,s])\n\tf,s= max(f,s), min(f,s)\n\tl[0] = f\n\tl.append(s)\n\tsecix+=1\n\nl = [l[0]]+l[secix:]\n\nfor i in range(n-1):\n\tpairs.append([maxval,l[1+i]])\n\nfor m in range(queries):\n\tq = int(input())\n\tif(q<=count):\n\t\tprint(str(pairs[q-1][0]),str(pairs[q-1][1]))\n\telse:\n\t\tq-=(count+1)\n\t\tpos = count+(q%(n-1))\n\t\tprint(str(pairs[pos][0]),str(pairs[pos][1]))","output":"linear"},{"instruction":"s = input()\nans = 2\ns1 = s[0:2]\ns2 = s[3:5]\ns3 = s[6:8]\ndef func(inp):\n    ans = 2\n    num = int(inp[0])\n    c = inp[1]\n    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))\n    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))\n    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))\n    ans = min( ans, 3 - s.count(inp))\n    return ans\nans = min(ans,func(s1))\nans = min(ans,func(s2))\nans = min(ans,func(s3))\nprint(ans)","output":"linear"},{"instruction":"n, m = map(int, input().split())\nans = m \/\/ n + min(1, m % n)\nprint(ans)","output":"constant"},{"instruction":"def main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    array = []\n    array.append(a)\n\n    for i in range(n - 1):\n        aux = []\n        for j in range(1, len(array[-1])):\n            xor = array[-1][j-1] ^ array[-1][j]\n            aux.append(xor)\n        array.append(aux)\n\n    for j in range(1, len(array)):\n        for k in range(len(array[j])):\n            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])\n            array[j][k] = maximo\n\n    q = int(input())\n    for i in range(q):\n        l, r = map(int, input().split(' '))\n        print(str(array[r - l][l - 1]))\n\nmain()","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nc = n + k\np = int(0.5 * ((8 * c + 9) ** 0.5 - 3))\nprint(n - p)","output":"constant"},{"instruction":"n, k = map(int, input().split())\nc = 1\nwhile c * (c + 1) \/\/ 2 < k:\n    c += 1\nwhile c * (c + 1) \/\/ 2 - (n - c) != k:\n    c += 1\nprint(n - c)","output":"linear"},{"instruction":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nsz = []\nt = [1] * 11\n\ncnt = dict()\nfor i in range(n):\n    sz.append(len(str(a[i])))\n    tmp = (sz[i], a[i] % k)\n    if tmp in cnt:\n        cnt[tmp] += 1\n    else:\n        cnt[tmp] = 1\n\nt[0] = 1\nfor i in range(1, 11):\n    t[i] = (t[i - 1] * 10) % k\n\nans = 0\nfor i in range(n):\n    for l in range(1, 11):\n        cur = (k - a[i] * t[l]) % k\n        tmp = (l, cur)\n        if tmp in cnt:\n            ans += cnt[tmp]\n        if (sz[i] == l and cur == a[i] % k):\n            ans -= 1\nprint(ans)","output":"nlogn"},{"instruction":"import math\nn,k=map(int,input().split())\nedges=[]\nfor i in range(n-1):\n    edges.append(tuple(map(int,input().split())))\ndegreelist=[]\nfor i in range(min(k+1,math.floor(math.log2(n))+10)):\n    degreelist.append({})\ndegrees=degreelist[0]\nfor i in range(1,n+1):\n    degrees[i]=0\nfor guy in edges:\n    degrees[guy[0]]+=1\n    degrees[guy[1]]+=1\nsmall=[]\ncenter=None\ndone=False\nfor i in range(k):\n    if not done:\n        small=[]\n        for guy in degrees:\n            if degrees[guy]==2:\n                print(\"No\")\n                done=True\n                break\n            if degrees[guy]==3:\n                small.append(guy)\n                if center==None:\n                    center=guy\n                elif center!=guy:\n                    print(\"No\")\n                    done=True\n                    break\n            elif degrees[guy]>1:\n                small.append(guy)\n        degrees=degreelist[i+1]\n        if center!=None and center not in small:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        elif len(small)==0:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        for guy in small:\n            degrees[guy]=0\n        for guy in edges:\n            if guy[0] in degrees and guy[1] in degrees:\n                degrees[guy[0]]+=1\n                degrees[guy[1]]+=1\n        for guy in degrees:\n            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:\n                if not done:\n                    print(\"No\")\n                done=True\n                break\n    else:\n        break\nif not done:\n    if len(degreelist[-1])==1:\n        print(\"Yes\")\n    else:\n        print(\"No\")","output":"linear"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        if r==self.size:\n            r = self.num\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nN,K = mi()\nS = input()\nS = [ord(S[i])-ord(\"a\") for i in range(N)]\n\npow_2 = [pow(2,i) for i in range(K)]\nk = K\n\ndef cond(n):\n    cnt = [0 for i in range(k)]\n    v = 0\n    for i in range(n):\n        if not  0<= S[i] < k:\n            continue\n        if cnt[S[i]]==0:\n            v += 1\n        cnt[S[i]] += 1\n\n    str_range = [[N for j in range(N)] for i in range(k)]\n    if v==1:\n        for i in range(k):\n            if cnt[i]:\n                str_range[i][0] = 0\n    elif v==0:\n        for i in range(k):\n            str_range[i][0] = 0\n\n    for i in range(n,N):\n        if 0 <= S[i-n] < k:\n            cnt[S[i-n]] -= 1\n            if cnt[S[i-n]] == 0:\n                v -= 1\n        if 0 <= S[i] < k:\n            cnt[S[i]] += 1\n            if cnt[S[i]] == 1:\n                v += 1\n\n        if v==1:\n            for j in range(k):\n                if cnt[j]:\n                    for l in range(i-n+1,-1,-1):\n                        if str_range[j][l] == N:\n                            str_range[j][l] = i - n + 1\n                        else:\n                            break\n                    break\n        elif v==0:\n            for j in range(k):\n                for l in range(i-n+1,-1,-1):\n                    if str_range[j][l] == N:\n                        str_range[j][l] = i - n + 1\n                    else:\n                        break\n\n    INF = N + 1\n    dp = [INF for bit in range(1<<k)]\n    dp[0] = 0\n\n    for bit in range(1<<k):\n        if dp[bit]>=N:\n            continue\n        idx = dp[bit]\n        for i in range(k):\n            if not bit >> i & 1:\n                nv = bit|pow_2[i]\n                tmp = str_range[i][idx] + n\n                dp[nv] = min(dp[nv],tmp)\n\n    return dp[-1]!=INF\n\nok = 0\nng = N+1\nwhile ng-ok>1:\n    mid = (ok+ng)\/\/2\n    if cond(mid):\n        ok = mid\n    else:\n        ng = mid\n\nprint(ok)","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\n\na.sort()\nans = 0\nwhile a:\n\tm = a[0]\n\tb = []\n\tfor x in a[1:]:\n\t\tif x % m != 0:\n\t\t\tb.append(x)\n\ta = b\n\tans += 1\nprint(ans)","output":"quadratic"},{"instruction":"n = int(input())\n\nm = input()\n\ns = list(m)\n\nif n==1:\n    ans = s[0]\nelse:\n    count = 0\n    for i in range(0,n):\n        if s[i]=='0':\n            count = count + 1\n    ans = '1'\n    for i in range(0,count):\n        ans = ans + '0'\n\nprint(ans)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd\nfor t in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l1=dd(int)\n    a=0\n    for j in l:\n        l1[j]+=1\n        if l1[j]==4:\n            a=j\n    if a:\n        print(a,a,a,a)\n    else:\n        c=0\n        x=0\n        l2=[]\n        for j in l1:\n            if l1[j]>=2:\n                l2.append(j)\n        l2.sort()\n        for j in l2:\n                c+=1\n                if c==1:\n                    a=j\n                elif c==2:\n                    b=j\n                else:\n                    if x\/j+j\/x<a\/b+b\/a:\n                        a,b=x,j\n                x=j\n        print(a,a,b,b)","output":"nlogn"},{"instruction":"n,k = map(int,input().split(\" \"))\ndegrees = [0] * n\nneighbors = [list() for x in range(n)]\nfor i in range(n-1):\n\tfirst,second = map(int,input().split(\" \"))\n\tdegrees[first-1] += 1\n\tdegrees[second-1] += 1\n\tneighbors[first-1] += [second]\n\tneighbors[second-1] += [first]\n\ncurr = 0\nfor i in range(n):\n\tif degrees[i] == 1:\n\t\tcurr = i+1\n\t\tbreak\nif curr == 0 or len(neighbors[curr-1]) == 0:\n\tprint(\"No\")\n\texit()\ncurr = neighbors[curr-1][0]\n\ndef check(prev,parent,curr,level,degrees,neighbors,k):\n\n\tif level == 0:\n\t\treturn len(parent) == 1 and degrees[curr-1] == 1,[]\n\tchecked = []\n\tfor neighbor in neighbors[curr-1]:\n\n\t\tif len(prev) != 0 and prev[0] == neighbor:\n\t\t\tchecked += [neighbor]\n\t\t\tcontinue\n\t\tif len(parent) != 0 and parent[0] == neighbor:\n\t\t\tcontinue\n\t\tresult,garbage = check([],[curr],neighbor,level-1,degrees,neighbors,k)\n\t\tif result:\n\t\t\tchecked += [neighbor]\n\t\telse:\n\n\t\t\tif len(parent) == 0:\n\t\t\t\tparent += [neighbor]\n\t\t\telse:\n\t\t\t\treturn False,[]\n\tif len(checked) > 2 and len(parent) == 0 and level == k:\n\n\t\treturn True,[]\n\telif len(checked) > 2 and len(parent) == 1 and level != k:\n\n\t\treturn True,parent\n\telse:\n\n\t\treturn False,[]\n\nprev = []\nparent = []\ncounter = 1\nwhile(counter <= k):\n\tresult,parent = check(prev,[],curr,counter,degrees,neighbors,k)\n\tif not(result):\n\t\tprint(\"No\")\n\t\texit()\n\tif counter == k:\n\t\tprint(\"Yes\")\n\t\texit()\n\tprev = [curr]\n\tcurr = parent[0]\n\tcounter += 1","output":"nlogn"},{"instruction":"def solve(n, k, v):\n    if(n >= 50):\n        print(\"YES \" + str(n - 1))\n        return\n    critical = 1\n    excess = 0\n    while(n > 0):\n\n        if(excess >= k):\n            print(\"YES \" + str(n))\n            return\n        if(critical > k):\n            print(\"NO\")\n            return\n        k -= critical\n        n -= 1\n        excess += (critical * 2 - 1) * v[n]\n        critical = (critical * 2 + 1)\n\n    if(excess >= k):\n        print(\"YES \" + str(n))\n        return\n    print(\"NO\")\n\nv = [0, 1]\n\nfor i in range(50):\n    a = 1 + 4 * v[-1]\n    v.append(a)\n\nt = int(input())\n\nfor tcase in range(t):\n    inputs = [int(x) for x in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    solve(n, k, v)","output":"logn"},{"instruction":"n=int(input())\nns=[]\nfor i in range(n):\n    s=input()\n    ns.append(s)\nns2=[]\nfor i in range(n):\n    s=input()\n    ns2.append(s)\n\ndef rotate(i,j):\n    return j,n-1-i\ndef flip(i,j):\n    return j,i\n\ndef main():\n    same=True\n    for i in range(n):\n        for j in range(n):\n            if ns[i][j]!=ns2[i][j]:\n                same=False\n                break\n        if same==False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            a, b = rotate(a, b)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            a, b = rotate(a, b)\n            a, b = rotate(a, b)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a,b=flip(i,j)\n            if ns[a][b]!=ns2[i][j]:\n                same=False\n                break\n        if same==False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            a, b = flip(a, b)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            a, b = rotate(a, b)\n            a, b = flip(a, b)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n\n    same=True\n    for i in range(n):\n        for j in range(n):\n            a, b = rotate(i, j)\n            a, b = rotate(a, b)\n            a, b = rotate(a, b)\n            a, b = flip(a, b)\n            if ns[i][j] != ns2[a][b]:\n                same = False\n                break\n        if same == False:\n            break\n    if same:\n        return True\n    else:\n        return False\n\nif main():\n    print('Yes')\nelse:\n    print('No')","output":"quadratic"},{"instruction":"n, k = [int(x) for x in input().split()]\n\nps = [int(x) for x in input().split()]\n\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n\n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))","output":"quadratic"},{"instruction":"n,c = map(int,input().split(\" \"))\nnums = list(map(int,input().split(\" \")))\n\ncPast = 0\ncountC = 0\n\nfor value in nums:\n\tif value == c:\n\t\tcountC += 1\n\ndef sawC(groupsList):\n\tfor key,groups in groupsList.items():\n\t\tif groups[-1] < 0:\n\t\t\tgroups[-1] -= 1\n\t\telse:\n\t\t\tgroups += [-1]\n\treturn groupsList\n\nsolution = countC\n\ngroupsList = {}\nfor num in nums:\n\tif num == c:\n\t\tgroupsList = sawC(groupsList)\n\telif num in groupsList.keys():\n\t\tif groupsList[num][-1] > 0:\n\t\t\tgroupsList[num][-1] += 1\n\t\telse:\n\t\t\tgroupsList[num] += [1]\n\telse:\n\t\tgroupsList[num] = [1]\n\nfor key,groups in groupsList.items():\n\n\tmaxDiff = 1\n\tcurrDiff = 0\n\tnewDiff = 0\n\tfor group in groups:\n\t\tcurrDiff += group\n\t\tif group > currDiff:\n\t\t\tcurrDiff = group\n\t\tif currDiff > maxDiff:\n\t\t\tmaxDiff = currDiff\n\tif maxDiff + countC > solution:\n\t\tsolution = countC + maxDiff\nprint(solution)","output":"linear"},{"instruction":"import io, os, sys\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef read():\n    n, m, k = map(int, input().split() )\n\n    h = [list(map(int, input().split() ) )+ [float(\"+inf\")] for _ in range(n)]\n\n    v = [list(map(int, input().split() ) ) for _ in range(n-1)]\n    v.append( [float(\"+inf\")] * m )\n\n    solve(n, m, k, h, v)\n\ndef solve(n, m, k, h, v):\n    if k % 2:\n        ans = \"-1 \" * m\n        for _ in range(n):\n            print(ans)\n        return\n\n    dp = [ [0] * (m+1) for _ in range(n+1)]\n\n    nxt = [ [0] * (m+1) for  _ in range(n+1)]\n\n    for _ in range(2, k + 1, 2):\n\n        for i in range(n):\n            for j in range(m):\n                l = 2 * h[i][j-1] + dp[i][j-1]\n                r = 2 * h[i][j]  + dp[i][j+1]\n                u = 2 * v[i-1][j] + dp[i-1][j]\n                d = 2 * v[i][j]  + dp[i+1][j]\n\n                hor = min(l, r)\n                ver = min(u, d)\n\n                nxt[i][j] = min(hor, ver)\n\n        dp, nxt = nxt, dp\n\n    for l in dp[:-1]:\n        print(\" \".join(map(str, l[:-1])))\n\nif __name__ == \"__main__\":\n    read()","output":"cubic"},{"instruction":"a,b = map(int,input().split())\nans = 0\nif(a > b):\n    ans += int(a\/\/b)\n    a = a%b\nwhile(b!=0):\n    ans += int(a\/\/b)\n    a,b = b,a%b\nprint(ans)","output":"constant"},{"instruction":"l,r=map(int,input().split(' '))\n\ndef gcd(a ,b):\n    if(b==0):return a\n    return gcd(b,a%b)\n\nfor a in range(l,r+1):\n    for b in range(a+1,r+1):\n        for c in range(b+1,r+1):\n            if(gcd(a,b)==1 and gcd(b,c)==1 and gcd(a,c)!=1):\n                print(a,b,c)\n                exit()\n\nprint(-1)","output":"constant"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn,m=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nl=-1;r=10**9+1\nans1,ans2=-1,-1\nwhile r-l>1:\n    x=(l+r)\/\/2\n    idx={}\n    for i in range(n):\n        v=0\n        for j in range(m):\n            if a[i][j]>=x:\n                v+=1\n            v<<=1\n        idx[v>>1]=i\n    ok=False\n    idx1,idx2=0,0\n    for aa,bb in idx.items():\n        for cc,dd in idx.items():\n            for d in range(m):\n                if (aa|cc)==(2**m)-1:\n                    ok=True\n                    idx1=bb+1\n                    idx2=dd+1\n    if ok:\n        l=x\n        ans1=idx1\n        ans2=idx2\n    else:\n        r=x\nprint(ans1,ans2)","output":"np"},{"instruction":"n = int(input())\npokemons = input()\n\nlast = {}\nstart_of_all = 0\nfor i in range(n):\n    ty = pokemons[i]\n    if ty not in last:\n        start_of_all = i\n    last[ty] = 0\n\nminlen = 100001\nfor i in range(n):\n    ty = pokemons[i]\n    last[ty] = i\n    length = i + 1 - min(last.values())\n    if i >= start_of_all and length < minlen:\n        minlen = length\n\nprint(minlen)","output":"linear"},{"instruction":"n, k = [int(x) for x in input().split()]\nps = [int(x) for x in input().split()]\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))","output":"quadratic"},{"instruction":"k = int(input())\nn = 0\ni = 0\nwhile (k > n):\n    n += pow(10, i) * 9 * (i + 1)\n    i = i + 1\nn -= pow(10, i - 1) * 9 * i\nk -= n\nt = (k - 1) \/ i\nr = k % i\nif (r == 0):\n    r = i\nm = pow(10, i - 1) + t\nm = int(m)\nans = int(m \/ pow(10,i - r)) % 10\nprint(ans)\n\ndef pow(i):\n    n = 1\n    for x in range(0,i):\n        n*=10\n    return n","output":"logn"},{"instruction":"from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    l=sorted(zip(lst(),range(n)))\n    p=0;ans=[0]*(2*n)\n    st=[0]*n;ln=0\n    s=input()\n    for i in range(2*n):\n        ch=s[i]\n        if ch=='0':\n            st[ln]=p\n            ans[i]=l[p][1]+1\n            ln+=1\n            p+=1\n        else:\n            ans[i]=l[st[ln-1]][1]+1\n            ln-=1\n    print(*ans)","output":"nlogn"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nQ, = getIntList()\nfor _ in range(Q):\n    N, M, K  = getIntList()\n    if max(N,M) >K:\n        print(-1)\n        continue\n    r = K\n    if N%2!= K%2:\n        r-=1\n    if M%2!= K%2:\n        r-=1\n    print(r)","output":"constant"},{"instruction":"n = int(input())\nsum = 0\n\nfor i in range(2, n + 1):\n  j = 2\n  while(j * i <= n):\n    sum += i\n    j += 1\nprint(4 * sum)","output":"linear"},{"instruction":"n = int(input())\nprint(3*(n\/\/2))","output":"constant"},{"instruction":"import sys as _sys\n\n_sys.setrecursionlimit(2**14)\n\n_cache = dict()\n\nclass _SortedSeqs:\n\n    def __init__(self, seqs):\n        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)\n\n    def __hash__(self):\n        return id(self)\n\ndef compute_max_area(r_seq, g_seq, b_seq):\n    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))\n    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))\n    return _compute_max_area(sorted_seqs_obj, seqs_sizes)\n\ndef _compute_max_area(sorted_seqs_obj, seqs_sizes):\n    cache_key = (sorted_seqs_obj, seqs_sizes)\n    if cache_key in _cache.keys():\n        return _cache[cache_key]\n\n    seqs = sorted_seqs_obj.seqs\n    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)\n\n    if nonempty_seqs_n < 2:\n        ab_seqs_indices_list = []\n\n    elif nonempty_seqs_n == 2:\n        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]\n        ab_seqs_indices_list = [ab_seqs_indices]\n\n    else:\n        assert nonempty_seqs_n == 3\n        seqs_indices_sorted_by_size = [\n            i for i, seq in sorted(\n                enumerate(seqs),\n                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])\n            )\n        ]\n        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]\n        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]\n        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]\n\n    max_areas_variants = []\n    for a_seq_index, b_seq_index in ab_seqs_indices_list:\n        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]\n        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]\n        new_seqs_sizes = list(seqs_sizes)\n        new_seqs_sizes[a_seq_index] -= 1\n        new_seqs_sizes[b_seq_index] -= 1\n        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))\n        max_area += a_seq_last * b_seq_last\n        max_areas_variants.append(max_area)\n\n    max_area = max(max_areas_variants, default=0)\n\n    _cache[cache_key] = max_area\n    return max_area\n\ndef _how_many_nonempty(seqs_sizes):\n    return len([size for size in seqs_sizes if size > 0])\n\ndef main():\n    r_n, g_n, b_n = map(int, input().split())\n    r_seq = tuple(map(int, input().split()))\n    g_seq = tuple(map(int, input().split()))\n    b_seq = tuple(map(int, input().split()))\n    result = compute_max_area(r_seq, g_seq, b_seq)\n    print(result)\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"f = lambda c: 'mps'.index(c)\nl = [[], [], []]\nfor c in input().split():\n    a, b = c\n    l[f(b)].append(int(a))\nfor i in range(3):\n    l[i].sort()\n\nres = 3\nfor x in l:\n    if len(x) == 0: continue\n    elif len(x) == 1: res = min(res, 2)\n    elif len(x) == 3:\n        if len(set(x)) == 1:\n            res = min(res, 0)\n            break\n        if x[0] == x[1] - 1 and x[1] == x[2] - 1:\n            res = min(res, 0)\n            break\n    res = min(res, 2)\n    for i in range(len(x)):\n        for j in range(i + 1, len(x)):\n            if abs(x[i] - x[j]) <= 2:\n                res = min(res, 1)\nprint(res)","output":"nlogn"},{"instruction":"n = int(input())\na = [int(s) for s in input().split()]\nos = 0\noss = []\nnos = 0\nnos_0 = -1\nnos_1 = -1\nsumnos = 0\nfor i in range(n):\n    if a[i] == 1:\n        os += 1\n        oss.append(i+1)\n    else:\n        sumnos += a[i]\n        nos += 1\n        if nos_0 == -1:\n            nos_0 = i+1\n        nos_1 = i+1\n\nif os <= sumnos-(2*(nos-1)):\n    es = []\n    oss_i = 0\n    ans = nos-1\n    if os >= 1:\n        ans += 1\n        es.append((nos_0, oss[0]))\n        oss_i += 1\n    if os >= 2:\n        ans += 1\n        es.append((nos_1, oss[1]))\n        oss_i += 1\n    print(\"YES\", ans)\n    prev_nos = -1\n    for i in range(n):\n        if a[i] > 1:\n            if prev_nos != -1:\n                es.append((prev_nos+1, i+1))\n            for j in range(a[i]-2):\n                if oss_i >= os:\n                    break\n                es.append((i+1, oss[oss_i]))\n                oss_i += 1\n            prev_nos = i\n    print(len(es))\n    for e in es:\n        print(*e)\nelse:\n    print(\"NO\")","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nn,q=map(int,input().split())\nA=deque(map(int,input().split()))\nQ=[int(input()) for i in range(q)]\n\nANS=[0]\n\nfor l in range(10**5+1):\n    x=A.popleft()\n    y=A.popleft()\n\n    ANS.append((x,y))\n\n    if x>y:\n        A.appendleft(x)\n        A.append(y)\n    else:\n        A.appendleft(y)\n        A.append(x)\n\nANS0=A[0]\nB=list(A)[1:]\n\nfor q in Q:\n    if q<=10**5+1:\n        print(*ANS[q])\n    else:\n        print(ANS0,B[(q-10**5-2)%(n-1)])","output":"linear"},{"instruction":"mod = 1000000007\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod\n    print(ans)","output":"logn"},{"instruction":"n=input()\nn1=int(n)\nc=[]\nfor i in range(0,n1):\n    z4=0\n    p,q=input().split()\n    a=int(p)\n    b=int(q)\n    while a!=0 and b!=0:\n        z1=z3=0\n        if a<=b:\n          z=(b\/a)\n          z1=int(z)\n          b=b-(z1*a)\n        if b<=a and b!=0:\n          z2=a\/b\n          z3=int(z2)\n          a=a-(z3*b)\n        z4=z4+z1+z3\n    c.append(z4)\nl=len(c)\nfor j in range(0,l):\n    print(c[j])","output":"constant"},{"instruction":"from collections import defaultdict\nfrom math import gcd\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = defaultdict(lambda: float(\"inf\"))\nfor a, b in zip(A, B):\n    dp[a] = min(dp[a], b)\n    for d in dp.copy():\n        cur = gcd(a, d)\n        dp[cur] = min(dp[cur], dp[a] + dp[d])\nif 1 not in dp:\n    print(-1)\nelse:\n    print(dp[1])","output":"np"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\ndef main():\n    n = rint()\n    a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n))\n    for i in range(4):\n        if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]:\n            exit(print('Yes'))\n    print('No')\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n            if id != None:\n                for i in range(r):\n                    self.mat[i][i] = 1\n\n    def __add__(self, other):\n        mat0 = Matrix(self.r, self.c)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n\n        return mat0\n\n    def __mul__(self, other):\n        mat0 = Matrix(self.r, other.c)\n\n        for i in range(self.r):\n            for j in range(other.c):\n                for k in range(self.c):\n                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n\n        return mat0\n\n    def dot_mul(self, other):\n        res = 0\n        for i in range(self.r):\n            for j in range(self.c):\n                res += self.mat[i][j] * other.mat[j][i]\n\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.r):\n            res += self.mat[i][i]\n\n        return res\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def mat_pow(self, mat, p, mod=None):\n        sq = Matrix(mat.r, mat.r, id=1)\n\n        while p:\n            if p & 1:\n                p -= 1\n                sq = sq * mat\n\n            p \/\/= 2\n            mat = mat * mat\n\n        return sq.mat\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from collections import Counter as C\nn, m = map(int, input().split())\nl = [*map(int, input().split())]\nc = sorted(C(l).items())\n\nres = 0\nj = 0\nfor hi, ni in c:\n\n    h = min(hi - j, ni) + j\n    res += (hi - 1) * ni\n    if h > j:\n        j = h\nm = max(l)\nif j < m:\n    res -= m - j\nprint(res)","output":"nlogn"},{"instruction":"def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M\/\/i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n\/\/i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n\/\/=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res\/\/x * (x-1)\n            while n%x==0:\n                n \/\/= x\n    if n!=1:\n        res = res\/\/n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n\/\/=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d \/\/ (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() \/\/ 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n \/\/= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n \/\/= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m\/\/=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\nP = permutations([i for i in range(4)])\nplus = [(0,0),(0,n),(n,0),(n,n)]\n\nA = []\nfor i in range(4):\n    tmp = [input() for i in range(n)]\n    if i!=3:\n        _ = input()\n    A.append(tmp)\n\ntmp = [[0 for i in range(2*n)] for j in range(2*n)]\nres = 10**17\nfor p in P:\n    for k in range(4):\n        x,y = plus[p[k]]\n        for i in range(n):\n            for j in range(n):\n                tmp[i+x][j+y] = int(A[k][i][j])\n\n    ans_1 = 0\n    ans_2 = 0\n    for i in range(2*n):\n        for j in range(2*n):\n            if tmp[i][j]==(i+j)%2:\n                ans_1 += 1\n            else:\n                ans_2 += 1\n\n    res = min(res,ans_1,ans_2)\n\nprint(res)","output":"quadratic"},{"instruction":"n = int(input())\nax,ay = list(map(int,input().split()))\nbx,by = list(map(int,input().split()))\ncx,cy = list(map(int,input().split()))\n\nif (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"n=int(input())\na,b=map(int,input().split())\nwhite=abs(a-1)+abs(b-1)\nblack=abs(n-a)+abs(n-b)\nif white<=black:\n    print(\"White\")\nelse:\n    print(\"Black\")","output":"constant"},{"instruction":"z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2\/\/gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n\n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\nl=z()\nn=len(l)\nans=0\nfor i in range(n):\n\n    for j in range(i+1,n+1):\n        p=l[i:j]\n        t=len(p)\n        x=0\n\n        for k in range( n):\n            if l[k:k+t]==p:\n                x+=1\n        if x>=2:\n            ans=max(ans,t)\nprint(ans)","output":"cubic"},{"instruction":"input()\nprint(25)","output":"constant"},{"instruction":"import sys\n\nclass APaintTheNumbers:\n    def solve(self):\n        n = int(input())\n        a = [int(_) for _ in input().split()]\n        a.sort()\n        ans = 0\n        done = [0] * n\n        for i in range(n):\n            if done[i]: continue\n            ans += 1\n            for j in range(i, n):\n                if done[j]: continue\n                if a[j] % a[i] == 0:\n                    done[j] = 1\n\n        print(ans)\n\nsolver = APaintTheNumbers()\ninput = sys.stdin.readline\n\nsolver.solve()","output":"quadratic"},{"instruction":"import math\n\nno_of_moves , no_of_candy = map(int,input().split())\n\ntotal_candy = now_candy = 1\nnow_moves = 1\n\nif(no_of_moves == 0 or (no_of_moves ==1 and no_of_candy == 1)):\n    print(0)\nelse:\n    while True:\n\n        now_candy = now_candy + 1\n        total_candy += now_candy\n        now_moves += 1\n        if(total_candy -(no_of_moves - now_moves) == no_of_candy):\n            break\n\n    print(no_of_moves - now_moves)","output":"logn"},{"instruction":"import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nn, k = map(int,input().split())\ns = input()\n\nmaxconseq = [[0 for j in range(k)] for i in range(n+1)]\nfor i in range(n):\n    if s[i]==ord('?'):\n        for j in range(k):\n            maxconseq[i][j] = maxconseq[i-1][j] + 1\n    else:\n        j = s[i]-97\n        maxconseq[i][j] = maxconseq[i-1][j] + 1\n\ndef judge(needed):\n\n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n\n    effect = [[inf]*(n+1) for j in range(k)]\n\n    for j in range(k):\n        for i in range(n)[::-1]:\n            if maxconseq[i][j]>=needed:\n                effect[j][i-needed+1] = i+1\n            effect[j][i] = min(effect[j][i], effect[j][i+1])\n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index])\n\n        minstate[state] = minimum\n\n    if minstate[-1]<=n:  return True\n    return False\n\nfront = 0\nrear = n\/\/k+1\n\nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n\n    if flag:\n        front = mid + 1\n    else:\n        rear = mid\n\nprint(front-1)","output":"np"},{"instruction":"import sys\nm,n = [int(i) for i in input().split(' ')]\nl = [[] for _ in range(m)]\nfor i in range(m):\n\tl[i] = input()\ninks = []\nfor i in range(1, m-1):\n\tfor j in range(1, n-1):\n\t\tif l[i-1][j-1] == '\n\t\t\t   inks += [(i-1,j-1),(i,j-1),(i+1,j-1),\n\t\t\t\t\t    (i-1,j  )        ,(i+1,j  ),\n\t\t\t\t\t\t(i-1,j+1),(i,j+1),(i+1,j+1),]\nfor i in range(m):\n\tfor j in range(n):\n\t\tif l[i][j] == '\n\t\t\tprint(\"NO\")\n\t\t\tsys.exit()\nelse:\n\tprint(\"YES\")","output":"quadratic"},{"instruction":"import sys\nimport threading\ninp = sys.stdin.buffer.readline\ninput = lambda: sys.stdin.readline().rstrip()\ndef I(): return list(map(int,inp().split()))\ndef main():\n    n,=I() ; vis=[0]*n ; st=[0]*n\n    if n==1:\n        print(1)\n        exit(0)\n    def dfs(g,e):\n        if vis[e]==1: return\n        else:\n            vis[e]=1\n            for i in g[e]:\n                dfs(g,i)\n            if len(g[e])==1 and e!=0: st[e]+=1\n            for i in g[e]:\n                st[e]+=st[i]\n    a=[int(i)-1 for i in input().split()]\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        g[i+1].append(a[i])\n        g[a[i]].append(i+1)\n    dfs(g,0)\n    st.sort()\n    print(*st)\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()","output":"quadratic"},{"instruction":"def ints():\n return list(map(int,input().split()))\nn,k=ints()\na,t=ints(),ints()\nans=sum(a[ii] for ii in range(n) if t[ii])\nbb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]\nll=0\nrr=k\ntmp=sws=sum(bb[:k])\nwhile rr<n:\n sws-=bb[ll]\n sws+=bb[rr]\n ll+=1\n rr+=1\n tmp=max(tmp,sws)\nans+=tmp\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\ns = input()\nwant = len(set(s))\nd = {}\nj = 0\ncount = 0\nans = float(\"inf\")\nfor i in range(n):\n    if s[i] not in d:\n        d[s[i]] = 0\n        count+=1\n    d[s[i]]+=1\n    if count==want:\n        while d[s[j]]>1:\n            d[s[j]]-=1\n            j+=1\n        ans = min(ans,i-j+1)\nprint(ans)","output":"linear"},{"instruction":"from sys import stdin, stdout, exit\nimport math\n\nn, k = map(int, stdin.readline().split())\n\nans = round((-3 + math.sqrt(9 + 8*(k+n))) \/ 2)\nstdout.write(str(n-ans) + \"\\n\")","output":"constant"},{"instruction":"from os import path;import sys,time\nmod = int(1e9 + 7)\nfrom math import ceil, floor,gcd,log,log2 ,factorial,sqrt\nfrom collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations\nfrom string import ascii_lowercase ,ascii_uppercase\nfrom bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')\nI = lambda :int(sys.stdin.buffer.readline())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ngrid = lambda  r :[lint() for i in range(r)]\nlocalsys = 0\nstart_time = time.time()\n\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) \/\/ factorial(r)\ndef ceill(n,x):\n    return (n+x -1 )\/\/x\nT =0\n\ndef solve():\n\tarr = list(map(int , S()))\n\ts , cnt , ans = 0 , 0 ,0\n\tfor i in arr:\n\t\ts , cnt = s + i , cnt + 1\n\t\tif i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0:\n\t\t\ts , cnt,ans  =0 , 0 , ans + 1\n\tprint(ans)\n\ndef run():\n    if (path.exists('input.txt')):\n        sys.stdin=open('input.txt','r')\n        sys.stdout=open('output.txt','w')\n\nrun()\nT = I() if T else 1\nfor _ in range(T):\n    solve()\n\nif localsys:\n    print(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","output":"linear"},{"instruction":"import sys\n\nn, q = map(int, input().split())\ntop = len(bin(n >> 1)) - 2\nans = [1] * q\n\nfor i in range(q):\n    v = int(input())\n    s = input()\n    if n == 1:\n        continue\n    for h in range(top+1):\n        if v & (1 << h):\n            break\n\n    for c in s:\n        if h == top and c == 'U' or h == 0 and c != 'U':\n            continue\n        if c == 'U':\n            v -= 1 << h\n            h += 1\n            v |= 1 << h\n        elif c == 'L':\n            v -= 1 << h\n            h -= 1\n            v |= 1 << h\n        else:\n            h -= 1\n            v |= 1 << h\n    ans[i] = v\n\nprint(*ans, sep='\\n')","output":"np"},{"instruction":"q=int(input())\n\nQ=[list(map(int,input().split())) for i in range(q)]\n\nfor n,m,k in Q:\n    if n>k or m>k:\n        print(-1)\n        continue\n\n    x=max(n,m)-min(n,m)\n    y=k-max(n,m)\n\n    if x%2==0 and y%2==0:\n        print(k)\n    elif x%2==0 and y%2==1:\n        print(k-2)\n    elif x%2==1 and y%2==0:\n        print(k-1)\n    elif x%2==1 and y%2==1:\n        print(k-1)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn,T=map(int,input().split())\nS=[list(map(int,input().split())) for i in range(n)]\n\nDP=[[0]*(4) for i in range(T+1)]\nmod=10**9+7\n\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef calc(used,recent,time):\n    ANS=0\n    for i in range(n):\n\n        if i in used:\n            continue\n        if time+S[i][0]>T:\n            continue\n        if S[i][1]==recent:\n            continue\n        if time+S[i][0]==T:\n            ANS+=1\n        if time+S[i][0]<T:\n            used2=list(used)+[i]\n            used2.sort()\n            recent2=S[i][1]\n            time2=time+S[i][0]\n            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod\n\n    return ANS\n\nprint(calc(tuple(),-1,0)%mod)","output":"np"},{"instruction":"import collections\n\nn = int(input())\na = [0, 0] + list(map(int, input().split()))\n\nG = collections.defaultdict(list)\nfor i in range(2, len(a)):\n    G[a[i]].append(i)\n\nnodes = []\nq = collections.deque([1])\nwhile q:\n    node = q.popleft()\n    nodes.append(node)\n    for v in G[node]:\n        q.append(v)\n\nnodes.reverse()\n\ndp = {}\nfor u in nodes:\n    count = 0\n    if len(G[u]) == 0: count += 1\n    for v in G[u]:\n        count += dp[v]\n    dp[u] = count\n\nres = sorted(dp.values())\nprint(' '.join(map(str, res)))","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nxs = [int(k) for k in input().split()]\nts = [int(k) for k in input().split()]\npos = [-1 for i in range(n + m)]\nif ts[0]:\n    pos[0] = 0\nfor i in range(1, n + m):\n    pos[i] = pos[i - 1]\n    if ts[i]:\n        pos[i] += 1\nresult = [0 for i in range(m)]\nleft = 0\nleftC = 0\nright = 0\nrightC = 0\nfor i in range(n + m):\n    if ts[i] == 0:\n        right = max(i, right)\n        while right + 1 < n + m and not ts[right]:\n            right += 1\n        mP, mD = 0, 20000000\n        if ts[left]:\n            mP = pos[left]\n            mD = xs[i] - xs[left]\n        if ts[right] and xs[right] - xs[i] < mD:\n            mD = xs[right] - xs[i]\n            mP = pos[right]\n        result[mP] += 1\n    else:\n        left = i\nprint(*result)","output":"linear"},{"instruction":"class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                res += 1\n                l -= 1\n                r += 1\n\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                res += 1\n                l -= 1\n                r += 1\n\n        return res","output":"quadratic"},{"instruction":"from collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef main():\n\n    n = int(nextline())\n    a = ints()\n    bs = set()\n    moves = {}\n    for i in range(n):\n        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])\n    winners = {}\n    for i in range(n, 0, -1):\n        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'\n        if winner == 'B':\n            bs.add(i)\n        winners[i] = winner\n    print(''.join(winners[ai] for ai in a))\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nf = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\ndef g(fi, se, p):\n    q = []\n    for x in p:\n        if f(fi, se, x):\n            if len(q) < 2:\n                q.append(x)\n            else:\n                if f(q[0], q[1], x):\n                    return 1\n    return 0\nprint('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')","output":"nlogn"},{"instruction":"def maxXORInRange(L, R):\n\n    LXR = L ^ R\n\n    msbPos = 0\n    while(LXR):\n\n        msbPos += 1\n        LXR >>= 1\n\n    maxXOR, two = 0, 1\n\n    while (msbPos):\n\n        maxXOR += two\n        two <<= 1\n        msbPos -= 1\n\n    return maxXOR\n\nL,R = map(int, input().split())\nprint(maxXORInRange(L, R))","output":"logn"},{"instruction":"n=int(input())\nif n==1 or n==2 :\n    print(n)\nelif n%2!=0 :\n    m=n*(n-1)*(n-2)\n    print(m)\nelif n%3!=0 :\n    m=n*(n-1)*(n-3)\n    print(m)\nelse :\n    m=(n-1)*(n-2)*(n-3)\n    print(m)","output":"constant"},{"instruction":"l1=l2=-1\nr1=r2=1<<30\nfor i in range(int(input())):\n l,r=map(int,input().split())\n if l>l1:il,l1,l2=i,l,l1\n elif l>l2:l2=l\n if r<r1:ir,r1,r2=i,r,r1\n elif r<r2:r2=r\nprint(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))","output":"linear"},{"instruction":"import math\ntemp=list(map(int,input().split()))\nN,q=temp[0],temp[1]\nfor j in range(0,q):\n    u=int(input())\n    S=input()\n    k=(N+1)\/\/2\n    n=int(math.log((N+1),10)\/math.log(2,10))-1\n    dup_n=n\n    store=[k]\n    while u!=k:\n        n-=1\n        if u>k:\n            k+=2**(n)\n        else:\n            k-=2**(n)\n        store.append(k)\n    for i in range(0,len(S)):\n        if S[i]=='R':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k+=2**(n)\n        elif S[i]=='L':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k-=2**(n)\n        else:\n            if n==dup_n:\n                continue\n            store.pop()\n            k=store[len(store)-1]\n            n+=1\n            continue\n        store.append(k)\n\n    print(k)","output":"np"},{"instruction":"import math\nn, r = [int(i) for i in input().split()]\n\nt = math.sin(math.pi\/n)\nres = r*t\/(1-t)\nprint(res)","output":"constant"},{"instruction":"n,m,k = map(int,input().split())\npi = list(map(int,input().split()))\nnum = 1\nans = 0\ni = 0\nwhile i < m:\n    temp = (pi[i] - num) \/\/ k\n    temp2 = i\n    i += 1\n    while i < m :\n        if temp != (pi[i] - num) \/\/ k:\n            break\n        i += 1\n    num += (i - temp2)\n    ans += 1\nprint(ans)","output":"linear"},{"instruction":"n,k=map(int,input().split())\nprint(-(-k\/\/n))","output":"constant"},{"instruction":"import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\ndef ria():\n    return [int(i) for i in input().split()]\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n\nelse:\n    sys.stdin = open('input.txt')\n\nn, m = ria()\nar = ria()\narc = []\nart = []\nres = []\nfor n, i in enumerate(ria()):\n    if i == 1:\n        art.append(ar[n])\n        res.append(0)\n    else:\n        arc.append(ar[n])\nnt = 0\nfor i in arc:\n    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):\n        nt += 1\n    res[nt] += 1\n\nfor i in res:\n    print(i,end= ' ')","output":"nlogn"},{"instruction":"def chk(n):\n    return int(n**0.5+0.1)**2 == n\nfor _ in range(int(input())):\n    n = int(input())\n    if n % 2 == 0 and chk(n\/\/2) or n % 4 == 0 and chk(n\/\/4):\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"constant"},{"instruction":"n=input()\nif int(n)>0:\n\tprint(n)\nelif -9<=int(n)<=0:\n\tprint(0)\nelse:\n\ta=(-int(n))\/\/10\n\tb=((-int(n))\/\/100)*10+int(n[-1])\n\tprint(max(-a,-b))","output":"constant"},{"instruction":"n, m, k = map(int, input().split())\n\na = list(map(int, input().split()))\n\nbest = 0\ndp = [0] * (n + 1)\nfor i in range(n):\n    b2 = 0\n    for j in range(max(-1, i - m), i + 1):\n        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))\n    dp[i] = max(b2, a[i] - k)\n    best = max(best, dp[i])\n\nprint(best)","output":"quadratic"},{"instruction":"k = int(input()) - 1\n\nl = 1\nc = 9\nwhile k >= c*l:\n    k -= c * l\n    l += 1\n    c *= 10\n\nc = 10**(l-1) + k \/\/ l\nprint(str(c)[k % l])","output":"constant"},{"instruction":"n,m=map(int,input().split())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nl1.sort()\nl2.sort()\nl2=l2[::-1]\nif n==1:\n    if l1[0]!=min(l2):\n        print(-1)\n    else :\n        print(sum(l2))\nelif max(l1)>min(l2):\n    print(-1)\nelse :\n    ans=0\n    l1=l1[::-1]\n    if min(l2)==l1[0]:\n        print(sum(l2) + (sum(l1)-l1[0])*m)\n    elif min(l2)!=l1[0]:\n        print(sum(l2)+l1[0]+sum(l1[1:])*m-l1[1])","output":"nlogn"},{"instruction":"from math import factorial,pow\nsend = input()\nreceived = input()\n\npos = 0\nfor p in send:\n\tpos = pos +1 if p=='+' else pos-1\nqcount = 0\ncurr_pos = 0\nfor p in received:\n\tif p=='+':\n\t\tcurr_pos = curr_pos +1\n\telif(p=='-'):\n\t\tcurr_pos = curr_pos-1\n\tif p=='?':\n\t\tqcount +=1\n\nif qcount == 0:\n\tprint(\"{:.12f}\".format(1.0 if pos==curr_pos else 0.0))\nelse:\n\texp_val_q = abs(pos -curr_pos)\n\tif exp_val_q%2!=qcount%2 or qcount<exp_val_q:\n\t\tprint(\"{:.12f}\".format(0.0))\n\telse:\n\t\tneg = (qcount - exp_val_q)\/2\n\t\tposi = qcount - neg\n\t\tval = factorial(qcount)\/(factorial(neg)*factorial(posi)*pow(2,qcount))\n\t\tprint(\"{:.12f}\".format(val))","output":"np"},{"instruction":"def solve(a, b):\n    m = len(a)\n    n = len(b)\n    p_b = [0]\n    for x in b[:]:\n        p_b.append(p_b[-1] + int(x))\n    s = 0\n    for i in range(m):\n        if a[i] == '0':\n            s += p_b[n - m + 1 + i] - p_b[i]\n        else:\n            s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i])\n    return s\n\na = input()\nb = input()\nprint(solve(a, b))","output":"linear"},{"instruction":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n\n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n\n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                return max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                return max(sell, cooldown)\n\n        return dfs(0, True)","output":"np"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\nc = 0\nfor i in range(n):\n    if a[i] > c:\n        print(i+1)\n        break\n    else:\n        c = max(a[i]+1, c)\nelse:\n    print(-1)","output":"linear"},{"instruction":"n = int(input())\nb = list(map(int, input().split()))\nff = []\nss = []\nfor i in  b[::-1]:\n    q = i\n    f = q \/\/ 2\n    if q % 2:\n        s = f + 1\n    else:\n        s = f\n    if len(ff) == 0:\n        ff = [f]\n        ss = [s]\n    else:\n        if f > ff[-1] or s < ss[-1]:\n            d = max(f - ff[-1], ss[-1] - s)\n            f -= d\n            s += d\n        ff.append(f)\n        ss.append(s)\nprint(*(ff[::-1] + ss))","output":"linear"},{"instruction":"import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    n=int(input())\n    s=list(input().strip())\n    t=list(input().strip())\n    res=True\n    ans=[]\n    for i in range(n):\n        if s[i]==t[i]:\n            continue\n        else:\n            ind=-1\n            for j in range(i+1,n):\n                if t[i]==s[j]:\n                    ind=j\n                    break\n            if ind==-1:\n                res=False\n                break\n            for j in range(ind-1,i-1,-1):\n                ans.append(j+1)\n                s[j],s[j+1]=s[j+1],s[j]\n    if res:\n        print(len(ans))\n        print(*ans)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n = int(input())\nprint((n*3)\/\/2)","output":"constant"},{"instruction":"n = int(input())\nl = list(map(int,input().split()))\nm = 0\nfor i in range(n):\n\tif l[i] >= 0:\n\t\tl[i] = -l[i] - 1\nfor i in range(n):\n\tif l[i] < 0 :\n\t\tm += 1\nif m % 2 == 0:\n\tfor i in range(n):\n\t\tprint(l[i], end = \" \")\nelse:\n\tmaksi = -1000000000000\n\tfor i in range(n):\n\t\tif abs(l[i]) > maksi:\n\t\t\tmaksi = abs(l[i])\n\t\t\tmk = i\n\tl[mk] = -l[mk] - 1\n\tfor i in range(n):\n\t\tprint(l[i], end = \" \")","output":"linear"},{"instruction":"import sys\nimport io, os\nimport math\nfrom heapq import *\ngcd = math.gcd\nsqrt = math.sqrt\nceil = math.ceil\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\ndef print(x, end):\n    sys.stdout.write(str(x) + end)\ndef strinp(testcases):\n    k = 5\n    if (testcases == -1 or testcases == 1):\n        k = 1\n    f = str(input())\n    f = f[2:len(f) - k]\n    return f\ndef ind(ch):\n    return ord(ch)-ord(\"a\")\ndef cleanarr(arr):\n    n = len(arr)\n\n    arr.sort()\n    c = []\n    curr=[arr[0], 1]\n    for i in range(n - 1):\n        if (arr[i] != arr[i + 1]):\n            if(curr[1]>=2):\n                c.append(curr)\n            curr=[arr[i+1],1]\n        else:\n            curr[1] += 1\n    if(curr[1]>=2):\n        c.append(curr)\n    return c\ndef main():\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        arr=list(map(int, input().split()))\n        g=arr[0]\n        c=cleanarr(arr)\n        if(n>=40000):\n            f=0\n            for i in range(len(c)):\n                if(c[i][1]>=4):\n                    f=c[i][0]\n                    break\n            print(f,\" \")\n            print(f,\" \")\n            print(f,\" \")\n            print(f,\"\\n\")\n            continue\n        mi=10**18\n        pair=[-1,-1]\n        for i in range(len(c)):\n            if(c[i][1]>=4):\n                pair=[c[i][0],c[i][0]]\n                break\n            if(i==len(c)-1):\n                break\n            a=c[i][0]\n            b=c[i+1][0]\n            if(mi==10**18):\n                pair=[a,b]\n                mi=0\n                continue\n            if ((((pair[0]+pair[1])**2)*a*b)-(((a+b)**2)*pair[0]*pair[1])>0):\n                pair=[a,b]\n        print(pair[0],\" \")\n        print(pair[0],\" \")\n        print(pair[1],\" \")\n        print(pair[1],\"\\n\")\nmain()","output":"nlogn"},{"instruction":"n = int(input())\nprint(n, 0, 0)","output":"constant"},{"instruction":"import sys\nn=int(input())\ns=input()\ns+=s\nh=0\nfor i in range(n):\n\tif s[i]=='H':\n\t\th+=1\nans=h\nfor i in range(n):\n\tc=0\n\tfor j in range(i,i+h):\n\t\tif s[j]=='T':\n\t\t\tc+=1\n\tans=min(ans,c)\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\n\nlst1 = []\nfor x in range(n):\n    lst1.append(input().split())\n\ns = input()\n\nlst2 = []\nfor x in range(n):\n    lst2.append(input().split())\n\ns = input()\n\nlst3 = []\nfor x in range(n):\n    lst3.append(input().split())\n\ns = input()\n\nlst4 = []\nfor x in range(n):\n    lst4.append(input().split())\n\nans_b1 = 0\nans_w1 = 0\nfor x in range(n):\n    for y in range(n):\n        if (x + y) & 1 == 0:\n            if lst1[x][0][y] == '0':\n                ans_b1 += 1\n            else:\n                ans_w1 += 1\n        else:\n            if lst1[x][0][y] == '1':\n                ans_b1 += 1\n            else:\n                ans_w1 += 1\n\nans_b2 = 0\nans_w2 = 0\nfor x in range(n):\n    for y in range(n):\n        if (x + y) & 1 == 0:\n            if lst2[x][0][y] == '0':\n                ans_b2 += 1\n            else:\n                ans_w2 += 1\n        else:\n            if lst2[x][0][y] == '1':\n                ans_b2 += 1\n            else:\n                ans_w2 += 1\n\nans_b3 = 0\nans_w3 = 0\nfor x in range(n):\n    for y in range(n):\n        if (x + y) & 1 == 0:\n            if lst3[x][0][y] == '0':\n                ans_b3 += 1\n            else:\n                ans_w3 += 1\n        else:\n            if lst3[x][0][y] == '1':\n                ans_b3 += 1\n            else:\n                ans_w3 += 1\n\nans_b4 = 0\nans_w4 = 0\nfor x in range(n):\n    for y in range(n):\n        if (x + y) & 1 == 0:\n            if lst4[x][0][y] == '0':\n                ans_b4 += 1\n            else:\n                ans_w4 += 1\n        else:\n            if lst4[x][0][y] == '1':\n                ans_b4 += 1\n            else:\n                ans_w4 += 1\n\nprint((2 * n) ** 2 - max(ans_b1 + ans_b2 + ans_w3 + ans_w4, ans_b1 + ans_w2 + ans_b3 + ans_w4, ans_b1 + ans_w2 + ans_w3 + ans_b4, ans_w1 + ans_b2 + ans_b3 + ans_w4, ans_w1 + ans_b2 + ans_w3 + ans_b4, ans_w1 + ans_w2 + ans_b3 + ans_b4))","output":"quadratic"},{"instruction":"base = 1000000007\nn , m , k = map(int,input().split())\na = list(map(int,input().split()))\nmx = 0\ns = 0\ndp = []\ndd= []\nfor j in range(m):\n    for i in range(n+1):\n        dp.append(base)\n        dd.append(0)\n    for i in range(n):\n        dd[i+1]=dd[i]+a[i]-k*(i % m== j)\n        dp[i+1] = min(dd[i],dp[i])\n\n        if (i % m == j):\n            mx = max ( mx , dd[i+1]-dp[i+1])\nprint(mx)","output":"quadratic"},{"instruction":"def func(n1,n2,n3):\n    global r,g,b\n    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):\n        return 0\n    if(n1<0):\n        return g[n2]*b[n3] + func(n1,n2-1,n3-1)\n    if(n2<0):\n        return r[n1]*b[n3] + func(n1-1,n2,n3-1)\n    if(n3<0):\n        return g[n2]*r[n1] + func(n1-1,n2-1,n3)\n    if(dp[n1][n2][n3]==-1):\n        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))\n    return dp[n1][n2][n3]\n\nR,G,B=tuple(map(int,input().split()))\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr=sorted(r)\ng=sorted(g)\nb=sorted(b)\nprefix1=[0]*R\nprefix2 = [0]*G\nprefix3 = [0]*B\nprefix1[0]=r[0]\nprefix2[0] = g[0]\nprefix3[0]=b[0]\ndp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]\n\nprint(func(R-1,G-1,B-1))","output":"cubic"},{"instruction":"R,G,B = map(int,input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\narea = 0\nr.sort(reverse=True)\nb.sort(reverse=True)\ng.sort(reverse=True)\nL = max(len(r),len(g),len(b))\ndp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]\n\ntr = 0\ntg = 0\ntb = 0\nfor i in range(R+1):\n\tfor j in range(G+1):\n\t\tfor k in range(B+1):\n\t\t\tif i>0 and j>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n\t\t\tif j>0 and k>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\n\t\t\tif i>0 and k>0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n\t\t\tarea = max(area,dp[i][j][k])\nprint(area)","output":"cubic"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\ndef popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, M = map(int, readline().split())\n\nAr = [tuple(map(int, readline().split())) for _ in range(N)]\n\npc = [popcount(i) for i in range(1<<(M+1))]\n\ninf = 1<<31\nmaxi = [0]*(1<<M)\n\nfor i in range(N):\n    a = Ar[i]\n    dp = [0]*(1<<M)\n    for S in range(1, 1<<M):\n        p = pc[S]\n        if p == 1:\n            k = S.bit_length() - 1\n            dp[S] = a[k]\n        else:\n            dp[S] = min(dp[-S&S], dp[S^(-S&S)])\n        maxi[S] = max(maxi[S], dp[S])\nfor i in range(M):\n    for j in range(1<<M):\n        if not j & (1<<i):\n            maxi[j] = max(maxi[j], maxi[j|(1<<i)])\n\nD = (1<<M)-1\nans = maxi[D]\naS, bS = D, D\nfor S in range(1<<M):\n    candi = min(maxi[S], maxi[D^S])\n    if candi > ans:\n        aS, bS = S, D^S\n        ans = candi\n\nAns = [None]*2\npre = False\nfro = False\n\nfor i in range(N):\n    a = Ar[i]\n    resa = inf\n    resb = inf\n    for j in range(M):\n        if (1<<j)&aS:\n            resa = min(resa, a[j])\n        else:\n            resb = min(resb, a[j])\n    if resa >= ans:\n        pre = True\n        Ans[0] = i+1\n    if resb >= ans:\n        fro = True\n        Ans[1] = i+1\n    if pre and fro:\n        break\nprint(*Ans)","output":"np"},{"instruction":"from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(map(xor, a[-1][:-1], a[-1][1:]))\n\nfor i in range(n - 1):\n    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))","output":"quadratic"},{"instruction":"n, m = list(map(int, input().split()))\nsquare = [0] * n\nl = list(map(int, input().split()))\nfor x in l:\n    square[x-1] += 1\nprint(min(square))","output":"quadratic"},{"instruction":"import math\nn=int(input())\nif(n%2==0):\n   x=math.floor(n\/2+1)*(math.floor(n\/2))\nif(n%2!=0):\n   x=(math.ceil(n\/2)*(math.ceil(n\/2)))\nprint(x)","output":"linear"},{"instruction":"n = int(input())\nA = map(int, input().split())\na = []\nfor x in A:\n\ta.append(x)\ntot = 0\nfor i in range(n):\n\tl = i\n\tr = n - i - 1\n\ttot += a[i] * l + -a[i] * r\n\nfrom collections import defaultdict\n\nfor_cnt = defaultdict(int)\n\nfor i in range(n):\n\tfault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]\n\ttot -= a[i] * fault\n\tfor_cnt[a[i]] += 1\n\nback_cnt = defaultdict(int)\n\ni = n - 1\nwhile i >= 0:\n\tfault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]\n\ttot -= -a[i] * fault\n\tback_cnt[a[i]] += 1\n\ti -= 1\n\nprint(tot)","output":"nlogn"},{"instruction":"(x, y) = list(map(int, input().split(' ')))\n\na = 0\nb = x * y\npos = True\n\nfor t in reversed(range(b)):\n    b -= 1\n    print(str(int(a \/ y + 1)) + ' '+ str(int(a % y + 1)))\n    a += b * (1 if pos else -1)\n    pos = not pos","output":"quadratic"},{"instruction":"n,k=map(int,input().split())\narr=list(map(int,input().split()))\npar=[i for i in range(260)]\npath=[-1 for i in range(260)]\nfor i in range(n):\n    j=arr[i]\n    if path[j] >=0:\n        par[j] =par[path[j]]\n        continue\n    jump=1\n    while j>0 and path[j] ==-1 and jump <k:\n        path[j] =arr[i]\n        j-=1\n        jump +=1\n    if arr[i] -par[j] +1 <=k:\n            par[arr[i]] =par[j]\n            path[j] =arr[i]\n    else:\n        par[arr[i]] =par[j+1]\nfor i in range(n):\n    print(par[arr[i]],end=' ')\nprint()","output":"quadratic"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, = getIntList()\n\ns1 = input() +'0'\ns2 = input() +'0'\n\nres = 0\n\ni = 0\nwhile i<N:\n    if s1[i] != s2[i]:\n        if s1[i+1] == s2[i] and s2[i+1] == s1[i]:\n            res+=1\n            i+=2\n            continue\n        res+=1\n    i+=1\nprint(res)","output":"linear"},{"instruction":"x,y,z,t1,t2,t3=map(int,input().split())\nif abs(x-y)*t1>=abs(x-z)*t2+t3*3+abs(x-y)*t2:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"import sys\ndef main():\n    pass\ndef binary(n):\n\n    return (bin(n).replace(\"0b\", \"\"))\ndef decimal(s):\n\n    return (int(s, 2))\ndef pow2(n):\n\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\ndef isPrime(n):\n\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\ndef lts(l):\n\n    s = ''.join(map(str, l))\n    return s\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\nfrom collections import OrderedDict\n\nn=iinp()\nl=[]\ns={\"purple\",\"green\",\"blue\",\"orange\",\"red\",\"yellow\"}\nfor i in range(n):\n    inp=ssinp()\n    s.remove(inp)\nprint(6-n)\nfor i in s:\n    if(i==\"purple\"):\n        print(\"Power\")\n    elif(i==\"green\"):\n        print(\"Time\")\n    elif(i==\"blue\"):\n        print(\"Space\")\n    elif (i == \"orange\"):\n        print(\"Soul\")\n    elif (i == \"red\"):\n        print(\"Reality\")\n    else:\n        print(\"Mind\")","output":"constant"},{"instruction":"def main():\n    n, m = map(int, input().split())\n\n    r = []\n    rappend = r.append\n    for i in range(1, (n >> 1) + 1):\n        for j in range(1, m + 1):\n            rappend(str(i) + ' ' + str(j))\n            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))\n\n    if n & 1:\n        for i in range(1, (m >> 1) + 1):\n            rappend(str((n + 1) >> 1) + ' ' + str(i))\n            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))\n        if m & 1:\n            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))\n\n    print('\\n'.join(r))\n\nmain()","output":"quadratic"},{"instruction":"n,tnow=map(int,input().split())\nleft=int(\"\".join([\"1\" for i in range(n)]),2)\narr=[]\ndp={}\nfor i in range(n):\n    a,b=map(int,input().split())\n    arr.append([a,b])\ndef recur(tnow,prevgenre,left):\n    key=str(left)+\"_\"+str(prevgenre)\n    if tnow==0:\n        return 1\n    elif key in dp:\n        return dp[key]\n    else:\n        ans=0\n        for i in range(n):\n            if (left&(1<<i))!=0:\n                if arr[i][0]<=tnow and arr[i][1]!=prevgenre:\n                    left=left&(~(1<<i))\n                    ans+=recur(tnow-arr[i][0],arr[i][1],left)\n                    left=left|(1<<i)\n        dp[key]= ans\n        return ans\n\nprint(recur(tnow,4,left)%(10**9+7))","output":"np"},{"instruction":"import math\ndef maxXor(l, r):\n  if l == r:\n    return 0\n  xor = l ^ r\n  twoPows = math.log(xor, 2)\n  return 2 ** int(math.floor(twoPows) + 1) - 1\n\nl, r = map(int, input().split())\nprint(maxXor(l, r))","output":"logn"},{"instruction":"from copy import *\nn,T=map(int,raw_input().split())\ncl=set(())\ndi={(0,0,0,T):1}\nfor k in range(n):\n    t,g=map(int,raw_input().split())\n    an=deepcopy(di)\n    for k in an:\n        nc=list(k)\n        nc[3]-=t\n        nc[g-1]+=1\n        if nc[3]>=0:\n            nc=tuple(nc)\n            if nc in di:\n                di[nc] += an[k]\n            else:\n                di[nc] = an[k]\nnd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}\nmo=10**9+7\ndef nb(tu):\n\n    if not(tu in nd):\n        if tu[tu[3]]==0:\n            nd[tu] =0\n        else:\n            nt=list(tu)\n            nt[tu[3]]-=1\n            nt[3]=(nt[3]+1)%3\n            nt2=nt[:]\n            nt2[3]=(nt2[3]+1)%3\n            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo\n    return nd[tu]\n\nprint(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)","output":"np"},{"instruction":"import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y\/\/g):\n\t    d=[max(d[0],d[1]),d[0]+n*g\/\/y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n\/\/g+1)+(g-n%g)*h(n\/\/g))","output":"np"},{"instruction":"n = int(input())\n\nprint(0, 0, n)","output":"constant"},{"instruction":"n,m = map(int,input().split())\narr1 = list(map(int,input().split()))\narr2 = list(map(int,input().split()))\n\nj = 0\nfor i in range(n):\n    if j<m and arr2[j]>=arr1[i]:\n        j+=1\nprint(j)","output":"linear"},{"instruction":"n, m = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\n\na.sort()\nlast = 0\ntotal = 0\nfor i in range(n - 1):\n    if a[i]>0 :\n        total += a[i] - 1\n        last = min(last + 1, a[i])\n\nprint(total + max(a[n-1] - max(1, a[n - 1] - last), 0))","output":"nlogn"},{"instruction":"from bisect import bisect_left\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        dp = []\n        dp.append(nums[0])\n\n        LIS = 1\n        for i in range(1, len(nums)):\n            if dp[-1] < nums[i]:\n                dp.append(nums[i])\n                LIS += 1\n                continue\n\n            idx = bisect_left(dp, nums[i])\n            dp[idx] = nums[i]\n\n        return LIS","output":"nlogn"},{"instruction":"n, u = map(int, input().split())\ne = list(map(int, input().split()))\nans = -1\nk = 2\nfor i in range(n-2):\n    while k<n-1 and e[k+1] - e[i] <= u:\n        k+=1\n    if i < k-1 and e[k] - e[i] <= u:\n        ans = max(ans,(e[k]-e[i+1]) \/ (e[k]-e[i]))\nprint(ans)","output":"nlogn"},{"instruction":"from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n\/\/i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\na = val()\nb = val()\n\nn = len(str(a))\n\na = [int(i) for i in str(a)]\na.sort()\nif len(str(b)) > n:\n\n    print(*sorted(a, reverse = 1), sep = '')\n    exit()\n\nb = str(b)\nb = [int(i) for i in b]\n\ndef makenum(s):return int(''.join(str(e) for e in s))\n\ndef givemax(a, b):\n    if len(a) > len(b):return a\n    elif len(b) > len(a):return b\n    else:\n        for j in range(len(a)):\n            if a[j] > b[j]:return a\n            elif b[j] > a[j]:return b\n        return a\n\n@lru_cache(None)\ndef dp(l, equal = 1):\n\n    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])\n    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))\n    ans = ''\n    l = list(l)\n    curr = b[n - len(l)]\n    for i in range(len(l)):\n        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':\n            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))\n        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':\n            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))\n\n    return str(ans)\n\nprint(dp(tuple(a), 1))","output":"cubic"},{"instruction":"n, p=map(int, input().split())\narr=list(map(int, input().split()))\nsu=0\nfor i in range(n):\n\tsu+=arr[i]\nmaxi, f=0, 0\nfor i in range(n-1):\n\tf+=arr[i]\n\tmaxi=max(maxi, f%p+(su-f)%p)\nprint(maxi)","output":"linear"},{"instruction":"import itertools\n\nkol1 = {'+': 0, '-': 0, '?': 0}\nkol2 = {'+': 0, '-': 0, '?': 0}\n\ns1 = input()\ns2 = input()\n\nfor s in s1:\n    kol1[s] += 1\n\nfor s in s2:\n    kol2[s] += 1\n\nif (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):\n    print('1.0')\n    exit()\n\nmod1 = kol1['+'] - kol1['-']\nmod2 = kol2['+'] - kol2['-']\nmod3 = abs(mod2-mod1)\nif (mod3>kol2['?']):\n    print(0.0)\n    exit()\n\nlist_comb = [1, -1]\nsum_pos = 0\ncol = 0\n\nfor comb in itertools.product(list_comb, repeat=kol2['?']):\n    if sum(comb)==mod3:\n        sum_pos += 1\n    col+=1\n\nprint(sum_pos\/col)","output":"np"},{"instruction":"from bisect import bisect_right,bisect_left\nn,c_tv,c_es=map(int,input().split())\nstart=[]\nend=[]\nadd=0\nfor _ in range(n):\n    l,r=map(int,input().split())\n    add+=(r-l)\n    start.append(l)\n    end.append(r)\nstart.sort()\nend.sort()\nans=add*c_es+n*c_tv\nM=10**9+7\nv=[0]*(n+1)\nfor i in range(n):\n    indx=bisect_left(end,start[i])-1\n    k=indx\n    while k>=0 and (start[i]-end[k])*c_es<c_tv and v[k]==1:\n        k-=1\n    if k==-1:\n        continue\n    if (start[i]-end[k])*c_es<c_tv:\n        ans-=c_tv-(start[i]-end[k])*c_es\n        v[k]=1\nprint(ans%M)","output":"nlogn"},{"instruction":"n,m,a,b = map(int,input().split())\nif n%m!=0:\n    mn = n\/\/m * m\n    mx = n\/\/m * m + m\n    print(min(((n - mn) * b),((mx - n) * a)))\nelse:print(0)","output":"linear"},{"instruction":"def main():\n    N, M, K = map(int, input().split())\n\n    if K % 2:\n        print((\"-1 \" * M + \"\\n\") * N)\n        return\n\n    colEdges = []\n    for i in range(N):\n        edges = list(map(int, input().split()))\n        colEdges.append(edges)\n\n    rowEdges = []\n    for i in range(N - 1):\n        edges = list(map(int, input().split()))\n        rowEdges.append(edges)\n\n    dp = [[[0 for i in range(M)] for j in range(N)] for k in range(2)]\n    p = [[[(i, j) for j in range(M)] for i in range(N)] for k in range(2)]\n    prev = 0\n    for k in range(K \/\/ 2):\n        cur = prev ^ 1\n        for i in range(N):\n            for j in range(M):\n                cand = (float('inf'), None)\n\n                if j:\n                    nxt = (dp[prev][i][j - 1] + colEdges[i][j - 1], p[prev][i][j - 1])\n                    cand = min(cand, nxt)\n                if j < M - 1:\n                    nxt = (dp[prev][i][j + 1] + colEdges[i][j], p[prev][i][j + 1])\n                    cand = min(cand, nxt)\n                if i:\n                    nxt = (dp[prev][i - 1][j] + rowEdges[i - 1][j], p[prev][i - 1][j])\n                    cand = min(cand, nxt)\n                if i < N - 1:\n                    nxt = (dp[prev][i + 1][j] + rowEdges[i][j], p[prev][i + 1][j])\n                    cand = min(cand, nxt)\n\n                dp[cur][i][j], p[cur][i][j] = cand\n        prev = cur\n\n    for i in range(N):\n        for j in range(M):\n             print(dp[prev][i][j] * 2, end=\" \")\n        print()\nmain()","output":"cubic"},{"instruction":"n = int(input())\na = sorted(list(map(int,input().split())))\nbal = 0\nif a.count(0)>1:\n    print('cslnb')\n    exit()\nif n-len(set(a))>1:\n    print('cslnb')\n    exit()\nif n-len(set(a))==1:\n    for i in range(1,n):\n        if a[i]==a[i-1]:\n            if a[i]-1 in a:\n                print('cslnb')\n                exit()\n            break\nif n==1:\n    print('cslnb' if not a[0] % 2 else 'sjfnb')\n    exit()\n\nfor i in range(n):\n    bal+=a[i]-i\nprint('sjfnb'if bal%2 else 'cslnb')","output":"nlogn"},{"instruction":"length = int(input())\nstart = []\nend = []\nfor i in range(length):\n    a, b = map(int, input().split(\" \"))\n    e, s = a - b, a + b\n    end.append([e, i])\n    start.append([s, i])\nend.sort(key = lambda x:x[0])\nstart.sort(key = lambda x:x[0])\ncant_visit = set()\nanswer = 0\nend_index = 0\nfor s, i in start:\n    if i not in cant_visit:\n        answer += 1\n        while end_index < length and end[end_index][0] < s:\n            cant_visit |= {end[end_index][1]}\n            end_index += 1\nprint(answer)","output":"nlogn"},{"instruction":"def main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum \/ k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    by_last_one = [[] for _ in range(k)]\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])\n            if found and not answer[mask]:\n                answer[mask] = True\n                masks[mask] = path\n                simple[mask] = True\n                by_last_one[calc_last_one(mask)].append(mask)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    for mask_right in range(2, 1 << k):\n        if not simple[mask_right]:\n            continue\n        last_one = calc_last_one(mask_right)\n        zeroes_count = 0\n        alternative_sum = 0\n        zero_list = []\n        for u in range(last_one):\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n                alternative_sum += len(by_last_one[u])\n                zero_list.append(u)\n        if zeroes_count == 0:\n            continue\n        if alternative_sum < (1 << zeroes_count):\n            for fill_last_zero in zero_list:\n                for mask_left in by_last_one[fill_last_zero]:\n                    if (mask_left & mask_right) != 0:\n                        continue\n                    joint_mask = mask_left | mask_right\n                    if not answer[joint_mask]:\n                        answer[joint_mask] = True\n                        left[joint_mask] = mask_left\n                        right[joint_mask] = mask_right\n                        by_last_one[last_one].append(joint_mask)\n                        if joint_mask == ((1 << k) - 1):\n                            return build_answer(k, masks, left, right)\n        else:\n            for mask_mask in range(1 << zeroes_count):\n                mask_left = 0\n                for u in range(zeroes_count):\n                    if (mask_mask & (1 << u)) != 0:\n                        mask_left = mask_left | (1 << zero_list[u])\n                joint_mask = mask_left | mask_right\n                if answer[mask_left] and not answer[joint_mask]:\n                    answer[joint_mask] = True\n                    left[joint_mask] = mask_left\n                    right[joint_mask] = mask_right\n                    by_last_one[last_one].append(joint_mask)\n                    if joint_mask == ((1 << k) - 1):\n                        return build_answer(k, masks, left, right)\n    return False, None, None\n\ndef calc_last_one(x):\n    result = -1\n    while x > 0:\n        x = x >> 1\n        result = result + 1\n    return result\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for i, a, j in masks[right[pos]]:\n            c[i] = a\n            p[i] = j\n        pos = left[pos]\n    for i, a, j in masks[pos]:\n        c[i] = a\n        p[i] = j\n    return True, c, p\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path.append((i_next, a[i_next][j_next], i))\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"n, p = map(int, input().split())\nlist1 = list(map(int, input().split()))\nmx = 0\ncurr = 0\nnxt = sum(list1)\nfor i in range(n - 1):\n    curr += list1[i]\n    nxt -= list1[i]\n    mx = max(mx, curr % p + nxt % p)\nprint(mx)","output":"linear"},{"instruction":"r, g, b = map(int, input().split())\nR = list(map(int, input().split()))\nG = list(map(int, input().split()))\nB = list(map(int, input().split()))\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\n\nmemo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\ndef calc(ir, ig, ib):\n    if memo[ir][ig][ib] != -1:\n        return memo[ir][ig][ib]\n    ans = 0\n    if ir < r and ig < g:\n        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])\n    if ir < r and ib < b:\n        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])\n    if ig < g and ib < b:\n        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])\n    memo[ir][ig][ib] = ans\n    return ans\n\nprint(calc(0, 0, 0))","output":"cubic"},{"instruction":"n, a, b = map(int, input().split())\n\nh = sorted(map(int, input().split()))\n\nprint(h[b] - h[b-1])","output":"nlogn"},{"instruction":"n,v = map(int, input().split())\nans = min(v, n-1)\nfor i in range(n - v - 1):\n    ans += i+2\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\nT = input().split(' ')\nfor i in range(n):\n    T[i]=int(T[i])\nL=[]\nM=[]\nt=0\nip=0\nIP=[]\nfor i in range(n):\n    if T[i]>=2:\n        L.append(i+1)\n        M.append(T[i])\n        t+=T[i]\n    else:\n        ip+=1\n        IP.append(i+1)\nif t-(2*len(L)-2)<ip:\n    print(\"NO\")\nelse:\n    for i in range(1, len(L)-1):\n        M[i]-=2\n    if len(L)>=2:\n        M[0]-=1\n        M[-1]-=1\n    print(\"YES\",end=' ')\n    if ip==0:\n        print(len(L)-1)\n    elif ip==1:\n        print(len(L))\n    else:\n        print(len(L)+1)\n    print(len(L)-1+ip)\n    if ip>=1:\n        print(IP[0], end=' ')\n        print(L[0])\n        M[0]-=1\n    if ip>=2:\n        print(IP[-1], end=' ')\n        print(L[-1])\n        M[-1]-=1\n    k=1\n    ind=0\n    while k < ip-1:\n        if M[ind]==0:\n            ind+=1\n        else:\n            print(IP[k], end=' ')\n            print(L[ind])\n            M[ind]-=1\n            k+=1\n    for i in range(len(L)-1):\n        print(L[i], end=' ')\n        print(L[i+1])","output":"linear"},{"instruction":"s = input().split()\nhand = {'m': [], 'p': [], 's':[]}\n\nfor item in s:\n\thand[item[1]].append(int(item[0]))\n\nmin_steps_needed = 10\n\nfor symb in ['m', 'p', 's']:\n\thand[symb] = sorted(hand[symb])\n\tfor start in range(1, 10):\n\t\ta_needed = 10\n\t\tb_needed = 10\n\n\t\ta_needed = 3 - hand[symb].count(start)\n\n\t\tb1, b2, b3 = 0, 0, 0\n\t\tif hand[symb].count(start) > 0:\n\t\t\tb1 = 1\n\t\tif hand[symb].count(start+1) > 0:\n\t\t\tb2 = 1\n\t\tif hand[symb].count(start+2) > 0:\n\t\t\tb3 = 1\n\n\t\tb_needed = 3 - b1 - b2 - b3\n\n\t\tif a_needed < min_steps_needed:\n\t\t\tmin_steps_needed = a_needed\n\t\tif b_needed < min_steps_needed:\n\t\t\tmin_steps_needed = b_needed\n\nprint(min_steps_needed)","output":"linear"},{"instruction":"n = int(input())\nA = [int(i) for i in input().split()]\nA = list(set(A))\nA.sort()\nif len(A)>1:\n    print(A[1])\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"arr1=str(input())\narr2=str(input())\narr1=arr1.encode()\narr2=arr2.encode()\narr1=bytearray(arr1)\narr2=bytearray(arr2)\nn, tot=len(arr1), 0\nfor i in range(n-1):\n\tif arr1[i]==48 and arr1[i+1]==48 and arr2[i]==48:\n\t\ttot+=1\n\t\tarr1[i]=49\n\t\tarr1[i+1]=49\n\t\tarr2[i]=49\n\telif arr1[i]==48 and arr2[i]==48 and arr2[i+1]==48:\n\t\ttot+=1\n\t\tarr1[i]=49\n\t\tarr2[i]=49\n\t\tarr2[i+1]=49\n\telif arr2[i]==48 and arr2[i+1]==48 and arr1[i+1]==48:\n\t\ttot+=1\n\t\tarr2[i]=49\n\t\tarr2[i+1]=49\n\t\tarr1[i+1]=49\n\telif arr1[i]==48 and arr1[i+1]==48 and arr2[i+1]==48:\n\t\ttot+=1\n\t\tarr1[i]=49\n\t\tarr1[i+1]=49\n\t\tarr2[i+1]=49\nprint(tot)","output":"constant"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n + 1) for _ in range(3024)]\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n    e[v][i] = i\n    d[i].append(i)\nfor v in range(1, 3024):\n    for i in range(n):\n        j = e[v][i]\n        h = e[v][j + 1] if j != -1 else -1\n        if j != -1 and h != -1:\n            e[v + 1][i] = h\n            d[i].append(h)\n\na = [_ for _ in range(1, n + 1)]\nfor s in range(n):\n    for e in d[s]:\n        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)\nprint(a[n - 1])","output":"cubic"},{"instruction":"import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nYp=lambda:print('Yes')\nNp=lambda:print('No')\n\nN = ip()\nL = []\nfor _ in range(N):\n    x,w = lp()\n    L.append([x-w,x+w])\nL.sort(reverse=True)\nans = 0\nedge = 1<<40\nfor i in range(N):\n    if L[i][1] <= edge:\n        edge = L[i][0]\n        ans += 1\nprint(ans)","output":"nlogn"},{"instruction":"def solve(i, j, k):\n    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):\n        return 0\n    if dp[i][j][k] != -1:\n        return dp[i][j][k]\n    ans = 0\n    if i >= 0 and j >= 0:\n        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))\n    if i >= 0 and k >= 0:\n        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))\n    if j >= 0 and k >= 0:\n        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))\n    dp[i][j][k] = ans\n    return ans\n\na, b, c = map(int, input().split())\nrs = sorted(list(map(int, input().split())))\ngs = sorted(list(map(int, input().split())))\nbs = sorted(list(map(int, input().split())))\ndp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]\nprint(solve(a - 1, b - 1, c - 1))","output":"cubic"},{"instruction":"data=list(map(int, input().split()))\nsum=0\ncont=0\nres=0\ncon2=0\ncon3=0\nfor i in range(data[0]):\n    sum=sum+con2\n    con2+=1\n    res=data[0]-con2\n\n    if data[1]==0:\n        if sum>= res:\n            cont+=1\n\n    else:\n        if sum>data[1]:\n            if res+1 == sum-data[1]:\n                cont=res+1\n                break\nprint(cont)","output":"logn"},{"instruction":"import sys\nfrom itertools import chain, combinations\n\ndef powerset(iterable):\n\ts = list(iterable)\n\treturn chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\ndef diff(s, x):\n\treturn True if (max(s)-min(s))>=x else False\n\ndef solve(problemset, l, r, x):\n\tmultiset = powerset(problemset)\n\tcnt = 0\n\tfor s in multiset:\n\t\tif sum(s)>=l and sum(s)<=r and diff(s, x):\n\t\t\tcnt += 1\n\treturn cnt\n\nsys.setrecursionlimit(10**7)\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI():return map(int, sys.stdin.readline().rstrip().split())\ndef LI():return list(map(int, sys.stdin.readline().rstrip().split()))\ndef LI2():return list(map(int, sys.stdin.readline().rstrip()))\ndef S():return sys.stdin.readline().rstrip()\ndef LS():return list(sys.stdin.readline().rstrip().split())\ndef LS2():return list(sys.stdin.readline().rstrip())\n\nn, l, r, x = MI()\n\nproblemset = LI()\n\nprint(solve(problemset, l, r, x))","output":"np"},{"instruction":"from collections import defaultdict\nfrom sys import setrecursionlimit,stdin\ninput=stdin.readline\nsetrecursionlimit(100000)\n\ndef dfs(r,g,b,rr,gg,bb):\n    if r<0 or g<0 or b<0:\n        return 0\n    x=0\n    y=0\n    z=0\n\n    if dp[r][g][b]!=-1:\n        return dp[r][g][b]\n    if r!=0 and g!=0:\n        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)\n    if r!=0 and b!=0:\n        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)\n    if b!=0 and g!=0:\n        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)\n    dp[r][g][b]=max(x,y,z)\n    return max(x,y,z)\n\nr,g,b=map(int,input().split())\nrr=list(map(int,input().split()))\ngg=list(map(int,input().split()))\nbb=list(map(int,input().split()))\nrr.sort()\ngg.sort()\nbb.sort()\ndp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\nprint(dfs(r,g,b,rr,gg,bb))","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\nmx = -1\nans = -1\nfor i in range(n):\n    if a[i] > mx+1:\n        ans = i+1\n        break\n    else:\n        mx = max(mx, a[i])\nprint(ans)","output":"linear"},{"instruction":"import sys\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nn = inp[ii]; ii += 1\nm = inp[ii]; ii += 1\nk = inp[ii]; ii += 1\n\nif k%2 == 1:\n\tfor _ in range(n):\n\t\ttoprint = [\"-1\" for __ in range(m)]\n\t\tprint(\" \".join(toprint))\n\n\tsys.exit()\n\nyw = []\n\nfor _ in range(n):\n\tyw.append(inp[ii:ii+m-1])\n\tii += m-1\n\nxw = []\n\nfor _ in range(n-1):\n\txw.append(inp[ii:ii+m])\n\tii += m\n\ninf = 10**10\n\nsteps = k\/\/2\n\ndp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)]\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tdp[0][i][j] = 0\n\nfor step in range(1, steps + 1):\n\tfor i in range(n):\n\t\tfor j in range(m):\n\n\t\t\tif i > 0:\n\t\t\t\tdp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j])\n\n\t\t\tif i < n-1:\n\t\t\t\tdp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j])\n\n\t\t\tif j > 0:\n\t\t\t\tdp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1])\n\n\t\t\tif j < m-1:\n\t\t\t\tdp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j])\n\nfor x in dp[-1]:\n\tprint(\" \".join(list(map(str, [2*o for o in x]))))","output":"cubic"},{"instruction":"n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\na.sort()\nb.sort()\na.reverse()\nb.reverse()\nif a[0]>b[-1]:\n    print(-1)\nelse:\n    que=[]\n    flag=True\n    if b[-1]==a[0]:\n        s=sum(b)\n        flag=False\n    else:\n        s=sum(b)-b[-1]+a[0]\n    if flag:\n        s+=(sum(a)-a[0])*m+b[-1]-a[1]\n    else:\n        s+=(sum(a)-a[0])*m\n    print(s)","output":"nlogn"},{"instruction":"n,a,b=map(int,input().split())\nalist=list(map(int,input().split()))\nalist.sort(reverse=True)\np=alist[a-1]\nq=alist[a]\nprint(p-q)","output":"nlogn"},{"instruction":"a = input()\nb = input()\nlist_a = list(a)\nlist_a.sort()\nmax_a = int(''.join(list_a))\nfor i in range(len(a)):\n    for j in range(i+1, len(a)):\n        list_a[i], list_a[j] = list_a[j], list_a[i]\n        temp_a = int(''.join(list_a))\n        if int(b) < temp_a or temp_a <= max_a:\n            list_a[i], list_a[j] = list_a[j], list_a[i]\n        else:\n            max_a = temp_a\nprint(max_a)","output":"cubic"},{"instruction":"n,p,l,r = map(int,input().split())\nif l == 1 and r == n:\n    print(0)\nelif l==1:\n    print(abs(p-r)+1)\nelif r == n:\n    print(abs(p - l) + 1)\nelse:\n    print(min(abs(p-r),abs(p - l))+r-l+2)","output":"constant"},{"instruction":"n=int(input())\ndef judge(x):\n    if x%2==0:\n        return 0\n    else:\n        return 1\nls=[int(x) for x in input().split()]\nif judge(ls[0])==judge(ls[1]):\n    for x in ls[2:]:\n        if judge(x)!=judge(ls[0]):\n            print(ls.index(x)+1)\n            break\nelse:\n    if judge(ls[2])==judge(ls[0]):\n        print(2)\n    elif judge(ls[2])==judge(ls[1]):\n        print(1)","output":"linear"},{"instruction":"l = input().split(' ')\nx = int(l[0])\nk = int(l[1])\n\nif x == 0:\n    print('0')\nelse:\n    mod = 1000000007\n\n    def pow_mod(a, b):\n        if b < 2:\n            return int(a ** b) % mod\n        elif b % 2 == 0:\n            return int(pow_mod(a, b \/\/ 2) ** 2) % mod\n        else:\n            return pow_mod(a, b - 1) * a % mod\n\n    twop = pow_mod(2, k)\n    high = x * twop\n    leafs = twop\n    low = high - leafs + 1\n    s = (high + 1) * high \/\/ 2 - (low - 1 + 1) * (low - 1) \/\/ 2\n    answer = s * 2 \/\/ leafs\n    answer %= mod\n\n    print(answer)","output":"logn"},{"instruction":"n, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(input())\ncnts = [0 for i in range(m)]\nfor i in range(n):\n    for j in range(m):\n        cnts[j] += 0 if grid[i][j] == '0' else 1\nfor i in range(n):\n    flag = True\n    for j in range(m):\n        if grid[i][j] == '1' and cnts[j] == 1:\n            flag = False\n            break\n    if flag:\n        print('YES')\n        exit(0)\nprint('NO')","output":"quadratic"},{"instruction":"import sys\nimport math\nfrom collections import OrderedDict\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, input().split())\ndef listinput(): return list(map(int, input().split()))\nn,k=minput()\nif n==k:print(math.ceil(n\/2)-1)\nelif k>2*n:print(0)\nelse:print(min(n,k-1)-k\/\/2)","output":"constant"},{"instruction":"n,t=list(map(int,input().split()))\na=sorted([list(map(int,input().split())) for i in range(n)])\nb=[a[i][0]-a[i][1]\/2-a[i-1][0]-a[i-1][1]\/2 for i in range(1,n)]\nc=2\nfor i in range(n-1):\n    c+=int(b[i]>t)*2+int(b[i]==t)\nprint(c)","output":"nlogn"},{"instruction":"x, k = map(int, input().split())\nmod = 1000 * 1000 * 1000 + 7\nif x == 0:\n    print(0)\nelse:\n    mul = pow(2, k + 1, mod)\n    cnt = pow(2, k, mod)\n    s1 = mul * cnt * x\n    s2 = cnt * (cnt - 1)\n    ans  = (s1 - s2) % mod\n    rev = pow(cnt, mod - 2, mod)\n    assert rev * cnt % mod == 1\n    ans *= rev\n    print(ans % mod)","output":"logn"},{"instruction":"a = input()\nb = input()\n\nlength_of_a = len(a)\nlength_of_b = len(b)\nfound_digit = False\nchk_finnish = False\nappended_digit_count = 0\nn = {}\nnum = []\nfor i in range(0,10):\n\tn[i] = 0\n\nfor i in range(0,length_of_a):\n\tc = int(a[i])\n\tn[c] += 1\n\nif length_of_a < length_of_b:\n\tnum = sorted(a,reverse=True)\n\tfor i in range(0,length_of_a):\n\t\tprint(num[i],end=\"\")\nelse:\n\tfor i in range(0,length_of_b):\n\t\tdigit = int(b[i])\n\t\tif n[digit] > 0:\n\t\t\tnum.append(digit)\n\t\t\tn[digit] -= 1\n\n\t\t\tappended_digit_count += 1\n\t\telse:\n\t\t\tj = digit - 1\n\t\t\twhile j > -1:\n\t\t\t\tif n[j] > 0:\n\t\t\t\t\tnum.append(j)\n\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tn[j] -= 1\n\n\t\t\t\t\tfound_digit = True\n\t\t\t\t\tchk_finnish = True\n\t\t\t\t\tbreak\n\t\t\t\tj -= 1\n\n\t\t\tif found_digit:\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tn[j] -= 1\n\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tif chk_finnish:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfound_digit = False\n\t\t\t\twhile found_digit == False:\n\t\t\t\t\tpop_up = num[appended_digit_count-1]\n\n\t\t\t\t\tdel num[-1]\n\t\t\t\t\tj = pop_up - 1\n\t\t\t\t\tn[pop_up] += 1\n\n\t\t\t\t\tappended_digit_count -= 1\n\t\t\t\t\twhile j > -1:\n\t\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\t\t\tn[j] -= 1\n\n\t\t\t\t\t\t\tfound_digit = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tj -= 1\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tbreak\n\n\tfor i in range(0,length_of_b):\n\t\tprint(num[i],end=\"\")","output":"cubic"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n\n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res","output":"nlogn"},{"instruction":"import math\ns1=input()\ns2=input()\ndist=0\npos=0\nunrecognized=0\nfor i in s1:\n\tif i ==\"+\":\n\t\tdist+=1\n\telse:\n\t\tdist-=1\n\nfor i in s2:\n\tif i ==\"+\":\n\t\tpos+=1\n\telif i==\"-\":\n\t\tpos-=1\n\telif i==\"?\":\n\t\tunrecognized+=1\ndifference=dist-pos\n\nif abs(difference)>abs(unrecognized):\n\tprint(\"{0:.9f}\".format(float(0)))\nelse:\n\textra=unrecognized-abs(difference)\n\tperm_extra=1\n\tfor i in range(1,unrecognized+1):\n\t\t\tperm_extra=perm_extra*i\n\tperm_extra=perm_extra\/(math.factorial(extra\/2+(unrecognized-extra))*math.factorial(extra\/2))\n\tif extra%2!=0:\n\t\tprint(\"{0:.9f}\".format(float(0)))\n\telse:\n\t\tprint(\"{0:.9f}\".format(float(perm_extra*(0.5**unrecognized))))","output":"np"},{"instruction":"from collections import namedtuple\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nn = int(input())\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    if rr[i] > 1:\n        a.append(vertex(rr[i], i + 1))\n    else:\n        b.append(vertex(rr[i], i + 1))\n    c += rr[i]\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    print('YES', len(a) - 1 + min(2, len(b)))\n    print(n - 1)\n    for i in range(1,len(a)):\n        print(a[i - 1].id, a[i].id)\n    if len(b) > 0:\n        print(b[0].id, a[0].id)\n    if len(b) > 1:\n        print(b[1].id, a[-1].id)\n    j, yes = 2, 0\n    for i in range(len(a)):\n        k = a[i].degree - 2\n        for t in range(k):\n            if j >= len(b):\n                yes = 1\n                break\n            print(a[i].id, b[j].id)\n            j += 1\n        if yes == 1:\n            break","output":"quadratic"},{"instruction":"from math import sin, pi\nn, r = map(int, input().split())\n\ndef p(n, r):\n    return 2 * n * r * sin(pi \/ n)\n\nle = 0; ri = r * 1000\nwhile ri - le > 1e-9:\n    m = (ri + le) \/ 2\n    if p(n, r + m) < n * m * 2:\n        ri = m\n    else:\n        le = m\nprint(m)","output":"constant"},{"instruction":"from bisect import bisect_left\nclass SegmentTree:\n    def __init__(self, N):\n        self.n = N\n        while (self.n & (self.n - 1)) != 0:\n            self.n += 1\n        self.tree = [0] * (2 * self.n)\n\n    def update(self, i, val):\n        self.tree[self.n + i] = val\n        j = (self.n + i) >> 1\n        while j >= 1:\n            self.tree[j] = max(self.tree[j << 1], self.tree[j << 1 | 1])\n            j >>= 1\n\n    def query(self, l, r):\n        if l > r:\n            return 0\n        res = float('-inf')\n        l += self.n\n        r += self.n + 1\n        while l < r:\n            if l & 1:\n                res = max(res, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res = max(res, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return res\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        def compress(arr):\n            sortedArr = sorted(set(arr))\n            order = []\n            for num in arr:\n                order.append(bisect_left(sortedArr, num))\n            return order\n\n        nums = compress(nums)\n        n = len(nums)\n        segTree = SegmentTree(n)\n\n        LIS = 0\n        for num in nums:\n            curLIS = segTree.query(0, num - 1) + 1\n            segTree.update(num, curLIS)\n            LIS = max(LIS, curLIS)\n        return LIS","output":"nlogn"},{"instruction":"n,k=map(int,input().split())\nmod=998244353\n\nNEXT={(0,1):2,(1,2):2}\n\nfor i in range(1,n):\n    NOW=NEXT\n    NEXT=dict()\n    for key in NOW:\n\n        if key[0]==0:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n            if k-(n-i)*2<key[1]+1<=k:\n                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]\n                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod\n\n        else:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod\n\n            if k-(n-i)*2<key[1]+2<=k:\n                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]\n\nANS=0\nfor key in NEXT:\n    if key[1]==k:\n        ANS=(ANS+NEXT[key])%mod\n\nprint(ANS)","output":"np"},{"instruction":"a=input()\nb=input()\nna=len(a)\nnb=len(b)\ndef fs(a,b):\n\ttry:\n\t\tfor i in range(a+1,len(b)):\n\t\t\tif b[a]>b[i]:\n\t\t\t\tans=b[i]\n\t\t\t\tk=b.copy()\n\t\t\t\tk.pop(i)\n\t\t\t\tans+=\"\".join(k)\n\t\t\t\treturn ans\n\t\treturn False\n\texcept:\n\t\treturn False\nif(na<nb):\n\tprint(\"\".join(sorted(list(a),reverse=True)))\nelse:\n\tif(a==b):\n\t\tprint(a)\n\n\telse:\n\t\tl=sorted(list(a),reverse=True)\n\t\tl2=l.copy()\n\t\tans1=\"\"\n\t\tflag=0\n\t\tans=[]\n\t\tfor i in b:\n\t\t\tfor j in range(len(l)):\n\t\t\t\tif i==l[j]:\n\t\t\t\t\tk=fs(j,l)\n\t\t\t\t\tif(k!=False):\n\t\t\t\t\t\tans.append(ans1+fs(j,l))\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tbreak\n\t\t\t\tif i>l[j]:\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tbreak\n\t\tans1+=\"\".join(l)\n\t\tif(int(ans1)<=int(b)):\n\t\t\tprint(ans1)\n\t\telse:\n\t\t\tfor i in sorted([int(i) for i in ans],reverse=True):\n\t\t\t\tif(i<=int(b)):\n\t\t\t\t\tprint(i)\n\t\t\t\t\tbreak","output":"cubic"},{"instruction":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        def dfs(i, flag):\n            if i >= len(nums) or (flag and i == len(nums) - 1):\n                return 0\n\n            return max(dfs(i + 1, flag),\n                       nums[i] + dfs(i + 2, flag or i == 0))\n        return max(dfs(0, True), dfs(1, False))","output":"np"},{"instruction":"n=int(input())\na=str(n)\nm=len(a)\nb=int(a[0:m-1])\nc=int(a[0:m-2]+a[-1])\nd=max(n,b,c)\nprint(d)","output":"constant"},{"instruction":"c1, c2, c3 = map(int, input().split())\nr = sorted(list(map(int, input().split())))\ng = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\ndp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]\nfor i in range(c1 + 1):\n    for j in range(c2 + 1):\n        for k in range(c3 + 1):\n            if i>0 and j>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])\n            if i>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])\n            if j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])\nprint(dp[c1][c2][c3])","output":"cubic"},{"instruction":"import sys\nimport math\n\nn=int(input())\nlista=[int(x) for x in input().strip().split()]\npap=lista[:]\npap.sort()\nif(pap[-1]==1):\n    pap[-1]=2\nelse:\n    pap=[1]+pap[:-1]\nfor i in range(n):\n    print(pap[i], end=\" \")","output":"nlogn"},{"instruction":"def nod(a, b):\n    while ((a != 0) and (b != 0)):\n        if (a > b):\n            a = a % b\n        else:\n            b = b % a\n    return a + b\ndef point3(x1, y1, x2, y2, x3, y3):\n    dy12 = x2 - x1\n    dx12 = -(y2 - y1)\n    dx13 = x3 - x1\n    dy13 = y3 - y1\n    if ((dx12 * dx13 + dy12 * dy13) == 0):\n        return True\n    else:\n        return False\n\nlstline = []\nmas = list(map(int, input().split()))\nn = mas[0]\nif (n <= 4):\n    for j in range(n):\n        mas = list(map(int, input().split()))\n    print('YES')\nelse:\n    lst5 = []\n    for j in range(5):\n        mas = list(map(int, input().split()))\n        lst5 = lst5 + [[mas[0], mas[1]]]\n    ok = True\n    for i in range(3):\n        for j in range(i + 1, 4, 1):\n            for k in range(j + 1, 5, 1):\n                if (ok):\n                    if (point3(lst5[i][0], lst5[i][1], lst5[j][0], lst5[j][1], lst5[k][0], lst5[k][1])):\n                        l1x1 = lst5[i][0]\n                        l1y1 = lst5[i][1]\n                        l1x2 = lst5[j][0]\n                        l1y2 = lst5[j][1]\n\n                        ok = False\n    if (ok == False):\n        lstline = []\n        for j in range(5):\n            if not(point3(l1x1, l1y1, l1x2, l1y2, lst5[j][0], lst5[j][1])):\n                lstline = lstline + [[lst5[j][0], lst5[j][1]]]\n\n    if (ok):\n        for j in range(n - 5):\n            mas = list(map(int, input().split()))\n        print('NO')\n    else:\n        res = 'YES'\n        ok1 = True\n        for j in range(n - 5):\n            mas = list(map(int, input().split()))\n            okey1 = point3(l1x1, l1y1, l1x2, l1y2, mas[0], mas[1])\n\n            if (ok1):\n                if (len(lstline) == 2):\n                    l2x1 = lstline[0][0]\n                    l2y1 = lstline[0][1]\n                    l2x2 = lstline[1][0]\n                    l2y2 = lstline[1][1]\n                    ok1 = False\n                    okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])\n                    if (not(okey1) and not(okey2)):\n                        res = 'NO'\n                elif(not(okey1)):\n                    lstline = lstline + [[mas[0], mas[1]]]\n            elif(not(okey1)):\n                okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])\n\n                if (not(okey2)):\n                    res = 'NO'\n        print(res)","output":"nlogn"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nans = float('inf')\nfor i in range(1, n-1):\n    bef = aft = float('inf')\n    for j in range(i):\n        if a[j] < a[i]:\n            bef = min(bef, b[j])\n    for j in range(i, n):\n        if a[i] < a[j]:\n            aft = min(aft, b[j])\n    ans = min(ans, b[i]+bef+aft)\nprint(-1 if ans > 10**9 else ans)","output":"quadratic"},{"instruction":"n=int(input())\nm=str(n)\nprint(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))","output":"constant"},{"instruction":"n, s = map(int, input().split())\nres = 0\nfor i in range(n, 0, -1):\n    res += s\/\/i\n    s = s % i\nprint(res)","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nfrom collections import Counter\n\ndef main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    d=dict()\n    z=0\n    s=0\n    for item in a:\n        if item in d:\n            d[item]+=1\n            z=item\n        else:\n            d[item]=1\n        s+=item\n\n    if len(a)-len(d)>=2:\n        print(\"cslnb\")\n        exit()\n    if len(a)==len(d):\n        z=(n*(n-1))\/\/2\n        if (s-z)%2:\n            print(\"sjfnb\")\n        else:\n            print(\"cslnb\")\n\n    else:\n        if z-1 in d or z==0:\n            print(\"cslnb\")\n        else:\n            zz=(n*(n-1))\/\/2\n            if (s-zz)%2:\n                print(\"sjfnb\")\n            else:\n                print(\"cslnb\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"import sys, collections, math, itertools, random, bisect\nINF = sys.maxsize\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\nmod = 1000000007\n\nl,r = get_ints()\nif r-l < 2:\n    print(-1)\nelif l%2 == 0:\n    print(l, l+1, l+2)\nelif r-l > 2:\n    print(l+1, l+2, l+3)\nelse:\n    print(-1)","output":"constant"},{"instruction":"print((int(input()))\/\/2+1)","output":"constant"},{"instruction":"import math\n\ns1 = input()\ns2 = input()\n\nplus, minus = s1.count('+'), s1.count('-')\n\npre_plus = s2.count('+'); pre_minus = s2.count('-')\n\nreq_plus, req_minus = plus- pre_plus, minus - pre_minus\n\nif req_minus < 0 or req_plus < 0:\n\tprint('%.12f'%0)\nelse:\n\tunknowns = len(s1) - (pre_minus + pre_plus)\n\n\tif unknowns == 0:\n\t\tprint('%.12f'%1)\n\telse:\n\t\tden = pow(2, unknowns)\n\t\tnum = math.factorial(unknowns)\/(math.factorial(req_plus)*math.factorial(req_minus))\n\t\tans = num\/den\n\t\tprint('%.12f'%ans)","output":"np"},{"instruction":"a, b = map(int, input().split())\n\nbitxor = a^b\n\nres = 1\nwhile bitxor:\n    bitxor >>= 1\n    res <<= 1\n\nprint(res-1)","output":"logn"},{"instruction":"n,ll,r,x=map(int,input().split(\" \"))\nl=list(map(int,input().split(\" \")))\nsubset = []\nfor i in range(1,(2**n)):\n  sub=[]\n  for j in range(n):\n    if (1<<j)&i>0:\n      sub.append(l[j])\n  subset.append(sub)\nc=0\n\nfor i in subset:\n  if len(i)>1:\n    su=sum(i)\n    if (su>=ll and su<=r) and ((max(i)-min(i))>=x):\n      c+=1\nprint(c)","output":"np"},{"instruction":"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)\n\ndef main():\n\tdef ask(c, d):\n\n\t\tprint(\"?\", c, d, flush = True)\n\t\treturn int(input())\n\n\trelative = ask(0, 0)\n\tcurA = 0\n\tcurB = 0\n\n\tfor i in range(29, -1, -1):\n\t\tq1 = ask(curA ^ 2 ** i, curB)\n\t\tq2 = ask(curA, curB ^ 2 ** i)\n\n\t\tif q1 == q2:\n\t\t\tif relative == 1:\n\t\t\t\tcurA ^= 2 ** i\n\t\t\telse:\n\t\t\t\tcurB ^= 2 ** i\n\t\t\trelative = q1\n\t\telif q2 == 1:\n\t\t\tcurA ^= 2 ** i\n\t\t\tcurB ^= 2 ** i\n\treturn curA, curB\nprint(\"!\", *main())","output":"constant"},{"instruction":"s=list(input())\ndic={}\nfor i in range(0,len(s)):\n    for j in range(i,len(s)):\n        ele=\"\".join(s[i:j+1])\n        if ele not in dic:\n            dic[ele]=1\n        else:\n            dic[ele]+=1\n\nans=[]\nfor key in dic.keys():\n    if dic[key]>=2:\n\n        ans.append(len(key))\nans.sort()\nif ans==[]:\n    print(0)\nelse:\n\n    print(ans[-1])","output":"cubic"},{"instruction":"class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n\n        fleets = 1\n        prevTime = (target - pair[0][0]) \/ pair[0][1]\n        for i in range(1, len(pair)):\n            currCar = pair[i]\n            currTime = (target - currCar[0]) \/ currCar[1]\n            if currTime > prevTime:\n                fleets += 1\n                prevTime = currTime\n        return fleets","output":"nlogn"},{"instruction":"def mypw2(deg):\n    if (deg >= 1500) : return 2 ** 150\n\n    return 2 ** deg\n\ndef sol():\n    n, k = map(int, input().split())\n    if (k == 0):\n        print(\"YES\", n)\n        return\n    for side in range(1, n + 1):\n        MIN = mypw2(side + 1) - side - 2\n        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;\n        MAX \/\/= 3\n\n        if (MIN <= k <= MAX):\n            print(\"YES\", n - side)\n            return\n    print(\"NO\")\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        sol()\n\nmain()","output":"logn"},{"instruction":"def chnge(last,cap,ini=(0,0)):\n    for i in range(ini[1],last[1]):\n        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])\n\nx1,y1,x2,y2,x3,y3 = map(int,input().split())\na = (max(x1,y1),[x1,y1],\"A\")\nb = (max(x2,y2),[x2,y2],\"B\")\nc = (max(x3,y3),[x3,y3],\"C\")\nm = max(a[0],b[0],c[0])\nfin = [[\"*\" for i in range(m)] for j in range(m)]\n\nif (x1*y1 + x2*y2 + x3*y3)!=m**2:\n    print(-1)\nelse:\n    l = sorted([a]+[b]+[c],reverse = True)\n    l[0][1].sort(reverse=True)\n    chnge(l[0][1],l[0][2])\n    ini=[0,l[0][1][1]]\n    last = l[1][1]\n    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:\n        last = [ini[0]+last[0],ini[1]+last[1]]\n    else:\n        last = [ini[0] + last[1], ini[1] + last[0]]\n    chnge(last,l[1][2],ini)\n    chr = l[2][2]\n    print(m)\n    for i in fin:\n        print(\"\".join(i).replace(\"*\",chr))","output":"np"},{"instruction":"n = int(input())\nli = list(map(int, input().split()))\nx = li.index(max(li))\nif li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root","output":"quadratic"},{"instruction":"import sys\nfrom array import array\nfrom typing import List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    dp = [array('h', [10000]) * (n + 1) for _ in range(n + 1)]\n    num = [array('h', [-1]) * (n + 1) for _ in range(n + 1)]\n    for i in range(n):\n        dp[i][i + 1] = 1\n        num[i][i + 1] = a[i]\n\n    for sublen in range(2, n + 1):\n        for l, r in zip(range(n), range(sublen, n + 1)):\n            for mid in range(l + 1, r):\n                if num[l][mid] == num[mid][r] != -1:\n                    dp[l][r] = 1\n                    num[l][r] = num[l][mid] + 1\n                    break\n\n                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid][r])\n\n    print(dp[0][-1])\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                l, r = i, j\n                while l < r and s[l] == s[r]:\n                    l += 1\n                    r -= 1\n                res += (l >= r)\n\n        return res","output":"cubic"},{"instruction":"ints=[int(x) for x in input().split()]\n\nn=ints[0]\nk=ints[1]\nprint(int(n-((8*(n+k)+9)**(1\/2)-3)\/2))","output":"logn"},{"instruction":"n , k = map(int , input().split())\nn , k = n-1 , k-1\n\nl = 0\nr = k\ng = k*(k+1)\/\/2\nans = -1\n\nwhile l <= r:\n \tm = (l+r)\/\/2\n \tif g-m*(m+1)\/\/2>=n:\n \t\tans = k-m\n \t\tl = m+1\n \telse:\n \t\tr = m-1\n\nprint(ans)","output":"logn"},{"instruction":"a,b= map(int, input().split())\n\nc=2*(a-1)-b*(b-1)\nif c > 0:\n    print(-1)\nelse:\n    d = int((1 + (1 - 4 * c) ** 0.5) \/ 2)\n    if d * (d - 1) + c > 0:\n        d -= 1\n\n    print(b -d)","output":"logn"},{"instruction":"def func(u,v,a,l):\n    if (v**2-u**2)>=2*a*l:\n        return ((u**2+2*a*l)**(1\/2)-u)\/a\n    else:\n        t1=(v-u)\/a\n        t2=(l-(u*t1+a*t1*t1\/2))\/v\n        return t1+t2\ndef efficient(v,a,w,d):\n    if 2*v*v-w*w<=2*a*d:\n        t1=v\/a\n        t2=(v-w)\/a\n        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)\/v\n        return t1+t2+t3\n    else:\n        bound=((2*a*d+w*w)\/2)**0.5\n        t1=bound\/a\n        t2=(bound-w)\/a\n        t3=func(0,w,a,d)\n        return t1+t2\n        return min(t1+t2,t3)\ndef main():\n    string1=input()\n    string2=input()\n    arr1=string1.split(\" \")\n    arr2=string2.split(\" \")\n    a=int(arr1[0])\n    v=int(arr1[1])\n    l=int(arr2[0])\n    d=int(arr2[1])\n    w=int(arr2[2])\n    if 2*a*d<=w**2 or v<=w:\n        t1=func(0,v,a,l)\n        print(\"%.8f\"%(t1))\n    else:\n        t1=efficient(v,a,w,d)\n        t2=func(w,v,a,l-d)\n        print(\"%.8f\"%(t1+t2))\nmain()","output":"constant"},{"instruction":"import math\nn=int(input())\nlst = list(map(int, input().strip().split(' ')))\ns=input()\nfor j in range(n):\n    lst[j]=[lst[j],j+1]\nlst.sort()\nstk=[]\ni=0\nfor j in range(2*n):\n    if s[j]=='0':\n        stk.append(lst[i][1])\n        print(lst[i][1],end=\" \")\n        i+=1\n\n    else:\n        print(stk[-1],end=\" \")\n        stk.pop()","output":"nlogn"},{"instruction":"n,s = map(int,input().split())\nif s>=n:\n    print('0')\nelse:\n    for i in range(s,n+2):\n        l=0\n        for j in str(i):\n            l+=int(j)\n        if i-l>=s:\n            break\n    print(n-i+1)","output":"logn"},{"instruction":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    x,k = LI()\n    if x == 0:\n        return 0\n    t = pow(2,k+1,mod) * x % mod\n    d = pow(2,k,mod) - 1\n\n    return (t + mod - d) % mod\n\nprint(main())","output":"logn"},{"instruction":"def fact(x):\n\tif x == 0:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\ndef lower_bound(li, num):\n\tanswer = -1\n\tstart = 0\n\tend = len(li)-1\n\n\twhile(start <= end):\n\t\tmiddle = (end+start)\/\/2\n\t\tif li[middle] >= num:\n\t\t\tanswer = middle\n\t\t\tend = middle - 1\n\t\telse:\n\t\t\tstart = middle + 1\n\treturn answer\ndef upper_bound(li, num):\n\tanswer = -1\n\tstart = 0\n\tend = len(li)-1\n\n\twhile(start <= end):\n\t\tmiddle = (end+start)\/\/2\n\n\t\tif li[middle] <= num:\n\t\t\tanswer = middle\n\t\t\tstart = middle + 1\n\n\t\telse:\n\t\t\tend = middle - 1\n\treturn answer\n\ndef abs(x):\n\treturn x if x >=0 else -x\ndef binary_search(li, val, lb, ub):\n\tans = 0\n\twhile(lb <= ub):\n\t\tmid = (lb+ub)\/\/2\n\n\t\tif li[mid] > val:\n\t\t\tub = mid-1\n\t\telif val > li[mid]:\n\t\t\tlb = mid + 1\n\t\telse:\n\t\t\tans = 1\n\t\t\tbreak\n\treturn ans\ndef kadane(x):\n\tsum_so_far = 0\n\tcurrent_sum = 0\n\tfor i in x:\n\t\tcurrent_sum += i\n\t\tif current_sum < 0:\n\t\t\tcurrent_sum = 0\n\t\telse:\n\t\t\tsum_so_far = mpos(sum_so_far,current_sum)\n\treturn sum_so_far\ndef pref(li):\n\tpref_sum = [0]\n\tfor i in li:\n\t\tpref_sum.append(pref_sum[-1] + i)\n\treturn pref_sum\ndef graph(n,m):\n\tadj = dict()\n\tfor i in range(1,n+1):\n\t\tadj.setdefault(i,0)\n\tfor i in range(m):\n\t\ta,b = map(int,input().split())\n\t\tadj[a] += 1\n\t\tadj[b] += 1\n\treturn adj\n\nimport sys\nimport threading\nfrom math import *\n\nfor _ in range(1):\n\n\tn,l,r,x = map(int,input().split())\n\n\ta = list(map(int,input().split()))\n\n\tcnt = 0\n\tfor mask in range(1,(1<<n)+1):\n\t\tmini = 10**9 + 10\n\t\tmaxi = 0\n\t\telem = 0\n\t\tsumi = 0\n\t\tfor j in range(n):\n\t\t\tif mask & (1<<j):\n\t\t\t\telem += 1\n\t\t\t\tsumi += a[j]\n\t\t\t\tmini = min(mini, a[j])\n\t\t\t\tmaxi = max(maxi, a[j])\n\n\t\tif elem >= 2:\n\t\t\tif (l <= sumi <= r) and (maxi-mini >= x):\n\t\t\t\tcnt += 1\n\tprint(cnt)","output":"np"},{"instruction":"import math\ndef factorial(num):\n    if num == 1:\n        return num\n    else:\n        return num * factorial(num - 1)\n\ns1=input()\ns2=input()\nans=0\nfor i in range(0,len(s1)):\n    if(s1[i]=='+'):\n        ans+=1\n    else:\n        ans-=1\nt=0\nqm=0\nfor i in range(0,len(s2)):\n    if(s2[i]=='+'):\n        t+=1\n    elif(s2[i]=='-'):\n        t-=1\n    else:\n        qm+=1\nif(qm==0):\n    if(ans==t):\n        print(1.000000000000)\n    else:\n        print(0.000000000000)\nelse:\n    k=ans-t\n    if(abs(k)==qm):\n        na=1\/pow(2,qm)\n        print(na)\n    elif(abs(k)>qm):\n        print(0.000000000000)\n    else:\n        if(k%2==0 and qm%2==1):\n            print(0.000000000000)\n        elif(k%2==1 and qm%2==0):\n            print(0.000000000000)\n        else:\n            a=abs((qm+k)\/2)\n            b=abs((qm-k)\/2)\n            nu=factorial(qm)\/(factorial(a)*factorial(b))\n            ans=nu\/(pow(2,qm))\n            print(ans)","output":"np"},{"instruction":"R, G, B = list(map(int, input().split()))\nr = sorted(list(map(int, input().split())), reverse=True)\ng = sorted(list(map(int, input().split())), reverse=True)\nb = sorted(list(map(int, input().split())), reverse=True)\n\nans = 0\ndp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n            if j<G and k<B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n            if i<R and k<B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"from sys import stdin\n\ndef solve(tc):\n    k = int(stdin.readline().strip())\n    cmp = 9\n    ndigit = 1\n\n    while k>(cmp*ndigit):\n        k -= cmp*ndigit\n        cmp *= 10\n        ndigit += 1\n\n    num = (10**(ndigit-1)) + ((k-1) \/\/ ndigit)\n    pos = (k-1) % ndigit\n\n    print(str(num)[pos])\n    pass\n\nLOCAL_TEST = not __debug__\nif LOCAL_TEST:\n    infile = __file__.split('.')[0] + \"-test.in\"\n    stdin = open(infile, 'r')\n\ntcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)\ntc = 1\nwhile tc <= tcs:\n    solve(tc)\n    tc += 1","output":"logn"},{"instruction":"import os\nfrom io import BytesIO, IOBase\nimport sys\n\ndef main():\n    n=int(input())\n    a=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        a.append((x,0))\n        a.append((y,1))\n    a.sort()\n    ans,s=[0]*n,[]\n    for x,y in a:\n        if y:\n            ans[len(s)-1]+=x-s[-1][0]+1-s[-1][1]\n            z=s.pop()\n            if s!=[]:\n                s[-1][1]+=(x-z[0]+1)\n        else:\n            s.append([x,0])\n    print(*ans)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"nlogn"},{"instruction":"n,m=[int(x) for x in input().split()]\na=sorted([int(x) for x in input().split()])\nb=[int(x) for x in input().split()]\nif max(a)<min(b):\n    print(sum(a)*m+sum(b)-a[-1]*(m-1)-a[-2])\nelif max(a)==min(b):\n    print(sum(a)*m+sum(b)-a[-1]*m)\nelse:\n    print(-1)","output":"nlogn"},{"instruction":"n = int(input())\n\np = []\nfor i in range(n):\n    la = list(map(float,input().split()))\n    p.append(la)\n\nfull_bit =  (1<<n) - 1\ndp = [0]*(full_bit) + [1]\n\nfor i in range(full_bit,0,-1):\n\n    cunt = bin(i)[2:].count('1')\n\n    if cunt == 1 or dp[i] == 0:\n        continue\n\n    mul = 1\/((cunt*(cunt-1))>>1)\n\n    for x in range(n):\n        if (i & (1<<x)) == 0:\n            continue\n        for y in range(x+1,n):\n            if (i & (1<<y)) == 0:\n                continue\n\n            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul\n            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul\n\nans = []\nfor i in range(n):\n    ans.append(dp[1<<i])\n\nprint(*ans)","output":"np"},{"instruction":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])","output":"nlogn"},{"instruction":"n = int(input())\ns = input()\ncount = 0\ntemp_count = 0\nfor c in s:\n    if c == 'x':\n        temp_count += 1\n    else:\n        temp_count = 0\n    if temp_count == 3:\n        count += 1\n        temp_count -= 1\n\nprint(count)","output":"linear"},{"instruction":"import math\nx, k = list(map(int, input().split()))\nmod = 10**9 + 7\nprint((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)","output":"logn"},{"instruction":"from sys import stdin\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])\n\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            mem[(i - 1) & 1][j][k1] = 0\n\nprint(sum(mem[(n - 1) & 1][k]) % mod)","output":"np"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ngraph=defaultdict(list)\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nbulb=[1]*(n+1)\nfor i in range(n-1):\n    bulb[par[i]]=0\n    graph[par[i]].append(i+2)\n\nzero=bulb.count(0)\nfor  i in range(n,0,-1):\n    if bulb[i]==0:\n        count=0\n        for j in graph[i]:\n            count+=bulb[j]\n        bulb[i]=count\nbulb=bulb[1:]\nbulb.sort()\nsys.stdout.write(' '.join(map(str,bulb)))","output":"quadratic"},{"instruction":"import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nn = int(input())\nC = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = [a-1 for a in A]\n\nvisit = [False]*n\nloops = []\nfor i in range(n):\n    if not visit[i]:\n        s = [i]\n        temp = set()\n        temp.add(i)\n        flag = False\n        while s:\n            v = s.pop()\n            if visit[A[v]]:\n                break\n            if A[v] in temp:\n                flag = True\n                p = A[v]\n                break\n            else:\n                s.append(A[v])\n                temp.add(A[v])\n        if flag:\n            loop = [p]\n            nv = A[p]\n            cnt = 0\n            while nv != p:\n                loop.append(nv)\n                nv = A[nv]\n            loops.append(loop)\n        for v in temp:\n            visit[v] = True\n\nans = 0\nfor l in loops:\n    m = 10**18\n    for i in l:\n        m = min(m, C[i])\n    ans += m\nprint(ans)","output":"linear"},{"instruction":"x=int(input())\nd=x\/\/2\nprint(d+1)","output":"constant"},{"instruction":"import string\n\nn, s, t = int(input()), input(), input()\nx, i, j = 0, -1, -1\nsc_dict = {c: set() for c in string.ascii_lowercase}\ntc_dict = {c: set() for c in string.ascii_lowercase}\nsti_dict, tsi_dict = dict(), dict()\n\nfor ci, sc, tc in zip(range(n), s, t):\n    if sc == tc:\n        continue\n    sc_dict[sc].add(tc)\n    tc_dict[tc].add(sc)\n    sti_dict[sc + tc] = ci\n    tsi_dict[tc + sc] = ci\n    x += 1\n\nfor c in string.ascii_lowercase:\n    cs = sc_dict[c] & tc_dict[c]\n    if not cs:\n        continue\n    c2 = cs.pop()\n    x -= 2\n    i = sti_dict[c + c2] + 1\n    j = tsi_dict[c + c2] + 1\n    break\nelse:\n    for c in string.ascii_lowercase:\n        if not sc_dict[c] or not tc_dict[c]:\n            continue\n        x -= 1\n        i = sti_dict[c + sc_dict[c].pop()] + 1\n        j = tsi_dict[c + tc_dict[c].pop()] + 1\n        break\n\nprint(x)\nprint(i, j)","output":"linear"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 1000000007;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if n < 0 or r < 0 or r > n: return 0;\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    C();\n\ndef D():\n    [n,m,k] = ti();\n    w = [[] for i in range(n)];\n    for i in range(n):\n        w[i] = ts();\n\n    mn = [[0 for j in range(k+1)] for i in range(n+1)];\n    for i in range(1,n+1):\n        for j in range(k+1):\n            c = 0;\n            st,en = -1,-1;\n            for x in range(m):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;\n            st,en = -1,-1;\n            c = 0;\n            for x in range(m-1,-1,-1):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            if st != -1 and en != -1 >= 0:\n                mn[i][j] = min(mn[i][j], st-en+1);\n\n    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];\n    for i in range(k+1):\n        dp[0][i] = 0;\n    for i in range(1,n+1):\n        for j in range(k+1):\n            for x in range(k+1):\n                if j-x >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);\n\n    print(dp[n][k]);\n\ndef getCount(n):\n    x = 1;\n    count = 0;\n    while n > 0:\n        if n & 1 == 1:\n            count += 1;\n        n = n >> 1;\n    return count;\n\ndef C():\n    try:\n        n = ts();\n        k = pi();\n        if k == 0:\n            print(1);\n            return;\n        dp = [0 for i in range(1010)];\n        for i in range(1010):\n            if i == 0 or i == 1:\n                continue;\n            dp[i] = dp[getCount(i)]+1;\n        fact(1010,mod);\n\n        ans = 0;\n        s = n;\n        count = 0;\n        for i in range(len(s)):\n            if s[i] == '0': continue;\n            for j in range(max(count,1),1010):\n                if dp[j] == k-1:\n                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;\n                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;\n            count += 1;\n        count = 0;\n        for i in range(len(s)):\n            if s[i] == '1': count += 1;\n        if dp[count] == k-1: ans = (ans+1)%mod;\n\n        print(ans);\n    except: print(sys.exc_info()[0]);\n\nmain();","output":"linear"},{"instruction":"import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nt = input()\ns = input()\nk = t.count('+') - s.count('+')\nn = s.count('?')\nif k > n or k < 0:\n    print('0.0')\nelse:\n    print(math.factorial(n) \/ (math.factorial(k) * math.factorial(n - k)) \/ 2**n)","output":"np"},{"instruction":"n, k = map(int, input().split())\nsame = [0] * (k + 1)\ndiff = [0] * (k + 1)\nmod = 998244353\nsame[1] = 2\nif k > 1 : diff[2] = 2\nfor i in range (n - 1) :\n    newsame = [0] * (k + 1)\n    newdiff = [0] * (k + 1)\n    for i in range (1, k + 1) : newsame[i] = (same[i] + same[i - 1] + 2 * diff[i]) % mod\n    for i in range (2, k + 1) : newdiff[i] = (2 * same[i - 1] + diff[i] + diff[i - 2]) % mod\n    same = newsame ; diff = newdiff\nprint((same[-1] + diff[-1]) % mod)","output":"np"},{"instruction":"def solve():\n  l, r = map(int, input().split())\n  if l==r:\n    print(0)\n    return\n  mx = str(bin(l^r))\n  x = len(mx[2:])\n  print(2**x-1)\nsolve()","output":"logn"},{"instruction":"a = input().split()\nst = set([])\ncnt = [[0 for i in range(9)] for i in range(3)]\nfor e in a:\n    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1\n    st.add(e)\nansw = len(st) - 1\nfor i in range(3):\n    for j in range(7):\n        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))\nprint(answ)","output":"linear"},{"instruction":"n=int(input())\na=[]\nfor i in range(n):\n    l=[int(i) for i in input().split()]\n    if i==0:\n        t=sum(l)\n    a.append(sum(l))\na.sort(reverse=True)\nprint(a.index(t)+1)","output":"linear"},{"instruction":"n,k=map(int,input().split())\nprint(max(min(n,k-1)-k\/\/2,0))","output":"constant"},{"instruction":"from sys import stdin,stdout\nfrom math import ceil\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):\n    n=nmbr()\n    a=lst()\n    p=0\n    ans=float('inf')\n    for i in range(n):\n        turns=ceil((a[i]-i)\/n)\n        if turns<ans:\n            ans=turns\n            p=i\n    print(p+1)","output":"linear"},{"instruction":"MOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom collections import defaultdict as dd\nn , = I()\nd = dd(list)\nfor i in range(n-1):\n\tt = I()\n\td[t[0]].append(t[1])\n\td[t[1]].append(t[0])\nl = I()\nv = [0]*(n+1)\ns = 1\nwhat = 0\nv[1] = 1\nwhile what < s:\n        a = set()\n        i = l[what]\n        for j in d[i]:\n                if not v[j]:\n                        a.add(j)\n        b = set()\n        for j in range(s,s + len(a)):\n                b.add(l[j])\n        if a!=b:\n                print('No')\n                exit()\n        kkk = 0\n        for k in a:\n            kkk += 1\n            v[k] = 1\n        s += kkk\n        what += 1\nif s != n:\n    print('No')\n    exit()\nprint('Yes')","output":"nlogn"},{"instruction":"n, k = [int(i) for i in input().split()]\nfor i in range(100*k+100*n):\n    if i*(i+1) == (n+k-i)*2:\n        print(n-i)\n        break","output":"linear"},{"instruction":"s=[list(input()) for i in range(2)]\nn=len(s[0])\ncnt=0\nfor i in range(n-1):\n  if s[0][i]==s[1][i]==s[0][i+1]==\"0\":\n    cnt+=1\n    s[0][i]=s[1][i]=s[0][i+1]=\"X\"\n  elif s[0][i]==s[1][i]==s[1][i+1]==\"0\":\n    cnt+=1\n    s[0][i]=s[1][i]=s[1][i+1]=\"X\"\n  elif s[0][i]==s[1][i+1]==s[0][i+1]==\"0\":\n    cnt+=1\n    s[0][i]=s[1][i+1]=s[0][i+1]=\"X\"\n  elif s[0][i+1]==s[1][i]==s[1][i+1]==\"0\":\n    cnt+=1\n    s[0][i+1]=s[1][i]=s[1][i+1]=\"X\"\nprint(cnt)","output":"constant"},{"instruction":"if __name__ == '__main__':\n    a = [int(c) for c in str(input())]\n    b = [int(c) for c in str(input())]\n    b_len = len(b)\n    a_len = len(a)\n    carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)]\n    b_zero_count = 0\n    b_one_count = 0\n    for b_i in range(b_len):\n        if b[b_i] == 0:\n            b_zero_count += 1\n        elif b[b_i] == 1:\n            b_one_count += 1\n        carCountPrefix[b_i+1][1] = b_one_count\n        carCountPrefix[b_i+1][0] = b_zero_count\n    res = 0\n    for cur in range(0, a_len):\n        for dig in range(2):\n            res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig)\n    print(res)","output":"linear"},{"instruction":"from math import sqrt\nn, k = map(int, input().split())\nprint(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))","output":"constant"},{"instruction":"n = int(input())\ns = list(input())\nt = list(input())\n\nif sorted(t) == sorted(s):\n    ans = []\n    for i in range(n-1, -1, -1):\n        if t[i] != s[i]:\n            j = s.index(t[i])\n            for k in range(j, i):\n                s[k], s[k+1] = s[k+1], s[k]\n                ans.append(str(k+1))\n    print(len(ans))\n    print(' '.join(ans))\nelse:\n    print(-1)","output":"quadratic"},{"instruction":"n,m,k = [int(w) for w in input().split()]\na = [int(w) for w in input().split()]\n\ndef f(o):\n    r = e = 0\n    for i, x in enumerate(a):\n        if i < o:\n            continue\n        if i % m == o:\n            e -= k\n            if e < -k:\n                e = -k\n        e += x\n        if e > r:\n            r = e\n    return r\n\nprint(max(f(o) for o in range(m)))","output":"quadratic"},{"instruction":"x1, y1, x2, y2, x3, y3 = map(int, input().split())\nrect1 = [x1, y1]\nrect2 = [x2, y2]\nrect3 = [x3, y3]\ndef func():\n    rect11 = [x1, y1]\n    rect22 = [x2, y2]\n    rect33 = [x3, y3]\n    rect1 = [x1, y1]\n    rect2 = [x2, y2]\n    rect3 = [x3, y3]\n\n    recta = [x1, y1]\n    rectb = [x2, y2]\n    rectc = [x3, y3]\n    for i in rect11:\n        for ii in rect22:\n            for iii in rect33:\n                if i==ii:\n                    rect1.remove(i)\n                    rect2.remove(ii)\n                    if rect1[0]+rect2[0]==iii:\n                        rect3.remove(iii)\n                        if i+rect3[0]==iii:\n                            print(iii)\n                            for j in range(iii):\n                                if j<rect1[0]:\n                                    print(\"C\"*rect3[0]+\"A\"*i)\n                                else:\n                                    print(\"C\"*rect3[0]+\"B\"*ii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n\n                if i==iii:\n                    rect1.remove(i)\n                    rect3.remove(iii)\n                    if rect1[0]+rect3[0]==ii:\n                        rect2.remove(ii)\n                        if i+rect2[0]==ii:\n                            print(ii)\n\n                            for j in range(ii):\n                                if j<rect1[0]:\n                                    print(\"B\"*rect2[0]+\"A\"*i)\n                                else:\n                                    print(\"B\"*rect2[0]+\"C\"*iii)\n                            exit()\n                rect1 = recta.copy()\n                rect2 = rectb.copy()\n                rect3 = rectc.copy()\n                if ii==iii:\n                    rect2.remove(ii)\n                    rect3.remove(iii)\n                    if rect2[0]+rect3[0]==i:\n                        rect1.remove(i)\n                        if i==rect1[0]+ii:\n                            print(i)\n                            for j in range(i):\n                                if j<rect2[0]:\n                                    print(\"A\"*rect1[0]+\"B\"*ii)\n                                else:print(\"A\"*rect1[0]+\"C\"*iii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n    return print(-1)\nfor i in rect1:\n    for ii in rect2:\n        for iii in rect3:\n            recta = [x1, y1]\n            rectb = [x2, y2]\n            rectc = [x3, y3]\n\n            if i==ii==iii:\n                rect1.remove(i)\n                rect2.remove(i)\n                rect3.remove(i)\n\n            if rect1[0]+rect2[0]+rect3[0]==i:\n                print(i)\n                for j in range(i):\n                    print(\"A\"*rect1[0]+\"B\"*rect2[0]+\"C\"*rect3[0])\n                exit()\n            rect1=recta\n            rect2=rectb\n            rect3=rectc\n\nfunc()","output":"np"},{"instruction":"n=int(input())\nli=[]\nfor i in range(1,n+1):\n    if n%i==0:\n        li.append(i)\np=0\nfor t in li:\n    l=[m for m in str(t)]\n    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:\n        p+=1\nif p>0:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\n\nt=1\nfor i in range(t):\n\n    n,m,k = map(int,input().split())\n    b=[]\n    horizontal_edges=[]\n    vertical_edges=[]\n    for i in range(n):\n        temp=[int(x) for x in input().split()]\n        horizontal_edges.append(temp)\n    for i in range(n-1):\n        temp=[int(x) for x in input().split()]\n        vertical_edges.append(temp)\n\n    if k%2==1:\n        for i in range(n):\n            for j in range(m):\n                print(-1,end=' ')\n            print()\n        continue\n\n    dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n\n    for z in range(2,k+1,2):\n        for i in range(n):\n            for j in range(m):\n                    if i>0:\n                        if i<n-1:\n                            dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j])\n                        else:\n                            dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j]\n                    else:\n                        dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j]\n                    if j>0:\n                        if j<m-1:\n                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j])\n                        else:\n                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j])\n\n    for i in range(n):\n            for j in range(m):\n                print(dp[i][j][k],end=' ')\n            print()","output":"cubic"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nok = False\nfor i in range(len(a)):\n    if (a[i] > min(a) ):\n        ans = a[i]\n        ok = True\n        break\nif (ok):\n    print(ans)\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\ndef getsum(BITTree,i):\n    i=i+1\n    s = 0\n    while i > 0:\n        s += BITTree[i]\n        i -= i & (-i)\n    return(s)\ndef updatebit(BITTree , n , i ,v):\n    i=i+1\n    while i <= n:\n        BITTree[i] += v\n        i += i & (-i)\n\nn=int(input())\nlista=[int(i) for i in input().split()]\ninvercount=0\nbitTree=[0]*(n+2)\nfor k in reversed(lista):\n        updatebit(bitTree,n+1,k,1)\n        counter=getsum(bitTree,k-1)\n        invercount+=counter\nm=int(input())\nfor i in range(m):\n    l,r=map(int,input().split())\n    summa=((r-l+1)*(r-l))\/2\n    if (invercount+summa)%2:\n        print('odd')\n        invercount=1\n    else:\n        print('even')\n        invercount=0","output":"quadratic"},{"instruction":"(n, k) = list(map(int, raw_input().split(' ')))\n\ndef sol(lo, hi, actions, k):\n    while lo < hi:\n        mid = (hi - lo) \/ 2 + lo\n        put_candies = mid * (mid + 1) \/ 2\n        eat_candies = actions - mid\n        if put_candies - eat_candies == k:\n            return eat_candies\n        elif put_candies - eat_candies > k:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return actions - hi\n\nres = sol(1, n, n, k)\nprint(res)","output":"logn"},{"instruction":"def main():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n    solve(n, k, p)\n\ndef solve(n, k, p):\n    group = 256 * [None]\n    r = p[:]\n    for i, pi in enumerate(p):\n\n        if group[pi] is not None:\n            r[i] = group[pi][0]\n        else:\n            lo = pi\n            while lo >= 0 and pi - lo < k and group[lo] is None:\n                lo -= 1\n            if lo < 0 or pi - lo == k:\n                lo += 1\n                hi = pi + 1\n            else:\n                if pi - group[lo][0] < k:\n                    lo = group[lo][0]\n                    hi = pi + 1\n                else:\n                    lo += 1\n                    hi = pi + 1\n            lohi = (lo, hi)\n            for j in range(lo, hi):\n                group[j] = lohi\n            r[i] = group[pi][0]\n    print(\" \".join(map(str, r)))\n\nmain()","output":"quadratic"},{"instruction":"from operator import itemgetter\nn = int(input())\nai = list(map(int,input().split()))\nai2 = [[ai[i], i] for i in range(n)]\nanswer = [0] * n\nai2.sort(key = itemgetter(0))\nanswer[ai2[0][1]] = 1\nanswer[ai2[-1][1]] = 0\nfor i in range(n-2,0,-1):\n    num = ai2[i][1] % ai2[i][0]\n    for j in range(num,n,ai2[i][0]):\n        if ai[j] > ai2[i][0] and answer[j] == 0:\n            answer[ai2[i][1]] = 1\n            break\nfor i in range(n):\n    if answer[i] == 1:\n        print(\"A\",end=\"\")\n    else:\n        print(\"B\",end=\"\")","output":"quadratic"},{"instruction":"tam,q = [int(i) for i in input().split()]\nt = input()\ns = t\n\nposi = -1\n\nfor j in range(tam-1):\n    if(t[:j+1] == t[tam - j -1:]):\n        posi = j\n\nadd = t[posi+1:]\n\nfor j in range(q-1):\n    s += add\n\nprint(s)","output":"quadratic"},{"instruction":"from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0]\n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n\/\/=i\n    if n>1:\n        lst.append(n)\n    return lst\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\na = getInt()\nb = getInt()\n\narr = list(str(a))\n\narr = sorted(arr)\nans=''\n\nwhile arr:\n    for i in range(len(arr)-1,-1,-1):\n        x=ans+arr[i]\n\n        for j in arr[:i]:\n            x+=j\n        for j in arr[i+1:]:\n            x+=j\n        if int(x)<=b:\n            ans+=arr[i]\n            arr.pop(i)\n            break\n\nprint(ans)","output":"cubic"},{"instruction":"n=input()\nl = list(map(int,input().split()))\nl = sorted(l)\ns = 0\nc = 0\ncnt =0\nfor i in l:\n\ts+=i\nfor i in l[::-1]:\n\tc+=i\n\tcnt+=1\n\tif c >(s\/2):\n\t\tbreak\nprint(cnt)","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.readline\nn=int(input())\nar=list(map(int,input().split()))\ndic={}\nli=[]\nfor i in range(n):\n    xx=[]\n    for j in range(n-i):\n        xx.append(0)\n    li.append(xx.copy())\nfor i in range(n):\n    for j in range(n-i):\n        if(i==0):\n            li[i][j]=ar[j]\n        else:\n            li[i][j]=li[i-1][j]^li[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])\nfor _ in range(int(input())):\n    l,r=map(int,input().split())\n    print(li[r-l][l-1])","output":"quadratic"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\n\nd = {}\npower = [2**i for i in range(31)]\nans = []\nfor i in a:\n    d[i] = 0\n\nfor num in d.keys():\n    for p in power:\n        if num+p in d:\n            ans = [num, num+p]\n            if num+p+p in d:\n                print(3)\n                ans.append(num+p+p)\n                print(*ans)\n                exit()\nif ans:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(a[0])","output":"nlogn"},{"instruction":"n = int(input())\ns = input()\n\nif n == 1:\n    print(s)\nelse:\n    zeros = s.count('0')\n    print('1' + zeros * '0')","output":"linear"},{"instruction":"import itertools\n\nelement_to_value = {\n  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,\n  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,\n  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,\n  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,\n  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,\n  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,\n  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,\n  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,\n  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,\n  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100\n}\nvalue_to_element = dict()\nfor (element, value) in element_to_value.items():\n  value_to_element[value] = element\n\n(n,k) = map(int,input().split())\nproducts_start_str = input().split()\nproducts_end_str = input().split()\n\nproducts_start = [element_to_value[elem] for elem in products_start_str]\nproducts_end = [element_to_value[elem] for elem in products_end_str]\n\nproducts_start.sort()\ningredient_value = []\ningredient_count = []\nfor (key, lst) in itertools.groupby(products_start):\n  ingredient_value.append(key)\n  ingredient_count.append(len(list(lst)))\nnr_ingredients = len(ingredient_value)\n\nconstruction_options = [[] for i in range(k)]\nfor combination in itertools.product(*[range(l+1) for l in ingredient_count]):\n  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))\n  if (value in products_end):\n    for i in range(k):\n      if products_end[i] == value:\n        construction_options[i].append(combination)\n\nsolution =  [None for i in range(k)]\ndef find_solution(used = [0 for i in range(nr_ingredients)], next = 0):\n  if (next == k):\n    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))\n  else:\n    for option in construction_options[next]:\n      usage = [used[i]+option[i] for i in range(nr_ingredients)]\n      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):\n        possible = find_solution(usage, next+1)\n        if (possible):\n          solution[next] = option\n          return True\n  return False\n\npossible = find_solution()\n\nif not possible:\n  print(\"NO\")\n  exit()\n\ndef combination_to_recipe(combination):\n  recipe = []\n  for i in range(nr_ingredients):\n    for j in range(combination[i]):\n      recipe.append(value_to_element[ingredient_value[i]])\n  return recipe\n\nprint(\"YES\")\nfor i in range(k):\n  recipe = combination_to_recipe(solution[i])\n  print(\"%s->%s\" % (\"+\".join(recipe),products_end_str[i]))","output":"np"},{"instruction":"import heapq\n\ndef doxor(a, b):\n    cnt = 0\n    for i in range(len(a)):\n        for j in range(len(a[0])):\n            cnt += a[i][j] ^ b[i][j]\n    return cnt\n\nn = int(input())\n\na, b = [], []\nfor i in range(n):\n    ai, bi = [], []\n    for j in range(n):\n        if i % 2 == 0:\n            ai.append(j % 2)\n            bi.append((j % 2) ^ 1)\n        else:\n            ai.append((j % 2) ^ 1)\n            bi.append(j % 2)\n    a.append(ai)\n    b.append(bi)\n\nboard = []\nboard.append([list(map(int, list(input()))) for _ in range(n)])\ninput()\nboard.append([list(map(int, list(input()))) for _ in range(n)])\ninput()\nboard.append([list(map(int, list(input()))) for _ in range(n)])\ninput()\nboard.append([list(map(int, list(input()))) for _ in range(n)])\n\na_cnts = []\nb_cnts = []\nfor b0 in board:\n    heapq.heappush(a_cnts, doxor(b0, a))\n    heapq.heappush(b_cnts, doxor(b0, b))\n\nprint(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) +\n      heapq.heappop(b_cnts) + heapq.heappop(b_cnts))","output":"quadratic"},{"instruction":"from sys import stdin, stdout\nimport math\nN = int(input())\n\narr = [int(x) for x in stdin.readline().split()]\n\nif sum(arr)==0:\n    print('cslnb')\n    quit()\n\narr.sort()\nzeros = 0\nfreq = {}\ndup = 0\nres = 0\n\nfor i in range(N):\n    num = arr[i]\n    if num==0:\n        zeros += 1\n        if zeros==2:\n            print('cslnb')\n            quit()\n\n    if num not in freq:\n        freq[num] = 1\n    else:\n        dup += 1\n        freq[num] += 1\n\n    if dup==2:\n        print('cslnb')\n        quit()\n\nfor i in range(N):\n    num = arr[i]\n    if freq[num]==2:\n        if (num-1) not in freq:\n            freq[num-1] = 1\n            freq[num] = 1\n            arr[i] = arr[i] - 1\n            res += 1\n            break\n        else:\n            print('cslnb')\n            quit()\n\nminus = [0]*N\n\nlevel = 0\nfor i in range(N):\n    minus[i] = min(arr[i],level)\n    if arr[i]>=level:\n        level += 1\n\nfor i in range(N):\n    res += arr[i] - minus[i]\n\nif res%2==0:\n    print('cslnb')\nelse:\n    print('sjfnb')","output":"nlogn"},{"instruction":"from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) \/\/ b\nlim=22\npo=[1<<j for j in range(lim+1)]\nmaxbits=lim\nmasks=po[lim]\ndp=[-1]*masks\nt=1\nfor i in range(1):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    for i in l:\n        dp[i]=i\n    for i in range(masks):\n        for j in range(maxbits):\n            if dp[i]==-1 and i&po[j]:\n                dp[i]=dp[i-po[j]]\n    ans=[dp[i^(masks-1)] for i in l]\n    print(*ans)","output":"np"},{"instruction":"n, k = map(int, input().split())\nprint(k \/\/ n + (k % n != 0))","output":"constant"},{"instruction":"hell=1000000007\nid1=0\nid2=0\na = []\ndef check(n,m,x):\n    global id1,id2\n    b = [0]*(1<<m)\n    idx = [0]*(1<<m)\n    for i in range(n):\n        mask=0\n        for j in range(m):\n            if a[i][j]>=x:\n                mask=mask^(1<<j)\n        b[mask]=1\n        idx[mask]=i+1\n    for i in range(1<<m):\n        if b[i]:\n            for j in range(1<<m):\n                if b[j]:\n                    mask=i|j\n                    if mask==((1<<m)-1):\n                        id1=idx[i]\n                        id2=idx[j]\n                        return 1\n    return 0\ndef meowmeow321():\n    n,m = map(int,input().split())\n    for i in range(n):\n        dog = [int(x) for x in input().split()]\n        a.append(dog)\n    lo=0\n    hi=hell\n    while hi-lo>0:\n        mid=(hi+lo+1)\/\/2\n        if check(n,m,mid):\n            lo=mid\n        else:\n            hi=mid-1\n    check(n,m,lo)\n    print(id1,id2)\n\nt=1\n\nfor xxx in range(t):\n    meowmeow321()","output":"np"},{"instruction":"R = lambda: map(int, input().split())\nn, k = R()\nif n == 1:\n    print(0)\n    exit(0)\nif 1 + k * (k - 1) \/\/ 2 < n:\n    print(-1)\n    exit(0)\nl, r = 0, k - 1\nwhile l < r:\n    m = (l + r + 1) \/\/ 2\n    if 1 + (m + k - 1) * (k - 1 - m + 1) \/\/ 2 >= n:\n        l = m\n    else:\n        r = m - 1\nif 1 + (l + k - 1) * ((k - 1) - l + 1) \/\/ 2 < n:\n    print(k - 1 - l + 2)\nelse:\n    print(k - 1 - l + 1)","output":"logn"},{"instruction":"import sys\nfrom collections import defaultdict\n\nreader = (map(int, line.split()) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\n\nelems = set()\nvals = defaultdict(list)\nfor i in range(n):\n    for pos, v in enumerate(input()):\n        elems.add(v)\n        vals[v].append((pos, i))\n\nelems = sorted(elems, reverse=True)\n\nmasks = [0] * n\nfull = (1<<m) - 1\nmet = {0:0}\nfor v in elems:\n    for pos, i in vals[v]:\n        curr_mask = masks[i] = masks[i] | (1<<pos)\n        met[curr_mask] = i\n        complement = full ^ curr_mask\n        if complement in met:\n            print(i+1, met[complement]+1)\n            sys.exit()","output":"np"},{"instruction":"n = int(input())\nprint(n if n < 3 else ((n - 1) * (n * (n - 2) if n & 1 else (n - 3) * (n if n % 3 else n - 2))))","output":"constant"},{"instruction":"t=1\nfor _ in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    dp=[[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        dp[0][i]=l[i]\n    for i in range(1,n):\n        for j in range(n-i):\n            dp[i][j]=dp[i-1][j]^dp[i-1][j+1]\n\n    for i in range(1,n):\n        for j in range(n-i):\n            dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j+1])\n\n    q=int(input())\n    for __ in range(q):\n        x,y=map(int,input().split())\n        x-=1\n        y-=1\n        print(dp[y-x][x])","output":"quadratic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(200001)]\npp=[0]*200001\ndef SieveOfEratosthenes(n=200000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\nn=int(input())\na=list(map(int,input().split()))\nif n==1:\n    print(1)\n    sys.exit(0)\ndp=[[-1 for j in range (5)] for i in range (n)]\nfor i in range (1,min(2,n)):\n    if a[i]<a[i-1]:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k>j:\n                    ch=k\n            dp[i][j]=ch\n    elif a[i]>a[i-1]:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k<j:\n                    ch=k\n            dp[i][j]=ch\n    else:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k!=j:\n                    ch=k\n            dp[i][j]=ch\nfor i in range (2,n):\n    if a[i]<a[i-1]:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k>j and dp[i-1][k]!=-1:\n                    ch=k\n            dp[i][j]=ch\n    elif a[i]>a[i-1]:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k<j and dp[i-1][k]!=-1:\n                    ch=k\n            dp[i][j]=ch\n    else:\n        for j in range (5):\n            ch=-1\n            for k in range (5):\n                if k!=j and dp[i-1][k]!=-1:\n                    ch=k\n            dp[i][j]=ch\n\nind=-1\nfor i in range (5):\n    if dp[-1][i]!=-1:\n        ind=i\nif ind==-1:\n    print(ind)\n    sys.exit(0)\nres=[ind+1]\nfor i in range (n-1,0,-1):\n    res.append(dp[i][ind]+1)\n    ind=dp[i][ind]\nprint(*res[::-1])","output":"linear"},{"instruction":"R,G,B=list(map(int,input().split()))\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\ndp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]\nans=0\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])\n            if i<R and k<B:\n                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])\n            if k<B and j<G:\n                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])\n            ans=max(ans,dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"from sys import stdin, stdout\nimport math\nimport heapq\nfrom itertools import accumulate\n\nQ = int(input())\n\nfour = []\n\nfor i in range(62):\n    four.append(4**i)\n\nfor i in range(Q):\n    N,K = [int(x) for x in stdin.readline().split()]\n\n    tmp_N = N\n    if N>=60:\n        N = 60\n\n    dk = (4**(N)-1)\/\/3\n    if K>dk:\n        print('NO')\n        continue\n\n    seq = []\n    block = []\n    s = 0\n    for i in range(N):\n        s += 2**(i+1) - 1\n        block.append(2**(i+1)-1)\n        seq.append(s)\n\n    if K>=seq[-1]:\n        print('YES',0)\n        continue\n\n    for i in range(N-1):\n        if K>=seq[i] and K<seq[i+1]:\n            d = K-seq[i]\n            happy = tmp_N-i-1\n            round = i+1\n            break\n\n    block = block[::-1]\n\n    res = 0\n    for i in range(round):\n        A = (4**(i+1)-1)\/\/3\n        B = block[i] - 2\n        res += A*B\n\n    if d<=res:\n        print('YES',happy)\n    else:\n        print('NO')","output":"logn"},{"instruction":"i = int(input())\ns = input().split()\n\nl = []\nfor j in s:\n    if not l or  int(j)%2 != l[-1]:\n        l.append(int(j)%2)\n    else:\n        l.pop()\n\nif len(l) < 2:\n    print('YES')\nelse:\n    print('NO')","output":"linear"},{"instruction":"n,k=map(int,input().split())\na=list(map(int,input().split()))\nt=list(map(int,input().split()))\nans=0\nm=0\nfor i in range(n):\n    if t[i]:\n        ans+=a[i]\n        a[i]=0\ncf=[0]*(n+1)\nfor i in range(1,n+1):\n    cf[i]=cf[i-1]+a[i-1]\nfor i in range(n-k+1):\n    m=max(m,cf[i+k]-cf[i])\nprint(ans+m)","output":"linear"},{"instruction":"import sys\nimport math\n\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:\/Competitive Programming\/input.txt', 'r')\n    outputfile = open('W:\/Competitive Programming\/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\nmod=1000000007\n\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n\nt=1\nfor tt in range(t):\n\n    n,k= map(int, sys.stdin.readline().split(' '))\n    a=list(map(int,sys.stdin.readline().split(' ')))\n    a.sort()\n\n    ans=0\n    c=1\n\n    for i in range(n):\n    \tif(c>a[n-1] or c>a[i]):\n    \t\tans+=a[i]-1\n    \t\tcontinue\n    \tif(i!=n-1):\n    \t\tans+=a[i]-1\n    \t\tc+=1\n    \telse:\n    \t\tans+=c-1\n    print(ans)\n\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()","output":"nlogn"},{"instruction":"import math\n\nln = [int(i) for i in input().split(\" \")]\n\nn = ln[0]\nm = ln[1]\nk = ln[2]\n\np = [int(i) for i in input().split(\" \")]\n\ni = 0\nct = 0\nops = 0\nwhile i < len(p):\n    nm = p[i] - ct\n    if nm % k == 0:\n        mnm = nm\n    else:\n        mnm = (nm \/\/ k) * k + k\n    si = i\n    while p[i] - ct <= mnm:\n        i += 1\n        if i >= len(p):\n            break\n    ct += i - si\n    ops += 1\n    if i >= len(p):\n        break\nprint(ops)","output":"linear"},{"instruction":"n = int(input())\na = [int(i) for i in input().split()]\na.sort()\nflag = 0\nfor i in range(n-1):\n\tif(a[i] == a[i+1]):\n\t\tif(flag == 1):\n\t\t\tflag = 2\n\t\t\tbreak\n\t\tflag = 1\n\t\tindex = i\n\t\tif(i+2<n and a[i+1] == a[i+2]):\n\t\t\tflag = 2\n\t\t\tbreak\n\t\telif(i>0 and a[i-1] == a[i]-1):\n\t\t\tflag = 2\n\t\t\tbreak\nif(flag == 2):\n\tprint(\"cslnb\")\nelif(flag ==1 and a[index] ==0):\n\tprint(\"cslnb\")\nelse:\n\tmoves=0\n\tfor i in range(n):\n\t\tif(a[i] == i):\n\t\t\tcontinue\n\t\telif(a[i]<i):\n\t\t\tcontinue\n\t\telse:\n\t\t\tmoves += (a[i] - i)\n\tif(moves%2 == 0):\n\t\tprint(\"cslnb\")\n\telse:\n\t\tprint(\"sjfnb\")","output":"nlogn"},{"instruction":"import math\nn, r = list(map(int, input().split(' ')))\nl = 2 * r * math.sin(math.pi\/n)\nR = l * r \/ (-l + 2*r)\nprint(R)","output":"constant"},{"instruction":"n = int(input())\nif n==0:\n    print(*[0,0,0])\nelif n==1:\n    print(*[0,0,1])\nelse:\n    prev2 = 0\n    prev1 = 1\n    prev = 1\n    while prev!=n:\n        curr = prev+prev1\n        prev2 = prev1\n        prev1 = prev\n        prev = curr\n    print(*[0,prev2,prev1])","output":"constant"},{"instruction":"n = int(input())\nr = 1\nt = sum(map(int, input().split()))\nfor i in range(n - 1):\n    if sum(map(int, input().split())) > t:\n        r += 1\n\nprint(r)","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])","output":"cubic"},{"instruction":"n, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r] * n\nfor i in range(n):\n    for j in range(i):\n        if not (abs(x[i] - x[j]) > 2 * r):\n            y[i] = max(y[i], (4 * r ** 2 - (x[i] - x[j]) ** 2) ** 0.5 + y[j])\nfor i in y:\n    print(i, end=' ')","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\n\nprint((k + n - 1) \/\/ n)","output":"constant"},{"instruction":"n,k=map(int,input().split())\nif k>n+(n-1):\n    print(0)\nelse:\n    if k<=n:\n        print((k-1)\/\/2)\n    else:\n        x=n-(k-n)\n        print((x+1)\/\/2)","output":"constant"},{"instruction":"MAX = 100001\nparent = []\n\ndef makeSet():\n    global parent\n    parent = [i for i in range(MAX + 1)]\n\ndef findSet(u):\n    global parent\n    if u != parent[u]:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nmakeSet()\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\npos = dict()\nfor i in range(n):\n    pos[p[i]] = i + 1\n\nfor i in range(n):\n    unionSet(i + 1, pos.get(a - p[i], n + 1))\n    unionSet(i + 1, pos.get(b - p[i], 0))\n\nA = findSet(0)\nB = findSet(n + 1)\n\nif A != B:\n    print('YES')\n    for i in range(1, n + 1):\n        if findSet(i) == B:\n            print('1', end = \" \")\n        else:\n            print('0', end = \" \")\nelse:\n    print('NO')","output":"linear"},{"instruction":"n, v = map(int, input().split())\n\nresult = v-1 + (n-v)*(n-v+1)\/\/2 if n-1 > v else n-1\nprint(result)","output":"constant"},{"instruction":"def main():\n    n, d, k = map(int, input().split())\n    r, odd = divmod(d, 2)\n    k -= 1\n    cap = d + 1 if k == 1 else 1\n    if k > 1:\n        cap = 2 * (k ** (r + 1) - 1) \/\/ (k - 1) if odd else 1 + (k + 1) * (k ** r - 1) \/\/ (k - 1)\n    if n == 1 or k < 1 < n - 1 or k == 1 and d != n - 1 or d >= n or k > 1 and not d < n <= cap:\n        print('NO')\n        return\n\n    def dfs(parent, depth):\n        stack = []\n        for _ in range(k - 1):\n            child = rest.pop()\n            res.append('%s %s' % (parent, child))\n            if depth:\n                stack.append((child, depth))\n        while stack:\n            parent, depth = stack.pop()\n            depth -= 1\n            for _ in range(k):\n                child = rest.pop()\n                res.append('%s %s' % (parent, child))\n                if depth:\n                    stack.append((child, depth))\n\n    res = ['YES']\n    for pc in enumerate(range(2, d + 2), 1):\n        res.append('%d %d' % pc)\n    rest = list(range(n, d + 1, -1))\n    try:\n        for p in range(r + 1, r + odd + 2):\n            dfs(p, r - 1)\n        for de, p, q in zip(range(r - 2, -1, -1), range(r, 1, -1), range(r + odd + 2, d + 1)):\n            dfs(p, de)\n            dfs(q, de)\n    except IndexError:\n        pass\n    print('\\n'.join(res))\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"n,s = map(int,input().split())\nt=[[0,0]]\nfor j in range(n):\n\n    a,b = map(int,input().split())\n\n    total = a*60+b\n\n    last = t[-1][0]*60+t[-1][1]+1\n\n    t.append([a,b])\n\n    if j==0:\n        if total>= s+1:\n            print(0,0)\n            break\n    if total-last > 2*s:\n        u = last+s\n        print(u\/\/60, u%60)\n        break\n\n    if j==n-1:\n        x = t[-1][0]*60+t[-1][1]\n        print((x+s+1)\/\/60 ,(x+s+1)%60 )\n        break","output":"linear"},{"instruction":"n=input()\ni=0\nwhile(True):\n    if (n-9*10**i*(i+1))<=0:\n        break\n    n-=9*10**i*(i+1)\n    i+=1\n\na=n\/(i+1)\nb=n%(i+1)\nif(b!=0):\n    print(str(10**i+a)[b-1])\nelse:\n    print(str(10**i+a-1)[-1])","output":"logn"},{"instruction":"n, s = map( int, input().split() )\n\nans = 0\nwhile s > 0:\n    a = s \/\/ n\n    s -= n * a\n    ans += a\n    n -= 1\n\nprint( ans )","output":"linear"},{"instruction":"n,k = map(int,input().split())\nt = input()\nif n==1:\n    print(t*k)\nelse:\n    i = len(t)-1\n    while i>0 and t[-i:] != t[:i]:\n            i-=1\n    t2 = t[i:]\n    print(t+t2*(k-1))","output":"quadratic"},{"instruction":"n= int(input())\nb = [int(_) for _ in input().split()]\nd = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]\n\ndef f(i, j):\n\tif d[i][j] != -1:\n\t\treturn d[i][j]\n\td[i][j] = 0\n\tfor m in range(i, j):\n\t\tl = f(i, m)\n\t\tif f(m+1, j) == l and l:\n\t\t\td[i][j] = l+1\n\t\t\tbreak\n\treturn d[i][j]\n\na = [_ for _ in range(1, n+1)]\nfor e in range(1, n):\n\tfor s in range(e+1):\n\t\tif f(s, e):\n\t\t\ta[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))\nprint(a[-1])","output":"cubic"},{"instruction":"def my_pow(a, n, m):\n\tif (n == 0) : return 1\n\tans = my_pow(a, n \/\/ 2, m)\n\tif (n % 2 == 0):\n\t\treturn ans * ans % m\n\telse:\n\t\treturn (ans * ans * a) % m\n\nx, k = map(int, input().split())\nif (x == 0):\n\tprint(0)\nelse:\n\tmod = 10**9 + 7\n\tx *= 2\n\tans = (x - 1) * my_pow(2, k, mod) + 1\n\tans %= mod\n\tans += 2 * mod\n\tprint(ans % mod)","output":"logn"},{"instruction":"n = int(input())\nif n == 1:\n    print(5)\nelse:\n    print(25)","output":"constant"},{"instruction":"def main():\n    n, k = map(int, input().split())\n    n -= 1\n    k -= 1\n    if n == 0:\n        minSplitters = 0\n    elif n <= k:\n        minSplitters = 1\n    elif n > sum_consecutive(k):\n        minSplitters = -1\n    else:\n        minSplitters = min_splitters(n, k)\n\n    print(minSplitters)\n\ndef min_splitters(n, k):\n    low, high = 1, k\n    while low < high:\n        mid = (low + high) \/\/ 2\n        summation = sum_consecutive2(mid, k)\n        if summation == n:\n            return k - mid + 1\n        elif summation > n:\n            low = mid + 1\n        else:\n            high = mid\n\n    return k - low + 2\n\ndef sum_consecutive(num):\n    return int(0.5 * num * (num + 1))\n\ndef sum_consecutive2(num1, num2):\n    return sum_consecutive(num2) - sum_consecutive(num1 - 1)\n\nif __name__ == '__main__':\n    main()","output":"logn"},{"instruction":"n = int(input())\nl = list(map(int, input().split()))\nodd = 0\nfor i in range(n):\n    for j in range(i, n):\n        if(l[i]>l[j]): odd ^= 1\n\nm = int(input())\nans = []\nfor i in range(m):\n    ll, r = map(int, input().split())\n    k = r-ll+1\n    if( (k*(k-1)\/2) %2): odd ^= 1\n    ans.append( \"odd\" if odd else \"even\")\n\nprint('\\n'.join(ans))","output":"quadratic"},{"instruction":"n=int(input())\narr=[]\nfor i in range(n):\n    arr.append(input())\n\narr.sort(key=lambda x: len(x))\nflag=False\nfor i in range(n-2,-1,-1):\n    if arr[i] not in arr[i+1]:\n        flag=True\n        break\n\nif flag:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in arr:\n        print(i)","output":"nlogn"},{"instruction":"my_list = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"yellow\":\"Mind\", \"red\":\"Reality\"}\n\nn = int(input())\nfor i in range(n):\n    my_list.pop(input())\n\nprint(len(my_list))\nfor i in my_list:\n    print(my_list[i])","output":"constant"},{"instruction":"l1,r=map(int,input().split())\nif(l1==r):\n    print(0)\nelse:\n    if(r&(r-1)==0):\n        print(r^(r-1))\n    else:\n        x=l1^r\n        p1=1\n        while(p1<=x):\n            p1*=2\n        print(p1-1)","output":"logn"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\nans = 0\nfor i in range(2, n):\n    for j in range(2 * i, n + 1, i):\n        ans += j \/\/ i\nprint(ans * 4)","output":"nlogn"},{"instruction":"n , s = map(int , input().split())\nlst = []\nfor i in range(n):\n    lst.append(list(map(int , input().split())))\nlst = sorted(lst , key =lambda x : x[0] , reverse = True)\nprev , ans = s , 0\nfor i in range(n):\n    ans += prev -lst[i][0]\n    if ans < lst[i][1]:\n        ans += (lst[i][1]- ans)\n\n    prev = lst[i][0]\nprint(ans+prev)","output":"linear"},{"instruction":"from math import factorial\ndrazil = input()\ndreamoon = input()\nnet_drazil = 0\nnet_dreamoon = 0\nuncretain_count = 0\nfor i in drazil:\n    if i == '-':\n        net_drazil -= 1\n    else:\n        net_drazil += 1\nfor i in dreamoon:\n    if i == '-':\n        net_dreamoon -= 1\n    elif i == '+':\n        net_dreamoon += 1\n    else:\n        uncretain_count += 1\nx = (uncretain_count + (net_drazil - net_dreamoon)) \/\/ 2\ny = (uncretain_count - (net_drazil - net_dreamoon)) \/\/ 2\n\nif abs(x) + abs(y) != uncretain_count:\n    print(0.0)\nelse:\n    out = factorial(uncretain_count)\/\/(factorial(x)*factorial(uncretain_count-x))\n    print(out\/2**uncretain_count)","output":"np"},{"instruction":"import os\nimport sys\nfrom io import BytesIO ,IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\ndef ssinp(): return input()\n\ndef iinp(): return int(input())\n\ndef nninp(): return map(int ,input().split())\n\ndef llinp(): return list(map(int ,input().split()))\n\ndef p(xyz): print(xyz)\ndef p2(a ,b): print(a ,b)\nimport math\n\nfrom collections import OrderedDict\n\na=llinp()\nans=0\nfor i in range(14):\n    temp=a.copy()\n    nos=temp[i]\n    temp[i]=0\n    for j in range(i+1,14):\n        temp[j]+=1\n        nos-=1\n    for j in range(0,14):\n        temp[j]+=nos\/\/14\n    nos=nos%14\n    j=0\n    while(nos!=0):\n        temp[j]+=1\n        nos-=1\n        j+=1\n    ans1=0\n    for c in temp:\n        if(c%2==0):\n            ans1+=c\n    ans=max(ans,ans1)\np(ans)","output":"constant"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, K = map(int, input().split())\nS = [-1 if a == \"?\" else ord(a) - 97 for a in input()]\nII = {1 << i: i for i in range(20)}\ndef calc(mmm):\n    inf = 300000\n    X = [[0] * N for _ in range(K)]\n    for k in range(K):\n        Xk = X[k]\n        mi = inf\n        r = 0\n        for i in range(N)[::-1]:\n            if S[i] < 0 or S[i] == k:\n                r += 1\n            else:\n                r = 0\n            if r >= mmm:\n                mi = min(mi, i + mmm)\n            Xk[i] = mi\n\n    Y = [0] * (1 << K)\n    for i in range(1, 1 << K):\n        mi = inf\n        for j in range(K):\n            if i >> j & 1:\n                ii = i ^ (1 << j)\n                if Y[ii] < N:\n                    mi = min(mi, X[j][Y[ii]])\n        Y[i] = mi\n    return 1 if Y[-1] < inf else 0\n\nl, r = 0, N \/\/ K + 1\nwhile r - l > 1:\n    m = l + r >> 1\n    if calc(m):\n        l = m\n    else:\n        r = m\nprint(l)","output":"np"},{"instruction":"import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\nDEBUG = False\n\ndef bisect_f(f, lo, hi):\n    if DEBUG:\n        assert f(lo) and not f(hi)\n    while hi - lo > 1:\n        mid = (lo + hi) \/\/ 2\n        if f(mid):\n            lo = mid\n        else:\n            hi = mid\n        if DEBUG:\n            assert f(lo) and not f(hi)\n    if DEBUG:\n        assert hi - lo == 1\n        assert f(lo) and not f(hi)\n    return lo\n\ndef solve(N, M, arrs):\n    def isPossible(target):\n        possible = set()\n        for arr in arrs:\n            mask = 0\n            for pos, x in enumerate(arr):\n                if x >= target:\n                    mask += 1 << pos\n            possible.add(mask)\n        allMask = (1 << M) - 1\n        for mask1 in possible:\n            for mask2 in possible:\n                if mask1 | mask2 == allMask:\n                    return (mask1 << 8) + mask2\n        return 0\n\n    lo = min(arrs[0])\n    hi = 10 ** 9 + 1\n    index = bisect_f(isPossible, lo, hi)\n\n    mask1, mask2 = divmod(isPossible(index), 1 << 8)\n    ans = [-1, -1]\n    for i, arr in enumerate(arrs):\n        mask = 0\n        for pos, x in enumerate(arr):\n            if x >= index:\n                mask += 1 << pos\n        if mask == mask1:\n            ans[0] = str(i + 1)\n        if mask == mask2:\n            ans[1] = str(i + 1)\n    return \" \".join(ans)\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    arrs = [[int(x) for x in input().split()] for i in range(N)]\n    ans = solve(N, M, arrs)\n    print(ans)","output":"np"},{"instruction":"n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2002)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2002):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])","output":"cubic"},{"instruction":"from collections import Counter\na = input()\nb = input()\nif len(a) < len(b):\n    print(''.join(sorted(a)[::-1]))\n    exit()\nn = len(a)\ncnt = Counter(a)\ndef f(i = 0, check = False):\n    if i == n: return []\n    for j in sorted(cnt)[::-1]:\n        if (check or j <= b[i]) and cnt[j]:\n            cnt[j] -= 1\n            res = f(i + 1, check or j < b[i])\n            if len(res) + i + 1 == n:\n                res.append(j)\n                return res\n            cnt[j] += 1\n    return []\nprint(''.join(f()[::-1]))","output":"cubic"},{"instruction":"import math\nimport random\nimport heapq,bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\nclass SegmentTree1:\n    def __init__(self, data, default=2**51, func=lambda a, b: a & b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a,b:max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n \/\/ 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) \/ 2)\n\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return count\n\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n \/\/= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    leftGreater = n\n\n    while (l <= r):\n        m = int(l + (r - l) \/ 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        else:\n            l = m + 1\n\n    return (n - leftGreater)\n\nfor ik in range(1):\n    n,k=map(int,input().split())\n    cards=list(map(int,input().split()))\n    l=list(map(int,input().split()))\n    h=list(map(int,input().split()))\n    h=[0]+h\n    count=defaultdict(int)\n    rt=defaultdict(int)\n    def find(x,y):\n        dp=[[0 for i in range(y+1)]for i in range(x+1)]\n        for i in range(1,x+1):\n            for j in range(y+1):\n                for t in range(min(j+1,k+1)):\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-t]+h[t])\n        return dp[x][y]\n    for i in range(n*k):\n        count[cards[i]]+=1\n    for i in range(n):\n        rt[l[i]]+=1\n    ans=0\n    for i in rt:\n        if count[i]==0:\n            continue\n        ans+=find(rt[i],count[i])\n    print(ans)","output":"cubic"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\nfigures=[\n  ((0,0),(0,1),(1,0)),\n  ((0,0),(0,1),(1,1)),\n  ((0,1),(1,0),(1,1)),\n  ((0,0),(1,0),(1,1)),\n]\n\nboard=[]\nfor _ in range(2):\n  s=rl()\n  board.append(list(s))\n\nn=len(board[0])\n\nans=0\nfor j in range(n-1):\n  for fig in figures:\n    ok=1\n    for fi,fj in fig:\n      if board[fi][j+fj]=='X':\n        ok=0\n        break\n    if not ok:\n      continue\n    ans+=1\n    for fi,fj in fig:\n      board[fi][j+fj]='X'\n\nprint(ans)","output":"constant"},{"instruction":"def my_solve(n, m, graph, mask):\n\tif do_dfs_bool(n,graph,mask.copy()):\n\t\tc = get_cyclic(n, graph, mask)\n\t\tfor u,v in c:\n\t\t\tgraph[u].remove(v)\n\t\t\tif not do_dfs_bool(n,graph,mask.copy()):\n\t\t\t\treturn 'YES'\n\t\t\tgraph[u].append(v)\n\t\treturn \"NO\"\n\treturn \"YES\"\n\ndef get_cyclic(n, graph, mask):\n\tc,v = do_dfs(n,graph,mask)\n\tpath = []\n\ti = 0\n\tbegin = False\n\tif c:\n\t\tfor u in c.keys():\n\t\t\tif c[u] == v:\n\t\t\t\tbegin = True\n\t\t\t\tpath.append((c[u],u))\n\t\t\telif begin:\n\t\t\t\tpath.append((c[u],u))\n\t\ttmp = list(c.keys())\n\t\tif len(tmp):\n\t\t\tpath.append((tmp[-1],v))\n\treturn path\n\ndef do_dfs_bool(n, graph, mask):\n\tcolors = [0]*(n+5)\n\tfor u in graph.keys():\n\t\tif not u in mask.keys():\n\t\t\tif dfs_bool(u,graph,mask,colors):\n\t\t\t\treturn True\n\treturn False\n\ndef dfs_bool(u, graph, mask,colors):\n\tcolors[u] = 1\n\tmask[u] = True\n\tfor v in graph[u]:\n\t\tif colors[v] == 1:\n\t\t\treturn True\n\t\tif colors[v] == 0:\n\t\t\tif dfs_bool(v,graph,mask,colors):\n\t\t\t\treturn True\n\tcolors[u] = 2\n\treturn False\n\ndef do_dfs(n, graph, mask):\n\tcolors = [0]*(n+5)\n\tc = {}\n\tfor u in graph.keys():\n\t\tif not u in mask.keys():\n\t\t\tc = {}\n\t\t\tp, v = dfs(u,graph,mask,c,colors)\n\t\t\tif p and v:\n\t\t\t\treturn (p,v)\n\ndef dfs(u, graph, mask, c, colors):\n\tcolors[u] = 1\n\tfor v in graph[u]:\n\t\tif colors[v] == 1:\n\t\t\treturn (c, v)\n\t\tif colors[v] == 0:\n\t\t\tc[v] = u\n\t\t\tp,w = dfs(v,graph,mask,c,colors)\n\t\t\tif w:\n\t\t\t\treturn (p,w)\n\tcolors[u] = 2\n\tif len(c) > 0:\n\t\tif u in c.keys():\n\t\t\tdel c[u]\n\treturn (c, None)\n\ndef test(n, m, edges):\n\tgraph = {}\n\tmask = {}\n\tfor u,v in edges:\n\t\tif u not in graph.keys():\n\t\t\tgraph[u] = []\n\t\tgraph[u].append(v)\n\t\tif v not in graph.keys():\n\t\t\tgraph[v] = []\n\treturn my_solve(n, m, graph, mask)\n\nif __name__ == '__main__':\n\tn,m = [int(x) for x in input().split()]\n\tedges = []\n\tfor i in range(0,m):\n\t\tu,v = [int(x) for x in input().split()]\n\t\tedges.append((u,v))\n\tprint(test(n, m, edges))","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nnums = list(map(int, input().split()))\ncounts = [{} for _ in range(11)]\nfor n in nums:\n    a = n\n    for i in range(11):\n        r = a % k\n        try:\n            counts[i][r] += 1\n        except KeyError:\n            counts[i][r] = 1\n        a *= 10\nres = 0\nfor i in nums:\n    wo = str(i)\n    le = len(wo)\n    mimo = (k-(i % k)) % k\n    if mimo in counts[le]:\n        res += counts[le][mimo]\n        if int(wo+wo) % k == 0:\n            res -= 1\nprint(res)","output":"nlogn"},{"instruction":"import heapq\n\ndef read_int():\n    return int(input().strip())\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\ndef solve():\n\n    R, G, B = read_ints()\n    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]\n\n    Rs = read_ints()\n    Gs = read_ints()\n    Bs = read_ints()\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n    answer = 0\n    for r in range(R+1):\n        for g in range(G+1):\n            for b in range(B+1):\n                if r > 0 and g > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])\n                if g > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])\n                if r > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])\n                answer = max(answer, dp[r][g][b])\n    return answer\n\nif __name__ == '__main__':\n    print(solve())","output":"cubic"},{"instruction":"import os,sys,math\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return len(a)\n\ndef solve():\n    n,m,k=In()\n\n    rt,do=[list(In()) for i in range(n)],[list(In()) for i in range(n-1)]\n\n    dp=[[0]*m for i in range(n)]\n    if k%2==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    k\/\/=2\n    dp_next=[[P]*m for i in range(n)]\n    for op in range(k):\n        for i in range(n):\n            for j in range(m):\n                ans=Inf\n                if i!=0:\n                    ans=min(ans,dp[i-1][j]+do[i-1][j])\n                if j!=0:\n                    ans=min(ans,dp[i][j-1]+rt[i][j-1])\n                if i!=n-1:\n                    ans = min( ans , dp[i+1][j]+do[i][j])\n                if j!=m-1 :\n                    ans=min( ans , dp[i][j+1]+rt[i][j])\n                dp_next[i][j]=ans\n\n        for i in range(n):\n            for j in range(m):\n                dp[i][j]=dp_next[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j],end=' ')\n        print()\n\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n\nM = 998244353\nP = 1000000007\nInf=float('inf')\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef print(*args, **kwargs):\n\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"ints=[int(x) for x in input().split()]\nn=ints[0]\nm=ints[1]\nk=ints[2]\nspecial=[int(x) for x in input().split()]\nnumOn=0\nnumOps=0\nwhile numOn<m:\n    numOps+=1\n    op=((special[numOn]-numOn-1)\/\/(k))*k+k+numOn+1\n    while numOn<m and special[numOn]<op:\n        numOn+=1\nprint(numOps)","output":"linear"},{"instruction":"import sys\n\nn, m, k = list(map(int,sys.stdin.readline().strip().split()))\np = list(map(int,sys.stdin.readline().strip().split()))\ni = 0\nc = 0\nd = 0\nwhile i < m:\n    c = c + 1\n    d2 = d\n    x = k*((p[i]-d2-1)\/\/k) + k\n    while p[i]-d2 <= x:\n        i = i + 1\n        d = d + 1\n        if i == m:\n            break\nprint(c)","output":"linear"},{"instruction":"n = int(input())\narr = set(map(int,input().split()))\n\ndef solve():\n    for i in arr:\n        for k in range(31):\n            if i - (1 << k) in arr and i + (1 << k) in arr:\n                return [i - (1 << k), i, i + (1 << k)]\n    for i in arr:\n        for k in range(31):\n            if i + (1 << k) in arr:\n                return [i, i + (1 << k)]\n\n    for i in arr:\n        return [i]\n\nlst = solve()\n\nprint(len(lst))\nprint(*lst)","output":"nlogn"},{"instruction":"n,tar=[int(i) for i in input().split()]\na=[int(i) for i in input().split()]\n\nfrom collections import defaultdict\nd=defaultdict(lambda:[])\ncount=0\nfor i in range(n):\n    d[a[i]].append(i)\n    if a[i]==tar:\n        count+=1\n\npresum=[1 if a[0]==tar else 0]\nfor e in a[1:]:\n    if e==tar:\n        presum.append(presum[-1]+1)\n    else:\n        presum.append(presum[-1])\n\nfinal = 0\nfor k,v in d.items():\n    if k==tar:\n        continue\n\n    t=1\n    tt=1\n    for i in range(1,len(v)):\n        ind=v[i]\n        preind=v[i-1]\n\n        t -= presum[ind] - presum[preind]\n        t=max(t,0)\n        t+=1\n        tt=max(tt,t)\n\n    final=max(final,tt)\n\nprint(final + count)","output":"linear"},{"instruction":"import sys\ndef getSum(a):\n    sum1 = a * (a + 1) \/\/ 2\n    return sum1\ndef getSumOfTwo(a, b):\n    if a <= 1:\n        return getSum(b)\n    return getSum(b) - getSum(a - 1)\n\nn, k = [int(elem) for elem in input().split()]\nif n == 1:\n    print(0)\n    sys.exit(0)\nif n <= k:\n    print(1)\n    sys.exit(0)\nif getSum(k - 1) < n - 1:\n    print(-1)\n    sys.exit(0)\n\nn -= 1\nk -= 1\nleft, right = 1, k\nwhile left < right:\n    mid = (left + right) \/\/ 2\n    sum1 = getSumOfTwo(mid, k)\n    if sum1 == n:\n        print(k - mid + 1)\n        sys.exit(0)\n    if sum1 > n :\n        left = mid + 1\n    else:\n        right = mid\nprint(k - left + 2)","output":"logn"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) \/\/ 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n\n        pivot = l\n\n        def binary_search(left: int, right: int) -> int:\n            while left <= right:\n                mid = (left + right) \/\/ 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n\n        result = binary_search(0, pivot - 1)\n        if result != -1:\n            return result\n\n        return binary_search(pivot, len(nums) - 1)","output":"logn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    n, m = RL()\n    arr = []\n    for _ in range(n):  arr.append(RLL())\n    res = []\n    def c(num):\n        nonlocal res\n        dic = {}\n        for i in range(n):\n            now = 0\n            for j in range(m):\n\n                if arr[i][j]>=num:\n                    now|=1<<j\n            dic[now] = i+1\n\n        for k, v in dic.items():\n            for kk, vv in dic.items():\n                if k|kk==(1<<m)-1:\n                    res = v, vv\n                    return True\n\n        return False\n\n    l, r = 0, 10**9\n\n    while l<=r:\n        mp = (l+r+1)\/\/2\n        now = c(mp)\n        if now:\n            l = mp+1\n        else:\n            r = mp-1\n\n    print(*res)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"n, k = map(int, input().split())\n\ntm = []\n\nfor _ in range(n):\n    p, t = map(int, input().split())\n    tm.append([p, t])\n\ntm.sort(key=lambda x: (x[0] * -1, x[1]))\nans = tm.count(tm[k-1])\nprint(ans)","output":"nlogn"},{"instruction":"def f():\n    n = int(input())\n    A = [int(s) for s in input().split()]\n    memo = [[None for j in range(n+1)] for i in range(n+1)]\n    for i in range(n):\n        memo[i][i] = [A[i],A[i],1]\n    for l in range(2,n+1):\n        for left in range(0,n-l+1):\n            right = left + l - 1\n            minLen = l\n            shortestMid = right\n            for mid in range(left+1,right+1):\n                pre = memo[left][mid-1]\n                post = memo[mid][right]\n                combLen = pre[2] + post[2]\n                if pre[1]==post[0]:\n                    combLen -= 1\n                if combLen < minLen:\n                    minLen = combLen\n                    shortestMid = mid\n            pre = memo[left][shortestMid - 1]\n            post = memo[shortestMid][right]\n            startEle = pre[0]\n            endEle = post[1]\n            if pre[2] == 1:\n                if pre[0] == post[0]:\n                    startEle = pre[0] + 1\n            if post[2] == 1:\n                if pre[1] == post[0]:\n                    endEle = post[0] + 1\n            memo[left][right] = [startEle, endEle, minLen]\n\n    print(memo[0][n-1][2])\n\nf()","output":"cubic"},{"instruction":"import sys\n\nfrom bisect import bisect_right as lb\nfrom collections import deque\n\nfrom queue import PriorityQueue as pq\nfrom math import *\ninput_ = lambda: sys.stdin.readline().strip(\"\\r\\n\")\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab,bc,cd : ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x : print(x)\nprinT = lambda x : print(x)\nf = lambda : sys.stdout.flush()\ninv =lambda x:pow(x,mod-2,mod)\nmod = 10**9 + 7\n\nn,s = il()\n\nl = s\nh = n\nans = n+1\n\nwhile (l<=h) :\n    m = (l+h)\/\/2\n\n    t = 0\n\n    for i in str(m) :\n        t += int(i)\n\n    if (m-t >= s) :\n        ans = m\n        h = m-1\n    else :\n        l = m+1\n\nprint(n-ans+1)","output":"logn"},{"instruction":"import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    starting=[]\n    ending=[]\n    points=[]\n    for i in range(n):\n        x,y=get_ints()\n        starting.append(x)\n        ending.append(y)\n    ans=0\n    start_count=collections.Counter(starting)\n    end_count=collections.Counter(ending)\n    s=starting.copy()\n    s.sort()\n    e=ending.copy()\n    e.sort()\n    maxim=max(starting)\n    minim=min(ending)\n\n    for i in range(n):\n        if starting[i]==maxim:\n            if start_count[maxim]>1:\n                loc_max=maxim\n            else:\n                pos=bisect.bisect_left(s,maxim)\n                loc_max=s[pos-1]\n        else:\n            loc_max=maxim\n        if ending[i]==minim:\n            if end_count[minim]>1:\n                loc_min=minim\n            else:\n                pos=bisect.bisect_right(e,minim)\n                loc_min=e[pos]\n        else:\n            loc_min=minim\n        ans=max(ans,loc_min-loc_max)\n\n    print(ans)","output":"linear"},{"instruction":"class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if ( board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r \/\/ 3, c \/\/ 3)]):\n                    return False\n\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r \/\/ 3, c \/\/ 3)].add(board[r][c])\n\n        return True","output":"quadratic"},{"instruction":"def cic(my_string):\n\tmy_hash=set();\n\tmax_v=-1<<256;\n\tfor i in range(len(my_string)):\n\t\tempty=my_string[i]+''\n\t\tif empty in my_hash:\n\t\t\tmax_v=max(max_v,len(empty))\n\t\telse:\n\t\t\tmy_hash.add(empty)\n\t\tfor j in range(i+1,len(my_string)):\n\t\t\tempty+=my_string[j]\n\t\t\tif empty not in my_hash:\n\t\t\t\tmy_hash.add(empty)\n\t\t\telse:\n\t\t\t\tmax_v=max(max_v,len(empty))\n\treturn 0 if max_v<0 else max_v\n\ndef main():\n\tmy_string=input()\n\tprint(cic(my_string))\n\nif __name__=='__main__':\n\tmain()","output":"cubic"},{"instruction":"import sys\n\nsys.setrecursionlimit(10**5)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LI1(): return list(map(int1, sys.stdin.buffer.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ninf = 10**16\n\nn, md = LI()\n\ndef nHr(hn, hr):\n    return nCr(hn+hr-1, hr-1)\n\ndef nPr(com_n, com_r):\n    if com_r < 0: return 0\n    if com_n < com_r: return 0\n    return fac[com_n]*ifac[com_n-com_r]%md\n\ndef nCr(com_n, com_r):\n    if com_r < 0: return 0\n    if com_n < com_r: return 0\n    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md\n\nn_max = 405\nfac = [1]\nfor i in range(1, n_max+1): fac.append(fac[-1]*i%md)\nifac = [1]*(n_max+1)\nifac[n_max] = pow(fac[n_max], md-2, md)\nfor i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md\npw = [1]\nfor i in range(400): pw.append(pw[-1]*2%md)\n\ndp = [[0]*(n\/\/2+2) for _ in range(n+2)]\ndp[0][0] = 1\nfor i in range(1, n+2):\n    for j in range(1, n\/\/2+2):\n        v = 0\n        for k in range(i-2, -1, -1):\n            v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md\n        dp[i][j] = v%md\n\nans = sum(dp[-1])%md\nprint(ans)","output":"cubic"},{"instruction":"def solve(n, k):\n\n\tif n >= 60:\n\t\treturn \"YES \" + str(n - 1)\n\n\tmxxx = (4 ** n - 1) \/\/ 3\n\n\tif k > mxxx:\n\t\treturn 'NO'\n\n\tmn, mx = 0, 0\n\n\tfor i in range(n):\n\t\tmn += 2 ** (i + 1) - 1\n\t\tmx += 4 ** i\n\t\tif mn <= k and mx >= k:\n\t\t\treturn \"YES \" + str(n - i - 1)\n\n\tif k >= 22 and k <= 25:\n\t\treturn 'YES ' + str(n - 3)\n\n\tif k == 2:\n\t\tif n >= 2:\n\t\t\treturn 'YES ' + str(n - 1)\n\t\treturn 'NO'\n\n\tif k == 3:\n\t\tif n <= 2:\n\t\t\treturn 'NO'\n\t\treturn 'YES ' + str(n - 1)\n\n\tif k >= 6 and k <= 10:\n\t\treturn 'YES ' + str(n - 2)\n\nt = int(input())\n\nfor i in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))","output":"logn"},{"instruction":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        res = 0\n        nums.sort()\n\n        curr, streak = nums[0], 0\n        i = 0\n        while i < len(nums):\n            if curr != nums[i]:\n                curr = nums[i]\n                streak = 0\n            while i < len(nums) and nums[i] == curr:\n                i += 1\n            streak += 1\n            curr += 1\n            res = max(res, streak)\n        return res","output":"nlogn"},{"instruction":"from itertools import combinations\n\nn,l,r,x = map(int,input().split())\na=list(map(int,input().split()))\n\nc=[]\nfor i in range(2,n+1):\n\tc+=list(combinations(a,i))\n\ncnt=0\n\nfor t in c:\n\tm=min(t)\n\tM=max(t)\n\ts=sum(t)\n\tif M-m >=x and (s>=l and s<=r):\n\t\tcnt+=1\n\nprint(cnt)","output":"np"},{"instruction":"for _ in range(int(input())):\n    s = input()\n    ro=co=0\n    for c in s:\n        if '0'<= c <= '9': ro = 10*ro+int(c)\n        elif ro:\n            ro, co = s[1:].split('C'); co=int(co)\n            v = ''\n            while co:\n                co-=1\n                r = co%26\n                co = co\/\/26\n                v += chr(65+r)\n            print(v[::-1]+ro)\n            break\n        else: co = co*26 + ord(c) - 64\n    else:\n        print(\"R{}C{}\".format(ro, co))","output":"linear"},{"instruction":"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        points.sort(key=lambda p: p[0]**2 + p[1]**2)\n        return points[:k]","output":"nlogn"},{"instruction":"def main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x \/ k) in a:\n            b[x] = b[int(x \/ k)]\n            count[b[int(x \/ k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y \/ 2)\n\n    print(n)\n\nmain()","output":"nlogn"},{"instruction":"def out_edge(x,y):\n    a[x] -= 1\n    a[y] -= 1\n    print(x,y)\n\nn = int(input())\na =list(map(int, input().split()))\nsa = sum(a)\nma = min(a)\nif (sa <2*(n-1)) or (ma<1):\n    print('NO')\n    exit()\n\nverts = sorted(enumerate(a,1), key = lambda x: x[1], reverse= True)\nverts = [list(j) for j in verts]\noutres = []\nfor kk in range(1,n):\n    if  verts[kk-1][1] >= 1:\n        outres.append((verts[kk] [0], verts[kk-1][0]))\n        verts[kk][1] -= 1\n        verts[kk-1][1] -= 1\n    else:\n        break\nelse:\n    kk+=1\n\npath_len = kk\n\nprint('YES', min(n-1, path_len))\n\nreserve_start = 0\nwhile kk < n:\n    if verts[reserve_start][1] >0:\n        outres.append((verts[reserve_start][0], verts[kk][0]))\n        verts[reserve_start][1] -= 1\n        verts[kk][1] -= 1\n        kk +=1\n    else:\n        reserve_start += 1\n\nprint(len(outres))\nfor oo in outres:\n    print(*oo)","output":"nlogn"},{"instruction":"q = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    ans = k\n    sample = \"RGB\"\n    for i in range(n - k + 1):\n        cnt = 0\n        x = 0\n        for j in range(i, i + k):\n            if s[j] != sample[x]:\n                cnt += 1\n            x = (x + 1) % 3\n\n        ans = min(ans, cnt)\n        cnt = 0\n        x = 1\n        for j in range(i, i + k):\n            if s[j] != sample[x]:\n                cnt += 1\n            x = (x + 1) % 3\n        ans = min(ans, cnt)\n\n        cnt = 0\n        x = 2\n        for j in range(i, i + k):\n            if s[j] != sample[x]:\n                cnt += 1\n            x = (x + 1) % 3\n        ans = min(ans, cnt)\n\n    print(ans)","output":"quadratic"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nprime = [True for i in range(200001)]\npp=[0]*200001\ndef SieveOfEratosthenes(n=200000):\n\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\nn,m=map(int, input().split())\na=list(map(int, input().split()))\nt=n\/\/m\nremain=[[] for i in range(m)]\nfor i in range(n):\n    x=a[i]%m\n    remain[x].append(i)\nans=0\nf=[]\nfor i in range(2*m):\n    cur=i%m\n    while len(remain[cur])>t:\n        elm=remain[cur].pop()\n        f.append([elm,i])\n    while len(remain[cur])<t and len(f)!=0:\n        elm,j=f.pop()\n        remain[cur].append(elm)\n        a[elm]+=abs(i-j)\n        ans+=abs(i-j)\nprint(ans)\nprint(*a)","output":"linear"},{"instruction":"def palin(s):\n    global ans\n    if (s[::-1] != s or len(s) == 0):\n        return len(s)\n    else:\n        return palin(s[1:])\ns = input()\nprint(palin(s))","output":"linear"},{"instruction":"from bisect import bisect_left\n\ndef readint():\n    return int(input())\n\ndef readline():\n    return [int(c) for c in input().split()]\n\ndef main():\n    MAX = 10**9\n    n, m = readline()\n    v = sorted([readint() for _ in range(n)])\n\n    h = []\n    for _ in range(m):\n        x1, x2, _ = readline()\n        if x1 == 1:\n            h.append(x2)\n    h.sort()\n\n    lh = len(h)\n    if lh == 0:\n        print(0)\n    elif n == 0:\n        print(lh - bisect_left(h, MAX))\n    else:\n        mn = n + lh - bisect_left(h, MAX)\n        for i in range(n):\n            mn = min(mn, lh - bisect_left(h, v[i]) + i)\n        print(mn)\n\nif __name__ == '__main__':\n    main()","output":"nlogn"},{"instruction":"import sys\n\nclass ADIYWoodenLadder:\n    def solve(self):\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            a = [int(_) for _ in input().split()]\n            a.sort()\n            print(min(a[-2] - 1, n - 2))\n\nsolver = ADIYWoodenLadder()\ninput = sys.stdin.readline\n\nsolver.solve()","output":"nlogn"},{"instruction":"def suma(n):\n    return n*(n+1)\/\/2\n\ndef sumaij(i, j):\n    if i <= 1:\n        return suma(j)\n    return suma(j) - suma(i-1)\n\ndef bin_search_solution(n, k):\n    st, end = 1, k\n    while st < end:\n        mid = (st+end)\/\/2\n        s = sumaij(mid, k)\n        if s == n:\n            return k - mid + 1\n        if s > n:\n            st = mid + 1\n        else:\n            end = mid\n    return k - st + 2\n\ndef solve():\n    n, k = map(int, input().split())\n    if n == 1:\n        print(0)\n    elif k >= n:\n        print(1)\n    else:\n        n -= 1\n        k -= 1\n\n        if suma(k) < n:\n            print(-1)\n        else:\n            res = bin_search_solution(n, k)\n            print(res)\n\nif __name__ == '__main__':\n    solve()","output":"logn"},{"instruction":"import sys, os\n\nif os.environ['USERNAME']=='kissz':\n    inp=open('in.txt','r').readline\n    def debug(*args):\n        print(*args,file=sys.stderr)\nelse:\n    inp=sys.stdin.readline\n    def debug(*args):\n        pass\n\nn,m,k=map(int,inp().split())\nA=[[*map(int,inp().split())] for _ in range(n)]\nB=[[*map(int,inp().split())] for _ in range(n-1)]\nif k%2==0:\n    O=[[[1e12]*m for _ in range(n)] for _ in range(k\/\/2)]\n    for i in range(n):\n        for j in range(m):\n            if i>0:\n                O[0][i][j]=min(O[0][i][j],B[i-1][j])\n            if i<n-1:\n                O[0][i][j]=min(O[0][i][j],B[i][j])\n            if j>0:\n                O[0][i][j]=min(O[0][i][j],A[i][j-1])\n            if j<m-1:\n                O[0][i][j]=min(O[0][i][j],A[i][j])\n\n    for l in range(1,k\/\/2):\n        for i in range(n):\n            for j in range(m):\n                if i>0:\n                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])\n                if i<n-1:\n                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])\n                if j>0:\n                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])\n                if j<m-1:\n                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])\n\n    for i in range(n):\n        print(*[O[-1][i][j]*2 for j in range(m)])\nelse:\n    for i in range(n):\n        print(*[-1]*m)","output":"cubic"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nstate = [list(map(int, input().split())) for _ in range(N)]\n\nAns = {}\n\nl = -1\nr = 10**9+1\nwhile r-l > 1:\n    m = (l+r)\/\/2\n    T = {}\n    for j, S in enumerate(state):\n        bit = 0\n        for i, s in enumerate(S):\n            if s >= m:\n                bit += 1<<i\n        T[bit] = j\n\n    ok = False\n    for bit1 in range(1<<M):\n        for bit2 in range(1<<M):\n            if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T:\n                ok = True\n                Ans[m] = [T[bit1], T[bit2]]\n                break\n        if ok: break\n    if ok:\n        l = m\n    else:\n        r = m\nprint(Ans[l][0]+1, Ans[l][1]+1)","output":"np"},{"instruction":"n=int(input())\ns=['Power','Time','Space','Soul','Reality','Mind']\nfor _ in range(n):\n    i=input()\n    if(i=='purple'):\n        s.remove('Power')\n    elif(i=='green'):\n        s.remove('Time')\n    elif(i=='blue'):\n        s.remove('Space')\n    elif(i=='orange'):\n        s.remove('Soul')\n    elif(i=='red'):\n        s.remove('Reality')\n    elif(i=='yellow'):\n        s.remove('Mind')\nprint(len(s))\nfor i in range(len(s)):\n    print(s[i])\n","output":"constant"},{"instruction":"def iscomposite(value):\n    for i in range(2,value):\n        if(value%i==0):\n            return '1'\n    else:\n        return '0'\n\nn=int(input())\nfor i in range(4,n):\n    a=i\n    b=n-i\n    if(iscomposite(a)=='1' and iscomposite(b)=='1'):\n        print(a,b)\n        break\n    else:\n        continue","output":"constant"},{"instruction":"n=int(input())\nprint(2*n*n-2*n+1)","output":"constant"},{"instruction":"import itertools\nimport bisect\nimport math\nfrom collections import *\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\ndef main():\n    a = li()\n    b = li()\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] == \"0\":\n            ans += 1\n            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:\n                a[i] = b[i] = b[i - 1] = \"X\"\n            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == b[i + 1]:\n                a[i] = b[i] = b[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:\n                a[i] = b[i + 1] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == a[i + 1]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            else:\n                ans -= 1\n    print(ans)\n    pass\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"constant"},{"instruction":"import os\nimport sys\nfrom math import *\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz\/\"\nM = 1000000007\nEPS = 1e-6\n\ndef Ceil(a, b):\n    return a \/\/ b + int(a % b > 0)\n\ndef value():\n    return tuple(map(int, input().split()))\n\ndef array():\n    return [int(i) for i in input().split()]\n\ndef Int():\n    return int(input())\n\ndef Str():\n    return input()\n\ndef arrayS():\n    return [i for i in input().split()]\n\nn = int(input())\nif n == 0:\n    print(0)\nelse:\n    print(n \/\/ 2 + 1 if n % 2 != 0 else n + 1)","output":"constant"},{"instruction":"def inp1():\n    return int(input())\ndef inp2():\n    return list(map(int,input().split()))\ndef inp3():\n    return map(int,input().split())\nif 1:\n\n    n=inp1()\n    x=int(n**0.5)\n    i=0\n    y=n\n    ans=[]\n    while(i<n):\n          arr=[]\n          for j in range(x):\n              if y==0:\n                  break\n              arr.append(y)\n              y-=1\n              i+=1\n              if y==0:\n                  break\n          arr=arr[::-1]\n          for j in arr:\n              ans.append(j)\n    print(*ans)","output":"linear"},{"instruction":"import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\n\nn, a, b = map(int, input().split())\nXV = []\nfor i in range(n):\n    x, vx, vy = map(int, input().split())\n    XV.append((x, vx, vy))\nif a != 0:\n    ans = 0\n    d = defaultdict(lambda:0)\n    dvx = defaultdict(lambda:0)\n    dvy = defaultdict(lambda:0)\n    dvxy = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        k = -a*vx+vy\n        ans += max(0, d[k]-(dvx[(k, vx)]+dvy[(k, vy)]-dvxy[(k, vx, vy)]))\n        d[k] += 1\n        dvx[(k, vx)] += 1\n        dvy[(k, vy)] += 1\n        dvxy[(k, vx, vy)] += 1\n    print(ans*2)\nelse:\n    ans = 0\n    d = defaultdict(lambda:defaultdict(lambda:0))\n    ds = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        ans += max(0, ds[vy]-d[vy][vx])\n        d[vy][vx] += 1\n        ds[vy] += 1\n    print(ans*2)","output":"linear"},{"instruction":"n = int(input())\nl = [4,7,47,74,444,447,474,477,747,744,774,777]\n\nfor i in l:\n    if n % i == 0:\n        print('YES')\n        break\n    else:\n        pass\nelse:\n    print('NO')","output":"constant"},{"instruction":"n,m=map(int, input().split())\nnums = list(map(int, input().split()))\n\nleft = {}\nright = {}\n\nleftl = 0\nleftm = 0\n\nrightl = 0\nrightm = 0\n\nstart = nums.index(m)\n\nans = 1\n\nfor i in range(start-1,-1,-1):\n    if nums[i]>m:\n        leftm += 1\n    else:\n        leftl += 1\n\n    if leftl == leftm:\n        ans += 1\n    elif leftl+1 == leftm:\n        ans += 1\n\n    temp = leftm - leftl\n    if temp in left.keys():\n        left[temp] += 1\n    else:\n        left[temp] = 1\n\nfor i in range(start+1,n,1):\n    if nums[i]>m:\n        rightm += 1\n    else:\n        rightl += 1\n\n    if rightl == rightm:\n        ans += 1\n    elif rightl+1 == rightm:\n        ans += 1\n\n    temp = rightm-rightl\n    if temp in right.keys():\n        right[temp] += 1\n    else:\n        right[temp] = 1\nfor i in left.keys():\n    poss = (-1)*i\n    if poss in right.keys():\n        ans += right[poss]*left[i]\n\n    if poss+1 in right.keys():\n        ans += right[poss+1]*left[i]\n\nprint(ans)","output":"nlogn"},{"instruction":"import os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m = map(int,input().split())\n    x = ((n-5)\/\/4+((n-5)%4!=0))\n    if n <= 5:\n        a,b = '5','5'\n    else:\n        a = '5'*(x+1)\n        b = '4'*x+'5'\n    print(a,b)\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()","output":"constant"},{"instruction":"class Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        time = []\n        for i in intervals:\n            time.append((i.start, 1))\n            time.append((i.end, -1))\n\n        time.sort(key=lambda x: (x[0], x[1]))\n\n        res = count = 0\n        for t in time:\n            count += t[1]\n            res = max(res, count)\n        return res","output":"nlogn"},{"instruction":"n,k = list(map(int,input().split()))\n\nlimit = 998244353\n\nif k > 2*n:\n    print(0)\nelif k == 1 or k == 2*n:\n    print(2)\nelse:\n    same = [0] * (k+1)\n    same[1] = 2\n\n    diff = [0] * (k+1)\n    diff[2] = 2\n\n    for i in range(2, n+1):\n        for j in range(min(k, 2*i), 1, -1):\n\n            same[j] = same[j] + 2*diff[j] + same[j-1]\n            same[j] %= limit\n\n            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]\n            diff[j] %= limit\n\n    print((same[k] + diff[k]) % limit)","output":"np"},{"instruction":"n = int(input())\nlimit_int = limit = decimal = 9\ncount = 0\nwhile True:\n    count += 1\n    if n <= limit:\n        difference = limit - n\n        position = difference % count\n        difference = difference \/\/ count\n        difference = decimal - difference\n        print(''.join(list(reversed(str(difference))))[position])\n        break\n    else:\n        decimal = int(str(limit_int) * (count + 1))\n        limit += int(str(limit_int) + '0' * count) * (count + 1)","output":"constant"},{"instruction":"from math import *\nn,k=map(int,input().split())\nval=int(sqrt(9+(8*(n+k))))\nans=(-3+val)\/\/2\nprint(n-ans)","output":"constant"},{"instruction":"def req(a, b, c, d):\n\n    print(f\"? {a} {b} {c} {d}\")\n    return int(input())\n\ndef bin(l, r, down, left, up, right, tp, tar):\n    while r - l > 1:\n        m = (r + l) \/\/ 2\n\n        if tp == 0:\n            down = m\n        if tp == 1:\n            left = m\n        if tp == 2:\n            up = m\n        if tp == 3:\n            right = m\n\n        if req(down, left, up, right) == tar:\n            l = m\n        else:\n            r = m\n    return [l, r]\n\ndef find_rec(x1, y1, x2, y2) -> list:\n    up_ = bin(x1 - 1, x2 + 1, x1, y1, -2, y2, 2, 0)[1]\n    down_ = bin(x1 - 1, x2 + 1, -2, y1, x2, y2, 0, 1)[0]\n    left_ = bin(y1 - 1, y2 + 1, x1, -2, x2, y2, 1, 1)[0]\n    right_ = bin(left_ - 1, y2 + 1, x1, y1, x2, -2, 3, 0)[1]\n    return [down_, left_, up_, right_]\n\nn = int(input())\n\nl = 0\nr = n + 1\nwhile r - l > 1:\n    m = (l + r) \/\/ 2\n    if req(1, 1, m, n) == 0:\n        l = m\n    else:\n        r = m\n\nrec = []\n\nif r != n and req(r + 1, 1, n, n) == 1:\n    rec.append(find_rec(1, 1, r, n))\n    rec.append(find_rec(r + 1, 1, n, n))\nelse:\n    l = 0\n    r = n + 1\n    while r - l > 1:\n        m = (l + r) \/\/ 2\n        if req(1, 1, n, m) == 0:\n            l = m\n        else:\n            r = m\n    rec.append(find_rec(1, 1, n, r))\n    rec.append(find_rec(1, r + 1, n, n))\nprint('!', *rec[0], *rec[1])","output":"logn"},{"instruction":"n, m, k = map(int, input().split())\nA = list(map(int, input().split()))\nglans = 0\nfor s in range(m):\n    B = []\n    f = s\n    su = 0\n    sus = 0\n    for i in range(s, n):\n        su += A[i]\n        sus = max(sus, su)\n        if (i + 1) % m == s:\n            B.append(sus - k)\n            B.append(su - sus)\n            su = 0\n            sus = 0\n            f = i + 1\n    dob = 0\n    klol = 0\n    for j in range(f, n):\n        dob += A[j]\n        klol = max(klol, dob - k)\n    B = [0] + B + [klol]\n    for i in range(1, len(B)):\n        B[i] += B[i - 1]\n    cnt = -10 ** 10\n    ans = [0, 0]\n    minsum = 10 ** 10\n    candidat = 0\n    for i in range(len(B)):\n        if B[i] - minsum > cnt:\n            cnt = B[i] - minsum\n            ans[1] = i\n            ans[0] = candidat\n        if B[i] <= minsum:\n            minsum = B[i]\n            candidat = i\n    glans = max(glans, B[ans[1]] - B[ans[0]])\nprint(glans)","output":"quadratic"},{"instruction":"n = int(input())\nans = 0\nmod = 998244353\na = list(map(int, input().split()))\np = 1 \/ 2\n\nfor i in range(n):\n    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod\n    p = (2 * p) % mod\n\nprint(int(ans) % mod)","output":"linear"},{"instruction":"x, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    mod = 10 ** 9 + 7\n    p = pow(2, k, mod)\n    ans = (x * (p * 2) - (p - 1)) % mod\n    print(ans)","output":"logn"},{"instruction":"import math\nfrom decimal import Decimal\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) \/ 2\n\nline = input().split()\nn = Decimal(line[0])\nk = Decimal(line[1])\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = math.floor((3 + discriminant) \/ 2)\n    res2 = math.floor((3 - discriminant) \/ 2)\n    res1 = max(res1, res2)\n    print(int(k - res1 + 1));","output":"logn"},{"instruction":"import sys\nimport io, os\ninput = sys.stdin.readline\n\nn = int(input())\nS = [str(input().rstrip()) for i in range(n)]\nfrom collections import defaultdict\nd1 = defaultdict(lambda: 0)\nd2 = defaultdict(lambda: 0)\nans = 0\nfor i, s in enumerate(S):\n    cum1 = 0\n    flag1 = True\n    for c in s:\n        if c == '(':\n            cum1 += 1\n        else:\n            cum1 -= 1\n        if cum1 < 0:\n            flag1 = False\n    if flag1:\n        ans += d2[cum1]\n    cum2 = 0\n    flag2 = True\n    for i in reversed(range(len(s))):\n        c = s[i]\n        if c == ')':\n            cum2 += 1\n        else:\n            cum2 -= 1\n        if cum2 < 0:\n            flag2 = False\n    if flag2:\n        ans += d1[cum2]\n    if cum1 == 0 and cum2 == 0 and flag1 and flag2:\n        ans += 1\n    if flag1:\n        d1[cum1] += 1\n    if flag2:\n        d2[cum2] += 1\n\nprint(ans)","output":"linear"},{"instruction":"from math import ceil\n\nn=int(input())\nr=list(map(int,input().split()))\nl=[-1]\nl.extend(r)\na=['']*(n+1)\nd={}\nrd={}\nind={}\nfor i in range(1,n+1):\n    x=l[i]\n    ind[x]=i\n    d.setdefault(i,[])\n    s=x+i\n    while s<=n:\n        if l[s]>x:\n            d[i].append(s)\n            if s not in rd:\n                rd[s]=[]\n            rd[s].append(i)\n        s+=x\n    s = i-x\n    while s >=1:\n        if l[s] > x:\n            d[i].append(s)\n        s -= x\n\nans=0\n\nfor i in d:\n    if len(d[i])==0:\n        a[i]='B'\n        ans+=1\n\nwhile ans!=n:\n    for i in d:\n        dont=False\n        if a[i]!='':\n            continue\n        for j in d[i]:\n            if a[j]=='B':\n                a[i]='A'\n                ans+=1\n                break\n            if a[j]=='':\n                dont=True\n        else:\n            if not dont:\n                a[i]='B'\n                ans+=1\n\nprint(''.join(a))","output":"nlogn"},{"instruction":"from math import factorial\ns1,s2=input(),input()\na=s1.count('+')-s2.count('+')\nb=s1.count('-')-s2.count('-')\nif(a<0 or b<0):\n    print(0)\n    exit(0)\nans=factorial(a+b)\/factorial(a)\/factorial(b)\nans\/=(2**(a+b))\nprint(\"%.10f\"%ans)","output":"np"},{"instruction":"from __future__ import division\nfrom sys import stdin, stdout\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\nn, s = map(int, stdin.readline().split())\n\nif s % n == 0:\n    write(s \/\/ n)\nelse:\n    write(s \/\/ n + 1)","output":"constant"},{"instruction":"a,b = list(map(int, input().split()))\n\nx = a ^ b\n\nans = 1\nwhile x > 0:\n\n\tx \/\/= 2\n\tans *= 2\n\nprint(ans -1)","output":"logn"},{"instruction":"def main():\n\tl, r = map(int , input().split())\n\tif l == r :\n\t\tprint(0)\n\telse :\n\t\trs = \"\"\n\t\twhile (r):\n\t\t\trs += '1' if r%2 else '0'\n\t\t\tr \/\/= 2\n\t\tfor i in range(len(rs), 65):\n\t\t\trs += '0'\n\n\t\tls = \"\"\n\t\twhile (l):\n\t\t\tls += '1' if l%2 else '0'\n\t\t\tl \/\/= 2\n\t\tfor i in range(len(ls), 65):\n\t\t\tls += '0'\n\n\t\tpos = -1\n\t\tfor i in range(64, -1, -1):\n\n\t\t\tif (rs[i] == '1' and ls[i] == '0'):\n\t\t\t\tpos = i\n\t\t\t\tbreak\n\n\t\tans = 2**(pos+1) - 1\n\t\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()","output":"logn"},{"instruction":"import sys, math\n\nn = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().rstrip()))\nif len(set(arr)) == 1:\n    print('YES')\nelse:\n    val = sum(arr)\n    factor = set()\n    for i in range(1, int(val ** 0.5) + 1):\n        if val % i == 0:\n            factor.add(i)\n            factor.add(val \/\/ i)\n    can = False\n    for i in factor:\n        each = val \/\/ i\n        if 1 < i <= n:\n            idx = 0\n            temp = 0\n            cnt = 0\n            while idx < n:\n                if temp + arr[idx] < each:\n                    temp += arr[idx]\n                elif temp + arr[idx] > each:\n                    temp = 0\n                else:\n                    temp = 0\n                    cnt += 1\n                idx += 1\n            if cnt == i:\n                can = True\n    print('YES' if can else 'NO')","output":"quadratic"},{"instruction":"s1, s2 = input().split()\nans = s1[0]\nfor i in range(1, len(s1)):\n    if s1[i] < s2[0]:\n        ans += s1[i]\n        if i == len(s1) - 1:ans += s2[0]\n    else:\n        ans += s2[0]\n        break\nif len(s1) == 1:print(s1[0] + s2[0])\nelse:print(ans)","output":"linear"},{"instruction":"x=int(input())\ns=input()\n\ndef substring(x,s):\n    count=0\n    ans=0\n\n    for i in range(x):\n        if s[i]==\"x\":\n            count+=1\n        else:\n            if count>=3:\n                ans+=count-2\n            count=0\n    if count>=3:\n        ans+=count-2\n\n    return ans\nprint(substring(x,s))","output":"linear"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nT, = getIntList()\n\nMAXN = 10**18 + 10\ndef getUpper(N):\n    z = 1\n    r = 0\n    for i in range(N):\n        r+=z\n        z*=4\n        if r>MAXN:\n            break\n    return r\nfor _ in range(T):\n    N,K = getIntList()\n    tk = K\n    z = 1\n    for i in range(N):\n        tk -= z\n        z*= 4\n        if tk<0: break\n    if tk>0:\n        print('NO')\n        continue\n    nowcut =  0\n    nt = 1\n    nowupper = 0\n    ok = False\n    for i in range(N):\n        nt *=2\n        nowcut += nt-1\n\n        if nowcut >K: break\n        t = (nt *2 - 3)\n        tu  = t * getUpper(N-1-i)\n        nowupper += tu\n        dprint('bound', nowcut, nowcut+nowupper)\n        if nowcut<=K<= nowcut+nowupper:\n            ok = True\n            break\n    if ok:\n        print('YES', N-1-i)\n    else:\n        print(\"NO\")","output":"quadratic"},{"instruction":"t = int(input())\nfor i in range(t):\n    n, m = [int(item) for item in input().split()]\n    mat = []\n    col = [[] for _ in range(m)]\n    for j in range(n):\n        line = [int(item) for item in input().split()]\n        for k, item in enumerate(line):\n            col[k].append(item)\n        mat.append(line)\n    colmax = []\n    for line in col:\n        colmax.append([max(line), line])\n    colmax.sort(reverse=True)\n    colmax = colmax[:n]\n    ans = 0\n    for j in range(n ** (n-1)):\n        index = j\n        rot = [0]\n        for k in range(n-1):\n            rot.append(index % n)\n            index \/\/= n\n        ret = 0\n        for l in range(n):\n            val = 0\n            for k in range(len(colmax)):\n                val = max(val, colmax[k][1][(l + rot[k]) % n])\n            ret += val\n        ans = max(ans, ret)\n    print(ans)","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().strip().split()))\n\nb = set(a)\nres = len(b)\nif 0 in b:\n    res -= 1\nprint(res)","output":"linear"},{"instruction":"n, m = map(int, input().split())\n\nmp = []\n\nfor i in range(n):\n    line = input().strip()\n\n    mp.append(list(map(lambda c: c == '\n\nmp1 = [[False for _ in range(m)] for _ in range(n)]\n\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        f = all(mp[i - 1][j - k] for k in range(-1, 1+1))\n        f = f and all(mp[i + 1][j - k] for k in range(-1, 1+1))\n        f = f and (mp[i][j - 1] and mp[i][j + 1])\n\n        if not f:\n            continue\n\n        for ik in range(-1, 2):\n            for jk in range(-1, 2):\n                if ik == 0 and jk == 0:\n                    continue\n                mp1[i + ik][j + jk] = True\n\nif all(all(mp[i][j] == mp1[i][j] for j in range(m)) for i in range(n)):\n    print('YES')\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"n=input()\nm={}\ndef podstroka(s:str):\n    for i in range(0,len(s)):\n        for j in range(i+1,len(s)+1):\n            if s[i:j] in m:\n                m[s[i:j]] +=1\n            else:\n                m[s[i:j]] = 1\n    return m\n\npodstroka(n)\n\nmaxlen = 0\nfor x in m:\n    if m[x]>=2 and len(x)>maxlen:\n        maxlen=len(x)\nprint(maxlen)","output":"cubic"},{"instruction":"n,r = map(int,input().split())\nx_coord = list(map(int,input().split()))\nd = {}\nfor i in x_coord:\n    final = r\n\n    for j in range(i-r,i+r+1):\n        check = d.get(j,[-1,-1])\n        if check[0] > 0:\n            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5\n            final = max(potential,final)\n    for j in range(i-r,i+r+1):\n        d[j] = (i,final)\n    print(final)","output":"quadratic"},{"instruction":"input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n\n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)","output":"linear"},{"instruction":"import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\nfrom itertools import permutations\n\nI=sys.stdin.readline\n\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer \/\/ denom\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\treturn False\n\t\treturn True\n\ndef main():\n\tn=ii()\n\tarr=li()\n\tsett=set(arr)\n\tans=[arr[0]]\n\tflag=0\n\tfor x in range(31):\n\t\tfor i in arr:\n\t\t\tif (i-2**x) in sett and (i+2**x) in sett:\n\t\t\t\tans=[i-2**x,i,i+2**x]\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\t\telif i-2**x in sett:\n\t\t\t\tans=[i-2**x,i]\n\t\t\telif i+2**x in sett:\n\t\t\t\tans=[i,i+2**x]\n\n\t\tif flag:\n\t\t\tbreak\n\tprint(len(ans))\n\tprint(*ans)\n\nif __name__ == '__main__':\n\tmain()","output":"nlogn"},{"instruction":"import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n\nfigures=[\n  [(0,0),(0,1),(1,0)],\n  [(0,0),(0,1),(1,1)],\n  [(0,1),(1,0),(1,1)],\n  [(0,0),(1,0),(1,1)],\n]\n\nboard=[]\nfor _ in range(2):\n  s=rl()\n  board.append(list(s))\n\nn=len(board[0])\n\nans=0\nfor j in range(n-1):\n  for fig in figures:\n    ok=1\n    for fi,fj in fig:\n      if board[fi][j+fj]=='X':\n        ok=0\n        break\n    if not ok:\n      continue\n    ans+=1\n    for fi,fj in fig:\n      board[fi][j+fj]='X'\n    break\n\nprint(ans)","output":"constant"},{"instruction":"import sys\n\nmod = 998244353\nMAX_LENGTH = 20\nbound = [0] * MAX_LENGTH\n\ndef mul(a, b): return (a * b) % mod\ndef add(a, b):\n    a += b\n    if a < 0: a += mod\n    if a >= mod: a -= mod\n    return a\n\ndef digitize(num):\n    for i in range(MAX_LENGTH):\n        bound[i] = num % 10\n        num \/\/= 10\n\ndef rec(smaller, start, pos, mask):\n    global k\n    if bit_count[mask] > k:\n        return [0, 0]\n    if pos == -1:\n        return [0, 1]\n\n    if dp[smaller][start][pos][mask][0] != -1:\n        return dp[smaller][start][pos][mask]\n\n    res_sum = res_ways = 0\n    for digit in range(0, 10):\n        if smaller == 0 and digit > bound[pos]:\n            continue\n        new_smaller = smaller | (digit < bound[pos])\n        new_start = start | (digit > 0) | (pos == 0)\n        new_mask = (mask | (1 << digit)) if new_start == 1 else 0\n\n        cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask)\n        res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum))\n        res_ways = add(res_ways, cur_ways)\n\n    dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways\n    return dp[smaller][start][pos][mask]\n\ndef solve(upper_bound):\n    global dp\n    dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)]\n    digitize(upper_bound)\n    ans = rec(0, 0, MAX_LENGTH - 1, 0)\n    return ans[0]\n\ninp = [int(x) for x in sys.stdin.read().split()]\nl, r, k = inp[0], inp[1], inp[2]\n\nbit_count = [0] * (1 << 10)\nfor i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1\nten_pow = [1]\nfor i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10))\n\nprint(add(solve(r), -solve(l - 1)))","output":"cubic"},{"instruction":"from collections import Counter\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])","output":"cubic"},{"instruction":"def good(x1, y1, x2, y2):\n    if (x1 > x2):\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n    return (x2 >= y1)\n\ndef check(cent):\n    for i in range(n):\n        if (not good(cent - t, cent + t, x[i] - a[i], x[i] + a[i])):\n            return 0\n    return 1\n\nn, t = map(int, input().split())\nx = [0] * n\na = [0] * n\nfor i in range(n):\n    x[i], a[i] = map(int, input().split())\n    x[i] *= 2\n\nans = set()\n\nfor i in range(n):\n    val1 = x[i] - a[i] - t\n    val2 = x[i] + a[i] + t\n    if (check(val1)):\n        ans.add(val1)\n    if (check(val2)):\n        ans.add(val2)\nprint(len(ans))","output":"nlogn"},{"instruction":"def isValid(arr, l, r, x):\n\treturn l <= sum(arr) <= r and max(arr)-min(arr) >= x\n\nn, l, r, x = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nvalid = 0\n\nfor i in range(1, 1<<n):\n\ts = str(bin(i))[2:].rjust(n, '0')\n\ttemp = []\n\tfor j in range(n):\n\t\tif s[j] == '1':\n\t\t\ttemp.append(arr[j])\n\tif isValid(temp, l, r, x):\n\t\tvalid += 1\nprint(valid)","output":"np"},{"instruction":"n = int(input())\nans = 1\nfor i in range(n):\n    ans += 4 * i\nprint(ans)","output":"linear"},{"instruction":"t = input()\n\nn = len(t)\n\nmaxi = 0\n\nfor i in range(n):\n    s = t[i]\n    if t.count(s) > 1:\n        maxi = max(maxi, 1)\n    nr = 1\n    for j in range(i + 1, n):\n        s += t[j]\n        nr += 1\n        g = 0\n        for h in range(n - nr + 1):\n            if s == t[h:h + nr]:\n                g += 1\n        if g > 1:\n            maxi = max(nr,maxi)\n\nprint(maxi)","output":"cubic"},{"instruction":"n = int(input())\nans = 1\nfor i in range(1, n):\n    ans += i * 4\nprint(ans)","output":"linear"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nif sum(a[i]==i+1 for i in range(n))>=n\/\/1000:print(\"Petr\")\nelse:print(\"Um_nik\")","output":"nlogn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n\n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n\n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n\n            if l == r:\n                return _e\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n\n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n\n            return _op(sml, smr)\n\n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n\n            l += _size\n            r += _size\n\n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n\n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n\n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n\n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n\n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n\n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n\n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n\n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n\nMIL = 1 << 20\n\ndef makeNode(total, count):\n\n    return (total * MIL) + count\n\ndef getTotal(node):\n    return math.floor(node \/ MIL)\n\ndef getCount(node):\n    return node - getTotal(node) * MIL\n\nnodeIdentity = makeNode(0.0, 0.0)\n\ndef nodeOp(node1, node2):\n    return node1 + node2\n\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n\nidentityMapping = -1\n\ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n\n    count = getCount(node)\n    return makeNode(tag * count, count)\n\ndef composition(mapping1, mapping2):\n\n    return mapping1 if mapping1 != identityMapping else mapping2\n\nprime = [True for i in range(10)]\npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p):\n                pp[i]+=1\n                prime[i] = False\n        p += 1\n\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)\/\/2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n\nn = int(input())\na = list(map(int, input().split()))\ndifficulty = a[0]\nexpectation = a[0] % 998244353\nfor i in range(1, n):\n    expectation = expectation * 2 + difficulty + a[i]\n    difficulty = difficulty * 2 + a[i]\n    expectation %= 998244353\n    difficulty %= 998244353\nprint(expectation)","output":"linear"},{"instruction":"import copy\n\nn,m,k=map(int,input().split())\nA=list(map(int,input().split()))\n\nANS=0\n\nfor i in range(m):\n    B=copy.deepcopy(A)\n    for j in range(i,n,m):\n        B[j]-=k\n\n    NOW=0\n\n    for j in range(i,n):\n        if j%m==i:\n            NOW=max(NOW+B[j],B[j])\n        else:\n            NOW+=B[j]\n\n        ANS=max(ANS,NOW)\n\nprint(ANS)","output":"quadratic"},{"instruction":"R, G, B = list(map(int, input().split()))\nr = sorted([int(x) for x in input().split()], reverse=True)\ng = sorted([int(x) for x in input().split()], reverse=True)\nb = sorted([int(x) for x in input().split()], reverse=True)\n\nans = 0\ndp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n            if j<G and k<B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n            if i<R and k<B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"from sys import stdin, stdout\nfrom itertools import accumulate\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):\n    n,k=lst()\n    a=lst()\n    b=lst()\n    ps=list(accumulate(a))\n    dp=[[0 for _ in range(2)] for _ in range(1+n)]\n    for i in range(1,n+1):\n        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]\n        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])\n\n    print(max(max(v) for v in dp))","output":"linear"},{"instruction":"a = input()\nb = input()\nl = a.count(\"+\")-a.count(\"-\")\nk = b.count(\"?\")\nif k==0:\n    if (b.count(\"+\")-b.count(\"-\"))==l:\n        print(1)\n    else:\n        print(0)\nelse:\n    n=2**k\n    r=k\n    c=[]\n    t=0\n    while r>=0:\n        c.append(r-t)\n        t+=1\n        r-=1\n    import math\n    d=[]\n    for i in range(k+1):\n        d.append((math.factorial(k))\/\/(math.factorial(i)*math.factorial(k-i)))\n    f = b.count(\"+\")-b.count(\"-\")\n    if l-f in c:\n        print((d[c.index(l-f)])\/sum(d))\n    else:\n        print(0)","output":"np"},{"instruction":"n = int(input())\na = list(map(int, input().split()))\ns = set(a)\ns.discard(0)\nprint(len(s))","output":"linear"},{"instruction":"class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        q = deque()\n        last_num, open_groups = -1, 0\n\n        for num in sorted(count):\n            if ((open_groups > 0 and num > last_num + 1) or\n                open_groups > count[num]\n            ):\n                return False\n\n            q.append(count[num] - open_groups)\n            last_num = num\n            open_groups = count[num]\n\n            if len(q) == groupSize:\n                open_groups -= q.popleft()\n\n        return open_groups == 0","output":"nlogn"},{"instruction":"import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef check(x):\n    T1 = T[:x] + '*'\n    T2 = T[x:] + '*'\n    m1 = len(T1)\n    m2 = len(T2)\n\n    dp = list2d(N+1, m1, -1)\n    dp[0][0] = 0\n    for i in range(N):\n        s = S[i]\n        for j in range(m1):\n            k = dp[i][j]\n            if k != -1:\n                dp[i+1][j] = max(dp[i+1][j], k)\n                if T1[j] == s:\n                    dp[i+1][j+1] = max(dp[i+1][j+1], k)\n                if T2[k] == s:\n                    dp[i+1][j] = max(dp[i+1][j], k+1)\n    return dp[N][m1-1] == m2-1\n\nfor _ in range(INT()):\n    S = input()\n    T = input()\n\n    N = len(S)\n    M = len(T)\n    for x in range(M):\n        if check(x):\n            YES()\n            break\n    else:\n        NO()","output":"cubic"},{"instruction":"a, b = map(int, input().split())\nc = input()\nsu = 0\ncnt = 0\nj = -2\ni = 0\nlis = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and cnt < b:\n    if lis[i] in c and i-2 >= j:\n        su += i+1\n        cnt += 1\n        j = i\n    i += 1\nif cnt < b:\n    print(-1)\nelse:\n    print(su)","output":"linear"},{"instruction":"n = int(input())\nl = [int(x) - 1 for x in input().split()]\nparity = 0\nexplore = set(l)\nwhile len(explore) > 0:\n    x = explore.pop()\n    tmp = x\n    found = [x]\n    while l[tmp] != x:\n        tmp = l[tmp]\n        found.append(tmp)\n    for i in found[1:]:\n        explore.remove(i)\n    parity ^= (len(found) - 1) % 2\n\nif parity == n % 2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"import sys\ninput=sys.stdin.buffer.readline\nn=int(input())\narr=list(map(int,input().split()))\ngap=n\/\/2\ncount =0\nwhile gap >=1:\n    for j in range(gap ,n):\n        i= j-gap\n        while i >=0:\n            if arr[i +gap] >arr[i]:\n                break\n            else:\n                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]\n                count +=1\n            i-=gap\n    gap\/\/=2\nif count % 2== 3*n %2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")","output":"nlogn"},{"instruction":"a = list(input())\nb = input()\nout = []\nmx = '\/'\na.sort()\na.reverse()\nx = len(a)\nif x == len (b):\n    for i in range(x):\n        q = 0\n\n        for j in range(len(a)):\n            if a[j] == b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                q = 1\n                break\n            elif a[j] < b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n        if q == 0:\n            break\n    if q == 1:\n        print(''.join(out))\n    else:\n        y = len(out)\n        for i in range(y-1, -1, -1):\n            for j in range(len(a)):\n                if a[j] < b[i] and a[j]>mx:\n                    mx = a[j]\n            if mx != '\/':\n\n                a.append(out[len(out)-1])\n                out.pop()\n                out.append(mx)\n                a.pop(a.index(mx))\n                a.sort()\n                a.reverse()\n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n            else:\n                a.append(out[len(out)-1])\n                out.pop()\n                a.sort()\n                a.reverse()\n\n        a.pop(a.index(mx))\n        print(mx, end ='')\n        print(''.join(a))\n\nelse:\n    print(''.join(a))","output":"cubic"},{"instruction":"n=int(input())\nif(n<6):\n    print(-1)\nelse:\n    print(1,2)\n    print(1,3)\n    print(1,4)\n    for i in range(4,n):\n        print(2,i+1)\n\nfor i in range(n-1):\n    print(1,i+1+1)","output":"linear"},{"instruction":"import sys\nfrom math import gcd, sqrt\nfrom typing import Deque\n\nsys.setrecursionlimit(10 ** 5)\n\ninf = float(\"inf\")\nen = lambda x: list(enumerate(x))\n\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\nn = ii()\narr = rr()\narr = en(arr)\n\narr.sort(key=lambda x: x[1])\n\ni = 0\nbrr = []\n\nfor j in input():\n    if j == \"0\":\n        brr.append(arr[i])\n        print(arr[i][0] + 1, end=\" \")\n        i += 1\n    else:\n        x = brr.pop()\n        print(x[0] + 1, end=\" \")","output":"nlogn"},{"instruction":"n=int(input())\nn+=1\nif(n==1):print(0)\nelif n%2==0:print(n\/\/2)\nelse :print(n)","output":"constant"},{"instruction":"from math import factorial as fact\n\na = input()\nb = input()\n\naplus = a.count('+')\naminus = len(a) - aplus\n\nbplus = b.count('+')\nbminus = b.count('-')\nbjolly = len(b) - bplus - bminus\n\nif bplus > aplus or bminus > aminus:\n    print(0)\nelse:\n    c = aplus-bplus\n    res = fact(bjolly) \/ fact(bjolly-c) \/ fact(c) \/ 2**bjolly\n    print(res)","output":"np"},{"instruction":"import sys, string\n\ndef swap(i, j):\n    temp = a[i]\n    a[i] = a[j]\n    a[j] = temp\n\nn = int(sys.stdin.readline())\na = list(sys.stdin.readline().rstrip())\nb = list(sys.stdin.readline().rstrip())\nres_a = dict().fromkeys(list(string.ascii_lowercase), 0)\nres_b = dict().fromkeys(list(string.ascii_lowercase), 0)\n\nfor i in a:\n    res_a[i] += 1\nfor i in b:\n    res_b[i] += 1\n\ncan = True\nfor i in res_a:\n    if res_a[i] != res_b[i]:\n        can = False\n        break\nif not can:\n    print(-1)\nelse:\n    ans = []\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        else:\n            idx = -1\n            for j in range(i + 1, n):\n                if a[j] == b[i]:\n                    idx = j\n                    break\n            for j in range(idx, i, -1):\n                ans.append(j)\n                swap(j, j - 1)\n    print(len(ans))\n    print(' '.join(map(str, ans)))","output":"quadratic"},{"instruction":"s=input()\nn=len(s)\nl=[[0,0,0] for i in range(n)]\nans=0\nx=int(s[0])%3\nif(x==0):\n    ans+=1\nelse:\n    l[0][x]=1\nfor i in range(1,n):\n    x=int(s[i])%3\n    if(x==0):\n        ans+=1\n        continue\n\n    if(l[i-1][3-x]>0):\n        ans+=1\n        l[i][3-x]=0\n        l[i][x]=0\n    else:\n        if(l[i-1][x]!=0):\n            l[i][1]=1\n            l[i][2]=1\n        else:\n            l[i][x]=1\n\nprint(ans)","output":"linear"},{"instruction":"import sys\n\nn,m=map(int,input().split())\nA=list(map(int,input().split()))\n\nif n==1:\n    print(0)\n    sys.exit()\n\nA.sort(reverse=True)\n\nNOW=A[0]\nANS=1\ni=1\nwhile i<n:\n    if A[i]==A[i-1]:\n        NOW=max(1,NOW-1)\n        ANS+=1\n    else:\n        if A[i]>=NOW-1:\n            ANS+=1\n            NOW=max(NOW-1,1)\n        else:\n            ANS+=max(1,NOW-A[i])\n            NOW=A[i]\n    i+=1\n\nANS+=(NOW-1)\nprint(sum(A)-ANS)","output":"nlogn"},{"instruction":"from collections import defaultdict\n\ndata = defaultdict(list)\nposition = defaultdict()\nnxt = defaultdict()\nagg_sum = list()\n\nk = int(input())\ntrace = defaultdict()\nF = [False for x in range(1 << k)]\nback = [0 for x in range(1 << k)]\ntotal_sum = 0\nres = [(0, 0) for x in range(k)]\n\ndef build_mask(trace_mask):\n    if trace_mask == 0:\n        return\n\n    if trace.get(trace_mask):\n        for data in trace.get(trace_mask):\n            fr, to, v = data\n            res[fr] = (v, to)\n        return\n\n    sub_mask = back[trace_mask]\n    build_mask(sub_mask)\n    build_mask(trace_mask - sub_mask)\n\nif __name__ == '__main__':\n    for i in range(k):\n        values = list(map(int, input().split(' ')))\n        data[i] = values[1:]\n\n        agg_sum.append(sum(data[i]))\n        total_sum += agg_sum[i]\n\n        for cnt, v in enumerate(data[i], 0):\n            position[v] = (i, cnt)\n\n    if total_sum % k != 0:\n        print(\"No\")\n        exit(0)\n\n    row_sum = total_sum \/\/ k\n\n    for i in range(k):\n        for cnt, value in enumerate(data.get(i), 0):\n\n            x = i\n            y = cnt\n            mask = (1 << x)\n            could = True\n            circle = list()\n            while True:\n                next_value = row_sum - agg_sum[x] + data.get(x)[y]\n                if position.get(next_value) is None:\n                    could = False\n                    break\n\n                last_x = x\n                last_y = y\n\n                x, y = position.get(next_value)\n                circle.append((x, last_x, next_value))\n\n                if x == i and y == cnt:\n                    break\n\n                if mask & (1 << x):\n                    could = False\n                    break\n\n                mask |= (1 << x)\n\n            F[mask] |= could\n            if could:\n                trace[mask] = circle\n\n    for mask in range(1, 1 << k):\n        sub = mask\n        while sub > 0:\n            if F[sub] and F[mask - sub]:\n                F[mask] = True\n                back[mask] = sub\n                break\n            sub = mask & (sub - 1)\n\n    if F[(1 << k) - 1]:\n        print('Yes')\n        build_mask((1 << k) - 1)\n        for value in res:\n            print(value[0], value[1] + 1)\n    else:\n        print('No')","output":"np"},{"instruction":"from sys import stdin,stdout\ninput=stdin.readline\n\ndef count(audrey,imba,banget):\n    return((imba-audrey-1)%(banget-1))\n\nn,q=map(int,input().split())\nL=list(map(int,input().split()))\nmaxi=max(L)\nindexmax=L.index(maxi)\nP=[]\nfor i in range(indexmax):\n    P.append((L[0],L[1]))\n    if L[0]<L[1]:\n        L.append(L.pop(0))\n    else:\n        L.append(L.pop(1))\nY=tuple(L[1:])\nfor p in range(q):\n    m=int(input())\n    if m<=indexmax:\n        print(str(P[m-1][0])+' '+str(P[m-1][1]))\n    else:\n        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\\n')","output":"linear"},{"instruction":"a,b = map(int, input().split())\nx, y, z = map(int, input().split())\n\nans = max(0, 2*x+y-a)+max(0, 3*z+y-b)\nprint(ans)","output":"constant"},{"instruction":"n, l, r, x = map(int, input().split())\narr = list(map(int, input().split()))\nres = 0\nfor j in range(1, 2**n):\n    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]\n    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)\nprint(res)","output":"np"},{"instruction":"n = int(input())\nflag = True\nl , r = list(map(int,input().split())) , list(map(int,input().split()))\nans , check_l , check_r = [n for i in range(n)] , [0 for i in range(n)] , [0 for i in range(n)]\nfor i in range(n):\n    ans[i] -= l[i]+r[i]\nfor i in range(n):\n    cl , cr = 0 , 0\n    for j in range(i):\n        if ans[j] > ans[i]:\n            cl += 1\n    for j in range(i+1,n):\n        if ans[j] > ans[i]:\n\n            cr += 1\n\n    if cl != l[i] or cr!=r[i]:\n        flag = False\n        break\nmini = min(ans) - 1\nfor i in range(n):\n    ans[i] -= mini\n\nif flag:\n    print(\"YES\")\n    for i in ans:\n        print(i,end= ' ')\nelse:\n    print(\"NO\")","output":"quadratic"},{"instruction":"def bin(a):\n    if a <= 1:\n        return a\n    else:\n        return 10*bin(a\/\/2)+a%2\n\ndef convBin(a):\n    k,i = 0,0\n    while a!=0:\n        k += (a%10)*int((2**i))\n        a \/\/= 10\n        i += 1\n    return k\n\ndef maxi(a,b):\n    if a == b:\n        return 0\n    elif a+1 == b:\n        return a^b\n    elif a+2 == b:\n        x = a^(a+1)\n        y = a^(a+2)\n        z = (a+1)^(a+2)\n        return max(max(x,y),z)\n    else:\n        x = str(bin(a^b))\n        y = '1'*len(x)\n        return convBin(int(y))\na = list(map(int,input().split()))\nprint(maxi(a[0],a[1]))","output":"logn"},{"instruction":"d4i=[0,-1,0,1]\nd4j=[-1,0,1,0]\n\ndef main():\n\n    n,m,k=readIntArr()\n    horizontalEdges=[]\n    for _ in range(n):\n        horizontalEdges.append(readIntArr())\n    verticalEdges=[]\n    for _ in range(n-1):\n        verticalEdges.append(readIntArr())\n\n    if k%2==1:\n        ans=makeArr(-1,[n,m])\n    else:\n        dp=makeArr(inf,[n,m,k\/\/2+1])\n        for i in range(n):\n            for j in range(m):\n                dp[i][j][0]=0\n        for nM in range(1,k\/\/2+1):\n            for i in range(n):\n                for j in range(m):\n\n                    if j+1<m:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])\n\n                    if j-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])\n\n                    if i+1<n:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i+1][j][nM-1]+verticalEdges[i][j])\n\n                    if i-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])\n        ans=makeArr(0,[n,m])\n        for i in range(n):\n            for j in range(m):\n                ans[i][j]=dp[i][j][k\/\/2]*2\n\n    multiLineArrayOfArraysPrint(ans)\n\n    return\n\nimport sys\ninput=sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n    return [int(x) for x in input().split()]\n\ndef makeArr(defaultVal,dimensionArr):\n    dv=defaultVal;da=dimensionArr\n    if len(da)==1:return [dv for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(x,y):\n    print('? {} {}'.format(x,y))\n    sys.stdout.flush()\n    return int(input())\n\ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n\ninf=float('inf')\n\nMOD=998244353\n\nfor _abc in range(1):\n    main()","output":"cubic"},{"instruction":"n = int(input())\n\nif n > 0:\n    print(n)\nelse:\n    n = n * -1\n    x = n % 10\n    y = (n \/\/ 10) % 10\n\n    if x > y:\n        print(-(n \/\/ 10))\n    else:\n        print(-((n \/\/ 100)* 10 + x))","output":"constant"},{"instruction":"n, l, r, x = map(int, input().split())\ntasks = list(map(int, input().split()))\nmask = 3\nans = 0\n\nwhile (mask < (1 << n)):\n    sum_dif = 0\n    min_diff = float(\"inf\")\n    max_diff = -float(\"inf\")\n\n    if (mask & (mask-1)):\n        for i in range(n):\n            if (mask & (1 << i)):\n                sum_dif += tasks[i]\n                min_diff = min(min_diff, tasks[i])\n                max_diff = max(max_diff, tasks[i])\n        if (x <= (max_diff - min_diff)) and (l <= sum_dif <= r):\n            ans += 1\n\n    mask += 1\n\nprint(ans)","output":"np"},{"instruction":"import sys\ninput = sys.stdin.readline\ntest = int(input())\nfor _ in range(test):\n  s = input().rstrip()\n  t = input().rstrip()\n  n = len(s)\n  m = len(t)\n  ansls = []\n  pos = [[1000 for i in range(26)] for j in range(n+2)]\n  for i in range(n+1)[::-1]:\n    if i < n:\n      for j in range(26):\n        pos[i][j] = pos[i+1][j]\n    if i > 0:\n      x = ord(s[i-1])-97\n      pos[i][x] = i\n  flg = 0\n  for i in range(m):\n    t1 = t[:i]\n    t2 = t[i:]\n    m1 = len(t1)\n    m2 = len(t2)\n    dp = [[1000 for i in range(m2+1)] for j in range(m1+1)]\n    dp[0][0] = 0\n    for j in range(m1+1):\n      for k in range(m2+1):\n        if j > 0 and dp[j-1][k] < 1000:\n          t1x = ord(t1[j-1])-97\n          dp[j][k] = min(dp[j][k],pos[dp[j-1][k]+1][t1x])\n        if k > 0 and dp[j][k-1] < 1000:\n          t2x = ord(t2[k-1])-97\n          dp[j][k] = min(dp[j][k],pos[dp[j][k-1]+1][t2x])\n    if dp[-1][-1] < 1000:\n      flg = 1\n      break\n  if flg:\n    print(\"YES\")\n  else:\n    print(\"NO\")","output":"cubic"},{"instruction":"from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nfrom itertools import combinations\nimport sys\nimport math\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(map(int,sys.stdin.readline().strip().split()))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\ndef bfs(g,d):\n\tglobal n\n\n\tfor i in range(n,0,-1):\n\t\twhile g[i]:\n\t\t\tx = g[i].pop()\n\t\t\td[i]+=d[x]\n\treturn d\n\nn = int(input())\nl = list(numIN())\nif n==1:\n\tprint(1)\n\texit(0)\nif n==2:\n\tprint(1,1)\n\texit(0)\nd = [0]*(n+1)\nl = [0,0]+l\ng = defaultdict(list)\nfor i in range(2,n+1):\n\tg[l[i]].append(i)\n\td[i]+=1\n\td[l[i]]+=1\nfor i in range(1,n+1):\n\tif g[i]:\n\t\td[i] = 0\nx = bfs(g,d)\nx.sort()\nfor i in range(1,n+1):\n\tprint(x[i],end= ' ')","output":"nlogn"},{"instruction":"parent = [i for i in range(int(1e5 + 10))]\ndef findSet(u):\n    if parent[u] != u:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nif __name__ == '__main__':\n    n, a, b = map(int, input().split())\n    lst = list(map(int, input().split()))\n    temp = {lst[i]: i for i in range(n)}\n    for i in range(n):\n        if a - lst[i] in temp:\n            unionSet(i, temp[a - lst[i]])\n        else:\n            unionSet(i, n)\n        if b - lst[i] in temp:\n            unionSet(i, temp[b - lst[i]])\n        else:\n            unionSet(i, n + 1)\n\n    if findSet(n) == findSet(n + 1):\n        print('NO')\n    else:\n        print('YES')\n        tmp = findSet(n + 1)\n        lst = [0 if findSet(i) == tmp else 1 for i in range(n)]\n        print(*lst)","output":"linear"},{"instruction":"def ism(a, b, c):\n    return a==b and b==c\n\ndef isk(a, b, c):\n    x = [a, b, c]\n    x.sort()\n    if x[0][1] == x[1][1] and x[1][1] == x[2][1]:\n        if int(x[0][0])+1 == int(x[1][0]) and int(x[1][0])+1 == int(x[2][0]):\n            return 1\n    return 0\n\na, b, c = input().split()\nx = [a,b,c]\ntypem = []\ntypes = []\ntypep = []\nm, s, p = 0, 0, 0\n\nfor i in x:\n    if i[1]=='m':\n        m+=1\n        typem.append(i)\n    elif i[1]=='s':\n        s+=1\n        types.append(i)\n    elif i[1]=='p':\n        p+=1\n        typep.append(i)\n\nans = 0\ndone = 0\n\nif isk(a,b,c) or ism(a,b,c):\n    ans = 0\n    done = 1\n\nif done==0 and a==b and b==c:\n    ans = 0\n    done = 1\n\nelif done==0 and a==b:\n    ans = 1\n    done = 1\n\nelif done==0 and b==c:\n    ans = 1\n    done = 1\nelif done==0 and a==c:\n    ans = 1\n    done = 1\n\nif done==0 and m>=2:\n    typem.sort()\n    for i in range(len(typem)-1):\n        if abs(int(typem[i][0]) - int(typem[i+1][0])) <= 2 and \\\n           abs(int(typem[i][0]) - int(typem[i+1][0])) > 0:\n            ans = 1\n            done = 1\n\nif done==0 and s>=2:\n    types.sort()\n    for i in range(len(types)-1):\n        if abs(int(types[i][0]) - int(types[i+1][0])) <= 2 and \\\n           abs(int(types[i][0]) - int(types[i+1][0])) > 0:\n            ans = 1\n            done = 1\n\nif done==0 and p>=2:\n    typep.sort()\n    for i in range(len(typep)-1):\n        if abs(int(typep[i][0]) - int(typep[i+1][0])) <= 2 and \\\n           abs(int(typep[i][0]) - int(typep[i+1][0])) > 0:\n            ans = 1\n            done = 1\n\nif done == 0:\n    ans = 2\n    done = 1\n\nprint(ans)","output":"nlogn"},{"instruction":"n = int(input())\nx, y = list(map(int, input().strip().split()))\n\nif n-x + n-y >= x-1 + y-1:\n\tprint(\"White\")\nelse:\n\tprint(\"Black\")","output":"constant"},{"instruction":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n\n        return res","output":"quadratic"},{"instruction":"from math import *\n\ndef nCr(n, r):\n    f = factorial\n    return f(n) \/ f(r) \/ f(n - r)\n\ns1, s2 = [input() for i in range(2)]\ns1_pos, s2_pos, s1_neg, s2_neg, s1_q = s1.count('+'), s2.count('+'), s1.count('-'), s2.count('-'), s2.count('?')\n\nans = 0\nif s1_q == 0:\n    if s1_pos == s2_pos:\n        ans = 1\n    else:\n        ans = 0\nelse:\n    diff1 = s1_pos - s2_pos\n    if diff1 > s1_q or diff1 < 0:\n        ans = 0\n    else:\n        ans = nCr(s1_q, diff1) \/ 2 ** s1_q\n\nprint('{:.12f}'.format(ans))","output":"np"},{"instruction":"n = int(input())\nd={}\nfor _ in range(n):\n    a,b = map(int,input().split())\n    d[a] = b\n\ns=0\nm = int(input())\nfor _ in range(m):\n    x,y = map(int,input().split())\n\n    if x in d:\n        d[x] = max(d[x],y)\n\n    else:\n        d[x] = y\n\nfor i in d:\n\n    s+=d[i]\nprint(s)","output":"nlogn"},{"instruction":"num=int(input())\n\na=input()\n\nb=input()\n\ndic={}\n\nlis=[]\n\nham=0\n\nswap1=-1\n\nswap2=-1\n\np=False\n\nq=False\n\nfor i in range(num):\n\n    if a[i]!=b[i]:\n\n        ham+=1\n\n        lis.append(i)\n\n        dic[b[i]]=i\n\nfor i in lis:\n\n    if a[i] in dic:\n\n        p=True\n\n        swap1=i+1\n\n        f=dic[a[i]]\n\n        swap2=f+1\n\n        if a[f]==b[i]:\n\n            q=True\n\n            break\n\nprint(ham-(2 if q else 1 if p else 0))\n\nprint(swap1,swap2)","output":"linear"},{"instruction":"from sys import stdin\nfrom functools import reduce\nfrom operator import ior\ndef get_ints(): return list(map(int, stdin.readline().strip().split()))\n\nnk ,m = get_ints()\na = [int(input(),2) for x in range(nk)]\nif nk == 1:\n\tprint(\"NO\")\n\texit()\nnum =  reduce(ior,a)\nfor i in range(nk):\n\tk = a.copy()\n\tk.pop(i)\n\tn = reduce(ior,k)\n\tif n == num:\n\t\tprint(\"YES\")\n\t\texit()\nprint(\"NO\")","output":"quadratic"},{"instruction":"import collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n\n    import numpy\n    def dprint(*args, **kwargs):\n\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r')\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')\n    atexit.register(lambda :sys.stdout.close())\n\nN, M = getIntList()\n\nza  = getIntList()\nza.sort(reverse = True)\n\nre = 0\n\nfor i in range(N-1):\n    a = za[i]\n    b = za[i+1]\n    g = b\n    if g>=a:\n        t = a-1\n        if t<1: t = 1\n        re +=  g-t\n        za[i+1] = t\n        re += a - 1\n    else:\n        re += g\nprint(re)","output":"nlogn"},{"instruction":"a=[]\nn=int(input())\nfor i in range(n):\n    l,r=map(int,input().split())\n    a.append([l,r,i+1])\na.sort(key=lambda x:(x[0],-x[1]))\nr=0\niid=0\nf=1\nfor i in range(n):\n    if(r>=a[i][1]):\n        f=0\n        print(a[i][2],a[iid][2])\n        break;\n    else:\n        r=a[i][1]\n        iid=i;\nif(f):\n    print(\"-1 -1\")","output":"nlogn"},{"instruction":"n=int(input())\nif(n==0):\n    print(0)\nelif(n%2!=0):\n    print((n+1)\/\/2)\nelse:\n    print(n+1)","output":"constant"},{"instruction":"for _ in range(int(input())):\n    n,k=map(int,input().split())\n    if n>31:\n        print(\"YES\",n-1)\n        continue\n    else:\n        if k>(4**n-1)\/\/3:\n            print(\"NO\")\n            continue\n    l=(4**n-1)\/\/3\n    i=1\n    j=0\n    k1=k\n    while i<=n:\n        k-=(2**i-1)\n        j=i\n        if k<0:\n            j=j-1\n            k+=(2**i-1)\n            break\n        i+=1\n    k2=k1-k\n    k3=(2**(j+1)-1)*((4**(n-j)-1)\/\/3)\n\n    if l-k2-k3>=k:\n        print(\"YES\",n-i+1)\n    else:\n        print(\"NO\")","output":"logn"},{"instruction":"n = int(input())\nl1 = list(input().split())\nl2 = []\nfor i in l1:\n    l2.append(int(i))\nl1 = set(l2)\nl1 = list(l1)\nfor i in range(0, len(l1)):\n    for j in range(i + 1, len(l1)):\n        if l1[i] > l1[j]:\n            temp = l1[j]\n            l1[j] = l1[i]\n            l1[i] = temp\nif len(l1) > 1:\n    print(l1[1])\nelse:\n    print('NO')","output":"nlogn"},{"instruction":"print(\"? 0 0\")\nans00 = input()\nxr = 0\na = 0\nb = 0\ncb = 2 ** 29\nwhile cb:\n    print(\"?\", xr + cb, cb)\n    ans11 = input()\n    print(\"?\", xr, cb)\n    if ans11 == ans00:\n        ans01 = input()\n        if ans01 == '1':\n            a += cb\n            b += cb\n    else:\n        ans00 = input()\n        if ans11 == '1':\n            b += cb\n        else:\n            a += cb\n        xr += cb\n    cb \/\/= 2\nprint(\"!\", a, b)","output":"constant"},{"instruction":"n=int(input())\n\nif n<=2:\n    print(n)\nelse:\n    if n%2!=0:\n        print(n*(n-1)*(n-2))\n    elif n%3==0:\n        print((n-1)*(n-2)*(n-3))\n    else:\n        print(n*(n-1)*(n-3))","output":"constant"},{"instruction":"from collections import defaultdict\nn = int(input())\narr = defaultdict(int)\nfor a0 in range(n):\n\tl,r = input().strip().split()\n\tl,r=int(l),int(r)\n\tarr[l]+=1\n\tarr[r+1]-=1\n\nbrr=[0]*(n+1)\n\nl=sorted(arr.keys())\nsum=arr[l[0]]\nprevpoint=l[0]\nfor key in l[1:]:\n\tbrr[sum]+=key-prevpoint\n\tprevpoint=key\n\tsum+=arr[key]\nprint(*brr[1:])","output":"nlogn"},{"instruction":"from sys import stdin, stdout\n\nN = 55\n\nf = [0]\nfor i in range(1, N):\n    f.append(f[-1]*4 + 1)\n    if f[-1] > 1e18:\n        break\n\nt = int(stdin.readline().strip().split()[0])\n\nfor ca in range(0, t):\n    n, m = [int(x) for x in stdin.readline().strip().split()]\n    if n > 31:\n        stdout.write(\"YES {}\\n\".format(n-1))\n    else:\n\n        start = 0\n        found = False\n        res = -1\n        for i in range(1, n+1):\n            start += 2**i -1\n            end = start\n            for k in range(1, i+1):\n                end += f[n-k] * (2**(k+1) - 3)\n            if m >= start and m <= end:\n                found = True\n                res = i\n                break\n        if found:\n            stdout.write(\"YES {}\\n\".format(n-res))\n        else:\n            stdout.write(\"NO\\n\")","output":"logn"},{"instruction":"mod = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x != 0:\n    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)\nelse:\n    print(0)","output":"logn"},{"instruction":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n\n            m = l + ((r - l) \/\/ 2)\n\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1","output":"logn"},{"instruction":"n, k = (int(x) for x in input().split())\n\nif k > n * 2 or k < 3:\n    print(0)\nelif n >= k-1:\n    print(k - k\/\/2 - 1)\nelse:\n    print(n - k\/\/2)","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\nn, m, k = map(int, input().split())\nej = [list(map(int, input().split())) for _ in range(n)]\nei = [list(map(int, input().split())) for _ in range(n - 1)]\n\nif k % 2:\n  for _ in range(n): print(*[-1] * m)\n  exit(0)\ninf = -1\ndp = [[inf] * (n * m) for _ in range(k \/\/ 2 + 1)]\nfor t in range(n * m): dp[0][t] = 0\nfor c in range(k \/\/ 2):\n  for i in range(n):\n    for j in range(m):\n      t = i * m + j\n\n      tt = (i + 1) * m + j\n      if i + 1 < n and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i][j]): dp[c + 1][tt] = dp[c][t] + ei[i][j]\n\n      tt = i * m + j + 1\n      if j + 1 < m and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j]): dp[c + 1][tt] = dp[c][t] + ej[i][j]\n\n      tt = (i - 1) * m + j\n      if i - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i - 1][j]): dp[c + 1][tt] = dp[c][t] + ei[i - 1][j]\n\n      tt = i * m + j - 1\n      if j - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j - 1]): dp[c + 1][tt] = dp[c][t] + ej[i][j - 1]\n\nres = [[0] * m for _ in range(n)]\nfor i in range(n):\n  for j in range(m): res[i][j] = dp[-1][i * m + j] * 2\n  print(*res[i])","output":"cubic"},{"instruction":"class Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        start = sorted([i.start for i in intervals])\n        end = sorted([i.end for i in intervals])\n\n        res = count = 0\n        s = e = 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                s += 1\n                count += 1\n            else:\n                e += 1\n                count -= 1\n            res = max(res, count)\n        return res","output":"nlogn"},{"instruction":"def socket(n,m,k,arr):\n    arr.sort(reverse=True)\n    devices=m\n    curr_socket=0\n    e_socket=k\n    i=0\n    t_socket=0\n    count=0\n    while i<n:\n        if e_socket>=devices:\n            return 0\n        if curr_socket==0:\n            curr_socket+=arr[i]\n            count+=1\n            e_socket-=1\n            t_socket=curr_socket+e_socket\n        else:\n            if t_socket>=devices:\n                return count\n            else:\n                curr_socket+=arr[i]-1\n                count+=1\n                t_socket=curr_socket+e_socket\n        i+=1\n    if t_socket>=devices:\n        return count\n    return -1\n\nn,m,k=map(int,input().split())\narr=list(map(int,input().split()))\nprint(socket(n,m,k,arr))","output":"nlogn"},{"instruction":"n, s = map(int, input().split())\nif not 2*n - 1 <= s <= n * (n+1) \/\/ 2:\n    print('No')\n    exit()\nprint('Yes')\n\ndef ok(d):\n    dep, cur, sum, m = 2, 1, 1, 0\n    while cur + m < n:\n        m += cur\n        cur = min(n - m, cur * d)\n        sum += cur * dep\n        dep += 1\n    return sum <= s\n\nl, r = 1, n\nwhile l < r:\n    mid = (l+r) \/\/ 2\n    if ok(mid):\n        r = mid\n    else:\n        l = mid + 1\n\na, me = [l-1] * (n+1), [_ for _ in range(n+1)]\nsum, low = n * (n+1) \/\/ 2, 2\nwhile n > low and sum > s:\n    dest = min(sum-s, n-low)\n    sum -= dest\n    me[n] -= dest\n    a[me[n]+1] += l\n    a[me[n]] -= 1\n    if not a[low]: low += 1\n    n -= 1\nme, l, dg = sorted(me[1:]), 0, 0\nfor i in me[1:]:\n    while me[l] < i-1 or dg == r:\n        dg = 0\n        l += 1\n    print(l+1, end=' ')\n    dg += 1","output":"linear"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd\nn,m=map(int,input().split())\nl1=[]\nfor i in range(n):\n    l1.append(list(map(int,input().split())))\nl=0\nh=10**9\nc=2**m-1\nx,y=1,2\nwhile l<=h:\n    mid=(l+h)\/\/2\n    d=dd(int)\n    d1=dd(int)\n    for i in range(n):\n        s=[]\n        for j in range(m):\n            if l1[i][j]>=mid:\n                s.append('1')\n            else:\n                s.append('0')\n        s=int(''.join(s),2)\n        d[s]+=1\n        d1[s]=i+1\n    f=0\n    for i in d:\n        for j in d:\n            if i|j==c:\n                f=1\n                x=d1[i]\n                y=d1[j]\n                break\n        if f:\n            break\n    if f:\n        if l==h:\n            break\n        l=mid+1\n    else:\n        if l==h:\n            break\n        h=mid\nprint(x,y)","output":"np"},{"instruction":"Q = int(input())\n\ndef getsum(N):\n    A = (N+1)\/\/2\n    r1 = -A + A*(A+1)\n    B = N \/\/ 2\n    r2 = B*(B+1)\n    return -r1 + r2\n\nwhile Q != 0:\n    L, R = map(int, input().split())\n    print(getsum(R) - getsum(L-1))\n    Q -= 1","output":"constant"},{"instruction":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\nn, k = getList()\nnums = getList()\n\ndiff = []\n\nfor i, j in zip(nums, nums[1:]):\n    diff.append(j - i)\n\ndiff.sort()\nprint(sum(diff[:(n-k)]))","output":"nlogn"},{"instruction":"turns, candies = map(int, input().split())\nsumm = 0\nturn = 0\nwhile candies != summ - (turns - turn):\n    turn += 1\n    summ += turn\nprint(turns - turn)","output":"linear"},{"instruction":"N,U = map(int,input().strip().split())\n\nE = list(map(int,input().strip().split()))\nmaxu = -1\nj = 2\nif N < 3:\n    print(-1)\nfor i in range(N-2):\n    j = max(i+2,j)\n    if E[j] -E[i] > U:\n        continue\n    while j < N and E[j] - E[i] <= U:\n        j += 1\n    j -= 1\n    maxu = max(maxu, (E[j] - E[i+1]) \/ (E[j] - E[i]))\nprint(maxu)","output":"nlogn"},{"instruction":"l, r = (int(x) for x in input().split())\nlimit = l ^ r\n\nif limit != 0:\n  limit = len(bin(limit)) - 2\n  maxXor = '1' * limit\n  print(int(maxXor, 2))\nelse:\n  print(0)","output":"logn"},{"instruction":"n = int(input())\n\nxs = [int(x) for x in input().split()]\n\nseen = {}\n\nres = 0\n\nwhile xs:\n    j = xs.index(xs[0], 1)\n    res += j - 1\n    xs = xs[1:j] + xs[j+1:]\n\nprint(res)","output":"quadratic"},{"instruction":"def fis(sq):\n    if sq[2] < sq[0] or sq[3] < sq[1]:\n        return [0, 0]\n    sc = (sq[0] + sq[1]) % 2\n    fc = (sq[2] + sq[3]) % 2\n    sxl = sq[2] - sq[0] + 1\n    syl = sq[3] - sq[1] + 1\n    hf = (sxl * syl) \/\/ 2\n    cp = -1\n    if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1:\n        cp = sc\n    return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)])\n\nt = int(input())\nfor i in range(t):\n    n, m = [int(x) for x in input().split()]\n    wco = [int(x) for x in input().split()]\n    bco = [int(x) for x in input().split()]\n    wf, bf = fis([1, 1, m, n])\n    btw = fis(wco)[1]\n    wtb = fis(bco)[0]\n    bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])]\n    bna = fis(bnac)[1]\n    print(wf+btw-wtb-bna, bf+wtb-btw+bna)","output":"constant"},{"instruction":"import atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a * x + b + vy\n        dd = a * nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx, vy) not in dc[dd]:\n            dc[dd][(vx, vy)] = 0\n        dc[dd][(vx, vy)] += 1\n\n    tot = 0\n    for v, k in dc.items():\n        tt = 0\n        pp = 0\n        for _, cc in k.items():\n            tt -= cc * (cc + 1) \/\/ 2\n            pp += cc\n        tt += pp * (pp + 1) \/\/ 2\n        tot += tt * 2\n    print(tot)\n\nif __name__ == '__main__':\n    main()","output":"linear"},{"instruction":"l,r=tuple(map(int,input().split(\" \")))\nx=l^r\npow=1\nwhile(pow<=x) :\n    pow*=2\n\nprint(pow-1)","output":"logn"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n            if id != None:\n                for i in range(r):\n                    self.mat[i][i] = 1\n\n    def __add__(self, other):\n        mat0 = Matrix(self.r, self.c)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n\n        return mat0\n\n    def __mul__(self, other):\n        mat0 = Matrix(self.r, other.c)\n\n        for i in range(self.r):\n            for j in range(other.c):\n                for k in range(self.c):\n                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n\n        return mat0\n\n    def dot_mul(self, other):\n        res = 0\n        for i in range(self.r):\n            for j in range(self.c):\n                res += self.mat[i][j] * other.mat[j][i]\n\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.r):\n            res += self.mat[i][i]\n\n        return res\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def mat_pow(self, mat, p, mod=None):\n        sq = Matrix(mat.r, mat.r, id=1)\n\n        while p:\n            if p & 1:\n                p -= 1\n                sq = sq * mat\n\n            p \/\/= 2\n            mat = mat * mat\n\n        return sq.mat\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) \/\/ b\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"ax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\nif ax > bx:\n    ax, bx = bx, ax\n    ay, by = by, ay\nif ax > cx:\n    ax, cx = cx, ax\n    ay, cy = cy, ay\nif bx > cx:\n    bx, cx = cx, bx\n    by, cy = cy, by\nans = []\nfor i in range(min(ay, by, cy), max(ay, by, cy) + 1):\n    ans.append([bx, i])\nfor i in range(ax, bx):\n    ans.append([i, ay])\nfor i in range(bx + 1, cx + 1):\n    ans.append([i, cy])\nprint(len(ans))\nfor x in ans:\n    print(x[0], x[1])","output":"constant"},{"instruction":"n,m = map(int,input().split())\nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")","output":"constant"},{"instruction":"n = int(input())\nr = 0\ni = 2\nwhile i*2 <=n:\n\ta = int(n\/i)\n\tr += (a+2)*(a-2+1)\/2\n\ti += 1\nprint(int(4*r))","output":"linear"},{"instruction":"def find(a,b):\n    cc=2\n    for i in range(1,(1<<len(a))):\n        sx=0\n        minn=100000000\n        maxn=-1\n        for j in range(0,len(a)):\n            if(i &(1<<j)):\n                sx+= a[j];\n                minn = min(minn, a[j])\n                maxn = max(maxn, a[j])\n        if(sx>=b[1] and sx<=b[2] and (maxn-minn)>=b[3]):\n            cc+=1\n    if(cc<2):\n        return 2\n    else:\n        return cc-2\n\nb=list(map(int,input().split()))\na=list(map(int,input().split()))\nprint(find(a,b))","output":"np"},{"instruction":"from itertools import accumulate\nfrom sys import stdin, stdout\n\ndef main():\n    k = int(stdin.readline())\n    a = [\n        tuple(map(int, stdin.readline().split()[1:]))\n        for _ in range(k)\n    ]\n    a2ij = {\n        aij: (i, j)\n        for i, ai in enumerate(a)\n        for j, aij in enumerate(ai)\n    }\n\n    plena = [0, ] + list(accumulate(map(len, a)))\n    suma = tuple(map(sum, a))\n    totala = sum(suma)\n\n    if totala % k != 0:\n        stdout.write(\"No\\n\")\n    else:\n        needle = totala \/\/ k\n        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)\n        dp = compute_previous_mask(mask2i2cp)\n        output(dp, mask2i2cp)\n\ndef compute_mask2i2cp(a, a2ij, needle, plena, suma):\n    used = [False, ] * plena[-1]\n    number_of_masks = 1 << len(a)\n    mask2i2cp = [-1, ] * number_of_masks\n\n    for i, ai in enumerate(a):\n        for j, aij in enumerate(ai):\n            if not used[plena[i] + j]:\n                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)\n\n                if i2cp != -1:\n                    mask2i2cp[mask] = i2cp\n\n                    for cp in i2cp:\n                        if cp != -1:\n                            c, p = cp\n                            ii, jj = a2ij[c]\n                            used[plena[ii] + jj] = True\n\n    return mask2i2cp\n\ndef output(dp, mask2i2cp):\n    mask = len(mask2i2cp) - 1\n\n    if dp[mask] == -1:\n        stdout.write(\"No\\n\")\n    else:\n        answer = [-1, ] * len(mask2i2cp[dp[mask]])\n\n        while mask > 0:\n            current_mask = dp[mask]\n\n            for i, cp in enumerate(mask2i2cp[current_mask]):\n                if 1 == ((current_mask >> i) & 1):\n                    c, p = cp\n                    answer[i] = (c, p)\n\n            mask ^= current_mask\n\n        stdout.write('Yes\\n' + '\\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))\n\ndef compute_mask_i2cp(a2ij, aij, i, j, needle, suma):\n    i2cp = [-1, ] * len(suma)\n    mask = 0\n    current_a = aij\n    current_i = i\n\n    try:\n        while True:\n            next_a = needle - (suma[current_i] - current_a)\n\n            next_i, next_j = a2ij[next_a]\n\n            if ((mask >> next_i) & 1) == 1:\n                return mask, -1\n\n            mask |= 1 << next_i\n            i2cp[next_i] = (next_a, current_i)\n\n            if next_i == i:\n                if next_j == j:\n                    return mask, i2cp\n\n                return mask, -1\n\n            if next_i == current_i:\n                return mask, -1\n\n            current_a = next_a\n            current_i = next_i\n    except KeyError:\n        return mask, -1\n\ndef compute_previous_mask(mask2cp):\n    number_of_masks = len(mask2cp)\n    dp = [-1, ] * number_of_masks\n    dp[0] = 0\n\n    for mask, cp in enumerate(mask2cp):\n        if cp != -1:\n            complement_mask = (number_of_masks - 1) & (~mask)\n            previous_mask = complement_mask\n\n            while previous_mask > 0:\n                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:\n                    dp[previous_mask | mask] = mask\n\n                previous_mask = (previous_mask - 1) & complement_mask\n\n            if dp[mask] == -1:\n                dp[mask] = mask\n    return dp\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"def cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef f(v, i1, i2):\n    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]\n\n    res = []\n    for x in v:\n        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]\n        if cross(d, d2) != 0:\n            res.append(x)\n\n    return res\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit(0)\n\nv = []\nfor i in range(n):\n    v.append(list(map(int, input().split())))\n\nok = False\nfor first in range(3):\n    if ok:\n        break\n\n    for second in range(first+1, 3):\n        other = f(v, first, second)\n\n        if len(other) <= 2:\n            ok = True\n            break\n\n        remainder = f(other, 0, 1)\n\n        if not remainder:\n            ok = True\n\nif ok:\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"nlogn"},{"instruction":"n = int(input())\nif n%2==0:\n    a = n - 8\n    print(a,8)\nelse:\n    a = n-9\n    print(a,9)","output":"constant"},{"instruction":"import sys\n\ndef prepare():\n    stack = [i for i in range(n) if deg[i] == 0]\n    cnt = 0\n    while stack:\n        v = stack.pop()\n        cnt += 1\n        for dest in adj[v]:\n            deg[dest] -= 1\n            if deg[dest] == 0:\n                stack.append(dest)\n        adj[v].clear()\n\n    return cnt == n\n\ndef solve(st):\n    stack = [st]\n    visited = [0]*n\n    cnt = 0\n    while stack:\n        v = stack.pop()\n        cnt += 1\n        for dest in adj[v]:\n            if dest == st:\n                continue\n            visited[dest] += 1\n            if deg[dest] == visited[dest]:\n                stack.append(dest)\n\n    return cnt == m\n\nn, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())\nadj = [[] for _ in range(n)]\nrev = [[] for _ in range(n)]\ndeg = [0]*n\nfor u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):\n    adj[u-1].append(v-1)\n    rev[v-1].append(u-1)\n    deg[v-1] += 1\n\nok = prepare()\nif ok:\n    print('YES')\n    exit()\n\nm = len([1 for i in range(n) if deg[i] > 0])\nfor i in range(n):\n    if deg[i] == 1 and solve(i):\n        print('YES')\n        exit()\n\nprint('NO')","output":"quadratic"},{"instruction":"import sys\ninput = sys.stdin.readline\nn = int(input())\nif n < 6:\n    print(-1)\n\nelse:\n    l = []\n    o = []\n    x = (3+n)\/\/2\n    for i in range(3,x+1):\n        l.append((1,i))\n\n    for i in range(x+1,n+1):\n        o.append((2,i))\n\n    sys.stdout.write(\"1\"+\" \"+\"2\"+\"\\n\")\n    for x in l:\n        sys.stdout.write(str(x[0]) + \" \" + str(x[1]) + \"\\n\")\n\n    for x in o:\n        sys.stdout.write(str(x[0]) + \" \" + str(x[1]) + \"\\n\")\n\nsys.stdout.write(\"1\"+\" \"+\"2\"+\"\\n\")\np = 2\nfor i in range(3,n+1):\n    sys.stdout.write(str(p) + \" \" + str(i) + \"\\n\")\n    p = i","output":"linear"},{"instruction":"import math\n\nt = int(input())\n\ndef eval_(n, k):\n    level = 0.5*math.log2(3*k+1)\n    if n > 30:\n        cond = (level - n) > 0\n    else:\n        cond = (3*k+1) > 4**n\n    if cond:\n        return \"NO\"\n    elif n == 2 and k == 3:\n        return \"NO\"\n    else:\n        level = math.floor(level)\n\n        if n > 5:\n\n            temp = 1 + 0.5*math.log2(3*(k-1) + 1)\n            if n > temp:\n                return \"YES \" + str(n - 1)\n            else:\n                return \"YES  0\"\n        else:\n            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)\/\/3\n            start = (4**(level)-1)\/\/3\n            if k <=(start+delta):\n                return \"YES \" + str(n - level)\n            else:\n                return \"YES \" + str(n - level-1)\n\nfor i in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    print(eval_(n, k))","output":"constant"},{"instruction":"t = int(input())\nfor i in range(t):\n    n = int(input())\n\n    lens = sorted(map(int, input().split()))\n    cnt = len(list(filter(lambda x: x> 0, lens[:-2])))\n\n    print(min(cnt, lens[-2]-1))","output":"nlogn"},{"instruction":"from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)","output":"np"},{"instruction":"from sys import stdin, stdout\n\nnxt = []\n\ndef find_it(s, left, right):\n    global nxt\n    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]\n    dp[0][0] = 0\n    for i in range(len(left)+1):\n        for j in range(len(right)+1):\n            if dp[i][j] > len(s):\n                continue\n            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:\n                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:\n                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1\n            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:\n                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:\n                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1\n    if dp[len(left)][len(right)] != 1000:\n        return True\n    else:\n        return False\n\ndef main():\n    global nxt\n    n = int(stdin.readline())\n    for _ in range(n):\n        s = stdin.readline().rstrip()\n        t = stdin.readline().rstrip()\n        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)]\n        for i,x in enumerate(s):\n            nxt[ord(x) - 97][i] = i\n        for i in range(26):\n            for j in range(len(s)-1 ,-1,-1):\n                if nxt[i][j] != j:\n                    nxt[i][j] = nxt[i][j+1]\n\n        r = False\n        for i in range(len(t)):\n            res = find_it(s, t[:i], t[-len(t)+i:])\n            if res is True:\n                r = True\n                break\n\n        if r is True:\n            stdout.write(\"YES\\n\")\n        else:\n            stdout.write(\"NO\\n\")\n\nmain()","output":"cubic"},{"instruction":"n = int(input())\na = [int(x) for x in input().split()]\nh = [-1]*(n)\nb = [(a[i],i) for i in range(n)]\nb.sort(reverse=True)\nfor e in b:\n\n\tnum,idx = e\n\tflag = True\n\tallNeg = True\n\tfoundLosing = False\n\tfoundWin = False\n\tfor i in range(idx%num,n,num):\n\n\t\tif i == idx:\n\t\t\tcontinue\n\t\tif h[i]!= -1:\n\t\t\tallNeg = False\n\t\tif h[i] == 0:\n\t\t\tfoundLosing = True\n\t\t\tbreak\n\t\tif h[i] == 1:\n\t\t\tfoundWin = False\n\tif allNeg:\n\t\th[idx] = 0\n\telif foundLosing:\n\t\th[idx] = 1\n\telse:\n\t\th[idx] = 0\n\nfor i in range(n):\n\tif h[i]==0:\n\t\tprint('B',end='')\n\telse:\n\t\tprint('A',end='')","output":"quadratic"},{"instruction":"def is_prime(num):\n    if num > 1:\n        for i in range(2, num):\n            if (num % i) == 0:\n               return  False\n        else:\n            return True\n    else:\n        return False\n\nn = int(input())\ntemp = 0\nfirst = 0\nsecond = 0\nif n % 2 == 0:\n    temp = int(n\/2)\n    first = temp\n    second = n - temp\n    while is_prime(first) or is_prime(second):\n        first -= 1\n        second += 1\n        if first + second == n and (not is_prime(first) and not is_prime(second)):\n            break\nelse:\n    temp = int(n \/ 2)\n    first = temp\n    second = n - first\n    while is_prime(first) or is_prime(second):\n        first -= 1\n        second += 1\n        if first + second == n and (not is_prime(first) and not is_prime(second)):\n            break\nprint(first,end=\" \")\nprint(second)","output":"constant"},{"instruction":"n=int(input())\ns=list()\nfor i in range(n):\n    x=input()\n    s.append(x)\na=sorted(s,key=len)\nc=1\nfor i in range(n-1):\n    if(a[i] not in a[i+1]):\n        c=0\n        break\nif(c==0):\n    print('NO')\nelse:\n    print('YES')\n    for i in range(n):\n        print(a[i])","output":"nlogn"},{"instruction":"from sys import stdin, stdout\n\nidx1 = 0\nidx2 = 0\nVALD = 0\n\ndef getminmax(n, m, a):\n    l = 0\n    h = 1000000009\n\n    while l < h:\n        mid = (l+h+1)\/\/2\n        exists = existsequalorbig(mid, m, a)\n\n        if exists:\n\n            l = mid\n        else:\n            h = mid-1\n\ndef existsequalorbig(mid, m, a):\n    global idx1\n    global idx2\n    global VALD\n\n    abw = []\n    hs = set()\n\n    for i in range(len(a)):\n        v = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                v |= 1\n            v <<= 1\n        v >>= 1\n        if v not in hs:\n            hs.add(v)\n            abw.append([i, v])\n\n    for i in range(len(abw)):\n        for j in range(i, len(abw)):\n            if abw[i][1] | abw[j][1] == VALD:\n                idx1 = abw[i][0]\n                idx2 = abw[j][0]\n                return True\n\n    return False\n\nif __name__ == '__main__':\n    nm = list(map(int, stdin.readline().split()))\n    n = nm[0]\n    m = nm[1]\n\n    VALD = int(pow(2, m) - 1)\n\n    a = []\n    for i in range(n):\n        a.append(list(map(int, stdin.readline().split())))\n\n    getminmax(n, m, a)\n\n    stdout.write(str(idx1+1) + ' ' + str(idx2+1))","output":"np"},{"instruction":"import bisect\nimport time\ndef ass(a, b): print(f\"Assertion error: {a} != {b}\" if a != b else 'OK')\ndef nr(): return int(input())\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2, n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\ndef get_mask(num):\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num \/\/ p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\treturn num\n\ndef dump(dp):\n\tfor i,line in enumerate(dp):\n\t\tprint(i%10,line)\n\ndef get_left(n,k,lst):\n\tlast_in = {}\n\ts = []\n\tres = []\n\tfor i in range(n):\n\t\tgroup = get_mask(lst[i])\n\t\tif group in last_in: bisect.insort(s, last_in[group] + 1)\n\t\tlast_in[group] = i\n\t\tif len(s) <= k+1:\n\t\t\tres.append(s[::-1])\n\t\telse:\n\t\t\tm = len(s)\n\t\t\tres.append(s[m-1:m-k-2:-1])\n\treturn res\n\ndef get_dp(n,k,lst):\n\tres = []\n\tleft = get_left(n,k,lst)\n\tfor i in range(n):\n\t\tarr = left[i]\n\t\trow = [n] * (k+1)\n\t\tfor j in range(k+1):\n\t\t\tfor g in range(j+1):\n\t\t\t\tif g >= len(arr):\n\t\t\t\t\trow[j] = 1\n\t\t\t\telse:\n\t\t\t\t\tindex = arr[g]-1\n\t\t\t\t\tjindex = j-g\n\t\t\t\t\trow[j] = min(res[index][jindex] + 1, row[j])\n\t\tres.append(row)\n\treturn res\n\ndef f(n,k,lst):\n\tdp = get_dp(n,k,lst)\n\tprint(dp[n-1][k])\n\nprime = get_prime(3162)\n\nfor _ in range(nr()):\n\tn,k = nrs()\n\tf(n,k,nrs())","output":"cubic"},{"instruction":"import sys,os,io\nfrom sys import stdin\nimport math\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i):\n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x \/\/ spf[x]\n    return ret\n\ndef SieveOfEratosthenes(n):\n\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef solve():\n    n = ii()\n    c = [0] + li()\n    a = [0] + li()\n    vis = [False]*(n+1)\n    ans = 0\n\n    d = defaultdict(lambda:0)\n    cycleno = 0\n\n    for i in range(1,n+1):\n        if (vis[i]==False):\n            cur = i\n            first = i\n\n            while vis[cur]==False:\n                d[cur] = cycleno\n                vis[cur]=True\n                cur = a[cur]\n\n            if d[cur]==cycleno:\n                min_ = c[cur]\n                first = cur\n                cur = a[cur]\n\n                while first!=cur:\n\n                    min_ = min(c[cur],min_)\n                    cur = a[cur]\n                ans+=min_\n            cycleno+=1\n\n    print(ans)\n\nt = 1\n\nfor _ in range(t):\n    solve()","output":"linear"},{"instruction":"n = int(input())\na = list(input())\nsmm = 0\nfor i in range(n):\n    a[i] = int(a[i])\n    smm += a[i]\nans = \"NO\"\nsm = smm\nfor div in range(2, n + 1):\n    sm = smm\n    if not sm % div:\n        sm \/\/= div\n        f = 0\n        s = 0\n        for i in range(n):\n            s += a[i]\n            if s == sm:\n                s = 0\n                f += 1\n        if f == div:\n            ans = \"YES\"\n            break\nprint(ans)","output":"quadratic"},{"instruction":"import sys\ninput = lambda: sys.stdin.readline().strip()\nfrom math import ceil\n\ndef mismatch(s1, s2):\n    cnt = 0\n    for i in range(len(s1)):\n        if s1[i]!=s2[i]: cnt+=1\n    return cnt\n\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    check = ''\n    for i in range(ceil((k+2)\/3)):\n        check+='RGB'\n    ls = []\n    for i in range(3):\n        ls.append(check[i:i+k])\n    s = input()\n    m = n\n    for i in range(n-k+1):\n        for j in ls:\n            m = min(m, mismatch(s[i:i+k], j))\n    print(m)","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nrsum = [0]\nmaxx = 0.0\n\nfor i in range(n): rsum.append(rsum[-1] + arr[i])\n\nfor ki in range(k, n+1):\n    for i in range(n-ki+1):\n        tot = 0\n\n        avg = (rsum[i+ki] - rsum[i])\/ki\n\n        maxx = max(maxx, avg)\nprint(maxx)","output":"quadratic"},{"instruction":"from math import *\nn,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n\/\/g,x\/\/g,(x+y)\/\/g,n%g,lambda n:max(f(n,0),f(n,1))\ndef f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y):d=[max(d[0],d[1]),d[0]+n\/\/y+(i*x%y<n%y)]\n return d[s]\nprint(h(n+1)*r+h(n)*(g-r))","output":"np"},{"instruction":"n,m,k = list(map(int,input().split()))\n\nl = list(map(int,input().split()))\n\nout = 0\nd = 0\n\nwhile m > d:\n    nex = l[d]\n    page = (nex - d - 1)\/\/k\n    add = 1\n    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:\n        add += 1\n    d += add\n    out += 1\n\nprint(out)","output":"linear"},{"instruction":"from math import log\nfrom collections import deque\nn,k=map(int,input().split())\ns=list(map(int,input().split()))\nans=0\ns.sort()\ns1=deque(s)\nfor j in range(11):\n    d=dict()\n    z=10**j\n    for i in s:\n        y=i*z\n        u=y%k\n        if u in d:\n            d[u]+=1\n        else:\n            d.update({u:1})\n    aux=0\n    for i in s1:\n        y=i\n        lg=int(log(i,10))+1\n        lg=10**lg\n        if lg==z:\n            d[(y*z)%k]-=1\n            x=(k-y%k)\n            if y%k==0:\n                x=0\n            if x in d:\n                ans+=d[x]\n            d[(y*z)%k]+=1\n            aux+=1\n        else:\n            break\n    for i in range(aux):\n        s1.popleft()\n\nprint(ans)","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nh = 0\nans = 0\nfor i in range(n - 1):\n    ans += a[i] - 1\n    if a[i] > h:\n        h += 1\nif h < max(a):\n    ans += h\nelse:\n    ans += a[-1] - 1\nprint(ans)","output":"nlogn"},{"instruction":"class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        res = 0\n        for i in range(len(s)):\n            count, maxf = {}, 0\n            for j in range(i, len(s)):\n                count[s[j]] = 1 + count.get(s[j], 0)\n                maxf = max(maxf, count[s[j]])\n                if (j - i + 1) - maxf <= k:\n                    res = max(res, j - i + 1)\n        return res","output":"quadratic"},{"instruction":"def matches(pos, c, case):\n    if case==0:\n        return pos%3==\"RGB\".index(c)\n    elif case==1:\n        return pos%3==\"GBR\".index(c)\n    else:\n        return pos%3==\"BRG\".index(c)\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n\n    s = input()\n\n    mglobal = k\n\n    r=g=b=0\n\n    for i, c in enumerate(s[:k]):\n\n        r += not matches(i, c, 0)\n        g += not matches(i, c, 1)\n        b += not matches(i, c, 2)\n\n    mglobal = min([mglobal, r, g, b])\n    for i, c in enumerate(s[k:]):\n        i+=k\n        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))\n        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))\n        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))\n\n        mglobal = min([mglobal, r, g, b])\n\n    print(mglobal)","output":"linear"},{"instruction":"def getBW(x1, y1, x2, y2):\n    if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1:\n        return [(y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2, (y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2]\n    else:\n        if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1):\n            return [(y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2]\n        else:\n            return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2, (y2 + 1 - y1) * (x2 + 1 - x1) \/\/ 2]\n\ncs = int(input())\n\nfor c in range(cs):\n    m, n = map(int, input().split())\n    BW = getBW(1, 1, n, m)\n    x1, y1, x2, y2 = map(int, input().split())\n\n    x3, y3, x4, y4 = map(int, input().split())\n\n    BW1 = getBW(x1, y1, x2, y2)\n    BW2 = getBW(x3, y3, x4, y4)\n    BWO =[0, 0]\n\n    xo1 = max(x1, x3)\n    xo2 = min(x2, x4)\n    yo1 = max(y1, y3)\n    yo2 = min(y2, y4)\n    if (xo2 >= xo1 and yo2 >= yo1):\n        BWO = getBW(xo1, yo1, xo2, yo2)\n\n    B = BW[0] - BW1[0] + BW2[1] + BWO[0]\n    W = BW[1] + BW1[0] - BW2[1] - BWO[0]\n\n    print(W, end = \" \")\n    print(B)","output":"constant"},{"instruction":"from math import log\nk=int(input())\nr=k\nl=1\nt=log(10)\nwhile 1:\n\tm=(l+r)\/\/2\n\tx=int(log(m)\/t)\n\td=((1-10**(x+1))\/\/9) + (m+1)*(x+1)\n\tif 0<=(k-d)<=13:\n\t\tbreak\n\telif d>k:\n\t\tr=m-1\n\telse:\n\t\tl=m+1\nif m==1000:\n\td+=1\nif d==k:\n\tprint(str(m)[-1])\n\texit()\nst=\"\"\nv=k-d\nm+=1\nfor i in range(13):\n\tst+=str(m)\n\tm+=1\nprint(st[v-1])","output":"logn"},{"instruction":"n, k = map(int, input().split())\nif n == k:\n    print('1' * n)\nelif k == 1:\n    print('0' + '1' * (n - 1))\nelse:\n    x = (n - k) \/\/ 2\n    a = '0' * x + '1'\n    print(a * (n \/\/ (x + 1)) + '0' * (n % (x + 1)))","output":"constant"},{"instruction":"a=int(input())\nb=list(map(int,input().split()))\nz=max(b)\nif z==1:b[b.index(z)]=2\nelse:b[b.index(z)]=1\nprint(*sorted(b))","output":"nlogn"},{"instruction":"n,m=map(int,input().split())\nseq=list(map(str,input().split()))\nfp=list(map(str,input().split()))\nchecklist=[]\nfor number in seq:\n    if(number in fp):\n        checklist.append(number)\nprint(\" \".join(checklist))","output":"quadratic"},{"instruction":"n, k = map(int, input().split())\nl = 0\nr = n + 1\nwhile r - l > 1:\n    m = (l + r) \/\/ 2\n    if m * (m + 1) \/\/ 2 - (n - m) > k:\n        r = m\n    else:\n        l = m\nprint(n - l)","output":"logn"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\ndict = {i:0 for i in set(a)}\nfor i in range(m):\n    dict[a[i]] += 1\nk = 1\nwhile sum(dict[i]\/\/k for i in dict) >= n:\n    k += 1\nprint(k - 1)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) \/ (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) \/\/ (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\ndef main():\n    n, k = RLL()\n    dp = [[0]*4 for _ in range(k+2)]\n    dp[1][0] = 1\n    dp[1][3] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n    tag = 0\n    for i in range(2, n+1):\n        new = [[0]*4 for _ in range(k+2)]\n        for j in range(1, k+2):\n            for l in range(4):\n                tag+=1\n                new[j][l] = ((dp[j][l])%mod + (new[j][l])%mod)%mod\n                if l==0 or l==3:\n                    new[j][l] = ((dp[j-1][l^3])%mod + (new[j][l])%mod)%mod\n                    new[j][l] = (((dp[j][1])%mod+(dp[j][2])%mod) + (new[j][l])%mod)%mod\n                elif l==1 or l==2:\n                    new[j][l] = (((dp[j-1][0])%mod+(dp[j-1][3])%mod) + (new[j][l])%mod)%mod\n                    if j-2>=0: new[j][l] = ((dp[j-2][l^3])%mod + (new[j][l])%mod)%mod\n        dp = new\n    print(sum(dp[k])%mod)\n\nif __name__ == \"__main__\":\n    main()","output":"np"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase)]\n\ndef bi(n,k):\n    MIN=0\n    MAX=n\n\n    while MAX>MIN+1:\n        bn=(MIN+MAX)\/\/2\n        if math.log2(k+2+bn)<bn+1:\n            MAX=bn\n        elif math.log2(k+2+bn)==bn+1:\n            return bn\n        else:\n            MIN=bn\n\n    if MAX+1<=math.log2(k+2+MAX):\n        return MAX\n\n    return MIN\n\nfor n,k in T:\n    if n==1:\n        if k==1:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n\n    if n==2:\n        if 1<=k<=2:\n            print(\"YES\",1)\n        elif k==3:\n            print(\"NO\")\n        elif 4<=k<=5:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n\n    if n<=30 and k>(pow(4,n)-1)\/\/3:\n        print(\"NO\")\n        continue\n\n    ANS=bi(n,k)\n\n    print(\"YES\",n-ANS)","output":"logn"},{"instruction":"import sys\nimport random\n\nfrom itertools import permutations, combinations\nfrom math import sqrt, fabs, ceil\nfrom collections import namedtuple\n\nin_file_path = \"input.txt\"\noutput_file_path = \"output.txt\"\n\nSUBMIT = True\n\ndef read_num(fin, num_type=int):\n    tmp_list = [num_type(x) for x in fin.readline().strip().split()]\n    if len(tmp_list) == 1:\n        return tmp_list[0]\n    else:\n        return tuple(tmp_list)\n\ndef solve(fin):\n    T = read_num(fin)\n    for _ in range(0, T):\n        n, k = read_num(fin)\n        if n > 34 or k == 1:\n            print('YES', n - 1)\n        else:\n            f = [0]\n            for _ in range(0, n):\n                f.append(f[-1] * 4 + 1)\n            min_step = 1\n            max_step = 1 + f[n - 1]\n\n            out_range = 3\n            flag = True\n            for i in range(0, n):\n\n                if min_step <= k <= max_step:\n                    print('YES', n - i - 1)\n                    flag = False\n                    break\n                max_step += out_range\n                min_step += out_range\n                out_range = out_range * 2 + 1\n                if n - 2 - i >= 0:\n\n                    max_step += (out_range - 2) * f[n - 2 - i]\n\n            if flag:\n                print('NO')\n\nif __name__ == '__main__':\n    if SUBMIT:\n        solve(sys.stdin)\n    else:\n        solve(open(in_file_path, 'r'))","output":"logn"},{"instruction":"n=int(input());\nif n % 2 == 0:\n\n    print((n-4),\" 4\")\nelse:\n\n    print((n-9),\" 9\")","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    n,m=map(int,input().split())\n    ans=[];moves=n*m;\n    c1=[1,1];c2=[n,m];p=0\n    while moves>0:\n        if p%2==0:\n            ans.append(tuple(c1))\n            c1[1]+=1\n            if c1[1]>m:\n                c1[0]+=1;c1[1]=1\n        else:\n            ans.append(tuple(c2))\n            c2[1]-=1\n            if c2[1]<1:\n                c2[0]-=1;c2[1]=m\n        moves-=1;p+=1\n    for i in ans:\n        print(*i)\nmain()","output":"quadratic"},{"instruction":"n,l,r,x = map(int,input().split())\nc = list(map(int,input().split()))\nc.sort()\nans = 0\nfor i  in range(2**n):\n    s = []\n    for j in range(n):\n        if i&2**j:\n            s.append(c[j])\n    if sum(s)>=l and sum(s)<=r and max(s)-min(s)>=x:\n        ans+=1\n\nprint(ans)","output":"np"},{"instruction":"def cnt(s,t):\n    i,c=0,0\n    while(s.count(t)):\n        s=s[s[i:].index(t)+1:]\n        c+=1\n    return c\ns=(input())\nn=len(s)\nln=0\nfor i in range(n):\n    for j in range(i,n):\n        if(j-i+1<=ln):\n            continue\n        if(cnt(s,s[i:j+1])>=2):\n            ln=max(ln,j-i+1)\nprint(ln)","output":"cubic"},{"instruction":"n,m=map(int,input().split())\nc=0;ans=str()\nfor i in range(n):\n  ans+=str(c^1)\n  c=c^1\nprint(ans)","output":"linear"},{"instruction":"for _ in range(int(input())):\n    s = input()\n    t = input()\n    if len(t) == 1:\n        print(\"YES\" if t in s else \"NO\")\n        continue\n    nxt = [[-1] * 26 for _ in range(len(s) + 1)]\n    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1\n    for i in range(len(s) - 2, -1, -1):\n        for c in range(26):\n            nxt[i][c] = nxt[i + 1][c]\n        nxt[i][ord(s[i]) - ord('a')] = i\n    ans = \"NO\"\n    for p in range(1, len(t)):\n        a = t[:p]\n        b = t[p:]\n        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]\n        dp[0][0] = 0\n        for la in range(len(a) + 1):\n            for lb in range(len(b) + 1):\n                if dp[la][lb] != -1:\n                    if la < len(a):\n                        if dp[la + 1][lb] != -1:\n                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:\n                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                        else:\n                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                    if lb < len(b):\n                        if dp[la][lb + 1] != -1:\n                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:\n                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                        else:\n                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                if dp[len(a)][len(b)] != -1:\n                    ans = \"YES\"\n                    break\n    print(ans)","output":"cubic"},{"instruction":"n,x = list(map(int, input().split()))\na = set(map(int, input().split()))\n\nif len(a) < n :\n    print(0)\nelse :\n    d = set()\n    p = 0\n    for i in a :\n        d.add(i&x)\n        if i&x != i and i&x in a :\n            print(1)\n            p = 1\n            break\n    if len(d) < n and p == 0 :\n        print(2)\n    elif p != 1 :\n        print(-1)","output":"linear"},{"instruction":"class Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        n = len(intervals)\n        for i in range(n):\n            A = intervals[i]\n            for j in range(i + 1, n):\n                B = intervals[j]\n                if min(A.end, B.end) > max(A.start, B.start):\n                    return False\n        return True","output":"quadratic"},{"instruction":"MOD = 1000000007\ndef modpow(x, p):\n\n    result = 1\n    while p > 0:\n\n        if p % 2 == 1:\n            result = (result * x) % MOD\n\n        p = p \/\/ 2\n\n        x = (x * x) % MOD\n\n    return result\n\nn, k = map(int, input().split())\nk+=1\nif n == 0:\n\tprint(0)\nelse:\n\n\tans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD\n\tprint(ans)","output":"logn"},{"instruction":"n,k = map(int, input().split())\nd = (n-k)\/\/2+1\nans = ['1' if (i+1)%d==0 else '0' for i in range(n)]\nprint(''.join(ans))","output":"linear"},{"instruction":"num=int(input())\nlist_=sorted(set(map(int,input().split())))\nif len(list_)==1:\n    print(\"NO\")\nelse:\n\n    print(list_[1])","output":"nlogn"},{"instruction":"def problem(s, p):\n    for i in range(len(p)):\n        l = p[:i] + ' '\n        r = p[i:] + ' '\n\n        dp = [0] + [None] * i\n\n        for x in s:\n            for j in range(i, -1, -1):\n                if dp[j] is None:\n                    continue\n\n                if l[j] == x:\n                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])\n\n                temp = r[dp[j]]\n                if r[dp[j]] == x:\n                    dp[j] += 1\n\n        if dp[-1] == len(r) - 1:\n            return 'YES'\n\n    return 'NO'\n\nfor _ in range(int(input())):\n    print(problem(input(), input()))","output":"cubic"},{"instruction":"def search(arr,power):\n    lo=0\n    hi=len(arr)-1\n    ans=-1\n    while lo<=hi:\n        mid=(lo+hi)\/\/2\n        if arr[mid]<=power:\n            ans=mid\n            lo=mid+1\n        else:\n            hi=mid-1\n    return ans\n\nn,q = list(map(int, input().split()))\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\nfor i in range(1,n):\n    a[i]+=a[i-1]\npower = 0\nfor i in range(q):\n    power+=k[i]\n    pos = search(a,power)\n    if pos==n-1:\n        print(n)\n        power=0\n    elif pos==-1:\n        print(n)\n    else:\n        print(n-pos-1)","output":"nlogn"},{"instruction":"n, k = map(int, input().split())\ns = input()\na = [0] * 26\nfor i in s:\n    a[ord(i) - ord('a')] = 1\nans = 0\ni = 0\nwhile i < 26:\n    if a[i] > 0:\n        ans += i + 1\n        k -= 1\n        i += 1\n        if k == 0:\n            print(ans)\n            break\n    i += 1\nelse:\n    print(-1)","output":"linear"},{"instruction":"n=int(input())\nl=[-1 for i in range(n+1)]\ns=input().split()\nll=[int(i) for i in s]\nfor i in range(n):\n    j=ll[i]\n    l[j]=i\nres=[\".\" for i in range(n+1)]\nres[n]=\"B\"\nfor i in range(n-1,0,-1):\n    toadd=\"B\"\n    pos=l[i]%i\n    while pos<n:\n        j=ll[pos]\n        if j<=i:\n            pos+=i\n            continue\n        if abs(l[i]-l[j])%i==0 and res[j]==\"B\":\n            toadd=\"A\"\n            break\n        pos+=i\n    res[i]=toadd\nfor i in ll:\n    print(res[i],end=\"\")\nprint(\"\")","output":"nlogn"},{"instruction":"a = list(input())\nb = list(input())\nn = len(a)\na.sort()\n\ndef listtostring(li:list):\n    return ''.join(li)\n\nfor i in range(0,n):\n    for j in range(0,n):\n        t = a.copy()\n        t[i],t[j] = t[j],t[i]\n        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):\n\n            a[i],a[j] = a[j],a[i]\n\nprint(listtostring(a))","output":"cubic"},{"instruction":"def main():\n    input()\n    acc = {0: 0}\n    for p, c in zip(list(map(int, input().split())),\n                    list(map(int, input().split()))):\n        adds = []\n        for b, u in acc.items():\n            a = p\n            while b:\n                a, b = b, a % b\n            adds.append((a, u + c))\n        for a, u in adds:\n            acc[a] = min(u, acc.get(a, 1000000000))\n    print(acc.get(1, -1))\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"import io\nimport os\n\nimport sys\nfrom functools import lru_cache\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 5)\n\ndef solve(N, A):\n\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    maxVal = 1000 + 10\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n\n                intervals[l].append(r)\n\n    @lru_cache(maxsize=None)\n    def getBest(left):\n\n        if left == N:\n            return 0\n        best = float(\"inf\")\n        for right in intervals[left]:\n\n            best = min(best, 1 + getBest(right + 1))\n        return best\n\n    return getBest(0)\n\ndef tup(l, r):\n\n    return l * 16384 + r\n\ndef untup(t):\n\n    return divmod(t, 16384)\n\ndef solve(N, A):\n\n    cache = {}\n\n    def f(lr):\n        if lr not in cache:\n            l, r = untup(lr)\n\n            if r - l == 1:\n                return tup(1, A[l])\n            best = tup(float(\"inf\"), float(\"inf\"))\n            for i in range(l + 1, r):\n\n                lSplit = f(tup(l, i))\n                rSplit = f(tup(i, r))\n                lLen, lVal = untup(lSplit)\n                rLen, rVal = untup(rSplit)\n                if lLen != 1 or rLen != 1:\n\n                    best = min(best, tup(lLen + rLen, 9999))\n                else:\n                    if lVal == rVal:\n\n                        best = min(best, tup(1, lVal + 1))\n                    else:\n\n                        best = min(best, tup(2, 9999))\n            cache[lr] = best\n\n        return cache[lr]\n\n    ans = untup(f(tup(0, N)))[0]\n\n    return ans\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)","output":"cubic"},{"instruction":"def STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n\ndef Binary_Search(arr , x , n):\n    l ,r = 0 , n-1\n    while l <= r:\n        mid = l + (r - l) \/\/ 2\n        if arr[mid] == x :\n            return mid+1\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    return r + 1\n\nn , q = MAP()\na = LIST()\nb = LIST()\nps = list(accumulate(a))\nans = []\n\narrows = 0\nfor arrow in b :\n    arrows += arrow\n    if arrows >= ps[-1]:\n        ans.append(n)\n        arrows = 0\n    else:\n        res = Binary_Search(ps , arrows , n)\n        ans.append(n - res)\n\nfor i in ans:\n    print(i)","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    l,r=map(int,input().split(\" \"))\n    n=len(bin(r)[2:])\n    ans=0\n    for x in range(0,n+1):\n        if (r>>x)&1==1 and (l>>x)&1==0:\n            ans=max(ans,(1<<x)^((1<<x)-1))\n    print(ans)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"logn"},{"instruction":"n, k = map(int,input().split())\narr = list(map(int, input().split()))\n\ndef find_segment(arr, n, k):\n  f = [0]*100001\n  L = count = 0\n  R = -1\n  while R < n-1:\n    R += 1\n    if f[arr[R]] == 0:\n      count += 1\n    f[arr[R]] += 1\n    while count == k:\n      f[arr[L]] -= 1\n      if f[arr[L]] == 0:\n        print(L+1, R+1)\n        return\n      L += 1\n  print(-1,-1)\nfind_segment(arr, n, k)","output":"linear"},{"instruction":"import sys\n\ndef sol(a,b):\n\tfor square in [a,b]:\n\t\tfor i1 in range(4):\n\t\t\ti2 = (i1 + 1)%4\n\t\t\tp1,p2 = square[i1],square[i2]\n\n\t\t\tnorm = (p2[1]-p1[1],p1[0]-p2[0])\n\n\t\t\tminA = maxA = minB = maxB = None\n\t\t\tfor p in a:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minA == None or proj < minA:\n\t\t\t\t\tminA = proj\n\t\t\t\tif maxA == None or proj > maxA:\n\t\t\t\t\tmaxA = proj\n\t\t\tfor p in b:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minB == None or proj < minB:\n\t\t\t\t\tminB = proj\n\t\t\t\tif maxB == None or proj > maxB:\n\t\t\t\t\tmaxB = proj\n\n\t\t\tif maxA < minB or maxB < minA:\n\t\t\t\treturn False\n\treturn True\n\nx11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))\nx21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]\nb = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]\n\nprint([\"NO\",\"YES\"][sol(a,b)])","output":"constant"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a=list(map(int,input().rstrip()))\n    b=list(map(int,input().rstrip()))\n    ans,la,lb=[],len(a),len(b)\n    if la!=lb:\n        print(*sorted(a,reverse=True),sep=\"\")\n    else:\n        for i in range(lb):\n            if b[i] in a:\n                ans.append(b[i])\n                a.remove(b[i])\n            else:\n                while i>-1:\n                    ma=-1\n                    for j in a:\n                        if j<b[i]:\n                            ma=max(ma,j)\n                    if ma!=-1:\n                        ans.append(ma)\n                        a.remove(ma)\n                        break\n                    i-=1\n                    a.append(ans.pop())\n                a.sort()\n                while a:\n                    ans.append(a.pop())\n                break\n        print(\"\".join(str(i) for i in ans))\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"n = int(input())\nl1 = list(input().split())\nl2 = []\nfor i in l1:\n    l2.append(int(i))\nl1 = set(l2)\nl1 = list(l1)\nfor i in range(0, len(l1)):\n    for j in range(i + 1, len(l1)):\n        if l1[i] > l1[j]:\n            temp = l1[j]\n            l1[j] = l1[i]\n            l1[i] = temp\nif len(l1) > 1:\n    print(l1[1])\nelse:\n    print('NO')","output":"nlogn"},{"instruction":"n,k = map(int,input().split())\na = list(map(int,input().split()))\np = sorted(a)\np = p[-k:]\ns = sum(p)\nprint(s)\nidx = 0\ni = 0\ncount = 0\nans = []\nwhile len(ans)<k-1:\n    idx+=1\n    count+=1\n    if a[i] in p:\n        p.remove(a[i])\n        ans.append(count)\n        count = 0\n    i+=1\nfor i in ans:\n    print(i,end = \" \")\nprint(n-idx)","output":"nlogn"},{"instruction":"a,b,c = input().split()\nif a[1] == b[1] == c[1]:\n    t = sorted([int(a[0]),int(b[0]),int(c[0])])\n    if (t[1] == t[0] + 1 == t[2] - 1) or (t[0] == t[2]):print(0)\n    elif t[0] == t[1] or t[1] == t[2]:print(1)\n    elif t[0] + 1 == t[1] or t[1] + 1 == t[2] or t[0] + 2 == t[1] or t[1] + 2 == t[2]:print(1)\n    else:print(2)\nelif a[1] == b[1]:\n    s,t = int(a[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif c[1] == b[1]:\n    s,t = int(c[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif a[1] == c[1]:\n    s,t = int(a[0]),int(c[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelse:print(2)","output":"nlogn"},{"instruction":"q = int(input())\nfor i in range(q):\n    a, b, k = map(int, input().split())\n    if a < b:\n        a, b, = b, a\n    if a > k:\n        print(-1)\n    elif a % 2 == b % 2 != k % 2:\n        print(k - 2)\n    elif (a + b) % 2 != 0:\n        print(k - 1)\n    else:\n        print(k)","output":"constant"},{"instruction":"op=[0]*1000000\ncl=[0]*1000000\ndef fun(s):\n    v = []\n    for i in range(len(s)):\n        l = len(v)\n        if s[i]=='(':\n            v.append(s[i])\n        elif l>0 and v[l-1]=='(':\n            v.pop()\n        else :\n            v.append(')')\n\n    l = len(v)\n    if  l==0:\n        op[0]+=1\n        cl[0]+=1\n    elif v[0]==v[l-1]:\n        if  v[0]=='(':\n            op[l]+=1\n        else :\n            cl[l]+=1\n\nt = int ( input() )\nwhile t>0:\n    t-=1\n    s = str ( input() )\n    fun(s)\nans = 0\nfor i in range(1000000):\n    ans+=(op[i] * cl[i])\n\nprint(ans)","output":"linear"},{"instruction":"k = int(input())\n\nif k <= 9:\n\tprint(k)\n\nelse:\n\ts = 9\n\tn = 1\n\n\twhile s < k:\n\t\tn += 1\n\t\tprev_s = s\n\t\ts += (10**n - 10**(n-1)) * n\n\n\tdigit_pos = k - (prev_s + 1)\n\tnumber = 10**(n-1) + digit_pos \/\/ n\n\n\tif digit_pos \/ n != digit_pos \/\/ n:\n\t\tdigit_pos = digit_pos - (digit_pos \/\/ n) * n\n\n\telse:\n\t\tdigit_pos = 0\n\n\tprint(str(number)[digit_pos])","output":"logn"},{"instruction":"import math\nEPS = 1e-6\n\nhhh = None\n\ndef solve():\n    n, M = [int(x) for x in input().split()]\n\n    if out_of_solution_bounds(n, M):\n        print('No')\n        return\n\n    b = find_optimal_b(n, M)\n\n    heights = fast_find_optimal_height_distribution(n, M, b)\n    parents = build_tree(n, b, heights)\n    print('Yes')\n    print(*parents[1:])\n\ndef out_of_solution_bounds(n, M):\n    return M < 2*n - 1 or (n * (n+1)) \/\/ 2 < M\n\ndef find_optimal_b(n, M):\n    begin = 1\n    end = n\n    while begin != end:\n        mid = (begin + end) \/\/ 2\n        if get_min_H_given_b(n, mid) <= M:\n            end = mid\n        else:\n            begin = mid + 1\n    b = end\n    return b\n\ndef get_min_H_given_b(n, b):\n    if b == 1: return (n*(n+1)) \/\/ 2\n    m = math.floor(math.log((b-1)*n+1) \/ math.log(b) + EPS)\n    nl = round((b**m - 1) \/ (b - 1))\n    return (m*b**(m+1) - (m+1)*b**m + 1) \/\/ (b - 1)**2 + (m+1) * (n - nl)\n\ndef fast_find_optimal_height_distribution(n, M, b):\n    begin = 0\n    end = n+1\n    H_fn = lambda L : (L*(L+1))\/\/2 + get_min_H_given_b(n - L, b) + (L > 0)*(n - L)\n\n    while begin != end:\n        mid = (begin + end) \/\/ 2\n        if H_fn(mid) <= M:\n            begin = mid + 1\n        else:\n            end = mid\n    L = begin - 1\n\n    if L == n:\n        return [1 for _ in range(n)]\n\n    unif_branch_h = uniform_height_distribution(n - L, b)\n    if L == 0:\n        h = unif_branch_h\n    else:\n        h = [int(i < L) for i in range(n)]\n        for i, x in enumerate(unif_branch_h, 1):\n            h[i] += x\n\n    return locally_increase_H(h, M, b)\n\ndef uniform_height_distribution(n, b):\n    h = [0 for _ in range(n)]\n    h[0] = 1\n    i = 0\n    to_fill = n-1\n    while to_fill > 0:\n        i += 1\n        h[i] = min(b*h[i-1], to_fill)\n        to_fill -= h[i]\n    return h\n\ndef locally_increase_H(h, M, b):\n    i = 1\n    while not (b * (h[i-1]) >= (h[i] - 1) and b * (h[i] - 1) >= (h[i+1] + 1)):\n        i += 1\n\n    H = sum(i*x for i, x in enumerate(h, 1))\n    while H < M:\n        if b * (h[i-1] - 1) >= (h[i] + 1):\n            i -= 1\n        else:\n            while not b * (h[i] - 1) >= (h[i+1] + 1):\n                i += 1\n        h[i] -= 1\n        h[i+1] += 1\n        H += 1\n\n    return h\n\ndef build_tree(n, b, h):\n    p = [None for _ in range(n)]\n    p[0] = 1\n\n    i = 1\n    j = 0\n    for k in range(1, n):\n        if j == h[i]:\n            i += 1\n            j = 0\n        p[k] = k - j - h[i-1] + (j \/\/ b) + 1\n        j += 1\n    return p\n\nif __name__ == '__main__':\n    solve()","output":"linear"},{"instruction":"from collections import defaultdict\n\nmod_v = 1000000007\n\ntemp_arr = [[1]]\nfor i in range(1,1010):\n    a = [1]\n    for k in range(1,i):\n        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)\n    a.append(1)\n    temp_arr.append(a)\n\nans_arr = [1]\nfor i in range(1,1010):\n    res = 0\n    for j in range(i):\n        res += ans_arr[j] * temp_arr[i-1][j]\n        res %= mod_v\n    ans_arr.append(res)\n\nn_list=list(map(int, input().split()))\n\nn = n_list[0]\nlines = n_list[1]\n\nnew_list = [0 for __ in range(n)]\n\nfor i in range(lines):\n    input1 = list(map(int, input()))\n    for k in range(n):\n        new_list[k] |= input1[k] << i\n\ndefault_d = defaultdict(int)\nfor k in new_list:\n    default_d[k] += 1\n\nanswer = 1\nfor n in default_d.values():\n    answer = answer * ans_arr[n] % mod_v\n\nprint(answer)","output":"quadratic"},{"instruction":"x,k = map(int, input().split())\nmod = 1000000007\nflag = True\nif x==0:\n    flag=False\nif flag:\n    print((pow(2,k+1,mod)*x-pow(2,k,mod)+1+mod)%mod)\nelse:\n    print(0)","output":"logn"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\nb=0\nfor i in range(n):\n    if a[i]%2==1:\n        if i%2==0:\n            b+=1\n        else:\n            b-=1\nif n%2==0:\n    if b==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if b==0 or b==1:\n        print(\"YES\")\n    else:\n        print(\"NO\")","output":"linear"},{"instruction":"import sys\ninput=sys.stdin.readline\nfrom math import *\n\nl,r=map(int,input().split())\n\nl=list(bin(l)[2:])\nr=list(bin(r)[2:])\nl=['0' for i in range(len(r)-len(l))]+l\n\ns=\"\"\nfor i in range(len(r)):\n    if l[i]==r[i]:\n        s+=\"0\"\n    else:\n        s+=\"1\"*(len(r)-i)\n        break\nprint(int(s,2))","output":"logn"},{"instruction":"from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\ndef get(l, r):\n    if l > r:\n        return 0\n\n    if l & 1:\n        return (-l - r) * (r - l + 2) \/\/ 4\n    else:\n        return (l + r) * (r - l + 2) \/\/ 4\n\ndef solution(l, r):\n    l1, l2, r1, r2 = l, l, r, r\n\n    if l & 1:\n        l2 += 1\n    else:\n        l1 += 1\n\n    if r & 1:\n        r2 -= 1\n    else:\n        r1 -= 1\n\n    return get(l1, r1) + get(l2, r2)\n\nq = int(stdin.readline())\nfor i in range(q):\n    l, r = map(int, stdin.readline().split())\n    stdout.write(str(solution(l, r)) + '\\n')","output":"constant"},{"instruction":"debug = 0\nBIG = 10 ** 9 + 1\n\ninput = raw_input\n\ndef prof(f):\n    return f\n\ndef report(f):\n    def new_f(x):\n        res = f(x)\n\n        return res\n\n    return new_f if debug else f\n\ndef mcheck(a, pairs):\n    m = len(a[0])\n    allm = 2 ** m - 1\n\n    subs = {i: {i} for i in range(allm + 1)}\n\n    for i in range(allm + 1):\n        for j in range(i):\n            if i | j == i:\n                subs[i].add(j)\n\n    mx = [max(aa) for aa in a]\n\n    @prof\n    def check(v):\n        masks = {0: -1}\n        done = [False] * (allm + 1)\n        for i, aa in enumerate(a):\n            if mx[i] < v:\n                continue\n            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)\n\n            if not done[c]:\n                for cc in subs[c]:\n                    if allm - cc in masks:\n                        other = masks[allm - c]\n                        pairs[v] = i, other\n                        return True\n                    masks[cc] = i\n                    done[cc] = True\n\n        return False\n\n    return check\n\n@prof\ndef go():\n    n, m = map(int, input().split())\n\n    a = []\n\n    uniq = set()\n    for _ in range(n):\n        aa = tuple(map(int, input().split()))\n\n        a.append(aa)\n        uniq.update(aa)\n\n    uniq = sorted(uniq)\n    pairs = {0: (0, 0)}\n    check = mcheck(a, pairs)\n    l = 0\n    r = len(uniq) - 1\n    while l != r:\n        if debug: print(l, r)\n        if l + 1 == r:\n            if check(uniq[r]):\n                l = r\n            else:\n                r = l\n            continue\n        c = (l + r) \/\/ 2\n        if check(uniq[c]):\n            l = c\n        else:\n            r = c\n\n    l = uniq[l]\n    if debug: print(l, pairs[l])\n    if l not in pairs:\n        check(l)\n    a = pairs[l][0]\n    b = pairs[l][1]\n    if b == -1:\n        b = a\n\n    print(\"%d %d\" % (a + 1, b + 1))\n\ngo()","output":"np"},{"instruction":"import sys\ninput=sys.stdin.readline\nn,m=map(int,input().split())\nfor i in range(n\/\/2+n%2):\n    x1=i+1\n    x2=n-i\n    if(x1==x2):\n        for j in range(m\/\/2+m%2):\n            if(j+1==m-j):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n            else:\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n    else:\n        if(i%2==0):\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n        else:\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(m-j)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(j+1)+\"\\n\"))","output":"quadratic"},{"instruction":"import math\nn = int(input())\n\nif n>0:\n    print(n)\nelse:\n    l = list(str(n))\n\n    last = l[0:len(l)-1]\n    second = l[0:len(l)-2]\n    second+=l[-1]\n    lR = \"\".join(last)\n    sR = \"\".join(second)\n\n    print(max(eval(lR),eval(sR)))","output":"constant"},{"instruction":"from math import factorial as fact\ns1 = input()\ns2 = input()\nplus1 = s1.count(\"+\")\nminus1 = s1.count(\"-\")\n\nplus2 = s2.count(\"+\")\nminus2 = s2.count(\"-\")\nqCount = s2.count(\"?\")\n\nif(plus1==plus2 and minus1==minus2):\n\tprint(1)\nelse:\n\tplusReq = plus1 - plus2\n\tminusReq = minus1 - minus2\n\tif(plusReq >= 0 and minusReq >= 0):\n\t\tans = (0.5**qCount)*fact(qCount)\/(fact(plusReq)*fact(minusReq))\n\t\tprint(ans)\n\n\telse:\n\t\tprint(0)","output":"np"},{"instruction":"def pow(n):\n    if(n > 0):\n        if(n % 2 == 0):\n            x = pow(n \/\/ 2) % 1000000007\n            return (x * x) % 1000000007\n        else: return (pow(n - 1) * 2)% 1000000007\n    else:\n        return 1\n\nn, k = map(int, input().split())\nif(n == 0): print(0)\nelse: print((pow(k) * (2 * n - 1) + 1) % 1000000007)","output":"logn"},{"instruction":"n=int(input())\ns=0; pred=0\nfor i in range(1,20):\n    m=9*pow(10,i-1)*i\n    s+=m\n    if n<=s:\n        nd=pow(10,i-1)\n        sme=n-pred\n        num=sme\/\/i\n        ost=sme%i\n        if ost==0:\n            dig=nd+num-1\n        else:\n            dig=nd+num\n        d=i\n        rez=[]\n        ddig=dig\n        while d>0:\n            o=ddig%10\n            a=ddig\/\/10\n            rez.append(o)\n            d-=1\n            ddig=a\n        break\n    pred=s\nprint(str(rez[-ost]))","output":"logn"},{"instruction":"import math\n\nn, r = map(int, input().split())\ns = math.sin(math.pi \/ n)\nprint('%.7lf' % (r * s \/ (1 - s)))","output":"constant"},{"instruction":"x=list(map(int,input().split()))\npos=x[1]\nn=x[0]\nl=x[2]\nr=x[3]\nstep=0\nif pos<l :\n    step=l-pos+1\n\n    if r< n :\n        step+=r-l+1\nelif pos>r:\n    step=pos-r+1\n\n    if l> 1 :\n        step+=r-l+1\nelse:\n    if l>1 and n>r:\n        step+=min(pos-l,r-pos)+r-l+2\n    elif l==1 and n>r:\n        step=r-pos+1\n    elif l>1 and n==r:\n        step+=pos-l+1\n    else:\n        step=0\n\nprint(step)","output":"constant"},{"instruction":"T = input().split(' ')\nn = int(T[0])\nm = int(T[1])\nS = input().split(' ')\nfor i in range(n):\n    S[i] = int(S[i])\nind = 0\nfor k in range(n):\n    if S[k] == m:\n        ind = k\nk = ind\nP = [0]*(n+1)\nN = [0]*(n+1)\nR = [0]*(n-k)\nL = [0]*(k+1)\nfor i in range(k):\n    if S[k-1-i] < m:\n        L[k-1-i] = L[k-i] - 1\n    else:\n        L[k-1-i] = L[k-i] + 1\nfor i in range(n-k-1):\n    if S[k+1+i] > m:\n        R[1+i] = R[i] + 1\n    else:\n        R[1+i] = R[i] - 1\nc = 0\nfor el in R:\n    if el >= 0:\n        P[el]+=1\n        if el == 0:\n            N[el]+=1\n    else:\n        N[-el]+=1\nfor el in L:\n    if el >= 1:\n        c = c + N[el] + N[el-1]\n    else:\n        c = c + P[-el] + P[-el+1]\nprint(c)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\n\ndef main():\n    n,m = map(int,input().split())\n    a = []\n    for _ in [0]*n:\n        a.append(list(map(int,input().split())))\n\n    ok = 0\n    ng = 10**9+1\n    judge = pow(2,m)-1\n    dg = 1000\n\n    while ng-ok > 1:\n        mid = (ng+ok)\/\/2\n        tank = set()\n        for i in range(n):\n            r = 0\n            for j in range(m):\n                r *= 2\n                if a[i][j] >= mid:\n                    r += 1\n            tank.add(r)\n\n        for p in tank:\n            for q in tank:\n                if p|q == judge:\n                    ok = mid\n                    break\n        if ok != mid:\n            ng = mid\n\n    tank = set()\n    res = []\n    for i in range(n):\n        r = 0\n        for j in range(m):\n            r *= 2\n            if a[i][j] >= ok:\n                r += 1\n        if not r in tank:\n            res.append(i*dg+r)\n        tank.add(r)\n\n    for p in res:\n        for q in res:\n            if (p%dg)|(q%dg) == judge:\n                print(p\/\/dg+1,q\/\/dg+1)\n                return\n\nif __name__ == '__main__':\n    main()","output":"np"},{"instruction":"def maxXORInRange(L, R):\n    LXR = L ^ R\n    msbPos = 0\n    while(LXR):\n\n        msbPos += 1\n        LXR >>= 1\n    maxXOR, two = 0, 1\n\n    while (msbPos):\n\n        maxXOR += two\n        two <<= 1\n        msbPos -= 1\n\n    return maxXOR\nL, R = map(int,input().split())\nprint(maxXORInRange(L, R))","output":"logn"},{"instruction":"n, m, k = map(int, input().split())\nea = [list(map(int, input().split()))for _ in range(n)]\neb = [list(map(int, input().split()))for _ in range(n-1)]\ndp = [[[10**20]*m for __ in range(n)]for _ in range(k\/\/2+1)]\ndp[0] = [[0]*m for _ in range(n)]\n\ndef show_ans():\n    for line in dp[-1]:\n        print(' '.join(map(str, [d*2 for d in line])))\n\nif k % 2:\n    for i in range(n):\n        print(' '.join(['-1']*m))\n    exit()\nfor t in range(1, k\/\/2+1):\n    for i in range(n):\n        for j in range(m):\n            if i:\n                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i-1][j]+eb[i-1][j])\n            if i < n-1:\n                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i+1][j]+eb[i][j])\n            if j:\n                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j-1]+ea[i][j-1])\n            if j < m-1:\n                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j+1]+ea[i][j])\nshow_ans()","output":"cubic"},{"instruction":"from decimal import *\nar = [list(map(float, input().split())) for i in range(int(input()))]\ndp = [[0 for i in range(1 << 18)] for j in range(18)]\nn, ans = len(ar), 0\ndp[0][(1 << n) - 1] = 1\nfor i in range((1 << n) - 1, 0, -1):\n    for j in range(n):\n        if i & (1 << j) == 0:\n            continue\n        for k in range(n):\n            if i & (1 << k) != 0 or j == k:\n                continue\n            dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k])\nfor i in range(n):\n    ans = max(ans, dp[i][1 << i])\nprint('{:.6f}'.format(ans))","output":"np"},{"instruction":"import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn=int(input())\ns=input()\nt=input()\nif sorted(s)!=sorted(t):\n    print(-1)\n    quit()\ns=list(s)\nt=list(t)\nans=[]\nfor i in range(n):\n    for j in range(i,n-1):\n        if s[j+1] == t[i]:\n            for k in range(j,i-1,-1):\n                ans.append(k+1)\n                s[k+1], s[k] = s[k], s[k+1]\n            break\nprint(len(ans))\nprint(*ans)","output":"quadratic"},{"instruction":"def main():\n\n    n,m = map(int, input().split())\n    S = [list(str(input())) for _ in range(n)]\n\n    L = [[0]*m for _ in range(n)]\n    R = [[0]*m for _ in range(n)]\n    U = [[0]*m for _ in range(n)]\n    D = [[0]*m for _ in range(n)]\n\n    for i in range(n):\n        cnt = 0\n        for j in range(m):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                L[i][j] = cnt\n        cnt = 0\n        for j in reversed(range(m)):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                R[i][j] = cnt\n\n    for j in range(m):\n        cnt = 0\n        for i in range(n):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                U[i][j] = cnt\n        cnt = 0\n        for i in reversed(range(n)):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                D[i][j] = cnt\n\n    imosH = [[0]*(m+1) for _ in range(n)]\n    imosV = [[0]*m for _ in range(n+1)]\n    ans = []\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            if S[i][j] == '.':\n                continue\n            l = L[i][j]-1\n            r = R[i][j]-1\n            u = U[i][j]-1\n            d = D[i][j]-1\n            s = min([l, r, u, d])\n            if s == 0:\n                continue\n            ans.append((i+1, j+1, s))\n            imosV[i-s][j] += 1\n            imosV[i+s+1][j] -= 1\n            imosH[i][j-s] += 1\n            imosH[i][j+s+1] -= 1\n\n    from itertools import accumulate\n    for i in range(n):\n        imosH[i] = list(accumulate(imosH[i]))\n    for j in range(m):\n        for i in range(1, n+1):\n            imosV[i][j] += imosV[i-1][j]\n\n    for i in range(n):\n        for  j in range(m):\n            if S[i][j] == '*':\n                if imosH[i][j] <= 0 and imosV[i][j] <= 0:\n                    print(-1)\n                    exit()\n    else:\n        print(len(ans))\n        for i in range(len(ans)):\n            print(*ans[i])\n\nif __name__ == '__main__':\n    main()","output":"quadratic"},{"instruction":"from sys import stdin\n\ndef solve(tc):\n    n, k = map(int, stdin.readline().split())\n\n    if n == 1:\n        print(0)\n        return\n\n    if n <= k:\n        print(1)\n        return\n\n    lo, hi = 1, k-1\n    while lo < hi:\n        mid = lo + (hi-lo+1)\/\/2\n\n        cum = (k-2+mid-1)*(k-mid)\/\/2\n        if cum < n-k:\n            hi = mid - 1\n        else:\n            lo = mid\n\n    if lo == 1:\n        print(-1)\n        return\n\n    print(k-lo+1)\n\ntcs = 1\nfor tc in range(tcs):\n    solve(tc)","output":"logn"},{"instruction":"def main():\n    n, k = map(int, input().split(' '))\n\n    if(k > 2*n):\n        return(0)\n    if(k == 2*n or k==1):\n        return(2)\n\n    iguales = [0]*(k+1)\n    diferentes = [0]*(k+1)\n\n    iguales[1] = 2\n    diferentes[2] = 2\n\n    modulo = 998244353\n\n    for i in range(1, n):\n        auxigual = [0]*(k+1)\n        auxdiff = [0]*(k+1)\n\n        for j in range(1, k+1):\n            auxigual[j] = (iguales[j] + iguales[j-1] + 2*diferentes[j]) % modulo\n\n        for k in range(2, k+1):\n            auxdiff[k] = (diferentes[k] + diferentes[k-2] + 2*iguales[k-1]) % modulo\n\n        iguales = auxigual\n        diferentes = auxdiff\n\n    return((iguales[-1] + diferentes[-1]) % modulo)\n\nprint(main())","output":"np"},{"instruction":"from collections import defaultdict\n\ndef main():\n    R, G, B = map(int, input().split())\n    red = list(map(int, input().split()))\n    green = list(map(int, input().split()))\n    blue = list(map(int, input().split()))\n    red.sort(reverse=True)\n    green.sort(reverse=True)\n    blue.sort(reverse=True)\n    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]\n    dp[0][0][0] = 0\n    ans = 0\n    for i in range(R+1):\n        for j in range(G+1):\n            for k in range(B+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]\n                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])\n                ans = max(ans, dp[i][j][k])\n    print(ans)\n    return\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"import sys\nimport io, os\nimport math\nfrom heapq import *\ngcd = math.gcd\nsqrt = math.sqrt\nceil = math.ceil\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\ndef strinp(testcases):\n    k = 5\n    if (testcases == -1 or testcases == 1):\n        k = 1\n    f = str(input())\n    f = f[2:len(f) - k]\n    return f\ndef ind(ch):\n    return ord(ch)-ord(\"a\")\ndef main():\n    n=int(input())\n    b=[0]\n    cost=b+list(map(int, input().split()))\n    arr=b+list(map(int, input().split()))\n    nv=[-1]*(n+1)\n    colors=[]\n    c=0\n    for i in range(1,n+1):\n        if(nv[i]!=-1):\n            continue\n        nv[i]=c\n        dest=arr[i]\n        while(nv[dest]==-1):\n            nv[dest]=c\n            dest=arr[dest]\n        if(nv[dest]==c):\n            colors.append(dest)\n        c+=1\n    s=0\n    for i in colors:\n        mi=cost[i]\n        nxt=arr[i]\n        while(nxt!=i):\n            mi=min(mi,cost[nxt])\n            nxt=arr[nxt]\n        s+=mi\n    print(s)\nmain()","output":"linear"},{"instruction":"n, s = map(int, input().split())\nans = s\nfor i in range(n):\n    f, t = map(int, input().split())\n    if(t>(s-f)):\n        ans +=  t - (s-f)\n        s += t - (s-f)\n\nprint(ans)","output":"linear"},{"instruction":"n = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if l[i][0] - l[i][1] >= l[last][0] - l[last][1] and abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n\nprint(ans)","output":"nlogn"},{"instruction":"n,m = map(int,input().split())\nfinal = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    final.append([a,b])\nfinal.sort(key = lambda x: x[0]-x[1])\ns1 = 0\ns2 = 0\nfor i in final:\n    s2+=i[1]\n    s1+=i[0]\nif s2>m:\n    print(-1)\nelse:\n    if s1<=m:\n        print(0)\n    else:\n        i = n-1\n        count = 0\n        while s1>m:\n            s1 = s1 - (final[i][0]-final[i][1])\n            count+=1\n            i-=1\n        print(count)","output":"nlogn"},{"instruction":"num=int(input())\n\nvals=list(map(int,input().split()))\n\nvals.sort()\n\nflag=0\n\nfor i in vals:\n    if i>vals[0]:\n        print(i)\n        flag=1\n        break\n\nif flag==0:\n    print('NO')","output":"nlogn"},{"instruction":"import sys,os,io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_right , bisect_left\n\nimport math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n \/ 2\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n        while n % i== 0:\n            l.append(int(i))\n            n = n \/ i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef power(x, y, p) :\n\tres = 1\n\tx = x % p\n\tif (x == 0) :\n\t\treturn 0\n\twhile (y > 0) :\n\t\tif ((y & 1) == 1) :\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\n\ndef si():\n    return input()\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n\/\/x\n    return n\/\/x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\nt = 1\nfor _ in range(t):\n    a = input()\n    b = input()\n    ans = [a]\n    a = list(a)\n    b1 = b[:]\n    b = list(b)\n    if (len(a)<len(b)):\n        a.sort(reverse=True)\n        print(''.join(a))\n        continue\n    arr = [0]*10\n    for i in a:\n        arr[int(i)]+=1\n    f = 0\n    for chota in range(len(b)):\n        arr1 = arr[:]\n        temp = b[:chota]\n\n        for h in range(chota):\n            if (arr1[int(b[h])]<=0):\n                f = 1\n                break\n            else:\n                arr1[int(b[h])]-=1\n\n        if (f==1):\n            break\n        aa = []\n        for j in range(int(b[chota])-1,-1,-1):\n\n            if (arr1[j]>0):\n                temp.append(str(j))\n                arr1[j]-=1\n                break\n        for h in range(9,-1,-1):\n            if (arr1[h]>0):\n                temp+=[str(h)]*arr1[h]\n\n        ans.append(''.join(temp))\n\n    for i in ans:\n        if (i<=b1):\n            m = i\n            break\n    a.sort(reverse=True)\n    ans.append(''.join(a))\n\n    for i in ans:\n        if (i<=b1):\n            if (i>m):\n                m = i\n    print(m)","output":"cubic"},{"instruction":"n = int(input())\ns = list(input())\nt = input()\nif sorted(s) != sorted(t):\n    print(-1)\nelse:\n    lst = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if s[j] == t[i]:\n                lst[j] = i + 1\n                s[j] = \".\"\n                break\n    ans = 0\n    a = []\n    for i in range(n):\n        for j in range(n - 1):\n            if i != j:\n                if lst[j] > lst[j + 1]:\n                    ans += 1\n                    lst[j], lst[j + 1] = lst[j + 1], lst[j]\n                    a.append(j+1)\n    print(ans)\n    print(*a)","output":"quadratic"},{"instruction":"n=int(input())\na=[0,0]+[int(x) for x in input().split()]\nans=[0]*(n+1)\nfor i in range(n,1,-1):\n    if ans[i]==0:\n        ans[i]=1\n    ans[a[i]]+=ans[i]\nif n==1:\n    ans[1]=1\nans=ans[1:]\nans.sort()\nprint(*ans)","output":"nlogn"},{"instruction":"l,r=map(int,input().split())\nif(l==r):\n    print(0)\nelse:\n    if(r&(r-1)==0):\n        print(r^(r-1))\n    else:\n        x=l^r\n        p1=1\n        while(p1<=x):\n            p1*=2\n        print(p1-1)","output":"logn"},{"instruction":"from __future__ import division\nfrom sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\na, cur, ans = rints()[::-1], 2, -1\n\nfor i in range(n - 2):\n    cur = max(cur, i + 2)\n    for j in range(cur, n):\n        if a[i] - a[j] < 1:\n            cur += 1\n            continue\n\n        if a[i] - a[j] > m:\n            break\n\n        cur += 1\n\n        v = (a[i] - a[j - 1]) \/ (a[i] - a[j])\n        ans = max(ans, v)\n\nprint(ans)","output":"nlogn"},{"instruction":"import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nrn,gn,bn=MI()\nrr=LI()\ngg=LI()\nbb=LI()\nrr.sort(reverse=True)\ngg.sort(reverse=True)\nbb.sort(reverse=True)\ndp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]\ndp[0][0][0]=0\nans=0\nfor i in range(rn+1):\n    for j in range(gn+1):\n        for k in range(bn+1):\n            pre=dp[i][j][k]\n            if pre==-1:continue\n            ans=max(ans,pre)\n            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])\n            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])\n            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])\n\nprint(ans)","output":"cubic"},{"instruction":"import sys\n\nnext(sys.stdin)\n\nq_x, q_y = map(int, next(sys.stdin).rstrip().split())\nk_x, k_y = map(int, next(sys.stdin).rstrip().split())\ndest_x, dest_y = map(int, next(sys.stdin).rstrip().split())\n\ndef sign(x):\n    return 1 if x >= 0 else -1\n\ndef which_square(x, y):\n    return sign(x - q_x), sign(y - q_y)\n\nif which_square(k_x, k_y) == which_square(dest_x, dest_y):\n    print(\"YES\")\nelse:\n    print(\"NO\")","output":"constant"},{"instruction":"from math import log2\nn = int(input())\nif n == 1:\n    print(1)\n    exit()\nelif n == 3:\n    print(1, 1, 3)\n    exit()\nl = [1] * (n \/\/ 2)\nif n % 2 == 1:\n    l.append(1)\n\nxn = int(log2(n))\ntmp = n - len(l)\nfor i in range(2, xn+1):\n    fn = tmp \/\/ 2\n    if tmp % 2 == 1:\n        fn += 1\n    tmp -= fn\n    l += ([pow(2, i-1)] * fn)\nl.append((n \/\/ pow(2, xn - 1)) * pow(2, xn - 1))\nprint(' '.join(str(i) for i in l))","output":"linear"},{"instruction":"k = int(input())\nprev=0\nnextt=0\nNumofDigits=0\n\nwhile(True):\n    prev = nextt\n    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)\n    if(k>= prev and k<=nextt):\n        break\n    NumofDigits=NumofDigits+1\nif(NumofDigits==1):\n    print(k)\nelse:\n    result = (10**(NumofDigits-1))+int((k-(prev+1))\/NumofDigits)\n    i=0\n    while(True):\n        if (k-int(prev+1))%NumofDigits == i:\n            break\n        i=i+1\n    result = str(result)\n    print(result[i])","output":"constant"},{"instruction":"from sys import stdin, stdout\n\nget_string = lambda: stdin.readline().strip('\\n')\nget_intmap = lambda: map( int, get_string().split(' ') )\n\ndef testcase():\n    n, M = get_intmap()\n    a = [0] + list(get_intmap()) + [M]\n    ontime = [0] * (n + 1)\n    tmp = 0\n    for ind in range(n, -1, -1):\n        if ind %2 == 0:\n            tmp += a[ind + 1] - a[ind]\n        ontime[ind] = tmp\n    mx = ontime[0]\n\n    for ind in range(n + 1):\n        l,r = a[ind], a[ind+1]\n        if r - l <= 1: continue\n        for x in (l+1, r-1):\n            newtime = ontime[0] - ontime[ind]\n            if ind % 2 == 0:\n                newtime += x - l\n            else:\n                newtime += r - x\n            newtime += (M - r) - ontime[ind]\n            mx = max(mx, newtime)\n    print(mx)\n\ntestcase();quit()\nfor t in range(int(input())):\n    testcase()","output":"linear"},{"instruction":"str=input()\nn=len(str)\nans=0\namap={}\ndef fun():\n    global ans\n    for strLen in range(n,0,-1):\n        mark=0\n        for t in range(0,n):\n            if t+strLen>n:\n                break\n            s=str[t:t+strLen]\n            if s in amap:\n                amap[s]+=1\n            else:\n                amap[s]=1\n            if amap[s]>=2:\n                mark=1\n                ans=len(s)\n                print(ans)\n                break\n        if mark==1:\n            break\nfun()\nif ans==0:\n    print(ans)","output":"cubic"},{"instruction":"a,b=map(int,input().split())\n\nb1=bin(b)[2:]\na1=bin(a)[2:]\nif len(a1)==len(b1) :\n    d=(b^a)\n    v=d.bit_length()\n    print(int(\"0\"+\"1\"*(v),2))\nelse :\n    print(int(\"1\"*len(b1),2))","output":"logn"},{"instruction":"from collections import defaultdict\n\nn,a,b = map(int,input().split())\n\nhash = defaultdict(list)\n\nif a == 1 and b == 1:\n    if n == 2 or n == 3:\n        print('NO')\n        exit()\n\nif a == 1 or b == 1:\n\n    bool = [False]*(n+1)\n\n    if a>n or b>n:\n        print('NO')\n        exit()\n    print('YES')\n\n    l = []\n    for i in range(n):\n        z = ['0']*(n)\n        l.append(z)\n    ans = []\n\n    for i in range(n):\n        z = ['0']*(n)\n        ans.append(z)\n\n    if b == 1:\n\n        for i in range(a-1,n-1):\n\n            l[i][i+1] = '1'\n            l[i+1][i] = '1'\n\n        for i in l:\n            print(''.join(i))\n    else:\n\n        ans = []\n\n        for i in range(n):\n           z = ['0']*(n)\n           ans.append(z)\n\n        for i in range(b-1,n-1):\n\n            l[i][i+1] = '1'\n            l[i+1][i] = '1'\n\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    if l[i][j] == '1':\n                        ans[i][j] = '0'\n                    if l[i][j] == '0':\n                        ans[i][j] = '1'\n\n        for i in ans:\n            print(''.join(i))\n\nelse:\n    print('NO')","output":"quadratic"},{"instruction":"import sys\nimport copy\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\nC=list(input().strip())\n\ndef JUDGE(C):\n    ANS_one=0\n    ANS_zero=0\n\n    for c in C:\n        if c==\"0\":\n            ANS_zero+=1\n        else:\n            break\n\n    for c in C[::-1]:\n        if c==\"0\":\n            ANS_zero+=1\n        else:\n            break\n\n    for c in C:\n        if c==\"1\":\n            ANS_one+=1\n        else:\n            break\n\n    for c in C[::-1]:\n        if c==\"1\":\n            ANS_one+=1\n        else:\n            break\n\n    if ANS_zero>=n-k or ANS_one>=n-k:\n        return 1\n    else:\n        return 0\n\nif JUDGE(C)==1:\n    print(\"tokitsukaze\")\n    sys.exit()\n\nif k>=n-1:\n    print(\"quailty\")\n    sys.exit()\nif k<n\/2:\n    print(\"once again\")\n    sys.exit()\n\nCAN1=copy.copy(C)\nCAN2=copy.copy(C)\n\nif C[0]==\"0\":\n    for i in range(1,k+1):\n        CAN1[i]=\"1\"\nelse:\n    for i in range(1,k+1):\n        CAN1[i]=\"0\"\n\nif C[-1]==\"0\":\n    for i in range(n-1,n-k-1,-1):\n        CAN2[i]=\"1\"\nelse:\n    for i in range(n-2,n-k-2,-1):\n        CAN2[i]=\"0\"\n\nif JUDGE(CAN1)==1 and JUDGE(CAN2)==1:\n    print(\"quailty\")\n    sys.exit()\nelse:\n    print(\"once again\")\n    sys.exit()","output":"linear"},{"instruction":"x, y, z, t1, t2, t3 = map( int, input().split() )\nelevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3\nstairs = t1 * abs( x - y )\nif elevator > stairs:\n    print( 'NO' )\nelse:\n    print( 'YES' )","output":"constant"},{"instruction":"n,m = map(int,input().split())\narr1 = [int(i) for i in input().split()]\narr2 = [int(i) for i in input().split()]\n\nfor first in arr1:\n    for second in arr2:\n        if first == second:\n\n            print(first,end=\" \")","output":"quadratic"},{"instruction":"n,m = map(int,input().split())\n\nif m<=n:\n    print((m-1)\/\/2)\nelif m>n:\n    if (m-n) in range(1,n+1):\n        if(n-(m-n))%2==0:\n            print((n-(m-n))\/\/2)\n        else:\n            print((n-(m-n))\/\/2+1)\n    else:\n        print(0)","output":"constant"},{"instruction":"n, m, k = map(int, input().split())\n*a, = map(int, input().split())\ndp = [-1] * (n + 15)\nfor i in range(n):\n    s, mx = a[i], max(0, a[i])\n    for j in range(i - 1, max(-1, i - m), -1):\n        s += a[j]\n        mx = max(mx, s)\n    dp[i] = max(0, dp[i - m] + s - k, mx - k)\nprint(max(dp))","output":"quadratic"},{"instruction":"n = int(input())\nprint(25)","output":"constant"},{"instruction":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n\n        def backtrack(i, total):\n            if i ==len(nums):\n                return  total == target\n\n            return (backtrack(i + 1, total + nums[i]) +\n                    backtrack(i + 1, total - nums[i]))\n\n        return backtrack(0, 0)","output":"np"},{"instruction":"def check(st):\n    count = 1\n    i = 1\n    pre = st[0]\n    maxi = 0\n    pre_indx = 0\n    indx = [0 for i in range(n)]\n    while i<n:\n        if pre != st[i]:\n            count+=1\n        else:\n            indx[pre_indx] =count\n            count=1\n            pre_indx=i\n        pre =st[i]\n        i+=1\n    indx[pre_indx] =count\n    return indx\n\nst=input()\nn=len(st)\nactual_indx=check(st)\nreverse_indx=check(st[::-1])\nif st[0] ==st[-1]:\n    print(max(actual_indx))\nelse:\n    print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))","output":"linear"},{"instruction":"def color(x, y):\n\n\treturn 'white' if (x + y) % 2 == 0 else 'black'\n\ndef white(x1, y1, x2, y2):\n\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\tif color(x1, y1) != color(x2, y2):\n\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n\telse:\n\t\tif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) \/\/ 2\n\t\telif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) \/\/ 2\n\t\telse:\n\t\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) \/\/ 2\n\ndef black(x1, y1, x2, y2):\n\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\treturn (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)\n\ndef intersect_1D(x1, x2, x3, x4):\n\n\treturn max(x1, x3), min(x2, x4)\n\ndef intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):\n\n\txl, xr = intersect_1D(x1, x2, x3, x4)\n\tyl, yr = intersect_1D(y1, y2, y3, y4)\n\treturn xl, yl, xr, yr\n\nfor i in range(int(input())):\n\tn, m = map(int, input().split())\n\n\tx1, y1, x2, y2 = map(int, input().split())\n\n\tx3, y3, x4, y4 = map(int, input().split())\n\n\tw0, b0 = white(1, 1, m, n), black(1, 1, m, n)\n\n\t_b0 = black(x1, y1, x2, y2)\n\n\tw1, b1 = w0 + _b0, b0 - _b0\n\n\t_w1 = white(x3, y3, x4, y4)\n\n\tw2, b2 = w1 - _w1, b1 + _w1\n\n\txl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)\n\n\t_b2 = black(xl, yl, xr, yr)\n\n\tw3, b3 = w2 - _b2, b2 + _b2\n\n\tprint(w3, b3)","output":"constant"},{"instruction":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nak=[]\ni=0\nwhile 2**i <=2000000000:\n    ak.append(2**i)\n    i+=1\n\nn=int(input())\na=list(map(int,input().split()))\nd=dict()\nfor i,v in enumerate(a):\n    d[v]=d.get(v,set())\n    d[v].add(i)\nans=[0]*n\nfor i in range(n):\n    for j in ak:\n        if j-a[i] in d:\n            if (j-a[i]==a[i] and len(d[a[i]])>=2) or j-a[i]!=a[i] :\n                ans[i]=1\n                break\nprint(ans.count(0))","output":"nlogn"},{"instruction":"def A(n):\n\treturn (4**n-1)\/\/3\n\nL = 31\n\nT = int(input())\nfor _ in range(T):\n\tn,k = [int(_) for _ in input().split()]\n\n\tif n > L:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\n\tif k > A(n):\n\t\tprint(\"NO\")\n\t\tcontinue\n\n\tE = 1\n\tM = 0\n\tR = 0\n\twhile n >= 0:\n\t\tM += E\n\n\t\tI = 2*E-1\n\t\tE = 2*E+1\n\n\t\tn -= 1\n\t\tR += I*A(n)\n\n\t\tif M <= k and k <= M+R: break\n\n\tif n >= 0: print(\"YES\",n)\n\telse: print(\"NO\")","output":"linear"},{"instruction":"def cal(r,g,b):\n\tif dp[r][g][b]!=-1:\n\t\treturn dp[r][g][b]\n\tans=0\n\tif r<R and g<G:\n\t\tans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))\n\tif r<R and b<B:\n\t\tans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))\n\tif g<G and b<B:\n\t\tans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))\n\tdp[r][g][b]=ans\n\treturn ans\n\nR,G,B=map(int,input().split())\nrl=sorted(list(map(int,input().split())),reverse=True)\ngl=sorted(list(map(int,input().split())),reverse=True)\nbl=sorted(list(map(int,input().split())),reverse=True)\ndp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]\nprint(cal(0,0,0))","output":"cubic"},{"instruction":"from operator import itemgetter\n\nn = int(input())\nif n == 1:\n    print(1)\nelse:\n    pi = list(map(int,input().split()))\n    ai = [1] * (n+1)\n    ai[0] = 10**9\n    for i in pi:\n        ai[i] = 0\n    for i in range(n-2,-1,-1):\n        ai[pi[i]] += ai[i+2]\n    ai.sort()\n    for i in range(n):\n        print(ai[i],end=\" \")","output":"linear"},{"instruction":"x= int(input(\"\"))\nprint(int((x\/2)*3))","output":"constant"},{"instruction":"import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, k = mi()\nans = None\nfor x in range(1, n + 1):\n    if x * (x + 3) == 2 * (k + n):\n        ans = n - x\n        break\nprint(ans)","output":"linear"},{"instruction":"from math import*\nn,k=map(int,input().split())\ns=1\ndob=2\nfor i in range(1,n):\n    s+=dob\n    dob+=1\n    if s-(n-i-1)==k:\n        print(n-i-1)\n        exit()\nprint(0)","output":"linear"},{"instruction":"n=int(input())\nn+=1\n\nif n%2==0 or n==1:\n\tprint(n\/\/2)\nelse:\n\tprint(n)","output":"constant"},{"instruction":"def get_sign_1(fo):\n\tdef res(s, f=fo):\n\t\tif f**2+s**2 == 2*f*s+1:\n\t\t\treturn '1'\n\t\telse:\n\t\t\treturn '0'\n\treturn res\n\ndef get_signs_2(cf, rev):\n\tcf -= 1\n\tif rev:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\telse:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\treturn res2\n\telse:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '1'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '0'\n\t\t\telse:\n\t\t\t\tdef res2(s):\n\t\t\t\t\treturn '0'\n\t\t\treturn res2\n\treturn res\nn, a, b = map(int, input().split())\nc = a*b\nif a+b == c+1 and (c > 1 or n == 1 or n > 3):\n\tprint(\"YES\")\n\tif c == 1:\n\t\tget_sign_f = get_sign_1\n\telse:\n\t\tget_sign_f = get_signs_2(c, c == b)\n\tfor foo in range(n):\n\t\tprint(''.join(map(get_sign_f(foo), range(n))))\nelse:\n\tprint(\"NO\")","output":"quadratic"},{"instruction":"n = int(input())\na = []\n\nfor i in range(1, n+1):\n    l, r = map(int, input().split())\n    a.append((l, r, i))\n\na.sort()\n\nfor i in range(n-1):\n    if (a[i][0] == a[i+1][0]):\n        print(str(a[i][2]) + ' ' + str(a[i+1][2]))\n        break\n\n    if (a[i][1] >= a[i+1][1]):\n        print(str(a[i+1][2]) + ' ' + str(a[i][2]))\n        break\nelse:\n    print('-1 -1')","output":"nlogn"},{"instruction":"a=input()\nn=len(a)\nb=[]\nc=0\nd=0\nfor i in range(1,n):\n    if a[i]==a[i-1]:\n        b.append(['bw'.find(a[c]),i-c])\n        d=max(d,i-c)\n        c=i\nb.append(['bw'.find(a[c]),n-c])\nd=max(d,n-c)\nif d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:\n    d=max(d,b[-1][1]+b[0][1])\nprint(d)","output":"linear"},{"instruction":"from math import factorial as fact\ns=input()\nt=input()\npos=s.count('+')-t.count('+')\nneg=s.count('-')-t.count('-')\nque=t.count('?')\nif pos<0 or neg<0:\n    print(0)\nelse:\n    print((fact(que)\/(fact(pos)*fact(neg)))\/(2**que))","output":"np"},{"instruction":"import sys, heapq\n\nn, m = map(int, sys.stdin.readline().split())\nfor _ in range(m):\n    a, b = map(int, sys.stdin.readline().split())\nans = [0] * n\nfor i in range(1, n, 2):\n    ans[i] = 1\nprint(''.join(map(str, ans)))","output":"linear"},{"instruction":"n, m, k = map(int, input().split(' '))\np = tuple(map(int, input().split(' ')))\n\nd = 0\npart = (p[0]-1) \/\/ k\nmoves = 0\nskip = 0\n\nfor pi in p:\n    if (pi-1-d) \/\/ k == part:\n        skip += 1\n        continue\n    d += skip\n    part = (pi-1-d) \/\/ k\n    skip = 1\n    moves += 1\n\nprint(moves+1)","output":"linear"},{"instruction":"n,m=map(int,input().split())\nlisti=[]\nfor i in range(0,n):\n    string=input()\n    listi.append(string)\nrownum=0\nflag=False\nfor row in listi:\n\n    for letter in row:\n            if(\"B\" in row):\n                p=row.index(\"B\")\n\n                s=row[::-1]\n                q=abs(m-s.index(\"B\")-1)\n\n                if(p==q):\n                    print(rownum+1,row.index(row[p])+1)\n                    flag=True\n                    break\n                mr=(q+p)\/2\n\n                length=abs(q-p+1)\n\n                rn= rownum + length\/\/2\n\n                print(rn+1,int(mr+1))\n                flag=True\n                break\n\n    if(flag==True):\n        break\n\n    rownum+=1","output":"quadratic"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n\n        def dfs(i, prev):\n            if i == len(intervals):\n                return 0\n            res = dfs(i + 1, prev)\n            if prev == -1 or intervals[prev][1] <= intervals[i][0]:\n                res = max(res, 1 + dfs(i + 1, i))\n            return res\n\n        return len(intervals) - dfs(0, -1)","output":"np"},{"instruction":"def go():\n    n = int(input())\n    for i in range(n):\n        a, b, d = [int(i) for i in input().split(' ')]\n        if a > d or b > d:\n            print(-1)\n        elif a % 2 == b % 2:\n            if a % 2 == d % 2:\n                print(d)\n            else:\n                print(d - 2)\n        else:\n            if a % 2 == b % 2:\n                if d % 2 == a % 2:\n                    print(d)\n                else:\n                    print(d - 2)\n            else:\n                print(d - 1)\ngo()","output":"constant"},{"instruction":"def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\ndef pre(x, y):\n    w = x * (y \/\/ 2) + (y % 2) * (x + 1) \/\/ 2\n    b = x * (y \/\/ 2) + (y % 2) * x \/\/ 2\n    assert w + b == x * y\n    return w\n\ndef count(x1, y1, x2, y2):\n    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)\n    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w\n    return w, b\n\nfor t in range(ii()):\n    n, m = mi()\n    x1, y1, x2, y2 = mi()\n    x3, y3, x4, y4 = mi()\n    w = pre(m, n)\n    b = m * n - w\n\n    wc, bc = count(x1, y1, x2, y2)\n    w -= wc\n    b -= bc\n    w += (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):\n        x5 = max(x1, x3)\n        y5 = max(y1, y3)\n        x6 = min(x2, x4)\n        y6 = min(y2, y4)\n        w -= (x6 - x5 + 1) * (y6 - y5 + 1)\n        wc, bc = count(x5, y5, x6, y6)\n        w += wc\n        b += bc\n    wc, bc = count(x3, y3, x4, y4)\n    w -= wc\n    b -= bc\n    b += (x4 - x3 + 1) * (y4 - y3 + 1)\n    print(w, b)","output":"constant"},{"instruction":"import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nf=[[0]*n for i in range(n)]\nfor i in range(n):\n    f[0][i]=a[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=f[i-1][j]^f[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])\nq=int(input())\nfor _ in range(q):\n    l,r=map(int,input().split())\n    print(f[r-l][l-1])","output":"quadratic"},{"instruction":"n, U = list(map(int, input().strip().split()))\nE = list(map(int, input().strip().split()))\n\nmmax = -1\nfor i in range(0, n-2):\n    j = i + 1\n    l = j + 1\n    r = n - 1\n    while l < r:\n        mid = (l + r) \/\/ 2\n        if E[mid] - E[i] <= U:\n            l = mid + 1\n        else:\n            r = mid - 1\n    if E[l] - E[i] <= U:\n        cur = (E[l] - E[j]) \/ (E[l] - E[i])\n        mmax = max(mmax, cur)\n    else:\n        if l - 1 > j and E[l-1] - E[i] <= U:\n            cur = (E[l-1] - E[j]) \/ (E[l-1] - E[i])\n            mmax = max(mmax, cur)\nprint(mmax)","output":"nlogn"},{"instruction":"N,M=map(int,input().split())\nL=[0]+[int(_) for _ in input().split()]+[M]\nsumL=[0]\nans=-10**30\nfor i in range(1,N+1):\n    sumL.append(sumL[-1]-(-1)**i*L[i])\nfor i in range(1,N+1):\n    if L[i]>L[i-1]+1:\n        ans=max(ans,2*sumL[i-1]-sumL[-1]-(-1)**(i)*(L[i]-1))\n    if L[i]<L[i+1]-1:\n        ans=max(ans,2*sumL[i]-sumL[-1]+(-1)**i*(L[i]+1))\nif N%2==0:\n    print(max(ans,sumL[-1]+M))\nelse:\n    print(max(ans+M,sumL[-1]))","output":"linear"},{"instruction":"def Is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor i in range(2, 100):\n    if not Is_prime(i) and not Is_prime(n - i):\n        print(i, n - i)\n        break","output":"constant"},{"instruction":"n, k = map(int, input().split())\nif n == 1:\n    print(0)\nelif (k*k -k)\/\/2 +1 < n:\n    print(-1)\nelse:\n    g, b = 0, k\/\/2\n    while b != 0:\n        while g +b <= k and (k*k -k)\/\/2 +1 -((g +b)**2 -(g +b))\/\/2 >= n:\n            g += b\n        b \/\/= 2\n    print(k -g)","output":"logn"},{"instruction":"class Solution:\n\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res","output":"quadratic"},{"instruction":"import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\nQ = int(readline())\n\ncnt = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        if A[i] > A[j]:\n            cnt += 1\n\ncnt %= 2\n\nAns = [None]*Q\nfor qu in range(Q):\n    l, r = map(int, readline().split())\n    if (r-l+1)*(r-l)\/\/2 & 1:\n        cnt ^= 1\n\n    Ans[qu] = 'odd' if cnt else 'even'\n\nprint('\\n'.join(Ans))","output":"quadratic"},{"instruction":"n = int(input())\nprint((n\/\/2)+1)","output":"constant"},{"instruction":"def max1(a,b):\n    if a>=b:\n        return a,b\n    else:\n        return  b,a\ndef minus(a,b):\n    p=a\/\/b\n    cnt=p\n    return b,(a-(b*cnt)),cnt\nn=int(input())\nfor _ in range(n):\n    a,b=input().split()\n    a=int(a)\n    b=int(b)\n    cnt=0\n\n    while a>0 and b>0:\n        a,b=max1(a,b)\n        a,b,p=minus(a,b)\n        cnt+=p\n\n    print(cnt)","output":"constant"},{"instruction":"import io\nimport os\n\nfrom functools import lru_cache\nfrom collections import defaultdict\n\ndef solve(N, A):\n\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    maxVal = 1000 + 100\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n\n                intervals[l].append(r)\n\n    dp = {}\n    dp[N] = 0\n    for left in range(N - 1, -1, -1):\n        best = float(\"inf\")\n        for right in intervals[left]:\n\n            best = min(best, 1 + dp[right + 1])\n        dp[left] = best\n\n    return dp[0]\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)","output":"cubic"},{"instruction":"import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nmod = 10 ** 9 + 7\n\nR,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\ndp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]\nans=0\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],\n                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],\n                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            elif i>0 and j>0:\n                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]\n            elif i>0 and k>0:\n                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]\n                ans = max(ans, dp[i][j][k])\n            elif j>0 and k>0:\n                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]\n            ans=max(ans,dp[i][j][k])\n\nprint(ans)","output":"cubic"},{"instruction":"import os\nimport sys\n\nfrom collections import *\n\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\nn=Int()\na=array()\n\nseries = [1]\nfact = 1\nfor i in range(n+1):\n    series.append(((series[-1]*2)%M + fact)%M)\n    fact = (fact*2)%M\n\nind = n-1\nans=0\n\nfor i in range(n):\n    ans = (ans + (a[i]*series[ind])%M )%M\n    ind-=1\n\nprint(ans)","output":"linear"},{"instruction":"def val(s):\n  ans = ((int(s.split('+')[0][1:]) + int(s.split('+')[1].split(')')[0])) \/ int(s.split('\/')[1]))\n  return ans\n\nn = int(input())\ns = []\nf = {}\nfor i in range(n):\n  ss = input()\n  s.append(val(ss))\n  if(s[i] not in f):\n    f[s[i]] = 1\n  else:\n    f[s[i]] += 1\n\nfor i in range(len(s)):\n  print(f[s[i]], end= \" \")\nprint()","output":"linear"},{"instruction":"import sys\n\ndef find_pair(candidate,data,m):\n    ans = (-1,-1)\n    binary_bit = [False for i in range(1 << m)]\n    for i in data:\n        bit_tmp = 0\n        for j in range(len(i)):\n            if i[j] >= candidate: bit_tmp |= 1 << j\n        binary_bit[bit_tmp] = True\n\n    for i in range(1 << m):\n        for j in range(1 << m):\n            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:\n                ans = i , j\n                break\n    return ans\n\ndef backtracking(candidate,ans,data):\n    idx_i = -1 ; idx_j = -1\n    for i in range(len(data)):\n        bit_tmp = 0\n        for j in range(len(data[i])):\n            if data[i][j] >= candidate: bit_tmp |= 1 << j\n        if bit_tmp == ans[0]: idx_i = i\n        if bit_tmp == ans[1]: idx_j = i\n\n    print(str(idx_i + 1) + \" \" + str(idx_j + 1))\n\ndef main():\n    n , m = [int(i) for i in input().split()]\n    data = [[int(i) for i in input().split()] for i in range(n)]\n    a = 0 ; b = 10**9 + 7\n    ans = (-1,-1)\n    candidate = -1\n    while a <= b:\n        mid = (a + b)\/\/2\n        bin_ans = find_pair(mid,data,m)\n        if bin_ans[0] != -1 and bin_ans[1] != -1:\n            ans = bin_ans\n            candidate = mid\n            a = mid + 1\n        else:\n            b = mid - 1\n    backtracking(candidate,ans,data)\n\nmain()","output":"np"},{"instruction":"def mul(x, y, md):\n\treturn x * y % md;\n\ndef power(x, y, md) :\n\tres = 1;\n\twhile (y != 0):\n\t\tif (y & 1):\n\t\t\tres = mul(res, x, 1000000007);\n\t\tx = mul(x, x, 1000000007);\n\t\ty >>= 1;\n\treturn res\n\ndef inv(x, md):\n\treturn power(x, md - 2, 1000000007);\n\nt = input().split()\na = int(t[0])\nk = int(t[1])\nif (a == 0):\n\tprint(0)\nelse:\n\tfirst = power(2, 2 * k, 1000000007);\n\tsecond = power(2, k, 1000000007);\n\tans = mul(first, 2 * a - 1, 1000000007) + second;\n\tthird = inv(second, 1000000007);\n\tans = mul(ans, third, 1000000007);\n\tprint(ans)","output":"logn"},{"instruction":"import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nt = int(rd())\nfor _ in range(t):\n    n = int(rd())\n    a = list(map(int, rd().split()))\n    b = []\n    res_a, res_b = 1, 1e18\n\n    a = sorted(a)\n    i = 0\n    while i < n-1:\n        if a[i] == a[i+1]:\n            b.append(a[i])\n            i += 1\n\n        i += 1\n\n    p2s = lambda x, y : (x+y)**2\/(x*y)\n\n    for i in range(len(b)-1):\n        if p2s(res_a, res_b) > p2s(b[i], b[i+1]):\n            res_a, res_b = b[i], b[i+1]\n\n    print(res_a, res_a, res_b, res_b)","output":"nlogn"},{"instruction":"a = int(input())\n\nprint(a**2+(a-1)**2)","output":"constant"},{"instruction":"from io import BytesIO, IOBase\nimport sys\nimport math\nimport os\nfrom collections import defaultdict\nfrom math import ceil\nfrom bisect import bisect_left, bisect_left\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef mint(): return map(int, input().split())\ndef mfloat(): return map(float, input().split())\n\ndef solve():\n    n, m, k = mint()\n    horizontal = [list(mint()) for i in range(n)]\n    vertical = [list(mint()) for i in range(n-1)]\n    if k%2 or max(n, m)==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n\n    dp = [[[0]*(k\/\/2+1) for i in range(m)] for j in range(n)]\n    for length in range(1, k\/\/2+1):\n        for i in range(n):\n            for j in range(m):\n\n                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k\/\/2]*2, end=' ')\n        print()\n\ndef main():\n\n    t = 1\n    for _ in range(t):\n        solve()\n\nif __name__ == \"__main__\":\n    main()","output":"cubic"},{"instruction":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = l + (r - l) \/\/ 2\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n        return nums[l]","output":"logn"},{"instruction":"import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import permutations\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,k=map(int,sys.stdin.readline().split())\n\nmod=998244353\ndp=[[0,0,0,0] for x in range(k+3)]\ndp[1][0]=1\ndp[1][1]=1\ndp[2][2]=1\ndp[2][3]=1\nnewdp=[[0,0,0,0] for x in range(k+3)]\nfor i in range(n-1):\n\n    for j in range(k+1):\n        newdp[j+1][1]+=dp[j][0]\n        newdp[j+1][3]+=dp[j][0]\n        newdp[j+1][2]+=dp[j][0]\n        newdp[j][0]+=dp[j][0]\n        newdp[j][1]+=dp[j][1]\n        newdp[j+1][3]+=dp[j][1]\n        newdp[j+1][2]+=dp[j][1]\n        newdp[j+1][0]+=dp[j][1]\n        newdp[j][1]+=dp[j][2]\n        newdp[j+2][3]+=dp[j][2]\n        newdp[j][2]+=dp[j][2]\n        newdp[j][0]+=dp[j][2]\n        newdp[j][1]+=dp[j][3]\n        newdp[j][3]+=dp[j][3]\n        newdp[j+2][2]+=dp[j][3]\n        newdp[j][0]+=dp[j][3]\n\n        for a in range(3):\n            for b in range(4):\n                newdp[a+j][b]%=mod\n    for a in range(k+3):\n        for b in range(4):\n            dp[a][b]=newdp[a][b]\n            newdp[a][b]=0\nans=sum(dp[k])\nans%=mod\nprint(ans)","output":"np"},{"instruction":"def check(mid,n,m,arr):\n\tmasks = {}\n\tfor index in range(n):\n\t\tarray = arr[index]\n\t\tx = 0\n\t\tfor i in range(m):\n\t\t\tif array[i] >= mid:\n\t\t\t\tx ^= (1<<i)\n\t\tmasks[x] = index+1\n\tans = False\n\ta,b = 1,1\n\tif (1<<m)-1 in masks.keys():\n\t\treturn True,(masks[(1<<m)-1],masks[(1<<m)-1])\n\tfor i in  masks.keys():\n\t\tfor j in masks.keys():\n\t\t\torAns = i|j\n\t\t\tif(orAns == ((1<<m)-1)):\n\t\t\t\tif i == (1<<m)-1 and (i in masks.keys()):\n\t\t\t\t\ta = masks[i]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif j == (1<<m)-1 and (j in masks.keys()):\n\t\t\t\t\tb =  masks[j]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif (i in masks.keys()) and (j in masks.keys()):\n\t\t\t\t\tans = True\n\t\t\t\t\ta,b = masks[i],masks[j]\n\t\t\t\t\tbreak\n\treturn ans,(a,b)\n\ndef solve(n,m,arr):\n\tmini = 0\n\tmaxi = int(1e9)+5\n\ti,j = 1,1\n\twhile(mini<=maxi):\n\t\tmid = (mini+maxi)\/\/2\n\t\tans,res = check(mid,n,m,arr)\n\t\tif(ans):\n\t\t\ti,j = res\n\t\t\tmini =mid +1\n\t\telse:\n\t\t\tmaxi = mid -1\n\tprint(i,j)\n\ndef main():\n\tn,m = map(int,input().split(' '))\n\tarr = []\n\tfor _ in range(n):\n\t\tx = list(map(int,input().split(' ')))\n\t\tarr.append(x)\n\tsolve(n,m,arr)\n\nmain()","output":"np"},{"instruction":"n, m = map(int,input().split())\n\nmax_dist = (n - 1)* n\/\/2\nmin_dist = max_dist\ncurr_value = max_dist\nfor i in range(n):\n    curr_value = i * (i + 1) \/\/ 2 + (n - 1 - i)*(n - i)\/\/2\n    min_dist = min(min_dist, curr_value)\n\nanswer = 0\nadd_value = 0\n\nfor i in range(m):\n    x, d = map(int, input().split())\n    answer+=x\n    if d >= 0:\n        add_value += d*max_dist\n    else:\n        add_value += d * min_dist\n\nprint(answer + (add_value \/ n))","output":"linear"},{"instruction":"n,k=map(int,input().split())\n\nans=k\/\/n\nif(k%n):\n    ans+=1\nprint(ans)","output":"constant"},{"instruction":"n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n  if a[i]==a[i+1]==0:\n    lose=True\n  if a[i]==a[i+1]:\n    if pair:\n      lose=True\n    pair=True\n    if i>=1:\n      if a[i]==a[i-1]+1:\n        lose=True\nif lose:\n  print(\"cslnb\")\nelse:\n  eventual=n*(n-1)\/\/2\n  curr=sum(a)\n  if (curr-eventual)%2==0:\n    print(\"cslnb\")\n  else:\n    print(\"sjfnb\")","output":"nlogn"},{"instruction":"n, m = map(int, input().split())\nres = 0\nmx = (n-1)*n\/\/2\nmn = 0\nif n&1:\n    mn = (n\/\/2)*(n\/\/2+1)\nelse:\n    mn = n*n\/\/4\nfor i in range(m):\n    x, d = map(int, input().split())\n    res += x*n\n    if d > 0:\n        res += mx*d\n    else:\n        res += mn*d\nprint('%.10f'%(res\/n))","output":"linear"},{"instruction":"s = input()\ns = s*3\nn = len(s)\nm,curr=1,1\nfor i in range(n-1):\n    if s[i]!=s[i+1]:\n        curr+=1\n        m=max(curr,m)\n    else:\n        curr=1\nprint(min(m,n\/\/3))","output":"linear"},{"instruction":"def solve(moves,candies_end):\n    total_candies = 1\n    low = 0\n    high = moves\n    while low <= high:\n        mid = (low+high)\/\/2\n        if (((moves-mid)*(moves-mid+1))\/\/2)-mid == candies_end:\n            return mid\n        elif (((moves-mid)*(moves-mid+1))\/\/2)-mid < candies_end:\n            high = mid-1\n        else:\n            low = mid+1\n\nn,k = map(int,input().split())\nprint(solve(n,k))","output":"logn"},{"instruction":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        dp = [0] * n\n        dp[0] = 1\n\n        def bs(r, target):\n            l = 0\n            while l < r:\n                m = (l + r) >> 1\n                if intervals[m][1] <= target:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        for i in range(1, n):\n            idx = bs(i, intervals[i][0])\n            if idx == 0:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[i - 1], 1 + dp[idx - 1])\n        return n - dp[n - 1]","output":"nlogn"},{"instruction":"print(\"?\",0,0)\ne=int(input())\nastr=\"000000000000000000000000000000\"\nbstr=\"000000000000000000000000000000\"\nabig=e\nfor i in range(30):\n    if abig==0:\n        print(\"?\",int(astr,2)+2**(29-i),int(bstr,2))\n        e=int(input())\n        if e==1:\n            continue\n        else:\n            if i<29:\n                astr=astr[:i]+\"1\"+astr[i+1:]\n                bstr=bstr[:i]+\"1\"+bstr[i+1:]\n            else:\n                astr=astr[:i]+\"1\"\n                bstr=bstr[:i]+\"1\"\n    else:\n        print(\"?\",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))\n        e=int(input())\n        if e==-abig:\n            if abig==1:\n                if i<29:\n                    astr=astr[:i]+\"1\"+astr[i+1:]\n                else:\n                    astr=astr[:i]+\"1\"\n            else:\n                if i<29:\n                    bstr=bstr[:i]+\"1\"+bstr[i+1:]\n                else:\n                    bstr=bstr[:i]+\"1\"\n            print(\"?\",int(astr,2),int(bstr,2))\n            abig=int(input())\n        else:\n            print(\"?\",int(astr,2)+2**(29-i),int(bstr,2))\n            e=int(input())\n            if e==-1:\n                if i<29:\n                    astr=astr[:i]+\"1\"+astr[i+1:]\n                    bstr=bstr[:i]+\"1\"+bstr[i+1:]\n                else:\n                    astr=astr[:i]+\"1\"\n                    bstr=bstr[:i]+\"1\"\nprint(\"!\",int(astr,2),int(bstr,2))","output":"logn"},{"instruction":"def check(x,n,k):\n    ate = x\n    rem = n-ate\n\n    if rem*(rem+1)\/\/2 == k+ate and rem >= 0 and ate >= 0:\n        return True\n\n    return False\n\ndef main():\n    n,k = map(int,input().split())\n    b = -1*(2*n+3)\n    a = 1\n    c = n**2\n    c += n-(2*k)\n\n    d = ((b**2)-(4*a*c))**0.5\n    x1 = (-b+d)\/2*a\n    x2 = (-b-d)\/2*a\n\n    if check(x1,n,k):\n        print(int(x1))\n        return\n\n    print(int(x2))\n\nmain()","output":"logn"},{"instruction":"import sys\nimport math\ninput = sys.stdin.readline\nfor _ in range(1):\n    n,pos,l,r = map(int,input().split())\n    if l == 1 and r == n:\n        print(0)\n        continue\n\n    if l != 1 and r != n:\n        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)\n\n    else:\n        if l == 1:\n            ans = abs(pos-r)+1\n\n        else:\n            ans = abs(pos-l)+1\n\n    print(ans)","output":"constant"},{"instruction":"N = 405\nn, m = map(int, input().split())\ndp = [[0]*N for _ in range(N)]\nc = [[1]*N for _ in range(N)]\np = [0]*N\n\np[0] = 1\nfor i in range(1, N):\n    p[i] = (p[i-1]*2) % m\nfor i in range(1, N):\n    for j in range(1, i):\n        c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m\n\ndp[0][0] = 1\nfor i in range(2, n+2):\n    for x in range(1, (n-1)\/\/2 + 2):\n        for k in range(1, i):\n            dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m\nans = 0\nfor i in range(1, (n-1)\/\/2 + 2):\n    ans = (ans + dp[n+1][i]) % m\nprint(ans)","output":"cubic"},{"instruction":"import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            sys.exit()\n    c+=aux\n    c1+=1\nprint(\"Yes\")","output":"nlogn"},{"instruction":"import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef main():\n    pass\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\ndef decimal(s):\n    return (int(s, 2))\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n \/\/= 2\n        p += 1\n    return (p)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n\n    l = list(s)\n\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n\n    return (cnt)\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) \/\/ f(r) \/\/ f(n - r)\n\nmod = int(1e9) + 7\nimport math\n\ndef deep(node):\n    visited[node-1]=1\n    if(len(d[node])==1):\n        return node\n    for c in d[node]:\n        if(visited[c-1]!=1):\n            return(deep(c))\n\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")","output":"linear"},{"instruction":"N=int(input())\nL=list(map(int,input().split()))\n\nDP=[[-1]*N for i in range(N)]\nfor d in range(N):\n    for s in range(N-d):\n        e=s+d\n        if s==e:\n            DP[s][e]=L[s]\n            continue\n        for m in range(s,e):\n            l=DP[s][m]\n            r=DP[m+1][e]\n            if l==r and l!=-1:\n                DP[s][e]=max(DP[s][e],l+1)\nDP2=[i+1 for i in range(N)]\nfor i in range(N):\n    if DP[0][i]!=-1:\n        DP2[i]=1\n        continue\n    for j in range(i):\n        if DP[j+1][i]!=-1:\n            DP2[i]=min(DP2[i],DP2[j]+1)\nprint(DP2[N-1])","output":"cubic"},{"instruction":"sum = [0 for i in range(12)]\ni = 0\nwhile sum[i] < 10 ** 12:\n    i += 1\n    sum[i] = sum[i - 1] + i * (10 ** i - 10 ** (i - 1))\nk = int(input())\ni = 0\nwhile k > sum[i]:\n    i += 1\nans = 10 ** (i - 1) - 1\nans += (k - sum[i - 1]) \/\/ i\nif (k - sum[i - 1]) % i != 0:\n    ans += 1\nprint(str(ans)[(k - sum[i - 1]) % i - 1])","output":"logn"},{"instruction":"def ask(a, b):\n    print(\"?\", a, b, flush=True)\n    return int(input()) <= 0\n\ndef solve(M):\n    a, b = 0, 0\n    less = ask(0, 0)\n\n    for i in range(M - 1, -1, -1):\n        bit = 1 << i\n\n        if less:\n            if not ask(a | bit, b | bit):\n                b |= bit\n                less = ask(a, b)\n            elif ask(a | bit, b):\n                a |= bit\n                b |= bit\n        else:\n            if ask(a | bit, b | bit):\n                a |= bit\n                less = ask(a, b)\n            elif ask(a | bit, b):\n                a |= bit\n                b |= bit\n\n    print(\"!\", a, b, flush=True)\n\nif __name__ == '__main__':\n    solve(30)","output":"constant"},{"instruction":"from operator import *\nn, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])","output":"quadratic"},{"instruction":"import random\n\nn = int(input())\nv = []\nfor i in range(0, n):\n    x, y = map(int, input().split())\n    v.append([x, y, i])\n\nwhile 1>0:\n    random.shuffle(v)\n    x = y = 0\n    ans = [0]*n\n    for i in range(n):\n\n        if (x+v[i][0])**2+(y+v[i][1])**2 < (x-v[i][0])**2+(y-v[i][1])**2:\n            x += v[i][0]\n            y += v[i][1]\n            ans[v[i][2]] = 1\n        else:\n            x -= v[i][0]\n            y -= v[i][1]\n            ans[v[i][2]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n2","output":"nlogn"},{"instruction":"from itertools import combinations\nn,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(2,n+1):\n    for j in combinations(a,i):\n        if max(j)-min(j)>=x and l<=sum(j)<=r:\n            ans+=1\nprint(ans)","output":"np"},{"instruction":"k = 1000001\na = [True] * k\na[0] = a[1] = False\n\nfor i in range(k):\n    if a[i]:\n        for j in range(2*i, k, i):\n            a[j] = False\n\nn = int(input())\nfor i in range(4, n):\n    if not a[i] and not a[n-i]:\n        print(i, n-i)\n        exit()","output":"constant"},{"instruction":"n,k=map(int,input().split())\ns=input();flag=True;lenn=10**10;ans=0\nfor i in range(n):\n  s1=s+s[n-i-1:]*(k-1);cnt=0\n  for i in range(len(s1)-len(s)+1):\n     if s1[i:i+len(s)]==s:cnt+=1\n  if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1)\nprint(ans)","output":"quadratic"},{"instruction":"import sys\n\nlines = sys.stdin.readlines()\n\ndef read_a_num(line):\n    n = int(line.strip())\n    return n\n\ndef read_a_str(line):\n    line = line.strip()\n    return line\n\ndef check_ticket(digits):\n    for target in range(900):\n        seg_i = 0\n        seg_sum = 0\n        next_flag = False\n        for d in digits:\n            int_d = int(d)\n            if int_d > target:\n                next_flag = True\n                break\n            elif seg_sum + int_d > target:\n                if next_flag:\n                    break\n                next_flag = True\n                continue\n            elif int_d == target or seg_sum + int_d == target:\n                seg_i += 1\n                seg_sum = 0\n            else:\n                seg_sum += int_d\n\n        if next_flag:\n            continue\n\n        if seg_i >= 2 and seg_sum == 0:\n            return True\n\n    return False\n\ndigits = read_a_str(lines[1])\nif check_ticket(digits):\n    print(\"yes\")\nelse:\n    print(\"no\")","output":"quadratic"},{"instruction":"import sys\n\nk = int(input())\nd = [0]\nfor i in range(1, 12):\n    d.append((10 ** i - 10 ** (i - 1)) * i + d[i - 1])\n\nfor i in range(1, len(d)):\n    if k <= d[i]:\n        f = d[i - 1]\n        f1 = 10 ** (i - 1)\n\n        print(str(((k - f - 1) \/\/ i) + f1)[(k - f - 1) % i])\n        sys.exit()","output":"logn"},{"instruction":"n=int(input())\nif n%4==2:\n    print('!', '-1')\n    exit()\ndef qry(i):\n    print('?', i+1, flush=True)\n    a=int(input())\n    return a\ndef qry2(i):\n    a=qry(i+n\/\/2)-qry(i)\n    if a==0:\n        print('!', i+1)\n        exit()\n    return a\na=qry2(0)\nlb,rb=1,n\/\/2-1\nwhile lb<=rb:\n    mb=(lb+rb)\/\/2\n    b=qry2(mb)\n    if (a>0)==(b>0):\n        lb=mb+1\n    else:\n        rb=mb-1","output":"logn"},{"instruction":"n,r = map(int,input().split())\nx_coord = list(map(int,input().split()))\nd = {}\nfor i in x_coord:\n    final = r\n    for j in range(i-r,i+r+1):\n        check = d.get(j,[-1,-1])\n        if check[0] > 0:\n            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5\n            final = max(potential,final)\n    for j in range(i-r,i+r+1):\n        d[j] = (i,final)\n    print(final,end = \" \")","output":"quadratic"},{"instruction":"def bin_pow(num, _pow, module):\n    if _pow == 0:\n        return 1\n    if _pow == 1:\n        return num % module\n    if _pow % 2 == 1:\n        return num * bin_pow(num, _pow - 1, module) % module\n    res = bin_pow(num, _pow\/\/2, module)\n    return (res * res) % module\n\nx, k = map(int, input().split())\n\nif x == 0:\n    print(0)\n    exit(0)\n\nmod = 10**9 + 7\n\n__power = bin_pow(2, k, mod)\n\nprint((x* __power * 2 + 1 - __power) % mod)","output":"logn"},{"instruction":"size = int(input())\ns = input()\n\nct = 0\nF = 0\nfor i in range(size-2):\n    if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x':\n        ct += 1\n        F = 1\n\nif F == 0:\n    print(0)\nelse:\n    print(ct)","output":"linear"},{"instruction":"k = int(input())\nk_=k\nca = 9\ndi = 1\ntem = 9\nwhile k_>0:\n    k_-=ca*di\n    ca*=10\n    di+=1\n    tem += ca*di\n    if k_==0:\n        break\ntem -= ca*di\nca=int(ca\/10)\ndi-=1\ntem -= ca*di\nca=int(ca\/10)\nca_=0\nwhile ca>0:\n    ca_+=ca\n    ca= int(ca\/10)\nk -= tem\nre = int((k+di-1)\/\/di)+ca_\nre_= k%di\nif re_==0:\n    l=1\nelse:\n    l = 10**(di-re_)\nre = int(re\/\/l)\nprint(re%10)","output":"logn"},{"instruction":"from sys import stdin\nfrom collections import deque\nn=int(stdin.readline())\ng=dict()\nfor i in range(n-1):\n    a,b=map(int,stdin.readline().strip().split())\n    g.setdefault(a, set()).add(b)\n    g.setdefault(b, set()).add(a)\na=[int(x) for x in stdin.readline().strip().split()]\nans = True\nif n > 1 and a[0] == 1:\n    q=deque()\n    m=[0]*(n+1)\n    q.append(1)\n    m[1]=1\n    right=1\n    while len(q) > 0 and ans:\n        first = q.popleft()\n        cnt = 0\n        for v in g[first]:\n            if m[v] == 0:\n                cnt += 1\n        for i in range(right, right+cnt):\n            if m[a[i]] == 0 and a[i] in g[first]:\n                m[a[i]] = 1\n                q.append(a[i])\n            else:\n                ans = False\n                break\n        right += cnt\nelse:\n    ans = a[0] == 1\nif ans:\n    print(\"Yes\")\nelse:\n    print(\"No\")","output":"linear"},{"instruction":"tam,q = [int(i) for i in input().split()]\nt = input()\ns = t\n\nposi = -1\n\nfor j in range(tam-1):\n    if(t[:j+1] == t[tam - j -1:]):\n        posi = j\n\nadd = t[posi+1:]\n\nfor j in range(q-1):\n    s += add\n\nprint(s)","output":"quadratic"},{"instruction":"def main():\n    n, m, k = map(int, input().split())\n    inf = 1 << 30\n    left = [list(map(int, input().split())) for i in range(n)]\n    down = [list(map(int, input().split())) for i in range(n-1)]\n    if k & 1:\n        for i in range(n):\n            print(*[-1]*m)\n        exit()\n    ans = [[0]*m for i in range(n)]\n    for k in range(1, k\/\/2+1):\n        _ = [[inf]*m for ii in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    _[i][j] = min(_[i][j], ans[i-1][j]+down[i-1][j])\n                if i < n-1:\n                    _[i][j] = min(_[i][j], ans[i+1][j]+down[i][j])\n                if j:\n                    _[i][j] = min(_[i][j], ans[i][j-1]+left[i][j-1])\n                if j < m-1:\n                    _[i][j] = min(_[i][j], ans[i][j+1]+left[i][j])\n        ans = _\n    for i in range(n):\n        for j in range(m):\n            print(ans[i][j]*2, end=' ')\n        print()\n\nif __name__ == '__main__':\n    main()","output":"cubic"},{"instruction":"n=int(input())\narr=list(map(int,input().split()))\nmaxval=max(arr)\nmaxindex=-1\nfor i in range(n):\n\tif(arr[i]==maxval):\n\t\tmaxindex=i\n\t\tbreak\n\nflag=0\ntemp=maxval\nfor i in range(maxindex-1,-1,-1):\n\tif(temp<=arr[i]):\n\t\tflag=1\n\t\tbreak\n\telse:\n\t\ttemp=arr[i]\n\ntemp=maxval\nfor i in range(maxindex+1,n):\n\tif(arr[i]>=temp):\n\t\tflag=1\n\t\tbreak\n\telse:\n\t\ttemp=arr[i]\n\nif(flag==0):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","output":"linear"},{"instruction":"import copy\nlista=[]\nlistb=[]\ntemp=[]\na=int(input())\nflag=0\nmark=0\n\nfor i in range(0,a):\n    str=input()\n    for j in range(0,a):\n        temp.append(str[j])\n    lista.append(temp)\n    temp=[]\n\nfor i in range(0,a):\n    str=input()\n    for j in range(0,a):\n        temp.append(str[j])\n    listb.append(temp)\n    temp=[]\n\nlistacpy =copy.deepcopy(lista)\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\nmark=0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[a-1-j][i]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\n\nmark = 0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[a-1-i][a-1-j]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\n\nmark = 0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[j][a-1-i]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\nmark = 0\n\nlisttemp=copy.deepcopy(lista)\nfor i in range(0,a):\n    for j in range(0,a):\n        lista[i][j]=listtemp[i][a-1-j]\n\nlistacpy =copy.deepcopy(lista)\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\nmark = 0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[a-1-j][i]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\nmark = 0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[a-1-i][a-1-j]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\n\nmark = 0\n\nfor i in range(0,a):\n    for j in range(0,a):\n        listacpy[j][a-1-i]=lista[i][j]\n\nfor i in range(0,a):\n    for j in range(0,a):\n        if(listacpy[i][j]!=listb[i][j]):\n            mark=1\n            break\n    if(mark==1):\n        break\nif(mark==0):\n    flag=1\n\nif(flag==1):\n    print(\"yes\")\nelse:\n    print(\"no\")","output":"quadratic"},{"instruction":"from math import sqrt\n\na, v = map(int, input().split())\nl, d, w = map(int, input().split())\nw = min(v, w)\nlowtime = (v - w) \/ a\nlowdist = v * lowtime - a * lowtime**2 \/ 2\nstartdist = v**2 \/ (2 * a)\nif startdist + lowdist <= d:\n    ans = v \/ a + (d - startdist - lowdist) \/ v + lowtime\nelif w**2 <= 2 * d * a:\n    u = sqrt(a * d + w**2 \/ 2)\n    ans = (2 * u - w) \/ a\nelse:\n    ans = sqrt(2 * d \/ a)\n    w = ans * a\nhightime = (v - w) \/ a\nhighdist = w * hightime + a * hightime**2 \/ 2\nif highdist <= l - d:\n    ans += hightime + (l - d - highdist) \/ v\nelse:\n    disc = sqrt(w**2 + 2 * a * (l - d))\n    ans += (disc - w) \/ a\nprint('%.7f' % ans)","output":"constant"},{"instruction":"import sys\n\ndef rint():\n    return map(int, sys.stdin.readline().split())\n\ndef writable(r, c):\n    if r+2 >= n or c+2 >= m:\n        return False\n    t = set()\n    t.add(cells[r][c])\n    t.add(cells[r][c+1])\n    t.add(cells[r][c+2])\n    t.add(cells[r+1][c])\n    t.add(cells[r+1][c+2])\n    t.add(cells[r+2][c])\n    t.add(cells[r+2][c+1])\n    t.add(cells[r+2][c+2])\n    return not '.' in t\n\ndef fill_ink(r,c):\n    paper[r][c] = \"\n    paper[r][c+1] = \"\n    paper[r][c+2] = \"\n    paper[r+1][c] = \"\n    paper[r+1][c+2] = \"\n    paper[r+2][c] = \"\n    paper[r+2][c+1] = \"\n    paper[r+2][c+2] = \"\n\nn, m = rint()\n\ncells = []\nfor i in range(n):\n    cells.append(input())\n\npaper = [[\".\" for j in range(m)] for i in range(n)]\n\nfor r in range(n):\n    for c in range(m):\n        if writable(r,c) is True:\n            fill_ink(r, c)\n\nfor r in range(n):\n    for c in range(m):\n        if cells[r][c] != paper[r][c]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")","output":"quadratic"},{"instruction":"from collections import *\nn = int(input())\na = list(map(int,input().split()))\nd = Counter(a)\nans = 0\nfor i in range(n):\n    for j in range(31):\n        s = 1<<j\n        s = s-a[i]\n        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):\n            break\n    else:\n        ans+=1\nprint(ans)","output":"nlogn"},{"instruction":"import io, sys, atexit, os\nimport math as ma\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nfrom itertools import combinations\n\ndef li ():\n\treturn list (map (int, input ().split ()))\n\ndef num ():\n\treturn map (int, input ().split ())\n\ndef nu ():\n\treturn int (input ())\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\ndef lcm ( x, y ):\n\tgg = find_gcd (x, y)\n\treturn (x * y \/\/ gg)\n\nmm = 1000000007\nyp = 0\n\ndef isPrime ( n ):\n\n\tif (n <= 1):\n\t\treturn False\n\tif (n <= 3):\n\t\treturn True\n\n\tif (n % 2 == 0 or n % 3 == 0):\n\t\treturn False\n\n\ti = 5\n\twhile (i * i <= n):\n\t\tif (n % i == 0 or n % (i + 2) == 0):\n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef solve ():\n\tt = 1\n\tfor tt in range (t):\n\t\tn,k=num()\n\t\td=ma.sqrt(9+8*(n+k))\n\t\tgp=(-3+d)\/2\n\t\tprint(int(n-gp))\n\nif __name__ == \"__main__\":\n\tsolve ()","output":"logn"},{"instruction":"n = int(input())\nm = int(n**.5)\na = []\n\nfor i in range(0, n, m):\n    for j in range(i, min(i+m, n)):\n        a.append(min(i+m, n)-j + i)\n\nprint(' '.join(str(_) for _ in a))","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\ncnt = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i] > a[j]:\n            cnt += 1\neven = cnt % 2 == 0\nq = int(input())\nans = []\nfor _ in range(q):\n    l, r = map(int, input().split())\n    len = r - l + 1\n    pairs = len * (len-1) \/\/ 2\n    if pairs % 2 == 1:\n        even = not even\n    if even:\n        ans.append('even')\n    else:\n        ans.append('odd')\nprint('\\n'.join(ans))","output":"quadratic"},{"instruction":"if __name__ == '__main__':\n    n, s = map(int, input().split())\n    a = []\n    for _ in range(n):\n        h, m = map(int, input().split())\n        a.append(h * 60 + m)\n    if a[0] != 0 and a[0] > s:\n        print(0, 0)\n    else:\n        a.append(a[n - 1] + 2 * s + 3)\n        for i in range(1, n + 1):\n            if a[i] - (a[i - 1] + 2 + s) >= s:\n                print((a[i - 1] + s + 1)\/\/60, (a[i - 1] + s + 1)%60)\n                break","output":"linear"},{"instruction":"x, y, z, t1, t2, t3 = map(int, input().split())\nd1 = abs(x - y) * t1\nd2 = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3\nif d2 <= d1:\n    print('YES')\nelse:\n    print('NO')","output":"constant"},{"instruction":"n, m = map(int, input().split())\na = list(map(int, input().split()))\nh = max(a)\na.sort()\na.reverse()\na.append(0)\nans = sum(a)\nfor i in range(n):\n    if a[i + 1] >= a[i]:\n        a[i + 1] = a[i] - 1\n    ans -= max(a[i] - a[i + 1], 1)\nprint(ans)","output":"nlogn"},{"instruction":"import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\ncount = [[0] * m for _ in range(m)]\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        count[c1][c2] += 1\n\nsum_of_subset = [[0] * (1 << m) for _ in range(m)]\nfor i in range(m):\n    for j in range(1 << m):\n        if j == 0:\n            continue\n        lsb = j & -j\n        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n\nadj_in_subset = [0] * (1 << m)\nfor i in range(1 << m):\n    for j in range(m):\n        if i & (1 << j):\n            adj_in_subset[i] += sum_of_subset[j][i]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        not_i = ((1 << m) - 1) ^ i\n        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)\nprint(dp[-1])","output":"np"},{"instruction":"class MinIdx_Segtree:\n    def __init__(self, N, A):\n        self.n = N\n        self.INF = int(1e9)\n        self.A = A\n        while (self.n & (self.n - 1)) != 0:\n            self.A.append(self.INF)\n            self.n += 1\n        self.tree = [0] * (2 * self.n)\n        self.build()\n\n    def build(self):\n        for i in range(self.n):\n            self.tree[self.n + i] = i\n        for j in range(self.n - 1, 0, -1):\n            a = self.tree[j << 1]\n            b = self.tree[(j << 1) + 1]\n            if self.A[a] <= self.A[b]:\n                self.tree[j] = a\n            else:\n                self.tree[j] = b\n\n    def update(self, i, val):\n        self.A[i] = val\n        j = (self.n + i) >> 1\n        while j >= 1:\n            a = self.tree[j << 1]\n            b = self.tree[(j << 1) + 1]\n            if self.A[a] <= self.A[b]:\n                self.tree[j] = a\n            else:\n                self.tree[j] = b\n            j >>= 1\n\n    def query(self, ql, qh):\n        return self._query(1, 0, self.n - 1, ql, qh)\n\n    def _query(self, node, l, h, ql, qh):\n        if ql > h or qh < l:\n            return self.INF\n        if l >= ql and h <= qh:\n            return self.tree[node]\n        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)\n        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)\n        if a == self.INF:\n            return b\n        if b == self.INF:\n            return a\n        return a if self.A[a] <= self.A[b] else b\n\nclass Solution:\n    def getMaxArea(self, heights, l, r, st):\n        if l > r:\n            return 0\n        if l == r:\n            return heights[l]\n        minIdx = st.query(l, r)\n        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),\n                       self.getMaxArea(heights, minIdx + 1, r, st)),\n                   (r - l + 1) * heights[minIdx])\n\n    def largestRectangleArea(self, heights):\n        n = len(heights)\n        st = MinIdx_Segtree(n, heights)\n        return self.getMaxArea(heights, 0, n - 1, st)","output":"nlogn"},{"instruction":"n, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nret = 0\nfor i in range(m):\n\tcur = 0\n\tfor j in range(i, n):\n\t\tif j % m == i:\n\t\t\tcur = max(0, cur)\n\t\t\tcur -= k\n\t\tcur += a[j]\n\t\tret = max(ret, cur)\nprint(ret)","output":"quadratic"},{"instruction":"n=int(input())\ns=list(input())\nt=list(input())\nd={}\nans=0\nx,y=-1,-1\nfor i in range(n):\n\tif s[i]!=t[i]:\n\t\td[(s[i],t[i])]=i\n\t\tans+=1\nl=[chr(i+97) for i in range(26)]\nfor i in l:\n\tfor j in l:\n\t\tif (i,j) in d and (j,i) in d:\n\t\t\tans-=2\n\t\t\tx=d[(i,j)]+1\n\t\t\ty=d[(j,i)]+1\n\t\t\tbreak\n\tif x!=-1:\n\t\tbreak\nif x==y==-1:\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tfor k in l:\n\t\t\t\tif (i,j) in d and (j,k) in d:\n\t\t\t\t\tans-=1\n\t\t\t\t\tx=d[(i,j)]+1\n\t\t\t\t\ty=d[(j,k)]+1\n\t\t\t\t\tbreak\n\t\tif x!=-1:\n\t\t\tbreak\nprint(ans)\nprint(x,y)","output":"linear"},{"instruction":"import sys\n\nMOD = 10**9 + 7\n\nx,k = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = x*pow(2,k+1,MOD) % MOD\nb = (a - pow(2,k,MOD) + 1) % MOD\nprint(b if x != 0 else 0)","output":"logn"},{"instruction":"n, m, k, l = map(int, input().split())\nif m > n:\n    print(-1)\nelif l + k > n:\n    print(-1)\nelse:\n    s = (l + k) \/\/ m + bool((l + k) % m)\n    if s * m > n:\n        print(-1)\n    else:\n        print(s)","output":"constant"},{"instruction":"import sys\nI=sys.stdin.readlines()\nN,M,K=map(int,I[0].split())\nS=[I[i+1][:-1] for i in range(N)]\nD=dict()\nfor i in range(N):\n  D[S[i]]=i\nT=[I[i+N+1].split() for i in range(M)]\nfor i in range(M):\n  T[i][1]=int(T[i][1])-1\nG=[[] for i in range(N)]\nC=[0]*N\nfor i in range(M):\n  for j in range(K):\n    if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]:\n      print('NO')\n      exit()\n  for j in range(1<<K):\n    t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)])\n    x=D.get(t,-1)\n    if x!=-1 and x!=T[i][1]:\n      G[T[i][1]].append(x)\n      C[x]+=1\nP=[]\nQ=[]\nF=[1]*N\nfor i in range(N):\n  if C[i]==0 and F[i]:\n    Q.append(i)\n  while len(Q):\n    v=Q.pop()\n    F[v]=0\n    P.append(v+1)\n    for i in range(len(G[v])):\n      C[G[v][i]]-=1\n      if C[G[v][i]]==0:\n        Q.append(G[v][i])\nif len(P)==N:\n  print('YES')\n  print(*P)\nelse:\n  print('NO')","output":"np"},{"instruction":"from collections import deque\nfrom copy import deepcopy\n\nm,n,k  = map(int,input().split())\n\nhorizon = []\nfor i in range(m):\n    horizon.append( list(map(int,input().split()))  )\n\nvertical = []\nfor i in range(m-1):\n    vertical.append( list(map(int,input().split()))  )\n\nif k%2==1:\n    ans = [-1]*n\n    for i in range(m):\n        print(\" \".join(map(str,ans)))\n    exit()\n\ndirec = [[0,-1],[0,1],[1,0],[-1,0]]\n\nans = [[0 for j in range(n)] for i in range(m)]\n\nfor t in range(k\/\/2):\n    tempans = deepcopy(ans)\n\n    for i in range(m):\n        for j in range(n):\n            ans[i][j] = 2147483647\n            for d in range(4):\n                neighi = i + direc[d][0]\n                neighj = j + direc[d][1]\n                if neighi<0 or neighi>=m or neighj<0 or neighj>=n: continue\n                base = tempans[neighi][neighj]\n                if d==0: base += 2 * horizon[neighi][neighj]\n                if d==1: base += 2 * horizon[neighi][neighj-1]\n                if d==2: base += 2 * vertical[neighi-1][neighj]\n                if d==3: base += 2 * vertical[neighi][neighj]\n                ans[i][j] = min(ans[i][j],base)\n\nfor ele in ans:\n    print(\" \".join(map(str,ele)))","output":"cubic"},{"instruction":"print('4'*1131+'\\n'+'5'*1130+'6')","output":"constant"},{"instruction":"n=int(input())\nprint(2*n**2-2*n+1)","output":"constant"},{"instruction":"from itertools import combinations\nfrom sys import stdin\ninput = stdin.readline\nintin = lambda: map(int, input().split())\n\nn, l, r, x = intin()\n*a, = intin()\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))","output":"np"},{"instruction":"n=int(input())\nw=[int(k) for k in input().split()]\nc={w[j]:j+1 for j in range(n)}\n\nres=0\nfor j in range(1, n+1):\n    if w[j-1]==j:\n        pass\n    else:\n        res+=1\n        y=w[j-1]\n        w[j-1]=j\n        w[c[j]-1]=y\n        r=c[j]\n        c[j]=j\n        c[y]=r\nif n%2==0:\n    if res%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")\nelse:\n    if res%2:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")","output":"nlogn"},{"instruction":"n, k = [int(i) for i in input().split()]\n\nmid = n\/\/2\nleftside = 1\nrightside = n\n\ncandies = n-mid\n\nwhile mid * (mid + 1)\/\/2 - candies != k:\n    if k > mid * (mid + 1)\/\/2 - candies:\n        leftside = mid + 1\n    else:\n        rightside = mid\n\n    mid = (leftside + rightside)\/\/2\n    candies = n-mid\nprint(candies)","output":"logn"},{"instruction":"T=int(input())\nfor _ in range(T):\n    n,k=map(int,input().split())\n    s=input()\n    rq1=''\n    rq2=''\n    rq3=''\n\n    for i in range(k):\n        if(i%3==0):\n            rq1=rq1+'R'\n            rq2=rq2+'G'\n            rq3=rq3+'B'\n        elif(i%3==1):\n            rq1=rq1+'G'\n            rq2=rq2+'B'\n            rq3=rq3+'R'\n        elif(i%3==2):\n            rq1=rq1+'B'\n            rq2=rq2+'R'\n            rq3=rq3+'G'\n\n    ans=1000000000000000000\n\n    for i in range(0,len(s)-k+1):\n\n        a1=0\n        a2=0\n        a3=0\n\n        for j in range(i,i+k):\n\n            if(s[j]!=rq1[j-i]):\n                a1+=1\n            if(s[j]!=rq2[j-i]):\n                a2+=1\n            if(s[j]!=rq3[j-i]):\n                a3+=1\n\n        ans=min(ans,min(a1,a2,a3))\n\n    print(ans)","output":"quadratic"},{"instruction":"from bisect import bisect_left\n\nif __name__ == \"__main__\":\n    n, m = map(int, raw_input().split())\n    verticals = [int(raw_input()) for _ in range(n)]\n    h = [map(int, raw_input().split()) for _ in range(m)]\n    horizontals = [t[1] for t in h if t[0] == 1]\n\n    verticals.sort()\n    horizontals.sort()\n    verticals.append(10**9)\n    min_blockers = n + m\n    for i, v in enumerate(verticals):\n        cur_blockers = len(horizontals) - bisect_left(horizontals, v) + i\n        min_blockers = min(min_blockers, cur_blockers)\n\n    print(min_blockers)","output":"nlogn"},{"instruction":"from collections import *\nfrom itertools import *\nfrom random import  *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom sys import *\nfrom re import *\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\nz, zz = input, lambda: list(map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\ndef output(answer): stdout.write(str(answer))\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\nn,l,r,x = zzz()\narr = zzz()\ncnt=0\nfor i in range(2,2**n):\n    b = bin(i)[2:]\n    b='0'*(n-len(b))+b\n    s,mx,mi =0, float('-inf'),float('inf')\n    for j in range(n):\n        if b[j]=='1':\n            mx=max(mx,arr[j])\n            mi=min(mi,arr[j])\n            s+=arr[j]\n    if s>=l and s<=r and mx-mi>=x:\n        cnt+=1\nprint(cnt)","output":"np"},{"instruction":"import collections\nfrom functools import cmp_to_key\n\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))\n\nimport bisect\n\nbase = 10**9  + 7\ndef get2k(k) :\n    f = 2\n    b = 1\n    r = 1\n    while k>=b:\n        if k &b >0:\n            r = r*f % base\n        b*=2\n        f = f*f % base\n    return r\n\nx, k = getIntList()\nif x ==0:\n    print(0)\n    sys.exit()\nt2k = get2k(k)\n\nr = x *   t2k *2 - t2k + 1\nr = r% base\nprint(r)","output":"logn"},{"instruction":"x,k=map(int,input().split())\nprint(((pow(2,k,1000000007)*((2*x-1)%1000000007))%1000000007+1)%1000000007 if x!=0 else 0)","output":"logn"},{"instruction":"import sys\n\ninput = sys.stdin.readline\n\ndef intersection(segs):\n    end = float('inf')\n    start = - float('inf')\n    for l, r in segs:\n        end = min(end, r)\n        start = max(start, l)\n    return start, end\n\ndef solve():\n    n = int(input())\n    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]\n    starts = {}\n    ends = {}\n    x = intersection(segs)\n    for l, r in segs:\n        if r in starts:\n            starts[r] = max(starts[r], l)\n        else:\n            starts[r] = l\n        if l in ends:\n            ends[l] = min(ends[l], r)\n        else:\n            ends[l] = r\n\n    b = segs.copy()\n    b.remove((x[0], ends[x[0]]))\n    y = intersection(b)\n\n    c = segs.copy()\n    c.remove((starts[x[1]], x[1]))\n    z = intersection(c)\n\n    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)\n\nprint(solve())","output":"linear"},{"instruction":"D = False\n\ndef hash(r,c):\n    return str(r) + \"-\" + str(c)\n\ndef sol():\n    R, C = [int(x) for x in input().split(\" \")]\n    m = []\n    count = 0\n    for _ in range(R):\n        line = input()\n        m.append(line)\n        count += line.count(\"\n\n    if D: print(\"Count:\", count)\n\n    lookup = {}\n    for r in range(1, R-1):\n        for c in range(1, C-1):\n\n            if D: print(\"  row,col:\", r, c)\n\n            offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n            lst = []\n            fail = False\n\n            for o in offset:\n\n                cell = (r + o[0], c + o[1])\n                if D: print(\"  cell:\", cell, m[cell[0]][cell[1]])\n                h = hash(cell[0], cell[1])\n\n                if m[cell[0]][cell[1]] == \"\n                    if (not h in lookup):\n                        lst.append(h)\n\n                else:\n                    fail = True\n                    break\n\n            if not fail:\n                for item in lst:\n                    lookup[item] = True\n                count -= len(lst)\n\n    return \"YES\" if count == 0 else \"NO\"\n\nans = sol()\nprint(ans)","output":"quadratic"},{"instruction":"n=int(input());print(sum(i for i in range(1+n%2!=1,n+1,2)))","output":"linear"},{"instruction":"import sys\ninput = sys.stdin.readline\n\nok = set()\nfor i in range(114514):\n    x = i * i\n    ok.add(2 * x)\n    ok.add(4 * x)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = \"YES\" if n in ok else \"NO\"\n    print(ans)","output":"constant"},{"instruction":"from collections import defaultdict\n\ndef E1():\n\n    mod = 10 ** 9 + 7\n\n    comb = [[1]]\n    for i in range(1, 1010):\n        x = [1]\n        for j in range(1, i):\n            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)\n        x.append(1)\n        comb.append(x)\n\n    dp = [1]\n    for i in range(1, 1010):\n        r = 0\n        for k in range(i):\n            r += dp[k] * comb[i - 1][k]\n            r %= mod\n        dp.append(r)\n\n    m, n = map(int, input().split())\n\n    ns = [0 for __ in range(m)]\n    for j in range(n):\n        temp = input()\n        s = [int(i) for i in temp]\n        for i in range(m):\n            ns[i] |= s[i] << j\n\n    dd = defaultdict(int)\n    for e in ns:\n        dd[e] += 1\n\n    ans = 1\n    for b in dd.values():\n        ans = ans * dp[b] % mod\n\n    print(ans)\n\nif __name__=='__main__':\n    E1()","output":"quadratic"},{"instruction":"from heapq import *\n\nn,k=map(int,input().split())\np=[int(X) for X in input().split()]\nc=[int(x) for x in input().split()]\np=[[p[i],c[i],i] for i in range(n)]\np.sort()\nj=0\nan=[0]*n\nan[p[0][2]]=p[0][1]\nz=[]\nheapify(z)\n\nfor i in range(1,n):\n\n     s=p[i][1]\n     if p[i][0]!=p[i-1][0]:\n         while (j<i):\n\n             heappush(z,(-1)*p[j][1])\n             j+=1\n\n     tt=[]\n     for __ in range(k):\n\n         tt.append(heappop(z))\n         if not z:\n             break\n\n     for v in tt:\n         s+=abs(v)\n         heappush(z, v )\n\n     an[p[i][2]]=s\n\nprint(*an)","output":"nlogn"},{"instruction":"n = int(input())\nx, y = map(int, input().split())\n\ndef d(a, b):\n    return a + b\n\nif d(x-1, y-1) <= d(n-x, n-y):\n    print(\"White\")\nelse:\n    print(\"Black\")","output":"constant"},{"instruction":"class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2147483648\n        MAX = 2147483647\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x \/ 10)\n\n            if res > MAX \/\/ 10 or (res == MAX \/\/ 10 and digit > MAX % 10):\n                return 0\n            if res < MIN \/\/ 10 or (res == MIN \/\/ 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res","output":"constant"},{"instruction":"n = int(input())\na, edge = [0], []\nlast, sum, ans = 0, 0, 0\nfor i in map(int, input().split()) :\n    a.append(i)\n    sum += i\nfor i in range(1, n + 1) :\n    if(a[i] == 1) :\n        last = i\na[last] = 0\nfor i in range(1, n + 1) :\n    if(a[i] > 1) :\n        if(last) :\n            edge.append([last, i])\n            ans += 1\n        last = i\nfor i in range(1, n + 1) :\n    if(a[i] == 1 and last) :\n        edge.append([last, i])\n        last = 0\n        a[i] = 0\n        ans += 1\nfor i in range(1, n + 1) :\n    for j in range(1, n + 1) :\n        if(a[j] == 1 and a[i] > 2) :\n            edge.append([i, j])\n            a[i] -= 1\n            a[j] -= 1\nif(len(edge) != n - 1) :\n    print(\"NO\")\nelse :\n    print(\"YES\", ans)\n    print(len(edge))\n    for i in edge :\n        print(i[0], i[1])","output":"quadratic"},{"instruction":"x=list(map(int,input().split()))\npos=x[1]\nn=x[0]\nl=x[2]\nr=x[3]\nstep=0\nif pos<l :\n    step=l-pos+1\n\n    if r< n :\n        step+=r-l+1\nelif pos>r:\n    step=pos-r+1\n\n    if l> 1 :\n        step+=r-l+1\nelse:\n    if l>1 and n>r:\n        step+=min(pos-l,r-pos)+r-l+2\n    elif l==1 and n>r:\n        step=r-pos+1\n    elif l>1 and n==r:\n        step+=pos-l+1\n    else:\n        step=0\n\nprint(step)","output":"constant"},{"instruction":"def solution():\n\n    n = int(input())\n    segments = []\n    for i,_ in enumerate(range(n)):\n        x,y = input().split(\" \")\n        segments.append((int(x), int(y), i+1))\n\n    segments = sorted(segments, key=lambda x: (x[0], -x[1]))\n\n    for i,seg in enumerate(segments):\n        j = i+1\n        if j >= n:\n            print(\"-1 -1\")\n            return\n\n        while segments[j][1] <= seg[1]:\n            print(\"{} {}\".format(segments[j][2], seg[2]))\n            return\n\n    print(\"-1 -1\")\n    return\n\nsolution()","output":"nlogn"},{"instruction":"s = input().split()\nb = []\nb.append((s[0][1], int(s[0][0])))\nb.append((s[1][1], int(s[1][0])))\nb.append((s[2][1], int(s[2][0])))\nb.sort()\nif (b[0][0] == b[1][0] and b[1][0] == b[2][0]):\n    if (b[0] == b[1] and b[1] == b[2]):\n        print(0)\n    elif (b[0][1] + 1 == b[1][1] and b[1][1] + 1 == b[2][1]):\n        print(0)\n    elif (b[0] == b[1]):\n        print(1)\n    elif (b[1] == b[2]):\n        print(1)\n    elif b[0][1] + 1 == b[1][1]:\n        print(1)\n    elif b[0][1] + 2 == b[1][1]:\n        print(1)\n    elif b[1][1] + 1 == b[2][1]:\n        print(1)\n    elif b[1][1] + 2 == b[2][1]:\n        print(1)\n    elif b[0][1] + 1 == b[2][1]:\n        print(1)\n    elif b[0][1] + 2 == b[2][1]:\n        print(1)\n    else:\n        print(2)\nelif (b[0][0] != b[1][0] and b[1][0] != b[2][0] and b[2][0] != b[0][0]):\n    print(2)\nelif b[0][0] == b[1][0]:\n    if b[0] == b[1]:\n        print(1)\n    elif b[0][1] + 1 == b[1][1]:\n        print(1)\n    elif b[0][1] + 2 == b[1][1]:\n        print(1)\n    else:\n        print(2)\nelif b[1][0] == b[2][0]:\n    if (b[1] == b[2]):\n        print(1)\n    elif b[1][1] + 1 == b[2][1]:\n        print(1)\n    elif b[1][1] + 2 == b[2][1]:\n        print(1)\n    else:\n        print(2)\nelse:\n    print(2)","output":"nlogn"},{"instruction":"import sys\ndef fastio():\n    from io import StringIO\n    from atexit import register\n    global input\n    sys.stdin = StringIO(sys.stdin.read())\n    input = lambda : sys.stdin.readline().rstrip('\\r\\n')\n    sys.stdout = StringIO()\n    register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\n\ndef debug(*var, sep = ' ', end = '\\n'):\n    print(*var, file=sys.stderr, end = end, sep = sep)\n\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\nn, l, r, x = I()\na = I()\nans = 0\nfor i in range(1, 2 ** n):\n    if i & (i - 1) == 0:\n        continue\n    mn, mx, total = INF, -INF, 0\n    for j in range(n):\n        if (i >> j) & 1:\n            mn = min(mn, a[j])\n            mx = max(mx, a[j])\n            total += a[j]\n    if l <= total <= r and mx - mn >= x:\n        ans += 1\nprint(ans)","output":"np"},{"instruction":"t = int(input())\n\ndef sol(n, k):\n    p = 1\n    q = 1\n    acc = 0\n    while n > 0 and k >= p:\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += q*(4**n-1)\/\/3\n        if k <= acc:\n            return n\n        p = 2*p+1\n        q = 2*q+3\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)","output":"logn"},{"instruction":"n = int(input())\ns = input()\n\nfor sum in range(9 * n + 1):\n    cnt = 0\n    cursum = 0\n    for i in s:\n        cursum += int(i)\n        if cursum == sum:\n            cnt += 1\n            cursum = 0\n\n    if cursum == 0 and cnt > 1:\n        print(\"YES\")\n        exit(0)\n\nprint(\"NO\")","output":"quadratic"},{"instruction":"from collections import deque\nn=int(input())\nvisited=[False for i in range(n+2)]\ndp=[-1 for i in range(n+2)]\nl=[[] for i in range(n+2)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=deque(map(int,input().split()))\nb.popleft()\ns=deque([1])\nans=\"Yes\"\nvisited[1]=True\nwhile len(b)>0 and len(s)>0:\n    aux=0\n    for i in l[s[0]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(aux):\n        x=b.popleft()\n        if dp[x]==1:\n            s.append(x)\n            dp[x]=-1\n        else:\n            ans=\"No\"\n            b=[]\n            break\n    s.popleft()\nprint(ans)","output":"nlogn"},{"instruction":"def main():\n\n    a = input()\n    b = input()\n    if len(a) < len(b):\n        a = list(a)\n        a.sort(reverse=True)\n        print(''.join(a))\n        return\n\n    def solve(i, a: list):\n        if i == len(b):\n            return ''\n        if a.__contains__(b[i]):\n            a.remove(b[i])\n            suf = solve(i+1, a)\n            if suf is not None:\n                return b[i] + suf\n            a.append(b[i])\n        best = ''\n        for c in a:\n            if c < b[i] and c > best:\n                best = c\n        if best == '':\n            return None\n        a.remove(best)\n        a.sort(reverse=True)\n        return best + ''.join(a)\n\n    a = list(a)\n    print(solve(0, a))\n\nmain()","output":"cubic"},{"instruction":"i=int(input())\nd=i%2+8;print(d,i-d)","output":"constant"},{"instruction":"MOD = 998244353\ndef power(x, n) :\n    ans = 1\n    while (n) :\n        if ((n & 1) == 1) :\n            ans = ans * x % MOD\n        x = x * x % MOD\n        n = n \/\/ 2\n    return ans\n\nn = int(input())\na = list(map(int, input().split()))\nb = [0 for i in range(n + 1)]\n\ndef add(x, v) :\n    while (x <= n) :\n        b[x] = b[x] + v\n        x = x + (x & -x)\ndef get(x) :\n    ans = 0\n    while (x) :\n        ans = ans + b[x]\n        x = x - (x & -x)\n    return ans\n\nanss = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        add(a[i], 1)\n        anss = anss + get(n) - get(a[i])\n\nanss = anss % MOD\ntotal = 0\n\nsur = [0] + [1 for i in range(n)]\nfor i in range(n) :\n    if (a[i] == -1) :\n        total = total + 1\n    else :\n        sur[a[i]] = 0\n\nif (total == 0) :\n    print(anss)\n    exit(0)\nfor i in range(1, n + 1) :\n    sur[i] = sur[i] + sur[i - 1]\n\ndead = 0\n\nansa = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        ansa = ansa + sur[a[i]] * (total - dead) + (sur[n] - sur[a[i]]) * dead\n    else :\n        dead = dead + 1\n\nans = (ansa * 4 + anss * 4 * total + total * total * (total - 1)) % MOD\nans = (ans * power(4 * total, MOD - 2)) % MOD\nprint(ans)","output":"nlogn"},{"instruction":"import sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])","output":"nlogn"},{"instruction":"def reach_max(n, k):\n    return n * k + 1 - n * (n + 1) \/\/ 2\n\nn, k = map(int, input().split())\n\nif n == 1:\n    print(0)\n    exit()\n\nlo, hi = 1, k - 1\n\nif n > reach_max(hi, k):\n    print(-1)\n    exit()\n\nwhile lo < hi:\n    mid = (lo + hi) \/\/ 2\n    if reach_max(mid, k) < n:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)","output":"logn"},{"instruction":"import sys\n\nR, G, B = list(map(int, input().split()))\nr = sorted([int(x) for x in input().split()], reverse = True)\ng = sorted([int(x) for x in input().split()], reverse = True)\nb = sorted([int(x) for x in input().split()], reverse = True)\n\nans = 0\n\ndp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\n\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n            if  j<G and k<B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n            if i<R and k<B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])\n            ans = max(ans, dp[i][j][k])\nprint(ans)","output":"cubic"},{"instruction":"import math\nt=1\nwhile t:\n        t-=1\n        n=int(input())\n        m=int(input())\n        if(n>=27):\n                print(m)\n        else:\n                print(m%(pow(2,n)))","output":"constant"}]